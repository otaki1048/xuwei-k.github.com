<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>example/scalaz/example/WordCount.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz.example

<span class="comment">/**
 * Character/Line/Word Count from &quot;The Essense of the Iterator Pattern&quot;.
 *
 * @see [[http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf]]
 */</span>
<span class="keyword">object</span> <a title="object scalaz.example.WordCount" id="33481">WordCount</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="keyword">def</span> <a title="(args: Array[String])Unit" id="811178">main</a><span class="delimiter">(</span><a title="Array[String]" id="811181">args</a>: <span title="Array[String]">Array</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#811179" title="=&gt; Unit">wordCount</a>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="=&gt; Unit" id="811179">wordCount</a> <span class="delimiter">{</span>
    <span class="keyword">import</span> scalaz.typelevel.<span class="delimiter">{</span>AppFunc, AppFuncU, HList, HNil<span class="delimiter">}</span>,
      scalaz.typelevel.syntax.<a href="../../../typelevel/scalaz/typelevel/syntax/Syntax.scala.html#38968" title="object scalaz.typelevel.syntax.package.hlist">hlist</a>._,
      scalaz.<a href="../../../core/scalaz/package.scala.html#38710" title="object scalaz.package.State">State</a>._, scalaz.std.<a href="../../../core/scalaz/std/AnyVal.scala.html#26609" title="object scalaz.std.anyVal">anyVal</a>._, scalaz.std.<a href="../../../core/scalaz/std/List.scala.html#26285" title="object scalaz.std.list">list</a>._,
      scalaz.std.<a href="../../../core/scalaz/std/AnyVal.scala.html#26261" title="object scalaz.std.boolean">boolean</a>.test, scalaz.syntax.<a href="../../../core/scalaz/syntax/Syntax.scala.html#38782" title="object scalaz.syntax.package.equal">equal</a>._

    <span class="keyword">val</span> <a title="List[Char]" id="811193">text</a> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;the cat in the hat\n sat on the mat\n&quot;</span>.<span title="=&gt; List[Char]">toList</span>

    <span class="comment">// To count characters, treat Int as monoidal applicative</span>
    <span class="keyword">val</span> <a title="scalaz.typelevel.Func[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int]" id="811194">countChar</a> = <a href="../../../typelevel/scalaz/typelevel/Func.scala.html#811275" title="(f: Char =&gt; Int)(implicit F0: scalaz.Unapply[scalaz.Applicative,Int])scalaz.typelevel.Func[F0.M,scalaz.Applicative,Char,F0.A]">AppFuncU</a> <a href="../../../core/scalaz/Unapply.scala.html#354741" title="(implicit TC0: scalaz.Applicative[[α]Int])scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}" class="delimiter">{</a> <span class="delimiter">(</span>c: <span title="Char">Char</span><span class="delimiter">)</span> =&gt; <span title="Int(1)" class="int">1</span> <span class="delimiter">}</span>

    <span class="comment">// To count lines, treat Int as monoidal applicative</span>
    <span class="keyword">val</span> <a title="scalaz.typelevel.Func[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int]" id="811195">countLine</a> = <a href="../../../typelevel/scalaz/typelevel/Func.scala.html#811275" title="(f: Char =&gt; Int)(implicit F0: scalaz.Unapply[scalaz.Applicative,Int])scalaz.typelevel.Func[F0.M,scalaz.Applicative,Char,F0.A]">AppFuncU</a> <a href="../../../core/scalaz/Unapply.scala.html#354741" title="(implicit TC0: scalaz.Applicative[[α]Int])scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}" class="delimiter">{</a> <span class="delimiter">(</span>c: <span title="Char">Char</span><span class="delimiter">)</span> =&gt; <a href="../../../core/scalaz/std/AnyVal.scala.html#166112" title="(p: Boolean)Int">test</a><span class="delimiter">(</span><a href="../../../core/scalaz/syntax/EqualSyntax.scala.html#53447" title="(v: Char)(implicit F0: scalaz.Equal[Char])java.lang.Object with scalaz.syntax.EqualOps[Char]">c</a> <a href="../../../core/scalaz/syntax/EqualSyntax.scala.html#159163" title="(other: Char)Boolean">===</a> <span title="Char(\'\\n\')" class="char">'\n'</span><span class="delimiter">)</span> <span class="delimiter">}</span>

    <span class="comment">// To count words, we need to detect transitions from whitespace to non-whitespace.</span>
    <span class="keyword">val</span> <a title="scalaz.typelevel.Func[[α]scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.Applicative,Char,Int]" id="811196">countWord</a> = <a href="../../../typelevel/scalaz/typelevel/Func.scala.html#811275" title="(f: Char =&gt; scalaz.StateT[scalaz.Id.Id,Boolean,Int])(implicit F0: scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]])scalaz.typelevel.Func[F0.M,scalaz.Applicative,Char,F0.A]">AppFuncU</a> <a href="../../../core/scalaz/Unapply.scala.html#354810" title="(implicit TC0: scalaz.Applicative[[β]scalaz.StateT[scalaz.Id.Id,Boolean,β]])scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}" class="delimiter">{</a> <span class="delimiter">(</span>c: <span title="Char">Char</span><span class="delimiter">)</span> =&gt;
      <span class="keyword">for</span> <span class="delimiter">{</span>
        <a title="Boolean" id="813042">x</a> &lt;- <a href="../../../core/scalaz/State.scala.html#53410" title="[S]=&gt; scalaz.package.State[S,S]">get</a><a href="../../../core/scalaz/StateT.scala.html#86105" title="(f: Boolean =&gt; (Boolean, Boolean))(implicit F: scalaz.Functor[scalaz.Id.Id])scalaz.StateT[scalaz.Id.Id,Boolean,(Boolean, Boolean)]" class="delimiter">[</a><span title="Boolean">Boolean</span><span class="delimiter">]</span>
        <span class="keyword">val</span> <a title="Boolean" id="813043">y</a> = <a href="../../../core/scalaz/syntax/EqualSyntax.scala.html#53447" title="(v: Char)(implicit F0: scalaz.Equal[Char])java.lang.Object with scalaz.syntax.EqualOps[Char]">c</a> <a href="../../../core/scalaz/syntax/EqualSyntax.scala.html#159165" title="(other: Char)Boolean">=/=</a> <span title="Char(\' \')" class="char">' '</span>
        <a title="Unit" id="813052">_</a> &lt;- <a href="../../../core/scalaz/State.scala.html#53418" title="(s: Boolean)scalaz.package.State[Boolean,Unit]">put</a><a href="../../../core/scalaz/StateT.scala.html#86105" title="(f: Unit =&gt; Int)(implicit F: scalaz.Functor[scalaz.Id.Id])scalaz.StateT[scalaz.Id.Id,Boolean,Int]" class="delimiter">(</a><a href="#813043" title="Boolean">y</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">yield</span> <a href="../../../core/scalaz/std/AnyVal.scala.html#166112" title="(p: Boolean)Int">test</a><span class="delimiter">(</span><a href="#813043" title="Boolean">y</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#813042" title="Boolean">x</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <a href="../../../typelevel/scalaz/typelevel/Func.scala.html#811290" title="(g: scalaz.typelevel.Func[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Int,Int])scalaz.typelevel.Func[[α]scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.Applicative,Char,Int]">@&gt;&gt;&gt;</a> <a href="../../../typelevel/scalaz/typelevel/Func.scala.html#811275" title="(f: Int =&gt; Int)(implicit F0: scalaz.Unapply[scalaz.Applicative,Int])scalaz.typelevel.Func[F0.M,scalaz.Applicative,Int,F0.A]">AppFuncU</a> <a href="../../../core/scalaz/Unapply.scala.html#354741" title="(implicit TC0: scalaz.Applicative[[α]Int])scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}" class="delimiter">{</a> <span class="delimiter">(</span>x: <span title="Int">Int</span><span class="delimiter">)</span> =&gt; <a href="#814082" title="Int">x</a> <span class="delimiter">}</span>

    <span class="comment">// Compose applicative functions in parallel</span>
    <span class="keyword">val</span> <a title="scalaz.typelevel.HListFunc[scalaz.typelevel.TCCons[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.typelevel.TCCons[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.typelevel.TCCons[[α]scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.typelevel.TCNil]]],scalaz.Applicative,Char,Int]" id="811197">countAll</a> = <a href="#811194" title="scalaz.typelevel.Func[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int]">countChar</a> <a href="../../../typelevel/scalaz/typelevel/Func.scala.html#815589" title="(g: scalaz.typelevel.Func[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int])scalaz.typelevel.HListFunc[scalaz.typelevel.TCCons[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.typelevel.TCCons[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.typelevel.TCCons[[α]scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.typelevel.TCNil]]],scalaz.Applicative,Char,Int]">::</a> <a href="#811195" title="scalaz.typelevel.Func[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int]">countLine</a> <a href="../../../typelevel/scalaz/typelevel/Func.scala.html#815589" title="(g: scalaz.typelevel.Func[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int])scalaz.typelevel.HListFunc[scalaz.typelevel.TCCons[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.typelevel.TCCons[[α]scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.typelevel.TCNil]],scalaz.Applicative,Char,Int]">::</a> <span class="delimiter">(</span><a href="#811196" title="scalaz.typelevel.Func[[α]scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.Applicative,Char,Int]">countWord</a> <a href="../../../typelevel/scalaz/typelevel/Func.scala.html#811319" title="(tail: scalaz.typelevel.HListFunc[scalaz.typelevel.TCNil,scalaz.Applicative,Char,Int])scalaz.typelevel.HListFunc[scalaz.typelevel.TCCons[[α]scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.typelevel.TCNil],scalaz.Applicative,Char,Int]">consA</a> <a href="../../../typelevel/scalaz/typelevel/Func.scala.html#37704" title="object scalaz.typelevel.AppFunc">AppFunc</a>.<a href="../../../typelevel/scalaz/typelevel/Func.scala.html#815606" title="scalaz.typelevel.HListFunc[scalaz.typelevel.TCNil,scalaz.Applicative,Char,Int]">HNil</a><span class="delimiter">)</span>
    
    <span class="comment">// ... and execute them in a single traversal </span>
    <span class="keyword">val</span> <a href="#811198" title="scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]" id="811199">charCount</a> <a href="../../../typelevel/scalaz/typelevel/package.scala.html#815849" title="(scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]], scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]], scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]])">::</a> <a href="#811198" title="scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]" id="811200">lineCount</a> <a href="../../../typelevel/scalaz/typelevel/package.scala.html#815849" title="(list: scalaz.typelevel.package.HCons[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]],scalaz.typelevel.TCCons[[α]scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.typelevel.TCNil]#Product[List[Int]]])Option[(scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]], scalaz.typelevel.TCCons[[α]scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.typelevel.TCNil]#Product[List[Int]])]">::</a>  <a href="#811198" title="scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]]" id="811201">wordCountState</a> <a href="../../../typelevel/scalaz/typelevel/package.scala.html#815849" title="(list: scalaz.typelevel.package.HCons[scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]],scalaz.typelevel.TCNil#Product[List[Int]]])Option[(scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]], scalaz.typelevel.TCNil#Product[List[Int]])]">::</a> <a href="../../../typelevel/scalaz/typelevel/package.scala.html#38945" title="=&gt; scalaz.typelevel.package.HNil">HNil</a> = <a href="#811197" title="scalaz.typelevel.HListFunc[scalaz.typelevel.TCCons[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.typelevel.TCCons[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.typelevel.TCCons[[α]scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.typelevel.TCNil]]],scalaz.Applicative,Char,Int]">countAll</a> <a href="../../../typelevel/scalaz/typelevel/Func.scala.html#811325" title="(value: List[Char])(implicit G: scalaz.Traverse[List], implicit ev: =:=[scalaz.Applicative[scalaz.typelevel.TCCons[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.typelevel.TCCons[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.typelevel.TCCons[[α]scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.typelevel.TCNil]]]#Product],scalaz.Applicative[scalaz.typelevel.TCCons[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.typelevel.TCCons[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.typelevel.TCCons[[α]scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.typelevel.TCNil]]]#Product]])scalaz.typelevel.TCCons[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.typelevel.TCCons[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.typelevel.TCCons[[α]scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.typelevel.TCNil]]]#Product[List[Int]]">traverse</a> <a href="#811193" title="List[Char]">text</a>
    <span class="keyword">val</span> <a title="scalaz.Id.Id[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]]" id="811202">wordCount</a> = <a href="#811201" title="scalaz.Unapply[scalaz.Applicative,scalaz.StateT[scalaz.Id.Id,Boolean,Int]]{type M[X] = scalaz.StateT[scalaz.Id.Id,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]]">wordCountState</a>.<a href="../../../core/scalaz/StateT.scala.html#86101" title="(initial: Boolean)(implicit F: scalaz.Functor[scalaz.Id.Id])scalaz.Id.Id[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]]">eval</a><a href="../../../core/scalaz/package.scala.html#38664" title="=&gt; scalaz.Traverse[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]" class="delimiter">(</a><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

    <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%d\t%d\t%d\t&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#811200" title="scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]">lineCount</a>, <a href="#811202" title="scalaz.Id.Id[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]]">wordCount</a>, <a href="#811199" title="scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]">charCount</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// 2	9	35</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>