<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>typelevel/scalaz/typelevel/HList.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz
<span class="keyword">package</span> typelevel

<span class="keyword">import</span> <a href="../../../core/scalaz/Kleisli.scala.html#23337" title="object scalaz.Kleisli">Kleisli</a>._

<span class="keyword">import</span> <a href="../../../core/scalaz/Id.scala.html#11478" title="object scalaz.Id">Id</a>._

<span class="keyword">object</span> <a title="object scalaz.typelevel.HLists" id="37917">HLists</a> <span title="ScalaObject" class="delimiter">{</span>

  <span class="keyword">import</span> <a href="#458653" title="object scalaz.typelevel.HLists.KleisliProof">KleisliProof</a>._

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class IdOps[T &lt;: scalaz.typelevel.package.HList] extends java.lang.Object with ScalaObject" id="458650">IdOps</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="458651">T</a> &lt;: HList<span class="delimiter">]</span><a href="#458650" title="ScalaObject" class="delimiter">(</a><a title="T" id="1366935">list</a>: <a href="#458651" title="T">T</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/** Prepends a value to this list. */</span>
    <span class="keyword">def</span> <a title="[A](elem: A)scalaz.typelevel.package.HCons[A,T]" id="458686">::</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="458688">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="458705">elem</a>: <a href="#458688" title="A">A</a><span class="delimiter">)</span>: <a href="GenericList.scala.html#37907" title="scalaz.typelevel.package.HCons[A,T]">HCons</a><span class="delimiter">[</span>A, T<span class="delimiter">]</span> = <a href="GenericList.scala.html#459025" title="[M[_], H, T &lt;: scalaz.typelevel.GenericList[M]](head: M[H], tail: T)scalaz.typelevel.GenericCons[M,H,T]">GenericCons</a><span title="(head: scalaz.Id.Id[A], tail: T)scalaz.typelevel.GenericCons[scalaz.Id.Id,A,T]" class="delimiter">[</span><a href="../../../core/scalaz/Id.scala.html#42334" title="scalaz.Id.Id">Id</a>, <a href="#458688" title="A">A</a>, <a href="#458651" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#458705" title="A">elem</a>, <a href="#1366935" title="T">list</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Composes a list of functions of the shape `A =&gt; F[B]` using
     * [[scalaz.Kleisli]]. This operation can be seen as a fold with `compose`.
     */</span>
    <span class="keyword">def</span> <a title="[M[+_], H, R](implicit ev: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,R,T], implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]" id="458689">compose</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="458693">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="706769">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="458694">H</a>, <a title="&gt;: Nothing &lt;: Any" id="458695">R</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,R,T]" id="706767">ev</a>: <a href="#458655" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,R,T]">KleisliProof</a><span class="delimiter">[</span>Forward, M, H, R, T<span class="delimiter">]</span>, <a title="scalaz.Bind[M]" id="706768">b</a>: <a href="../../../core/scalaz/Bind.scala.html#22460" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../core/scalaz/Kleisli.scala.html#23336" title="scalaz.Kleisli[M,H,R]">Kleisli</a><span class="delimiter">[</span>M, H, R<span class="delimiter">]</span> =
      <a href="#703458" title="(list: T)(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]">ev</a><a href="#706768" title="scalaz.Bind[M]" class="delimiter">(</a><a href="#1366935" title="T">list</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Composes a list of functions of the shape `A =&gt; F[B]` using
     * [[scalaz.Kleisli]]. This operation can be seen as a fold with `andThen`.
     */</span>
    <span class="keyword">def</span> <a title="[M[+_], H, R](implicit ev: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,H,R,T], implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]" id="458696">reverseCompose</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="458700">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="702786">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="458701">H</a>, <a title="&gt;: Nothing &lt;: Any" id="458702">R</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,H,R,T]" id="702784">ev</a>: <a href="#458655" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,H,R,T]">KleisliProof</a><span class="delimiter">[</span>Reverse, M, H, R, T<span class="delimiter">]</span>, <a title="scalaz.Bind[M]" id="702785">b</a>: <a href="../../../core/scalaz/Bind.scala.html#22460" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../core/scalaz/Kleisli.scala.html#23336" title="scalaz.Kleisli[M,H,R]">Kleisli</a><span class="delimiter">[</span>M, H, R<span class="delimiter">]</span> =
      <a href="#703458" title="(list: T)(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]">ev</a><a href="#702785" title="scalaz.Bind[M]" class="delimiter">(</a><a href="#1366935" title="T">list</a><span class="delimiter">)</span>

  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait KleisliProof0 extends java.lang.Object with ScalaObject" id="458652">KleisliProof0</a> <span title="ScalaObject" class="delimiter">{</span>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[D &lt;: scalaz.typelevel.HLists.KleisliProof.Direction, H, R]=&gt; scalaz.typelevel.HLists.KleisliProof[D,scalaz.Id.Id,H,R,scalaz.typelevel.package.HCons[H =&gt; scalaz.Id.Id[R],scalaz.typelevel.package.HNil]]" id="458707">baseComposeProof</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scalaz.typelevel.HLists.KleisliProof.Direction" id="458711">D</a> &lt;: Direction, <a title="&gt;: Nothing &lt;: Any" id="458712">H</a>, <a title="&gt;: Nothing &lt;: Any" id="458713">R</a><span class="delimiter">]</span> =
      <a href="#458736" title="[D &lt;: scalaz.typelevel.HLists.KleisliProof.Direction, M[+_], H, R]=&gt; scalaz.typelevel.HLists.KleisliProof[D,M,H,R,scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]]">baseKleisliProof</a><span title="scalaz.typelevel.HLists.KleisliProof[D,scalaz.Id.Id,H,R,scalaz.typelevel.package.HCons[H =&gt; scalaz.Id.Id[R],scalaz.typelevel.package.HNil]]" class="delimiter">[</span><a href="#458711" title="D">D</a>, <a href="../../../core/scalaz/Id.scala.html#42334" title="scalaz.Id.Id">Id</a>, <a href="#458712" title="H">H</a>, <a href="#458713" title="R">R</a><span class="delimiter">]</span>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[OH, IH, R, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,IH,R,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,OH,R,scalaz.typelevel.package.HCons[OH =&gt; scalaz.Id.Id[IH],T]]" id="458714">consComposeRevProof</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="458719">OH</a>, <a title="&gt;: Nothing &lt;: Any" id="458720">IH</a>, <a title="&gt;: Nothing &lt;: Any" id="458721">R</a>, <a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="458722">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,IH,R,T]" id="703841">proof</a>: <a href="#458655" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,IH,R,T]">KleisliProof</a><span class="delimiter">[</span>Reverse, Id, IH, R, T<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#458745" title="[M[+_], OH, IH, R, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,IH,R,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,OH,R,scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]]">consKleisliRevProof</a><span title="(implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,IH,R,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,OH,R,scalaz.typelevel.package.HCons[OH =&gt; scalaz.Id.Id[IH],T]]" class="delimiter">[</span><a href="../../../core/scalaz/Id.scala.html#42334" title="scalaz.Id.Id">Id</a>, <a href="#458719" title="OH">OH</a>, <a href="#458720" title="IH">IH</a>, <a href="#458721" title="R">R</a>, <a href="#458722" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#703841" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,IH,R,T]">proof</a><span class="delimiter">)</span>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[H, OR, IR, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,IR,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,OR,scalaz.typelevel.package.HCons[IR =&gt; scalaz.Id.Id[OR],T]]" id="458723">consComposeProof</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="458728">H</a>, <a title="&gt;: Nothing &lt;: Any" id="458729">OR</a>, <a title="&gt;: Nothing &lt;: Any" id="458730">IR</a>, <a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="458731">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,IR,T]" id="703835">proof</a>: <a href="#458655" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,IR,T]">KleisliProof</a><span class="delimiter">[</span>Forward, Id, H, IR, T<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#458756" title="[M[+_], H, OR, IR, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,IR,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,OR,scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]]">consKleisliProof</a><span title="(implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,IR,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,OR,scalaz.typelevel.package.HCons[IR =&gt; scalaz.Id.Id[OR],T]]" class="delimiter">[</span><a href="../../../core/scalaz/Id.scala.html#42334" title="scalaz.Id.Id">Id</a>, <a href="#458728" title="H">H</a>, <a href="#458729" title="OR">OR</a>, <a href="#458730" title="IR">IR</a>, <a href="#458731" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#703835" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,IR,T]">proof</a><span class="delimiter">)</span>

  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object scalaz.typelevel.HLists.KleisliProof" id="458653">KleisliProof</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#458652" title="scalaz.typelevel.HLists.KleisliProof0">KleisliProof0</a> <span class="delimiter">{</span>

    <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait Direction extends java.lang.Object" id="458733">Direction</a>
    <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Forward extends java.lang.Object with scalaz.typelevel.HLists.KleisliProof.Direction with ScalaObject" id="458734">Forward</a> <a href="#458734" title="ScalaObject" class="keyword">extends</a> <a href="#458733" title="scalaz.typelevel.HLists.KleisliProof.Direction">Direction</a>
    <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Reverse extends java.lang.Object with scalaz.typelevel.HLists.KleisliProof.Direction with ScalaObject" id="458735">Reverse</a> <a href="#458735" title="ScalaObject" class="keyword">extends</a> <a href="#458733" title="scalaz.typelevel.HLists.KleisliProof.Direction">Direction</a>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[D &lt;: scalaz.typelevel.HLists.KleisliProof.Direction, M[+_], H, R]=&gt; scalaz.typelevel.HLists.KleisliProof[D,M,H,R,scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]]" id="458736">baseKleisliProof</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scalaz.typelevel.HLists.KleisliProof.Direction" id="458741">D</a> &lt;: Direction, <a title="[+_]&gt;: Nothing &lt;: Any" id="458742">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="703827">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="458743">H</a>, <a title="&gt;: Nothing &lt;: Any" id="458744">R</a><span class="delimiter">]</span>: <a href="#458655" title="scalaz.typelevel.HLists.KleisliProof[D,M,H,R,scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]]">KleisliProof</a><span class="delimiter">[</span>D, M, H, R, HCons<span class="delimiter">[</span>H =&gt; M<span class="delimiter">[</span>R<span class="delimiter">]</span>, HNil<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#1367453" title="java.lang.Object with scalaz.typelevel.HLists.KleisliProof[D,M,H,R,scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.typelevel.HLists.KleisliProof[D,M,H,R,scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]]" id="1367453">KleisliProof</a><span class="delimiter">[</span>D, M, H, R, HCons<span class="delimiter">[</span>H =&gt; M<span class="delimiter">[</span>R<span class="delimiter">]</span>, HNil<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(list: scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil])(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]" id="1367457">apply</a><span class="delimiter">(</span><a title="scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]" id="1367458">list</a>: <a href="GenericList.scala.html#37907" title="scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]">HCons</a><span class="delimiter">[</span>H =&gt; M<span class="delimiter">[</span>R<span class="delimiter">]</span>, HNil<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bind[M]" id="1367459">b</a>: <a href="../../../core/scalaz/Bind.scala.html#22460" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="../../../core/scalaz/Kleisli.scala.html#52667" title="(f: H =&gt; M[R])scalaz.Kleisli[M,H,R]">kleisli</a><span class="delimiter">(</span><a href="#1367458" title="scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]">list</a>.<a href="GenericList.scala.html#458590" title="=&gt; H =&gt; M[R]">head</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[M[+_], OH, IH, R, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,IH,R,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,OH,R,scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]]" id="458745">consKleisliRevProof</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="458751">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="703822">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="458752">OH</a>, <a title="&gt;: Nothing &lt;: Any" id="458753">IH</a>, <a title="&gt;: Nothing &lt;: Any" id="458754">R</a>, <a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="458755">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span>
      <span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,IH,R,T]" id="703821">proof</a>: <a href="#458655" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,IH,R,T]">KleisliProof</a><span class="delimiter">[</span>Reverse, M, IH, R, T<span class="delimiter">]</span>
    <span class="delimiter">)</span>: <a href="#458655" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,OH,R,scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]]">KleisliProof</a><span class="delimiter">[</span>Reverse, M, OH, R, HCons<span class="delimiter">[</span>OH =&gt; M<span class="delimiter">[</span>IH<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#1367482" title="java.lang.Object with scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,OH,R,scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,OH,R,scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]]" id="1367482">KleisliProof</a><span class="delimiter">[</span>Reverse, M, OH, R, HCons<span class="delimiter">[</span>OH =&gt; M<span class="delimiter">[</span>IH<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(list: scalaz.typelevel.package.HCons[OH =&gt; M[IH],T])(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,OH,R]" id="1367486">apply</a><span class="delimiter">(</span><a title="scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]" id="1367487">list</a>: <a href="GenericList.scala.html#37907" title="scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]">HCons</a><span class="delimiter">[</span>OH =&gt; M<span class="delimiter">[</span>IH<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bind[M]" id="1367488">b</a>: <a href="../../../core/scalaz/Bind.scala.html#22460" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="../../../core/scalaz/Kleisli.scala.html#52667" title="(f: OH =&gt; M[IH])scalaz.Kleisli[M,OH,IH]">kleisli</a><span class="delimiter">(</span><a href="#1367487" title="scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]">list</a>.<a href="GenericList.scala.html#458590" title="=&gt; OH =&gt; M[IH]">head</a><span class="delimiter">)</span> <a href="../../../core/scalaz/Kleisli.scala.html#113120" title="(k: scalaz.Kleisli[M,IH,R])(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,OH,R]">&gt;=&gt;</a> <a href="#703458" title="(list: T)(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,IH,R]">proof</a><a href="#1367488" title="scalaz.Bind[M]" class="delimiter">(</a><a href="#1367487" title="scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]">list</a>.<a href="GenericList.scala.html#458592" title="=&gt; T">tail</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[M[+_], H, OR, IR, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,IR,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,OR,scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]]" id="458756">consKleisliProof</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="458762">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="703815">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="458763">H</a>, <a title="&gt;: Nothing &lt;: Any" id="458764">OR</a>, <a title="&gt;: Nothing &lt;: Any" id="458765">IR</a>, <a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="458766">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span>
      <span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,IR,T]" id="703814">proof</a>: <a href="#458655" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,IR,T]">KleisliProof</a><span class="delimiter">[</span>Forward, M, H, IR, T<span class="delimiter">]</span>
    <span class="delimiter">)</span>: <a href="#458655" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,OR,scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]]">KleisliProof</a><span class="delimiter">[</span>Forward, M, H, OR, HCons<span class="delimiter">[</span>IR =&gt; M<span class="delimiter">[</span>OR<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#1367561" title="java.lang.Object with scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,OR,scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,OR,scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]]" id="1367561">KleisliProof</a><span class="delimiter">[</span>Forward, M, H, OR, HCons<span class="delimiter">[</span>IR =&gt; M<span class="delimiter">[</span>OR<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(list: scalaz.typelevel.package.HCons[IR =&gt; M[OR],T])(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,OR]" id="1367565">apply</a><span class="delimiter">(</span><a title="scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]" id="1367566">list</a>: <a href="GenericList.scala.html#37907" title="scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]">HCons</a><span class="delimiter">[</span>IR =&gt; M<span class="delimiter">[</span>OR<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bind[M]" id="1367567">b</a>: <a href="../../../core/scalaz/Bind.scala.html#22460" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="../../../core/scalaz/Kleisli.scala.html#52667" title="(f: IR =&gt; M[OR])scalaz.Kleisli[M,IR,OR]">kleisli</a><span class="delimiter">(</span><a href="#1367566" title="scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]">list</a>.<a href="GenericList.scala.html#458590" title="=&gt; IR =&gt; M[OR]">head</a><span class="delimiter">)</span> <a href="../../../core/scalaz/Kleisli.scala.html#113132" title="(k: scalaz.Kleisli[M,H,IR])(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,OR]">&lt;=&lt;</a> <a href="#703458" title="(list: T)(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,IR]">proof</a><a href="#1367567" title="scalaz.Bind[M]" class="delimiter">(</a><a href="#1367566" title="scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]">list</a>.<a href="GenericList.scala.html#458592" title="=&gt; T">tail</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

  <span class="delimiter">}</span>

  @annotation.implicitNotFound<span class="delimiter">(</span>msg = <span class="string">&quot;Could not compose HList ${T} in ${D} direction&quot;</span><span class="delimiter">)</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait KleisliProof[D &lt;: scalaz.typelevel.HLists.KleisliProof.Direction, M[+_], H, R, T &lt;: scalaz.typelevel.package.HList] extends java.lang.Object" id="458655">KleisliProof</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scalaz.typelevel.HLists.KleisliProof.Direction" id="458656">D</a> &lt;: Direction, <a title="[+_]&gt;: Nothing &lt;: Any" id="458657">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="1367639">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="458658">H</a>, <a title="&gt;: Nothing &lt;: Any" id="458659">R</a>, <a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="458660">T</a> &lt;: HList<span class="delimiter">]</span> <span title="java.lang.Object" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(list: T)(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]" id="703458">apply</a><span class="delimiter">(</span><a title="T" id="1367396">list</a>: <a href="#458660" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bind[M]" id="1367397">b</a>: <a href="../../../core/scalaz/Bind.scala.html#22460" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../core/scalaz/Kleisli.scala.html#23336" title="scalaz.Kleisli[M,H,R]">Kleisli</a><span class="delimiter">[</span>M, H, R<span class="delimiter">]</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>


<span class="comment">// vim: expandtab:ts=2:sw=2</span>

        </pre>
    </body>
</html>