<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/scalaz/package.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * '''Scalaz''': Type classes and pure functional data structures for Scala.
 *
 * This package, [[scalaz]], contains:
 *  - type class definitions
 *  - data structures
 *  - related functions
 *
 * Type class instances and other functions related to the Scala and Java standard library
 * are in scalaz.[[scalaz.std]]
 *
 * Implicit conversions and wrapper classes that provide a more convenient syntax for accessing
 * the functionality of the library are in scalaz.[[scalaz.syntax]].
 *
 * '''Type Classes Index'''
 *
 *  - [[scalaz.Semigroup]]
 *  - [[scalaz.Monoid]] extends [[scalaz.Semigroup]]
 *  - [[scalaz.Group]] extends [[scalaz.Monoid]]
 *  - [[scalaz.Equal]]
 *  - [[scalaz.Length]]
 *  - [[scalaz.Show]]
 *  - [[scalaz.Order]] extends [[scalaz.Equal]]
 *
 *  - [[scalaz.MetricSpace]]
 *  - [[scalaz.Plus]]
 *  - [[scalaz.Each]]
 *  - [[scalaz.Index]]
 *  - [[scalaz.Functor]]
 *  - [[scalaz.Pointed]] extends [[scalaz.Functor]]
 *  - [[scalaz.Contravariant]]
 *  - [[scalaz.Copointed]] extends [[scalaz.Functor]]
 *  - [[scalaz.Apply]] extends [[scalaz.Functor]]
 *  - [[scalaz.Applicative]] extends [[scalaz.Apply]] with [[scalaz.Pointed]]
 *  - [[scalaz.Bind]] extends [[scalaz.Apply]]
 *  - [[scalaz.Monad]] extends [[scalaz.Applicative]] with [[scalaz.Bind]]
 *  - [[scalaz.Cojoin]]
 *  - [[scalaz.Cobind]]
 *  - [[scalaz.Comonad]] extends [[scalaz.Copointed]] with [[scalaz.Cojoin]] with [[scalaz.Cobind]]
 *  - [[scalaz.PlusEmpty]] extends [[scalaz.Plus]]
 *  - [[scalaz.ApplicativePlus]] extends [[scalaz.Applicative]] with [[scalaz.PlusEmpty]]
 *  - [[scalaz.MonadPlus]] extends [[scalaz.Monad]] with [[scalaz.ApplicativePlus]]
 *  - [[scalaz.Foldable]]
 *  - [[scalaz.Traverse]] extends [[scalaz.Functor]] with [[scalaz.Foldable]]
 *
 *  - [[scalaz.Bifunctor]]
 *  - [[scalaz.Bitraverse]] extends [[scalaz.Bifunctor]]
 *  - [[scalaz.ArrId]]
 *  - [[scalaz.Compose]]
 *  - [[scalaz.Category]] extends [[scalaz.ArrId]] with [[scalaz.Compose]]
 *  - [[scalaz.Arrow]] extends [[scalaz.Category]]
 *
 *  '''Data Structures Index'''
 *  - [[scalaz.Validation]] Represent computations that may succeed or fail, accumulating multiple errors.
 *  - [[scalaz.NonEmptyList]] A list containing at least one element.
 *  - [[scalaz.DList]] A difference list, supporting efficient append and prepend.
 *  - [[scalaz.EphemeralStream]] A stream that holds weak references to its elements, and recomputes them if needed
 *    if reclaimed by the garbage collector.
 *  - [[scalaz.Heap]] A priority queue, implemented with bootstrapped skew binomial heaps.
 *  - [[scalaz.Endo]] Represents functions from `A =&gt; A`.
 *  - [[scalaz.FingerTree]] A tree containing elements at it's leaves, and measures at the nodes. Can be adapted to
 *    various purposes by choosing a different measure, for example [[scalaz.IndSeq]] and [[scalaz.OrdSeq]].
 *  - [[scalaz.LensT]] Composable, functional alternative to getters and setters
 *  - [[scalaz.Tree]] A multiway tree. Each node contains a single element, and a `Stream` of sub-trees.
 *  - [[scalaz.TreeLoc]] A cursor over a [[scalaz.Tree]].
 *  - [[scalaz.Zipper]] A functional cursor over a List.
 *
 *  - [[scalaz.Kleisli]] Represents a function `A =&gt; M[B]`, allowing chaining. Also known, and aliased, as `scalaz.ReaderT`.
 *  - [[scalaz.StateT]] Computations that modify state.
 *  - [[scalaz.WriterT]] Computations that log a value
 *  - [[scalaz.OptionT]] Represents computations of type `F[Option[A]]`
 *  - [[scalaz.EitherT]] Represents computations of type `F[A \/ B]`
 */</span>
<span class="keyword">package</span> <span class="keyword">object</span> <a title="object scalaz.package" id="12885">scalaz</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="keyword">import</span> <a href="Id.scala.html#11478" title="object scalaz.Id">Id</a>._

  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="package extends scalaz.Traverse[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]" id="38664">idInstance</a>: <a href="#42340" title="package extends scalaz.Traverse[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]">Traverse</a><span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Each<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Monad<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Comonad<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Cojoin<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Distributive<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Zip<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Unzip<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Cozip<span class="delimiter">[</span>Id<span class="delimiter">]</span> = <a href="Id.scala.html#11478" title="object scalaz.Id">Id</a>.<a href="Id.scala.html#42337" title="=&gt; scalaz.Traverse[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]">id</a>

  <span class="keyword">type</span> <a title="package[T] extends AnyRef" id="38666">Tagged</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38667">T</a><span class="delimiter">]</span> = <a href="#64283" title="package extends AnyRef" class="delimiter">{</a><span class="keyword">type</span> Tag = T<span class="delimiter">}</span>

  <span class="comment">/**
   * Tag a type `T` with `Tag`. The resulting type is a subtype of `T`.
   *
   * The resulting type is used to discriminate between type class instances.
   *
   * @see [[scalaz.Tag]] and [[scalaz.Tags]]
   *
   * Credit to Miles Sabin for the idea.
   */</span>
  <span class="keyword">type</span> <a title="package[T, Tag] extends T with scalaz.package.Tagged[Tag]" id="38668">@@</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38669">T</a>, <a title="&gt;: Nothing &lt;: Any" id="38670">Tag</a><span class="delimiter">]</span> = <a href="#64288" title="package extends T with scalaz.package.Tagged[Tag]">T</a> <span class="keyword">with</span> Tagged<span class="delimiter">[</span>Tag<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[-F[_], +G[_]]scalaz.NaturalTransformation[F,G]" id="38671">~&gt;</a><span class="delimiter">[</span>-<a title="[_]&gt;: Nothing &lt;: Any" id="38672">F</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="146542">_</a><span class="delimiter">]</span>, +<a title="[_]&gt;: Nothing &lt;: Any" id="38673">G</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="146543">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="NaturalTransformation.scala.html#16919" title="scalaz.NaturalTransformation[F,G]">NaturalTransformation</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[+F[_], -G[_]]scalaz.NaturalTransformation[G,F]" id="38674">&lt;~</a><span class="delimiter">[</span>+<a title="[_]&gt;: Nothing &lt;: Any" id="38675">F</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="368566">_</a><span class="delimiter">]</span>, -<a title="[_]&gt;: Nothing &lt;: Any" id="38676">G</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="368567">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="NaturalTransformation.scala.html#16919" title="scalaz.NaturalTransformation[G,F]">NaturalTransformation</a><span class="delimiter">[</span>G, F<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[-F[_,_], +G[_,_]]scalaz.BiNaturalTransformation[F,G]" id="38677">~~&gt;</a><span class="delimiter">[</span>-<a title="[_, _]&gt;: Nothing &lt;: Any" id="38678">F</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="293472">_</a>,<a title="&gt;: Nothing &lt;: Any" id="293473">_</a><span class="delimiter">]</span>, +<a title="[_, _]&gt;: Nothing &lt;: Any" id="38679">G</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="293474">_</a>,<a title="&gt;: Nothing &lt;: Any" id="293475">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="NaturalTransformation.scala.html#17522" title="scalaz.BiNaturalTransformation[F,G]">BiNaturalTransformation</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="Nothing" id="38680">⊥</a> = <span title="Nothing">Nothing</span>
  <span class="keyword">type</span> <a title="Any" id="38681">⊤</a> = <span title="Any">Any</span>

  <span class="keyword">type</span> <a title="[G[_], F[_]]scalaz.MonadPartialOrder[G,F]" id="38682">|&gt;=|</a><span class="delimiter">[</span><a title="[_]&gt;: Nothing &lt;: Any" id="38683">G</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="368568">_</a><span class="delimiter">]</span>, <a title="[_]&gt;: Nothing &lt;: Any" id="38684">F</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="368569">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="MonadTrans.scala.html#16727" title="scalaz.MonadPartialOrder[G,F]">MonadPartialOrder</a><span class="delimiter">[</span>G, F<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[F[+_], E, +A]scalaz.Kleisli[F,E,A]" id="38685">ReaderT</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="38686">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="114474">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="38687">E</a>, +<a title="&gt;: Nothing &lt;: Any" id="38688">A</a><span class="delimiter">]</span> = <a href="Kleisli.scala.html#23336" title="scalaz.Kleisli[F,E,A]">Kleisli</a><span class="delimiter">[</span>F, E, A<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[E, A]scalaz.Kleisli[Option,E,A]" id="38689">=?&gt;</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38690">E</a>, <a title="&gt;: Nothing &lt;: Any" id="38691">A</a><span class="delimiter">]</span> = <a href="Kleisli.scala.html#23336" title="scalaz.Kleisli[Option,E,A]">Kleisli</a><span class="delimiter">[</span>Option, E, A<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[E, +A]scalaz.package.ReaderT[scalaz.Id.Id,E,A]" id="38692">Reader</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38693">E</a>, +<a title="&gt;: Nothing &lt;: Any" id="38694">A</a><span class="delimiter">]</span> = <a href="Kleisli.scala.html#23336" title="scalaz.package.ReaderT[scalaz.Id.Id,E,A]">ReaderT</a><span class="delimiter">[</span>Id, E, A<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[+W, +A]scalaz.WriterT[scalaz.Id.Id,W,A]" id="38695">Writer</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="38696">W</a>, +<a title="&gt;: Nothing &lt;: Any" id="38697">A</a><span class="delimiter">]</span> = <a href="WriterT.scala.html#12023" title="scalaz.WriterT[scalaz.Id.Id,W,A]">WriterT</a><span class="delimiter">[</span>Id, W, A<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[+W, +A]scalaz.UnwriterT[scalaz.Id.Id,W,A]" id="38698">Unwriter</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="38699">W</a>, +<a title="&gt;: Nothing &lt;: Any" id="38700">A</a><span class="delimiter">]</span> = <a href="UnwriterT.scala.html#15791" title="scalaz.UnwriterT[scalaz.Id.Id,W,A]">UnwriterT</a><span class="delimiter">[</span>Id, W, A<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="object scalaz.package.Reader" id="38701">Reader</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[E, A](f: E =&gt; A)scalaz.package.Reader[E,A]" id="114476">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="114479">E</a>, <a title="&gt;: Nothing &lt;: Any" id="114480">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="E =&gt; A" id="114481">f</a>: E =&gt; A<span class="delimiter">)</span>: <a href="Kleisli.scala.html#23336" title="scalaz.package.Reader[E,A]">Reader</a><span class="delimiter">[</span>E, A<span class="delimiter">]</span> = <a href="Kleisli.scala.html#52694" title="[M[+_], A, B](f: A =&gt; M[B])scalaz.Kleisli[M,A,B]">Kleisli</a><span title="(f: E =&gt; scalaz.Id.Id[A])scalaz.Kleisli[scalaz.Id.Id,E,A]" class="delimiter">[</span><a href="Id.scala.html#42334" title="scalaz.Id.Id">Id</a>, <a href="#114479" title="E">E</a>, <a href="#114480" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#114481" title="E =&gt; A">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object scalaz.package.Writer" id="38703">Writer</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[W, A](w: W, a: A)scalaz.WriterT[scalaz.Id.Id,W,A]" id="114491">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="114494">W</a>, <a title="&gt;: Nothing &lt;: Any" id="114495">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="W" id="114496">w</a>: <a href="#114494" title="W">W</a>, <a title="A" id="114497">a</a>: <a href="#114495" title="A">A</a><span class="delimiter">)</span>: <a href="WriterT.scala.html#12023" title="scalaz.WriterT[scalaz.Id.Id,W,A]">WriterT</a><span class="delimiter">[</span>Id, W, A<span class="delimiter">]</span> = <a href="WriterT.scala.html#111811" title="[F[+_], W, A](v: F[(W, A)])scalaz.WriterT[F,W,A]">WriterT</a><span title="(v: (W, A))scalaz.WriterT[scalaz.Id.Id,W,A]" class="delimiter">[</span><a href="Id.scala.html#42334" title="scalaz.Id.Id">Id</a>, <a href="#114494" title="W">W</a>, <a href="#114495" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="(_1: W, _2: A)(W, A)" class="delimiter">(</span><a href="#114496" title="W">w</a>, <a href="#114497" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object scalaz.package.Unwriter" id="38705">Unwriter</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[U, A](u: U, a: A)scalaz.UnwriterT[scalaz.Id.Id,U,A]" id="360607">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="360610">U</a>, <a title="&gt;: Nothing &lt;: Any" id="360611">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="U" id="360612">u</a>: <a href="#360610" title="U">U</a>, <a title="A" id="360613">a</a>: <a href="#360611" title="A">A</a><span class="delimiter">)</span>: <a href="UnwriterT.scala.html#15791" title="scalaz.UnwriterT[scalaz.Id.Id,U,A]">UnwriterT</a><span class="delimiter">[</span>Id, U, A<span class="delimiter">]</span> = <a href="UnwriterT.scala.html#356771" title="[F[+_], W, A](v: F[(W, A)])scalaz.UnwriterT[F,W,A]">UnwriterT</a><span title="(v: (U, A))scalaz.UnwriterT[scalaz.Id.Id,U,A]" class="delimiter">[</span><a href="Id.scala.html#42334" title="scalaz.Id.Id">Id</a>, <a href="#360610" title="U">U</a>, <a href="#360611" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="(_1: U, _2: A)(U, A)" class="delimiter">(</span><a href="#360612" title="U">u</a>, <a href="#360613" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A state transition, representing a function `S =&gt; (A, S)`. */</span>
  <span class="keyword">type</span> <a title="[S, +A]scalaz.StateT[scalaz.Id.Id,S,A]" id="38707">State</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38708">S</a>, +<a title="&gt;: Nothing &lt;: Any" id="38709">A</a><span class="delimiter">]</span> = <a href="StateT.scala.html#11753" title="scalaz.StateT[scalaz.Id.Id,S,A]">StateT</a><span class="delimiter">[</span>Id, S, A<span class="delimiter">]</span>

  <span class="comment">// important to define here, rather than at the top-level, to avoid Scala 2.9.2 bug</span>
  <span class="keyword">object</span> <a title="object scalaz.package.State" id="38710">State</a> <span title="ScalaObject" class="keyword">extends</span> <a href="State.scala.html#18767" title="scalaz.StateFunctions">StateFunctions</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[S, A](f: S =&gt; (S, A))scalaz.package.State[S,A]" id="86133">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="86136">S</a>, <a title="&gt;: Nothing &lt;: Any" id="86137">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S =&gt; (S, A)" id="86138">f</a>: S =&gt; <span class="delimiter">(</span>S, A<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="StateT.scala.html#11753" title="scalaz.package.State[S,A]">State</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> = <a href="#368589" title="java.lang.Object with scalaz.StateT[scalaz.Id.Id,S,A]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.StateT[scalaz.Id.Id,S,A]" id="368589">StateT</a><span class="delimiter">[</span>Id, S, A<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(s: S)(S, A)" id="368593">apply</a><span class="delimiter">(</span><a title="S" id="368594">s</a>: <a href="#86136" title="S">S</a><span class="delimiter">)</span> = <a href="#86138" title="(v1: S)(S, A)">f</a><span class="delimiter">(</span><a href="#368594" title="S">s</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[A, B]scalaz.StoreT[scalaz.Id.Id,A,B]" id="38712">Store</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38713">A</a>, <a title="&gt;: Nothing &lt;: Any" id="38714">B</a><span class="delimiter">]</span> = <a href="StoreT.scala.html#20783" title="scalaz.StoreT[scalaz.Id.Id,A,B]">StoreT</a><span class="delimiter">[</span>Id, A, B<span class="delimiter">]</span>
  <span class="comment">// flipped</span>
  <span class="keyword">type</span> <a title="[A, B]scalaz.package.Store[B,A]" id="38715">|--&gt;</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38716">A</a>, <a title="&gt;: Nothing &lt;: Any" id="38717">B</a><span class="delimiter">]</span> = <a href="StoreT.scala.html#20783" title="scalaz.package.Store[B,A]">Store</a><span class="delimiter">[</span>B, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="object scalaz.package.Store" id="38718">Store</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B](f: A =&gt; B, a: A)scalaz.package.Store[A,B]" id="127637">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="127640">A</a>, <a title="&gt;: Nothing &lt;: Any" id="127641">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="127642">f</a>: A =&gt; B, <a title="A" id="127643">a</a>: <a href="#127640" title="A">A</a><span class="delimiter">)</span>: <a href="StoreT.scala.html#20783" title="scalaz.package.Store[A,B]">Store</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> = <a href="StoreT.scala.html#20784" title="object scalaz.StoreT">StoreT</a>.<a href="StoreT.scala.html#127128" title="(a: A)(f: A =&gt; B)scalaz.package.Store[A,B]">store</a><span class="delimiter">(</span><a href="#127643" title="A">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#127642" title="A =&gt; B">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>


  <span class="keyword">type</span> <a title="[-R, +W, S, +A]scalaz.ReaderWriterStateT[scalaz.Id.Identity,R,W,S,A]" id="38720">ReaderWriterState</a><span class="delimiter">[</span>-<a title="&gt;: Nothing &lt;: Any" id="38721">R</a>, +<a title="&gt;: Nothing &lt;: Any" id="38722">W</a>, <a title="&gt;: Nothing &lt;: Any" id="38723">S</a>, +<a title="&gt;: Nothing &lt;: Any" id="38724">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#18245" title="scalaz.ReaderWriterStateT[scalaz.Id.Identity,R,W,S,A]">ReaderWriterStateT</a><span class="delimiter">[</span>Identity, R, W, S, A<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[F[+_], -R, +W, S, +A]scalaz.ReaderWriterStateT[F,R,W,S,A]" id="38725">RWST</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="38726">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="368612">_</a><span class="delimiter">]</span>, -<a title="&gt;: Nothing &lt;: Any" id="38727">R</a>, +<a title="&gt;: Nothing &lt;: Any" id="38728">W</a>, <a title="&gt;: Nothing &lt;: Any" id="38729">S</a>, +<a title="&gt;: Nothing &lt;: Any" id="38730">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#18245" title="scalaz.ReaderWriterStateT[F,R,W,S,A]">ReaderWriterStateT</a><span class="delimiter">[</span>F, R, W, S, A<span class="delimiter">]</span>

  <span class="keyword">val</span> <a title="scalaz.ReaderWriterStateT.type" id="38731">RWST</a>: ReaderWriterStateT.<span class="keyword">type</span> = <a href="ReaderWriterStateT.scala.html#18246" title="object scalaz.ReaderWriterStateT">ReaderWriterStateT</a>

  <span class="keyword">type</span> <a title="[-R, +W, S, +A]scalaz.package.ReaderWriterState[R,W,S,A]" id="38733">RWS</a><span class="delimiter">[</span>-<a title="&gt;: Nothing &lt;: Any" id="38734">R</a>, +<a title="&gt;: Nothing &lt;: Any" id="38735">W</a>, <a title="&gt;: Nothing &lt;: Any" id="38736">S</a>, +<a title="&gt;: Nothing &lt;: Any" id="38737">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#18245" title="scalaz.package.ReaderWriterState[R,W,S,A]">ReaderWriterState</a><span class="delimiter">[</span>R, W, S, A<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[F[_]]scalaz.ApplicativePlus[F]" id="38738">Alternative</a><span class="delimiter">[</span><a title="[_]&gt;: Nothing &lt;: Any" id="38739">F</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="368613">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="ApplicativePlus.scala.html#17450" title="scalaz.ApplicativePlus[F]">ApplicativePlus</a><span class="delimiter">[</span>F<span class="delimiter">]</span>

  <span class="comment">/**
   * An [[scalaz.Validation]] with a [[scalaz.NonEmptyList]] as the failure type.
   *
   * Useful for accumulating errors through the corresponding [[scalaz.Applicative]] instance.
   */</span>
  <span class="keyword">type</span> <a title="[+E, +X]scalaz.Validation[scalaz.NonEmptyList[E],X]" id="38740">ValidationNEL</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="38741">E</a>, +<a title="&gt;: Nothing &lt;: Any" id="38742">X</a><span class="delimiter">]</span> = <a href="Validation.scala.html#11900" title="scalaz.Validation[scalaz.NonEmptyList[E],X]">Validation</a><span class="delimiter">[</span>NonEmptyList<span class="delimiter">[</span>E<span class="delimiter">]</span>, X<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[Option[A],scalaz.Tags.First]" id="38743">FirstOption</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38744">A</a><span class="delimiter">]</span> = Option<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="#96573" title="scalaz.package.@@[Option[A],scalaz.Tags.First]">@@</a> Tags.First
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[Option[A],scalaz.Tags.Last]" id="38745">LastOption</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38746">A</a><span class="delimiter">]</span> = Option<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="#96717" title="scalaz.package.@@[Option[A],scalaz.Tags.Last]">@@</a> Tags.Last
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[Option[A],scalaz.Tags.Min]" id="38747">MinOption</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38748">A</a><span class="delimiter">]</span> = Option<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="#96847" title="scalaz.package.@@[Option[A],scalaz.Tags.Min]">@@</a> Tags.Min
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[Option[A],scalaz.Tags.Max]" id="38749">MaxOption</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38750">A</a><span class="delimiter">]</span> = Option<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="#95046" title="scalaz.package.@@[Option[A],scalaz.Tags.Max]">@@</a> Tags.Max

  <span class="comment">//</span>
  <span class="comment">// Lens type aliases</span>
  <span class="comment">//</span>
  <span class="keyword">type</span> <a title="[A, B]scalaz.LensT[scalaz.Id.Id,A,B]" id="38751">Lens</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38752">A</a>, <a title="&gt;: Nothing &lt;: Any" id="38753">B</a><span class="delimiter">]</span> = <a href="Lens.scala.html#12320" title="scalaz.LensT[scalaz.Id.Id,A,B]">LensT</a><span class="delimiter">[</span>Id, A, B<span class="delimiter">]</span>

  <span class="comment">// important to define here, rather than at the top-level, to avoid Scala 2.9.2 bug</span>
  <span class="keyword">object</span> <a title="object scalaz.package.Lens" id="38754">Lens</a> <span title="ScalaObject" class="keyword">extends</span> <a href="Lens.scala.html#20303" title="scalaz.LensTFunctions">LensTFunctions</a> <span class="keyword">with</span> <a href="Lens.scala.html#18335" title="scalaz.LensTInstances">LensTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B](r: A =&gt; scalaz.package.Store[B,A])scalaz.package.Lens[A,B]" id="286548">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="286551">A</a>, <a title="&gt;: Nothing &lt;: Any" id="286552">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scalaz.package.Store[B,A]" id="286553">r</a>: A =&gt; Store<span class="delimiter">[</span>B, A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Lens.scala.html#12320" title="scalaz.package.Lens[A,B]">Lens</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> =
      <a href="Lens.scala.html#126804" title="(r: A =&gt; scalaz.package.Store[B,A])scalaz.package.Lens[A,B]">lens</a><span class="delimiter">(</span><a href="#286553" title="A =&gt; scalaz.package.Store[B,A]">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[A, B]scalaz.package.Lens[A,B]" id="38756">@&gt;</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38757">A</a>, <a title="&gt;: Nothing &lt;: Any" id="38758">B</a><span class="delimiter">]</span> = <a href="Lens.scala.html#12320" title="scalaz.package.Lens[A,B]">Lens</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[A, B]scalaz.PLensT[scalaz.Id.Id,A,B]" id="38759">PLens</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38760">A</a>, <a title="&gt;: Nothing &lt;: Any" id="38761">B</a><span class="delimiter">]</span> = <a href="PLens.scala.html#12095" title="scalaz.PLensT[scalaz.Id.Id,A,B]">PLensT</a><span class="delimiter">[</span>Id, A, B<span class="delimiter">]</span>

  <span class="comment">// important to define here, rather than at the top-level, to avoid Scala 2.9.2 bug</span>
  <span class="keyword">object</span> <a title="object scalaz.package.PLens" id="38762">PLens</a> <span title="ScalaObject" class="keyword">extends</span> <a href="PLens.scala.html#21359" title="scalaz.PLensTFunctions">PLensTFunctions</a> <span class="keyword">with</span> <a href="PLens.scala.html#16382" title="scalaz.PLensTInstances">PLensTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B](r: A =&gt; Option[scalaz.package.Store[B,A]])scalaz.package.PLens[A,B]" id="77852">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77855">A</a>, <a title="&gt;: Nothing &lt;: Any" id="77856">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; Option[scalaz.package.Store[B,A]]" id="368636">r</a>: A =&gt; Option<span class="delimiter">[</span>Store<span class="delimiter">[</span>B, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="PLens.scala.html#12095" title="scalaz.package.PLens[A,B]">PLens</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> =
      <a href="PLens.scala.html#77585" title="(r: A =&gt; Option[scalaz.package.Store[B,A]])scalaz.package.PLens[A,B]">plens</a><span class="delimiter">(</span><a href="#368636" title="A =&gt; Option[scalaz.package.Store[B,A]]">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[A, B]scalaz.package.PLens[A,B]" id="38764">@?&gt;</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38765">A</a>, <a title="&gt;: Nothing &lt;: Any" id="38766">B</a><span class="delimiter">]</span> = <a href="PLens.scala.html#12095" title="scalaz.package.PLens[A,B]">PLens</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[F[+_], A, B]scalaz.StateT[F,A,Option[B]]" id="38767">PStateT</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="38768">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="332092">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="38769">A</a>, <a title="&gt;: Nothing &lt;: Any" id="38770">B</a><span class="delimiter">]</span> = <a href="StateT.scala.html#11753" title="scalaz.StateT[F,A,Option[B]]">StateT</a><span class="delimiter">[</span>F, A, Option<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[A, B]scalaz.StateT[scalaz.Id.Id,A,Option[B]]" id="38771">PState</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38772">A</a>, <a title="&gt;: Nothing &lt;: Any" id="38773">B</a><span class="delimiter">]</span> = <a href="StateT.scala.html#11753" title="scalaz.StateT[scalaz.Id.Id,A,Option[B]]">StateT</a><span class="delimiter">[</span>Id, A, Option<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>