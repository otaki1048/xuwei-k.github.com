<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/scalaz/Free.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz

<span class="keyword">import</span> annotation.tailrec
<span class="keyword">import</span> <a href="#23010" title="object scalaz.Free">Free</a>._
<span class="keyword">import</span> std.<a href="std/Function.scala.html#25964" title="object scalaz.std.function">function</a>._
<span class="keyword">import</span> std.<a href="std/Tuple.scala.html#26804" title="object scalaz.std.tuple">tuple</a>._

<span class="comment">// TODO report compiler bug when this appears just above FreeInstances:</span>
<span class="comment">//      &quot;java.lang.Error: typeConstructor inapplicable for &lt;none&gt;&quot;</span>
<span class="keyword">object</span> <a title="object scalaz.Free" id="23010">Free</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#22595" title="scalaz.FreeFunctions">FreeFunctions</a> <span class="keyword">with</span> <a href="#20537" title="scalaz.FreeInstances">FreeInstances</a> <span class="delimiter">{</span>

  <span class="comment">/** Return from the computation with the given value. */</span>
  case <span class="keyword">class</span> <a title="class Return[S[+_], +A] extends scalaz.Free[S,A] with ScalaObject with Product with Serializable" id="195785">Return</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="163382">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="163402">_</a><span class="delimiter">]</span>: Functor, +<a title="&gt;: Nothing &lt;: Any" id="163383">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="163400">a</a>: <a href="#163383" title="A">A</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#23009" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span>

  <span class="comment">/** Suspend the computation with the given suspension. */</span>
  case <span class="keyword">class</span> <a title="class Suspend[S[+_], +A] extends scalaz.Free[S,A] with ScalaObject with Product with Serializable" id="195779">Suspend</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="195214">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="195773">_</a><span class="delimiter">]</span>: Functor, +<a title="&gt;: Nothing &lt;: Any" id="195215">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="195771">a</a>: <a href="#195214" title="S[scalaz.Free[S,A]]">S</a><span class="delimiter">[</span>Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#23009" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span>

  <span class="comment">/** Call a subroutine and continue with the given function. */</span>
  case <span class="keyword">class</span> <a title="class Gosub[S[+_], A, +B] extends scalaz.Free[S,B] with ScalaObject with Product with Serializable" id="195767">Gosub</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="195693">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="195759">_</a><span class="delimiter">]</span>: Functor, <a title="&gt;: Nothing &lt;: Any" id="195694">A</a>, +<a title="&gt;: Nothing &lt;: Any" id="195695">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="195756">a</a>: <a href="#23009" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span>,
                                          <a title="A =&gt; scalaz.Free[S,B]" id="195757">f</a>: A =&gt; Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#23009" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span>

  <span class="comment">/** A computation that can be stepped through, suspended, and paused */</span>
  <span class="keyword">type</span> <a title="[+A]scalaz.Free[Function0,A]" id="52838">Trampoline</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="52839">A</a><span class="delimiter">]</span> = <a href="#23009" title="scalaz.Free[Function0,A]">Free</a><span class="delimiter">[</span>Function0, A<span class="delimiter">]</span>

  <span class="comment">/** A computation that produces values of type `A`, eventually resulting in a value of type `B`. */</span>
  <span class="keyword">type</span> <a title="[A, +B]scalaz.Free[[+x](A, x),B]" id="52840">Source</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="52841">A</a>, +<a title="&gt;: Nothing &lt;: Any" id="52842">B</a><span class="delimiter">]</span> = <a href="#23009" title="scalaz.Free[[+x](A, x),B]">Free</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>A, x<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#f, B<span class="delimiter">]</span>

  <span class="comment">/** A computation that accepts values of type `A`, eventually resulting in a value of type `B`.
    * Note the similarity to an [[scalaz.iteratee.Iteratee]].
    */</span>
  <span class="keyword">type</span> <a title="[A, +B]scalaz.Free[[+x]=&gt; A =&gt; x,B]" id="52843">Sink</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="52844">A</a>, +<a title="&gt;: Nothing &lt;: Any" id="52845">B</a><span class="delimiter">]</span> = <a href="#23009" title="scalaz.Free[[+x]=&gt; A =&gt; x,B]">Free</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; A<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#f, B<span class="delimiter">]</span>
<span class="delimiter">}</span>

<span class="comment">/** A free operational monad for some functor `S`. Binding is done using the heap instead of the stack,
  * allowing tail-call elimination. */</span>
<span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Free[S[+_], +A] extends java.lang.Object with ScalaObject" id="23009">Free</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="24996">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="195786">_</a><span class="delimiter">]</span>, +<a title="&gt;: Nothing &lt;: Any" id="24997">A</a><span class="delimiter">]</span><a href="#23009" title="ScalaObject" class="delimiter">(</a><span class="keyword">implicit</span> <a title="scalaz.Functor[S]" id="194365">S</a>: <a href="Functor.scala.html#14432" title="scalaz.Functor[S]">Functor</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[B](f: A =&gt; B)scalaz.Free[S,B]" id="117059">map</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117061">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="117129">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#23009" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span> =
    <a href="#117065" title="(f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]">flatMap</a><span class="delimiter">(</span><a title="A" id="195795">a</a> =&gt; <a href="#195785" title="(a: B)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,B]">Return</a><a href="#194365" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#117129" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#195795" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Alias for `flatMap` */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[B](f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]" id="117062">&gt;&gt;=</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117064">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free[S,B]" id="154353">f</a>: A =&gt; Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23009" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span> = <a href="#23009" title="Free.this.type" class="keyword">this</a> <a href="#117065" title="(f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]">flatMap</a> <a href="#154353" title="A =&gt; scalaz.Free[S,B]">f</a>

  <span class="comment">/** Binds the given continuation to the result of this computation.
    * All left-associated binds are reassociated to the right. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[B](f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]" id="117065">flatMap</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117067">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free[S,B]" id="195789">f</a>: A =&gt; Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23009" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span> = <a href="#23009" title="scalaz.Free[S,A]" class="keyword">this</a> <span title="scalaz.Free[S,B]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="scalaz.Free.Gosub[S,Any,B]">Gosub</span><span class="delimiter">(</span><a title="scalaz.Free[S,Any]" id="196173">a</a>, <a title="Any =&gt; scalaz.Free[S,A]" id="196174">g</a><span class="delimiter">)</span> =&gt; <a href="#195767" title="(a: scalaz.Free[S,Any], f: Any =&gt; scalaz.Free[S,B])(implicit evidence$3: scalaz.Functor[S])scalaz.Free.Gosub[S,Any,B]">Gosub</a><a href="#194365" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#196173" title="scalaz.Free[S,Any]">a</a>, <span class="delimiter">(</span>x: <span title="Any">Any</span><span class="delimiter">)</span> =&gt; <a href="#195767" title="(a: scalaz.Free[S,A], f: A =&gt; scalaz.Free[S,B])(implicit evidence$3: scalaz.Functor[S])scalaz.Free.Gosub[S,A,B]">Gosub</a><a href="#194365" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#196174" title="(v1: Any)scalaz.Free[S,A]">g</a><span class="delimiter">(</span><a href="#196186" title="Any">x</a><span class="delimiter">)</span>, <a href="#195789" title="A =&gt; scalaz.Free[S,B]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="scalaz.Free.Gosub[S,A,B]" id="196926">a</a>           =&gt; <a href="#195767" title="(a: scalaz.Free[S,A], f: A =&gt; scalaz.Free[S,B])(implicit evidence$3: scalaz.Functor[S])scalaz.Free.Gosub[S,A,B]">Gosub</a><a href="#194365" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#196926" title="scalaz.Free[S,A]">a</a>, <a href="#195789" title="A =&gt; scalaz.Free[S,B]">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Evaluates a single layer of the free monad. */</span>
  @tailrec <span class="keyword">final</span> <span class="keyword">def</span> <a title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]" id="117068">resume</a>: <span class="delimiter">(</span>S<span class="delimiter">[</span>Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">]</span> <a href="Either.scala.html#10076" title="scalaz.\/[S[scalaz.Free[S,A]],A]">\/</a> A<span class="delimiter">)</span> = <a href="#23009" title="scalaz.Free[S,A]" class="keyword">this</a> <span title="scalaz.\/[S[scalaz.Free[S,A]],A]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="scalaz.\/[Nothing,A]">Return</span><span class="delimiter">(</span><a title="A" id="197307">a</a><span class="delimiter">)</span>  =&gt; <a href="Either.scala.html#10077" title="object scalaz.\/">\/</a>.<a href="Either.scala.html#133444" title="(v1: A)scalaz.\/[Nothing,A]">right</a><span class="delimiter">(</span><a href="#197307" title="A">a</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="scalaz.\/[S[scalaz.Free[S,A]],Nothing]">Suspend</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="197316">t</a><span class="delimiter">)</span> =&gt; <a href="Either.scala.html#10077" title="object scalaz.\/">\/</a>.<a href="Either.scala.html#133439" title="(v1: S[scalaz.Free[S,A]])scalaz.\/[S[scalaz.Free[S,A]],Nothing]">left</a><span class="delimiter">(</span><a href="#197316" title="S[scalaz.Free[S,A]]">t</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="scalaz.\/[S[scalaz.Free[S,A]],A]" id="197326">a</a> Gosub <a title="Any =&gt; scalaz.Free[S,A]" id="197327">f</a>  =&gt; <a href="#197326" title="scalaz.Free[S,Any]">a</a> <span title="scalaz.\/[S[scalaz.Free[S,A]],A]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="scalaz.\/[S[scalaz.Free[S,A]],A]">Return</span><span class="delimiter">(</span><a title="Any" id="197332">a</a><span class="delimiter">)</span>  =&gt; <a href="#197327" title="(v1: Any)scalaz.Free[S,A]">f</a><span class="delimiter">(</span><a href="#197332" title="Any">a</a><span class="delimiter">)</span>.<a href="#117068" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a>
      <span class="keyword">case</span> <span title="scalaz.\/[S[scalaz.Free[S,A]],Nothing]">Suspend</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,Any]]" id="197338">t</a><span class="delimiter">)</span> =&gt; <a href="Either.scala.html#10077" title="object scalaz.\/">\/</a>.<a href="Either.scala.html#133439" title="(v1: S[scalaz.Free[S,A]])scalaz.\/[S[scalaz.Free[S,A]],Nothing]">left</a><span class="delimiter">(</span><a href="#194365" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#42343" title="(fa: S[scalaz.Free[S,Any]])(f: scalaz.Free[S,Any] =&gt; scalaz.Free[S,A])S[scalaz.Free[S,A]]">map</a><span class="delimiter">(</span><a href="#197338" title="S[scalaz.Free[S,Any]]">t</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#197352" title="scalaz.Free[S,Any]">_</a>: <a href="#23009" title="scalaz.Free[S,Any]">Free</a><span class="delimiter">[</span>S, Any<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#117065" title="(f: Any =&gt; scalaz.Free[S,A])scalaz.Free[S,A]">flatMap</a> <a href="#197327" title="Any =&gt; scalaz.Free[S,A]">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="scalaz.\/[S[scalaz.Free[S,A]],A]" id="197365">b</a> Gosub <a title="Any =&gt; scalaz.Free[S,Any]" id="197366">g</a>  =&gt; <a href="#197365" title="scalaz.Free[S,Any]">b</a>.<a href="#117065" title="(f: Any =&gt; scalaz.Free[S,A])scalaz.Free[S,A]">flatMap</a><span class="delimiter">(</span><span class="delimiter">(</span>x: <span title="Any">Any</span><span class="delimiter">)</span> =&gt; <a href="#197366" title="(v1: Any)scalaz.Free[S,Any]">g</a><span class="delimiter">(</span><a href="#197371" title="Any">x</a><span class="delimiter">)</span> <a href="#117065" title="(f: Any =&gt; scalaz.Free[S,A])scalaz.Free[S,A]">flatMap</a> <a href="#197327" title="Any =&gt; scalaz.Free[S,A]">f</a><span class="delimiter">)</span>.<a href="#117068" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Changes the suspension functor by the given natural transformation. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[T[+_]](f: scalaz.package.~&gt;[S,T])(implicit evidence$4: scalaz.Functor[T])scalaz.Free[T,A]" id="197379">mapSuspension</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="117071">T</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="197380">_</a><span class="delimiter">]</span>:Functor<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.package.~&gt;[S,T]" id="197378">f</a>: S <a href="NaturalTransformation.scala.html#16919" title="scalaz.package.~&gt;[S,T]">~&gt;</a> T<span class="delimiter">)</span>: <a href="#23009" title="scalaz.Free[T,A]">Free</a><span class="delimiter">[</span>T, A<span class="delimiter">]</span> =
    <a href="#117068" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a> <span title="scalaz.Free[T,A]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Suspend[T,A]">-\/</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="197385">s</a><span class="delimiter">)</span>  =&gt; <a href="#195779" title="(a: T[scalaz.Free[T,A]])(implicit evidence$2: scalaz.Functor[T])scalaz.Free.Suspend[T,A]">Suspend</a><a href="#197379" title="scalaz.Functor[T]" class="delimiter">(</a><a href="NaturalTransformation.scala.html#146546" title="(fa: S[scalaz.Free[T,A]])T[scalaz.Free[T,A]]">f</a><span class="delimiter">(</span><a href="#194365" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#42343" title="(fa: S[scalaz.Free[S,A]])(f: scalaz.Free[S,A] =&gt; scalaz.Free[T,A])S[scalaz.Free[T,A]]">map</a><span class="delimiter">(</span><a href="#197385" title="S[scalaz.Free[S,A]]">s</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#197406" title="scalaz.Free[S,A]">_</a>: <a href="#23009" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#197379" title="(f: scalaz.package.~&gt;[S,T])(implicit evidence$4: scalaz.Functor[T])scalaz.Free[T,A]">mapSuspension</a> <a href="#197378" title="scalaz.package.~&gt;[S,T]">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Return[T,A]">\/-</span><span class="delimiter">(</span><a title="A" id="198141">r</a><span class="delimiter">)</span> =&gt; <a href="#195785" title="(a: A)(implicit evidence$1: scalaz.Functor[T])scalaz.Free.Return[T,A]">Return</a><a href="#197379" title="scalaz.Functor[T]" class="delimiter">(</a><a href="#198141" title="A">r</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Modifies the first suspension with the given natural transformation. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(f: scalaz.package.~&gt;[S,S])scalaz.Free[S,A]" id="117072">mapFirstSuspension</a><span class="delimiter">(</span><a title="scalaz.package.~&gt;[S,S]" id="198510">f</a>: S <a href="NaturalTransformation.scala.html#16919" title="scalaz.package.~&gt;[S,S]">~&gt;</a> S<span class="delimiter">)</span>: <a href="#23009" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> = <a href="#117068" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a> <span title="scalaz.Free[S,A]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="scalaz.Free.Suspend[S,A]">-\/</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="198513">s</a><span class="delimiter">)</span> =&gt; <a href="#195779" title="(a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><a href="#194365" title="scalaz.Functor[S]" class="delimiter">(</a><a href="NaturalTransformation.scala.html#146546" title="(fa: S[scalaz.Free[S,A]])S[scalaz.Free[S,A]]">f</a><span class="delimiter">(</span><a href="#198513" title="S[scalaz.Free[S,A]]">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="scalaz.Free.Return[S,A]">\/-</span><span class="delimiter">(</span><a title="A" id="198888">r</a><span class="delimiter">)</span> =&gt; <a href="#195785" title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><a href="#194365" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#198888" title="A">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Applies a function `f` to a value in this monad and a corresponding value in the dual comonad, annihilating both. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[G[+_], B, C](bs: scalaz.Cofree[G,B])(f: (A, B) =&gt; C)(implicit G: scalaz.Functor[G], implicit d: scalaz.Zap[S,G])C" id="117073">zapWith</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="117077">G</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="199261">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="117078">B</a>, <a title="&gt;: Nothing &lt;: Any" id="117079">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Cofree[G,B]" id="199256">bs</a>: <a href="Cofree.scala.html#21032" title="scalaz.Cofree[G,B]">Cofree</a><span class="delimiter">[</span>G, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="199257">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[G]" id="199258">G</a>: <a href="Functor.scala.html#14432" title="scalaz.Functor[G]">Functor</a><span class="delimiter">[</span>G<span class="delimiter">]</span>, <a title="scalaz.Zap[S,G]" id="199259">d</a>: <a href="Zap.scala.html#11690" title="scalaz.Zap[S,G]">Zap</a><span class="delimiter">[</span>S, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#117079" title="C">C</a> =
    <a href="Zap.scala.html#11691" title="object scalaz.Zap">Zap</a>.<a href="Zap.scala.html#146726" title="(implicit d: scalaz.Zap[S,G], implicit F: scalaz.Functor[S], implicit G: scalaz.Functor[G])scalaz.Zap[[α]scalaz.Free[S,α],[α]scalaz.Cofree[G,α]]">monadComonadZap</a>.<a href="Zap.scala.html#62560" title="(fa: scalaz.Free[S,A], gb: scalaz.Cofree[G,B])(f: (A, B) =&gt; C)C">zapWith</a><span class="delimiter">(</span><a href="#23009" title="scalaz.Free[S,A]" class="keyword">this</a>, <a href="#199256" title="scalaz.Cofree[G,B]">bs</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#199257" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span>

  <span class="comment">/** Applies a function in a comonad to the corresponding value in this monad, annihilating both. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[G[+_], B](fs: scalaz.Cofree[G,A =&gt; B])(implicit G: scalaz.Functor[G], implicit d: scalaz.Zap[S,G])B" id="117080">zap</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="117083">G</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="200319">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="117084">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Cofree[G,A =&gt; B]" id="200315">fs</a>: <a href="Cofree.scala.html#21032" title="scalaz.Cofree[G,A =&gt; B]">Cofree</a><span class="delimiter">[</span>G, A =&gt; B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[G]" id="200316">G</a>: <a href="Functor.scala.html#14432" title="scalaz.Functor[G]">Functor</a><span class="delimiter">[</span>G<span class="delimiter">]</span>, <a title="scalaz.Zap[S,G]" id="200317">d</a>: <a href="Zap.scala.html#11690" title="scalaz.Zap[S,G]">Zap</a><span class="delimiter">[</span>S, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#117084" title="B">B</a> =
    <a href="#117073" title="(bs: scalaz.Cofree[G,A =&gt; B])(f: (A, A =&gt; B) =&gt; B)(implicit G: scalaz.Functor[G], implicit d: scalaz.Zap[S,G])B">zapWith</a><span class="delimiter">(</span><a href="#200315" title="scalaz.Cofree[G,A =&gt; B]">fs</a><span class="delimiter">)</span><a href="#200316" title="scalaz.Functor[G]" class="delimiter">(</a><span class="delimiter">(</span><a title="A" id="200344">a</a>, <a title="A =&gt; B" id="200345">f</a><span class="delimiter">)</span> =&gt; <a href="#200345" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#200344" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Runs a single step, using a function that extracts the resumption from its suspension functor. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[AA &gt;: A](f: S[scalaz.Free[S,A]] =&gt; scalaz.Free[S,AA])scalaz.Free[S,AA]" id="117085">bounce</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="117087">AA</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]] =&gt; scalaz.Free[S,AA]" id="200988">f</a>: S<span class="delimiter">[</span>Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">]</span> =&gt; Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23009" title="scalaz.Free[S,AA]">Free</a><span class="delimiter">[</span>S, AA<span class="delimiter">]</span> = <a href="#117068" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a> <span title="scalaz.Free[S,AA]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="scalaz.Free[S,AA]">-\/</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="200992">s</a><span class="delimiter">)</span> =&gt; <a href="#200988" title="(v1: S[scalaz.Free[S,A]])scalaz.Free[S,AA]">f</a><span class="delimiter">(</span><a href="#200992" title="S[scalaz.Free[S,A]]">s</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="scalaz.Free.Return[S,A]">\/-</span><span class="delimiter">(</span><a title="A" id="200995">r</a><span class="delimiter">)</span> =&gt; <a href="#195785" title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><a href="#194365" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#200995" title="A">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Runs to completion, using a function that extracts the resumption from its suspension functor. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[AA &gt;: A](f: S[scalaz.Free[S,AA]] =&gt; scalaz.Free[S,AA])AA" id="117088">go</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="117090">AA</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,AA]] =&gt; scalaz.Free[S,AA]" id="201363">f</a>: S<span class="delimiter">[</span>Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">]</span> =&gt; Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#117090" title="AA">AA</a> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(t: scalaz.Free[S,AA])AA" id="201366">go2</a><span class="delimiter">(</span><a title="scalaz.Free[S,AA]" id="201367">t</a>: <a href="#23009" title="scalaz.Free[S,AA]">Free</a><span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#117090" title="AA">AA</a> = <a href="#201367" title="scalaz.Free[S,AA]">t</a>.<a href="#117068" title="=&gt; scalaz.\/[S[scalaz.Free[S,AA]],AA]">resume</a> <span title="AA" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="AA">-\/</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,AA]]" id="201369">s</a><span class="delimiter">)</span> =&gt; <a href="#201366" title="(t: scalaz.Free[S,AA])AA">go2</a><span class="delimiter">(</span><a href="#201363" title="(v1: S[scalaz.Free[S,AA]])scalaz.Free[S,AA]">f</a><span class="delimiter">(</span><a href="#201369" title="S[scalaz.Free[S,AA]]">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="AA">\/-</span><span class="delimiter">(</span><a title="AA" id="201372">r</a><span class="delimiter">)</span> =&gt; <a href="#201372" title="AA">r</a>
    <span class="delimiter">}</span>
    <a href="#201366" title="(t: scalaz.Free[S,AA])AA">go2</a><span class="delimiter">(</span><a href="#23009" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Runs to completion, allowing the resumption function to thread an arbitrary state of type `B`. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[B, AA &gt;: A](b: B)(f: (B, S[scalaz.Free[S,AA]]) =&gt; (B, scalaz.Free[S,AA]))(B, AA)" id="117091">foldRun</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117094">B</a>, <a title="&gt;: A &lt;: Any" id="117095">AA</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="201373">b</a>: <a href="#117094" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, S[scalaz.Free[S,AA]]) =&gt; (B, scalaz.Free[S,AA])" id="201374">f</a>: <span class="delimiter">(</span>B, S<span class="delimiter">[</span>Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>B, Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="(B, AA)" class="delimiter">(</span>B, AA<span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(t: scalaz.Free[S,AA], z: B)(B, AA)" id="201378">foldRun2</a><span class="delimiter">(</span><a title="scalaz.Free[S,AA]" id="201379">t</a>: <a href="#23009" title="scalaz.Free[S,AA]">Free</a><span class="delimiter">[</span>S, AA<span class="delimiter">]</span>, <a title="B" id="201380">z</a>: <a href="#117094" title="B">B</a><span class="delimiter">)</span>: <span title="(B, AA)" class="delimiter">(</span>B, AA<span class="delimiter">)</span> = <a href="#201379" title="scalaz.Free[S,AA]">t</a>.<a href="#117068" title="=&gt; scalaz.\/[S[scalaz.Free[S,AA]],AA]">resume</a> <span title="(B, AA)" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="(B, AA)">-\/</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,AA]]" id="201382">s</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
        <span class="keyword">val</span> <a href="#201384" title="(B, scalaz.Free[S,AA])" class="delimiter">(</a><a href="#201383" title="B" id="201384">b1</a>, <a href="#201383" title="scalaz.Free[S,AA]" id="201385">s1</a><span class="delimiter">)</span> = <a href="#201374" title="(v1: B, v2: S[scalaz.Free[S,AA]])(B, scalaz.Free[S,AA])">f</a><span title="(B, scalaz.Free[S,AA]) @unchecked" class="delimiter">(</span><a href="#201380" title="B">z</a>, <a href="#201382" title="S[scalaz.Free[S,AA]]">s</a><span class="delimiter">)</span>
        <a href="#201378" title="(t: scalaz.Free[S,AA], z: B)(B, AA)">foldRun2</a><span class="delimiter">(</span><a href="#201385" title="scalaz.Free[S,AA]">s1</a>, <a href="#201384" title="B">b1</a><span class="delimiter">)</span> 
      <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="(B, AA)">\/-</span><span class="delimiter">(</span><a title="AA" id="201399">r</a><span class="delimiter">)</span> =&gt; <span title="(_1: B, _2: AA)(B, AA)" class="delimiter">(</span><a href="#201380" title="B">z</a>, <a href="#201399" title="AA">r</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#201378" title="(t: scalaz.Free[S,AA], z: B)(B, AA)">foldRun2</a><span class="delimiter">(</span><a href="#23009" title="scalaz.Free[S,A]" class="keyword">this</a>, <a href="#201373" title="B">b</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">import</span> <a href="Liskov.scala.html#10149" title="object scalaz.Liskov">Liskov</a>._

  <span class="comment">/** Runs a trampoline all the way to the end, tail-recursively. */</span>
  <span class="keyword">def</span> <a title="[B &gt;: A](implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,B],scalaz.Free.Trampoline[B]])B" id="117097">run</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="117099">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,B],scalaz.Free.Trampoline[B]]" id="117198">ev</a>: Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span> <a href="Liskov.scala.html#10148" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,B],scalaz.Free.Trampoline[B]]">&lt;~&lt;</a> Trampoline<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#117099" title="B">B</a> =
    <a href="Liskov.scala.html#117568" title="(a: scalaz.Free[S,B])scalaz.Free.Trampoline[B]">ev</a><span class="delimiter">(</span><a href="#23009" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span>.<a href="#117088" title="(f: (() =&gt; scalaz.Free[Function0,B]) =&gt; scalaz.Free[Function0,B])B">go</a><span class="delimiter">(</span><a href="#201417" title="()scalaz.Free[Function0,B]">_</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Interleave this computation with another, combining the results with the given function. */</span>
  <span class="keyword">def</span> <a title="[B, C](tb: scalaz.Free[S,B], f: (A, B) =&gt; C)scalaz.Free[S,C]" id="117100">zipWith</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117103">B</a>, <a title="&gt;: Nothing &lt;: Any" id="117104">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free[S,B]" id="201418">tb</a>: <a href="#23009" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span>, <a title="(A, B) =&gt; C" id="201419">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#23009" title="scalaz.Free[S,C]">Free</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="(_1: scalaz.\/[S[scalaz.Free[S,A]],A], _2: scalaz.\/[S[scalaz.Free[S,B]],B])(scalaz.\/[S[scalaz.Free[S,A]],A], scalaz.\/[S[scalaz.Free[S,B]],B])" class="delimiter">(</span><a href="#117068" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a>, <a href="#201418" title="scalaz.Free[S,B]">tb</a>.<a href="#117068" title="=&gt; scalaz.\/[S[scalaz.Free[S,B]],B]">resume</a><span class="delimiter">)</span> <span title="scalaz.Free[S,C]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Suspend[S,C]" class="delimiter">(</span>-\/<span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="201432">a</a><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="S[scalaz.Free[S,B]]" id="201434">b</a><span class="delimiter">)</span><span class="delimiter">)</span>   =&gt; <a href="#195779" title="(a: S[scalaz.Free[S,C]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,C]">Suspend</a><a href="#194365" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#194365" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#42343" title="(fa: S[scalaz.Free[S,A]])(f: scalaz.Free[S,A] =&gt; scalaz.Free.Suspend[S,C])S[scalaz.Free.Suspend[S,C]]">map</a><span class="delimiter">(</span><a href="#201432" title="S[scalaz.Free[S,A]]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="201452">x</a> =&gt; <a href="#195779" title="(a: S[scalaz.Free[S,C]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,C]">Suspend</a><a href="#194365" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#194365" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#42343" title="(fa: S[scalaz.Free[S,B]])(f: scalaz.Free[S,B] =&gt; scalaz.Free[S,C])S[scalaz.Free[S,C]]">map</a><span class="delimiter">(</span><a href="#201434" title="S[scalaz.Free[S,B]]">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Free[S,B]" id="201470">y</a> =&gt; <a href="#201452" title="scalaz.Free[S,A]">x</a> <a href="#117100" title="(tb: scalaz.Free[S,B], f: (A, B) =&gt; C)scalaz.Free[S,C]">zipWith</a><span class="delimiter">(</span><a href="#201470" title="scalaz.Free[S,B]">y</a>, <a href="#201419" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Suspend[S,C]" class="delimiter">(</span>-\/<span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="202207">a</a><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="B" id="202209">b</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#195779" title="(a: S[scalaz.Free[S,C]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,C]">Suspend</a><a href="#194365" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#194365" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#42343" title="(fa: S[scalaz.Free[S,A]])(f: scalaz.Free[S,A] =&gt; scalaz.Free[S,C])S[scalaz.Free[S,C]]">map</a><span class="delimiter">(</span><a href="#202207" title="S[scalaz.Free[S,A]]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="202227">x</a> =&gt; <a href="#202227" title="scalaz.Free[S,A]">x</a> <a href="#117100" title="(tb: scalaz.Free[S,B], f: (A, B) =&gt; C)scalaz.Free[S,C]">zipWith</a><span class="delimiter">(</span><a href="#195785" title="(a: B)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,B]">Return</a><a href="#194365" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#202209" title="B">b</a><span class="delimiter">)</span>, <a href="#201419" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Suspend[S,C]" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="A" id="202967">a</a><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="S[scalaz.Free[S,B]]" id="202969">b</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#195779" title="(a: S[scalaz.Free[S,C]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,C]">Suspend</a><a href="#194365" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#194365" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#42343" title="(fa: S[scalaz.Free[S,B]])(f: scalaz.Free[S,B] =&gt; scalaz.Free[S,C])S[scalaz.Free[S,C]]">map</a><span class="delimiter">(</span><a href="#202969" title="S[scalaz.Free[S,B]]">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Free[S,B]" id="202987">y</a> =&gt; <a href="#195785" title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span class="delimiter">(</span><a href="#202967" title="A">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#194365" title="scalaz.Functor[S]">S</a><span class="delimiter">)</span> <a href="#117100" title="(tb: scalaz.Free[S,B], f: (A, B) =&gt; C)scalaz.Free[S,C]">zipWith</a><span class="delimiter">(</span><a href="#202987" title="scalaz.Free[S,B]">y</a>, <a href="#201419" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Return[S,C]" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="A" id="203372">a</a><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="B" id="203374">b</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#195785" title="(a: C)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,C]">Return</a><a href="#194365" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#201419" title="(v1: A, v2: B)C">f</a><span class="delimiter">(</span><a href="#203372" title="A">a</a>, <a href="#203374" title="B">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Runs a `Source` all the way to the end, tail-recursively, collecting the produced values. */</span>
  <span class="keyword">def</span> <a title="[B, C &gt;: A](implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[B,C]])(Vector[B], C)" id="117105">collect</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117108">B</a>, <a title="&gt;: A &lt;: Any" id="117109">C</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[B,C]]" id="203744">ev</a>: Free<span class="delimiter">[</span>S, C<span class="delimiter">]</span> <a href="Liskov.scala.html#10148" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[B,C]]">&lt;~&lt;</a> Source<span class="delimiter">[</span>B, C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Vector[B], C)" class="delimiter">(</span>Vector<span class="delimiter">[</span>B<span class="delimiter">]</span>, C<span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(c: scalaz.Free.Source[B,C], v: Vector[B])(Vector[B], C)" id="203747">go</a><span class="delimiter">(</span><a title="scalaz.Free.Source[B,C]" id="203748">c</a>: <a href="#23009" title="scalaz.Free.Source[B,C]">Source</a><span class="delimiter">[</span>B, C<span class="delimiter">]</span>, <a title="Vector[B]" id="203750">v</a>: <span title="Vector[B]">Vector</span><span class="delimiter">[</span>B<span class="delimiter">]</span> = <span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="(Vector[B], C)" class="delimiter">(</span>Vector<span class="delimiter">[</span>B<span class="delimiter">]</span>, C<span class="delimiter">)</span> =
      <a href="#203748" title="scalaz.Free.Source[B,C]">c</a>.<a href="#117068" title="=&gt; scalaz.\/[(B, scalaz.Free[[+x](B, x),C]),C]">resume</a> <span title="(Vector[B], C)" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="(Vector[B], C)">-\/</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="B" id="203757">b</a>, <a title="scalaz.Free[[+x](B, x),C]" id="203758">cont</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#203747" title="(c: scalaz.Free.Source[B,C], v: Vector[B])(Vector[B], C)">go</a><span class="delimiter">(</span><a href="#203758" title="scalaz.Free[[+x](B, x),C]">cont</a>, <a href="#203750" title="Vector[B]">v</a> <span title="(elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[B],B,Vector[B]])Vector[B]">:+</span> <a href="#203757" title="B">b</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="(Vector[B], C)">\/-</span><span class="delimiter">(</span><a title="C" id="204228">r</a><span class="delimiter">)</span>        =&gt; <span title="(_1: Vector[B], _2: C)(Vector[B], C)" class="delimiter">(</span><a href="#203750" title="Vector[B]">v</a>, <a href="#204228" title="C">r</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="#203747" title="(c: scalaz.Free.Source[B,C], v: Vector[B])(Vector[B], C)">go</a><span class="delimiter">(</span><a href="Liskov.scala.html#117568" title="(a: scalaz.Free[S,C])scalaz.Free.Source[B,C]">ev</a><span class="delimiter">(</span><a href="#23009" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Drive this `Source` with the given Sink. */</span>
  <span class="keyword">def</span> <a title="[E, B, C &gt;: A](sink: scalaz.Free.Sink[Option[E],B])(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[E,C]])(C, B)" id="117110">drive</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117114">E</a>, <a title="&gt;: Nothing &lt;: Any" id="117115">B</a>, <a title="&gt;: A &lt;: Any" id="117116">C</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Sink[Option[E],B]" id="204239">sink</a>: <a href="#23009" title="scalaz.Free.Sink[Option[E],B]">Sink</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>E<span class="delimiter">]</span>, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[E,C]]" id="204240">ev</a>: Free<span class="delimiter">[</span>S, C<span class="delimiter">]</span> <a href="Liskov.scala.html#10148" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[E,C]]">&lt;~&lt;</a> Source<span class="delimiter">[</span>E, C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(C, B)" class="delimiter">(</span>C, B<span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)" id="204244">go</a><span class="delimiter">(</span><a title="scalaz.Free.Source[E,C]" id="204245">src</a>: <a href="#23009" title="scalaz.Free.Source[E,C]">Source</a><span class="delimiter">[</span>E, C<span class="delimiter">]</span>, <a title="scalaz.Free.Sink[Option[E],B]" id="204246">snk</a>: <a href="#23009" title="scalaz.Free.Sink[Option[E],B]">Sink</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>E<span class="delimiter">]</span>, B<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(C, B)" class="delimiter">(</span>C, B<span class="delimiter">)</span> =
      <span title="(_1: scalaz.\/[(E, scalaz.Free[[+x](E, x),C]),C], _2: scalaz.\/[=&gt; Option[E] =&gt; scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B],B])(scalaz.\/[(E, scalaz.Free[[+x](E, x),C]),C], scalaz.\/[=&gt; Option[E] =&gt; scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B],B])" class="delimiter">(</span><a href="#204245" title="scalaz.Free.Source[E,C]">src</a>.<a href="#117068" title="=&gt; scalaz.\/[(E, scalaz.Free[[+x](E, x),C]),C]">resume</a>, <a href="#204246" title="scalaz.Free.Sink[Option[E],B]">snk</a>.<a href="#117068" title="=&gt; scalaz.\/[=&gt; Option[E] =&gt; scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B],B]">resume</a><span class="delimiter">)</span> <span title="(C, B)" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>-\/<span class="delimiter">(</span><span class="delimiter">(</span><a title="E" id="204258">e</a>, <a title="scalaz.Free[[+x](E, x),C]" id="204259">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="=&gt; Option[E] =&gt; scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B]" id="204261">f</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#204244" title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)">go</a><span class="delimiter">(</span><a href="#204259" title="scalaz.Free[[+x](E, x),C]">c</a>, <a href="#204261" title="(v1: =&gt; Option[E])scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B]">f</a><span class="delimiter">(</span><span title="(x: E)Some[E]">Some</span><span class="delimiter">(</span><a href="#204258" title="E">e</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>-\/<span class="delimiter">(</span><span class="delimiter">(</span><a title="E" id="204271">e</a>, <a title="scalaz.Free[[+x](E, x),C]" id="204272">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="B" id="204274">y</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#204244" title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)">go</a><span class="delimiter">(</span><a href="#204272" title="scalaz.Free[[+x](E, x),C]">c</a>, <a href="#11718" title="object scalaz.Sink">Sink</a>.<a href="#52854" title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]">sinkMonad</a><span title="scalaz.Monad[[x]scalaz.Free[[+x]=&gt; Option[E] =&gt; x,x]]" class="delimiter">[</span><span title="Option[E]">Option</span><span class="delimiter">[</span>E<span class="delimiter">]</span><span class="delimiter">]</span>.<a href="Pointed.scala.html#43396" title="(a: =&gt; B)scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B]">pure</a><span class="delimiter">(</span><a href="#204274" title="B">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="C" id="204286">x</a><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="=&gt; Option[E] =&gt; scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B]" id="204288">f</a><span class="delimiter">)</span><span class="delimiter">)</span>      =&gt; <a href="#204244" title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)">go</a><span class="delimiter">(</span><a href="#23568" title="object scalaz.Source">Source</a>.<a href="#52858" title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]">sourceMonad</a><span title="scalaz.Monad[[x]scalaz.Free[[+x](E, x),x]]" class="delimiter">[</span><a href="#117114" title="E">E</a><span class="delimiter">]</span>.<a href="Pointed.scala.html#43396" title="(a: =&gt; C)scalaz.Free[[+x](E, x),C]">pure</a><span class="delimiter">(</span><a href="#204286" title="C">x</a><span class="delimiter">)</span>, <a href="#204288" title="(v1: =&gt; Option[E])scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B]">f</a><span class="delimiter">(</span><span title="object None">None</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="C" id="204301">x</a><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="B" id="204303">y</a><span class="delimiter">)</span><span class="delimiter">)</span>     =&gt; <span title="(_1: C, _2: B)(C, B)" class="delimiter">(</span><a href="#204301" title="C">x</a>, <a href="#204303" title="B">y</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="#204244" title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)">go</a><span class="delimiter">(</span><a href="Liskov.scala.html#117568" title="(a: scalaz.Free[S,C])scalaz.Free.Source[E,C]">ev</a><span class="delimiter">(</span><a href="#23009" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span>, <a href="#204239" title="scalaz.Free.Sink[Option[E],B]">sink</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Feed the given stream to this `Source`. */</span>
  <span class="keyword">def</span> <a title="[E, C &gt;: A](ss: Stream[E])(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]])C" id="117117">feed</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117120">E</a>, <a title="&gt;: A &lt;: Any" id="117121">C</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="Stream[E]" id="204311">ss</a>: <span title="Stream[E]">Stream</span><span class="delimiter">[</span>E<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]]" id="204312">ev</a>: Free<span class="delimiter">[</span>S, C<span class="delimiter">]</span> <a href="Liskov.scala.html#10148" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]]">&lt;~&lt;</a> Sink<span class="delimiter">[</span>E, C<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#117121" title="C">C</a> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(snk: scalaz.Free.Sink[E,C], rest: Stream[E])C" id="204316">go</a><span class="delimiter">(</span><a title="scalaz.Free.Sink[E,C]" id="204317">snk</a>: <a href="#23009" title="scalaz.Free.Sink[E,C]">Sink</a><span class="delimiter">[</span>E, C<span class="delimiter">]</span>, <a title="Stream[E]" id="204318">rest</a>: <span title="Stream[E]">Stream</span><span class="delimiter">[</span>E<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#117121" title="C">C</a> = <span title="(_1: Stream[E], _2: scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C])(Stream[E], scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C])" class="delimiter">(</span><a href="#204318" title="Stream[E]">rest</a>, <a href="#204317" title="scalaz.Free.Sink[E,C]">snk</a>.<a href="#117068" title="=&gt; scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C]">resume</a><span class="delimiter">)</span> <span title="C" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="C" class="delimiter">(</span><a title="E" id="204353">x</a> <a href="#204335" title="(xs: scala.collection.immutable.Stream[E])Option[(E, scala.collection.immutable.Stream[E])]">#::</a> <a title="scala.collection.immutable.Stream[E]" id="204354">xs</a>, -\/<span class="delimiter">(</span><a title="=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C]" id="204356">f</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#204316" title="(snk: scalaz.Free.Sink[E,C], rest: Stream[E])C">go</a><span class="delimiter">(</span><a href="#204356" title="(v1: =&gt; E)scalaz.Free[[+x]=&gt; E =&gt; x,C]">f</a><span class="delimiter">(</span><a href="#204353" title="E">x</a><span class="delimiter">)</span>, <a href="#204354" title="scala.collection.immutable.Stream[E]">xs</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="C" class="delimiter">(</span><a href="#204361" title="(x: scala.collection.immutable.Stream[E])Some[scala.collection.immutable.Stream[E]]">Stream</a><span class="delimiter">(</span><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C]" id="204381">f</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#204316" title="(snk: scalaz.Free.Sink[E,C], rest: Stream[E])C">go</a><span class="delimiter">(</span><a href="#204381" title="(v1: =&gt; E)scalaz.Free[[+x]=&gt; E =&gt; x,C]">f</a><span class="delimiter">(</span>sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="java.lang.String(&quot;No more values.&quot;)" class="string">&quot;No more values.&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="(xs: Nothing*)scala.collection.immutable.Stream[Nothing]">Stream</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="C" class="delimiter">(</span>_, \/-<span class="delimiter">(</span><a title="C" id="204393">r</a><span class="delimiter">)</span><span class="delimiter">)</span>       =&gt; <a href="#204393" title="C">r</a>
    <span class="delimiter">}</span>
    <a href="#204316" title="(snk: scalaz.Free.Sink[E,C], rest: Stream[E])C">go</a><span class="delimiter">(</span><a href="Liskov.scala.html#117568" title="(a: scalaz.Free[S,C])scalaz.Free.Sink[E,C]">ev</a><span class="delimiter">(</span><a href="#23009" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span>, <a href="#204311" title="Stream[E]">ss</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Feed the given source to this `Sink`. */</span>
  <span class="keyword">def</span> <a title="[E, B, C &gt;: A](source: scalaz.Free.Source[E,B])(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]])(C, B)" id="117122">drain</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117126">E</a>, <a title="&gt;: Nothing &lt;: Any" id="117127">B</a>, <a title="&gt;: A &lt;: Any" id="117128">C</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Source[E,B]" id="204395">source</a>: <a href="#23009" title="scalaz.Free.Source[E,B]">Source</a><span class="delimiter">[</span>E, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]]" id="204396">ev</a>: Free<span class="delimiter">[</span>S, C<span class="delimiter">]</span> <a href="Liskov.scala.html#10148" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]]">&lt;~&lt;</a> Sink<span class="delimiter">[</span>E, C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(C, B)" class="delimiter">(</span>C, B<span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(src: scalaz.Free.Source[E,B], snk: scalaz.Free.Sink[E,C])(C, B)" id="204400">go</a><span class="delimiter">(</span><a title="scalaz.Free.Source[E,B]" id="204401">src</a>: <a href="#23009" title="scalaz.Free.Source[E,B]">Source</a><span class="delimiter">[</span>E, B<span class="delimiter">]</span>, <a title="scalaz.Free.Sink[E,C]" id="204402">snk</a>: <a href="#23009" title="scalaz.Free.Sink[E,C]">Sink</a><span class="delimiter">[</span>E, C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(C, B)" class="delimiter">(</span>C, B<span class="delimiter">)</span> = <span title="(_1: scalaz.\/[(E, scalaz.Free[[+x](E, x),B]),B], _2: scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C])(scalaz.\/[(E, scalaz.Free[[+x](E, x),B]),B], scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C])" class="delimiter">(</span><a href="#204401" title="scalaz.Free.Source[E,B]">src</a>.<a href="#117068" title="=&gt; scalaz.\/[(E, scalaz.Free[[+x](E, x),B]),B]">resume</a>, <a href="#204402" title="scalaz.Free.Sink[E,C]">snk</a>.<a href="#117068" title="=&gt; scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C]">resume</a><span class="delimiter">)</span> <span title="(C, B)" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>-\/<span class="delimiter">(</span><span class="delimiter">(</span><a title="E" id="204414">e</a>, <a title="scalaz.Free[[+x](E, x),B]" id="204415">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C]" id="204417">f</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#204400" title="(src: scalaz.Free.Source[E,B], snk: scalaz.Free.Sink[E,C])(C, B)">go</a><span class="delimiter">(</span><a href="#204415" title="scalaz.Free[[+x](E, x),B]">c</a>, <a href="#204417" title="(v1: =&gt; E)scalaz.Free[[+x]=&gt; E =&gt; x,C]">f</a><span class="delimiter">(</span><a href="#204414" title="E">e</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>-\/<span class="delimiter">(</span><span class="delimiter">(</span><a title="E" id="204424">e</a>, <a title="scalaz.Free[[+x](E, x),B]" id="204425">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="C" id="204427">y</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#204400" title="(src: scalaz.Free.Source[E,B], snk: scalaz.Free.Sink[E,C])(C, B)">go</a><span class="delimiter">(</span><a href="#204425" title="scalaz.Free[[+x](E, x),B]">c</a>, <a href="#11718" title="object scalaz.Sink">Sink</a>.<a href="#52854" title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]">sinkMonad</a><span title="scalaz.Monad[[x]scalaz.Free[[+x]=&gt; E =&gt; x,x]]" class="delimiter">[</span><a href="#117126" title="E">E</a><span class="delimiter">]</span>.<a href="Pointed.scala.html#43396" title="(a: =&gt; C)scalaz.Free[[+x]=&gt; E =&gt; x,C]">pure</a><span class="delimiter">(</span><a href="#204427" title="C">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Nothing" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="B" id="204438">x</a><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C]" id="204440">f</a><span class="delimiter">)</span><span class="delimiter">)</span>      =&gt; sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="java.lang.String(&quot;Not enough values in source.&quot;)" class="string">&quot;Not enough values in source.&quot;</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="B" id="204444">x</a><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="C" id="204446">y</a><span class="delimiter">)</span><span class="delimiter">)</span>     =&gt; <span title="(_1: C, _2: B)(C, B)" class="delimiter">(</span><a href="#204446" title="C">y</a>, <a href="#204444" title="B">x</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#204400" title="(src: scalaz.Free.Source[E,B], snk: scalaz.Free.Sink[E,C])(C, B)">go</a><span class="delimiter">(</span><a href="#204395" title="scalaz.Free.Source[E,B]">source</a>, <a href="Liskov.scala.html#117568" title="(a: scalaz.Free[S,C])scalaz.Free.Sink[E,C]">ev</a><span class="delimiter">(</span><a href="#23009" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="object scalaz.Trampoline" id="13434">Trampoline</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#23771" title="scalaz.TrampolineInstances">TrampolineInstances</a>

<span class="keyword">trait</span> <a title="trait TrampolineInstances extends java.lang.Object with ScalaObject" id="23771">TrampolineInstances</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="TrampolineInstances extends scalaz.Monad[scalaz.Free.Trampoline] with scalaz.Copointed[scalaz.Free.Trampoline]" id="52847">trampolineMonad</a>: <a href="#117635" title="TrampolineInstances extends scalaz.Monad[scalaz.Free.Trampoline] with scalaz.Copointed[scalaz.Free.Trampoline]">Monad</a><span class="delimiter">[</span>Trampoline<span class="delimiter">]</span> <span class="keyword">with</span> Copointed<span class="delimiter">[</span>Trampoline<span class="delimiter">]</span> = <a href="#204458" title="java.lang.Object with scalaz.Monad[scalaz.Free.Trampoline] with scalaz.Copointed[scalaz.Free.Trampoline]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.Monad[scalaz.Free.Trampoline] with scalaz.Copointed[scalaz.Free.Trampoline]" id="204458">Monad</a><span class="delimiter">[</span>Trampoline<span class="delimiter">]</span> <span class="keyword">with</span> <a href="Copointed.scala.html#16847" title="scalaz.Copointed[scalaz.Free.Trampoline]">Copointed</a><span class="delimiter">[</span>Trampoline<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free[Function0,A]" id="204510">point</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="204512">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="204521">a</a>: =&gt; A<span class="delimiter">)</span> = <a href="#52804" title="[S[+_], A](value: =&gt; A)(implicit S: scalaz.Pointed[S])scalaz.Free[S,A]">return_</a><span title="(value: =&gt; A)(implicit S: scalaz.Pointed[Function0])scalaz.Free[Function0,A]" class="delimiter">[</span><span title="Function0">Function0</span>, <a href="#204512" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#52879" title="function0Instance extends java.lang.Object with scalaz.Traverse[Function0] with scalaz.Monad[Function0] with scalaz.Copointed[Function0]" class="delimiter">(</a><a href="#204521" title="=&gt; A">a</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[A, B](ta: scalaz.Free.Trampoline[A])(f: A =&gt; scalaz.Free.Trampoline[B])scalaz.Free[Function0,B]" id="204513">bind</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="204516">A</a>, <a title="&gt;: Nothing &lt;: Any" id="204517">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Trampoline[A]" id="204869">ta</a>: <a href="#23009" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free.Trampoline[B]" id="204870">f</a>: A =&gt; Trampoline<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#204869" title="scalaz.Free.Trampoline[A]">ta</a> <a href="#117065" title="(f: A =&gt; scalaz.Free[Function0,B])scalaz.Free[Function0,B]">flatMap</a> <a href="#204870" title="A =&gt; scalaz.Free.Trampoline[B]">f</a>
    <span class="keyword">def</span> <a title="[A](p: scalaz.Free.Trampoline[A])A" id="204518">copoint</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="204520">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Trampoline[A]" id="204893">p</a>: Free.<a href="#23009" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#204520" title="A">A</a> = <span class="delimiter">{</span>
      <span class="keyword">import</span> std.<a href="std/Function.scala.html#25964" title="object scalaz.std.function">function</a>.function0Instance
      <a href="#204893" title="scalaz.Free.Trampoline[A]">p</a>.<a href="#117097" title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[Function0,A],scalaz.Free.Trampoline[A]])A">run</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="object scalaz.Sink" id="11718">Sink</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#15143" title="scalaz.SinkInstances">SinkInstances</a>

<span class="keyword">trait</span> <a title="trait SinkInstances extends java.lang.Object with ScalaObject" id="15143">SinkInstances</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]" id="52854">sinkMonad</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="52856">S</a><span class="delimiter">]</span>: <a href="Monad.scala.html#22172" title="scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Sink<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> =
    <a href="#205220" title="java.lang.Object with scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]" id="205220">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Sink<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free.Suspend[[+x]=&gt; S =&gt; x,A]" id="205278">point</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="205280">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="205286">a</a>: =&gt; A<span class="delimiter">)</span> =
        <a href="#195779" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: =&gt; S =&gt; scalaz.Free[[+x]=&gt; S =&gt; x,A])(implicit evidence$2: scalaz.Functor[[+x]=&gt; S =&gt; x])scalaz.Free.Suspend[[+x]=&gt; S =&gt; x,A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; S<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x]=&gt; S =&gt; x">f</span>, <a href="#205280" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#52886" title="FunctionInstances extends scalaz.Monad[[a]=&gt; S =&gt; a] with scalaz.Zip[[a]=&gt; S =&gt; a] with scalaz.Unzip[[a]=&gt; S =&gt; a] with scalaz.Distributive[[a]=&gt; S =&gt; a]" class="delimiter">(</a><a title="=&gt; S" id="205302">s</a> =&gt;
          <a href="#195785" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[[+x]=&gt; S =&gt; x])scalaz.Free.Return[[+x]=&gt; S =&gt; x,A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; S<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x]=&gt; S =&gt; x">f</span>, <a href="#205280" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#52886" title="FunctionInstances extends scalaz.Monad[[a]=&gt; S =&gt; a] with scalaz.Zip[[a]=&gt; S =&gt; a] with scalaz.Unzip[[a]=&gt; S =&gt; a] with scalaz.Distributive[[a]=&gt; S =&gt; a]" class="delimiter">(</a><a href="#205286" title="=&gt; A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="[A, B](s: scalaz.Free.Sink[S,A])(f: A =&gt; scalaz.Free.Sink[S,B])scalaz.Free[[+x]=&gt; S =&gt; x,B]" id="205281">bind</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="205284">A</a>, <a title="&gt;: Nothing &lt;: Any" id="205285">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Sink[S,A]" id="206110">s</a>: <a href="#23009" title="scalaz.Free.Sink[S,A]">Sink</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free.Sink[S,B]" id="206111">f</a>: A =&gt; Sink<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#206110" title="scalaz.Free.Sink[S,A]">s</a> <a href="#117065" title="(f: A =&gt; scalaz.Free[[+x]=&gt; S =&gt; x,B])scalaz.Free[[+x]=&gt; S =&gt; x,B]">flatMap</a> <a href="#206111" title="A =&gt; scalaz.Free.Sink[S,B]">f</a>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="object scalaz.Source" id="23568">Source</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#14354" title="scalaz.SourceInstances">SourceInstances</a>

<span class="keyword">trait</span> <a title="trait SourceInstances extends java.lang.Object with ScalaObject" id="14354">SourceInstances</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]" id="52858">sourceMonad</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="52860">S</a><span class="delimiter">]</span>: <a href="Monad.scala.html#22172" title="scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Source<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> =
    <a href="#206162" title="java.lang.Object with scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]" id="206162">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Source<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free.Return[[+x](S, x),A]" id="206220">point</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="206222">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="206228">a</a>: =&gt; A<span class="delimiter">)</span> = <a href="#195785" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[[+x](S, x)])scalaz.Free.Return[[+x](S, x),A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>S, x<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x](S, x)">f</span>, <a href="#206222" title="A">A</a><span class="delimiter">]</span><a href="std/Tuple.scala.html#54309" title="TupleInstances0 extends scalaz.Traverse[[x](S, x)] with scalaz.Comonad[[x](S, x)]" class="delimiter">(</a><a href="#206228" title="=&gt; A">a</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="[A, B](s: scalaz.Free.Source[S,A])(f: A =&gt; scalaz.Free.Source[S,B])scalaz.Free[[+x](S, x),B]" id="206223">bind</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="206226">A</a>, <a title="&gt;: Nothing &lt;: Any" id="206227">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Source[S,A]" id="206908">s</a>: <a href="#23009" title="scalaz.Free.Source[S,A]">Source</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free.Source[S,B]" id="206909">f</a>: A =&gt; Source<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#206908" title="scalaz.Free.Source[S,A]">s</a> <a href="#117065" title="(f: A =&gt; scalaz.Free[[+x](S, x),B])scalaz.Free[[+x](S, x),B]">flatMap</a> <a href="#206909" title="A =&gt; scalaz.Free.Source[S,B]">f</a>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">// Trampoline, Sink, and Source are type aliases. We need to add their type class instances</span>
<span class="comment">// to Free to be part of the implicit scope.</span>
<span class="keyword">trait</span> <a title="trait FreeInstances extends java.lang.Object with scalaz.TrampolineInstances with scalaz.SinkInstances with scalaz.SourceInstances with ScalaObject" id="20537">FreeInstances</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#23771" title="scalaz.TrampolineInstances">TrampolineInstances</a> <span class="keyword">with</span> <a href="#15143" title="scalaz.SinkInstances">SinkInstances</a> <span class="keyword">with</span> <a href="#14354" title="scalaz.SourceInstances">SourceInstances</a> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S[+_]](implicit evidence$5: scalaz.Functor[S])scalaz.Monad[[x]scalaz.Free[S,x]]" id="117596">freeMonad</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="52852">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="117600">_</a><span class="delimiter">]</span>:Functor<span class="delimiter">]</span>: <a href="Monad.scala.html#22172" title="scalaz.Monad[[x]scalaz.Free[S,x]]">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Free<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> =
    <a href="#206959" title="java.lang.Object with scalaz.Monad[[x]scalaz.Free[S,x]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.Monad[[x]scalaz.Free[S,x]]" id="206959">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Free<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free.Return[S,A]" id="207017">point</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="207019">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="207030">a</a>: =&gt; A<span class="delimiter">)</span> = <a href="#195785" title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><a href="#117596" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#207030" title="=&gt; A">a</a><span class="delimiter">)</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](fa: scalaz.Free[S,A])(f: A =&gt; B)scalaz.Free[S,B]" id="207020">map</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="207023">A</a>, <a title="&gt;: Nothing &lt;: Any" id="207024">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="207414">fa</a>: <a href="#23009" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="207415">f</a>: A =&gt; B<span class="delimiter">)</span> = <a href="#207414" title="scalaz.Free[S,A]">fa</a> <a href="#117059" title="(f: A =&gt; B)scalaz.Free[S,B]">map</a> <a href="#207415" title="A =&gt; B">f</a>
      <span class="keyword">def</span> <a title="[A, B](a: scalaz.Free[S,A])(f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]" id="207025">bind</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="207028">A</a>, <a title="&gt;: Nothing &lt;: Any" id="207029">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="207462">a</a>: <a href="#23009" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free[S,B]" id="207463">f</a>: A =&gt; Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#207462" title="scalaz.Free[S,A]">a</a> <a href="#117065" title="(f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]">flatMap</a> <a href="#207463" title="A =&gt; scalaz.Free[S,B]">f</a>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait FreeFunctions extends java.lang.Object with ScalaObject" id="22595">FreeFunctions</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="comment">/** Collapse a trampoline to a single step. */</span>
  <span class="keyword">def</span> <a title="[A](r: scalaz.Free.Trampoline[A])scalaz.Free.Trampoline[A]" id="52801">reset</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="52803">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Trampoline[A]" id="207532">r</a>: <a href="#23009" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23009" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span> <span class="keyword">val</span> <a title="A" id="207535">a</a> = <a href="#207532" title="scalaz.Free.Trampoline[A]">r</a>.<a href="#117097" title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[Function0,A],scalaz.Free.Trampoline[A]])A">run</a>; <a href="#52804" title="(value: =&gt; A)(implicit S: scalaz.Pointed[Function0])scalaz.Free[Function0,A]">return_</a><a href="std/Function.scala.html#52879" title="function0Instance extends java.lang.Object with scalaz.Traverse[Function0] with scalaz.Monad[Function0] with scalaz.Copointed[Function0]" class="delimiter">(</a><a href="#207535" title="A">a</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="comment">/** Suspend the given computation in a single step. */</span>
  <span class="keyword">def</span> <a title="[S[+_], A](value: =&gt; A)(implicit S: scalaz.Pointed[S])scalaz.Free[S,A]" id="52804">return_</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="52807">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="154394">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="52808">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="154392">value</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Pointed[S]" id="154393">S</a>: <a href="Pointed.scala.html#9812" title="scalaz.Pointed[S]">Pointed</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23009" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> =
    <a href="#195779" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]" class="delimiter">[</span><a href="#52807" title="S">S</a>, <a href="#52808" title="A">A</a><span class="delimiter">]</span><a href="#154393" title="scalaz.Pointed[S]" class="delimiter">(</a><a href="#154393" title="scalaz.Pointed[S]">S</a>.<a href="Pointed.scala.html#43393" title="(a: =&gt; scalaz.Free.Return[S,A])S[scalaz.Free.Return[S,A]]">point</a><span class="delimiter">(</span><a href="#195785" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]" class="delimiter">[</span><a href="#52807" title="S">S</a>, <a href="#52808" title="A">A</a><span class="delimiter">]</span><a href="#154393" title="scalaz.Pointed[S]" class="delimiter">(</a><a href="#154392" title="=&gt; A">value</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[S[+_], A](value: =&gt; scalaz.Free[S,A])(implicit S: scalaz.Pointed[S])scalaz.Free[S,A]" id="52809">suspend</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="52812">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="154217">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="52813">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.Free[S,A]" id="154215">value</a>: =&gt; Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Pointed[S]" id="154216">S</a>: <a href="Pointed.scala.html#9812" title="scalaz.Pointed[S]">Pointed</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23009" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> =
    <a href="#195779" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]" class="delimiter">[</span><a href="#52812" title="S">S</a>, <a href="#52813" title="A">A</a><span class="delimiter">]</span><a href="#154216" title="scalaz.Pointed[S]" class="delimiter">(</a><a href="#154216" title="scalaz.Pointed[S]">S</a>.<a href="Pointed.scala.html#43393" title="(a: =&gt; scalaz.Free[S,A])S[scalaz.Free[S,A]]">point</a><span class="delimiter">(</span><a href="#154215" title="=&gt; scalaz.Free[S,A]">value</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** A trampoline step that doesn't do anything. */</span>
  <span class="keyword">def</span> <a title="=&gt; scalaz.Free.Trampoline[Unit]" id="52814">pause</a>: <a href="#23009" title="scalaz.Free.Trampoline[Unit]">Trampoline</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> =
    <a href="#52804" title="(value: =&gt; Unit)(implicit S: scalaz.Pointed[Function0])scalaz.Free[Function0,Unit]">return_</a><a href="std/Function.scala.html#52879" title="function0Instance extends java.lang.Object with scalaz.Traverse[Function0] with scalaz.Monad[Function0] with scalaz.Copointed[Function0]" class="delimiter">(</a><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** A source that produces the given value. */</span>
  <span class="keyword">def</span> <a title="[A](a: A)scalaz.Free.Source[A,Unit]" id="52815">produce</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="52817">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="209604">a</a>: <a href="#52817" title="A">A</a><span class="delimiter">)</span>: <a href="#23009" title="scalaz.Free.Source[A,Unit]">Source</a><span class="delimiter">[</span>A, Unit<span class="delimiter">]</span> =
    <a href="#195779" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: (A, scalaz.Free[[+x](A, x),Unit]))(implicit evidence$2: scalaz.Functor[[+x](A, x)])scalaz.Free.Suspend[[+x](A, x),Unit]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>A, x<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x](A, x)">f</span>, <span title="Unit">Unit</span><span class="delimiter">]</span><a href="std/Tuple.scala.html#54309" title="TupleInstances0 extends scalaz.Traverse[[x](A, x)] with scalaz.Comonad[[x](A, x)]" class="delimiter">(</a><a href="#209604" title="(x: A)ArrowAssoc[A]">a</a> <span title="(y: scalaz.Free.Return[[+x](A, x),Unit])(A, scalaz.Free.Return[[+x](A, x),Unit])">-&gt;</span> <a href="#195785" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: Unit)(implicit evidence$1: scalaz.Functor[[+x](A, x)])scalaz.Free.Return[[+x](A, x),Unit]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>A, x<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x](A, x)">f</span>, <span title="Unit">Unit</span><span class="delimiter">]</span><a href="std/Tuple.scala.html#54309" title="TupleInstances0 extends scalaz.Traverse[[x](A, x)] with scalaz.Comonad[[x](A, x)]" class="delimiter">(</a><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** A sink that waits for a single value and returns it. */</span>
  <span class="keyword">def</span> <a title="[A]=&gt; scalaz.Free.Sink[A,A]" id="52818">await</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="52820">A</a><span class="delimiter">]</span>: <a href="#23009" title="scalaz.Free.Sink[A,A]">Sink</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="#195779" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: =&gt; A =&gt; scalaz.Free[[+x]=&gt; A =&gt; x,A])(implicit evidence$2: scalaz.Functor[[+x]=&gt; A =&gt; x])scalaz.Free.Suspend[[+x]=&gt; A =&gt; x,A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; A<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x]=&gt; A =&gt; x">f</span>, <a href="#52820" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#52886" title="FunctionInstances extends scalaz.Monad[[a]=&gt; A =&gt; a] with scalaz.Zip[[a]=&gt; A =&gt; a] with scalaz.Unzip[[a]=&gt; A =&gt; a] with scalaz.Distributive[[a]=&gt; A =&gt; a]" class="delimiter">(</a><a title="=&gt; A" id="211271">a</a> =&gt; <a href="#195785" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[[+x]=&gt; A =&gt; x])scalaz.Free.Return[[+x]=&gt; A =&gt; x,A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; A<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x]=&gt; A =&gt; x">f</span>, <a href="#52820" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#52886" title="FunctionInstances extends scalaz.Monad[[a]=&gt; A =&gt; a] with scalaz.Zip[[a]=&gt; A =&gt; a] with scalaz.Unzip[[a]=&gt; A =&gt; a] with scalaz.Distributive[[a]=&gt; A =&gt; a]" class="delimiter">(</a><a href="#211271" title="=&gt; A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>


        </pre>
    </body>
</html>