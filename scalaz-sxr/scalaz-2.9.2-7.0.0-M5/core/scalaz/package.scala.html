<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/scalaz/package.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * '''Scalaz''': Type classes and pure functional data structures for Scala.
 *
 * This package, [[scalaz]], contains:
 *  - type class definitions
 *  - data structures
 *  - related functions
 *
 * Type class instances and other functions related to the Scala and Java standard library
 * are in scalaz.[[scalaz.std]]
 *
 * Implicit conversions and wrapper classes that provide a more convenient syntax for accessing
 * the functionality of the library are in scalaz.[[scalaz.syntax]].
 *
 * '''Type Classes Index'''
 *
 *  - [[scalaz.Semigroup]]
 *  - [[scalaz.Monoid]] extends [[scalaz.Semigroup]]
 *  - [[scalaz.Group]] extends [[scalaz.Monoid]]
 *  - [[scalaz.Equal]]
 *  - [[scalaz.Length]]
 *  - [[scalaz.Show]]
 *  - [[scalaz.Order]] extends [[scalaz.Equal]]
 *
 *  - [[scalaz.MetricSpace]]
 *  - [[scalaz.Plus]]
 *  - [[scalaz.Each]]
 *  - [[scalaz.Index]]
 *  - [[scalaz.Functor]]
 *  - [[scalaz.Pointed]] extends [[scalaz.Functor]]
 *  - [[scalaz.Contravariant]]
 *  - [[scalaz.Copointed]] extends [[scalaz.Functor]]
 *  - [[scalaz.Apply]] extends [[scalaz.Functor]]
 *  - [[scalaz.Applicative]] extends [[scalaz.Apply]] with [[scalaz.Pointed]]
 *  - [[scalaz.Bind]] extends [[scalaz.Apply]]
 *  - [[scalaz.Monad]] extends [[scalaz.Applicative]] with [[scalaz.Bind]]
 *  - [[scalaz.Cojoin]]
 *  - [[scalaz.Cobind]]
 *  - [[scalaz.Comonad]] extends [[scalaz.Copointed]] with [[scalaz.Cojoin]] with [[scalaz.Cobind]]
 *  - [[scalaz.PlusEmpty]] extends [[scalaz.Plus]]
 *  - [[scalaz.ApplicativePlus]] extends [[scalaz.Applicative]] with [[scalaz.PlusEmpty]]
 *  - [[scalaz.MonadPlus]] extends [[scalaz.Monad]] with [[scalaz.ApplicativePlus]]
 *  - [[scalaz.Foldable]]
 *  - [[scalaz.Traverse]] extends [[scalaz.Functor]] with [[scalaz.Foldable]]
 *
 *  - [[scalaz.Bifunctor]]
 *  - [[scalaz.Bitraverse]] extends [[scalaz.Bifunctor]]
 *  - [[scalaz.ArrId]]
 *  - [[scalaz.Compose]]
 *  - [[scalaz.Category]] extends [[scalaz.ArrId]] with [[scalaz.Compose]]
 *  - [[scalaz.Arrow]] extends [[scalaz.Category]]
 *
 *  '''Data Structures Index'''
 *  - [[scalaz.Validation]] Represent computations that may succeed or fail, accumulating multiple errors.
 *  - [[scalaz.NonEmptyList]] A list containing at least one element.
 *  - [[scalaz.DList]] A difference list, supporting efficient append and prepend.
 *  - [[scalaz.EphemeralStream]] A stream that holds weak references to its elements, and recomputes them if needed
 *    if reclaimed by the garbage collector.
 *  - [[scalaz.Heap]] A priority queue, implemented with bootstrapped skew binomial heaps.
 *  - [[scalaz.Endo]] Represents functions from `A =&gt; A`.
 *  - [[scalaz.FingerTree]] A tree containing elements at it's leaves, and measures at the nodes. Can be adapted to
 *    various purposes by choosing a different measure, for example [[scalaz.IndSeq]] and [[scalaz.OrdSeq]].
 *  - [[scalaz.LensT]] Composable, functional alternative to getters and setters
 *  - [[scalaz.Tree]] A multiway tree. Each node contains a single element, and a `Stream` of sub-trees.
 *  - [[scalaz.TreeLoc]] A cursor over a [[scalaz.Tree]].
 *  - [[scalaz.Zipper]] A functional cursor over a List.
 *
 *  - [[scalaz.Kleisli]] Represents a function `A =&gt; M[B]`, allowing chaining. Also known, and aliased, as `scalaz.ReaderT`.
 *  - [[scalaz.StateT]] Computations that modify state.
 *  - [[scalaz.WriterT]] Computations that log a value
 *  - [[scalaz.OptionT]] Represents computations of type `F[Option[A]]`
 *  - [[scalaz.EitherT]] Represents computations of type `F[A \/ B]`
 */</span>
<span class="keyword">package</span> <span class="keyword">object</span> <a title="object scalaz.package" id="12891">scalaz</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="keyword">import</span> <a href="Id.scala.html#11472" title="object scalaz.Id">Id</a>._

  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="package extends scalaz.Traverse[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]" id="38787">idInstance</a>: <a href="#42465" title="package extends scalaz.Traverse[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]">Traverse</a><span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Each<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Monad<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Comonad<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Cojoin<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Distributive<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Zip<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Unzip<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Cozip<span class="delimiter">[</span>Id<span class="delimiter">]</span> = <a href="Id.scala.html#11472" title="object scalaz.Id">Id</a>.<a href="Id.scala.html#42462" title="=&gt; scalaz.Traverse[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]">id</a>

  <span class="keyword">type</span> <a title="package[T] extends AnyRef" id="38789">Tagged</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38790">T</a><span class="delimiter">]</span> = <a href="#64411" title="package extends AnyRef" class="delimiter">{</a><span class="keyword">type</span> Tag = T<span class="delimiter">}</span>

  <span class="comment">/**
   * Tag a type `T` with `Tag`. The resulting type is a subtype of `T`.
   *
   * The resulting type is used to discriminate between type class instances.
   *
   * @see [[scalaz.Tag]] and [[scalaz.Tags]]
   *
   * Credit to Miles Sabin for the idea.
   */</span>
  <span class="keyword">type</span> <a title="package[T, Tag] extends T with scalaz.package.Tagged[Tag]" id="38791">@@</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38792">T</a>, <a title="&gt;: Nothing &lt;: Any" id="38793">Tag</a><span class="delimiter">]</span> = <a href="#64416" title="package extends T with scalaz.package.Tagged[Tag]">T</a> <span class="keyword">with</span> Tagged<span class="delimiter">[</span>Tag<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[-F[_], +G[_]]scalaz.NaturalTransformation[F,G]" id="38794">~&gt;</a><span class="delimiter">[</span>-<a title="[_]&gt;: Nothing &lt;: Any" id="38795">F</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="148047">_</a><span class="delimiter">]</span>, +<a title="[_]&gt;: Nothing &lt;: Any" id="38796">G</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="148048">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="NaturalTransformation.scala.html#16934" title="scalaz.NaturalTransformation[F,G]">NaturalTransformation</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[+F[_], -G[_]]scalaz.NaturalTransformation[G,F]" id="38797">&lt;~</a><span class="delimiter">[</span>+<a title="[_]&gt;: Nothing &lt;: Any" id="38798">F</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="369504">_</a><span class="delimiter">]</span>, -<a title="[_]&gt;: Nothing &lt;: Any" id="38799">G</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="369505">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="NaturalTransformation.scala.html#16934" title="scalaz.NaturalTransformation[G,F]">NaturalTransformation</a><span class="delimiter">[</span>G, F<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[-F[_,_], +G[_,_]]scalaz.BiNaturalTransformation[F,G]" id="38800">~~&gt;</a><span class="delimiter">[</span>-<a title="[_, _]&gt;: Nothing &lt;: Any" id="38801">F</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="294826">_</a>,<a title="&gt;: Nothing &lt;: Any" id="294827">_</a><span class="delimiter">]</span>, +<a title="[_, _]&gt;: Nothing &lt;: Any" id="38802">G</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="294828">_</a>,<a title="&gt;: Nothing &lt;: Any" id="294829">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="NaturalTransformation.scala.html#17546" title="scalaz.BiNaturalTransformation[F,G]">BiNaturalTransformation</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="Nothing" id="38803">⊥</a> = <span title="Nothing">Nothing</span>
  <span class="keyword">type</span> <a title="Any" id="38804">⊤</a> = <span title="Any">Any</span>

  <span class="keyword">type</span> <a title="[G[_], F[_]]scalaz.MonadPartialOrder[G,F]" id="38805">|&gt;=|</a><span class="delimiter">[</span><a title="[_]&gt;: Nothing &lt;: Any" id="38806">G</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="369506">_</a><span class="delimiter">]</span>, <a title="[_]&gt;: Nothing &lt;: Any" id="38807">F</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="369507">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="MonadTrans.scala.html#16742" title="scalaz.MonadPartialOrder[G,F]">MonadPartialOrder</a><span class="delimiter">[</span>G, F<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[F[+_], E, +A]scalaz.Kleisli[F,E,A]" id="38808">ReaderT</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="38809">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="114614">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="38810">E</a>, +<a title="&gt;: Nothing &lt;: Any" id="38811">A</a><span class="delimiter">]</span> = <a href="Kleisli.scala.html#23372" title="scalaz.Kleisli[F,E,A]">Kleisli</a><span class="delimiter">[</span>F, E, A<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[E, A]scalaz.Kleisli[Option,E,A]" id="38812">=?&gt;</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38813">E</a>, <a title="&gt;: Nothing &lt;: Any" id="38814">A</a><span class="delimiter">]</span> = <a href="Kleisli.scala.html#23372" title="scalaz.Kleisli[Option,E,A]">Kleisli</a><span class="delimiter">[</span>Option, E, A<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[E, +A]scalaz.package.ReaderT[scalaz.Id.Id,E,A]" id="38815">Reader</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38816">E</a>, +<a title="&gt;: Nothing &lt;: Any" id="38817">A</a><span class="delimiter">]</span> = <a href="Kleisli.scala.html#23372" title="scalaz.package.ReaderT[scalaz.Id.Id,E,A]">ReaderT</a><span class="delimiter">[</span>Id, E, A<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[+W, +A]scalaz.WriterT[scalaz.Id.Id,W,A]" id="38818">Writer</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="38819">W</a>, +<a title="&gt;: Nothing &lt;: Any" id="38820">A</a><span class="delimiter">]</span> = <a href="WriterT.scala.html#12023" title="scalaz.WriterT[scalaz.Id.Id,W,A]">WriterT</a><span class="delimiter">[</span>Id, W, A<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[+W, +A]scalaz.UnwriterT[scalaz.Id.Id,W,A]" id="38821">Unwriter</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="38822">W</a>, +<a title="&gt;: Nothing &lt;: Any" id="38823">A</a><span class="delimiter">]</span> = <a href="UnwriterT.scala.html#15806" title="scalaz.UnwriterT[scalaz.Id.Id,W,A]">UnwriterT</a><span class="delimiter">[</span>Id, W, A<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="object scalaz.package.Reader" id="38824">Reader</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[E, A](f: E =&gt; A)scalaz.package.Reader[E,A]" id="114616">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="114619">E</a>, <a title="&gt;: Nothing &lt;: Any" id="114620">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="E =&gt; A" id="114621">f</a>: E =&gt; A<span class="delimiter">)</span>: <a href="Kleisli.scala.html#23372" title="scalaz.package.Reader[E,A]">Reader</a><span class="delimiter">[</span>E, A<span class="delimiter">]</span> = <a href="Kleisli.scala.html#52822" title="[M[+_], A, B](f: A =&gt; M[B])scalaz.Kleisli[M,A,B]">Kleisli</a><span title="(f: E =&gt; scalaz.Id.Id[A])scalaz.Kleisli[scalaz.Id.Id,E,A]" class="delimiter">[</span><a href="Id.scala.html#42459" title="scalaz.Id.Id">Id</a>, <a href="#114619" title="E">E</a>, <a href="#114620" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#114621" title="E =&gt; A">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object scalaz.package.Writer" id="38826">Writer</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[W, A](w: W, a: A)scalaz.WriterT[scalaz.Id.Id,W,A]" id="114631">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="114634">W</a>, <a title="&gt;: Nothing &lt;: Any" id="114635">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="W" id="114636">w</a>: <a href="#114634" title="W">W</a>, <a title="A" id="114637">a</a>: <a href="#114635" title="A">A</a><span class="delimiter">)</span>: <a href="WriterT.scala.html#12023" title="scalaz.WriterT[scalaz.Id.Id,W,A]">WriterT</a><span class="delimiter">[</span>Id, W, A<span class="delimiter">]</span> = <a href="WriterT.scala.html#111951" title="[F[+_], W, A](v: F[(W, A)])scalaz.WriterT[F,W,A]">WriterT</a><span title="(v: (W, A))scalaz.WriterT[scalaz.Id.Id,W,A]" class="delimiter">[</span><a href="Id.scala.html#42459" title="scalaz.Id.Id">Id</a>, <a href="#114634" title="W">W</a>, <a href="#114635" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="(_1: W, _2: A)(W, A)" class="delimiter">(</span><a href="#114636" title="W">w</a>, <a href="#114637" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object scalaz.package.Unwriter" id="38828">Unwriter</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[U, A](u: U, a: A)scalaz.UnwriterT[scalaz.Id.Id,U,A]" id="361545">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="361548">U</a>, <a title="&gt;: Nothing &lt;: Any" id="361549">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="U" id="361550">u</a>: <a href="#361548" title="U">U</a>, <a title="A" id="361551">a</a>: <a href="#361549" title="A">A</a><span class="delimiter">)</span>: <a href="UnwriterT.scala.html#15806" title="scalaz.UnwriterT[scalaz.Id.Id,U,A]">UnwriterT</a><span class="delimiter">[</span>Id, U, A<span class="delimiter">]</span> = <a href="UnwriterT.scala.html#357709" title="[F[+_], W, A](v: F[(W, A)])scalaz.UnwriterT[F,W,A]">UnwriterT</a><span title="(v: (U, A))scalaz.UnwriterT[scalaz.Id.Id,U,A]" class="delimiter">[</span><a href="Id.scala.html#42459" title="scalaz.Id.Id">Id</a>, <a href="#361548" title="U">U</a>, <a href="#361549" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="(_1: U, _2: A)(U, A)" class="delimiter">(</span><a href="#361550" title="U">u</a>, <a href="#361551" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A state transition, representing a function `S =&gt; (A, S)`. */</span>
  <span class="keyword">type</span> <a title="[S, +A]scalaz.StateT[scalaz.Id.Id,S,A]" id="38830">State</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38831">S</a>, +<a title="&gt;: Nothing &lt;: Any" id="38832">A</a><span class="delimiter">]</span> = <a href="StateT.scala.html#11747" title="scalaz.StateT[scalaz.Id.Id,S,A]">StateT</a><span class="delimiter">[</span>Id, S, A<span class="delimiter">]</span>

  <span class="comment">// important to define here, rather than at the top-level, to avoid Scala 2.9.2 bug</span>
  <span class="keyword">object</span> <a title="object scalaz.package.State" id="38833">State</a> <span title="ScalaObject" class="keyword">extends</span> <a href="State.scala.html#18788" title="scalaz.StateFunctions">StateFunctions</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[S, A](f: S =&gt; (S, A))scalaz.package.State[S,A]" id="86273">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="86276">S</a>, <a title="&gt;: Nothing &lt;: Any" id="86277">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S =&gt; (S, A)" id="86278">f</a>: S =&gt; <span class="delimiter">(</span>S, A<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="StateT.scala.html#11747" title="scalaz.package.State[S,A]">State</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> = <a href="#369527" title="java.lang.Object with scalaz.StateT[scalaz.Id.Id,S,A]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.StateT[scalaz.Id.Id,S,A]" id="369527">StateT</a><span class="delimiter">[</span>Id, S, A<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(s: S)(S, A)" id="369531">apply</a><span class="delimiter">(</span><a title="S" id="369532">s</a>: <a href="#86276" title="S">S</a><span class="delimiter">)</span> = <a href="#86278" title="(v1: S)(S, A)">f</a><span class="delimiter">(</span><a href="#369532" title="S">s</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[A, B]scalaz.StoreT[scalaz.Id.Id,A,B]" id="38835">Store</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38836">A</a>, <a title="&gt;: Nothing &lt;: Any" id="38837">B</a><span class="delimiter">]</span> = <a href="StoreT.scala.html#20819" title="scalaz.StoreT[scalaz.Id.Id,A,B]">StoreT</a><span class="delimiter">[</span>Id, A, B<span class="delimiter">]</span>
  <span class="comment">// flipped</span>
  <span class="keyword">type</span> <a title="[A, B]scalaz.package.Store[B,A]" id="38838">|--&gt;</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38839">A</a>, <a title="&gt;: Nothing &lt;: Any" id="38840">B</a><span class="delimiter">]</span> = <a href="StoreT.scala.html#20819" title="scalaz.package.Store[B,A]">Store</a><span class="delimiter">[</span>B, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="object scalaz.package.Store" id="38841">Store</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B](f: A =&gt; B, a: A)scalaz.package.Store[A,B]" id="128788">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="128791">A</a>, <a title="&gt;: Nothing &lt;: Any" id="128792">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="128793">f</a>: A =&gt; B, <a title="A" id="128794">a</a>: <a href="#128791" title="A">A</a><span class="delimiter">)</span>: <a href="StoreT.scala.html#20819" title="scalaz.package.Store[A,B]">Store</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> = <a href="StoreT.scala.html#20820" title="object scalaz.StoreT">StoreT</a>.<a href="StoreT.scala.html#128279" title="(a: A)(f: A =&gt; B)scalaz.package.Store[A,B]">store</a><span class="delimiter">(</span><a href="#128794" title="A">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#128793" title="A =&gt; B">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>


  <span class="keyword">type</span> <a title="[-R, +W, S, +A]scalaz.ReaderWriterStateT[scalaz.Id.Identity,R,W,S,A]" id="38843">ReaderWriterState</a><span class="delimiter">[</span>-<a title="&gt;: Nothing &lt;: Any" id="38844">R</a>, +<a title="&gt;: Nothing &lt;: Any" id="38845">W</a>, <a title="&gt;: Nothing &lt;: Any" id="38846">S</a>, +<a title="&gt;: Nothing &lt;: Any" id="38847">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#18266" title="scalaz.ReaderWriterStateT[scalaz.Id.Identity,R,W,S,A]">ReaderWriterStateT</a><span class="delimiter">[</span>Identity, R, W, S, A<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[F[+_], -R, +W, S, +A]scalaz.ReaderWriterStateT[F,R,W,S,A]" id="38848">RWST</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="38849">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="369550">_</a><span class="delimiter">]</span>, -<a title="&gt;: Nothing &lt;: Any" id="38850">R</a>, +<a title="&gt;: Nothing &lt;: Any" id="38851">W</a>, <a title="&gt;: Nothing &lt;: Any" id="38852">S</a>, +<a title="&gt;: Nothing &lt;: Any" id="38853">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#18266" title="scalaz.ReaderWriterStateT[F,R,W,S,A]">ReaderWriterStateT</a><span class="delimiter">[</span>F, R, W, S, A<span class="delimiter">]</span>

  <span class="keyword">val</span> <a title="scalaz.ReaderWriterStateT.type" id="38854">RWST</a>: ReaderWriterStateT.<span class="keyword">type</span> = <a href="ReaderWriterStateT.scala.html#18267" title="object scalaz.ReaderWriterStateT">ReaderWriterStateT</a>

  <span class="keyword">type</span> <a title="[-R, +W, S, +A]scalaz.package.ReaderWriterState[R,W,S,A]" id="38856">RWS</a><span class="delimiter">[</span>-<a title="&gt;: Nothing &lt;: Any" id="38857">R</a>, +<a title="&gt;: Nothing &lt;: Any" id="38858">W</a>, <a title="&gt;: Nothing &lt;: Any" id="38859">S</a>, +<a title="&gt;: Nothing &lt;: Any" id="38860">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#18266" title="scalaz.package.ReaderWriterState[R,W,S,A]">ReaderWriterState</a><span class="delimiter">[</span>R, W, S, A<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[F[_]]scalaz.ApplicativePlus[F]" id="38861">Alternative</a><span class="delimiter">[</span><a title="[_]&gt;: Nothing &lt;: Any" id="38862">F</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="369551">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="ApplicativePlus.scala.html#17474" title="scalaz.ApplicativePlus[F]">ApplicativePlus</a><span class="delimiter">[</span>F<span class="delimiter">]</span>

  <span class="comment">/**
   * An [[scalaz.Validation]] with a [[scalaz.NonEmptyList]] as the failure type.
   *
   * Useful for accumulating errors through the corresponding [[scalaz.Applicative]] instance.
   */</span>
  <span class="keyword">type</span> <a title="[+E, +X]scalaz.Validation[scalaz.NonEmptyList[E],X]" id="38863">ValidationNEL</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="38864">E</a>, +<a title="&gt;: Nothing &lt;: Any" id="38865">X</a><span class="delimiter">]</span> = <a href="Validation.scala.html#11897" title="scalaz.Validation[scalaz.NonEmptyList[E],X]">Validation</a><span class="delimiter">[</span>NonEmptyList<span class="delimiter">[</span>E<span class="delimiter">]</span>, X<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[Option[A],scalaz.Tags.First]" id="38866">FirstOption</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38867">A</a><span class="delimiter">]</span> = Option<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="#96713" title="scalaz.package.@@[Option[A],scalaz.Tags.First]">@@</a> Tags.First
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[Option[A],scalaz.Tags.Last]" id="38868">LastOption</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38869">A</a><span class="delimiter">]</span> = Option<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="#96857" title="scalaz.package.@@[Option[A],scalaz.Tags.Last]">@@</a> Tags.Last
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[Option[A],scalaz.Tags.Min]" id="38870">MinOption</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38871">A</a><span class="delimiter">]</span> = Option<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="#96987" title="scalaz.package.@@[Option[A],scalaz.Tags.Min]">@@</a> Tags.Min
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[Option[A],scalaz.Tags.Max]" id="38872">MaxOption</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38873">A</a><span class="delimiter">]</span> = Option<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="#95186" title="scalaz.package.@@[Option[A],scalaz.Tags.Max]">@@</a> Tags.Max

  <span class="comment">//</span>
  <span class="comment">// Lens type aliases</span>
  <span class="comment">//</span>
  <span class="keyword">type</span> <a title="[A, B]scalaz.LensT[scalaz.Id.Id,A,B]" id="38874">Lens</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38875">A</a>, <a title="&gt;: Nothing &lt;: Any" id="38876">B</a><span class="delimiter">]</span> = <a href="Lens.scala.html#12320" title="scalaz.LensT[scalaz.Id.Id,A,B]">LensT</a><span class="delimiter">[</span>Id, A, B<span class="delimiter">]</span>

  <span class="comment">// important to define here, rather than at the top-level, to avoid Scala 2.9.2 bug</span>
  <span class="keyword">object</span> <a title="object scalaz.package.Lens" id="38877">Lens</a> <span title="ScalaObject" class="keyword">extends</span> <a href="Lens.scala.html#20339" title="scalaz.LensTFunctions">LensTFunctions</a> <span class="keyword">with</span> <a href="Lens.scala.html#18356" title="scalaz.LensTInstances">LensTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B](r: A =&gt; scalaz.package.Store[B,A])scalaz.package.Lens[A,B]" id="287901">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="287904">A</a>, <a title="&gt;: Nothing &lt;: Any" id="287905">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scalaz.package.Store[B,A]" id="287906">r</a>: A =&gt; Store<span class="delimiter">[</span>B, A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Lens.scala.html#12320" title="scalaz.package.Lens[A,B]">Lens</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> =
      <a href="Lens.scala.html#127955" title="(r: A =&gt; scalaz.package.Store[B,A])scalaz.package.Lens[A,B]">lens</a><span class="delimiter">(</span><a href="#287906" title="A =&gt; scalaz.package.Store[B,A]">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[A, B]scalaz.package.Lens[A,B]" id="38879">@&gt;</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38880">A</a>, <a title="&gt;: Nothing &lt;: Any" id="38881">B</a><span class="delimiter">]</span> = <a href="Lens.scala.html#12320" title="scalaz.package.Lens[A,B]">Lens</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[A, B]scalaz.PLensT[scalaz.Id.Id,A,B]" id="38882">PLens</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38883">A</a>, <a title="&gt;: Nothing &lt;: Any" id="38884">B</a><span class="delimiter">]</span> = <a href="PLens.scala.html#12095" title="scalaz.PLensT[scalaz.Id.Id,A,B]">PLensT</a><span class="delimiter">[</span>Id, A, B<span class="delimiter">]</span>

  <span class="comment">// important to define here, rather than at the top-level, to avoid Scala 2.9.2 bug</span>
  <span class="keyword">object</span> <a title="object scalaz.package.PLens" id="38885">PLens</a> <span title="ScalaObject" class="keyword">extends</span> <a href="PLens.scala.html#21398" title="scalaz.PLensTFunctions">PLensTFunctions</a> <span class="keyword">with</span> <a href="PLens.scala.html#16397" title="scalaz.PLensTInstances">PLensTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B](r: A =&gt; Option[scalaz.package.Store[B,A]])scalaz.package.PLens[A,B]" id="77992">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77995">A</a>, <a title="&gt;: Nothing &lt;: Any" id="77996">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; Option[scalaz.package.Store[B,A]]" id="369574">r</a>: A =&gt; Option<span class="delimiter">[</span>Store<span class="delimiter">[</span>B, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="PLens.scala.html#12095" title="scalaz.package.PLens[A,B]">PLens</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> =
      <a href="PLens.scala.html#77725" title="(r: A =&gt; Option[scalaz.package.Store[B,A]])scalaz.package.PLens[A,B]">plens</a><span class="delimiter">(</span><a href="#369574" title="A =&gt; Option[scalaz.package.Store[B,A]]">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[A, B]scalaz.package.PLens[A,B]" id="38887">@?&gt;</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38888">A</a>, <a title="&gt;: Nothing &lt;: Any" id="38889">B</a><span class="delimiter">]</span> = <a href="PLens.scala.html#12095" title="scalaz.package.PLens[A,B]">PLens</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[F[+_], A, B]scalaz.StateT[F,A,Option[B]]" id="38890">PStateT</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="38891">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="333031">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="38892">A</a>, <a title="&gt;: Nothing &lt;: Any" id="38893">B</a><span class="delimiter">]</span> = <a href="StateT.scala.html#11747" title="scalaz.StateT[F,A,Option[B]]">StateT</a><span class="delimiter">[</span>F, A, Option<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[A, B]scalaz.StateT[scalaz.Id.Id,A,Option[B]]" id="38894">PState</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38895">A</a>, <a title="&gt;: Nothing &lt;: Any" id="38896">B</a><span class="delimiter">]</span> = <a href="StateT.scala.html#11747" title="scalaz.StateT[scalaz.Id.Id,A,Option[B]]">StateT</a><span class="delimiter">[</span>Id, A, Option<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>