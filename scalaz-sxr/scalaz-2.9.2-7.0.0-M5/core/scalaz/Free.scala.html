<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/scalaz/Free.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz

<span class="keyword">import</span> annotation.tailrec
<span class="keyword">import</span> <a href="#23049" title="object scalaz.Free">Free</a>._
<span class="keyword">import</span> std.<a href="std/Function.scala.html#26012" title="object scalaz.std.function">function</a>._
<span class="keyword">import</span> std.<a href="std/Tuple.scala.html#26852" title="object scalaz.std.tuple">tuple</a>._

<span class="comment">// TODO report compiler bug when this appears just above FreeInstances:</span>
<span class="comment">//      &quot;java.lang.Error: typeConstructor inapplicable for &lt;none&gt;&quot;</span>
<span class="keyword">object</span> <a title="object scalaz.Free" id="23049">Free</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#22637" title="scalaz.FreeFunctions">FreeFunctions</a> <span class="keyword">with</span> <a href="#20570" title="scalaz.FreeInstances">FreeInstances</a> <span class="delimiter">{</span>

  <span class="comment">/** Return from the computation with the given value. */</span>
  case <span class="keyword">class</span> <a title="class Return[S[+_], +A] extends scalaz.Free[S,A] with ScalaObject with Product with Serializable" id="197193">Return</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="164798">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="164818">_</a><span class="delimiter">]</span>: Functor, +<a title="&gt;: Nothing &lt;: Any" id="164799">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="164816">a</a>: <a href="#164799" title="A">A</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#23048" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span>

  <span class="comment">/** Suspend the computation with the given suspension. */</span>
  case <span class="keyword">class</span> <a title="class Suspend[S[+_], +A] extends scalaz.Free[S,A] with ScalaObject with Product with Serializable" id="197187">Suspend</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="196622">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="197181">_</a><span class="delimiter">]</span>: Functor, +<a title="&gt;: Nothing &lt;: Any" id="196623">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="197179">a</a>: <a href="#196622" title="S[scalaz.Free[S,A]]">S</a><span class="delimiter">[</span>Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#23048" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span>

  <span class="comment">/** Call a subroutine and continue with the given function. */</span>
  case <span class="keyword">class</span> <a title="class Gosub[S[+_], A, +B] extends scalaz.Free[S,B] with ScalaObject with Product with Serializable" id="197175">Gosub</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="197101">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="197167">_</a><span class="delimiter">]</span>: Functor, <a title="&gt;: Nothing &lt;: Any" id="197102">A</a>, +<a title="&gt;: Nothing &lt;: Any" id="197103">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="197164">a</a>: <a href="#23048" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span>,
                                          <a title="A =&gt; scalaz.Free[S,B]" id="197165">f</a>: A =&gt; Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#23048" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span>

  <span class="comment">/** A computation that can be stepped through, suspended, and paused */</span>
  <span class="keyword">type</span> <a title="[+A]scalaz.Free[Function0,A]" id="52966">Trampoline</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="52967">A</a><span class="delimiter">]</span> = <a href="#23048" title="scalaz.Free[Function0,A]">Free</a><span class="delimiter">[</span>Function0, A<span class="delimiter">]</span>

  <span class="comment">/** A computation that produces values of type `A`, eventually resulting in a value of type `B`. */</span>
  <span class="keyword">type</span> <a title="[A, +B]scalaz.Free[[+x](A, x),B]" id="52968">Source</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="52969">A</a>, +<a title="&gt;: Nothing &lt;: Any" id="52970">B</a><span class="delimiter">]</span> = <a href="#23048" title="scalaz.Free[[+x](A, x),B]">Free</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>A, x<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#f, B<span class="delimiter">]</span>

  <span class="comment">/** A computation that accepts values of type `A`, eventually resulting in a value of type `B`.
    * Note the similarity to an [[scalaz.iteratee.Iteratee]].
    */</span>
  <span class="keyword">type</span> <a title="[A, +B]scalaz.Free[[+x]=&gt; A =&gt; x,B]" id="52971">Sink</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="52972">A</a>, +<a title="&gt;: Nothing &lt;: Any" id="52973">B</a><span class="delimiter">]</span> = <a href="#23048" title="scalaz.Free[[+x]=&gt; A =&gt; x,B]">Free</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; A<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#f, B<span class="delimiter">]</span>
<span class="delimiter">}</span>

<span class="comment">/** A free operational monad for some functor `S`. Binding is done using the heap instead of the stack,
  * allowing tail-call elimination. */</span>
<span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Free[S[+_], +A] extends java.lang.Object with ScalaObject" id="23048">Free</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="25044">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="197194">_</a><span class="delimiter">]</span>, +<a title="&gt;: Nothing &lt;: Any" id="25045">A</a><span class="delimiter">]</span><a href="#23048" title="ScalaObject" class="delimiter">(</a><span class="keyword">implicit</span> <a title="scalaz.Functor[S]" id="195773">S</a>: <a href="Functor.scala.html#14441" title="scalaz.Functor[S]">Functor</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[B](f: A =&gt; B)scalaz.Free[S,B]" id="117199">map</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117201">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="117269">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#23048" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span> =
    <a href="#117205" title="(f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]">flatMap</a><span class="delimiter">(</span><a title="A" id="197203">a</a> =&gt; <a href="#197193" title="(a: B)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,B]">Return</a><a href="#195773" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#117269" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#197203" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Alias for `flatMap` */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[B](f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]" id="117202">&gt;&gt;=</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117204">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free[S,B]" id="155776">f</a>: A =&gt; Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23048" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span> = <a href="#23048" title="Free.this.type" class="keyword">this</a> <a href="#117205" title="(f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]">flatMap</a> <a href="#155776" title="A =&gt; scalaz.Free[S,B]">f</a>

  <span class="comment">/** Binds the given continuation to the result of this computation.
    * All left-associated binds are reassociated to the right. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[B](f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]" id="117205">flatMap</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117207">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free[S,B]" id="197197">f</a>: A =&gt; Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23048" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span> = <a href="#23048" title="scalaz.Free[S,A]" class="keyword">this</a> <span title="scalaz.Free[S,B]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="scalaz.Free.Gosub[S,Any,B]">Gosub</span><span class="delimiter">(</span><a title="scalaz.Free[S,Any]" id="197581">a</a>, <a title="Any =&gt; scalaz.Free[S,A]" id="197582">g</a><span class="delimiter">)</span> =&gt; <a href="#197175" title="(a: scalaz.Free[S,Any], f: Any =&gt; scalaz.Free[S,B])(implicit evidence$3: scalaz.Functor[S])scalaz.Free.Gosub[S,Any,B]">Gosub</a><a href="#195773" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#197581" title="scalaz.Free[S,Any]">a</a>, <span class="delimiter">(</span>x: <span title="Any">Any</span><span class="delimiter">)</span> =&gt; <a href="#197175" title="(a: scalaz.Free[S,A], f: A =&gt; scalaz.Free[S,B])(implicit evidence$3: scalaz.Functor[S])scalaz.Free.Gosub[S,A,B]">Gosub</a><a href="#195773" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#197582" title="(v1: Any)scalaz.Free[S,A]">g</a><span class="delimiter">(</span><a href="#197594" title="Any">x</a><span class="delimiter">)</span>, <a href="#197197" title="A =&gt; scalaz.Free[S,B]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="scalaz.Free.Gosub[S,A,B]" id="198334">a</a>           =&gt; <a href="#197175" title="(a: scalaz.Free[S,A], f: A =&gt; scalaz.Free[S,B])(implicit evidence$3: scalaz.Functor[S])scalaz.Free.Gosub[S,A,B]">Gosub</a><a href="#195773" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#198334" title="scalaz.Free[S,A]">a</a>, <a href="#197197" title="A =&gt; scalaz.Free[S,B]">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Evaluates a single layer of the free monad. */</span>
  @tailrec <span class="keyword">final</span> <span class="keyword">def</span> <a title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]" id="117208">resume</a>: <span class="delimiter">(</span>S<span class="delimiter">[</span>Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">]</span> <a href="Either.scala.html#10076" title="scalaz.\/[S[scalaz.Free[S,A]],A]">\/</a> A<span class="delimiter">)</span> = <a href="#23048" title="scalaz.Free[S,A]" class="keyword">this</a> <span title="scalaz.\/[S[scalaz.Free[S,A]],A]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="scalaz.\/[Nothing,A]">Return</span><span class="delimiter">(</span><a title="A" id="198715">a</a><span class="delimiter">)</span>  =&gt; <a href="Either.scala.html#10077" title="object scalaz.\/">\/</a>.<a href="Either.scala.html#134595" title="(v1: A)scalaz.\/[Nothing,A]">right</a><span class="delimiter">(</span><a href="#198715" title="A">a</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="scalaz.\/[S[scalaz.Free[S,A]],Nothing]">Suspend</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="198724">t</a><span class="delimiter">)</span> =&gt; <a href="Either.scala.html#10077" title="object scalaz.\/">\/</a>.<a href="Either.scala.html#134590" title="(v1: S[scalaz.Free[S,A]])scalaz.\/[S[scalaz.Free[S,A]],Nothing]">left</a><span class="delimiter">(</span><a href="#198724" title="S[scalaz.Free[S,A]]">t</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="scalaz.\/[S[scalaz.Free[S,A]],A]" id="198734">a</a> Gosub <a title="Any =&gt; scalaz.Free[S,A]" id="198735">f</a>  =&gt; <a href="#198734" title="scalaz.Free[S,Any]">a</a> <span title="scalaz.\/[S[scalaz.Free[S,A]],A]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="scalaz.\/[S[scalaz.Free[S,A]],A]">Return</span><span class="delimiter">(</span><a title="Any" id="198740">a</a><span class="delimiter">)</span>  =&gt; <a href="#198735" title="(v1: Any)scalaz.Free[S,A]">f</a><span class="delimiter">(</span><a href="#198740" title="Any">a</a><span class="delimiter">)</span>.<a href="#117208" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a>
      <span class="keyword">case</span> <span title="scalaz.\/[S[scalaz.Free[S,A]],Nothing]">Suspend</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,Any]]" id="198746">t</a><span class="delimiter">)</span> =&gt; <a href="Either.scala.html#10077" title="object scalaz.\/">\/</a>.<a href="Either.scala.html#134590" title="(v1: S[scalaz.Free[S,A]])scalaz.\/[S[scalaz.Free[S,A]],Nothing]">left</a><span class="delimiter">(</span><a href="#195773" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#42468" title="(fa: S[scalaz.Free[S,Any]])(f: scalaz.Free[S,Any] =&gt; scalaz.Free[S,A])S[scalaz.Free[S,A]]">map</a><span class="delimiter">(</span><a href="#198746" title="S[scalaz.Free[S,Any]]">t</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#198760" title="scalaz.Free[S,Any]">_</a>: <a href="#23048" title="scalaz.Free[S,Any]">Free</a><span class="delimiter">[</span>S, Any<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#117205" title="(f: Any =&gt; scalaz.Free[S,A])scalaz.Free[S,A]">flatMap</a> <a href="#198735" title="Any =&gt; scalaz.Free[S,A]">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="scalaz.\/[S[scalaz.Free[S,A]],A]" id="198773">b</a> Gosub <a title="Any =&gt; scalaz.Free[S,Any]" id="198774">g</a>  =&gt; <a href="#198773" title="scalaz.Free[S,Any]">b</a>.<a href="#117205" title="(f: Any =&gt; scalaz.Free[S,A])scalaz.Free[S,A]">flatMap</a><span class="delimiter">(</span><span class="delimiter">(</span>x: <span title="Any">Any</span><span class="delimiter">)</span> =&gt; <a href="#198774" title="(v1: Any)scalaz.Free[S,Any]">g</a><span class="delimiter">(</span><a href="#198779" title="Any">x</a><span class="delimiter">)</span> <a href="#117205" title="(f: Any =&gt; scalaz.Free[S,A])scalaz.Free[S,A]">flatMap</a> <a href="#198735" title="Any =&gt; scalaz.Free[S,A]">f</a><span class="delimiter">)</span>.<a href="#117208" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Changes the suspension functor by the given natural transformation. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[T[+_]](f: scalaz.package.~&gt;[S,T])(implicit evidence$4: scalaz.Functor[T])scalaz.Free[T,A]" id="198787">mapSuspension</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="117211">T</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="198788">_</a><span class="delimiter">]</span>:Functor<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.package.~&gt;[S,T]" id="198786">f</a>: S <a href="NaturalTransformation.scala.html#16934" title="scalaz.package.~&gt;[S,T]">~&gt;</a> T<span class="delimiter">)</span>: <a href="#23048" title="scalaz.Free[T,A]">Free</a><span class="delimiter">[</span>T, A<span class="delimiter">]</span> =
    <a href="#117208" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a> <span title="scalaz.Free[T,A]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Suspend[T,A]">-\/</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="198793">s</a><span class="delimiter">)</span>  =&gt; <a href="#197187" title="(a: T[scalaz.Free[T,A]])(implicit evidence$2: scalaz.Functor[T])scalaz.Free.Suspend[T,A]">Suspend</a><a href="#198787" title="scalaz.Functor[T]" class="delimiter">(</a><a href="NaturalTransformation.scala.html#148051" title="(fa: S[scalaz.Free[T,A]])T[scalaz.Free[T,A]]">f</a><span class="delimiter">(</span><a href="#195773" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#42468" title="(fa: S[scalaz.Free[S,A]])(f: scalaz.Free[S,A] =&gt; scalaz.Free[T,A])S[scalaz.Free[T,A]]">map</a><span class="delimiter">(</span><a href="#198793" title="S[scalaz.Free[S,A]]">s</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#198814" title="scalaz.Free[S,A]">_</a>: <a href="#23048" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#198787" title="(f: scalaz.package.~&gt;[S,T])(implicit evidence$4: scalaz.Functor[T])scalaz.Free[T,A]">mapSuspension</a> <a href="#198786" title="scalaz.package.~&gt;[S,T]">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Return[T,A]">\/-</span><span class="delimiter">(</span><a title="A" id="199549">r</a><span class="delimiter">)</span> =&gt; <a href="#197193" title="(a: A)(implicit evidence$1: scalaz.Functor[T])scalaz.Free.Return[T,A]">Return</a><a href="#198787" title="scalaz.Functor[T]" class="delimiter">(</a><a href="#199549" title="A">r</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Modifies the first suspension with the given natural transformation. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(f: scalaz.package.~&gt;[S,S])scalaz.Free[S,A]" id="117212">mapFirstSuspension</a><span class="delimiter">(</span><a title="scalaz.package.~&gt;[S,S]" id="199918">f</a>: S <a href="NaturalTransformation.scala.html#16934" title="scalaz.package.~&gt;[S,S]">~&gt;</a> S<span class="delimiter">)</span>: <a href="#23048" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> = <a href="#117208" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a> <span title="scalaz.Free[S,A]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="scalaz.Free.Suspend[S,A]">-\/</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="199921">s</a><span class="delimiter">)</span> =&gt; <a href="#197187" title="(a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><a href="#195773" title="scalaz.Functor[S]" class="delimiter">(</a><a href="NaturalTransformation.scala.html#148051" title="(fa: S[scalaz.Free[S,A]])S[scalaz.Free[S,A]]">f</a><span class="delimiter">(</span><a href="#199921" title="S[scalaz.Free[S,A]]">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="scalaz.Free.Return[S,A]">\/-</span><span class="delimiter">(</span><a title="A" id="200296">r</a><span class="delimiter">)</span> =&gt; <a href="#197193" title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><a href="#195773" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#200296" title="A">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Applies a function `f` to a value in this monad and a corresponding value in the dual comonad, annihilating both. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[G[+_], B, C](bs: scalaz.Cofree[G,B])(f: (A, B) =&gt; C)(implicit G: scalaz.Functor[G], implicit d: scalaz.Zap[S,G])C" id="117213">zapWith</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="117217">G</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="200669">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="117218">B</a>, <a title="&gt;: Nothing &lt;: Any" id="117219">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Cofree[G,B]" id="200664">bs</a>: <a href="Cofree.scala.html#21068" title="scalaz.Cofree[G,B]">Cofree</a><span class="delimiter">[</span>G, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="200665">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[G]" id="200666">G</a>: <a href="Functor.scala.html#14441" title="scalaz.Functor[G]">Functor</a><span class="delimiter">[</span>G<span class="delimiter">]</span>, <a title="scalaz.Zap[S,G]" id="200667">d</a>: <a href="Zap.scala.html#11684" title="scalaz.Zap[S,G]">Zap</a><span class="delimiter">[</span>S, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#117219" title="C">C</a> =
    <a href="Zap.scala.html#11685" title="object scalaz.Zap">Zap</a>.<a href="Zap.scala.html#148231" title="(implicit d: scalaz.Zap[S,G], implicit F: scalaz.Functor[S], implicit G: scalaz.Functor[G])scalaz.Zap[[α]scalaz.Free[S,α],[α]scalaz.Cofree[G,α]]">monadComonadZap</a>.<a href="Zap.scala.html#62688" title="(fa: scalaz.Free[S,A], gb: scalaz.Cofree[G,B])(f: (A, B) =&gt; C)C">zapWith</a><span class="delimiter">(</span><a href="#23048" title="scalaz.Free[S,A]" class="keyword">this</a>, <a href="#200664" title="scalaz.Cofree[G,B]">bs</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#200665" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span>

  <span class="comment">/** Applies a function in a comonad to the corresponding value in this monad, annihilating both. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[G[+_], B](fs: scalaz.Cofree[G,A =&gt; B])(implicit G: scalaz.Functor[G], implicit d: scalaz.Zap[S,G])B" id="117220">zap</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="117223">G</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="201727">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="117224">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Cofree[G,A =&gt; B]" id="201723">fs</a>: <a href="Cofree.scala.html#21068" title="scalaz.Cofree[G,A =&gt; B]">Cofree</a><span class="delimiter">[</span>G, A =&gt; B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[G]" id="201724">G</a>: <a href="Functor.scala.html#14441" title="scalaz.Functor[G]">Functor</a><span class="delimiter">[</span>G<span class="delimiter">]</span>, <a title="scalaz.Zap[S,G]" id="201725">d</a>: <a href="Zap.scala.html#11684" title="scalaz.Zap[S,G]">Zap</a><span class="delimiter">[</span>S, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#117224" title="B">B</a> =
    <a href="#117213" title="(bs: scalaz.Cofree[G,A =&gt; B])(f: (A, A =&gt; B) =&gt; B)(implicit G: scalaz.Functor[G], implicit d: scalaz.Zap[S,G])B">zapWith</a><span class="delimiter">(</span><a href="#201723" title="scalaz.Cofree[G,A =&gt; B]">fs</a><span class="delimiter">)</span><a href="#201724" title="scalaz.Functor[G]" class="delimiter">(</a><span class="delimiter">(</span><a title="A" id="201752">a</a>, <a title="A =&gt; B" id="201753">f</a><span class="delimiter">)</span> =&gt; <a href="#201753" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#201752" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Runs a single step, using a function that extracts the resumption from its suspension functor. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[AA &gt;: A](f: S[scalaz.Free[S,A]] =&gt; scalaz.Free[S,AA])scalaz.Free[S,AA]" id="117225">bounce</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="117227">AA</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]] =&gt; scalaz.Free[S,AA]" id="202396">f</a>: S<span class="delimiter">[</span>Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">]</span> =&gt; Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23048" title="scalaz.Free[S,AA]">Free</a><span class="delimiter">[</span>S, AA<span class="delimiter">]</span> = <a href="#117208" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a> <span title="scalaz.Free[S,AA]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="scalaz.Free[S,AA]">-\/</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="202400">s</a><span class="delimiter">)</span> =&gt; <a href="#202396" title="(v1: S[scalaz.Free[S,A]])scalaz.Free[S,AA]">f</a><span class="delimiter">(</span><a href="#202400" title="S[scalaz.Free[S,A]]">s</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="scalaz.Free.Return[S,A]">\/-</span><span class="delimiter">(</span><a title="A" id="202403">r</a><span class="delimiter">)</span> =&gt; <a href="#197193" title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><a href="#195773" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#202403" title="A">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Runs to completion, using a function that extracts the resumption from its suspension functor. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[AA &gt;: A](f: S[scalaz.Free[S,AA]] =&gt; scalaz.Free[S,AA])AA" id="117228">go</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="117230">AA</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,AA]] =&gt; scalaz.Free[S,AA]" id="202771">f</a>: S<span class="delimiter">[</span>Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">]</span> =&gt; Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#117230" title="AA">AA</a> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(t: scalaz.Free[S,AA])AA" id="202774">go2</a><span class="delimiter">(</span><a title="scalaz.Free[S,AA]" id="202775">t</a>: <a href="#23048" title="scalaz.Free[S,AA]">Free</a><span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#117230" title="AA">AA</a> = <a href="#202775" title="scalaz.Free[S,AA]">t</a>.<a href="#117208" title="=&gt; scalaz.\/[S[scalaz.Free[S,AA]],AA]">resume</a> <span title="AA" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="AA">-\/</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,AA]]" id="202777">s</a><span class="delimiter">)</span> =&gt; <a href="#202774" title="(t: scalaz.Free[S,AA])AA">go2</a><span class="delimiter">(</span><a href="#202771" title="(v1: S[scalaz.Free[S,AA]])scalaz.Free[S,AA]">f</a><span class="delimiter">(</span><a href="#202777" title="S[scalaz.Free[S,AA]]">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="AA">\/-</span><span class="delimiter">(</span><a title="AA" id="202780">r</a><span class="delimiter">)</span> =&gt; <a href="#202780" title="AA">r</a>
    <span class="delimiter">}</span>
    <a href="#202774" title="(t: scalaz.Free[S,AA])AA">go2</a><span class="delimiter">(</span><a href="#23048" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Runs to completion, allowing the resumption function to thread an arbitrary state of type `B`. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[B, AA &gt;: A](b: B)(f: (B, S[scalaz.Free[S,AA]]) =&gt; (B, scalaz.Free[S,AA]))(B, AA)" id="117231">foldRun</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117234">B</a>, <a title="&gt;: A &lt;: Any" id="117235">AA</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="202781">b</a>: <a href="#117234" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, S[scalaz.Free[S,AA]]) =&gt; (B, scalaz.Free[S,AA])" id="202782">f</a>: <span class="delimiter">(</span>B, S<span class="delimiter">[</span>Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>B, Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="(B, AA)" class="delimiter">(</span>B, AA<span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(t: scalaz.Free[S,AA], z: B)(B, AA)" id="202786">foldRun2</a><span class="delimiter">(</span><a title="scalaz.Free[S,AA]" id="202787">t</a>: <a href="#23048" title="scalaz.Free[S,AA]">Free</a><span class="delimiter">[</span>S, AA<span class="delimiter">]</span>, <a title="B" id="202788">z</a>: <a href="#117234" title="B">B</a><span class="delimiter">)</span>: <span title="(B, AA)" class="delimiter">(</span>B, AA<span class="delimiter">)</span> = <a href="#202787" title="scalaz.Free[S,AA]">t</a>.<a href="#117208" title="=&gt; scalaz.\/[S[scalaz.Free[S,AA]],AA]">resume</a> <span title="(B, AA)" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="(B, AA)">-\/</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,AA]]" id="202790">s</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
        <span class="keyword">val</span> <a href="#202792" title="(B, scalaz.Free[S,AA])" class="delimiter">(</a><a href="#202791" title="B" id="202792">b1</a>, <a href="#202791" title="scalaz.Free[S,AA]" id="202793">s1</a><span class="delimiter">)</span> = <a href="#202782" title="(v1: B, v2: S[scalaz.Free[S,AA]])(B, scalaz.Free[S,AA])">f</a><span title="(B, scalaz.Free[S,AA]) @unchecked" class="delimiter">(</span><a href="#202788" title="B">z</a>, <a href="#202790" title="S[scalaz.Free[S,AA]]">s</a><span class="delimiter">)</span>
        <a href="#202786" title="(t: scalaz.Free[S,AA], z: B)(B, AA)">foldRun2</a><span class="delimiter">(</span><a href="#202793" title="scalaz.Free[S,AA]">s1</a>, <a href="#202792" title="B">b1</a><span class="delimiter">)</span> 
      <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="(B, AA)">\/-</span><span class="delimiter">(</span><a title="AA" id="202807">r</a><span class="delimiter">)</span> =&gt; <span title="(_1: B, _2: AA)(B, AA)" class="delimiter">(</span><a href="#202788" title="B">z</a>, <a href="#202807" title="AA">r</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#202786" title="(t: scalaz.Free[S,AA], z: B)(B, AA)">foldRun2</a><span class="delimiter">(</span><a href="#23048" title="scalaz.Free[S,A]" class="keyword">this</a>, <a href="#202781" title="B">b</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">import</span> <a href="Liskov.scala.html#10149" title="object scalaz.Liskov">Liskov</a>._

  <span class="comment">/** Runs a trampoline all the way to the end, tail-recursively. */</span>
  <span class="keyword">def</span> <a title="[B &gt;: A](implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,B],scalaz.Free.Trampoline[B]])B" id="117237">run</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="117239">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,B],scalaz.Free.Trampoline[B]]" id="117338">ev</a>: Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span> <a href="Liskov.scala.html#10148" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,B],scalaz.Free.Trampoline[B]]">&lt;~&lt;</a> Trampoline<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#117239" title="B">B</a> =
    <a href="Liskov.scala.html#117708" title="(a: scalaz.Free[S,B])scalaz.Free.Trampoline[B]">ev</a><span class="delimiter">(</span><a href="#23048" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span>.<a href="#117228" title="(f: (() =&gt; scalaz.Free[Function0,B]) =&gt; scalaz.Free[Function0,B])B">go</a><span class="delimiter">(</span><a href="#202825" title="()scalaz.Free[Function0,B]">_</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Interleave this computation with another, combining the results with the given function. */</span>
  <span class="keyword">def</span> <a title="[B, C](tb: scalaz.Free[S,B], f: (A, B) =&gt; C)scalaz.Free[S,C]" id="117240">zipWith</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117243">B</a>, <a title="&gt;: Nothing &lt;: Any" id="117244">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free[S,B]" id="202826">tb</a>: <a href="#23048" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span>, <a title="(A, B) =&gt; C" id="202827">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#23048" title="scalaz.Free[S,C]">Free</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="(_1: scalaz.\/[S[scalaz.Free[S,A]],A], _2: scalaz.\/[S[scalaz.Free[S,B]],B])(scalaz.\/[S[scalaz.Free[S,A]],A], scalaz.\/[S[scalaz.Free[S,B]],B])" class="delimiter">(</span><a href="#117208" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a>, <a href="#202826" title="scalaz.Free[S,B]">tb</a>.<a href="#117208" title="=&gt; scalaz.\/[S[scalaz.Free[S,B]],B]">resume</a><span class="delimiter">)</span> <span title="scalaz.Free[S,C]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Suspend[S,C]" class="delimiter">(</span>-\/<span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="202840">a</a><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="S[scalaz.Free[S,B]]" id="202842">b</a><span class="delimiter">)</span><span class="delimiter">)</span>   =&gt; <a href="#197187" title="(a: S[scalaz.Free[S,C]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,C]">Suspend</a><a href="#195773" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#195773" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#42468" title="(fa: S[scalaz.Free[S,A]])(f: scalaz.Free[S,A] =&gt; scalaz.Free.Suspend[S,C])S[scalaz.Free.Suspend[S,C]]">map</a><span class="delimiter">(</span><a href="#202840" title="S[scalaz.Free[S,A]]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="202860">x</a> =&gt; <a href="#197187" title="(a: S[scalaz.Free[S,C]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,C]">Suspend</a><a href="#195773" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#195773" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#42468" title="(fa: S[scalaz.Free[S,B]])(f: scalaz.Free[S,B] =&gt; scalaz.Free[S,C])S[scalaz.Free[S,C]]">map</a><span class="delimiter">(</span><a href="#202842" title="S[scalaz.Free[S,B]]">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Free[S,B]" id="202878">y</a> =&gt; <a href="#202860" title="scalaz.Free[S,A]">x</a> <a href="#117240" title="(tb: scalaz.Free[S,B], f: (A, B) =&gt; C)scalaz.Free[S,C]">zipWith</a><span class="delimiter">(</span><a href="#202878" title="scalaz.Free[S,B]">y</a>, <a href="#202827" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Suspend[S,C]" class="delimiter">(</span>-\/<span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="203615">a</a><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="B" id="203617">b</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#197187" title="(a: S[scalaz.Free[S,C]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,C]">Suspend</a><a href="#195773" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#195773" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#42468" title="(fa: S[scalaz.Free[S,A]])(f: scalaz.Free[S,A] =&gt; scalaz.Free[S,C])S[scalaz.Free[S,C]]">map</a><span class="delimiter">(</span><a href="#203615" title="S[scalaz.Free[S,A]]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="203635">x</a> =&gt; <a href="#203635" title="scalaz.Free[S,A]">x</a> <a href="#117240" title="(tb: scalaz.Free[S,B], f: (A, B) =&gt; C)scalaz.Free[S,C]">zipWith</a><span class="delimiter">(</span><a href="#197193" title="(a: B)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,B]">Return</a><a href="#195773" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#203617" title="B">b</a><span class="delimiter">)</span>, <a href="#202827" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Suspend[S,C]" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="A" id="204375">a</a><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="S[scalaz.Free[S,B]]" id="204377">b</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#197187" title="(a: S[scalaz.Free[S,C]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,C]">Suspend</a><a href="#195773" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#195773" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#42468" title="(fa: S[scalaz.Free[S,B]])(f: scalaz.Free[S,B] =&gt; scalaz.Free[S,C])S[scalaz.Free[S,C]]">map</a><span class="delimiter">(</span><a href="#204377" title="S[scalaz.Free[S,B]]">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Free[S,B]" id="204395">y</a> =&gt; <a href="#197193" title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span class="delimiter">(</span><a href="#204375" title="A">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#195773" title="scalaz.Functor[S]">S</a><span class="delimiter">)</span> <a href="#117240" title="(tb: scalaz.Free[S,B], f: (A, B) =&gt; C)scalaz.Free[S,C]">zipWith</a><span class="delimiter">(</span><a href="#204395" title="scalaz.Free[S,B]">y</a>, <a href="#202827" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Return[S,C]" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="A" id="204780">a</a><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="B" id="204782">b</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#197193" title="(a: C)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,C]">Return</a><a href="#195773" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#202827" title="(v1: A, v2: B)C">f</a><span class="delimiter">(</span><a href="#204780" title="A">a</a>, <a href="#204782" title="B">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Runs a `Source` all the way to the end, tail-recursively, collecting the produced values. */</span>
  <span class="keyword">def</span> <a title="[B, C &gt;: A](implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[B,C]])(Vector[B], C)" id="117245">collect</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117248">B</a>, <a title="&gt;: A &lt;: Any" id="117249">C</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[B,C]]" id="205152">ev</a>: Free<span class="delimiter">[</span>S, C<span class="delimiter">]</span> <a href="Liskov.scala.html#10148" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[B,C]]">&lt;~&lt;</a> Source<span class="delimiter">[</span>B, C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Vector[B], C)" class="delimiter">(</span>Vector<span class="delimiter">[</span>B<span class="delimiter">]</span>, C<span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(c: scalaz.Free.Source[B,C], v: Vector[B])(Vector[B], C)" id="205155">go</a><span class="delimiter">(</span><a title="scalaz.Free.Source[B,C]" id="205156">c</a>: <a href="#23048" title="scalaz.Free.Source[B,C]">Source</a><span class="delimiter">[</span>B, C<span class="delimiter">]</span>, <a title="Vector[B]" id="205158">v</a>: <span title="Vector[B]">Vector</span><span class="delimiter">[</span>B<span class="delimiter">]</span> = <span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="(Vector[B], C)" class="delimiter">(</span>Vector<span class="delimiter">[</span>B<span class="delimiter">]</span>, C<span class="delimiter">)</span> =
      <a href="#205156" title="scalaz.Free.Source[B,C]">c</a>.<a href="#117208" title="=&gt; scalaz.\/[(B, scalaz.Free[[+x](B, x),C]),C]">resume</a> <span title="(Vector[B], C)" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="(Vector[B], C)">-\/</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="B" id="205165">b</a>, <a title="scalaz.Free[[+x](B, x),C]" id="205166">cont</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#205155" title="(c: scalaz.Free.Source[B,C], v: Vector[B])(Vector[B], C)">go</a><span class="delimiter">(</span><a href="#205166" title="scalaz.Free[[+x](B, x),C]">cont</a>, <a href="#205158" title="Vector[B]">v</a> <span title="(elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[B],B,Vector[B]])Vector[B]">:+</span> <a href="#205165" title="B">b</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="(Vector[B], C)">\/-</span><span class="delimiter">(</span><a title="C" id="205636">r</a><span class="delimiter">)</span>        =&gt; <span title="(_1: Vector[B], _2: C)(Vector[B], C)" class="delimiter">(</span><a href="#205158" title="Vector[B]">v</a>, <a href="#205636" title="C">r</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="#205155" title="(c: scalaz.Free.Source[B,C], v: Vector[B])(Vector[B], C)">go</a><span class="delimiter">(</span><a href="Liskov.scala.html#117708" title="(a: scalaz.Free[S,C])scalaz.Free.Source[B,C]">ev</a><span class="delimiter">(</span><a href="#23048" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Drive this `Source` with the given Sink. */</span>
  <span class="keyword">def</span> <a title="[E, B, C &gt;: A](sink: scalaz.Free.Sink[Option[E],B])(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[E,C]])(C, B)" id="117250">drive</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117254">E</a>, <a title="&gt;: Nothing &lt;: Any" id="117255">B</a>, <a title="&gt;: A &lt;: Any" id="117256">C</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Sink[Option[E],B]" id="205647">sink</a>: <a href="#23048" title="scalaz.Free.Sink[Option[E],B]">Sink</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>E<span class="delimiter">]</span>, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[E,C]]" id="205648">ev</a>: Free<span class="delimiter">[</span>S, C<span class="delimiter">]</span> <a href="Liskov.scala.html#10148" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[E,C]]">&lt;~&lt;</a> Source<span class="delimiter">[</span>E, C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(C, B)" class="delimiter">(</span>C, B<span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)" id="205652">go</a><span class="delimiter">(</span><a title="scalaz.Free.Source[E,C]" id="205653">src</a>: <a href="#23048" title="scalaz.Free.Source[E,C]">Source</a><span class="delimiter">[</span>E, C<span class="delimiter">]</span>, <a title="scalaz.Free.Sink[Option[E],B]" id="205654">snk</a>: <a href="#23048" title="scalaz.Free.Sink[Option[E],B]">Sink</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>E<span class="delimiter">]</span>, B<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(C, B)" class="delimiter">(</span>C, B<span class="delimiter">)</span> =
      <span title="(_1: scalaz.\/[(E, scalaz.Free[[+x](E, x),C]),C], _2: scalaz.\/[=&gt; Option[E] =&gt; scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B],B])(scalaz.\/[(E, scalaz.Free[[+x](E, x),C]),C], scalaz.\/[=&gt; Option[E] =&gt; scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B],B])" class="delimiter">(</span><a href="#205653" title="scalaz.Free.Source[E,C]">src</a>.<a href="#117208" title="=&gt; scalaz.\/[(E, scalaz.Free[[+x](E, x),C]),C]">resume</a>, <a href="#205654" title="scalaz.Free.Sink[Option[E],B]">snk</a>.<a href="#117208" title="=&gt; scalaz.\/[=&gt; Option[E] =&gt; scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B],B]">resume</a><span class="delimiter">)</span> <span title="(C, B)" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>-\/<span class="delimiter">(</span><span class="delimiter">(</span><a title="E" id="205666">e</a>, <a title="scalaz.Free[[+x](E, x),C]" id="205667">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="=&gt; Option[E] =&gt; scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B]" id="205669">f</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#205652" title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)">go</a><span class="delimiter">(</span><a href="#205667" title="scalaz.Free[[+x](E, x),C]">c</a>, <a href="#205669" title="(v1: =&gt; Option[E])scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B]">f</a><span class="delimiter">(</span><span title="(x: E)Some[E]">Some</span><span class="delimiter">(</span><a href="#205666" title="E">e</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>-\/<span class="delimiter">(</span><span class="delimiter">(</span><a title="E" id="205679">e</a>, <a title="scalaz.Free[[+x](E, x),C]" id="205680">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="B" id="205682">y</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#205652" title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)">go</a><span class="delimiter">(</span><a href="#205680" title="scalaz.Free[[+x](E, x),C]">c</a>, <a href="#11712" title="object scalaz.Sink">Sink</a>.<a href="#52982" title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]">sinkMonad</a><span title="scalaz.Monad[[x]scalaz.Free[[+x]=&gt; Option[E] =&gt; x,x]]" class="delimiter">[</span><span title="Option[E]">Option</span><span class="delimiter">[</span>E<span class="delimiter">]</span><span class="delimiter">]</span>.<a href="Pointed.scala.html#43521" title="(a: =&gt; B)scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B]">pure</a><span class="delimiter">(</span><a href="#205682" title="B">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="C" id="205694">x</a><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="=&gt; Option[E] =&gt; scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B]" id="205696">f</a><span class="delimiter">)</span><span class="delimiter">)</span>      =&gt; <a href="#205652" title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)">go</a><span class="delimiter">(</span><a href="#23610" title="object scalaz.Source">Source</a>.<a href="#52986" title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]">sourceMonad</a><span title="scalaz.Monad[[x]scalaz.Free[[+x](E, x),x]]" class="delimiter">[</span><a href="#117254" title="E">E</a><span class="delimiter">]</span>.<a href="Pointed.scala.html#43521" title="(a: =&gt; C)scalaz.Free[[+x](E, x),C]">pure</a><span class="delimiter">(</span><a href="#205694" title="C">x</a><span class="delimiter">)</span>, <a href="#205696" title="(v1: =&gt; Option[E])scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B]">f</a><span class="delimiter">(</span><span title="object None">None</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="C" id="205709">x</a><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="B" id="205711">y</a><span class="delimiter">)</span><span class="delimiter">)</span>     =&gt; <span title="(_1: C, _2: B)(C, B)" class="delimiter">(</span><a href="#205709" title="C">x</a>, <a href="#205711" title="B">y</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="#205652" title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)">go</a><span class="delimiter">(</span><a href="Liskov.scala.html#117708" title="(a: scalaz.Free[S,C])scalaz.Free.Source[E,C]">ev</a><span class="delimiter">(</span><a href="#23048" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span>, <a href="#205647" title="scalaz.Free.Sink[Option[E],B]">sink</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Feed the given stream to this `Source`. */</span>
  <span class="keyword">def</span> <a title="[E, C &gt;: A](ss: Stream[E])(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]])C" id="117257">feed</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117260">E</a>, <a title="&gt;: A &lt;: Any" id="117261">C</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="Stream[E]" id="205719">ss</a>: <span title="Stream[E]">Stream</span><span class="delimiter">[</span>E<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]]" id="205720">ev</a>: Free<span class="delimiter">[</span>S, C<span class="delimiter">]</span> <a href="Liskov.scala.html#10148" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]]">&lt;~&lt;</a> Sink<span class="delimiter">[</span>E, C<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#117261" title="C">C</a> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(snk: scalaz.Free.Sink[E,C], rest: Stream[E])C" id="205724">go</a><span class="delimiter">(</span><a title="scalaz.Free.Sink[E,C]" id="205725">snk</a>: <a href="#23048" title="scalaz.Free.Sink[E,C]">Sink</a><span class="delimiter">[</span>E, C<span class="delimiter">]</span>, <a title="Stream[E]" id="205726">rest</a>: <span title="Stream[E]">Stream</span><span class="delimiter">[</span>E<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#117261" title="C">C</a> = <span title="(_1: Stream[E], _2: scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C])(Stream[E], scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C])" class="delimiter">(</span><a href="#205726" title="Stream[E]">rest</a>, <a href="#205725" title="scalaz.Free.Sink[E,C]">snk</a>.<a href="#117208" title="=&gt; scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C]">resume</a><span class="delimiter">)</span> <span title="C" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="C" class="delimiter">(</span><a title="E" id="205761">x</a> <a href="#205743" title="(xs: scala.collection.immutable.Stream[E])Option[(E, scala.collection.immutable.Stream[E])]">#::</a> <a title="scala.collection.immutable.Stream[E]" id="205762">xs</a>, -\/<span class="delimiter">(</span><a title="=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C]" id="205764">f</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#205724" title="(snk: scalaz.Free.Sink[E,C], rest: Stream[E])C">go</a><span class="delimiter">(</span><a href="#205764" title="(v1: =&gt; E)scalaz.Free[[+x]=&gt; E =&gt; x,C]">f</a><span class="delimiter">(</span><a href="#205761" title="E">x</a><span class="delimiter">)</span>, <a href="#205762" title="scala.collection.immutable.Stream[E]">xs</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="C" class="delimiter">(</span><a href="#205769" title="(x: scala.collection.immutable.Stream[E])Some[scala.collection.immutable.Stream[E]]">Stream</a><span class="delimiter">(</span><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C]" id="205789">f</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#205724" title="(snk: scalaz.Free.Sink[E,C], rest: Stream[E])C">go</a><span class="delimiter">(</span><a href="#205789" title="(v1: =&gt; E)scalaz.Free[[+x]=&gt; E =&gt; x,C]">f</a><span class="delimiter">(</span>sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="java.lang.String(&quot;No more values.&quot;)" class="string">&quot;No more values.&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="(xs: Nothing*)scala.collection.immutable.Stream[Nothing]">Stream</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="C" class="delimiter">(</span>_, \/-<span class="delimiter">(</span><a title="C" id="205801">r</a><span class="delimiter">)</span><span class="delimiter">)</span>       =&gt; <a href="#205801" title="C">r</a>
    <span class="delimiter">}</span>
    <a href="#205724" title="(snk: scalaz.Free.Sink[E,C], rest: Stream[E])C">go</a><span class="delimiter">(</span><a href="Liskov.scala.html#117708" title="(a: scalaz.Free[S,C])scalaz.Free.Sink[E,C]">ev</a><span class="delimiter">(</span><a href="#23048" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span>, <a href="#205719" title="Stream[E]">ss</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Feed the given source to this `Sink`. */</span>
  <span class="keyword">def</span> <a title="[E, B, C &gt;: A](source: scalaz.Free.Source[E,B])(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]])(C, B)" id="117262">drain</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="117266">E</a>, <a title="&gt;: Nothing &lt;: Any" id="117267">B</a>, <a title="&gt;: A &lt;: Any" id="117268">C</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Source[E,B]" id="205803">source</a>: <a href="#23048" title="scalaz.Free.Source[E,B]">Source</a><span class="delimiter">[</span>E, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]]" id="205804">ev</a>: Free<span class="delimiter">[</span>S, C<span class="delimiter">]</span> <a href="Liskov.scala.html#10148" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]]">&lt;~&lt;</a> Sink<span class="delimiter">[</span>E, C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(C, B)" class="delimiter">(</span>C, B<span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(src: scalaz.Free.Source[E,B], snk: scalaz.Free.Sink[E,C])(C, B)" id="205808">go</a><span class="delimiter">(</span><a title="scalaz.Free.Source[E,B]" id="205809">src</a>: <a href="#23048" title="scalaz.Free.Source[E,B]">Source</a><span class="delimiter">[</span>E, B<span class="delimiter">]</span>, <a title="scalaz.Free.Sink[E,C]" id="205810">snk</a>: <a href="#23048" title="scalaz.Free.Sink[E,C]">Sink</a><span class="delimiter">[</span>E, C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(C, B)" class="delimiter">(</span>C, B<span class="delimiter">)</span> = <span title="(_1: scalaz.\/[(E, scalaz.Free[[+x](E, x),B]),B], _2: scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C])(scalaz.\/[(E, scalaz.Free[[+x](E, x),B]),B], scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C])" class="delimiter">(</span><a href="#205809" title="scalaz.Free.Source[E,B]">src</a>.<a href="#117208" title="=&gt; scalaz.\/[(E, scalaz.Free[[+x](E, x),B]),B]">resume</a>, <a href="#205810" title="scalaz.Free.Sink[E,C]">snk</a>.<a href="#117208" title="=&gt; scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C]">resume</a><span class="delimiter">)</span> <span title="(C, B)" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>-\/<span class="delimiter">(</span><span class="delimiter">(</span><a title="E" id="205822">e</a>, <a title="scalaz.Free[[+x](E, x),B]" id="205823">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C]" id="205825">f</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#205808" title="(src: scalaz.Free.Source[E,B], snk: scalaz.Free.Sink[E,C])(C, B)">go</a><span class="delimiter">(</span><a href="#205823" title="scalaz.Free[[+x](E, x),B]">c</a>, <a href="#205825" title="(v1: =&gt; E)scalaz.Free[[+x]=&gt; E =&gt; x,C]">f</a><span class="delimiter">(</span><a href="#205822" title="E">e</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>-\/<span class="delimiter">(</span><span class="delimiter">(</span><a title="E" id="205832">e</a>, <a title="scalaz.Free[[+x](E, x),B]" id="205833">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="C" id="205835">y</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#205808" title="(src: scalaz.Free.Source[E,B], snk: scalaz.Free.Sink[E,C])(C, B)">go</a><span class="delimiter">(</span><a href="#205833" title="scalaz.Free[[+x](E, x),B]">c</a>, <a href="#11712" title="object scalaz.Sink">Sink</a>.<a href="#52982" title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]">sinkMonad</a><span title="scalaz.Monad[[x]scalaz.Free[[+x]=&gt; E =&gt; x,x]]" class="delimiter">[</span><a href="#117266" title="E">E</a><span class="delimiter">]</span>.<a href="Pointed.scala.html#43521" title="(a: =&gt; C)scalaz.Free[[+x]=&gt; E =&gt; x,C]">pure</a><span class="delimiter">(</span><a href="#205835" title="C">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Nothing" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="B" id="205846">x</a><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C]" id="205848">f</a><span class="delimiter">)</span><span class="delimiter">)</span>      =&gt; sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="java.lang.String(&quot;Not enough values in source.&quot;)" class="string">&quot;Not enough values in source.&quot;</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="B" id="205852">x</a><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="C" id="205854">y</a><span class="delimiter">)</span><span class="delimiter">)</span>     =&gt; <span title="(_1: C, _2: B)(C, B)" class="delimiter">(</span><a href="#205854" title="C">y</a>, <a href="#205852" title="B">x</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#205808" title="(src: scalaz.Free.Source[E,B], snk: scalaz.Free.Sink[E,C])(C, B)">go</a><span class="delimiter">(</span><a href="#205803" title="scalaz.Free.Source[E,B]">source</a>, <a href="Liskov.scala.html#117708" title="(a: scalaz.Free[S,C])scalaz.Free.Sink[E,C]">ev</a><span class="delimiter">(</span><a href="#23048" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="object scalaz.Trampoline" id="13437">Trampoline</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#23819" title="scalaz.TrampolineInstances">TrampolineInstances</a>

<span class="keyword">trait</span> <a title="trait TrampolineInstances extends java.lang.Object with ScalaObject" id="23819">TrampolineInstances</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="TrampolineInstances extends scalaz.Monad[scalaz.Free.Trampoline] with scalaz.Copointed[scalaz.Free.Trampoline]" id="52975">trampolineMonad</a>: <a href="#117775" title="TrampolineInstances extends scalaz.Monad[scalaz.Free.Trampoline] with scalaz.Copointed[scalaz.Free.Trampoline]">Monad</a><span class="delimiter">[</span>Trampoline<span class="delimiter">]</span> <span class="keyword">with</span> Copointed<span class="delimiter">[</span>Trampoline<span class="delimiter">]</span> = <a href="#205866" title="java.lang.Object with scalaz.Monad[scalaz.Free.Trampoline] with scalaz.Copointed[scalaz.Free.Trampoline]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.Monad[scalaz.Free.Trampoline] with scalaz.Copointed[scalaz.Free.Trampoline]" id="205866">Monad</a><span class="delimiter">[</span>Trampoline<span class="delimiter">]</span> <span class="keyword">with</span> <a href="Copointed.scala.html#16862" title="scalaz.Copointed[scalaz.Free.Trampoline]">Copointed</a><span class="delimiter">[</span>Trampoline<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free[Function0,A]" id="205918">point</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="205920">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="205929">a</a>: =&gt; A<span class="delimiter">)</span> = <a href="#52932" title="[S[+_], A](value: =&gt; A)(implicit S: scalaz.Pointed[S])scalaz.Free[S,A]">return_</a><span title="(value: =&gt; A)(implicit S: scalaz.Pointed[Function0])scalaz.Free[Function0,A]" class="delimiter">[</span><span title="Function0">Function0</span>, <a href="#205920" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#53007" title="function0Instance extends java.lang.Object with scalaz.Traverse[Function0] with scalaz.Monad[Function0] with scalaz.Copointed[Function0]" class="delimiter">(</a><a href="#205929" title="=&gt; A">a</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[A, B](ta: scalaz.Free.Trampoline[A])(f: A =&gt; scalaz.Free.Trampoline[B])scalaz.Free[Function0,B]" id="205921">bind</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="205924">A</a>, <a title="&gt;: Nothing &lt;: Any" id="205925">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Trampoline[A]" id="206277">ta</a>: <a href="#23048" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free.Trampoline[B]" id="206278">f</a>: A =&gt; Trampoline<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#206277" title="scalaz.Free.Trampoline[A]">ta</a> <a href="#117205" title="(f: A =&gt; scalaz.Free[Function0,B])scalaz.Free[Function0,B]">flatMap</a> <a href="#206278" title="A =&gt; scalaz.Free.Trampoline[B]">f</a>
    <span class="keyword">def</span> <a title="[A](p: scalaz.Free.Trampoline[A])A" id="205926">copoint</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="205928">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Trampoline[A]" id="206301">p</a>: Free.<a href="#23048" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#205928" title="A">A</a> = <span class="delimiter">{</span>
      <span class="keyword">import</span> std.<a href="std/Function.scala.html#26012" title="object scalaz.std.function">function</a>.function0Instance
      <a href="#206301" title="scalaz.Free.Trampoline[A]">p</a>.<a href="#117237" title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[Function0,A],scalaz.Free.Trampoline[A]])A">run</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="object scalaz.Sink" id="11712">Sink</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#15158" title="scalaz.SinkInstances">SinkInstances</a>

<span class="keyword">trait</span> <a title="trait SinkInstances extends java.lang.Object with ScalaObject" id="15158">SinkInstances</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]" id="52982">sinkMonad</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="52984">S</a><span class="delimiter">]</span>: <a href="Monad.scala.html#22208" title="scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Sink<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> =
    <a href="#206628" title="java.lang.Object with scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]" id="206628">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Sink<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free.Suspend[[+x]=&gt; S =&gt; x,A]" id="206686">point</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="206688">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="206694">a</a>: =&gt; A<span class="delimiter">)</span> =
        <a href="#197187" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: =&gt; S =&gt; scalaz.Free[[+x]=&gt; S =&gt; x,A])(implicit evidence$2: scalaz.Functor[[+x]=&gt; S =&gt; x])scalaz.Free.Suspend[[+x]=&gt; S =&gt; x,A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; S<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x]=&gt; S =&gt; x">f</span>, <a href="#206688" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#53014" title="FunctionInstances extends scalaz.Monad[[a]=&gt; S =&gt; a] with scalaz.Zip[[a]=&gt; S =&gt; a] with scalaz.Unzip[[a]=&gt; S =&gt; a] with scalaz.Distributive[[a]=&gt; S =&gt; a]" class="delimiter">(</a><a title="=&gt; S" id="206710">s</a> =&gt;
          <a href="#197193" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[[+x]=&gt; S =&gt; x])scalaz.Free.Return[[+x]=&gt; S =&gt; x,A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; S<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x]=&gt; S =&gt; x">f</span>, <a href="#206688" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#53014" title="FunctionInstances extends scalaz.Monad[[a]=&gt; S =&gt; a] with scalaz.Zip[[a]=&gt; S =&gt; a] with scalaz.Unzip[[a]=&gt; S =&gt; a] with scalaz.Distributive[[a]=&gt; S =&gt; a]" class="delimiter">(</a><a href="#206694" title="=&gt; A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="[A, B](s: scalaz.Free.Sink[S,A])(f: A =&gt; scalaz.Free.Sink[S,B])scalaz.Free[[+x]=&gt; S =&gt; x,B]" id="206689">bind</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="206692">A</a>, <a title="&gt;: Nothing &lt;: Any" id="206693">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Sink[S,A]" id="207518">s</a>: <a href="#23048" title="scalaz.Free.Sink[S,A]">Sink</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free.Sink[S,B]" id="207519">f</a>: A =&gt; Sink<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#207518" title="scalaz.Free.Sink[S,A]">s</a> <a href="#117205" title="(f: A =&gt; scalaz.Free[[+x]=&gt; S =&gt; x,B])scalaz.Free[[+x]=&gt; S =&gt; x,B]">flatMap</a> <a href="#207519" title="A =&gt; scalaz.Free.Sink[S,B]">f</a>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="object scalaz.Source" id="23610">Source</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#14363" title="scalaz.SourceInstances">SourceInstances</a>

<span class="keyword">trait</span> <a title="trait SourceInstances extends java.lang.Object with ScalaObject" id="14363">SourceInstances</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]" id="52986">sourceMonad</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="52988">S</a><span class="delimiter">]</span>: <a href="Monad.scala.html#22208" title="scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Source<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> =
    <a href="#207570" title="java.lang.Object with scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]" id="207570">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Source<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free.Return[[+x](S, x),A]" id="207628">point</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="207630">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="207636">a</a>: =&gt; A<span class="delimiter">)</span> = <a href="#197193" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[[+x](S, x)])scalaz.Free.Return[[+x](S, x),A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>S, x<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x](S, x)">f</span>, <a href="#207630" title="A">A</a><span class="delimiter">]</span><a href="std/Tuple.scala.html#54437" title="TupleInstances0 extends scalaz.Traverse[[x](S, x)] with scalaz.Comonad[[x](S, x)]" class="delimiter">(</a><a href="#207636" title="=&gt; A">a</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="[A, B](s: scalaz.Free.Source[S,A])(f: A =&gt; scalaz.Free.Source[S,B])scalaz.Free[[+x](S, x),B]" id="207631">bind</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="207634">A</a>, <a title="&gt;: Nothing &lt;: Any" id="207635">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Source[S,A]" id="208316">s</a>: <a href="#23048" title="scalaz.Free.Source[S,A]">Source</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free.Source[S,B]" id="208317">f</a>: A =&gt; Source<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#208316" title="scalaz.Free.Source[S,A]">s</a> <a href="#117205" title="(f: A =&gt; scalaz.Free[[+x](S, x),B])scalaz.Free[[+x](S, x),B]">flatMap</a> <a href="#208317" title="A =&gt; scalaz.Free.Source[S,B]">f</a>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">// Trampoline, Sink, and Source are type aliases. We need to add their type class instances</span>
<span class="comment">// to Free to be part of the implicit scope.</span>
<span class="keyword">trait</span> <a title="trait FreeInstances extends java.lang.Object with scalaz.TrampolineInstances with scalaz.SinkInstances with scalaz.SourceInstances with ScalaObject" id="20570">FreeInstances</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#23819" title="scalaz.TrampolineInstances">TrampolineInstances</a> <span class="keyword">with</span> <a href="#15158" title="scalaz.SinkInstances">SinkInstances</a> <span class="keyword">with</span> <a href="#14363" title="scalaz.SourceInstances">SourceInstances</a> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S[+_]](implicit evidence$5: scalaz.Functor[S])scalaz.Monad[[x]scalaz.Free[S,x]]" id="117736">freeMonad</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="52980">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="117740">_</a><span class="delimiter">]</span>:Functor<span class="delimiter">]</span>: <a href="Monad.scala.html#22208" title="scalaz.Monad[[x]scalaz.Free[S,x]]">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Free<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> =
    <a href="#208367" title="java.lang.Object with scalaz.Monad[[x]scalaz.Free[S,x]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.Monad[[x]scalaz.Free[S,x]]" id="208367">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Free<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free.Return[S,A]" id="208425">point</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="208427">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="208438">a</a>: =&gt; A<span class="delimiter">)</span> = <a href="#197193" title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><a href="#117736" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#208438" title="=&gt; A">a</a><span class="delimiter">)</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](fa: scalaz.Free[S,A])(f: A =&gt; B)scalaz.Free[S,B]" id="208428">map</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="208431">A</a>, <a title="&gt;: Nothing &lt;: Any" id="208432">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="208822">fa</a>: <a href="#23048" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="208823">f</a>: A =&gt; B<span class="delimiter">)</span> = <a href="#208822" title="scalaz.Free[S,A]">fa</a> <a href="#117199" title="(f: A =&gt; B)scalaz.Free[S,B]">map</a> <a href="#208823" title="A =&gt; B">f</a>
      <span class="keyword">def</span> <a title="[A, B](a: scalaz.Free[S,A])(f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]" id="208433">bind</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="208436">A</a>, <a title="&gt;: Nothing &lt;: Any" id="208437">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="208870">a</a>: <a href="#23048" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free[S,B]" id="208871">f</a>: A =&gt; Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#208870" title="scalaz.Free[S,A]">a</a> <a href="#117205" title="(f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]">flatMap</a> <a href="#208871" title="A =&gt; scalaz.Free[S,B]">f</a>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait FreeFunctions extends java.lang.Object with ScalaObject" id="22637">FreeFunctions</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="comment">/** Collapse a trampoline to a single step. */</span>
  <span class="keyword">def</span> <a title="[A](r: scalaz.Free.Trampoline[A])scalaz.Free.Trampoline[A]" id="52929">reset</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="52931">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Trampoline[A]" id="208940">r</a>: <a href="#23048" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23048" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span> <span class="keyword">val</span> <a title="A" id="208943">a</a> = <a href="#208940" title="scalaz.Free.Trampoline[A]">r</a>.<a href="#117237" title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[Function0,A],scalaz.Free.Trampoline[A]])A">run</a>; <a href="#52932" title="(value: =&gt; A)(implicit S: scalaz.Pointed[Function0])scalaz.Free[Function0,A]">return_</a><a href="std/Function.scala.html#53007" title="function0Instance extends java.lang.Object with scalaz.Traverse[Function0] with scalaz.Monad[Function0] with scalaz.Copointed[Function0]" class="delimiter">(</a><a href="#208943" title="A">a</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="comment">/** Suspend the given computation in a single step. */</span>
  <span class="keyword">def</span> <a title="[S[+_], A](value: =&gt; A)(implicit S: scalaz.Pointed[S])scalaz.Free[S,A]" id="52932">return_</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="52935">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="155817">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="52936">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="155815">value</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Pointed[S]" id="155816">S</a>: <a href="Pointed.scala.html#9812" title="scalaz.Pointed[S]">Pointed</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23048" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> =
    <a href="#197187" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]" class="delimiter">[</span><a href="#52935" title="S">S</a>, <a href="#52936" title="A">A</a><span class="delimiter">]</span><a href="#155816" title="scalaz.Pointed[S]" class="delimiter">(</a><a href="#155816" title="scalaz.Pointed[S]">S</a>.<a href="Pointed.scala.html#43518" title="(a: =&gt; scalaz.Free.Return[S,A])S[scalaz.Free.Return[S,A]]">point</a><span class="delimiter">(</span><a href="#197193" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]" class="delimiter">[</span><a href="#52935" title="S">S</a>, <a href="#52936" title="A">A</a><span class="delimiter">]</span><a href="#155816" title="scalaz.Pointed[S]" class="delimiter">(</a><a href="#155815" title="=&gt; A">value</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[S[+_], A](value: =&gt; scalaz.Free[S,A])(implicit S: scalaz.Pointed[S])scalaz.Free[S,A]" id="52937">suspend</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="52940">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="155640">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="52941">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.Free[S,A]" id="155638">value</a>: =&gt; Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Pointed[S]" id="155639">S</a>: <a href="Pointed.scala.html#9812" title="scalaz.Pointed[S]">Pointed</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23048" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> =
    <a href="#197187" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]" class="delimiter">[</span><a href="#52940" title="S">S</a>, <a href="#52941" title="A">A</a><span class="delimiter">]</span><a href="#155639" title="scalaz.Pointed[S]" class="delimiter">(</a><a href="#155639" title="scalaz.Pointed[S]">S</a>.<a href="Pointed.scala.html#43518" title="(a: =&gt; scalaz.Free[S,A])S[scalaz.Free[S,A]]">point</a><span class="delimiter">(</span><a href="#155638" title="=&gt; scalaz.Free[S,A]">value</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** A trampoline step that doesn't do anything. */</span>
  <span class="keyword">def</span> <a title="=&gt; scalaz.Free.Trampoline[Unit]" id="52942">pause</a>: <a href="#23048" title="scalaz.Free.Trampoline[Unit]">Trampoline</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> =
    <a href="#52932" title="(value: =&gt; Unit)(implicit S: scalaz.Pointed[Function0])scalaz.Free[Function0,Unit]">return_</a><a href="std/Function.scala.html#53007" title="function0Instance extends java.lang.Object with scalaz.Traverse[Function0] with scalaz.Monad[Function0] with scalaz.Copointed[Function0]" class="delimiter">(</a><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** A source that produces the given value. */</span>
  <span class="keyword">def</span> <a title="[A](a: A)scalaz.Free.Source[A,Unit]" id="52943">produce</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="52945">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="211012">a</a>: <a href="#52945" title="A">A</a><span class="delimiter">)</span>: <a href="#23048" title="scalaz.Free.Source[A,Unit]">Source</a><span class="delimiter">[</span>A, Unit<span class="delimiter">]</span> =
    <a href="#197187" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: (A, scalaz.Free[[+x](A, x),Unit]))(implicit evidence$2: scalaz.Functor[[+x](A, x)])scalaz.Free.Suspend[[+x](A, x),Unit]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>A, x<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x](A, x)">f</span>, <span title="Unit">Unit</span><span class="delimiter">]</span><a href="std/Tuple.scala.html#54437" title="TupleInstances0 extends scalaz.Traverse[[x](A, x)] with scalaz.Comonad[[x](A, x)]" class="delimiter">(</a><a href="#211012" title="(x: A)ArrowAssoc[A]">a</a> <span title="(y: scalaz.Free.Return[[+x](A, x),Unit])(A, scalaz.Free.Return[[+x](A, x),Unit])">-&gt;</span> <a href="#197193" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: Unit)(implicit evidence$1: scalaz.Functor[[+x](A, x)])scalaz.Free.Return[[+x](A, x),Unit]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>A, x<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x](A, x)">f</span>, <span title="Unit">Unit</span><span class="delimiter">]</span><a href="std/Tuple.scala.html#54437" title="TupleInstances0 extends scalaz.Traverse[[x](A, x)] with scalaz.Comonad[[x](A, x)]" class="delimiter">(</a><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** A sink that waits for a single value and returns it. */</span>
  <span class="keyword">def</span> <a title="[A]=&gt; scalaz.Free.Sink[A,A]" id="52946">await</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="52948">A</a><span class="delimiter">]</span>: <a href="#23048" title="scalaz.Free.Sink[A,A]">Sink</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="#197187" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: =&gt; A =&gt; scalaz.Free[[+x]=&gt; A =&gt; x,A])(implicit evidence$2: scalaz.Functor[[+x]=&gt; A =&gt; x])scalaz.Free.Suspend[[+x]=&gt; A =&gt; x,A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; A<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x]=&gt; A =&gt; x">f</span>, <a href="#52948" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#53014" title="FunctionInstances extends scalaz.Monad[[a]=&gt; A =&gt; a] with scalaz.Zip[[a]=&gt; A =&gt; a] with scalaz.Unzip[[a]=&gt; A =&gt; a] with scalaz.Distributive[[a]=&gt; A =&gt; a]" class="delimiter">(</a><a title="=&gt; A" id="212679">a</a> =&gt; <a href="#197193" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[[+x]=&gt; A =&gt; x])scalaz.Free.Return[[+x]=&gt; A =&gt; x,A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; A<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x]=&gt; A =&gt; x">f</span>, <a href="#52948" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#53014" title="FunctionInstances extends scalaz.Monad[[a]=&gt; A =&gt; a] with scalaz.Zip[[a]=&gt; A =&gt; a] with scalaz.Unzip[[a]=&gt; A =&gt; a] with scalaz.Distributive[[a]=&gt; A =&gt; a]" class="delimiter">(</a><a href="#212679" title="=&gt; A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>


        </pre>
    </body>
</html>