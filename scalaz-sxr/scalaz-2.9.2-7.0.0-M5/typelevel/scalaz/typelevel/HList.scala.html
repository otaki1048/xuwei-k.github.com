<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>typelevel/scalaz/typelevel/HList.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz
<span class="keyword">package</span> typelevel

<span class="keyword">import</span> <a href="../../../core/scalaz/Kleisli.scala.html#23373" title="object scalaz.Kleisli">Kleisli</a>._

<span class="keyword">import</span> <a href="../../../core/scalaz/Id.scala.html#11472" title="object scalaz.Id">Id</a>._

<span class="keyword">object</span> <a title="object scalaz.typelevel.HLists" id="38100">HLists</a> <span title="ScalaObject" class="delimiter">{</span>

  <span class="keyword">import</span> <a href="#464360" title="object scalaz.typelevel.HLists.KleisliProof">KleisliProof</a>._

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class IdOps[T &lt;: scalaz.typelevel.package.HList] extends java.lang.Object with ScalaObject" id="464357">IdOps</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="464358">T</a> &lt;: HList<span class="delimiter">]</span><a href="#464357" title="ScalaObject" class="delimiter">(</a><a title="T" id="1372885">list</a>: <a href="#464358" title="T">T</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/** Prepends a value to this list. */</span>
    <span class="keyword">def</span> <a title="[A](elem: A)scalaz.typelevel.package.HCons[A,T]" id="464393">::</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="464395">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="464412">elem</a>: <a href="#464395" title="A">A</a><span class="delimiter">)</span>: <a href="GenericList.scala.html#38090" title="scalaz.typelevel.package.HCons[A,T]">HCons</a><span class="delimiter">[</span>A, T<span class="delimiter">]</span> = <a href="GenericList.scala.html#464732" title="[M[_], H, T &lt;: scalaz.typelevel.GenericList[M]](head: M[H], tail: T)scalaz.typelevel.GenericCons[M,H,T]">GenericCons</a><span title="(head: scalaz.Id.Id[A], tail: T)scalaz.typelevel.GenericCons[scalaz.Id.Id,A,T]" class="delimiter">[</span><a href="../../../core/scalaz/Id.scala.html#42459" title="scalaz.Id.Id">Id</a>, <a href="#464395" title="A">A</a>, <a href="#464358" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#464412" title="A">elem</a>, <a href="#1372885" title="T">list</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Composes a list of functions of the shape `A =&gt; F[B]` using
     * [[scalaz.Kleisli]]. This operation can be seen as a fold with `compose`.
     */</span>
    <span class="keyword">def</span> <a title="[M[+_], H, R](implicit ev: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,R,T], implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]" id="464396">compose</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="464400">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="712657">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="464401">H</a>, <a title="&gt;: Nothing &lt;: Any" id="464402">R</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,R,T]" id="712655">ev</a>: <a href="#464362" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,R,T]">KleisliProof</a><span class="delimiter">[</span>Forward, M, H, R, T<span class="delimiter">]</span>, <a title="scalaz.Bind[M]" id="712656">b</a>: <a href="../../../core/scalaz/Bind.scala.html#22496" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../core/scalaz/Kleisli.scala.html#23372" title="scalaz.Kleisli[M,H,R]">Kleisli</a><span class="delimiter">[</span>M, H, R<span class="delimiter">]</span> =
      <a href="#709346" title="(list: T)(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]">ev</a><a href="#712656" title="scalaz.Bind[M]" class="delimiter">(</a><a href="#1372885" title="T">list</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Composes a list of functions of the shape `A =&gt; F[B]` using
     * [[scalaz.Kleisli]]. This operation can be seen as a fold with `andThen`.
     */</span>
    <span class="keyword">def</span> <a title="[M[+_], H, R](implicit ev: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,H,R,T], implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]" id="464403">reverseCompose</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="464407">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="708674">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="464408">H</a>, <a title="&gt;: Nothing &lt;: Any" id="464409">R</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,H,R,T]" id="708672">ev</a>: <a href="#464362" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,H,R,T]">KleisliProof</a><span class="delimiter">[</span>Reverse, M, H, R, T<span class="delimiter">]</span>, <a title="scalaz.Bind[M]" id="708673">b</a>: <a href="../../../core/scalaz/Bind.scala.html#22496" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../core/scalaz/Kleisli.scala.html#23372" title="scalaz.Kleisli[M,H,R]">Kleisli</a><span class="delimiter">[</span>M, H, R<span class="delimiter">]</span> =
      <a href="#709346" title="(list: T)(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]">ev</a><a href="#708673" title="scalaz.Bind[M]" class="delimiter">(</a><a href="#1372885" title="T">list</a><span class="delimiter">)</span>

  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait KleisliProof0 extends java.lang.Object with ScalaObject" id="464359">KleisliProof0</a> <span title="ScalaObject" class="delimiter">{</span>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[D &lt;: scalaz.typelevel.HLists.KleisliProof.Direction, H, R]=&gt; scalaz.typelevel.HLists.KleisliProof[D,scalaz.Id.Id,H,R,scalaz.typelevel.package.HCons[H =&gt; scalaz.Id.Id[R],scalaz.typelevel.package.HNil]]" id="464414">baseComposeProof</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scalaz.typelevel.HLists.KleisliProof.Direction" id="464418">D</a> &lt;: Direction, <a title="&gt;: Nothing &lt;: Any" id="464419">H</a>, <a title="&gt;: Nothing &lt;: Any" id="464420">R</a><span class="delimiter">]</span> =
      <a href="#464443" title="[D &lt;: scalaz.typelevel.HLists.KleisliProof.Direction, M[+_], H, R]=&gt; scalaz.typelevel.HLists.KleisliProof[D,M,H,R,scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]]">baseKleisliProof</a><span title="scalaz.typelevel.HLists.KleisliProof[D,scalaz.Id.Id,H,R,scalaz.typelevel.package.HCons[H =&gt; scalaz.Id.Id[R],scalaz.typelevel.package.HNil]]" class="delimiter">[</span><a href="#464418" title="D">D</a>, <a href="../../../core/scalaz/Id.scala.html#42459" title="scalaz.Id.Id">Id</a>, <a href="#464419" title="H">H</a>, <a href="#464420" title="R">R</a><span class="delimiter">]</span>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[OH, IH, R, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,IH,R,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,OH,R,scalaz.typelevel.package.HCons[OH =&gt; scalaz.Id.Id[IH],T]]" id="464421">consComposeRevProof</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="464426">OH</a>, <a title="&gt;: Nothing &lt;: Any" id="464427">IH</a>, <a title="&gt;: Nothing &lt;: Any" id="464428">R</a>, <a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="464429">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,IH,R,T]" id="709729">proof</a>: <a href="#464362" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,IH,R,T]">KleisliProof</a><span class="delimiter">[</span>Reverse, Id, IH, R, T<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#464452" title="[M[+_], OH, IH, R, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,IH,R,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,OH,R,scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]]">consKleisliRevProof</a><span title="(implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,IH,R,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,OH,R,scalaz.typelevel.package.HCons[OH =&gt; scalaz.Id.Id[IH],T]]" class="delimiter">[</span><a href="../../../core/scalaz/Id.scala.html#42459" title="scalaz.Id.Id">Id</a>, <a href="#464426" title="OH">OH</a>, <a href="#464427" title="IH">IH</a>, <a href="#464428" title="R">R</a>, <a href="#464429" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#709729" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,IH,R,T]">proof</a><span class="delimiter">)</span>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[H, OR, IR, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,IR,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,OR,scalaz.typelevel.package.HCons[IR =&gt; scalaz.Id.Id[OR],T]]" id="464430">consComposeProof</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="464435">H</a>, <a title="&gt;: Nothing &lt;: Any" id="464436">OR</a>, <a title="&gt;: Nothing &lt;: Any" id="464437">IR</a>, <a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="464438">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,IR,T]" id="709723">proof</a>: <a href="#464362" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,IR,T]">KleisliProof</a><span class="delimiter">[</span>Forward, Id, H, IR, T<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#464463" title="[M[+_], H, OR, IR, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,IR,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,OR,scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]]">consKleisliProof</a><span title="(implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,IR,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,OR,scalaz.typelevel.package.HCons[IR =&gt; scalaz.Id.Id[OR],T]]" class="delimiter">[</span><a href="../../../core/scalaz/Id.scala.html#42459" title="scalaz.Id.Id">Id</a>, <a href="#464435" title="H">H</a>, <a href="#464436" title="OR">OR</a>, <a href="#464437" title="IR">IR</a>, <a href="#464438" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#709723" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,IR,T]">proof</a><span class="delimiter">)</span>

  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object scalaz.typelevel.HLists.KleisliProof" id="464360">KleisliProof</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#464359" title="scalaz.typelevel.HLists.KleisliProof0">KleisliProof0</a> <span class="delimiter">{</span>

    <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait Direction extends java.lang.Object" id="464440">Direction</a>
    <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Forward extends java.lang.Object with scalaz.typelevel.HLists.KleisliProof.Direction with ScalaObject" id="464441">Forward</a> <a href="#464441" title="ScalaObject" class="keyword">extends</a> <a href="#464440" title="scalaz.typelevel.HLists.KleisliProof.Direction">Direction</a>
    <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Reverse extends java.lang.Object with scalaz.typelevel.HLists.KleisliProof.Direction with ScalaObject" id="464442">Reverse</a> <a href="#464442" title="ScalaObject" class="keyword">extends</a> <a href="#464440" title="scalaz.typelevel.HLists.KleisliProof.Direction">Direction</a>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[D &lt;: scalaz.typelevel.HLists.KleisliProof.Direction, M[+_], H, R]=&gt; scalaz.typelevel.HLists.KleisliProof[D,M,H,R,scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]]" id="464443">baseKleisliProof</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scalaz.typelevel.HLists.KleisliProof.Direction" id="464448">D</a> &lt;: Direction, <a title="[+_]&gt;: Nothing &lt;: Any" id="464449">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="709715">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="464450">H</a>, <a title="&gt;: Nothing &lt;: Any" id="464451">R</a><span class="delimiter">]</span>: <a href="#464362" title="scalaz.typelevel.HLists.KleisliProof[D,M,H,R,scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]]">KleisliProof</a><span class="delimiter">[</span>D, M, H, R, HCons<span class="delimiter">[</span>H =&gt; M<span class="delimiter">[</span>R<span class="delimiter">]</span>, HNil<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#1373376" title="java.lang.Object with scalaz.typelevel.HLists.KleisliProof[D,M,H,R,scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.typelevel.HLists.KleisliProof[D,M,H,R,scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]]" id="1373376">KleisliProof</a><span class="delimiter">[</span>D, M, H, R, HCons<span class="delimiter">[</span>H =&gt; M<span class="delimiter">[</span>R<span class="delimiter">]</span>, HNil<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(list: scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil])(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]" id="1373380">apply</a><span class="delimiter">(</span><a title="scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]" id="1373381">list</a>: <a href="GenericList.scala.html#38090" title="scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]">HCons</a><span class="delimiter">[</span>H =&gt; M<span class="delimiter">[</span>R<span class="delimiter">]</span>, HNil<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bind[M]" id="1373382">b</a>: <a href="../../../core/scalaz/Bind.scala.html#22496" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="../../../core/scalaz/Kleisli.scala.html#52795" title="(f: H =&gt; M[R])scalaz.Kleisli[M,H,R]">kleisli</a><span class="delimiter">(</span><a href="#1373381" title="scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]">list</a>.<a href="GenericList.scala.html#464297" title="=&gt; H =&gt; M[R]">head</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[M[+_], OH, IH, R, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,IH,R,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,OH,R,scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]]" id="464452">consKleisliRevProof</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="464458">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="709710">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="464459">OH</a>, <a title="&gt;: Nothing &lt;: Any" id="464460">IH</a>, <a title="&gt;: Nothing &lt;: Any" id="464461">R</a>, <a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="464462">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span>
      <span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,IH,R,T]" id="709709">proof</a>: <a href="#464362" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,IH,R,T]">KleisliProof</a><span class="delimiter">[</span>Reverse, M, IH, R, T<span class="delimiter">]</span>
    <span class="delimiter">)</span>: <a href="#464362" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,OH,R,scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]]">KleisliProof</a><span class="delimiter">[</span>Reverse, M, OH, R, HCons<span class="delimiter">[</span>OH =&gt; M<span class="delimiter">[</span>IH<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#1373405" title="java.lang.Object with scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,OH,R,scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,OH,R,scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]]" id="1373405">KleisliProof</a><span class="delimiter">[</span>Reverse, M, OH, R, HCons<span class="delimiter">[</span>OH =&gt; M<span class="delimiter">[</span>IH<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(list: scalaz.typelevel.package.HCons[OH =&gt; M[IH],T])(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,OH,R]" id="1373409">apply</a><span class="delimiter">(</span><a title="scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]" id="1373410">list</a>: <a href="GenericList.scala.html#38090" title="scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]">HCons</a><span class="delimiter">[</span>OH =&gt; M<span class="delimiter">[</span>IH<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bind[M]" id="1373411">b</a>: <a href="../../../core/scalaz/Bind.scala.html#22496" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="../../../core/scalaz/Kleisli.scala.html#52795" title="(f: OH =&gt; M[IH])scalaz.Kleisli[M,OH,IH]">kleisli</a><span class="delimiter">(</span><a href="#1373410" title="scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]">list</a>.<a href="GenericList.scala.html#464297" title="=&gt; OH =&gt; M[IH]">head</a><span class="delimiter">)</span> <a href="../../../core/scalaz/Kleisli.scala.html#113260" title="(k: scalaz.Kleisli[M,IH,R])(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,OH,R]">&gt;=&gt;</a> <a href="#709346" title="(list: T)(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,IH,R]">proof</a><a href="#1373411" title="scalaz.Bind[M]" class="delimiter">(</a><a href="#1373410" title="scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]">list</a>.<a href="GenericList.scala.html#464299" title="=&gt; T">tail</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[M[+_], H, OR, IR, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,IR,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,OR,scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]]" id="464463">consKleisliProof</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="464469">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="709703">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="464470">H</a>, <a title="&gt;: Nothing &lt;: Any" id="464471">OR</a>, <a title="&gt;: Nothing &lt;: Any" id="464472">IR</a>, <a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="464473">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span>
      <span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,IR,T]" id="709702">proof</a>: <a href="#464362" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,IR,T]">KleisliProof</a><span class="delimiter">[</span>Forward, M, H, IR, T<span class="delimiter">]</span>
    <span class="delimiter">)</span>: <a href="#464362" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,OR,scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]]">KleisliProof</a><span class="delimiter">[</span>Forward, M, H, OR, HCons<span class="delimiter">[</span>IR =&gt; M<span class="delimiter">[</span>OR<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#1373484" title="java.lang.Object with scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,OR,scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,OR,scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]]" id="1373484">KleisliProof</a><span class="delimiter">[</span>Forward, M, H, OR, HCons<span class="delimiter">[</span>IR =&gt; M<span class="delimiter">[</span>OR<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(list: scalaz.typelevel.package.HCons[IR =&gt; M[OR],T])(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,OR]" id="1373488">apply</a><span class="delimiter">(</span><a title="scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]" id="1373489">list</a>: <a href="GenericList.scala.html#38090" title="scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]">HCons</a><span class="delimiter">[</span>IR =&gt; M<span class="delimiter">[</span>OR<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bind[M]" id="1373490">b</a>: <a href="../../../core/scalaz/Bind.scala.html#22496" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="../../../core/scalaz/Kleisli.scala.html#52795" title="(f: IR =&gt; M[OR])scalaz.Kleisli[M,IR,OR]">kleisli</a><span class="delimiter">(</span><a href="#1373489" title="scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]">list</a>.<a href="GenericList.scala.html#464297" title="=&gt; IR =&gt; M[OR]">head</a><span class="delimiter">)</span> <a href="../../../core/scalaz/Kleisli.scala.html#113272" title="(k: scalaz.Kleisli[M,H,IR])(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,OR]">&lt;=&lt;</a> <a href="#709346" title="(list: T)(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,IR]">proof</a><a href="#1373490" title="scalaz.Bind[M]" class="delimiter">(</a><a href="#1373489" title="scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]">list</a>.<a href="GenericList.scala.html#464299" title="=&gt; T">tail</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

  <span class="delimiter">}</span>

  @annotation.implicitNotFound<span class="delimiter">(</span>msg = <span class="string">&quot;Could not compose HList ${T} in ${D} direction&quot;</span><span class="delimiter">)</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait KleisliProof[D &lt;: scalaz.typelevel.HLists.KleisliProof.Direction, M[+_], H, R, T &lt;: scalaz.typelevel.package.HList] extends java.lang.Object" id="464362">KleisliProof</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scalaz.typelevel.HLists.KleisliProof.Direction" id="464363">D</a> &lt;: Direction, <a title="[+_]&gt;: Nothing &lt;: Any" id="464364">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="1373562">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="464365">H</a>, <a title="&gt;: Nothing &lt;: Any" id="464366">R</a>, <a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="464367">T</a> &lt;: HList<span class="delimiter">]</span> <span title="java.lang.Object" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(list: T)(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]" id="709346">apply</a><span class="delimiter">(</span><a title="T" id="1373319">list</a>: <a href="#464367" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bind[M]" id="1373320">b</a>: <a href="../../../core/scalaz/Bind.scala.html#22496" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../core/scalaz/Kleisli.scala.html#23372" title="scalaz.Kleisli[M,H,R]">Kleisli</a><span class="delimiter">[</span>M, H, R<span class="delimiter">]</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>


<span class="comment">// vim: expandtab:ts=2:sw=2</span>

        </pre>
    </body>
</html>