<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/reflect/api/Types.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scala.reflect
<span class="keyword">package</span> api

<span class="keyword">trait</span> <a title="trait Types extends Object with ScalaObject" id="17708">Types</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a> self: Universe =&gt;

  /** This class declares operations that are visible in a Type.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class AbsType extends Object with ScalaObject" id="28368">AbsType</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>

    /** The type symbol associated with the type, or `NoSymbol` for types
     *  that do not refer to a type symbol.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="376781">typeSymbol</a>: <a href="Symbols.scala.html#28350" title="Types.this.Symbol">Symbol</a>

    /** The defined or declared members with name `name` in this type;
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Alternatives of overloaded symbol appear in the order they are declared.
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="376782">declaration</a><span class="delimiter">(</span><a title="Types.this.Name" id="385835">name</a>: <a href="Names.scala.html#28427" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#28350" title="Types.this.Symbol">Symbol</a>

    /** The collection of declarations in this type
     */
    <span class="keyword">def</span> <a title="=&gt; Iterable[Types.this.Symbol]" id="376783">allDeclarations</a>: <a href="../../collection/Iterable.scala.html#6178" title="Iterable[Types.this.Symbol]">Iterable</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    /** The member with given name, either directly declared or inherited,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="376784">member</a><span class="delimiter">(</span><a title="Types.this.Name" id="378696">name</a>: <a href="Names.scala.html#28427" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#28350" title="Types.this.Symbol">Symbol</a>

    /** The non-private member with given name, either directly declared or inherited,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="376785">nonPrivateMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="385839">name</a>: <a href="Names.scala.html#28427" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#28350" title="Types.this.Symbol">Symbol</a>

    /** An iterable containing all members of this type (directly declared or inherited)
     *  Members appear in the linearization order of their owners.
     *  Members with the same owner appear in reverse order of their declarations.
     */
    <span class="keyword">def</span> <a title="=&gt; Iterable[Types.this.Symbol]" id="376786">allMembers</a>: <a href="../../collection/Iterable.scala.html#6178" title="Iterable[Types.this.Symbol]">Iterable</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    /** An iterable containing all non-private members of this type (directly declared or inherited)
     *  Members appear in the linearization order of their owners.
     *  Members with the same owner appear in reverse order of their declarations.
     */
    <span class="keyword">def</span> <a title="=&gt; Iterable[Types.this.Symbol]" id="376787">nonPrivateMembers</a>: <a href="../../collection/Iterable.scala.html#6178" title="Iterable[Types.this.Symbol]">Iterable</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    /** Substitute types in `to` for corresponding occurrences of references to
     *  symbols `from` in this type.
     */
    <span class="keyword">def</span> <a title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type" id="376788">subst</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="385845">from</a>: <a href="../../collection/immutable/List.scala.html#12053" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="385846">to</a>: <a href="../../collection/immutable/List.scala.html#12053" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#28371" title="Types.this.Type">Type</a>

    /** If this is a parameterized types, the type arguments.
     *  Otherwise the empty list
     */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="376789">typeArguments</a>: <a href="../../collection/immutable/List.scala.html#12053" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>

    /** Is this type a type constructor that is missing its type arguments?
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="376790">isHigherKinded</a>: <a href="../../Boolean.scala.html#64" title="Boolean">Boolean</a>

    /**
     *  Expands type aliases and converts higher-kinded TypeRefs to PolyTypes.
     *  Functions on types are also implemented as PolyTypes.
     *
     *  Example: (in the below, &lt;List&gt; is the type constructor of List)
     *    TypeRef(pre, &lt;List&gt;, List()) is replaced by
     *    PolyType(X, TypeRef(pre, &lt;List&gt;, List(X)))
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="376791">normalize</a>: <a href="#28371" title="Types.this.Type">Type</a>

    /** Does this type conform to given type argument `that`? */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="376792">&lt;:&lt;</a> <span class="delimiter">(</span><a title="Types.this.Type" id="385854">that</a>: <a href="#28371" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#64" title="Boolean">Boolean</a>

    /** Is this type equivalent to given type argument `that`? */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="376793">=:=</a> <span class="delimiter">(</span><a title="Types.this.Type" id="385856">that</a>: <a href="#28371" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#64" title="Boolean">Boolean</a>

    /** The list of all baseclasses of this type (including its own typeSymbol)
     *  in reverse linearization order, starting with the class itself and ending
     *  in class Any.
     */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="376794">baseClasses</a>: <a href="../../collection/immutable/List.scala.html#12053" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    /** The least type instance of given class which is a supertype
     *  of this type.  Example:
     *  {{{
     *    class D[T]
     *    class C extends p.D[Int]
     *    ThisType(C).baseType(D) = p.D[Int]
     * }}}
     */
    <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="376795">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="385860">clazz</a>: <a href="Symbols.scala.html#28350" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#28371" title="Types.this.Type">Type</a>

    /** This type as seen from prefix `pre` and class `clazz`. This means:
     *  Replace all thistypes of `clazz` or one of its subclasses
     *  by `pre` and instantiate all parameters by arguments of `pre`.
     *  Proceed analogously for thistypes referring to outer classes.
     *
     *  Example:
     *    class D[T] { def m: T }
     *    class C extends p.D[Int]
     *    T.asSeenFrom(ThisType(C), D)  (where D is owner of m)
     *      = Int
     */
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="376796">asSeenFrom</a><span class="delimiter">(</span><a title="Types.this.Type" id="385862">pre</a>: <a href="#28371" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="385863">clazz</a>: <a href="Symbols.scala.html#28350" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#28371" title="Types.this.Type">Type</a>

    /** The erased type corresponding to this type after
     *  all transcformations from Scala to Java have been performed.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="376797">erasedType</a>: <a href="#28371" title="Types.this.Type">Type</a>

   /** Apply `f` to each part of this type, returning
    *  a new type. children get mapped before their parents */
    <span class="keyword">def</span> <a title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.Type" id="376798">map</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Types.this.Type" id="385865">f</a>: Type =&gt; Type<span class="delimiter">)</span>: <a href="#28371" title="Types.this.Type">Type</a>

    /** Apply `f` to each part of this type, for side effects only */
    <span class="keyword">def</span> <a title="(f: Types.this.Type =&gt; Unit)Unit" id="376799">foreach</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Unit" id="385867">f</a>: Type =&gt; Unit<span class="delimiter">)</span>

    /** Returns optionally first type (in a preorder traversal) which satisfies predicate `p`,
     *  or None if none exists.
     */
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Option[Types.this.Type]" id="376800">find</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="385869">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[Types.this.Type]">Option</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>

    /** Is there part of this type which satisfies predicate `p`? */
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Boolean" id="376801">exists</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="385871">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Boolean.scala.html#64" title="Boolean">Boolean</a>

    /** Does this type contain a reference to given symbol? */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="376802">contains</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="385873">sym</a>: <a href="Symbols.scala.html#28350" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#64" title="Boolean">Boolean</a>
  <span class="delimiter">}</span>

  /** This class declares methods that are visible in a `SingleType`.
   */
  <span class="keyword">trait</span> <a title="trait AbsSingletonType extends Types.this.AbsType" id="28369">AbsSingletonType</a> <span class="keyword">extends</span> <a href="#28368" title="Types.this.AbsType">AbsType</a> <span class="delimiter">{</span>

    /** The type underlying a singleton type */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="385875">underlying</a>: <a href="#28371" title="Types.this.Type">Type</a>

    /** Widen from singleton type to its underlying non-singleton
     *  base type by applying one or more `underlying` dereferences,
     *  identity for all other types.
     *
     *  class Outer { class C ; val x: C }
     *  val o: Outer
     *  &lt;o.x.type&gt;.widen = o.C
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="385876">widen</a>: <a href="#28371" title="Types.this.Type">Type</a>
  <span class="delimiter">}</span>

  /** This class declares methods that are visible in a `CompoundType` (i.e.
   *  a class/trait/object template or refined type of the form
   *  {{{
   *     P_1 with ... with P_m { D_1; ...; D_n }
   *  }}}
   *  P_n
   */
  <span class="keyword">trait</span> <a title="trait AbsCompoundType extends Types.this.AbsType" id="28370">AbsCompoundType</a> <span class="keyword">extends</span> <a href="#28368" title="Types.this.AbsType">AbsType</a> <span class="delimiter">{</span>

    /** The list of parent types of this compound type */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="385878">parents</a>: <a href="../../collection/immutable/List.scala.html#12053" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The type of Scala types, and also Scala type signatures.
   *  (No difference is internally made between the two).
   */
  <span class="keyword">type</span> <a title="&gt;: Null &lt;: Types.this.AbsType" id="28371">Type</a> &gt;: Null &lt;: AbsType

  /** The type of Scala singleton types, i.e. types that are inhabited
   *  by only one nun-null value. These include types of the forms
   *  {{{
   *    C.this.type
   *    C.super.type
   *    x.type
   *  }}}
   *  as well as constant types.
   */
  <span class="keyword">type</span> <a title="&gt;: Null &lt;: Types.this.Type" id="28372">SingletonType</a> &gt;: Null &lt;: Type

  /** This constant is used as a special value that indicates that no meaningful type exists.
   */
  <span class="keyword">val</span> <a title="=&gt; Types.this.Type" id="28373">NoType</a>: <a href="#28371" title="Types.this.Type">Type</a>

  /** This constant is used as a special value denoting the empty prefix in a path dependent type.
   *  For instance `x.type` is represented as `SingleType(NoPrefix, &lt;x&gt;)`, where `&lt;x&gt;` stands for
   *  the symbol for `x`.
   */
  <span class="keyword">val</span> <a title="=&gt; Types.this.Type" id="28374">NoPrefix</a>: <a href="#28371" title="Types.this.Type">Type</a>

  /** The `ThisType` type describes types of the form on the left with the
   *  correspnding ThisType representations to the right.
   *  {{{
   *     C.this.type             ThisType(C)
   *  }}}
   */
  <span class="keyword">type</span> <a title="&gt;: Nothing &lt;: Types.this.SingletonType" id="28375">ThisType</a> &lt;: SingletonType

  /** The constructor/deconstructor for `ThisType` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.ThisTypeExtractor" id="28376">ThisType</a>: <a href="#28377" title="Types.this.ThisTypeExtractor">ThisTypeExtractor</a>

  /** An extractor class to create and pattern match with syntax `ThisType(sym)`
   *  where `sym` is the class prefix of the this type.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ThisTypeExtractor extends Object with ScalaObject" id="28377">ThisTypeExtractor</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="385881">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="385884">sym</a>: <a href="Symbols.scala.html#28350" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#28371" title="Types.this.Type">Type</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.ThisType)Option[Types.this.Symbol]" id="385882">unapply</a><span class="delimiter">(</span><a title="Types.this.ThisType" id="385886">tpe</a>: <a href="#28375" title="Types.this.ThisType">ThisType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[Types.this.Symbol]">Option</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The `TypeRef` type describes types of any of the forms on the left,
   *  with their TypeRef representations to the right.
   *  {{{
   *     T # C[T_1, ..., T_n]      TypeRef(T, C, List(T_1, ..., T_n))
   *     p.C[T_1, ..., T_n]        TypeRef(p.type, C, List(T_1, ..., T_n))
   *     C[T_1, ..., T_n]          TypeRef(NoPrefix, C, List(T_1, ..., T_n))
   *     T # C                     TypeRef(T, C, Nil)
   *     p.C                       TypeRef(p.type, C, Nil)
   *     C                         TypeRef(NoPrefix, C, Nil)
   *  }}}
   */
  <span class="keyword">type</span> <a title="&gt;: Nothing &lt;: Types.this.Type" id="28378">TypeRef</a> &lt;: Type

  /** The constructor/deconstructor for `TypeRef` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.TypeRefExtractor" id="28379">TypeRef</a>: <a href="#28380" title="Types.this.TypeRefExtractor">TypeRefExtractor</a>

  /** An extractor class to create and pattern match with syntax `TypeRef(pre, sym, args)`
   *  Here, `pre` is the prefix of the type reference, `sym` is the symbol
   *  referred to by the type reference, and `args` is a possible empty list of
   *  type argumenrts.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeRefExtractor extends Object with ScalaObject" id="28380">TypeRefExtractor</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="385889">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="385892">pre</a>: <a href="#28371" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="385893">sym</a>: <a href="Symbols.scala.html#28350" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="385894">args</a>: <a href="../../collection/immutable/List.scala.html#12053" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#28371" title="Types.this.Type">Type</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.TypeRef)Option[(Types.this.Type, Types.this.Symbol, List[Types.this.Type])]" id="385890">unapply</a><span class="delimiter">(</span><a title="Types.this.TypeRef" id="385896">tpe</a>: <a href="#28378" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[(Types.this.Type, Types.this.Symbol, List[Types.this.Type])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Type, Symbol, List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The `SingleType` type describes types of any of the forms on the left,
   *  with their TypeRef representations to the right.
   *  {{{
   *     (T # x).type             SingleType(T, x)
   *     p.x.type                 SingleType(p.type, x)
   *     x.type                   SingleType(NoPrefix, x)
   */
  <span class="keyword">type</span> <a title="&gt;: Nothing &lt;: Types.this.SingletonType" id="28381">SingleType</a> &lt;: SingletonType

  /** The constructor/deconstructor for `SingleType` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.SingleTypeExtractor" id="28382">SingleType</a>: <a href="#28383" title="Types.this.SingleTypeExtractor">SingleTypeExtractor</a>

  /** An extractor class to create and pattern match with syntax `SingleType(pre, sym)`
   *  Here, `pre` is the prefix of the single-type, and `sym` is the stable value symbol
   *  referred to by the single-type.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SingleTypeExtractor extends Object with ScalaObject" id="28383">SingleTypeExtractor</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="378412">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="378414">pre</a>: <a href="#28371" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="378415">sym</a>: <a href="Symbols.scala.html#28350" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#28371" title="Types.this.Type">Type</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.SingleType)Option[(Types.this.Type, Types.this.Symbol)]" id="378413">unapply</a><span class="delimiter">(</span><a title="Types.this.SingleType" id="385899">tpe</a>: <a href="#28381" title="Types.this.SingleType">SingleType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[(Types.this.Type, Types.this.Symbol)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Type, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The `SuperType` type is not directly written, but arises when `C.super` is used
   *  as a prefix in a `TypeRef` or `SingleType`. It's internal presentation is
   *  {{{
   *     SuperType(thistpe, supertpe)
   *  }}}
   *  Here, `thistpe` is the type of the corresponding this-type. For instance,
   *  in the type arising from C.super, the `thistpe` part would be `ThisType(C)`.
   *  `supertpe` is the type of the super class referred to by the `super`.
   */
  <span class="keyword">type</span> <a title="&gt;: Nothing &lt;: Types.this.SingletonType" id="28384">SuperType</a> &lt;: SingletonType

  /** The constructor/deconstructor for `SuperType` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.SuperTypeExtractor" id="28385">SuperType</a>: <a href="#28386" title="Types.this.SuperTypeExtractor">SuperTypeExtractor</a>

  /** An extractor class to create and pattern match with syntax `SingleType(thistpe, supertpe)`
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SuperTypeExtractor extends Object with ScalaObject" id="28386">SuperTypeExtractor</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(thistpe: Types.this.Type, supertpe: Types.this.Type)Types.this.Type" id="385902">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="385905">thistpe</a>: <a href="#28371" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="385906">supertpe</a>: <a href="#28371" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#28371" title="Types.this.Type">Type</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.SuperType)Option[(Types.this.Type, Types.this.Type)]" id="385903">unapply</a><span class="delimiter">(</span><a title="Types.this.SuperType" id="385908">tpe</a>: <a href="#28384" title="Types.this.SuperType">SuperType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[(Types.this.Type, Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Type, Type<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The `ConstantType` type is not directly written in user programs, but arises as the type of a constant.
   *  The REPL expresses constant types like   Int(11).  Here are some constants with their types.
   *  {{{
   *     1           ConstantType(Constant(1))
   *     &quot;abc&quot;       ConstantType(Constant(&quot;abc&quot;))
   *  }}}
   */
  <span class="keyword">type</span> <a title="&gt;: Nothing &lt;: Types.this.SingletonType" id="28387">ConstantType</a> &lt;: SingletonType

  /** The constructor/deconstructor for `ConstantType` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.ConstantTypeExtractor" id="28388">ConstantType</a>: <a href="#28389" title="Types.this.ConstantTypeExtractor">ConstantTypeExtractor</a>

  /** An extractor class to create and pattern match with syntax `ConstantType(constant)`
   *  Here, `constant` is the constant value represented by the type.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ConstantTypeExtractor extends Object with ScalaObject" id="28389">ConstantTypeExtractor</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(value: Types.this.Constant)Types.this.ConstantType" id="385911">apply</a><span class="delimiter">(</span><a title="Types.this.Constant" id="385914">value</a>: <a href="Constants.scala.html#28420" title="Types.this.Constant">Constant</a><span class="delimiter">)</span>: <a href="#28387" title="Types.this.ConstantType">ConstantType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.ConstantType)Option[Types.this.Constant]" id="385912">unapply</a><span class="delimiter">(</span><a title="Types.this.ConstantType" id="385916">tpe</a>: <a href="#28387" title="Types.this.ConstantType">ConstantType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[Types.this.Constant]">Option</a><span class="delimiter">[</span>Constant<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** A subtype of Type representing refined types as well as `ClassInfo` signatures.
   */
  <span class="keyword">type</span> <a title="&gt;: Nothing &lt;: Types.this.Type" id="28390">CompoundType</a> &lt;: /*AbsCompoundType with*/ Type

  /** The `RefinedType` type defines types of any of the forms on the left,
   *  with their RefinedType representations to the right.
   *  {{{
   *     P_1 with ... with P_m { D_1; ...; D_n}      RefinedType(List(P_1, ..., P_m), Scope(D_1, ..., D_n))
   *     P_1 with ... with P_m                       RefinedType(List(P_1, ..., P_m), Scope())
   *     { D_1; ...; D_n}                            RefinedType(List(AnyRef), Scope(D_1, ..., D_n))
   *  }}}
   */
  <span class="keyword">type</span> <a title="&gt;: Nothing &lt;: Types.this.CompoundType" id="28391">RefinedType</a> &lt;: CompoundType

  /** The constructor/deconstructor for `RefinedType` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.RefinedTypeExtractor" id="28392">RefinedType</a>: <a href="#28393" title="Types.this.RefinedTypeExtractor">RefinedTypeExtractor</a>

  /** An extractor class to create and pattern match with syntax `RefinedType(parents, decls)`
   *  Here, `parents` is the list of parent types of the class, and `decls` is the scope
   *  containing all declarations in the class.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class RefinedTypeExtractor extends Object with ScalaObject" id="28393">RefinedTypeExtractor</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.RefinedType" id="378836">apply</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="378845">parents</a>: <a href="../../collection/immutable/List.scala.html#12053" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="378846">decls</a>: <a href="Scopes.scala.html#28424" title="Types.this.Scope">Scope</a><span class="delimiter">)</span>: <a href="#28391" title="Types.this.RefinedType">RefinedType</a>

    /** An alternative constructor that passes in the synthetic classs symbol
     *  that backs the refined type. (Normally, a fresh class symbol is created automatically).
     */
    <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType" id="378837">apply</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="378841">parents</a>: <a href="../../collection/immutable/List.scala.html#12053" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="378842">decls</a>: <a href="Scopes.scala.html#28424" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="378843">clazz</a>: <a href="Symbols.scala.html#28350" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#28391" title="Types.this.RefinedType">RefinedType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.RefinedType)Option[(List[Types.this.Type], Types.this.Scope)]" id="378838">unapply</a><span class="delimiter">(</span><a title="Types.this.RefinedType" id="385919">tpe</a>: <a href="#28391" title="Types.this.RefinedType">RefinedType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[(List[Types.this.Type], Types.this.Scope)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span>, Scope<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="&gt;: Nothing &lt;: Types.this.Type" id="28394">NullaryMethodType</a> &lt;: Type
  <span class="keyword">val</span> <a title="=&gt; Types.this.NullaryMethodTypeExtractor" id="28395">NullaryMethodType</a>: <a href="#28411" title="Types.this.NullaryMethodTypeExtractor">NullaryMethodTypeExtractor</a>

  <span class="keyword">type</span> <a title="&gt;: Nothing &lt;: Types.this.Type" id="28396">PolyType</a> &lt;: Type
  <span class="keyword">val</span> <a title="=&gt; Types.this.PolyTypeExtractor" id="28397">PolyType</a>: <a href="#28412" title="Types.this.PolyTypeExtractor">PolyTypeExtractor</a>

  <span class="keyword">type</span> <a title="&gt;: Nothing &lt;: Types.this.Type" id="28398">ExistentialType</a> &lt;: Type
  <span class="keyword">val</span> <a title="=&gt; Types.this.ExistentialTypeExtractor" id="28399">ExistentialType</a>: <a href="#28413" title="Types.this.ExistentialTypeExtractor">ExistentialTypeExtractor</a>

  <span class="keyword">type</span> <a title="&gt;: Nothing &lt;: Types.this.Type" id="28400">AnnotatedType</a> &lt;: Type
  <span class="keyword">val</span> <a title="=&gt; Types.this.AnnotatedTypeExtractor" id="28401">AnnotatedType</a>: <a href="#28414" title="Types.this.AnnotatedTypeExtractor">AnnotatedTypeExtractor</a>

  /** The `MethodType` type signature is used to indicate parameters and result type of a method
   */
  <span class="keyword">type</span> <a title="&gt;: Nothing &lt;: Types.this.Type" id="28402">MethodType</a> &lt;: Type

  /** The constructor/deconstructor for `MethodType` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.MethodTypeExtractor" id="28403">MethodType</a>: <a href="#28404" title="Types.this.MethodTypeExtractor">MethodTypeExtractor</a>

  /** An extractor class to create and pattern match with syntax `MethodType(params, respte)`
   *  Here, `params` is a potentially empty list of parameter symbols of the method,
   *  and `restpe` is the result type of the method. If the method is curried, `restpe` would
   *  be another `MethodType`.
   *  Note: `MethodType(Nil, Int)` would be the type of a method defined with an empty parameter list.
   *  {{{
   *     def f(): Int
   *  }}}
   *  If the method is completely parameterless, as in
   *  {{{
   *     def f: Int
   *  }}}
   *  its type is a `NullaryMethodType`.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class MethodTypeExtractor extends Object with ScalaObject" id="28404">MethodTypeExtractor</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType" id="385934">apply</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="385937">params</a>: <a href="../../collection/immutable/List.scala.html#12053" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="385938">resultType</a>: <a href="#28371" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#28402" title="Types.this.MethodType">MethodType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.MethodType)Option[(List[Types.this.Symbol], Types.this.Type)]" id="385935">unapply</a><span class="delimiter">(</span><a title="Types.this.MethodType" id="385940">tpe</a>: <a href="#28402" title="Types.this.MethodType">MethodType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[(List[Types.this.Symbol], Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, Type<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The `TypeBounds` type signature is used to indicate lower and upper type bounds
   *  of type parameters and abstract types. It is not a first-class type.
   *  If an abstract type or type parameter is declared with any of the forms
   *  on the left, its type signature is the TypeBounds type on the right.
   *  {{{
   *     T &gt;: L &lt;: U               TypeBounds(L, U)
   *     T &gt;: L                    TypeBounds(L, Any)
   *     T &lt;: U                    TypeBounds(Nothing, U)
   *  }}}
   */
  <span class="keyword">type</span> <a title="&gt;: Nothing &lt;: Types.this.Type" id="28405">TypeBounds</a> &lt;: Type

  /** The constructor/deconstructor for `TypeBounds` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.TypeBoundsExtractor" id="28406">TypeBounds</a>: <a href="#28407" title="Types.this.TypeBoundsExtractor">TypeBoundsExtractor</a>

  /** An extractor class to create and pattern match with syntax `TypeBound(lower, upper)`
   *  Here, `lower` is the lower bound of the `TypeBounds` pair, and `upper` is
   *  the upper bound.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeBoundsExtractor extends Object with ScalaObject" id="28407">TypeBoundsExtractor</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds" id="378799">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="378801">lo</a>: <a href="#28371" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="378802">hi</a>: <a href="#28371" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#28405" title="Types.this.TypeBounds">TypeBounds</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.TypeBounds)Option[(Types.this.Type, Types.this.Type)]" id="378800">unapply</a><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="385943">tpe</a>: <a href="#28405" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[(Types.this.Type, Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Type, Type<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The `ClassInfo` type signature is used to define parents and declarations
   *  of classes, traits, and objects. If a class, trait, or object C is declared like this
   *  {{{
   *     C extends P_1 with ... with P_m { D_1; ...; D_n}
   *  }}}
   *  its `ClassInfo` type has the following form:
   *  {{{
   *     ClassInfo(List(P_1, ..., P_m), Scope(D_1, ..., D_n), C)
   *  }}}
   */
  <span class="keyword">type</span> <a title="&gt;: Nothing &lt;: Types.this.CompoundType" id="28408">ClassInfoType</a> &lt;: CompoundType

  /** The constructor/deconstructor for `ClassInfoType` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.ClassInfoTypeExtractor" id="28409">ClassInfoType</a>: <a href="#28410" title="Types.this.ClassInfoTypeExtractor">ClassInfoTypeExtractor</a>

  /** An extractor class to create and pattern match with syntax `ClassInfo(parents, decls, clazz)`
   *  Here, `parents` is the list of parent types of the class, `decls` is the scope
   *  containing all declarations in the class, and `clazz` is the symbol of the class
   *  itself.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ClassInfoTypeExtractor extends Object with ScalaObject" id="28410">ClassInfoTypeExtractor</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.ClassInfoType" id="385946">apply</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="385949">parents</a>: <a href="../../collection/immutable/List.scala.html#12053" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="385950">decls</a>: <a href="Scopes.scala.html#28424" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="385951">clazz</a>: <a href="Symbols.scala.html#28350" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#28408" title="Types.this.ClassInfoType">ClassInfoType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.ClassInfoType)Option[(List[Types.this.Type], Types.this.Scope, Types.this.Symbol)]" id="385947">unapply</a><span class="delimiter">(</span><a title="Types.this.ClassInfoType" id="385953">tpe</a>: <a href="#28408" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[(List[Types.this.Type], Types.this.Scope, Types.this.Symbol)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span>, Scope, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>






  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class NullaryMethodTypeExtractor extends Object with ScalaObject" id="28411">NullaryMethodTypeExtractor</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(resultType: Types.this.Type)Types.this.NullaryMethodType" id="385922">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="385956">resultType</a>: <a href="#28371" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#28394" title="Types.this.NullaryMethodType">NullaryMethodType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.NullaryMethodType)Option[Types.this.Type]" id="385923">unapply</a><span class="delimiter">(</span><a title="Types.this.NullaryMethodType" id="385958">tpe</a>: <a href="#28394" title="Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[Types.this.Type]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Type<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class PolyTypeExtractor extends Object with ScalaObject" id="28412">PolyTypeExtractor</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType" id="385925">apply</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="385961">typeParams</a>: <a href="../../collection/immutable/List.scala.html#12053" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="385962">resultType</a>: <a href="#28371" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#28396" title="Types.this.PolyType">PolyType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.PolyType)Option[(List[Types.this.Symbol], Types.this.Type)]" id="385926">unapply</a><span class="delimiter">(</span><a title="Types.this.PolyType" id="385964">tpe</a>: <a href="#28396" title="Types.this.PolyType">PolyType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[(List[Types.this.Symbol], Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, Type<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ExistentialTypeExtractor extends Object with ScalaObject" id="28413">ExistentialTypeExtractor</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType" id="385928">apply</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="385967">quantified</a>: <a href="../../collection/immutable/List.scala.html#12053" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="385968">underlying</a>: <a href="#28371" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#28398" title="Types.this.ExistentialType">ExistentialType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.ExistentialType)Option[(List[Types.this.Symbol], Types.this.Type)]" id="385929">unapply</a><span class="delimiter">(</span><a title="Types.this.ExistentialType" id="385970">tpe</a>: <a href="#28398" title="Types.this.ExistentialType">ExistentialType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[(List[Types.this.Symbol], Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, Type<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class AnnotatedTypeExtractor extends Object with ScalaObject" id="28414">AnnotatedTypeExtractor</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType" id="385931">apply</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="385973">annotations</a>: <a href="../../collection/immutable/List.scala.html#12053" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span>, <a title="Types.this.Type" id="385974">underlying</a>: <a href="#28371" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="385975">selfsym</a>: <a href="Symbols.scala.html#28350" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#28400" title="Types.this.AnnotatedType">AnnotatedType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.AnnotatedType)Option[(List[Types.this.AnnotationInfo], Types.this.Type, Types.this.Symbol)]" id="385932">unapply</a><span class="delimiter">(</span><a title="Types.this.AnnotatedType" id="385977">tpe</a>: <a href="#28400" title="Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[(List[Types.this.AnnotationInfo], Types.this.Type, Types.this.Symbol)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span>, Type, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The least upper bound wrt &lt;:&lt; of a list of types */
  <span class="keyword">def</span> <a title="(xs: List[Types.this.Type])Types.this.Type" id="28415">lub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="385979">xs</a>: <a href="../../collection/immutable/List.scala.html#12053" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#28371" title="Types.this.Type">Type</a>

    /** The greatest lower bound wrt &lt;:&lt; of a list of types */
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="28416">glb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="385981">ts</a>: <a href="../../collection/immutable/List.scala.html#12053" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#28371" title="Types.this.Type">Type</a>
<span class="delimiter">}</span>


        </pre>
    </body>
</html>