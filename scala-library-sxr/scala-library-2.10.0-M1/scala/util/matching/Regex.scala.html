<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/util/matching/Regex.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2007-2011, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */


/**
 * This package is concerned with regular expression (regex) matching against strings,
 * with the main goal of pulling out information from those matches, or replacing
 * them with something else.
 *
 * There are four classes and three objects, with most of them being members of
 * Regex companion object. [[scala.util.matching.Regex]] is the class users instantiate
 * to do regular expression matching.
 *
 * The remaining classes and objects in the package are used in the following way:
 *
 * * The companion object to [[scala.util.matching.Regex]] just contains the other members.
 * * [[scala.util.matching.Regex.Match]] makes more information about a match available.
 * * [[scala.util.matching.Regex.MatchIterator]] is used to iterate over multiple matches.
 * * [[scala.util.matching.Regex.MatchData]] is just a base trait for the above classes.
 * * [[scala.util.matching.Regex.Groups]] extracts group from a [[scala.util.matching.Regex.Match]]
 *   without recomputing the match.
 * * [[scala.util.matching.Regex.Match]] converts a [[scala.util.matching.Regex.Match]]
 *   into a [[java.lang.String]].
 *
 */
<span class="keyword">package</span> scala.util.matching

<span class="keyword">import</span> scala.collection.AbstractIterator
<span class="keyword">import</span> java.util.regex.<span class="delimiter">{</span> Pattern, Matcher <span class="delimiter">}</span>

/** This class provides methods for creating and using regular expressions.
 *  It is based on the regular expressions of the JDK since 1.4.
 *
 *  Its main goal is to extract strings that match a pattern, or the subgroups
 *  that make it up. For that reason, it is usually used with for comprehensions
 *  and matching (see methods for examples).
 *
 *  A Regex is created from a [[java.lang.String]] representation of the
 *  regular expression pattern^1^. That pattern is compiled
 *  during construction, so frequently used patterns should be declared outside
 *  loops if performance is of concern. Possibly, they might be declared on a
 *  companion object, so that they need only to be initialized once.
 *
 *  The canonical way of creating regex patterns is by using the method `r`, provided
 *  on [[java.lang.String]] through an implicit conversion into
 *  [[scala.collection.immutable.WrappedString]]. Using triple quotes to write these
 *  strings avoids having to quote the backslash character (`\`).
 *
 *  Using the constructor directly, on the other hand, makes
 *  it possible to declare names for subgroups in the pattern.
 *
 *  For example, both declarations below generate the same regex, but the second
 *  one associate names with the subgroups.
 *
 *  {{{
 *  val dateP1 = &quot;&quot;&quot;(\d\d\d\d)-(\d\d)-(\d\d)&quot;&quot;&quot;.r
 *  val dateP2 = new scala.util.matching.Regex(&quot;&quot;&quot;(\d\d\d\d)-(\d\d)-(\d\d)&quot;&quot;&quot;, &quot;year&quot;, &quot;month&quot;, &quot;day&quot;)
 *  }}}
 *
 *  There are two ways of using a `Regex` to find a pattern: calling methods on
 *  Regex, such as `findFirstIn` or `findAllIn`, or using it as an extractor in a
 *  pattern match.
 *
 *  Note, however, that when Regex is used as an extractor in a pattern match, it
 *  only succeeds if the whole text can be matched. For this reason, one usually
 *  calls a method to find the matching substrings, and then use it as an extractor
 *  to break match into subgroups.
 *
 *  As an example, the above patterns can be used like this:
 *
 *  {{{
 *  val dateP1(year, month, day) = &quot;2011-07-15&quot;
 *
 *  // val dateP1(year, month, day) = &quot;Date 2011-07-15&quot; // throws an exception at runtime
 *
 *  val copyright: String = dateP1 findFirstIn &quot;Date of this document: 2011-07-15&quot; match {
 *    case Some(dateP1(year, month, day)) =&gt; &quot;Copyright &quot;+year
 *    case None                           =&gt; &quot;No copyright&quot;
 *  }
 *
 *  val copyright: Option[String] = for {
 *    dateP1(year, month, day) &lt;- dateP1 findFirstIn &quot;Last modified 2011-07-15&quot;
 *  } yield year

 *  def getYears(text: String): Iterator[String] = for (dateP1(year, _, _) &lt;- dateP1 findAllIn text) yield year
 *  def getFirstDay(text: String): Option[String] = for (m &lt;- dateP2 findFirstMatchIn text) yield m group &quot;day&quot;
 *  }}}
 *
 *  Regex does not provide a method that returns a [[scala.Boolean]]. One can
 *  use [[java.lang.String]] `matches` method, or, if `Regex` is preferred,
 *  either ignore the return value or test the `Option` for emptyness. For example:
 *
 *  {{{
 *  def hasDate(text: String): Boolean = (dateP1 findFirstIn text).nonEmpty
 *  def printLinesWithDates(lines: Traversable[String]) {
 *    lines foreach { line =&gt;
 *      dateP1 findFirstIn line foreach { _ =&gt; println(line) }
 *    }
 *  }
 *  }}}
 *
 *  There are also methods that can be used to replace the patterns
 *  on a text. The substitutions can be simple replacements, or more
 *  complex functions. For example:
 *
 *  {{{
 *  val months = Map( 1 -&gt; &quot;Jan&quot;, 2 -&gt; &quot;Feb&quot;, 3 -&gt; &quot;Mar&quot;,
 *                    4 -&gt; &quot;Apr&quot;, 5 -&gt; &quot;May&quot;, 6 -&gt; &quot;Jun&quot;,
 *                    7 -&gt; &quot;Jul&quot;, 8 -&gt; &quot;Aug&quot;, 9 -&gt; &quot;Sep&quot;,
 *                    10 -&gt; &quot;Oct&quot;, 11 -&gt; &quot;Nov&quot;, 12 -&gt; &quot;Dec&quot;)
 *
 *  import scala.util.matching.Regex.Match
 *  def reformatDate(text: String) = dateP2 replaceAllIn ( text, (m: Match) =&gt;
 *    &quot;%s %s, %s&quot; format (months(m group &quot;month&quot; toInt), m group &quot;day&quot;, m group &quot;year&quot;)
 *  )
 *  }}}
 *
 *  You can use special pattern syntax constructs like `(?idmsux-idmsux)`ยน to switch
 *  various regex compilation options like `CASE_INSENSITIVE` or `UNICODE_CASE`.
 *
 *  @note ยน A detailed description is available in [[java.util.regex.Pattern]].
 *  @see [[java.util.regex.Pattern]]
 *
 *  @author  Thibaud Hottelier
 *  @author  Philipp Haller
 *  @author  Martin Odersky
 *  @version 1.1, 29/01/2008
 *
 *  @param regex      A string representing a regular expression
 *  @param groupNames A mapping from names to indices in capture groups
 */
@SerialVersionUID<span class="delimiter">(</span>-<span class="long">2094783597747625537L</span><span class="delimiter">)</span>
<span class="keyword">class</span> <a title="class Regex extends Object with Serializable with ScalaObject" id="19955">Regex</a><a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">(</a><a title="String" id="209883">regex</a>: <span title="String">String</span>, <a title="String*" id="209884">groupNames</a>: <span title="String*">String</span>*<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="../../Serializable.scala.html#886" title="Serializable">Serializable</a> <span class="delimiter">{</span>

  <span class="keyword">import</span> <a href="#411201" title="object scala.util.matching.Regex">Regex</a>._

  /** The compiled pattern */
  <span class="keyword">val</span> <a title="java.util.regex.Pattern" id="209869">pattern</a> = <span title="object java.util.regex.Pattern">Pattern</span>.<span title="(x$1: String)java.util.regex.Pattern">compile</span><span class="delimiter">(</span><a href="#209883" title="String">regex</a><span class="delimiter">)</span>

  /** Tries to match target (whole match) and returns the matching subgroups.
   *  if the pattern has no subgroups, then it returns an empty list on a
   *  successful match.
   *
   *  Note, however, that if some subgroup has not been matched, a `null` will
   *  be returned for that subgroup.
   *
   *  For example:
   *
   *  {{{
   *  val p1 = &quot;ab*c&quot;.r
   *  val p2 = &quot;a(b*)c&quot;.r
   *
   *  val p1Matches = &quot;abbbc&quot; match {
   *    case p1() =&gt; true
   *    case _    =&gt; false
   *  }
   *
   *  val numberOfB = &quot;abbbc&quot; match {
   *    case p2(b) =&gt; Some(b.length)
   *    case _     =&gt; None
   *  }
   *  }}}
   *
   *  @param target The string to match
   *  @return       The matches
   */
  <span class="keyword">def</span> <a title="(target: Any)Option[List[String]]" id="209871">unapplySeq</a><span class="delimiter">(</span><a title="Any" id="409678">target</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[List[String]]">Option</a><span class="delimiter">[</span>List<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#409678" title="Any">target</a> <span title="Option[List[String]]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a title="Option[List[String]]" id="409680">s</a>: java.lang.<span title="CharSequence">CharSequence</span> =&gt;
      <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="409681">m</a> = <a href="#209869" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#409680" title="CharSequence">s</a><span class="delimiter">)</span>
      <span title="Option[List[String]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#409681" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">matches</span><span class="delimiter">)</span> <a href="../../Option.scala.html#29745" title="(x: List[String])Some[List[String]]">Some</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="../../LowPriorityImplicits.scala.html#7396" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">1</a> <a href="../../runtime/RichInt.scala.html#23866" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#409681" title="java.util.regex.Matcher">m</a>.<span title="()Int">groupCount</span><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#25104" title="=&gt; List[Int]">toList</a> <a href="../../collection/TraversableLike.scala.html#23327" title="(f: Int =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Int],String,List[String]])List[String]">map</a> <a href="#409681" title="java.util.regex.Matcher">m</a>.<a href="#409830" title="(x$1: Int)String">group</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="../../Option.scala.html#1700" title="object None">None</a>
    <span class="keyword">case</span> <a href="#409864" title="Option[List[String]]">Match</a><span class="delimiter">(</span><a title="String" id="409910">s</a><span class="delimiter">)</span> =&gt;
      <a href="#209871" title="(target: Any)Option[List[String]]">unapplySeq</a><span class="delimiter">(</span><a href="#409910" title="String">s</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="None.type">_</span> =&gt;
      <a href="../../Option.scala.html#1700" title="object None">None</a>
  <span class="delimiter">}</span>

  /** Return all matches of this regexp in given character sequence as a [[scala.util.mathcing.Regex.MatchIterator]],
   *  which is a special [[scala.collection.Iterator]] that returns the
   *  matched strings, but can also be converted into a normal iterator
   *  that returns objects of type [[scala.util.matching.Regex.Match]]
   *  that can be queried for data such as the text that precedes the
   *  match, subgroups, etc.
   *
   *  @param source The text to match against.
   *  @return       A [[scala.util.matching.Regex.MatchIterator]] of all matches.
   *  @example      {{{for (words &lt;- &quot;&quot;&quot;\w+&quot;&quot;&quot;.r findAllIn &quot;A simple example.&quot;) yield words}}}
   */
  <span class="keyword">def</span> <a title="(source: CharSequence)scala.util.matching.Regex.MatchIterator" id="209872">findAllIn</a><span class="delimiter">(</span><a title="CharSequence" id="409911">source</a>: java.lang.<span title="CharSequence">CharSequence</span><span class="delimiter">)</span> = <span title="scala.util.matching.Regex.MatchIterator" class="keyword">new</span> <a href="#411201" title="object scala.util.matching.Regex">Regex</a>.<a href="#409674" title="scala.util.matching.Regex.MatchIterator">MatchIterator</a><span class="delimiter">(</span><a href="#409911" title="CharSequence">source</a>, <a href="#19955" title="scala.util.matching.Regex" class="keyword">this</a>, <a href="#209884" title="String*">groupNames</a><span class="delimiter">)</span>

  /** Return optionally first matching string of this regexp in given character sequence,
   *  or None if it does not exist.
   *
   *  @param source The text to match against.
   *  @return       An [[scala.Option]] of the first matching string in the text.
   *  @example      {{{&quot;&quot;&quot;\w+&quot;&quot;&quot;.r findFirstIn &quot;A simple example.&quot; foreach println // prints &quot;A&quot;}}}
   */
  <span class="keyword">def</span> <a title="(source: CharSequence)Option[String]" id="209873">findFirstIn</a><span class="delimiter">(</span><a title="CharSequence" id="409943">source</a>: java.lang.<span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[String]">Option</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="409945">m</a> = <a href="#209869" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#409943" title="CharSequence">source</a><span class="delimiter">)</span>
    <span title="Option[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#409945" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">find</span><span class="delimiter">)</span> <a href="../../Option.scala.html#29745" title="(x: String)Some[String]">Some</a><span class="delimiter">(</span><a href="#409945" title="java.util.regex.Matcher">m</a>.<span title="()String">group</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="../../Option.scala.html#1700" title="object None">None</a>
  <span class="delimiter">}</span>

  /** Return optionally first match of this regexp in given character sequence,
   *  or None if it does not exist.
   *
   *  The main difference between this method and `findFirstIn` is that the (optional) return
   *  type for this is [[scala.util.matching.Regex.Match]], through which more
   *  data can be obtained about the match, such as the strings that precede and follow it,
   *  or subgroups.
   *
   *  @param source The text to match against.
   *  @return       A [[scala.Option]] of [[scala.util.matching.Regex.Match]] of the first matching string in the text.
   *  @example      {{{(&quot;&quot;&quot;[a-z]&quot;&quot;&quot;.r findFirstMatchIn &quot;A simple example.&quot;) map (_.start) // returns Some(2), the index of the first match in the text}}}
   */
  <span class="keyword">def</span> <a title="(source: CharSequence)Option[scala.util.matching.Regex.Match]" id="209874">findFirstMatchIn</a><span class="delimiter">(</span><a title="CharSequence" id="409953">source</a>: java.lang.<span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[scala.util.matching.Regex.Match]">Option</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="409955">m</a> = <a href="#209869" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#409953" title="CharSequence">source</a><span class="delimiter">)</span>
    <span title="Option[scala.util.matching.Regex.Match]" class="keyword">if</span> <span class="delimiter">(</span><a href="#409955" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">find</span><span class="delimiter">)</span> <a href="../../Option.scala.html#29745" title="(x: scala.util.matching.Regex.Match)Some[scala.util.matching.Regex.Match]">Some</a><span class="delimiter">(</span><span title="scala.util.matching.Regex.Match" class="keyword">new</span> <a href="#409669" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">(</span><a href="#409953" title="CharSequence">source</a>, <a href="#409955" title="java.util.regex.Matcher">m</a>, <a href="#209884" title="String*">groupNames</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="../../Option.scala.html#1700" title="object None">None</a>
  <span class="delimiter">}</span>

  /** Return optionally match of this regexp at the beginning of the
   *  given character sequence, or None if regexp matches no prefix
   *  of the character sequence.
   *
   *  The main difference from this method to `findFirstIn` is that this
   *  method will not return any matches that do not begin at the start
   *  of the text being matched against.
   *
   *  @param source The text to match against.
   *  @return       A [[scala.Option]] of the matched prefix.
   *  @example      {{{&quot;&quot;&quot;[a-z]&quot;&quot;&quot;.r findPrefixOf &quot;A simple example.&quot; // returns None, since the text does not begin with a lowercase letter}}}
   */
  <span class="keyword">def</span> <a title="(source: CharSequence)Option[String]" id="209875">findPrefixOf</a><span class="delimiter">(</span><a title="CharSequence" id="409964">source</a>: java.lang.<span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[String]">Option</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="409966">m</a> = <a href="#209869" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#409964" title="CharSequence">source</a><span class="delimiter">)</span>
    <span title="Option[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#409966" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">lookingAt</span><span class="delimiter">)</span> <a href="../../Option.scala.html#29745" title="(x: String)Some[String]">Some</a><span class="delimiter">(</span><a href="#409966" title="java.util.regex.Matcher">m</a>.<span title="()String">group</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="../../Option.scala.html#1700" title="object None">None</a>
  <span class="delimiter">}</span>

  /** Return optionally match of this regexp at the beginning of the
   *  given character sequence, or None if regexp matches no prefix
   *  of the character sequence.
   *
   *  The main difference from this method to `findFirstMatchIn` is that
   *  this method will not return any matches that do not begin at the
   *  start of the text being matched against.
   *
   *  @param source The text to match against.
   *  @return       A [[scala.Option]] of the [[scala.util.matching.Regex.Match]] of the matched string.
   *  @example      {{{&quot;&quot;&quot;\w+&quot;&quot;&quot;.r findPrefixMatchOf &quot;A simple example.&quot; map (_.after) // returns Some(&quot; simple example.&quot;)}}}
   */
  <span class="keyword">def</span> <a title="(source: CharSequence)Option[scala.util.matching.Regex.Match]" id="209876">findPrefixMatchOf</a><span class="delimiter">(</span><a title="CharSequence" id="409972">source</a>: java.lang.<span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[scala.util.matching.Regex.Match]">Option</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="409974">m</a> = <a href="#209869" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#409972" title="CharSequence">source</a><span class="delimiter">)</span>
    <span title="Option[scala.util.matching.Regex.Match]" class="keyword">if</span> <span class="delimiter">(</span><a href="#409974" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">lookingAt</span><span class="delimiter">)</span> <a href="../../Option.scala.html#29745" title="(x: scala.util.matching.Regex.Match)Some[scala.util.matching.Regex.Match]">Some</a><span class="delimiter">(</span><span title="scala.util.matching.Regex.Match" class="keyword">new</span> <a href="#409669" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">(</span><a href="#409972" title="CharSequence">source</a>, <a href="#409974" title="java.util.regex.Matcher">m</a>, <a href="#209884" title="String*">groupNames</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="../../Option.scala.html#1700" title="object None">None</a>
  <span class="delimiter">}</span>

  /** Replaces all matches by a string.
   *
   *  @param target      The string to match
   *  @param replacement The string that will replace each match
   *  @return            The resulting string
   *  @example           {{{&quot;&quot;&quot;\d+&quot;&quot;&quot;.r replaceAllIn (&quot;July 15&quot;, &quot;&lt;NUMBER&gt;&quot;) // returns &quot;July &lt;NUMBER&gt;&quot;}}}
   */
  <span class="keyword">def</span> <a title="(target: CharSequence, replacement: String)String" id="209877">replaceAllIn</a><span class="delimiter">(</span><a title="CharSequence" id="409978">target</a>: java.lang.<span title="CharSequence">CharSequence</span>, <a title="String" id="409979">replacement</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="409981">m</a> = <a href="#209869" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#409978" title="CharSequence">target</a><span class="delimiter">)</span>
    <a href="#409981" title="java.util.regex.Matcher">m</a>.<span title="(x$1: String)String">replaceAll</span><span class="delimiter">(</span><a href="#409979" title="String">replacement</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /**
   * Replaces all matches using a replacer function. The replacer function takes a
   * [[scala.util.matching.Regex.Match]] so that extra information can be obtained
   * from the match. For example:
   *
   * {{{
   * import scala.util.matching.Regex
   * val datePattern = new Regex(&quot;&quot;&quot;(\d\d\d\d)-(\d\d)-(\d\d)&quot;&quot;&quot;, &quot;year&quot;, &quot;month&quot;, &quot;day&quot;)
   * val text = &quot;From 2011-07-15 to 2011-07-17&quot;
   * val repl = datePattern replaceAllIn (text, m =&gt; m.group(&quot;month&quot;)+&quot;/&quot;+m.group(&quot;day&quot;))
   * }}}
   *
   * @param target      The string to match.
   * @param replacer    The function which maps a match to another string.
   * @return            The target string after replacements.
   */
  <span class="keyword">def</span> <a title="(target: CharSequence, replacer: scala.util.matching.Regex.Match =&gt; String)String" id="209878">replaceAllIn</a><span class="delimiter">(</span><a title="CharSequence" id="409982">target</a>: java.lang.<span title="CharSequence">CharSequence</span>, <a title="scala.util.matching.Regex.Match =&gt; String" id="409983">replacer</a>: Match =&gt; String<span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="replacementData extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement" id="409985">it</a> = <span title="scala.util.matching.Regex.MatchIterator" class="keyword">new</span> <a href="#411201" title="object scala.util.matching.Regex">Regex</a>.<a href="#409674" title="scala.util.matching.Regex.MatchIterator">MatchIterator</a><span class="delimiter">(</span><a href="#409982" title="CharSequence">target</a>, <a href="#19955" title="scala.util.matching.Regex" class="keyword">this</a>, <a href="#209884" title="String*">groupNames</a><span class="delimiter">)</span>.<a href="#409939" title="=&gt; scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">replacementData</a>
    <a href="#409985" title="replacementData extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">it</a> <a href="../../collection/Iterator.scala.html#31060" title="(f: scala.util.matching.Regex.Match =&gt; java.util.regex.Matcher)Unit">foreach</a> <span class="delimiter">(</span><a title="scala.util.matching.Regex.Match" id="410040">md</a> =&gt; <a href="#409985" title="replacementData extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">it</a> <a href="#410000" title="(rs: String)java.util.regex.Matcher">replace</a> <a href="../../Function1.scala.html#25386" title="(v1: scala.util.matching.Regex.Match)String">replacer</a><span class="delimiter">(</span><a href="#410040" title="scala.util.matching.Regex.Match">md</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#409985" title="replacementData extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">it</a>.<a href="#409999" title="=&gt; String">replaced</a>
  <span class="delimiter">}</span>

  /**
   * Replaces some of the matches using a replacer function that returns an [[scala.Option]].
   * The replacer function takes a [[scala.util.matching.Regex.Match]] so that extra
   * information can be btained from the match. For example:
   *
   * {{{
   * import scala.util.matching.Regex._
   *
   * val map = Map(&quot;x&quot; -&gt; &quot;a var&quot;, &quot;y&quot; -&gt; &quot;another var&quot;)
   * val text = &quot;A text with variables %x, %y and %z.&quot;
   * val varPattern = &quot;&quot;&quot;%(\w+)&quot;&quot;&quot;.r
   * val mapper = (m: Match) =&gt; map get (m group 1)
   * val repl = varPattern replaceSomeIn (text, mapper)
   * }}}
   *
   * @param target      The string to match.
   * @param replacer    The function which optionally maps a match to another string.
   * @return            The target string after replacements.
   */
  <span class="keyword">def</span> <a title="(target: CharSequence, replacer: scala.util.matching.Regex.Match =&gt; Option[String])String" id="209879">replaceSomeIn</a><span class="delimiter">(</span><a title="CharSequence" id="410057">target</a>: java.lang.<span title="CharSequence">CharSequence</span>, <a title="scala.util.matching.Regex.Match =&gt; Option[String]" id="410058">replacer</a>: Match =&gt; Option<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="replacementData extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement" id="410060">it</a> = <span title="scala.util.matching.Regex.MatchIterator" class="keyword">new</span> <a href="#411201" title="object scala.util.matching.Regex">Regex</a>.<a href="#409674" title="scala.util.matching.Regex.MatchIterator">MatchIterator</a><span class="delimiter">(</span><a href="#410057" title="CharSequence">target</a>, <a href="#19955" title="scala.util.matching.Regex" class="keyword">this</a>, <a href="#209884" title="String*">groupNames</a><span class="delimiter">)</span>.<a href="#409939" title="=&gt; scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">replacementData</a>
    <span class="keyword">for</span> <span class="delimiter">(</span><a title="scala.util.matching.Regex.Match" id="410069">matchdata</a> &lt;- <a href="../../collection/Iterator.scala.html#31060" title="(f: scala.util.matching.Regex.Match =&gt; Unit)Unit">it</a> ; <a title="String" id="410075">replacement</a> &lt;- <a href="../../Function1.scala.html#25386" title="(v1: scala.util.matching.Regex.Match)Option[String]">replacer</a><a href="../../Option.scala.html#29605" title="(f: String =&gt; java.util.regex.Matcher)Unit" class="delimiter">(</a><a href="#410069" title="scala.util.matching.Regex.Match">matchdata</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#410060" title="replacementData extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">it</a> <a href="#410000" title="(rs: String)java.util.regex.Matcher">replace</a> <a href="#410075" title="String">replacement</a>

    <a href="#410060" title="replacementData extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">it</a>.<a href="#409999" title="=&gt; String">replaced</a>
  <span class="delimiter">}</span>

  /** Replaces the first match by a string.
   *
   *  @param target      The string to match
   *  @param replacement The string that will replace the match
   *  @return            The resulting string
   */
  <span class="keyword">def</span> <a title="(target: CharSequence, replacement: String)String" id="209880">replaceFirstIn</a><span class="delimiter">(</span><a title="CharSequence" id="410078">target</a>: java.lang.<span title="CharSequence">CharSequence</span>, <a title="String" id="410079">replacement</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="410081">m</a> = <a href="#209869" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#410078" title="CharSequence">target</a><span class="delimiter">)</span>
    <a href="#410081" title="java.util.regex.Matcher">m</a>.<span title="(x$1: String)String">replaceFirst</span><span class="delimiter">(</span><a href="#410079" title="String">replacement</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Splits the provided character sequence around matches of this regexp.
   *
   *  @param toSplit The character sequence to split
   *  @return        The array of strings computed by splitting the
   *                 input around matches of this regexp
   */
  <span class="keyword">def</span> <a title="(toSplit: CharSequence)Array[String]" id="209881">split</a><span class="delimiter">(</span><a title="CharSequence" id="410082">toSplit</a>: java.lang.<span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../Array.scala.html#1405" title="Array[String]">Array</a><span class="delimiter">[</span>String<span class="delimiter">]</span> =
    <a href="#209869" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)Array[String]">split</span><span class="delimiter">(</span><a href="#410082" title="CharSequence">toSplit</a><span class="delimiter">)</span>

  /** The string defining the regular expression */
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="209882">toString</a> = <a href="#209883" title="String">regex</a>
<span class="delimiter">}</span>

/** This object defines inner classes that describe
 *  regex matches and helper objects. The class hierarchy
 *  is as follows:
 *
 *  {{{
 *            MatchData
 *            /      \
 *   MatchIterator  Match
 *  }}}
 *
 */
<span class="keyword">object</span> <a title="object scala.util.matching.Regex" id="411201">Regex</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>

  /** This class provides methods to access
   *  the details of a match.
   */
  <span class="keyword">trait</span> <a title="trait MatchData extends Object with ScalaObject" id="409668">MatchData</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>

    /** The source from where the match originated */
    <span class="keyword">val</span> <a title="=&gt; CharSequence" id="409870">source</a>: java.lang.<span title="CharSequence">CharSequence</span>

    /** The names of the groups, or some empty sequence if one defined */
    <span class="keyword">val</span> <a title="=&gt; Seq[String]" id="409871">groupNames</a>: <a href="../../collection/Seq.scala.html#6553" title="Seq[String]">Seq</a><span class="delimiter">[</span>String<span class="delimiter">]</span>

    /** The number of subgroups in the pattern (not all of these need to match!) */
    <span class="keyword">def</span> <a title="=&gt; Int" id="409872">groupCount</a>: <a href="../../Int.scala.html#385" title="Int">Int</a>

    /** The index of the first matched character, or -1 if nothing was matched */
    <span class="keyword">def</span> <a title="=&gt; Int" id="409873">start</a>: <a href="../../Int.scala.html#385" title="Int">Int</a>

    /** The index of the first matched character in group `i`,
     *  or -1 if nothing was matched for that group */
    <span class="keyword">def</span> <a title="(i: Int)Int" id="409874">start</a><span class="delimiter">(</span><a title="Int" id="410096">i</a>: <a href="../../Int.scala.html#385" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Int.scala.html#385" title="Int">Int</a>

    /** The index of the last matched character, or -1 if nothing was matched */
    <span class="keyword">def</span> <a title="=&gt; Int" id="409875">end</a>: <a href="../../Int.scala.html#385" title="Int">Int</a>

    /** The index following the last matched character in group `i`,
     *  or -1 if nothing was matched for that group */
    <span class="keyword">def</span> <a title="(i: Int)Int" id="409876">end</a><span class="delimiter">(</span><a title="Int" id="410100">i</a>: <a href="../../Int.scala.html#385" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Int.scala.html#385" title="Int">Int</a>

    /** The matched string, or `null` if nothing was matched */
    <span class="keyword">def</span> <a title="=&gt; String" id="409877">matched</a>: <span title="String">String</span> =
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#409873" title="=&gt; Int">start</a> <a href="../../Int.scala.html#23935" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#409870" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><a href="#409873" title="=&gt; Int">start</a>, <a href="#409875" title="=&gt; Int">end</a><span class="delimiter">)</span>.<span title="()String">toString</span>
      <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>

    /** The matched string in group `i`,
     *  or `null` if nothing was matched */
    <span class="keyword">def</span> <a title="(i: Int)String" id="409878">group</a><span class="delimiter">(</span><a title="Int" id="410121">i</a>: <a href="../../Int.scala.html#385" title="Int">Int</a><span class="delimiter">)</span>: <span title="String">String</span> =
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#409874" title="(i: Int)Int">start</a><span class="delimiter">(</span><a href="#410121" title="Int">i</a><span class="delimiter">)</span> <a href="../../Int.scala.html#23935" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#409870" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><a href="#409874" title="(i: Int)Int">start</a><span class="delimiter">(</span><a href="#410121" title="Int">i</a><span class="delimiter">)</span>, <a href="#409876" title="(i: Int)Int">end</a><span class="delimiter">(</span><a href="#410121" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="()String">toString</span>
      <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>

    /** All matched subgroups, i.e. not including group(0) */
    <span class="keyword">def</span> <a title="=&gt; List[String]" id="409879">subgroups</a>: <a href="../../collection/immutable/List.scala.html#12053" title="List[String]">List</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">(</span><a href="../../LowPriorityImplicits.scala.html#7396" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">1</a> <a href="../../runtime/RichInt.scala.html#23866" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#409872" title="=&gt; Int">groupCount</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#25104" title="=&gt; List[Int]">toList</a> <a href="../../collection/TraversableLike.scala.html#23327" title="(f: Int =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Int],String,List[String]])List[String]">map</a> <a href="#409878" title="(i: Int)String">group</a>

    /** The char sequence before first character of match,
     *  or `null` if nothing was matched */
    <span class="keyword">def</span> <a title="=&gt; CharSequence" id="409880">before</a>: java.lang.<span title="CharSequence">CharSequence</span> =
      <span title="CharSequence" class="keyword">if</span> <span class="delimiter">(</span><a href="#409873" title="=&gt; Int">start</a> <a href="../../Int.scala.html#23935" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#409870" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#409873" title="=&gt; Int">start</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>

    /** The char sequence before first character of match in group `i`,
     *  or `null` if nothing was matched for that group  */
    <span class="keyword">def</span> <a title="(i: Int)CharSequence" id="409881">before</a><span class="delimiter">(</span><a title="Int" id="410294">i</a>: <a href="../../Int.scala.html#385" title="Int">Int</a><span class="delimiter">)</span>: java.lang.<span title="CharSequence">CharSequence</span> =
      <span title="CharSequence" class="keyword">if</span> <span class="delimiter">(</span><a href="#409874" title="(i: Int)Int">start</a><span class="delimiter">(</span><a href="#410294" title="Int">i</a><span class="delimiter">)</span> <a href="../../Int.scala.html#23935" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#409870" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#409874" title="(i: Int)Int">start</a><span class="delimiter">(</span><a href="#410294" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>

    /** Returns char sequence after last character of match,
     *  or `null` if nothing was matched */
    <span class="keyword">def</span> <a title="=&gt; CharSequence" id="409882">after</a>: java.lang.<span title="CharSequence">CharSequence</span> =
      <span title="CharSequence" class="keyword">if</span> <span class="delimiter">(</span><a href="#409875" title="=&gt; Int">end</a> <a href="../../Int.scala.html#23935" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#409870" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><a href="#409875" title="=&gt; Int">end</a>, <a href="#409870" title="=&gt; CharSequence">source</a>.<span title="()Int">length</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>

    /** The char sequence after last character of match in group `i`,
     *  or `null` if nothing was matched for that group  */
    <span class="keyword">def</span> <a title="(i: Int)CharSequence" id="409883">after</a><span class="delimiter">(</span><a title="Int" id="410322">i</a>: <a href="../../Int.scala.html#385" title="Int">Int</a><span class="delimiter">)</span>: java.lang.<span title="CharSequence">CharSequence</span> =
      <span title="CharSequence" class="keyword">if</span> <span class="delimiter">(</span><a href="#409876" title="(i: Int)Int">end</a><span class="delimiter">(</span><a href="#410322" title="Int">i</a><span class="delimiter">)</span> <a href="../../Int.scala.html#23935" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#409870" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><a href="#409876" title="(i: Int)Int">end</a><span class="delimiter">(</span><a href="#410322" title="Int">i</a><span class="delimiter">)</span>, <a href="#409870" title="=&gt; CharSequence">source</a>.<span title="()Int">length</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>

    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Map[String,Int]" id="409885">nameToIndex</a>: <a href="../../collection/immutable/Map.scala.html#11480" title="Map[String,Int]">Map</a><span class="delimiter">[</span>String, Int<span class="delimiter">]</span> = <a href="../../collection/generic/GenMapFactory.scala.html#26699" title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</a><span title="(elems: (String, Int)*)scala.collection.immutable.Map[String,Int]" class="delimiter">[</span><span title="String">String</span>, <a href="../../Int.scala.html#385" title="Int">Int</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span> <a href="../../collection/immutable/MapLike.scala.html#78564" title="(xs: scala.collection.GenTraversableOnce[(String, Int)])scala.collection.immutable.Map[String,Int]">++</a> <span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <a href="../../collection/immutable/List.scala.html#23415" title="(x: String)List[String]">::</a> <a href="#409871" title="=&gt; Seq[String]">groupNames</a>.<a href="../../collection/TraversableOnce.scala.html#25104" title="=&gt; List[String]">toList</a><span class="delimiter">)</span>.<a href="../../collection/IterableLike.scala.html#25345" title="(implicit bf: scala.collection.generic.CanBuildFrom[List[String],(String, Int),List[(String, Int)]])List[(String, Int)]">zipWithIndex</a>

    /** Returns the group with given name
     *
     *  @param id The group name
     *  @return   The requested group
     *  @throws   NoSuchElementException if the requested group name is not defined
     */
    <span class="keyword">def</span> <a title="(id: String)String" id="409886">group</a><span class="delimiter">(</span><a title="String" id="410245">id</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <a href="#409884" title="=&gt; Map[String,Int]">nameToIndex</a>.<a href="../../collection/MapLike.scala.html#44081" title="(key: String)Option[Int]">get</a><span class="delimiter">(</span><a href="#410245" title="String">id</a><span class="delimiter">)</span> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="../../Option.scala.html#1700" title="Nothing">None</a> =&gt; <span title="Nothing" class="keyword">throw</span> <span title="(x$1: String)java.util.NoSuchElementException" class="keyword">new</span> <a href="../../package.scala.html#22874" title="java.util.NoSuchElementException">NoSuchElementException</a><span class="delimiter">(</span><span title="String(&quot;group name &quot;)" class="string">&quot;group name &quot;</span><span title="(x$1: Any)String">+</span><a href="#410245" title="String">id</a><span title="(x$1: Any)String">+</span><span title="String(&quot; not defined&quot;)" class="string">&quot; not defined&quot;</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="String">Some</span><span class="delimiter">(</span><a title="Int" id="410499">index</a><span class="delimiter">)</span> =&gt; <a href="#409878" title="(i: Int)String">group</a><span class="delimiter">(</span><a href="#410499" title="Int">index</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** The matched string; equivalent to `matched.toString` */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="409887">toString</a> = <a href="#409877" title="=&gt; String">matched</a>

  <span class="delimiter">}</span>

  /** Provides information about a succesful match.
   */
  <span class="keyword">class</span> <a title="class Match extends Object with scala.util.matching.Regex.MatchData with ScalaObject" id="409669">Match</a><a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">(</a><span class="keyword">val</span> <a title="CharSequence" id="409960">source</a>: java.lang.<span title="CharSequence">CharSequence</span>,
              <a title="java.util.regex.Matcher" id="409961">matcher</a>: <span title="java.util.regex.Matcher">Matcher</span>,
              <span class="keyword">val</span> <a title="Seq[String]" id="409962">groupNames</a>: <a href="../../collection/Seq.scala.html#6553" title="Seq[String]">Seq</a><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#409668" title="scala.util.matching.Regex.MatchData">MatchData</a> <span class="delimiter">{</span>

    /** The index of the first matched character */
    <span class="keyword">val</span> <a title="Int" id="409897">start</a> = <a href="#409961" title="java.util.regex.Matcher">matcher</a>.<span title="()Int">start</span>

    /** The index following the last matched character */
    <span class="keyword">val</span> <a title="Int" id="409899">end</a> = <a href="#409961" title="java.util.regex.Matcher">matcher</a>.<span title="()Int">end</span>

    /** The number of subgroups */
    <span class="keyword">def</span> <a title="=&gt; Int" id="409901">groupCount</a> = <a href="#409961" title="java.util.regex.Matcher">matcher</a>.<span title="()Int">groupCount</span>

    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Array[Int]" id="409903">starts</a>: <a href="../../Array.scala.html#1405" title="Array[Int]">Array</a><span class="delimiter">[</span>Int<span class="delimiter">]</span> =
      <span class="delimiter">(</span><span class="delimiter">(</span><a href="../../LowPriorityImplicits.scala.html#7396" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">0</a> <a href="../../runtime/RichInt.scala.html#23866" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#409901" title="=&gt; Int">groupCount</a><span class="delimiter">)</span> <a href="../../collection/TraversableLike.scala.html#23327" title="(f: Int =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[Int],Int,scala.collection.immutable.IndexedSeq[Int]])scala.collection.immutable.IndexedSeq[Int]">map</a> <a href="#409961" title="java.util.regex.Matcher">matcher</a>.<a href="#410631" title="(x$1: Int)Int">start</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#25100" title="(implicit evidence$1: ClassManifest[Int])Array[Int]">toArray</a>
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Array[Int]" id="409905">ends</a>: <a href="../../Array.scala.html#1405" title="Array[Int]">Array</a><span class="delimiter">[</span>Int<span class="delimiter">]</span> =
      <span class="delimiter">(</span><span class="delimiter">(</span><a href="../../LowPriorityImplicits.scala.html#7396" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">0</a> <a href="../../runtime/RichInt.scala.html#23866" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#409901" title="=&gt; Int">groupCount</a><span class="delimiter">)</span> <a href="../../collection/TraversableLike.scala.html#23327" title="(f: Int =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[Int],Int,scala.collection.immutable.IndexedSeq[Int]])scala.collection.immutable.IndexedSeq[Int]">map</a> <a href="#409961" title="java.util.regex.Matcher">matcher</a>.<a href="#410777" title="(x$1: Int)Int">end</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#25100" title="(implicit evidence$1: ClassManifest[Int])Array[Int]">toArray</a>

    /** The index of the first matched character in group `i` */
    <span class="keyword">def</span> <a title="(i: Int)Int" id="409906">start</a><span class="delimiter">(</span><a title="Int" id="410822">i</a>: <a href="../../Int.scala.html#385" title="Int">Int</a><span class="delimiter">)</span> = <a href="../../Array.scala.html#23463" title="(i: Int)Int">starts</a><span class="delimiter">(</span><a href="#410822" title="Int">i</a><span class="delimiter">)</span>

    /** The index following the last matched character in group `i` */
    <span class="keyword">def</span> <a title="(i: Int)Int" id="409907">end</a><span class="delimiter">(</span><a title="Int" id="410827">i</a>: <a href="../../Int.scala.html#385" title="Int">Int</a><span class="delimiter">)</span> = <a href="../../Array.scala.html#23463" title="(i: Int)Int">ends</a><span class="delimiter">(</span><a href="#410827" title="Int">i</a><span class="delimiter">)</span>

    /** The match itself with matcher-dependent lazy vals forced,
     *  so that match is valid even once matcher is advanced
     */
    <span class="keyword">def</span> <a title="=&gt; Match.this.type" id="409908">force</a>: <span class="keyword">this</span>.<span class="keyword">type</span> = <span class="delimiter">{</span> <a href="#409902" title="=&gt; Array[Int]">starts</a>; <a href="#409904" title="=&gt; Array[Int]">ends</a>; <a href="#409669" title="Match.this.type" class="keyword">this</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** An extractor object for Matches, yielding the matched string
   *
   *  This can be used to help writing replacer functions when you
   *  are not interested in match data. For example:
   *
   *  {{{
   *  import scala.util.matching.Regex.Match
   *  &quot;&quot;&quot;\w+&quot;&quot;&quot;.r replaceAllIn (&quot;A simple example.&quot;, _ match { case Match(s) =&gt; s.toUpperCase })
   *  }}}
   *
   */
  <span class="keyword">object</span> <a title="object scala.util.matching.Regex.Match" id="409670">Match</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(m: scala.util.matching.Regex.Match)Some[String]" id="409864">unapply</a><span class="delimiter">(</span><a title="scala.util.matching.Regex.Match" id="409865">m</a>: <a href="#409669" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#55" title="Some[String]">Some</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="../../Option.scala.html#29745" title="(x: String)Some[String]">Some</a><span class="delimiter">(</span><a href="#409865" title="scala.util.matching.Regex.Match">m</a>.<a href="#409877" title="=&gt; String">matched</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** An extractor object that yields the groups in the match. Using an extractor
   *  rather than the original regex avoids recomputing the match.
   *
   *  {{{
   *  import scala.util.matching.Regex.Groups
   *
   *  val datePattern = &quot;&quot;&quot;(\d\d\d\d)-(\d\d)-(\d\d)&quot;&quot;&quot;.r
   *  val text = &quot;The doc spree happened on 2011-07-15.&quot;
   *  val day = datePattern replaceAllIn(text, _ match { case Groups(year, month, day) =&gt; month+&quot;/&quot;+day })
   *  }}}
   */
  <span class="keyword">object</span> <a title="object scala.util.matching.Regex.Groups" id="409672">Groups</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(m: scala.util.matching.Regex.Match)Option[Seq[String]]" id="410837">unapplySeq</a><span class="delimiter">(</span><a title="scala.util.matching.Regex.Match" id="410839">m</a>: <a href="#409669" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#556" title="Option[Seq[String]]">Option</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="Option[Seq[String]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#410839" title="scala.util.matching.Regex.Match">m</a>.<a href="#409901" title="=&gt; Int">groupCount</a> <a href="../../Int.scala.html#23928" title="(x: Int)Boolean">&gt;</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="../../Option.scala.html#29745" title="(x: Seq[String])Some[Seq[String]]">Some</a><span class="delimiter">(</span><a href="../../LowPriorityImplicits.scala.html#7396" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">1</a> <a href="../../runtime/RichInt.scala.html#23866" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#410839" title="scala.util.matching.Regex.Match">m</a>.<a href="#409901" title="=&gt; Int">groupCount</a> <a href="../../collection/TraversableLike.scala.html#23327" title="(f: Int =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[Int],String,Seq[String]])Seq[String]">map</a> <a href="#410839" title="scala.util.matching.Regex.Match">m</a>.<a href="#409878" title="(i: Int)String">group</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="../../Option.scala.html#1700" title="object None">None</a>
  <span class="delimiter">}</span>

  /** A class to step through a sequence of regex matches
   */
  <span class="keyword">class</span> <a title="class MatchIterator extends scala.collection.AbstractIterator[String] with Iterator[String] with scala.util.matching.Regex.MatchData with ScalaObject" id="409674">MatchIterator</a><a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">(</a><span class="keyword">val</span> <a title="CharSequence" id="409940">source</a>: java.lang.<span title="CharSequence">CharSequence</span>, <span class="keyword">val</span> <a title="scala.util.matching.Regex" id="409941">regex</a>: <a href="#19955" title="scala.util.matching.Regex">Regex</a>, <span class="keyword">val</span> <a title="Seq[String]" id="409942">groupNames</a>: <a href="../../collection/Seq.scala.html#6553" title="Seq[String]">Seq</a><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="../../collection/Iterator.scala.html#5842" title="scala.collection.AbstractIterator[String]">AbstractIterator</a><span class="delimiter">[</span>String<span class="delimiter">]</span> <span class="keyword">with</span> <a href="../../collection/Iterator.scala.html#6700" title="Iterator[String]">Iterator</a><span class="delimiter">[</span>String<span class="delimiter">]</span> <span class="keyword">with</span> <a href="#409668" title="scala.util.matching.Regex.MatchData">MatchData</a> <span class="delimiter">{</span> self =&gt;

    <span class="keyword">protected</span> <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="409925">matcher</a> = <a href="#409941" title="=&gt; scala.util.matching.Regex">regex</a>.<a href="#209869" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#409940" title="=&gt; CharSequence">source</a><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Boolean" id="409928">nextSeen</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is there another match? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="409930">hasNext</a>: <a href="../../Boolean.scala.html#64" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#24721" title="=&gt; Boolean">!</a><a href="#409928" title="=&gt; Boolean">nextSeen</a><span class="delimiter">)</span> <a href="#409928" title="(x$1: Boolean)Unit">nextSeen</a> = <a href="#409925" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()Boolean">find</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#409928" title="=&gt; Boolean">nextSeen</a>
    <span class="delimiter">}</span>

    /** The next matched substring of `source` */
    <span class="keyword">def</span> <a title="()String" id="409931">next</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#24721" title="=&gt; Boolean">!</a><a href="#409930" title="=&gt; Boolean">hasNext</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <span title="java.util.NoSuchElementException" class="keyword">new</span> <a href="../../package.scala.html#22874" title="java.util.NoSuchElementException">NoSuchElementException</a>
      <a href="#409928" title="(x$1: Boolean)Unit">nextSeen</a> = <span title="Boolean(false)" class="keyword">false</span>
      <a href="#409925" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()String">group</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="409932">toString</a> = <a href="#409674" title="scala.util.matching.Regex.MatchIterator" class="keyword">super</a><span class="delimiter">[</span>AbstractIterator<span class="delimiter">]</span>.<a href="../../collection/Iterator.scala.html#31092" title="()String">toString</a>

    /** The index of the first matched character */
    <span class="keyword">def</span> <a title="=&gt; Int" id="409933">start</a>: <a href="../../Int.scala.html#385" title="Int">Int</a> = <a href="#409925" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()Int">start</span>

    /** The index of the first matched character in group `i` */
    <span class="keyword">def</span> <a title="(i: Int)Int" id="409934">start</a><span class="delimiter">(</span><a title="Int" id="411005">i</a>: <a href="../../Int.scala.html#385" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Int.scala.html#385" title="Int">Int</a> = <a href="#409925" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="(x$1: Int)Int">start</span><span class="delimiter">(</span><a href="#411005" title="Int">i</a><span class="delimiter">)</span>

    /** The index of the last matched character */
    <span class="keyword">def</span> <a title="=&gt; Int" id="409935">end</a>: <a href="../../Int.scala.html#385" title="Int">Int</a> = <a href="#409925" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()Int">end</span>

    /** The index following the last matched character in group `i` */
    <span class="keyword">def</span> <a title="(i: Int)Int" id="409936">end</a><span class="delimiter">(</span><a title="Int" id="411016">i</a>: <a href="../../Int.scala.html#385" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Int.scala.html#385" title="Int">Int</a> = <a href="#409925" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="(x$1: Int)Int">end</span><span class="delimiter">(</span><a href="#411016" title="Int">i</a><span class="delimiter">)</span>

    /** The number of subgroups */
    <span class="keyword">def</span> <a title="=&gt; Int" id="409937">groupCount</a> = <a href="#409925" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()Int">groupCount</span>

    /** Convert to an iterator that yields MatchData elements instead of Strings */
    <span class="keyword">def</span> <a title="=&gt; Iterator[scala.util.matching.Regex.Match]" id="409938">matchData</a>: <a href="../../collection/Iterator.scala.html#6700" title="Iterator[scala.util.matching.Regex.Match]">Iterator</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> = <a href="#411026" title="scala.collection.AbstractIterator[scala.util.matching.Regex.Match]" class="keyword">new</a> <a title="anonymous class $anon extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match]" id="411026">AbstractIterator</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="411028">hasNext</a> = <a href="#409674" title="MatchIterator.this.type">self</a>.<a href="#409930" title="=&gt; Boolean">hasNext</a>
      <span class="keyword">def</span> <a title="()scala.util.matching.Regex.Match" id="411029">next</a> = <span class="delimiter">{</span> <a href="#409674" title="MatchIterator.this.type">self</a>.<a href="#409931" title="()String">next</a>; <span title="scala.util.matching.Regex.Match" class="keyword">new</span> <a href="#409669" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">(</span><a href="#409940" title="=&gt; CharSequence">source</a>, <a href="#409925" title="=&gt; java.util.regex.Matcher">matcher</a>, <a href="#409942" title="=&gt; Seq[String]">groupNames</a><span class="delimiter">)</span>.<a href="#409908" title="=&gt; scala.util.matching.Regex.Match">force</a> <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** Convert to an iterator that yields MatchData elements instead of Strings and has replacement support */
    <span class="keyword">private</span><span class="delimiter">[</span>matching<span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement" id="409939">replacementData</a> = <a href="#409989" title="scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement" class="keyword">new</a> <a title="anonymous class $anon extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement" id="409989">AbstractIterator</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> <span class="keyword">with</span> <a href="#409675" title="scala.util.matching.Regex.Replacement">Replacement</a> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="=&gt; java.util.regex.Matcher" id="409991">matcher</a> = <a href="#409674" title="MatchIterator.this.type">self</a>.<a href="#409925" title="=&gt; java.util.regex.Matcher">matcher</a>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="409992">hasNext</a> = <a href="#409674" title="MatchIterator.this.type">self</a>.<a href="#409930" title="=&gt; Boolean">hasNext</a>
      <span class="keyword">def</span> <a title="()scala.util.matching.Regex.Match" id="409993">next</a> = <span class="delimiter">{</span> <a href="#409674" title="MatchIterator.this.type">self</a>.<a href="#409931" title="()String">next</a>; <span title="scala.util.matching.Regex.Match" class="keyword">new</span> <a href="#409669" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">(</span><a href="#409940" title="=&gt; CharSequence">source</a>, <a href="#409991" title="=&gt; java.util.regex.Matcher">matcher</a>, <a href="#409942" title="=&gt; Seq[String]">groupNames</a><span class="delimiter">)</span>.<a href="#409908" title="=&gt; scala.util.matching.Regex.Match">force</a> <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /**
   * A trait able to build a string with replacements assuming it has a matcher.
   * Meant to be mixed in with iterators.
   */
  <span class="keyword">private</span><span class="delimiter">[</span>matching<span class="delimiter">]</span> <span class="keyword">trait</span> <a title="trait Replacement extends Object with ScalaObject" id="409675">Replacement</a> <a href="../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; java.util.regex.Matcher" id="409995">matcher</a>: <span title="java.util.regex.Matcher">Matcher</span>

    <span class="keyword">private</span> <span class="keyword">var</span> <a title="StringBuffer" id="409997">sb</a> = <span title="StringBuffer" class="keyword">new</span> java.lang.<span title="StringBuffer">StringBuffer</span>

    <span class="keyword">def</span> <a title="=&gt; String" id="409999">replaced</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="StringBuffer" id="410052">newsb</a> = <span title="(x$1: CharSequence)StringBuffer" class="keyword">new</span> java.lang.<span title="StringBuffer">StringBuffer</span><span class="delimiter">(</span><a href="#409997" title="=&gt; StringBuffer">sb</a><span class="delimiter">)</span>
      <a href="#409995" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="(x$1: StringBuffer)StringBuffer">appendTail</span><span class="delimiter">(</span><a href="#410052" title="StringBuffer">newsb</a><span class="delimiter">)</span>
      <a href="#410052" title="StringBuffer">newsb</a>.<span title="()String">toString</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(rs: String)java.util.regex.Matcher" id="410000">replace</a><span class="delimiter">(</span><a title="String" id="410041">rs</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#409995" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="(x$1: StringBuffer, x$2: String)java.util.regex.Matcher">appendReplacement</span><span class="delimiter">(</span><a href="#409997" title="=&gt; StringBuffer">sb</a>, <a href="#410041" title="String">rs</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>