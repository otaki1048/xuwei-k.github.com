<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/actors/threadpool/locks/ReentrantReadWriteLock.java</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/licenses/publicdomain
 */</span>

<span class="keyword">package</span> scala.actors.threadpool.locks;

<span class="keyword">import</span> java.util.HashMap;
<span class="keyword">import</span> scala.actors.threadpool.*;
<span class="keyword">import</span> scala.actors.threadpool.helpers.*;

<span class="comment">/**
 * An implementation of {@link ReadWriteLock} supporting similar
 * semantics to {@link ReentrantLock}.
 * &lt;p&gt;This class has the following properties:
 *
 * &lt;ul&gt;
 * &lt;li&gt;&lt;b&gt;Acquisition order&lt;/b&gt;
 *
 * &lt;p&gt;The order of entry
 * to the read and write lock is unspecified, subject to reentrancy
 * constraints.  A nonfair lock that is continously contended may
 * indefinitely postpone one or more reader or writer threads, but
 * will normally have higher throughput than a fair lock.
 * &lt;p&gt;
 *
 * DEPARTURE FROM java.util.concurrent: this implementation impose
 * a writer-preferrence and thus its acquisition order may be different
 * than in java.util.concurrent.
 *
 * &lt;li&gt;&lt;b&gt;Reentrancy&lt;/b&gt;
 *
 * &lt;p&gt;This lock allows both readers and writers to reacquire read or
 * write locks in the style of a {@link ReentrantLock}. Non-reentrant
 * readers are not allowed until all write locks held by the writing
 * thread have been released.
 *
 * &lt;p&gt;Additionally, a writer can acquire the read lock, but not
 * vice-versa.  Among other applications, reentrancy can be useful
 * when write locks are held during calls or callbacks to methods that
 * perform reads under read locks.  If a reader tries to acquire the
 * write lock it will never succeed.
 *
 * &lt;li&gt;&lt;b&gt;Lock downgrading&lt;/b&gt;
 * &lt;p&gt;Reentrancy also allows downgrading from the write lock to a read lock,
 * by acquiring the write lock, then the read lock and then releasing the
 * write lock. However, upgrading from a read lock to the write lock is
 * &lt;b&gt;not&lt;/b&gt; possible.
 *
 * &lt;li&gt;&lt;b&gt;Interruption of lock acquisition&lt;/b&gt;
 * &lt;p&gt;The read lock and write lock both support interruption during lock
 * acquisition.
 *
 * &lt;li&gt;&lt;b&gt;{@link Condition} support&lt;/b&gt;
 * &lt;p&gt;The write lock provides a {@link Condition} implementation that
 * behaves in the same way, with respect to the write lock, as the
 * {@link Condition} implementation provided by
 * {@link ReentrantLock#newCondition} does for {@link ReentrantLock}.
 * This {@link Condition} can, of course, only be used with the write lock.
 *
 * &lt;p&gt;The read lock does not support a {@link Condition} and
 * {@code readLock().newCondition()} throws
 * {@code UnsupportedOperationException}.
 *
 * &lt;li&gt;&lt;b&gt;Instrumentation&lt;/b&gt;
 * &lt;p&gt;This class supports methods to determine whether locks
 * are held or contended. These methods are designed for monitoring
 * system state, not for synchronization control.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Serialization of this class behaves in the same way as built-in
 * locks: a deserialized lock is in the unlocked state, regardless of
 * its state when serialized.
 *
 * &lt;p&gt;&lt;b&gt;Sample usages&lt;/b&gt;. Here is a code sketch showing how to exploit
 * reentrancy to perform lock downgrading after updating a cache (exception
 * handling is elided for simplicity):
 * &lt;pre&gt;
 * class CachedData {
 *   Object data;
 *   volatile boolean cacheValid;
 *   ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
 *
 *   void processCachedData() {
 *     rwl.readLock().lock();
 *     if (!cacheValid) {
 *        // Must release read lock before acquiring write lock
 *        rwl.readLock().unlock();
 *        rwl.writeLock().lock();
 *        // Recheck state because another thread might have acquired
 *        //   write lock and changed state before we did.
 *        if (!cacheValid) {
 *          data = ...
 *          cacheValid = true;
 *        }
 *        // Downgrade by acquiring read lock before releasing write lock
 *        rwl.readLock().lock();
 *        rwl.writeLock().unlock(); // Unlock write, still hold read
 *     }
 *
 *     use(data);
 *     rwl.readLock().unlock();
 *   }
 * }
 * &lt;/pre&gt;
 *
 * ReentrantReadWriteLocks can be used to improve concurrency in some
 * uses of some kinds of Collections. This is typically worthwhile
 * only when the collections are expected to be large, accessed by
 * more reader threads than writer threads, and entail operations with
 * overhead that outweighs synchronization overhead. For example, here
 * is a class using a TreeMap that is expected to be large and
 * concurrently accessed.
 *
 * &lt;pre&gt;{@code
 * class RWDictionary {
 *    private final Map&lt;String, Data&gt; m = new TreeMap&lt;String, Data&gt;();
 *    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
 *    private final Lock r = rwl.readLock();
 *    private final Lock w = rwl.writeLock();
 *
 *    public Data get(String key) {
 *        r.lock();
 *        try { return m.get(key); }
 *        finally { r.unlock(); }
 *    }
 *    public String[] allKeys() {
 *        r.lock();
 *        try { return m.keySet().toArray(); }
 *        finally { r.unlock(); }
 *    }
 *    public Data put(String key, Data value) {
 *        w.lock();
 *        try { return m.put(key, value); }
 *        finally { w.unlock(); }
 *    }
 *    public void clear() {
 *        w.lock();
 *        try { m.clear(); }
 *        finally { w.unlock(); }
 *    }
 * }}&lt;/pre&gt;
 *
 * &lt;h3&gt;Implementation Notes&lt;/h3&gt;
 *
 * &lt;p&gt;This lock supports a maximum of 65535 recursive write locks
 * and 65535 read locks. Attempts to exceed these limits result in
 * {@link Error} throws from locking methods.
 *
 * @since 1.5
 * @author Doug Lea
 *
 */</span>
public <span class="keyword">class</span> <a title="object scala.actors.threadpool.locks.ReentrantReadWriteLock" id="12033">ReentrantReadWriteLock</a> implements ReadWriteLock, java.io.Serializable  <span class="delimiter">{</span>
    <span class="keyword">private</span> static <span class="keyword">final</span> long <a title="Long" id="2790183">serialVersionUID</a> = -<span class="long">3463448656717690166L</span>;

    <span class="keyword">final</span> ReadLock readerLock_ = <span class="keyword">new</span> ReadLock<span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>;
    <span class="keyword">final</span> WriteLock writerLock_ = <span class="keyword">new</span> WriteLock<span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>;

    <span class="keyword">final</span> Sync sync;

    <span class="comment">/**
     * Creates a new {@code ReentrantReadWriteLock} with
     * default (nonfair) ordering properties.
     */</span>
    public ReentrantReadWriteLock<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">this</span>.sync = <span class="keyword">new</span> NonfairSync<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    public Lock writeLock<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">return</span> writerLock_; <span class="delimiter">}</span>
    public Lock readLock<span class="delimiter">(</span><span class="delimiter">)</span>  <span class="delimiter">{</span> <span class="keyword">return</span> readerLock_; <span class="delimiter">}</span>

    <span class="comment">/**
     * Synchronization implementation for ReentrantReadWriteLock.
     * Subclassed into fair and nonfair versions.
     */</span>
    <span class="keyword">private</span> <span class="keyword">abstract</span> static <span class="keyword">class</span> <a title="object scala.actors.threadpool.locks.ReentrantReadWriteLock.Sync" id="2790186">Sync</a> implements java.io.Serializable <span class="delimiter">{</span>

        <span class="keyword">private</span> static <span class="keyword">final</span> int <a title="Int" id="2790197">NONE</a>   = <span class="int">0</span>;
        <span class="keyword">private</span> static <span class="keyword">final</span> int <a title="Int" id="2790198">READER</a> = <span class="int">1</span>;
        <span class="keyword">private</span> static <span class="keyword">final</span> int <a title="Int" id="2790199">WRITER</a> = <span class="int">2</span>;

        transient int <span title="">activeReaders_</span> = <span class="int">0</span>;
        transient Thread <span title="">activeWriter_</span> = <span class="keyword">null</span>;
        transient int <span title="">waitingReaders_</span> = <span class="int">0</span>;
        transient int <span title="">waitingWriters_</span> = <span class="int">0</span>;

        <span class="comment">/** Number of acquires on write lock by activeWriter_ thread **/</span>
        transient int <span title="">writeHolds_</span> = <span class="int">0</span>;

        <span class="comment">/** Number of acquires on read lock by any reader thread **/</span>
        transient HashMap&lt;Thread, Integer&gt; <span title="">readers_</span> = <span class="keyword">new</span> HashMap&lt;Thread, Integer&gt;<span class="delimiter">(</span><span class="delimiter">)</span>;

        <span class="comment">/** cache/reuse the special Integer value one to speed up readlocks **/</span>
        static <span class="keyword">final</span> Integer <a title="java.lang.Integer" id="2790200">IONE</a> = <span class="keyword">new</span> Integer<span class="delimiter">(</span><span class="int">1</span><span class="delimiter">)</span>;

        Sync<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span><span class="delimiter">}</span>

        <span class="comment">/*
           Each of these variants is needed to maintain atomicity
           of wait counts during wait loops. They could be
           made faster by manually inlining each other. We hope that
           compilers do this for us though.
        */</span>

        synchronized boolean startReadFromNewReader<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            boolean pass = startRead<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>!pass<span class="delimiter">)</span> ++waitingReaders_;
            <span class="keyword">return</span> pass;
        <span class="delimiter">}</span>

        synchronized boolean startWriteFromNewWriter<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            boolean pass = startWrite<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>!pass<span class="delimiter">)</span> ++waitingWriters_;
            <span class="keyword">return</span> pass;
        <span class="delimiter">}</span>

        synchronized boolean startReadFromWaitingReader<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            boolean pass = startRead<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>pass<span class="delimiter">)</span> --waitingReaders_;
            <span class="keyword">return</span> pass;
        <span class="delimiter">}</span>

        synchronized boolean startWriteFromWaitingWriter<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            boolean pass = startWrite<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>pass<span class="delimiter">)</span> --waitingWriters_;
            <span class="keyword">return</span> pass;
        <span class="delimiter">}</span>

        <span class="comment">/*
           A bunch of small synchronized methods are needed
           to allow communication from the Lock objects
           back to this object, that serves as controller
         */</span>

        synchronized void cancelledWaitingReader<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span> --waitingReaders_; <span class="delimiter">}</span>
        synchronized void cancelledWaitingWriter<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span> --waitingWriters_; <span class="delimiter">}</span>

        boolean allowReader<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> <span class="delimiter">(</span>activeWriter_ == <span class="keyword">null</span> &amp;&amp; waitingWriters_ == <span class="int">0</span><span class="delimiter">)</span> ||
                activeWriter_ == Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        synchronized boolean startRead<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            Thread t = Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span>;
            Object c = readers_.get<span class="delimiter">(</span>t<span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>c != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// already held -- just increment hold count</span>
                readers_.put<span class="delimiter">(</span>t, <span class="keyword">new</span> Integer<span class="delimiter">(</span> <span class="delimiter">(</span> <span class="delimiter">(</span>Integer<span class="delimiter">)</span> <span class="delimiter">(</span>c<span class="delimiter">)</span><span class="delimiter">)</span>.intValue<span class="delimiter">(</span><span class="delimiter">)</span> + <span class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>;
                ++activeReaders_;
                <span class="keyword">return</span> <span class="keyword">true</span>;
            <span class="delimiter">}</span>
            <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>allowReader<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                readers_.put<span class="delimiter">(</span>t, IONE<span class="delimiter">)</span>;
                ++activeReaders_;
                <span class="keyword">return</span> <span class="keyword">true</span>;
            <span class="delimiter">}</span>
            <span class="keyword">else</span>
                <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="delimiter">}</span>

        synchronized boolean startWrite<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>activeWriter_ == Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// already held; re-acquire</span>
                ++writeHolds_;
                <span class="keyword">return</span> <span class="keyword">true</span>;
            <span class="delimiter">}</span>
            <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>writeHolds_ == <span class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>activeReaders_ == <span class="int">0</span> ||
                    <span class="delimiter">(</span>readers_.size<span class="delimiter">(</span><span class="delimiter">)</span> == <span class="int">1</span> &amp;&amp;
                     readers_.get<span class="delimiter">(</span>Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> != <span class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    activeWriter_ = Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span>;
                    writeHolds_ = <span class="int">1</span>;
                    <span class="keyword">return</span> <span class="keyword">true</span>;
                <span class="delimiter">}</span>
                <span class="keyword">else</span>
                    <span class="keyword">return</span> <span class="keyword">false</span>;
            <span class="delimiter">}</span>
            <span class="keyword">else</span>
                <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="delimiter">}</span>

        synchronized int endRead<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            Thread t = Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span>;
            Object c = readers_.get<span class="delimiter">(</span>t<span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>c == <span class="keyword">null</span><span class="delimiter">)</span>
                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException<span class="delimiter">(</span><span class="delimiter">)</span>;
            --activeReaders_;
            <span class="keyword">if</span> <span class="delimiter">(</span>c != IONE<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// more than one hold; decrement count</span>
                int h = <span class="delimiter">(</span> <span class="delimiter">(</span>Integer<span class="delimiter">)</span> <span class="delimiter">(</span>c<span class="delimiter">)</span><span class="delimiter">)</span>.intValue<span class="delimiter">(</span><span class="delimiter">)</span> - <span class="int">1</span>;
                Integer ih = <span class="delimiter">(</span>h == <span class="int">1</span><span class="delimiter">)</span> ? IONE : <span class="keyword">new</span> Integer<span class="delimiter">(</span>h<span class="delimiter">)</span>;
                readers_.put<span class="delimiter">(</span>t, ih<span class="delimiter">)</span>;
                <span class="keyword">return</span> NONE;
            <span class="delimiter">}</span>
            <span class="keyword">else</span> <span class="delimiter">{</span>
                readers_.remove<span class="delimiter">(</span>t<span class="delimiter">)</span>;

                <span class="keyword">if</span> <span class="delimiter">(</span>writeHolds_ &gt; <span class="int">0</span><span class="delimiter">)</span> <span class="comment">// a write lock is still held by current thread</span>
                    <span class="keyword">return</span> NONE;
                <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>activeReaders_ == <span class="int">0</span> &amp;&amp; waitingWriters_ &gt; <span class="int">0</span><span class="delimiter">)</span>
                    <span class="keyword">return</span> WRITER;
                <span class="keyword">else</span>
                    <span class="keyword">return</span> NONE;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        synchronized int endWrite<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>activeWriter_ != Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
            --writeHolds_;
            <span class="keyword">if</span> <span class="delimiter">(</span>writeHolds_ &gt; <span class="int">0</span><span class="delimiter">)</span> <span class="comment">// still being held</span>
                <span class="keyword">return</span> NONE;
            <span class="keyword">else</span> <span class="delimiter">{</span>
                activeWriter_ = <span class="keyword">null</span>;
                <span class="keyword">if</span> <span class="delimiter">(</span>waitingReaders_ &gt; <span class="int">0</span> &amp;&amp; allowReader<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="keyword">return</span> READER;
                <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>waitingWriters_ &gt; <span class="int">0</span><span class="delimiter">)</span>
                    <span class="keyword">return</span> WRITER;
                <span class="keyword">else</span>
                    <span class="keyword">return</span> NONE;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        synchronized Thread getOwner<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> activeWriter_;
        <span class="delimiter">}</span>

        synchronized int getReadLockCount<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> activeReaders_;
        <span class="delimiter">}</span>

        synchronized boolean isWriteLocked<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> activeWriter_ != <span class="keyword">null</span>;
        <span class="delimiter">}</span>

        synchronized boolean isWriteLockedByCurrentThread<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> activeWriter_ == Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        synchronized int getWriteHoldCount<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> isWriteLockedByCurrentThread<span class="delimiter">(</span><span class="delimiter">)</span> ? writeHolds_ : <span class="int">0</span>;
        <span class="delimiter">}</span>

        synchronized int getReadHoldCount<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>activeReaders_ == <span class="int">0</span><span class="delimiter">)</span> <span class="keyword">return</span> <span class="int">0</span>;
            Thread t = Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span>;
            Integer i = readers_.get<span class="delimiter">(</span>t<span class="delimiter">)</span>;
            <span class="keyword">return</span> <span class="delimiter">(</span>i == <span class="keyword">null</span><span class="delimiter">)</span> ? <span class="int">0</span> : i.intValue<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        <span class="keyword">final</span> synchronized boolean hasQueuedThreads<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> waitingWriters_ &gt; <span class="int">0</span> || waitingReaders_ &gt; <span class="int">0</span>;
        <span class="delimiter">}</span>

        <span class="keyword">final</span> synchronized int getQueueLength<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> waitingWriters_ + waitingReaders_;
        <span class="delimiter">}</span>

        <span class="keyword">private</span> void readObject<span class="delimiter">(</span>java.io.ObjectInputStream in<span class="delimiter">)</span>
                throws java.io.IOException, ClassNotFoundException <span class="delimiter">{</span>
            in.defaultReadObject<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="comment">// readers_ is transient, need to reinitialize. Let's flush the memory</span>
            <span class="comment">// and ensure visibility by synchronizing (all other accesses to</span>
            <span class="comment">// readers_ are also synchronized on &quot;this&quot;)</span>
            synchronized <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                readers_ = <span class="keyword">new</span> HashMap&lt;Thread, Integer&gt;<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Nonfair version of Sync
     */</span>
    <span class="keyword">private</span> static <span class="keyword">class</span> <a title="object scala.actors.threadpool.locks.ReentrantReadWriteLock.NonfairSync" id="2790189">NonfairSync</a> <span class="keyword">extends</span> Sync <span class="delimiter">{</span>
        <span class="keyword">private</span> static <span class="keyword">final</span> long <a title="Long" id="2790202">serialVersionUID</a> = -<span class="long">2392241841540339773L</span>;

        NonfairSync<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span><span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * The lock returned by method {@link ReentrantReadWriteLock#readLock}.
     */</span>
    public static <span class="keyword">class</span> <a title="object scala.actors.threadpool.locks.ReentrantReadWriteLock.ReadLock" id="2790192">ReadLock</a> implements Lock, java.io.Serializable <span class="delimiter">{</span>

        <span class="keyword">private</span> static <span class="keyword">final</span> long <a title="Long" id="2790204">serialVersionUID</a> = -<span class="long">5992448646407690164L</span>;

        <span class="keyword">final</span> ReentrantReadWriteLock lock;

        <span class="comment">/**
         * Constructor for use by subclasses
         *
         * @param lock the outer lock object
         * @throws NullPointerException if the lock is null
         */</span>
        <span class="keyword">protected</span> ReadLock<span class="delimiter">(</span>ReentrantReadWriteLock lock<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>lock == <span class="keyword">null</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">this</span>.lock = lock;
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Acquires the read lock.
         *
         * &lt;p&gt;Acquires the read lock if the write lock is not held by
         * another thread and returns immediately.
         *
         * &lt;p&gt;If the write lock is held by another thread then
         * the current thread becomes disabled for thread scheduling
         * purposes and lies dormant until the read lock has been acquired.
         */</span>
        public void lock<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            synchronized <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>lock.sync.startReadFromNewReader<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">return</span>;
                boolean wasInterrupted = Thread.interrupted<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">try</span> <span class="delimiter">{</span>
                    <span class="keyword">while</span> <span class="delimiter">(</span><span class="keyword">true</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                        <span class="keyword">try</span> <span class="delimiter">{</span>
                            ReadLock.<span class="keyword">this</span>.wait<span class="delimiter">(</span><span class="delimiter">)</span>;
                        <span class="delimiter">}</span>
                        <span class="keyword">catch</span> <span class="delimiter">(</span>InterruptedException ex<span class="delimiter">)</span> <span class="delimiter">{</span>
                            wasInterrupted = <span class="keyword">true</span>;
                            <span class="comment">// no need to propagate the potentially masked</span>
                            <span class="comment">// signal, since readers are always notified all</span>
                        <span class="delimiter">}</span>
                        <span class="keyword">if</span> <span class="delimiter">(</span>lock.sync.startReadFromWaitingReader<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">return</span>;
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span>
                <span class="keyword">finally</span> <span class="delimiter">{</span>
                    <span class="keyword">if</span> <span class="delimiter">(</span>wasInterrupted<span class="delimiter">)</span> Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span>.interrupt<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Acquires the read lock unless the current thread is
         * {@linkplain Thread#interrupt interrupted}.
         *
         * &lt;p&gt;Acquires the read lock if the write lock is not held
         * by another thread and returns immediately.
         *
         * &lt;p&gt;If the write lock is held by another thread then the
         * current thread becomes disabled for thread scheduling
         * purposes and lies dormant until one of two things happens:
         *
         * &lt;ul&gt;
         *
         * &lt;li&gt;The read lock is acquired by the current thread; or
         *
         * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}
         * the current thread.
         *
         * &lt;/ul&gt;
         *
         * &lt;p&gt;If the current thread:
         *
         * &lt;ul&gt;
         *
         * &lt;li&gt;has its interrupted status set on entry to this method; or
         *
         * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while
         * acquiring the read lock,
         *
         * &lt;/ul&gt;
         *
         * then {@link InterruptedException} is thrown and the current
         * thread's interrupted status is cleared.
         *
         * &lt;p&gt;In this implementation, as this method is an explicit
         * interruption point, preference is given to responding to
         * the interrupt over normal or reentrant acquisition of the
         * lock.
         *
         * @throws InterruptedException if the current thread is interrupted
         */</span>
        public void lockInterruptibly<span class="delimiter">(</span><span class="delimiter">)</span> throws InterruptedException <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>Thread.interrupted<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException<span class="delimiter">(</span><span class="delimiter">)</span>;
            InterruptedException ie = <span class="keyword">null</span>;
            synchronized <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>!lock.sync.startReadFromNewReader<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">for</span> <span class="delimiter">(</span>; ; <span class="delimiter">)</span> <span class="delimiter">{</span>
                        <span class="keyword">try</span> <span class="delimiter">{</span>
                            ReadLock.<span class="keyword">this</span>.wait<span class="delimiter">(</span><span class="delimiter">)</span>;
                            <span class="keyword">if</span> <span class="delimiter">(</span>lock.sync.startReadFromWaitingReader<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
                                <span class="keyword">return</span>;
                        <span class="delimiter">}</span>
                        <span class="keyword">catch</span> <span class="delimiter">(</span>InterruptedException ex<span class="delimiter">)</span> <span class="delimiter">{</span>
                            lock.sync.cancelledWaitingReader<span class="delimiter">(</span><span class="delimiter">)</span>;
                            ie = ex;
                            break;
                        <span class="delimiter">}</span>
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>ie != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="comment">// fall through outside synch on interrupt.</span>
                <span class="comment">// This notification is not really needed here,</span>
                <span class="comment">//   but may be in plausible subclasses</span>
                lock.writerLock_.signalWaiters<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">throw</span> ie;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Acquires the read lock only if the write lock is not held by
         * another thread at the time of invocation.
         *
         * &lt;p&gt;Acquires the read lock if the write lock is not held by
         * another thread and returns immediately with the value
         * {@code true}. Even when this lock has been set to use a
         * fair ordering policy, a call to {@code tryLock()}
         * &lt;em&gt;will&lt;/em&gt; immediately acquire the read lock if it is
         * available, whether or not other threads are currently
         * waiting for the read lock.  This &amp;quot;barging&amp;quot; behavior
         * can be useful in certain circumstances, even though it
         * breaks fairness. If you want to honor the fairness setting
         * for this lock, then use {@link #tryLock(long, TimeUnit)
         * tryLock(0, TimeUnit.SECONDS) } which is almost equivalent
         * (it also detects interruption).
         *
         * &lt;p&gt;If the write lock is held by another thread then
         * this method will return immediately with the value
         * {@code false}.
         *
         * @return {@code true} if the read lock was acquired
         */</span>
        public boolean tryLock<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> lock.sync.startRead<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Acquires the read lock if the write lock is not held by
         * another thread within the given waiting time and the
         * current thread has not been {@linkplain Thread#interrupt
         * interrupted}.
         *
         * &lt;p&gt;Acquires the read lock if the write lock is not held by
         * another thread and returns immediately with the value
         * {@code true}. If this lock has been set to use a fair
         * ordering policy then an available lock &lt;em&gt;will not&lt;/em&gt; be
         * acquired if any other threads are waiting for the
         * lock. This is in contrast to the {@link #tryLock()}
         * method. If you want a timed {@code tryLock} that does
         * permit barging on a fair lock then combine the timed and
         * un-timed forms together:
         *
         * &lt;pre&gt;if (lock.tryLock() || lock.tryLock(timeout, unit) ) { ... }
         * &lt;/pre&gt;
         *
         * &lt;p&gt;If the write lock is held by another thread then the
         * current thread becomes disabled for thread scheduling
         * purposes and lies dormant until one of three things happens:
         *
         * &lt;ul&gt;
         *
         * &lt;li&gt;The read lock is acquired by the current thread; or
         *
         * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}
         * the current thread; or
         *
         * &lt;li&gt;The specified waiting time elapses.
         *
         * &lt;/ul&gt;
         *
         * &lt;p&gt;If the read lock is acquired then the value {@code true} is
         * returned.
         *
         * &lt;p&gt;If the current thread:
         *
         * &lt;ul&gt;
         *
         * &lt;li&gt;has its interrupted status set on entry to this method; or
         *
         * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while
         * acquiring the read lock,
         *
         * &lt;/ul&gt; then {@link InterruptedException} is thrown and the
         * current thread's interrupted status is cleared.
         *
         * &lt;p&gt;If the specified waiting time elapses then the value
         * {@code false} is returned.  If the time is less than or
         * equal to zero, the method will not wait at all.
         *
         * &lt;p&gt;In this implementation, as this method is an explicit
         * interruption point, preference is given to responding to
         * the interrupt over normal or reentrant acquisition of the
         * lock, and over reporting the elapse of the waiting time.
         *
         * @param timeout the time to wait for the read lock
         * @param unit the time unit of the timeout argument
         * @return {@code true} if the read lock was acquired
         * @throws InterruptedException if the current thread is interrupted
         * @throws NullPointerException if the time unit is null
         *
         */</span>
        public boolean tryLock<span class="delimiter">(</span>long timeout, TimeUnit unit<span class="delimiter">)</span> throws InterruptedException <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>Thread.interrupted<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException<span class="delimiter">(</span><span class="delimiter">)</span>;
            InterruptedException ie = <span class="keyword">null</span>;
            long nanos = unit.toNanos<span class="delimiter">(</span>timeout<span class="delimiter">)</span>;
            synchronized <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>nanos &lt;= <span class="int">0</span><span class="delimiter">)</span>
                    <span class="keyword">return</span> lock.sync.startRead<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>lock.sync.startReadFromNewReader<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="keyword">return</span> <span class="keyword">true</span>;
                <span class="keyword">else</span> <span class="delimiter">{</span>
                    long deadline = Utils.nanoTime<span class="delimiter">(</span><span class="delimiter">)</span> + nanos;
                    <span class="keyword">for</span> <span class="delimiter">(</span>; ; <span class="delimiter">)</span> <span class="delimiter">{</span>
                        <span class="keyword">try</span> <span class="delimiter">{</span>
                            TimeUnit.NANOSECONDS.timedWait<span class="delimiter">(</span>ReadLock.<span class="keyword">this</span>, nanos<span class="delimiter">)</span>;
                        <span class="delimiter">}</span>
                        <span class="keyword">catch</span> <span class="delimiter">(</span>InterruptedException ex<span class="delimiter">)</span> <span class="delimiter">{</span>
                            lock.sync.cancelledWaitingReader<span class="delimiter">(</span><span class="delimiter">)</span>;
                            ie = ex;
                            break;
                        <span class="delimiter">}</span>
                        <span class="keyword">if</span> <span class="delimiter">(</span>lock.sync.startReadFromWaitingReader<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
                            <span class="keyword">return</span> <span class="keyword">true</span>;
                        <span class="keyword">else</span> <span class="delimiter">{</span>
                            nanos = deadline - Utils.nanoTime<span class="delimiter">(</span><span class="delimiter">)</span>;
                            <span class="keyword">if</span> <span class="delimiter">(</span>nanos &lt;= <span class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                                lock.sync.cancelledWaitingReader<span class="delimiter">(</span><span class="delimiter">)</span>;
                                break;
                            <span class="delimiter">}</span>
                        <span class="delimiter">}</span>
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="comment">// safeguard on interrupt or timeout:</span>
            lock.writerLock_.signalWaiters<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>ie != <span class="keyword">null</span><span class="delimiter">)</span>
                <span class="keyword">throw</span> ie;
            <span class="keyword">else</span>
                <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// timed out</span>
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Attempts to release this lock.
         *
         * &lt;p&gt; If the number of readers is now zero then the lock
         * is made available for write lock attempts.
         */</span>
        public void unlock<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            switch <span class="delimiter">(</span>lock.sync.endRead<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> Sync.NONE: <span class="keyword">return</span>;
                <span class="keyword">case</span> Sync.READER: lock.readerLock_.signalWaiters<span class="delimiter">(</span><span class="delimiter">)</span>; <span class="keyword">return</span>;
                <span class="keyword">case</span> Sync.WRITER: lock.writerLock_.signalWaiters<span class="delimiter">(</span><span class="delimiter">)</span>; <span class="keyword">return</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Throws {@code UnsupportedOperationException} because
         * {@code ReadLocks} do not support conditions.
         *
         * @throws UnsupportedOperationException always
         */</span>
        public Condition newCondition<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        synchronized void signalWaiters<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            notifyAll<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Returns a string identifying this lock, as well as its lock state.
         * The state, in brackets, includes the String {@code &quot;Read locks =&quot;}
         * followed by the number of held read locks.
         *
         * @return a string identifying this lock, as well as its lock state
         */</span>
        public String toString<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            int r = lock.getReadLockCount<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">return</span> <span class="keyword">super</span>.toString<span class="delimiter">(</span><span class="delimiter">)</span> +
                <span class="string">&quot;[Read locks = &quot;</span> + r + <span class="string">&quot;]&quot;</span>;
        <span class="delimiter">}</span>

    <span class="delimiter">}</span>

    <span class="comment">/**
     * The lock returned by method {@link ReentrantReadWriteLock#writeLock}.
     */</span>
    public static <span class="keyword">class</span> <a title="object scala.actors.threadpool.locks.ReentrantReadWriteLock.WriteLock" id="2790195">WriteLock</a> implements Lock, CondVar.ExclusiveLock,
                                             java.io.Serializable <span class="delimiter">{</span>

        <span class="keyword">private</span> static <span class="keyword">final</span> long <a title="Long" id="2790206">serialVersionUID</a> = -<span class="long">4992448646407690164L</span>;
        <span class="keyword">final</span> ReentrantReadWriteLock lock;

        <span class="comment">/**
         * Constructor for use by subclasses
         *
         * @param lock the outer lock object
         * @throws NullPointerException if the lock is null
         */</span>
        <span class="keyword">protected</span> WriteLock<span class="delimiter">(</span>ReentrantReadWriteLock lock<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>lock == <span class="keyword">null</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">this</span>.lock = lock;
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Acquires the write lock.
         *
         * &lt;p&gt;Acquires the write lock if neither the read nor write lock
         * are held by another thread
         * and returns immediately, setting the write lock hold count to
         * one.
         *
         * &lt;p&gt;If the current thread already holds the write lock then the
         * hold count is incremented by one and the method returns
         * immediately.
         *
         * &lt;p&gt;If the lock is held by another thread then the current
         * thread becomes disabled for thread scheduling purposes and
         * lies dormant until the write lock has been acquired, at which
         * time the write lock hold count is set to one.
         */</span>
        public void lock<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            synchronized <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>lock.sync.startWriteFromNewWriter<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">return</span>;
                boolean wasInterrupted = Thread.interrupted<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">try</span> <span class="delimiter">{</span>
                    <span class="keyword">while</span> <span class="delimiter">(</span><span class="keyword">true</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                        <span class="keyword">try</span> <span class="delimiter">{</span>
                            WriteLock.<span class="keyword">this</span>.wait<span class="delimiter">(</span><span class="delimiter">)</span>;
                        <span class="delimiter">}</span>
                        <span class="keyword">catch</span> <span class="delimiter">(</span>InterruptedException ex<span class="delimiter">)</span> <span class="delimiter">{</span>
                            wasInterrupted = <span class="keyword">true</span>;
                            <span class="comment">// no need to notify; if we were notified,</span>
                            <span class="comment">// we will act as notified, and succeed in</span>
                            <span class="comment">// startWrite and return</span>
                        <span class="delimiter">}</span>
                        <span class="keyword">if</span> <span class="delimiter">(</span>lock.sync.startWriteFromWaitingWriter<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">return</span>;
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span>
                <span class="keyword">finally</span> <span class="delimiter">{</span>
                    <span class="keyword">if</span> <span class="delimiter">(</span>wasInterrupted<span class="delimiter">)</span> Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span>.interrupt<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Acquires the write lock unless the current thread is
         * {@linkplain Thread#interrupt interrupted}.
         *
         * &lt;p&gt;Acquires the write lock if neither the read nor write lock
         * are held by another thread
         * and returns immediately, setting the write lock hold count to
         * one.
         *
         * &lt;p&gt;If the current thread already holds this lock then the
         * hold count is incremented by one and the method returns
         * immediately.
         *
         * &lt;p&gt;If the lock is held by another thread then the current
         * thread becomes disabled for thread scheduling purposes and
         * lies dormant until one of two things happens:
         *
         * &lt;ul&gt;
         *
         * &lt;li&gt;The write lock is acquired by the current thread; or
         *
         * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}
         * the current thread.
         *
         * &lt;/ul&gt;
         *
         * &lt;p&gt;If the write lock is acquired by the current thread then the
         * lock hold count is set to one.
         *
         * &lt;p&gt;If the current thread:
         *
         * &lt;ul&gt;
         *
         * &lt;li&gt;has its interrupted status set on entry to this method;
         * or
         *
         * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while
         * acquiring the write lock,
         *
         * &lt;/ul&gt;
         *
         * then {@link InterruptedException} is thrown and the current
         * thread's interrupted status is cleared.
         *
         * &lt;p&gt;In this implementation, as this method is an explicit
         * interruption point, preference is given to responding to
         * the interrupt over normal or reentrant acquisition of the
         * lock.
         *
         * @throws InterruptedException if the current thread is interrupted
         */</span>
        public void lockInterruptibly<span class="delimiter">(</span><span class="delimiter">)</span> throws InterruptedException <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>Thread.interrupted<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException<span class="delimiter">(</span><span class="delimiter">)</span>;
            InterruptedException ie = <span class="keyword">null</span>;
            synchronized <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>!lock.sync.startWriteFromNewWriter<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">for</span> <span class="delimiter">(</span>; ; <span class="delimiter">)</span> <span class="delimiter">{</span>
                        <span class="keyword">try</span> <span class="delimiter">{</span>
                            WriteLock.<span class="keyword">this</span>.wait<span class="delimiter">(</span><span class="delimiter">)</span>;
                            <span class="keyword">if</span> <span class="delimiter">(</span>lock.sync.startWriteFromWaitingWriter<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
                                <span class="keyword">return</span>;
                        <span class="delimiter">}</span>
                        <span class="keyword">catch</span> <span class="delimiter">(</span>InterruptedException ex<span class="delimiter">)</span> <span class="delimiter">{</span>
                            lock.sync.cancelledWaitingWriter<span class="delimiter">(</span><span class="delimiter">)</span>;
                            WriteLock.<span class="keyword">this</span>.notify<span class="delimiter">(</span><span class="delimiter">)</span>;
                            ie = ex;
                            break;
                        <span class="delimiter">}</span>
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>ie != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="comment">// Fall through outside synch on interrupt.</span>
                <span class="comment">//  On exception, we may need to signal readers.</span>
                <span class="comment">//  It is not worth checking here whether it is strictly necessary.</span>
                lock.readerLock_.signalWaiters<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">throw</span> ie;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Acquires the write lock only if it is not held by another thread
         * at the time of invocation.
         *
         * &lt;p&gt;Acquires the write lock if neither the read nor write lock
         * are held by another thread
         * and returns immediately with the value {@code true},
         * setting the write lock hold count to one. Even when this lock has
         * been set to use a fair ordering policy, a call to
         * {@code tryLock()} &lt;em&gt;will&lt;/em&gt; immediately acquire the
         * lock if it is available, whether or not other threads are
         * currently waiting for the write lock.  This &amp;quot;barging&amp;quot;
         * behavior can be useful in certain circumstances, even
         * though it breaks fairness. If you want to honor the
         * fairness setting for this lock, then use {@link
         * #tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS) }
         * which is almost equivalent (it also detects interruption).
         *
         * &lt;p&gt; If the current thread already holds this lock then the
         * hold count is incremented by one and the method returns
         * {@code true}.
         *
         * &lt;p&gt;If the lock is held by another thread then this method
         * will return immediately with the value {@code false}.
         *
         * @return {@code true} if the lock was free and was acquired
         * by the current thread, or the write lock was already held
         * by the current thread; and {@code false} otherwise.
         */</span>
        public boolean tryLock<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> lock.sync.startWrite<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Acquires the write lock if it is not held by another thread
         * within the given waiting time and the current thread has
         * not been {@linkplain Thread#interrupt interrupted}.
         *
         * &lt;p&gt;Acquires the write lock if neither the read nor write lock
         * are held by another thread
         * and returns immediately with the value {@code true},
         * setting the write lock hold count to one. If this lock has been
         * set to use a fair ordering policy then an available lock
         * &lt;em&gt;will not&lt;/em&gt; be acquired if any other threads are
         * waiting for the write lock. This is in contrast to the {@link
         * #tryLock()} method. If you want a timed {@code tryLock}
         * that does permit barging on a fair lock then combine the
         * timed and un-timed forms together:
         *
         * &lt;pre&gt;if (lock.tryLock() || lock.tryLock(timeout, unit) ) { ... }
         * &lt;/pre&gt;
         *
         * &lt;p&gt;If the current thread already holds this lock then the
         * hold count is incremented by one and the method returns
         * {@code true}.
         *
         * &lt;p&gt;If the lock is held by another thread then the current
         * thread becomes disabled for thread scheduling purposes and
         * lies dormant until one of three things happens:
         *
         * &lt;ul&gt;
         *
         * &lt;li&gt;The write lock is acquired by the current thread; or
         *
         * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}
         * the current thread; or
         *
         * &lt;li&gt;The specified waiting time elapses
         *
         * &lt;/ul&gt;
         *
         * &lt;p&gt;If the write lock is acquired then the value {@code true} is
         * returned and the write lock hold count is set to one.
         *
         * &lt;p&gt;If the current thread:
         *
         * &lt;ul&gt;
         *
         * &lt;li&gt;has its interrupted status set on entry to this method;
         * or
         *
         * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while
         * acquiring the write lock,
         *
         * &lt;/ul&gt;
         *
         * then {@link InterruptedException} is thrown and the current
         * thread's interrupted status is cleared.
         *
         * &lt;p&gt;If the specified waiting time elapses then the value
         * {@code false} is returned.  If the time is less than or
         * equal to zero, the method will not wait at all.
         *
         * &lt;p&gt;In this implementation, as this method is an explicit
         * interruption point, preference is given to responding to
         * the interrupt over normal or reentrant acquisition of the
         * lock, and over reporting the elapse of the waiting time.
         *
         * @param timeout the time to wait for the write lock
         * @param unit the time unit of the timeout argument
         *
         * @return {@code true} if the lock was free and was acquired
         * by the current thread, or the write lock was already held by the
         * current thread; and {@code false} if the waiting time
         * elapsed before the lock could be acquired.
         *
         * @throws InterruptedException if the current thread is interrupted
         * @throws NullPointerException if the time unit is null
         *
         */</span>
        public boolean tryLock<span class="delimiter">(</span>long timeout, TimeUnit unit<span class="delimiter">)</span> throws InterruptedException <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>Thread.interrupted<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException<span class="delimiter">(</span><span class="delimiter">)</span>;
            InterruptedException ie = <span class="keyword">null</span>;
            long nanos = unit.toNanos<span class="delimiter">(</span>timeout<span class="delimiter">)</span>;
            synchronized <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>nanos &lt;= <span class="int">0</span><span class="delimiter">)</span>
                    <span class="keyword">return</span> lock.sync.startWrite<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>lock.sync.startWriteFromNewWriter<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="keyword">return</span> <span class="keyword">true</span>;
                <span class="keyword">else</span> <span class="delimiter">{</span>
                    long deadline = Utils.nanoTime<span class="delimiter">(</span><span class="delimiter">)</span> + nanos;
                    <span class="keyword">for</span> <span class="delimiter">(</span>; ; <span class="delimiter">)</span> <span class="delimiter">{</span>
                        <span class="keyword">try</span> <span class="delimiter">{</span>
                            TimeUnit.NANOSECONDS.timedWait<span class="delimiter">(</span>WriteLock.<span class="keyword">this</span>, nanos<span class="delimiter">)</span>;
                        <span class="delimiter">}</span>
                        <span class="keyword">catch</span> <span class="delimiter">(</span>InterruptedException ex<span class="delimiter">)</span> <span class="delimiter">{</span>
                            lock.sync.cancelledWaitingWriter<span class="delimiter">(</span><span class="delimiter">)</span>;
                            WriteLock.<span class="keyword">this</span>.notify<span class="delimiter">(</span><span class="delimiter">)</span>;
                            ie = ex;
                            break;
                        <span class="delimiter">}</span>
                        <span class="keyword">if</span> <span class="delimiter">(</span>lock.sync.startWriteFromWaitingWriter<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
                            <span class="keyword">return</span> <span class="keyword">true</span>;
                        <span class="keyword">else</span> <span class="delimiter">{</span>
                            nanos = deadline - Utils.nanoTime<span class="delimiter">(</span><span class="delimiter">)</span>;
                            <span class="keyword">if</span> <span class="delimiter">(</span>nanos &lt;= <span class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                                lock.sync.cancelledWaitingWriter<span class="delimiter">(</span><span class="delimiter">)</span>;
                                WriteLock.<span class="keyword">this</span>.notify<span class="delimiter">(</span><span class="delimiter">)</span>;
                                break;
                            <span class="delimiter">}</span>
                        <span class="delimiter">}</span>
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>

            lock.readerLock_.signalWaiters<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>ie != <span class="keyword">null</span><span class="delimiter">)</span>
                <span class="keyword">throw</span> ie;
            <span class="keyword">else</span>
                <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// timed out</span>
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Attempts to release this lock.
         *
         * &lt;p&gt;If the current thread is the holder of this lock then
         * the hold count is decremented. If the hold count is now
         * zero then the lock is released.  If the current thread is
         * not the holder of this lock then {@link
         * IllegalMonitorStateException} is thrown.
         *
         * @throws IllegalMonitorStateException if the current thread does not
         * hold this lock.
         */</span>
        public void unlock<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            switch <span class="delimiter">(</span>lock.sync.endWrite<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> Sync.NONE: <span class="keyword">return</span>;
                <span class="keyword">case</span> Sync.READER: lock.readerLock_.signalWaiters<span class="delimiter">(</span><span class="delimiter">)</span>; <span class="keyword">return</span>;
                <span class="keyword">case</span> Sync.WRITER: lock.writerLock_.signalWaiters<span class="delimiter">(</span><span class="delimiter">)</span>; <span class="keyword">return</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Returns a {@link Condition} instance for use with this
         * {@link Lock} instance.
         * &lt;p&gt;The returned {@link Condition} instance supports the same
         * usages as do the {@link Object} monitor methods ({@link
         * Object#wait() wait}, {@link Object#notify notify}, and {@link
         * Object#notifyAll notifyAll}) when used with the built-in
         * monitor lock.
         *
         * &lt;ul&gt;
         *
         * &lt;li&gt;If this write lock is not held when any {@link
         * Condition} method is called then an {@link
         * IllegalMonitorStateException} is thrown.  (Read locks are
         * held independently of write locks, so are not checked or
         * affected. However it is essentially always an error to
         * invoke a condition waiting method when the current thread
         * has also acquired read locks, since other threads that
         * could unblock it will not be able to acquire the write
         * lock.)
         *
         * &lt;li&gt;When the condition {@linkplain Condition#await() waiting}
         * methods are called the write lock is released and, before
         * they return, the write lock is reacquired and the lock hold
         * count restored to what it was when the method was called.
         *
         * &lt;li&gt;If a thread is {@linkplain Thread#interrupt interrupted} while
         * waiting then the wait will terminate, an {@link
         * InterruptedException} will be thrown, and the thread's
         * interrupted status will be cleared.
         *
         * &lt;li&gt; Waiting threads are signalled in FIFO order.
         *
         * &lt;li&gt;The ordering of lock reacquisition for threads returning
         * from waiting methods is the same as for threads initially
         * acquiring the lock, which is in the default case not specified,
         * but for &lt;em&gt;fair&lt;/em&gt; locks favors those threads that have been
         * waiting the longest.
         *
         * &lt;/ul&gt;
         *
         * @return the Condition object
         */</span>
        public Condition newCondition<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> <span class="keyword">new</span> CondVar<span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        synchronized void signalWaiters<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            notify<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Returns a string identifying this lock, as well as its lock
         * state.  The state, in brackets includes either the String
         * {@code &quot;Unlocked&quot;} or the String {@code &quot;Locked by&quot;}
         * followed by the {@linkplain Thread#getName name} of the owning thread.
         *
         * @return a string identifying this lock, as well as its lock state
         */</span>
        public String toString<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            Thread o = lock.getOwner<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">return</span> <span class="keyword">super</span>.toString<span class="delimiter">(</span><span class="delimiter">)</span> + <span class="delimiter">(</span><span class="delimiter">(</span>o == <span class="keyword">null</span><span class="delimiter">)</span> ?
                                       <span class="string">&quot;[Unlocked]&quot;</span> :
                                       <span class="string">&quot;[Locked by thread &quot;</span> + o.getName<span class="delimiter">(</span><span class="delimiter">)</span> + <span class="string">&quot;]&quot;</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Queries if this write lock is held by the current thread.
         * Identical in effect to {@link
         * ReentrantReadWriteLock#isWriteLockedByCurrentThread}.
         *
         * @return {@code true} if the current thread holds this lock and
         *	   {@code false} otherwise
         * @since 1.6
         */</span>
        public boolean isHeldByCurrentThread<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> lock.sync.isWriteLockedByCurrentThread<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Queries the number of holds on this write lock by the current
         * thread.  A thread has a hold on a lock for each lock action
         * that is not matched by an unlock action.  Identical in effect
         * to {@link ReentrantReadWriteLock#getWriteHoldCount}.
         *
         * @return the number of holds on this lock by the current thread,
         *	   or zero if this lock is not held by the current thread
         * @since 1.6
         */</span>
        public int getHoldCount<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> lock.sync.getWriteHoldCount<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

    <span class="delimiter">}</span>

    <span class="comment">// Instrumentation and status</span>

    <span class="comment">/**
     * Returns {@code true} if this lock has fairness set true.
     *
     * @return {@code true} if this lock has fairness set true
     */</span>
    public <span class="keyword">final</span> boolean isFair<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns the thread that currently owns the write lock, or
     * {@code null} if not owned. When this method is called by a
     * thread that is not the owner, the return value reflects a
     * best-effort approximation of current lock status. For example,
     * the owner may be momentarily {@code null} even if there are
     * threads trying to acquire the lock but have not yet done so.
     * This method is designed to facilitate construction of
     * subclasses that provide more extensive lock monitoring
     * facilities.
     *
     * @return the owner, or {@code null} if not owned
     */</span>
    <span class="keyword">protected</span> Thread getOwner<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> sync.getOwner<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Queries the number of read locks held for this lock. This
     * method is designed for use in monitoring system state, not for
     * synchronization control.
     * @return the number of read locks held.
     */</span>
    public int getReadLockCount<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> sync.getReadLockCount<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Queries if the write lock is held by any thread. This method is
     * designed for use in monitoring system state, not for
     * synchronization control.
     *
     * @return {@code true} if any thread holds the write lock and
     *         {@code false} otherwise
     */</span>
    public boolean isWriteLocked<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> sync.isWriteLocked<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Queries if the write lock is held by the current thread.
     *
     * @return {@code true} if the current thread holds the write lock and
     *         {@code false} otherwise
     */</span>
    public boolean isWriteLockedByCurrentThread<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> sync.isWriteLockedByCurrentThread<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Queries the number of reentrant write holds on this lock by the
     * current thread.  A writer thread has a hold on a lock for
     * each lock action that is not matched by an unlock action.
     *
     * @return the number of holds on the write lock by the current thread,
     *         or zero if the write lock is not held by the current thread
     */</span>
    public int getWriteHoldCount<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> sync.getWriteHoldCount<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Queries the number of reentrant read holds on this lock by the
     * current thread.  A reader thread has a hold on a lock for
     * each lock action that is not matched by an unlock action.
     *
     * @return the number of holds on the read lock by the current thread,
     *         or zero if the read lock is not held by the current thread
     * @since 1.6
     */</span>
    public int getReadHoldCount<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> sync.getReadHoldCount<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>


<span class="comment">//    /**</span>
<span class="comment">//     * Returns a collection containing threads that may be waiting to</span>
<span class="comment">//     * acquire the write lock.  Because the actual set of threads may</span>
<span class="comment">//     * change dynamically while constructing this result, the returned</span>
<span class="comment">//     * collection is only a best-effort estimate.  The elements of the</span>
<span class="comment">//     * returned collection are in no particular order.  This method is</span>
<span class="comment">//     * designed to facilitate construction of subclasses that provide</span>
<span class="comment">//     * more extensive lock monitoring facilities.</span>
<span class="comment">//     * @return the collection of threads</span>
<span class="comment">//     */</span>
<span class="comment">//    protected Collection getQueuedWriterThreads() {</span>
<span class="comment">//        return sync.getExclusiveQueuedThreads();</span>
<span class="comment">//    }</span>
<span class="comment">//</span>
<span class="comment">//    /**</span>
<span class="comment">//     * Returns a collection containing threads that may be waiting to</span>
<span class="comment">//     * acquire the read lock.  Because the actual set of threads may</span>
<span class="comment">//     * change dynamically while constructing this result, the returned</span>
<span class="comment">//     * collection is only a best-effort estimate.  The elements of the</span>
<span class="comment">//     * returned collection are in no particular order.  This method is</span>
<span class="comment">//     * designed to facilitate construction of subclasses that provide</span>
<span class="comment">//     * more extensive lock monitoring facilities.</span>
<span class="comment">//     * @return the collection of threads</span>
<span class="comment">//     */</span>
<span class="comment">//    protected Collection getQueuedReaderThreads() {</span>
<span class="comment">//        return sync.getSharedQueuedThreads();</span>
<span class="comment">//    }</span>
<span class="comment">//</span>
    <span class="comment">/**
     * Queries whether any threads are waiting to acquire the read or
     * write lock. Note that because cancellations may occur at any
     * time, a {@code true} return does not guarantee that any other
     * thread will ever acquire a lock.  This method is designed
     * primarily for use in monitoring of the system state.
     *
     * @return {@code true} if there may be other threads waiting to
     *         acquire the lock
     */</span>
    public <span class="keyword">final</span> boolean hasQueuedThreads<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> sync.hasQueuedThreads<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>
<span class="comment">//</span>
<span class="comment">//    /**</span>
<span class="comment">//     * Queries whether the given thread is waiting to acquire either</span>
<span class="comment">//     * the read or write lock. Note that because cancellations may</span>
<span class="comment">//     * occur at any time, a &lt;tt&gt;true&lt;/tt&gt; return does not guarantee</span>
<span class="comment">//     * that this thread will ever acquire a lock.  This method is</span>
<span class="comment">//     * designed primarily for use in monitoring of the system state.</span>
<span class="comment">//     *</span>
<span class="comment">//     * @param thread the thread</span>
<span class="comment">//     * @return true if the given thread is queued waiting for this lock.</span>
<span class="comment">//     * @throws NullPointerException if thread is null</span>
<span class="comment">//     */</span>
<span class="comment">//    public final boolean hasQueuedThread(Thread thread) {</span>
<span class="comment">//        return sync.isQueued(thread);</span>
<span class="comment">//    }</span>

    <span class="comment">/**
     * Returns an estimate of the number of threads waiting to acquire
     * either the read or write lock.  The value is only an estimate
     * because the number of threads may change dynamically while this
     * method traverses internal data structures.  This method is
     * designed for use in monitoring of the system state, not for
     * synchronization control.
     *
     * @return the estimated number of threads waiting for this lock
     */</span>
    public <span class="keyword">final</span> int getQueueLength<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> sync.getQueueLength<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

<span class="comment">//    /**</span>
<span class="comment">//     * Returns a collection containing threads that may be waiting to</span>
<span class="comment">//     * acquire either the read or write lock.  Because the actual set</span>
<span class="comment">//     * of threads may change dynamically while constructing this</span>
<span class="comment">//     * result, the returned collection is only a best-effort estimate.</span>
<span class="comment">//     * The elements of the returned collection are in no particular</span>
<span class="comment">//     * order.  This method is designed to facilitate construction of</span>
<span class="comment">//     * subclasses that provide more extensive monitoring facilities.</span>
<span class="comment">//     * @return the collection of threads</span>
<span class="comment">//     */</span>
<span class="comment">//    protected Collection getQueuedThreads() {</span>
<span class="comment">//        return sync.getQueuedThreads();</span>
<span class="comment">//    }</span>
<span class="comment">//</span>
<span class="comment">//    /**</span>
<span class="comment">//     * Queries whether any threads are waiting on the given condition</span>
<span class="comment">//     * associated with the write lock. Note that because timeouts and</span>
<span class="comment">//     * interrupts may occur at any time, a &lt;tt&gt;true&lt;/tt&gt; return does</span>
<span class="comment">//     * not guarantee that a future &lt;tt&gt;signal&lt;/tt&gt; will awaken any</span>
<span class="comment">//     * threads.  This method is designed primarily for use in</span>
<span class="comment">//     * monitoring of the system state.</span>
<span class="comment">//     * @param condition the condition</span>
<span class="comment">//     * @return &lt;tt&gt;true&lt;/tt&gt; if there are any waiting threads.</span>
<span class="comment">//     * @throws IllegalMonitorStateException if this lock</span>
<span class="comment">//     * is not held</span>
<span class="comment">//     * @throws IllegalArgumentException if the given condition is</span>
<span class="comment">//     * not associated with this lock</span>
<span class="comment">//     * @throws NullPointerException if condition null</span>
<span class="comment">//     */</span>
<span class="comment">//    public boolean hasWaiters(Condition condition) {</span>
<span class="comment">//        if (condition == null)</span>
<span class="comment">//            throw new NullPointerException();</span>
<span class="comment">//        if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))</span>
<span class="comment">//            throw new IllegalArgumentException(&quot;not owner&quot;);</span>
<span class="comment">//        return sync.hasWaiters((AbstractQueuedSynchronizer.ConditionObject)condition);</span>
<span class="comment">//    }</span>

<span class="comment">//    /**</span>
<span class="comment">//     * Returns an estimate of the number of threads waiting on the</span>
<span class="comment">//     * given condition associated with the write lock. Note that because</span>
<span class="comment">//     * timeouts and interrupts may occur at any time, the estimate</span>
<span class="comment">//     * serves only as an upper bound on the actual number of waiters.</span>
<span class="comment">//     * This method is designed for use in monitoring of the system</span>
<span class="comment">//     * state, not for synchronization control.</span>
<span class="comment">//     * @param condition the condition</span>
<span class="comment">//     * @return the estimated number of waiting threads.</span>
<span class="comment">//     * @throws IllegalMonitorStateException if this lock</span>
<span class="comment">//     * is not held</span>
<span class="comment">//     * @throws IllegalArgumentException if the given condition is</span>
<span class="comment">//     * not associated with this lock</span>
<span class="comment">//     * @throws NullPointerException if condition null</span>
<span class="comment">//     */</span>
<span class="comment">//    public int getWaitQueueLength(Condition condition) {</span>
<span class="comment">//        if (condition == null)</span>
<span class="comment">//            throw new NullPointerException();</span>
<span class="comment">//        if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))</span>
<span class="comment">//            throw new IllegalArgumentException(&quot;not owner&quot;);</span>
<span class="comment">//        return sync.getWaitQueueLength((AbstractQueuedSynchronizer.ConditionObject)condition);</span>
<span class="comment">//    }</span>
<span class="comment">//</span>
<span class="comment">//    /**</span>
<span class="comment">//     * Returns a collection containing those threads that may be</span>
<span class="comment">//     * waiting on the given condition associated with the write lock.</span>
<span class="comment">//     * Because the actual set of threads may change dynamically while</span>
<span class="comment">//     * constructing this result, the returned collection is only a</span>
<span class="comment">//     * best-effort estimate. The elements of the returned collection</span>
<span class="comment">//     * are in no particular order.  This method is designed to</span>
<span class="comment">//     * facilitate construction of subclasses that provide more</span>
<span class="comment">//     * extensive condition monitoring facilities.</span>
<span class="comment">//     * @param condition the condition</span>
<span class="comment">//     * @return the collection of threads</span>
<span class="comment">//     * @throws IllegalMonitorStateException if this lock</span>
<span class="comment">//     * is not held</span>
<span class="comment">//     * @throws IllegalArgumentException if the given condition is</span>
<span class="comment">//     * not associated with this lock</span>
<span class="comment">//     * @throws NullPointerException if condition null</span>
<span class="comment">//     */</span>
<span class="comment">//    protected Collection getWaitingThreads(Condition condition) {</span>
<span class="comment">//        if (condition == null)</span>
<span class="comment">//            throw new NullPointerException();</span>
<span class="comment">//        if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))</span>
<span class="comment">//            throw new IllegalArgumentException(&quot;not owner&quot;);</span>
<span class="comment">//        return sync.getWaitingThreads((AbstractQueuedSynchronizer.ConditionObject)condition);</span>
<span class="comment">//    }</span>

    <span class="comment">/**
     * Returns a string identifying this lock, as well as its lock state.
     * The state, in brackets, includes the String {@code &quot;Write locks =&quot;}
     * followed by the number of reentrantly held write locks, and the
     * String {@code &quot;Read locks =&quot;} followed by the number of held
     * read locks.
     *
     * @return a string identifying this lock, as well as its lock state
     */</span>
    public String toString<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">super</span>.toString<span class="delimiter">(</span><span class="delimiter">)</span> +
            <span class="string">&quot;[Write locks = &quot;</span> + getWriteHoldCount<span class="delimiter">(</span><span class="delimiter">)</span> +
            <span class="string">&quot;, Read locks = &quot;</span> + getReadLockCount<span class="delimiter">(</span><span class="delimiter">)</span> + <span class="string">&quot;]&quot;</span>;
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>