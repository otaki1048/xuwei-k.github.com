<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/collection/GenTraversableOnce.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2003-2011, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

<span class="keyword">package</span> scala.collection

<span class="comment">/** A template trait for all traversable-once objects which may be
 *  traversed in parallel.
 *
 *  Methods in this trait are either abstract or can be implemented in terms
 *  of other methods.
 *  
 *  @define Coll GenTraversableOnce
 *  @define coll collection or iterator
 *  @define possiblyparinfo
 *  This trait may possibly have operations implemented in parallel.
 *  @define undefinedorder
 *  The order in which operations are performed on elements is unspecified and may be nondeterministic.
 *  @define orderDependent
 * 
 *    Note: might return different results for different runs, unless the underlying collection type is ordered.
 *  @define orderDependentFold
 * 
 *    Note: might return different results for different runs, unless the
 *    underlying collection type is ordered or the operator is associative
 *    and commutative.
 *  @define mayNotTerminateInf
 *
 *    Note: may not terminate for infinite-sized collections.
 *  @define willNotTerminateInf
 *
 *    Note: will not terminate for infinite-sized collections.
 *
 *  @author Martin Odersky
 *  @author Aleksandar Prokopec
 *  @since 2.9
 */</span>
<span class="keyword">trait</span> <a title="trait GenTraversableOnce[+A] extends java.lang.Object with ScalaObject" id="7769">GenTraversableOnce</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="12277">A</a><span class="delimiter">]</span> <a href="../ScalaObject.scala.html#456" title="ScalaObject" class="delimiter">{</a>
  
  <span class="keyword">def</span> <a title="[U](f: A =&gt; U)Unit" id="30817">foreach</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="30819">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; U" id="35899">f</a>: A =&gt; U<span class="delimiter">)</span>: <a href="../Unit.scala.html#453" title="Unit">Unit</a>
  
  <span class="keyword">def</span> <a title="=&gt; Boolean" id="30820">hasDefiniteSize</a>: <a href="../Boolean.scala.html#57" title="Boolean">Boolean</a>
  
  <span class="keyword">def</span> <a title="=&gt; scala.collection.TraversableOnce[A]" id="30821">seq</a>: <a href="TraversableOnce.scala.html#9011" title="scala.collection.TraversableOnce[A]">TraversableOnce</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  
  <span class="comment">/** The size of this $coll.
   *
   *  $willNotTerminateInf
   *
   *  @return    the number of elements in this $coll.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; Int" id="30822">size</a>: <a href="../Int.scala.html#378" title="Int">Int</a>
  
  <span class="comment">/** Tests whether the $coll is empty.
   *
   *  @return    `true` if the $coll contains no elements, `false` otherwise.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; Boolean" id="30823">isEmpty</a>: <a href="../Boolean.scala.html#57" title="Boolean">Boolean</a>
  
  <span class="comment">/** Tests whether the $coll is not empty.
   * 
   *  @return    `true` if the $coll contains at least one element, `false` otherwise.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; Boolean" id="30824">nonEmpty</a>: <a href="../Boolean.scala.html#57" title="Boolean">Boolean</a>
  
  <span class="comment">/** Tests whether this $coll can be repeatedly traversed.  Always
   *  true for Traversables and false for Iterators unless overridden.
   *
   *  @return   `true` if it is repeatedly traversable, `false` otherwise.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; Boolean" id="30825">isTraversableAgain</a>: <a href="../Boolean.scala.html#57" title="Boolean">Boolean</a>
  
  <span class="comment">/** Reduces the elements of this sequence using the specified associative binary operator.
   *  
   *  $undefinedorder
   *  
   *  Note this method has a different signature than the `reduceLeft`
   *  and `reduceRight` methods of the trait `Traversable`.
   *  The result of reducing may only be a supertype of this parallel collection's
   *  type parameter `T`.
   *  
   *  @tparam U      A type parameter for the binary operator, a supertype of `T`.
   *  @param op       A binary operator that must be associative.
   *  @return         The result of applying reduce operator `op` between all the elements if the collection is nonempty.
   *  @throws UnsupportedOperationException
   *  if this $coll is empty.
   */</span>
  <span class="keyword">def</span> <a title="[A1 &gt;: A](op: (A1, A1) =&gt; A1)A1" id="30826">reduce</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30828">A1</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="(A1, A1) =&gt; A1" id="36875">op</a>: <span class="delimiter">(</span>A1, A1<span class="delimiter">)</span> =&gt; A1<span class="delimiter">)</span>: <a href="#30828" title="A1">A1</a>
  
  <span class="comment">/** Optionally reduces the elements of this sequence using the specified associative binary operator.
   *  
   *  $undefinedorder
   *  
   *  Note this method has a different signature than the `reduceLeftOption`
   *  and `reduceRightOption` methods of the trait `Traversable`.
   *  The result of reducing may only be a supertype of this parallel collection's
   *  type parameter `T`.
   *  
   *  @tparam U      A type parameter for the binary operator, a supertype of `T`.
   *  @param op      A binary operator that must be associative.
   *  @return        An option value containing result of applying reduce operator `op` between all
   *                 the elements if the collection is nonempty, and `None` otherwise. 
   */</span>
  <span class="keyword">def</span> <a title="[A1 &gt;: A](op: (A1, A1) =&gt; A1)Option[A1]" id="30829">reduceOption</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30831">A1</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="(A1, A1) =&gt; A1" id="36860">op</a>: <span class="delimiter">(</span>A1, A1<span class="delimiter">)</span> =&gt; A1<span class="delimiter">)</span>: <a href="../Option.scala.html#552" title="Option[A1]">Option</a><span class="delimiter">[</span>A1<span class="delimiter">]</span>
  
  <span class="comment">/** Folds the elements of this sequence using the specified associative binary operator.
   *  The order in which the elements are reduced is unspecified and may be nondeterministic.
   *  
   *  Note this method has a different signature than the `foldLeft`
   *  and `foldRight` methods of the trait `Traversable`.
   *  The result of folding may only be a supertype of this parallel collection's
   *  type parameter `T`.
   *  
   *  @tparam U      a type parameter for the binary operator, a supertype of `T`.
   *  @param z       a neutral element for the fold operation, it may be added to the result
   *                 an arbitrary number of times, not changing the result (e.g. `Nil` for list concatenation,
   *                 0 for addition, or 1 for multiplication)
   *  @param op      a binary operator that must be associative
   *  @return        the result of applying fold operator `op` between all the elements and `z`
   */</span>
  <span class="keyword">def</span> <a title="[A1 &gt;: A](z: A1)(op: (A1, A1) =&gt; A1)A1" id="30832">fold</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30834">A1</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="A1" id="36835">z</a>: <a href="#30834" title="A1">A1</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A1, A1) =&gt; A1" id="36836">op</a>: <span class="delimiter">(</span>A1, A1<span class="delimiter">)</span> =&gt; A1<span class="delimiter">)</span>: <a href="#30834" title="A1">A1</a>
  
  <span class="comment">/** A syntactic sugar for out of order folding. See `fold`. */</span>
  <span class="keyword">def</span> <a title="[A1 &gt;: A](z: A1)(op: (A1, A1) =&gt; A1)A1" id="30835">/:\</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30837">A1</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="A1" id="93733">z</a>: <a href="#30837" title="A1">A1</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A1, A1) =&gt; A1" id="93734">op</a>: <span class="delimiter">(</span>A1, A1<span class="delimiter">)</span> =&gt; A1<span class="delimiter">)</span>: <a href="#30837" title="A1">A1</a> = <a href="#30832" title="(z: A1)(op: (A1, A1) =&gt; A1)A1">fold</a><span class="delimiter">(</span><a href="#93733" title="A1">z</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#93734" title="(A1, A1) =&gt; A1">op</a><span class="delimiter">)</span>
  
  <span class="comment">/** Applies a binary operator to a start value and all elements of this $coll,
   *  going left to right.
   *
   *  Note: `/:` is alternate syntax for `foldLeft`; `z /: xs` is the same as
   *  `xs foldLeft z`.
   *  $willNotTerminateInf
   *  $orderDependentFold
   *
   *  @param   z    the start value.
   *  @param   op   the binary operator.
   *  @tparam  B    the result type of the binary operator.
   *  @return  the result of inserting `op` between consecutive elements of this $coll,
   *           going left to right with the start value `z` on the left:
   *           {{{
   *             op(...op(op(z, x,,1,,), x,,2,,), ..., x,,n,,)
   *           }}}
   *           where `x,,1,,, ..., x,,n,,` are the elements of this $coll.
   */</span>
  <span class="keyword">def</span> <a title="[B](z: B)(op: (B, A) =&gt; B)B" id="30838">/:</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="30840">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="36816">z</a>: <a href="#30840" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, A) =&gt; B" id="36817">op</a>: <span class="delimiter">(</span>B, A<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#30840" title="B">B</a>
  
  <span class="comment">/** Applies a binary operator to all elements of this $coll and a start value,
   *  going right to left.
   *
   *  Note: `:\` is alternate syntax for `foldRight`; `xs :\ z` is the same as
   *  `xs foldRight z`.
   *  $willNotTerminateInf
   *  $orderDependentFold
   * 
   *  @param   z    the start value
   *  @param   op   the binary operator
   *  @tparam  B    the result type of the binary operator.
   *  @return  the result of inserting `op` between consecutive elements of this $coll,
   *           going right to left with the start value `z` on the right:
   *           {{{
   *             op(x,,1,,, op(x,,2,,, ... op(x,,n,,, z)...))
   *           }}}
   *           where `x,,1,,, ..., x,,n,,` are the elements of this $coll.
   */</span>
  <span class="keyword">def</span> <a title="[B](z: B)(op: (A, B) =&gt; B)B" id="30841">:\</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="30843">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="36797">z</a>: <a href="#30843" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; B" id="36798">op</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#30843" title="B">B</a>
  
  <span class="comment">/** Applies a binary operator to a start value and all elements of this $coll,
   *  going left to right.
   * 
   *  $willNotTerminateInf
   *  $orderDependentFold
   *
   *  @param   z    the start value.
   *  @param   op   the binary operator.
   *  @tparam  B    the result type of the binary operator.
   *  @return  the result of inserting `op` between consecutive elements of this $coll,
   *           going left to right with the start value `z` on the left:
   *           {{{
   *             op(...op(z, x,,1,,), x,,2,,, ..., x,,n,,)
   *           }}}
   *           where `x,,1,,, ..., x,,n,,` are the elements of this $coll.
   */</span>
  <span class="keyword">def</span> <a title="[B](z: B)(op: (B, A) =&gt; B)B" id="30844">foldLeft</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="30846">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="36778">z</a>: <a href="#30846" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, A) =&gt; B" id="36779">op</a>: <span class="delimiter">(</span>B, A<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#30846" title="B">B</a>
  
  <span class="comment">/** Applies a binary operator to all elements of this $coll and a start value,
   *  going right to left.
   * 
   *  $willNotTerminateInf
   *  $orderDependentFold
   *  @param   z    the start value.
   *  @param   op   the binary operator.
   *  @tparam  B    the result type of the binary operator.
   *  @return  the result of inserting `op` between consecutive elements of this $coll,
   *           going right to left with the start value `z` on the right:
   *           {{{
   *             op(x,,1,,, op(x,,2,,, ... op(x,,n,,, z)...))
   *           }}}
   *           where `x,,1,,, ..., x,,n,,` are the elements of this $coll.
   */</span>
  <span class="keyword">def</span> <a title="[B](z: B)(op: (A, B) =&gt; B)B" id="30847">foldRight</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="30849">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="36759">z</a>: <a href="#30849" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; B" id="36760">op</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#30849" title="B">B</a>
  
  <span class="comment">/** Aggregates the results of applying an operator to subsequent elements.
   *  
   *  This is a more general form of `fold` and `reduce`. It has similar semantics, but does
   *  not require the result to be a supertype of the element type. It traverses the elements in
   *  different partitions sequentially, using `seqop` to update the result, and then
   *  applies `combop` to results from different partitions. The implementation of this
   *  operation may operate on an arbitrary number of collection partitions, so `combop`
   *  may be invoked arbitrary number of times.
   *  
   *  For example, one might want to process some elements and then produce a `Set`. In this
   *  case, `seqop` would process an element and append it to the list, while `combop`
   *  would concatenate two lists from different partitions together. The initial value
   *  `z` would be an empty set.
   *  
   *  {{{
   *    pc.aggregate(Set[Int]())(_ += process(_), _ ++ _)
   *  }}}
   *  
   *  Another example is calculating geometric mean from a collection of doubles
   *  (one would typically require big doubles for this).
   *  
   *  @tparam S        the type of accumulated results
   *  @param z         the initial value for the accumulated result of the partition - this
   *                   will typically be the neutral element for the `seqop` operator (e.g.
   *                   `Nil` for list concatenation or `0` for summation)
   *  @param seqop     an operator used to accumulate results within a partition
   *  @param combop    an associative operator used to combine results from different partitions
   */</span>
  <span class="keyword">def</span> <a title="[B](z: B)(seqop: (B, A) =&gt; B, combop: (B, B) =&gt; B)B" id="30850">aggregate</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="30852">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="36730">z</a>: <a href="#30852" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, A) =&gt; B" id="36731">seqop</a>: <span class="delimiter">(</span>B, A<span class="delimiter">)</span> =&gt; B, <a title="(B, B) =&gt; B" id="36732">combop</a>: <span class="delimiter">(</span>B, B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#30852" title="B">B</a>
  
  <span class="comment">/** Applies a binary operator to all elements of this $coll, going right to left.
   *  $willNotTerminateInf
   *  $orderDependentFold
   * 
   *  @param  op    the binary operator.
   *  @tparam  B    the result type of the binary operator.
   *  @return  the result of inserting `op` between consecutive elements of this $coll,
   *           going right to left:
   *           {{{
   *             op(x,,1,,, op(x,,2,,, ..., op(x,,n-1,,, x,,n,,)...))
   *           }}}
   *           where `x,,1,,, ..., x,,n,,` are the elements of this $coll.
   *  @throws `UnsupportedOperationException` if this $coll is empty.
   */</span>
  <span class="keyword">def</span> <a title="[B &gt;: A](op: (A, B) =&gt; B)B" id="30853">reduceRight</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30855">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="(A, B) =&gt; B" id="36712">op</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#30855" title="B">B</a>
  
  <span class="comment">/** Optionally applies a binary operator to all elements of this $coll, going left to right.
   *  $willNotTerminateInf
   *  $orderDependentFold
   *  
   *  @param  op    the binary operator.
   *  @tparam  B    the result type of the binary operator.
   *  @return  an option value containing the result of `reduceLeft(op)` is this $coll is nonempty,
   *           `None` otherwise.
   */</span>
  <span class="keyword">def</span> <a title="[B &gt;: A](op: (B, A) =&gt; B)Option[B]" id="30856">reduceLeftOption</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30858">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="(B, A) =&gt; B" id="36694">op</a>: <span class="delimiter">(</span>B, A<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="../Option.scala.html#552" title="Option[B]">Option</a><span class="delimiter">[</span>B<span class="delimiter">]</span>

  <span class="comment">/** Optionally applies a binary operator to all elements of this $coll, going
   *  right to left.
   *  $willNotTerminateInf
   *  $orderDependentFold
   * 
   *  @param  op    the binary operator.
   *  @tparam  B    the result type of the binary operator.
   *  @return  an option value containing the result of `reduceRight(op)` is this $coll is nonempty,
   *           `None` otherwise.
   */</span>
  <span class="keyword">def</span> <a title="[B &gt;: A](op: (A, B) =&gt; B)Option[B]" id="30859">reduceRightOption</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30861">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="(A, B) =&gt; B" id="36676">op</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="../Option.scala.html#552" title="Option[B]">Option</a><span class="delimiter">[</span>B<span class="delimiter">]</span>
  
  <span class="comment">/** Counts the number of elements in the $coll which satisfy a predicate.
   *
   *  @param p     the predicate  used to test elements.
   *  @return      the number of elements satisfying the predicate `p`.
   */</span>
  <span class="keyword">def</span> <a title="(p: A =&gt; Boolean)Int" id="30862">count</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="36669">p</a>: A =&gt; Boolean<span class="delimiter">)</span>: <a href="../Int.scala.html#378" title="Int">Int</a>
  
  <span class="comment">/** Sums up the elements of this collection.
   * 
   *   @param   num  an implicit parameter defining a set of numeric operations
   *                 which includes the `+` operator to be used in forming the sum.
   *   @tparam  B    the result type of the `+` operator.  
   *   @return       the sum of all elements of this $coll with respect to the `+` operator in `num`.
   *
   *   @usecase def sum: A
   * 
   *   @return       the sum of all elements in this $coll of numbers of type `Int`.
   *   Instead of `Int`, any other type `T` with an implicit `Numeric[T]` implementation 
   *   can be used as element type of the $coll and as result type of `sum`. 
   *   Examples of such types are: `Long`, `Float`, `Double`, `BigInt`.
   * 
   */</span>
  <span class="keyword">def</span> <a title="[A1 &gt;: A](implicit num: Numeric[A1])A1" id="30863">sum</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30865">A1</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Numeric[A1]" id="36654">num</a>: <a href="../math/Numeric.scala.html#19029" title="Numeric[A1]">Numeric</a><span class="delimiter">[</span>A1<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#30865" title="A1">A1</a>
  
  <span class="comment">/** Multiplies up the elements of this collection.
   * 
   *   @param   num  an implicit parameter defining a set of numeric operations
   *                 which includes the `*` operator to be used in forming the product.
   *   @tparam  B    the result type of the `*` operator.  
   *   @return       the product of all elements of this $coll with respect to the `*` operator in `num`.
   *
   *   @usecase def product: A
   * 
   *   @return       the product of all elements in this $coll of numbers of type `Int`.
   *   Instead of `Int`, any other type `T` with an implicit `Numeric[T]` implementation 
   *   can be used as element type of the $coll and as result type of `product`. 
   *   Examples of such types are: `Long`, `Float`, `Double`, `BigInt`.
   */</span>
  <span class="keyword">def</span> <a title="[A1 &gt;: A](implicit num: Numeric[A1])A1" id="30866">product</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30868">A1</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Numeric[A1]" id="36639">num</a>: <a href="../math/Numeric.scala.html#19029" title="Numeric[A1]">Numeric</a><span class="delimiter">[</span>A1<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#30868" title="A1">A1</a>
  
  <span class="comment">/** Finds the smallest element.
   *
   *  @param    cmp   An ordering to be used for comparing elements.
   *  @tparam   B     The type over which the ordering is defined.   
   *  @return   the smallest element of this $coll with respect to the ordering `cmp`.
   *
   *  @usecase def min: A
   *  @return   the smallest element of this $coll  
   */</span>
  <span class="keyword">def</span> <a title="[A1 &gt;: A](implicit ord: Ordering[A1])A" id="30869">min</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30871">A1</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Ordering[A1]" id="36624">ord</a>: <a href="../math/Ordering.scala.html#18894" title="Ordering[A1]">Ordering</a><span class="delimiter">[</span>A1<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#12277" title="A">A</a>
  
  <span class="comment">/** Finds the largest element.
   *
   *  @param    cmp   An ordering to be used for comparing elements.
   *  @tparam   B     The type over which the ordering is defined.   
   *  @return   the largest element of this $coll with respect to the ordering `cmp`.
   *
   *  @usecase def max: A
   *  @return   the largest element of this $coll. 
   */</span>
  <span class="keyword">def</span> <a title="[A1 &gt;: A](implicit ord: Ordering[A1])A" id="30872">max</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30874">A1</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Ordering[A1]" id="36609">ord</a>: <a href="../math/Ordering.scala.html#18894" title="Ordering[A1]">Ordering</a><span class="delimiter">[</span>A1<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#12277" title="A">A</a>
  
  <span class="keyword">def</span> <a title="[B](f: A =&gt; B)(implicit cmp: Ordering[B])A" id="30875">maxBy</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="30877">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="36590">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Ordering[B]" id="36591">cmp</a>: <a href="../math/Ordering.scala.html#18894" title="Ordering[B]">Ordering</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#12277" title="A">A</a>
  
  <span class="keyword">def</span> <a title="[B](f: A =&gt; B)(implicit cmp: Ordering[B])A" id="30878">minBy</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="30880">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="36571">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Ordering[B]" id="36572">cmp</a>: <a href="../math/Ordering.scala.html#18894" title="Ordering[B]">Ordering</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#12277" title="A">A</a>
  
  <span class="keyword">def</span> <a title="(pred: A =&gt; Boolean)Boolean" id="30881">forall</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="36336">pred</a>: A =&gt; Boolean<span class="delimiter">)</span>: <a href="../Boolean.scala.html#57" title="Boolean">Boolean</a>

  <span class="keyword">def</span> <a title="(pred: A =&gt; Boolean)Boolean" id="30882">exists</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="36324">pred</a>: A =&gt; Boolean<span class="delimiter">)</span>: <a href="../Boolean.scala.html#57" title="Boolean">Boolean</a>
  
  <span class="comment">/** Finds the first element of the $coll satisfying a predicate, if any.
   * 
   *  $mayNotTerminateInf
   *  $orderDependent
   *
   *  @param p    the predicate used to test elements.
   *  @return     an option value containing the first element in the $coll
   *              that satisfies `p`, or `None` if none exists.
   */</span>
  <span class="keyword">def</span> <a title="(pred: A =&gt; Boolean)Option[A]" id="30883">find</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="36312">pred</a>: A =&gt; Boolean<span class="delimiter">)</span>: <a href="../Option.scala.html#552" title="Option[A]">Option</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  
  <span class="comment">/** Copies values of this $coll to an array.
   *  Fills the given array `xs` with values of this $coll.
   *  Copying will stop once either the end of the current $coll is reached,
   *  or the end of the array is reached.
   *
   *  $willNotTerminateInf
   * 
   *  @param  xs     the array to fill.
   *  @tparam B      the type of the elements of the array. 
   * 
   *  @usecase def copyToArray(xs: Array[A]): Unit
   */</span>
  <span class="keyword">def</span> <a title="[B &gt;: A](xs: Array[B])Unit" id="30884">copyToArray</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30886">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[B]" id="35599">xs</a>: <a href="../Array.scala.html#1422" title="Array[B]">Array</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Unit.scala.html#453" title="Unit">Unit</a>
  
  <span class="comment">/** Copies values of this $coll to an array.
   *  Fills the given array `xs` with values of this $coll, beginning at index `start`.
   *  Copying will stop once either the end of the current $coll is reached,
   *  or the end of the array is reached.
   *
   *  $willNotTerminateInf
   * 
   *  @param  xs     the array to fill.
   *  @param  start  the starting index.
   *  @tparam B      the type of the elements of the array. 
   *
   *  @usecase def copyToArray(xs: Array[A], start: Int): Unit
   */</span>
  <span class="keyword">def</span> <a title="[B &gt;: A](xs: Array[B], start: Int)Unit" id="30887">copyToArray</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30889">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[B]" id="35589">xs</a>: <a href="../Array.scala.html#1422" title="Array[B]">Array</a><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a title="Int" id="35590">start</a>: <a href="../Int.scala.html#378" title="Int">Int</a><span class="delimiter">)</span>: <a href="../Unit.scala.html#453" title="Unit">Unit</a>
  
  <span class="keyword">def</span> <a title="[B &gt;: A](xs: Array[B], start: Int, len: Int)Unit" id="30890">copyToArray</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30892">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[B]" id="35576">xs</a>: <a href="../Array.scala.html#1422" title="Array[B]">Array</a><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a title="Int" id="35577">start</a>: <a href="../Int.scala.html#378" title="Int">Int</a>, <a title="Int" id="35578">len</a>: <a href="../Int.scala.html#378" title="Int">Int</a><span class="delimiter">)</span>: <a href="../Unit.scala.html#453" title="Unit">Unit</a>
  
  <span class="comment">/** Displays all elements of this $coll in a string using start, end, and
   *  separator strings.
   *
   *  @param start the starting string.
   *  @param sep   the separator string.
   *  @param end   the ending string.
   *  @return      a string representation of this $coll. The resulting string
   *               begins with the string `start` and ends with the string
   *               `end`. Inside, the string representations (w.r.t. the method
   *               `toString`) of all elements of this $coll are separated by
   *               the string `sep`.
   *
   *  @example  `List(1, 2, 3).mkString(&quot;(&quot;, &quot;; &quot;, &quot;)&quot;) = &quot;(1; 2; 3)&quot;`
   */</span>
  <span class="keyword">def</span> <a title="(start: String, sep: String, end: String)String" id="30893">mkString</a><span class="delimiter">(</span><a title="String" id="35745">start</a>: <span title="String">String</span>, <a title="String" id="35746">sep</a>: <span title="String">String</span>, <a title="String" id="35747">end</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span>
  
  <span class="comment">/** Displays all elements of this $coll in a string using a separator string.
   *
   *  @param sep   the separator string.
   *  @return      a string representation of this $coll. In the resulting string
   *               the string representations (w.r.t. the method `toString`)
   *               of all elements of this $coll are separated by the string `sep`.
   *
   *  @example  `List(1, 2, 3).mkString(&quot;|&quot;) = &quot;1|2|3&quot;`
   */</span>
  <span class="keyword">def</span> <a title="(sep: String)String" id="30894">mkString</a><span class="delimiter">(</span><a title="String" id="35743">sep</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span>
  
  <span class="comment">/** Displays all elements of this $coll in a string.
   *
   *  @return a string representation of this $coll. In the resulting string
   *          the string representations (w.r.t. the method `toString`)
   *          of all elements of this $coll follow each other without any
   *          separator string.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; String" id="30895">mkString</a>: <span title="String">String</span>
  
  <span class="comment">/** Converts this $coll to an array.
   *  $willNotTerminateInf
   * 
   *  @tparam B the type of the elements of the array. A `ClassManifest` for
   *            this type must be available.
   *  @return   an array containing all elements of this $coll.
   *
   *  @usecase def toArray: Array[A]
   *  @return  an array containing all elements of this $coll.
   *           A `ClassManifest` must be available for the element type of this $coll.
   */</span>
  <span class="keyword">def</span> <a title="[A1 &gt;: A](implicit evidence$1: ClassManifest[A1])Array[A1]" id="36531">toArray</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30898">A1</a> &gt;: A: ClassManifest<span class="delimiter">]</span>: <a href="../Array.scala.html#1422" title="Array[A1]">Array</a><span class="delimiter">[</span>A1<span class="delimiter">]</span>
  
  <span class="comment">/** Converts this $coll to a list.
   *  $willNotTerminateInf
   *  @return a list containing all elements of this $coll.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; List[A]" id="30899">toList</a>: <a href="immutable/List.scala.html#14021" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  
  <span class="comment">/** Converts this $coll to an indexed sequence.
   *  $willNotTerminateInf
   *  @return an indexed sequence containing all elements of this $coll.
   */</span>	
  <span class="keyword">def</span> <a title="[A1 &gt;: A]=&gt; scala.collection.immutable.IndexedSeq[A1]" id="30900">toIndexedSeq</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30902">A1</a> &gt;: A<span class="delimiter">]</span>: immutable.<a href="immutable/IndexedSeq.scala.html#14093" title="scala.collection.immutable.IndexedSeq[A1]">IndexedSeq</a><span class="delimiter">[</span>A1<span class="delimiter">]</span>
  
  <span class="comment">/** Converts this $coll to a stream.
   *  $willNotTerminateInf
   *  @return a stream containing all elements of this $coll.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; Stream[A]" id="30903">toStream</a>: <a href="immutable/Stream.scala.html#13223" title="Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  
  <span class="comment">/** Returns an Iterator over the elements in this $coll.  Will return
   *  the same Iterator if this instance is already an Iterator.
   *  $willNotTerminateInf
   *  @return an Iterator containing all elements of this $coll.
   */</span>	
  <span class="keyword">def</span> <a title="=&gt; Iterator[A]" id="30904">toIterator</a>: <a href="Iterator.scala.html#8756" title="Iterator[A]">Iterator</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  
  <span class="comment">/** Converts this $coll to a mutable buffer.
   *  $willNotTerminateInf
   *  @return a buffer containing all elements of this $coll.
   */</span>	
  <span class="keyword">def</span> <a title="[A1 &gt;: A]=&gt; scala.collection.mutable.Buffer[A1]" id="30905">toBuffer</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30907">A1</a> &gt;: A<span class="delimiter">]</span>: collection.mutable.<a href="mutable/Buffer.scala.html#14696" title="scala.collection.mutable.Buffer[A1]">Buffer</a><span class="delimiter">[</span>A1<span class="delimiter">]</span>
  
  <span class="comment">/** Converts this $coll to an unspecified Traversable.  Will return
   *  the same collection if this instance is already Traversable.
   *  $willNotTerminateInf
   *  @return a Traversable containing all elements of this $coll.
   */</span>	
  <span class="keyword">def</span> <a title="=&gt; scala.collection.GenTraversable[A]" id="30908">toTraversable</a>: <a href="GenTraversable.scala.html#8189" title="scala.collection.GenTraversable[A]">GenTraversable</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  
  <span class="comment">/** Converts this $coll to an iterable collection.  Note that
   *  the choice of target `Iterable` is lazy in this default implementation
   *  as this `TraversableOnce` may be lazy and unevaluated (i.e. it may
   *  be an iterator which is only traversable once).
   *
   *  $willNotTerminateInf 
   *  @return an `Iterable` containing all elements of this $coll.
   */</span>	
  <span class="keyword">def</span> <a title="=&gt; scala.collection.GenIterable[A]" id="30909">toIterable</a>: <a href="GenIterable.scala.html#8675" title="scala.collection.GenIterable[A]">GenIterable</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  
  <span class="comment">/** Converts this $coll to a sequence. As with `toIterable`, it's lazy
   *  in this default implementation, as this `TraversableOnce` may be
   *  lazy and unevaluated.
   *  
   *  $willNotTerminateInf
   *  @return a sequence containing all elements of this $coll.
   */</span>	
  <span class="keyword">def</span> <a title="=&gt; scala.collection.GenSeq[A]" id="30910">toSeq</a>: <a href="GenSeq.scala.html#8708" title="scala.collection.GenSeq[A]">GenSeq</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  
  <span class="comment">/** Converts this $coll to a set.
   *  $willNotTerminateInf
   *  @return      a set containing all elements of this $coll.
   */</span>
  <span class="keyword">def</span> <a title="[A1 &gt;: A]=&gt; scala.collection.GenSet[A1]" id="30911">toSet</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="30913">A1</a> &gt;: A<span class="delimiter">]</span>: <a href="GenSet.scala.html#7661" title="scala.collection.GenSet[A1]">GenSet</a><span class="delimiter">[</span>A1<span class="delimiter">]</span>
  
  <span class="comment">/** Converts this $coll to a map.  This method is unavailable unless
   *  the elements are members of Tuple2, each ((T, U)) becoming a key-value
   *  pair in the map.  Duplicate keys will be overwritten by later keys:
   *  if this is an unordered collection, which key is in the resulting map
   *  is undefined.
   *  $willNotTerminateInf
   *  @return    a map containing all elements of this $coll.
   *  @usecase   def toMap[T, U]: Map[T, U]
   *  @return    a map of type `immutable.Map[T, U]`
   *             containing all key/value pairs of type `(T, U)` of this $coll.
   */</span>
  <span class="keyword">def</span> <a title="[K, V](implicit ev: &lt;:&lt;[A,(K, V)])scala.collection.GenMap[K,V]" id="30914">toMap</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="30917">K</a>, <a title="&gt;: Nothing &lt;: Any" id="30918">V</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="&lt;:&lt;[A,(K, V)]" id="36355">ev</a>: A <a href="../Predef.scala.html#9660" title="&lt;:&lt;[A,(K, V)]">&lt;:&lt;</a> <span class="delimiter">(</span>K, V<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="GenMap.scala.html#8990" title="scala.collection.GenMap[K,V]">GenMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>