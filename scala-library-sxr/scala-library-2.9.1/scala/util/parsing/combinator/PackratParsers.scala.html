<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/util/parsing/combinator/PackratParsers.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2006-2011, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>


<span class="keyword">package</span> scala.util.parsing.combinator

<span class="keyword">import</span> scala.util.parsing.combinator._
<span class="keyword">import</span> scala.util.parsing.input.<span class="delimiter">{</span> Reader, Position <span class="delimiter">}</span>
<span class="keyword">import</span> scala.collection.mutable

<span class="comment">/**
 *  &lt;p&gt;
 *    &lt;code&gt;PackratParsers&lt;/code&gt; is a component that extends the parser combinators
 *    provided by &lt;a href=&quot;Parsers.html&quot;&gt;&lt;code&gt;Parsers&lt;/code&gt;&lt;/a&gt; with a memoization facility
 *    (``Packrat Parsing'').
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    Packrat Parsing is a technique for implementing backtracking, recursive-descent parsers, with the
 *    advantage that it guarantees unlimited lookahead and a linear parse time. Using this technique,
 *    left recursive grammars can also be accepted.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    Using &lt;code&gt;PackratParsers&lt;/code&gt; is very similar to using &lt;code&gt;Parsers&lt;/code&gt;:
 *  &lt;ul&gt;
 *    &lt;li&gt; any class/trait that extends &lt;code&gt;Parsers&lt;/code&gt; (directly or through a subclass) can
 *         mix in &lt;code&gt;PackratParsers&lt;/code&gt;. Example:
 *         &lt;code&gt;object MyGrammar extends StandardTokenParsers with PackratParsers &lt;/code&gt;
 *    &lt;li&gt; each grammar production previously declared as a &lt;code&gt;def&lt;/code&gt; without formal parameters
 *         becomes a &lt;code&gt;lazy val&lt;/code&gt;, and its type is changed from &lt;code&gt;Parser[Elem]&lt;/code&gt;
 *         to &lt;code&gt;PackratParser[Elem]&lt;/code&gt;. So, for example, &lt;code&gt;def production: Parser[Int] = {...}&lt;/code&gt; 
 *         becomes &lt;code&gt;lazy val production: PackratParser[Int] = {...}&lt;/code&gt;
 *    &lt;li&gt; Important: using &lt;code&gt;PackratParser&lt;/code&gt;s is not an ``all or nothing'' decision. They
 *         can be free mixed with regular &lt;code&gt;Parser&lt;/code&gt;s in a single grammar.
 *  &lt;/ul&gt;
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    Cached parse results are attached to the &lt;i&gt;input&lt;/i&gt;, not the grammar.
 *    Therefore, &lt;code&gt;PackratsParser&lt;/code&gt;s require a &lt;code&gt;PackratReader&lt;/code&gt; as input, which
 *    adds memoization to an underlying &lt;code&gt;Reader&lt;/code&gt;. Programmers can create &lt;code&gt;PackratReader&lt;/code&gt;
 *    objects either manually, as in &lt;code&gt;production(new PackratReader(new lexical.Scanner(&quot;input&quot;)))&lt;/code&gt;,
 *    but the common way should be to rely on the combinator &lt;code&gt;phrase&lt;/code&gt; to wrap a given
 *    input with a &lt;code&gt;PackratReader&lt;/code&gt; if the input is not one itself.
 *  &lt;/p&gt;
 *
 * @see Bryan Ford: &quot;Packrat Parsing: Simple, Powerful, Lazy, Linear Time.&quot; ICFP'02
 * @see Alessandro Warth, James R. Douglass, Todd Millstein: &quot;Packrat Parsers Can Support Left Recursion.&quot; PEPM'08
 *  
 * @since 2.8
 * @author Manohar Jonnalagedda, Tiark Rompf
 */</span>

<span class="keyword">trait</span> <a title="trait PackratParsers extends java.lang.Object with scala.util.parsing.combinator.Parsers with ScalaObject" id="22360">PackratParsers</a> <a href="../../../ScalaObject.scala.html#456" title="ScalaObject" class="keyword">extends</a> <a href="Parsers.scala.html#22402" title="scala.util.parsing.combinator.Parsers">Parsers</a> <span class="delimiter">{</span>
  
  <span class="comment">//type Input = PackratReader[Elem]</span>
  
  <span class="comment">/**
   * A specialized &lt;code&gt;Reader&lt;/code&gt; class that wraps an underlying &lt;code&gt;Reader&lt;/code&gt;
   * and provides memoization of parse results.
   */</span>
  <span class="keyword">class</span> <a title="class PackratReader[+T] extends scala.util.parsing.input.Reader[T] with ScalaObject" id="460706">PackratReader</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="460707">T</a><span class="delimiter">]</span><a href="../../../ScalaObject.scala.html#456" title="ScalaObject" class="delimiter">(</a><a title="scala.util.parsing.input.Reader[T]" id="460982">underlying</a>: <a href="../input/Reader.scala.html#22947" title="scala.util.parsing.input.Reader[T]">Reader</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="../input/Reader.scala.html#22947" title="scala.util.parsing.input.Reader[T]">Reader</a><span class="delimiter">[</span>T<span class="delimiter">]</span>  <span class="delimiter">{</span> outer =&gt;
    
    <span class="comment">/*
     * caching of intermediate parse results and information about recursion
     */</span>
     
    <span class="keyword">private</span><span class="delimiter">[</span>PackratParsers<span class="delimiter">]</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[(PackratParsers.this.Parser[_], scala.util.parsing.input.Position),PackratParsers.this.MemoEntry[_]]" id="460744">cache</a> = mutable.<a href="../../../collection/mutable/HashMap.scala.html#14880" title="object scala.collection.mutable.HashMap">HashMap</a>.<a href="../../../collection/mutable/HashMap.scala.html#120266" title="[A, B]=&gt; scala.collection.mutable.HashMap[A,B]">empty</a><span title="scala.collection.mutable.HashMap[(PackratParsers.this.Parser[_], scala.util.parsing.input.Position),PackratParsers.this.MemoEntry[_]]" class="delimiter">[</span><a href="../../../Tuple2.scala.html#1512" title="(PackratParsers.this.Parser[_], scala.util.parsing.input.Position)" class="delimiter">(</a>Parser<span class="delimiter">[</span>_<span class="delimiter">]</span>, Position<span class="delimiter">)</span>, <a href="#461751" title="PackratParsers.this.MemoEntry[_]">MemoEntry</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>

    <span class="keyword">private</span><span class="delimiter">[</span>PackratParsers<span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](p: PackratParsers.this.Parser[T])Option[PackratParsers.this.MemoEntry[T]]" id="460746">getFromCache</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460748">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PackratParsers.this.Parser[T]" id="460983">p</a>: <a href="Parsers.scala.html#460325" title="PackratParsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../Option.scala.html#552" title="Option[PackratParsers.this.MemoEntry[T]]">Option</a><span class="delimiter">[</span>MemoEntry<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="#460744" title="=&gt; scala.collection.mutable.HashMap[(PackratParsers.this.Parser[_], scala.util.parsing.input.Position),PackratParsers.this.MemoEntry[_]]">cache</a>.<a href="../../../collection/mutable/HashMap.scala.html#50489" title="(key: (PackratParsers.this.Parser[_], scala.util.parsing.input.Position))Option[PackratParsers.this.MemoEntry[_]]">get</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#30706" title="(_1: PackratParsers.this.Parser[T], _2: scala.util.parsing.input.Position)(PackratParsers.this.Parser[T], scala.util.parsing.input.Position)" class="delimiter">(</a><a href="#460983" title="PackratParsers.this.Parser[T]">p</a>, <a href="#460761" title="=&gt; scala.util.parsing.input.Position">pos</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Option[PackratParsers.this.MemoEntry[T]]" class="delimiter">[</span><a href="../../../Option.scala.html#552" title="Option[PackratParsers.this.MemoEntry[T]]">Option</a><span class="delimiter">[</span>MemoEntry<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
    <span class="delimiter">}</span>
    
    <span class="keyword">private</span><span class="delimiter">[</span>PackratParsers<span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](p: PackratParsers.this.Parser[T], w: PackratParsers.this.MemoEntry[T])PackratParsers.this.MemoEntry[T]" id="460749">updateCacheAndGet</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460751">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PackratParsers.this.Parser[T]" id="461043">p</a>: <a href="Parsers.scala.html#460325" title="PackratParsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="PackratParsers.this.MemoEntry[T]" id="461044">w</a>: <a href="#461751" title="PackratParsers.this.MemoEntry[T]">MemoEntry</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#461751" title="PackratParsers.this.MemoEntry[T]">MemoEntry</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="#460744" title="=&gt; scala.collection.mutable.HashMap[(PackratParsers.this.Parser[_], scala.util.parsing.input.Position),PackratParsers.this.MemoEntry[_]]">cache</a>.<a href="../../../collection/mutable/HashMap.scala.html#50490" title="(key: (PackratParsers.this.Parser[_], scala.util.parsing.input.Position), value: PackratParsers.this.MemoEntry[_])Option[PackratParsers.this.MemoEntry[_]]">put</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#30706" title="(_1: PackratParsers.this.Parser[T], _2: scala.util.parsing.input.Position)(PackratParsers.this.Parser[T], scala.util.parsing.input.Position)" class="delimiter">(</a><a href="#461043" title="PackratParsers.this.Parser[T]">p</a>, <a href="#460761" title="=&gt; scala.util.parsing.input.Position">pos</a><span class="delimiter">)</span>,<a href="#461044" title="PackratParsers.this.MemoEntry[T]">w</a><span class="delimiter">)</span>
      <a href="#461044" title="PackratParsers.this.MemoEntry[T]">w</a>
    <span class="delimiter">}</span>

    <span class="comment">/* a cache for storing parser heads: allows to know which parser is involved
       in a recursion*/</span>
    <span class="keyword">private</span><span class="delimiter">[</span>PackratParsers<span class="delimiter">]</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]" id="460752">recursionHeads</a>: mutable.<a href="../../../collection/mutable/HashMap.scala.html#14879" title="scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]">HashMap</a><span class="delimiter">[</span>Position, Head<span class="delimiter">]</span> = mutable.<a href="../../../collection/mutable/HashMap.scala.html#14880" title="object scala.collection.mutable.HashMap">HashMap</a>.<a href="../../../collection/mutable/HashMap.scala.html#120266" title="scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]">empty</a>

    <span class="comment">//a stack that keeps a list of all involved rules</span>
    <span class="keyword">private</span><span class="delimiter">[</span>PackratParsers<span class="delimiter">]</span> <span class="keyword">var</span> <a title="List[PackratParsers.this.LR]" id="460755">lrStack</a>: <a href="../../../collection/immutable/List.scala.html#14021" title="List[PackratParsers.this.LR]">List</a><span class="delimiter">[</span>LR<span class="delimiter">]</span> = <a href="../../../collection/immutable/List.scala.html#13674" title="object Nil">Nil</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.CharSequence" id="460757">source</a>: java.lang.<span title="java.lang.CharSequence">CharSequence</span> = <a href="#460982" title="scala.util.parsing.input.Reader[T]">underlying</a>.<a href="../input/Reader.scala.html#460603" title="=&gt; java.lang.CharSequence">source</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="460758">offset</a>: <a href="../../../Int.scala.html#378" title="Int">Int</a> = <a href="#460982" title="scala.util.parsing.input.Reader[T]">underlying</a>.<a href="../input/Reader.scala.html#460604" title="=&gt; Int">offset</a>

    <span class="keyword">def</span> <a title="=&gt; T" id="460759">first</a>: <a href="#460707" title="T">T</a> = <a href="#460982" title="scala.util.parsing.input.Reader[T]">underlying</a>.<a href="../input/Reader.scala.html#460605" title="=&gt; T">first</a>
    <span class="keyword">def</span> <a title="=&gt; scala.util.parsing.input.Reader[T]" id="460760">rest</a>: <a href="../input/Reader.scala.html#22947" title="scala.util.parsing.input.Reader[T]">Reader</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#461150" title="PackratParsers.this.PackratReader[T]{}" class="keyword">new</a> <a title="anonymous class $anon extends PackratParsers.this.PackratReader[T]" id="461150">PackratReader</a><span class="delimiter">(</span><a href="#460982" title="scala.util.parsing.input.Reader[T]">underlying</a>.<a href="../input/Reader.scala.html#460606" title="=&gt; scala.util.parsing.input.Reader[T]">rest</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">private</span><span class="delimiter">[</span>PackratParsers<span class="delimiter">]</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[(PackratParsers.this.Parser[_], scala.util.parsing.input.Position),PackratParsers.this.MemoEntry[_]]" id="461157">cache</a> = <a href="#460706" title="PackratReader.this.type">outer</a>.<a href="#460744" title="=&gt; scala.collection.mutable.HashMap[(PackratParsers.this.Parser[_], scala.util.parsing.input.Position),PackratParsers.this.MemoEntry[_]]">cache</a>
      <span class="keyword">override</span> <span class="keyword">private</span><span class="delimiter">[</span>PackratParsers<span class="delimiter">]</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]" id="461159">recursionHeads</a> = <a href="#460706" title="PackratReader.this.type">outer</a>.<a href="#460752" title="=&gt; scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]">recursionHeads</a>
      <a href="#460755" title="(x$1: List[PackratParsers.this.LR])Unit">lrStack</a> = <a href="#460706" title="PackratReader.this.type">outer</a>.<a href="#460755" title="=&gt; List[PackratParsers.this.LR]">lrStack</a>
    <span class="delimiter">}</span>
  
    <span class="keyword">def</span> <a title="=&gt; scala.util.parsing.input.Position" id="460761">pos</a>: <a href="../input/Position.scala.html#22923" title="scala.util.parsing.input.Position">Position</a> = <a href="#460982" title="scala.util.parsing.input.Reader[T]">underlying</a>.<a href="../input/Reader.scala.html#460608" title="=&gt; scala.util.parsing.input.Position">pos</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="460762">atEnd</a>: <a href="../../../Boolean.scala.html#57" title="Boolean">Boolean</a> = <a href="#460982" title="scala.util.parsing.input.Reader[T]">underlying</a>.<a href="../input/Reader.scala.html#460609" title="=&gt; Boolean">atEnd</a>
  <span class="delimiter">}</span>

  
  <span class="comment">/**
   *  &lt;p&gt;
   *    A parser generator delimiting whole phrases (i.e. programs).
   *  &lt;/p&gt;
   *  &lt;p&gt;
   *    Overridden to make sure any input passed to the argument parser
   *    is wrapped in a &lt;code&gt;PackratReader&lt;/code&gt;.
   *  &lt;/p&gt;
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="[T](p: PackratParsers.this.Parser[T])PackratParsers.this.PackratParser[T]" id="460708">phrase</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460710">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PackratParsers.this.Parser[T]" id="461232">p</a>: <a href="Parsers.scala.html#460325" title="PackratParsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="PackratParsers.this.Parser[T]" id="461428">q</a> = <a href="#22360" title="scala.util.parsing.combinator.PackratParsers" class="keyword">super</a>.<a href="Parsers.scala.html#460397" title="(p: PackratParsers.this.Parser[T])PackratParsers.this.Parser[T]">phrase</a><span class="delimiter">(</span><a href="#461232" title="PackratParsers.this.Parser[T]">p</a><span class="delimiter">)</span>
    <a href="#461434" title="PackratParsers.this.PackratParser[T]" class="keyword">new</a> <a title="anonymous class $anon extends PackratParsers.this.PackratParser[T]" id="461434">PackratParser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(in: PackratParsers.this.Input)PackratParsers.this.ParseResult[T]" id="461444">apply</a><span class="delimiter">(</span><a title="PackratParsers.this.Input" id="461445">in</a>: <a href="../input/Reader.scala.html#22947" title="PackratParsers.this.Input">Input</a><span class="delimiter">)</span> = <a href="#461445" title="PackratParsers.this.Input">in</a> <span title="PackratParsers.this.ParseResult[T]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="PackratParsers.this.ParseResult[T]" id="461454">in</a>: <a href="#460706" title="PackratParsers.this.PackratReader[_]">PackratReader</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="Parsers.scala.html#460616" title="(in: PackratParsers.this.Input)PackratParsers.this.ParseResult[T]">q</a><span class="delimiter">(</span><a href="#461454" title="PackratParsers.this.PackratReader[_]">in</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <a title="PackratParsers.this.ParseResult[T]" id="461467">in</a> =&gt; <a href="Parsers.scala.html#460616" title="(in: PackratParsers.this.Input)PackratParsers.this.ParseResult[T]">q</a><span class="delimiter">(</span><span title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]" class="keyword">new</span> <a href="#460706" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">PackratReader</a><span class="delimiter">(</span><a href="#461467" title="PackratParsers.this.Input">in</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(r: PackratParsers.this.ParseResult[_])scala.util.parsing.input.Position" id="460711">getPosFromResult</a><span class="delimiter">(</span><a title="PackratParsers.this.ParseResult[_]" id="461499">r</a>: <a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[_]">ParseResult</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../input/Position.scala.html#22923" title="scala.util.parsing.input.Position">Position</a> = <a href="#461499" title="PackratParsers.this.ParseResult[_]">r</a>.<a href="Parsers.scala.html#461279" title="=&gt; PackratParsers.this.Input">next</a>.<a href="../input/Reader.scala.html#460608" title="=&gt; scala.util.parsing.input.Position">pos</a>
 
  <span class="comment">// auxiliary data structures</span>
 
  <span class="keyword">private</span> case <span class="keyword">class</span> <a title="class MemoEntry[+T] extends java.lang.Object with ScalaObject with Product with Serializable" id="461751">MemoEntry</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="461753">T</a><span class="delimiter">]</span><a href="../../../ScalaObject.scala.html#456" title="ScalaObject" class="delimiter">(</a><span class="keyword">var</span> <a title="Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]]" id="462287">r</a>: <a href="../../../Either.scala.html#2076" title="Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]]">Either</a><span class="delimiter">[</span>LR,ParseResult<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; PackratParsers.this.ParseResult[T]" id="460775">getResult</a>: <a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#462287" title="=&gt; Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]]">r</a> <span title="PackratParsers.this.ParseResult[T]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="PackratParsers.this.ParseResult[T]">Left</span><span class="delimiter">(</span>LR<span class="delimiter">(</span><a title="PackratParsers.this.ParseResult[Any]" id="461652">res</a>,_,_<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#461652" title="PackratParsers.this.ParseResult[Any]">res</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="PackratParsers.this.ParseResult[T]" class="delimiter">[</span><a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
      <span class="keyword">case</span> <span title="PackratParsers.this.ParseResult[T]">Right</span><span class="delimiter">(</span><a title="PackratParsers.this.ParseResult[Any]" id="461662">res</a><span class="delimiter">)</span> =&gt; <a href="#461662" title="PackratParsers.this.ParseResult[Any]">res</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="PackratParsers.this.ParseResult[T]" class="delimiter">[</span><a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">private</span> case <span class="keyword">class</span> <a title="class LR extends java.lang.Object with ScalaObject with Product with Serializable" id="461620">LR</a><a href="../../../ScalaObject.scala.html#456" title="ScalaObject" class="delimiter">(</a><span class="keyword">var</span> <a title="PackratParsers.this.ParseResult[_]" id="462684">seed</a>: <a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[_]">ParseResult</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <span class="keyword">var</span> <a title="PackratParsers.this.Parser[_]" id="462685">rule</a>: <a href="Parsers.scala.html#460325" title="PackratParsers.this.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <span class="keyword">var</span> <a title="Option[PackratParsers.this.Head]" id="462686">head</a>: <a href="../../../Option.scala.html#552" title="Option[PackratParsers.this.Head]">Option</a><span class="delimiter">[</span>Head<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; scala.util.parsing.input.Position" id="460898">getPos</a>: <a href="../input/Position.scala.html#22923" title="scala.util.parsing.input.Position">Position</a> = <a href="#460711" title="(r: PackratParsers.this.ParseResult[_])scala.util.parsing.input.Position">getPosFromResult</a><span class="delimiter">(</span><a href="#462684" title="=&gt; PackratParsers.this.ParseResult[_]">seed</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">private</span> case <span class="keyword">class</span> <a title="class Head extends java.lang.Object with ScalaObject with Product with Serializable" id="462091">Head</a><a href="../../../ScalaObject.scala.html#456" title="ScalaObject" class="delimiter">(</a><span class="keyword">var</span> <a title="PackratParsers.this.Parser[_]" id="462407">headParser</a>: <a href="Parsers.scala.html#460325" title="PackratParsers.this.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <span class="keyword">var</span> <a title="List[PackratParsers.this.Parser[_]]" id="462408">involvedSet</a>: <a href="../../../collection/immutable/List.scala.html#14021" title="List[PackratParsers.this.Parser[_]]">List</a><span class="delimiter">[</span>Parser<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>, <span class="keyword">var</span> <a title="List[PackratParsers.this.Parser[_]]" id="462409">evalSet</a>: <a href="../../../collection/immutable/List.scala.html#14021" title="List[PackratParsers.this.Parser[_]]">List</a><span class="delimiter">[</span>Parser<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; PackratParsers.this.Parser[Any]" id="460832">getHead</a> = <a href="#462407" title="=&gt; PackratParsers.this.Parser[_]">headParser</a>
  <span class="delimiter">}</span>
  
  <span class="comment">/** 
   * The root class of packrat parsers. 
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class PackratParser[+T] extends PackratParsers.this.Parser[T] with ScalaObject" id="460722">PackratParser</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="460723">T</a><span class="delimiter">]</span> <a href="../../../ScalaObject.scala.html#456" title="ScalaObject" class="keyword">extends</a> <span class="keyword">super</span>.<a href="Parsers.scala.html#460325" title="PackratParsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
  
  <span class="comment">/**
   * Implicitly convert a parser to a packrat parser.
   * The conversion is triggered by giving the appropriate target type: 
   * val myParser: PackratParser[MyResult] = aParser
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](p: =&gt; PackratParsers.this.Parser[T])PackratParsers.this.PackratParser[T]" id="460724">parser2packrat</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460726">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; PackratParsers.this.Parser[T]" id="462162">p</a>: =&gt; <span class="keyword">super</span>.Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460722" title="PackratParsers.this.PackratParser[T]">PackratParser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="PackratParsers.this.Parser[T]" id="462167">q</a> = <a href="#462162" title="=&gt; PackratParsers.this.Parser[T]">p</a>
    <a href="#460732" title="(p: PackratParsers.this.Parser[T])PackratParsers.this.PackratParser[T]">memo</a><span class="delimiter">(</span><a href="#22360" title="scala.util.parsing.combinator.PackratParsers" class="keyword">super</a>.<a href="Parsers.scala.html#460319" title="(f: PackratParsers.this.Input =&gt; PackratParsers.this.ParseResult[T])PackratParsers.this.Parser[T]">Parser</a> <span class="delimiter">{</span><a title="PackratParsers.this.Input" id="462182">in</a> =&gt; <a href="Parsers.scala.html#460616" title="(in: PackratParsers.this.Input)PackratParsers.this.ParseResult[T]">q</a><span class="delimiter">(</span><a href="#462182" title="PackratParsers.this.Input">in</a><span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>


  <span class="comment">/*
   * An unspecified function that is called when a packrat reader is applied.
   * It verifies whether we are in the process of growing a parse or not. 
   * In the former case, it makes sure that rules involved in the recursion are evaluated. 
   * It also prevents non-involved rules from getting evaluated further
   */</span>
  
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(p: PackratParsers.this.Parser[_], in: PackratParsers.this.PackratReader[PackratParsers.this.Elem])Option[PackratParsers.this.MemoEntry[_]]" id="460727">recall</a><span class="delimiter">(</span><a title="PackratParsers.this.Parser[_]" id="462196">p</a>: <span class="keyword">super</span>.<a href="Parsers.scala.html#460325" title="PackratParsers.this.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]" id="462197">in</a>: <a href="#460706" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">PackratReader</a><span class="delimiter">[</span>Elem<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../Option.scala.html#552" title="Option[PackratParsers.this.MemoEntry[_]]">Option</a><span class="delimiter">[</span>MemoEntry<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Option[PackratParsers.this.MemoEntry[Any]]" id="462248">cached</a> = <a href="#462197" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">in</a>.<a href="#460746" title="(p: PackratParsers.this.Parser[_$10])Option[PackratParsers.this.MemoEntry[_$10]]">getFromCache</a><span class="delimiter">(</span><a href="#462196" title="PackratParsers.this.Parser[_]">p</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Option[PackratParsers.this.Head]" id="462249">head</a> = <a href="#462197" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">in</a>.<a href="#460752" title="=&gt; scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]">recursionHeads</a>.<a href="../../../collection/mutable/HashMap.scala.html#50489" title="(key: scala.util.parsing.input.Position)Option[PackratParsers.this.Head]">get</a><span class="delimiter">(</span><a href="#462197" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">in</a>.<a href="#460761" title="=&gt; scala.util.parsing.input.Position">pos</a><span class="delimiter">)</span>
    
    <a href="#462249" title="Option[PackratParsers.this.Head]">head</a> <span title="Option[PackratParsers.this.MemoEntry[_]]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="../../../Option.scala.html#1729" title="Option[PackratParsers.this.MemoEntry[Any]]">None</a> =&gt; <span class="comment">/*no heads*/</span> <a href="#462248" title="Option[PackratParsers.this.MemoEntry[Any]]">cached</a>
      <span class="keyword">case</span> <span title="Option[PackratParsers.this.MemoEntry[Any]]">Some</span><span class="delimiter">(</span><a title="PackratParsers.this.Head" id="462260">h</a>@Head<span class="delimiter">(</span><a title="PackratParsers.this.Parser[Any]" id="462261">hp</a>, <a title="List[PackratParsers.this.Parser[_]]" id="462267">involved</a>, <a title="List[PackratParsers.this.Parser[_]]" id="462268">evalSet</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
        <span class="comment">//heads found</span>
        <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#462248" title="Option[PackratParsers.this.MemoEntry[Any]]">cached</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../Option.scala.html#1729" title="object None">None</a> <a href="../../../Boolean.scala.html#32896" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../Boolean.scala.html#32892" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#462261" title="PackratParsers.this.Parser[Any]">hp</a><a href="../../../collection/immutable/List.scala.html#26456" title="(x: PackratParsers.this.Parser[_])List[PackratParsers.this.Parser[_]]">::</a><a href="#462267" title="List[PackratParsers.this.Parser[_]]">involved</a> <a href="../../../collection/SeqLike.scala.html#31435" title="(elem: Any)Boolean">contains</a> <a href="#462196" title="PackratParsers.this.Parser[_]">p</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="comment">//Nothing in the cache, and p is not involved</span>
          <span title="Nothing" class="keyword">return</span> <a href="../../../Option.scala.html#35203" title="(x: PackratParsers.this.MemoEntry[Nothing])Some[PackratParsers.this.MemoEntry[Nothing]]">Some</a><span class="delimiter">(</span><a href="#461751" title="(r: Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]])PackratParsers.this.MemoEntry[Nothing]">MemoEntry</a><span class="delimiter">(</span><a href="../../../Either.scala.html#49290" title="(b: PackratParsers.this.Failure)Right[Nothing,PackratParsers.this.Failure]">Right</a><span class="delimiter">(</span><a href="Parsers.scala.html#461387" title="(msg: String, next: PackratParsers.this.Input)PackratParsers.this.Failure">Failure</a><span class="delimiter">(</span><span title="java.lang.String(&quot;dummy &quot;)" class="string">&quot;dummy &quot;</span>,<a href="#462197" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">in</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#462268" title="List[PackratParsers.this.Parser[_]]">evalSet</a> <a href="../../../collection/SeqLike.scala.html#31435" title="(elem: Any)Boolean">contains</a> <a href="#462196" title="PackratParsers.this.Parser[_]">p</a><span class="delimiter">)</span><span class="delimiter">{</span>
          <span class="comment">//something in cache, and p is in the evalSet</span>
          <span class="comment">//remove the rule from the evalSet of the Head</span>
          <a href="#462260" title="PackratParsers.this.Head">h</a>.<a href="#462409" title="(x$1: List[PackratParsers.this.Parser[_]])Unit">evalSet</a> = <a href="#462260" title="PackratParsers.this.Head">h</a>.<a href="#462409" title="=&gt; List[PackratParsers.this.Parser[_]]">evalSet</a>.<a href="../../../collection/TraversableLike.scala.html#26368" title="(p: PackratParsers.this.Parser[_] =&gt; Boolean)List[PackratParsers.this.Parser[_]]">filterNot</a><span class="delimiter">(</span><a href="#462323" title="PackratParsers.this.Parser[_]">_</a><span title="(x$1: AnyRef)Boolean">==</span><a href="#462196" title="PackratParsers.this.Parser[_]">p</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="PackratParsers.this.ParseResult[Any]" id="462312">tempRes</a> = <a href="Parsers.scala.html#460616" title="(in: scala.util.parsing.input.Reader[PackratParsers.this.Elem])PackratParsers.this.ParseResult[Any]">p</a><span class="delimiter">(</span><a href="#462197" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">in</a><span class="delimiter">)</span>
          <span class="comment">//we know that cached has an entry here</span>
          <span class="keyword">val</span> <a title="PackratParsers.this.MemoEntry[_]" id="462313">tempEntry</a>: <a href="#461751" title="PackratParsers.this.MemoEntry[_]">MemoEntry</a><span class="delimiter">[</span>_<span class="delimiter">]</span> = <a href="#462248" title="Option[PackratParsers.this.MemoEntry[Any]]">cached</a>.<a href="../../../Option.scala.html#25789" title="=&gt; PackratParsers.this.MemoEntry[Any]">get</a> <span class="comment">// match {case Some(x: MemoEntry[_]) =&gt; x}</span>
          <span class="comment">//cache is modified</span>
          <a href="#462313" title="PackratParsers.this.MemoEntry[_]">tempEntry</a>.<a href="#462287" title="(x$1: Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]])Unit">r</a> = <a href="../../../Either.scala.html#49290" title="(b: PackratParsers.this.ParseResult[Any])Right[Nothing,PackratParsers.this.ParseResult[Any]]">Right</a><span class="delimiter">(</span><a href="#462312" title="PackratParsers.this.ParseResult[Any]">tempRes</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#462248" title="Option[PackratParsers.this.MemoEntry[Any]]">cached</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/*
   * setting up the left-recursion. We have the LR for the rule head
   * we modify the involvedSets of all LRs in the stack, till we see
   * the current parser again
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(p: PackratParsers.this.Parser[_], in: PackratParsers.this.PackratReader[_], recDetect: PackratParsers.this.LR)Unit" id="460728">setupLR</a><span class="delimiter">(</span><a title="PackratParsers.this.Parser[_]" id="462357">p</a>: <a href="Parsers.scala.html#460325" title="PackratParsers.this.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="PackratParsers.this.PackratReader[_]" id="462358">in</a>: <a href="#460706" title="PackratParsers.this.PackratReader[_]">PackratReader</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="PackratParsers.this.LR" id="462359">recDetect</a>: <a href="#461620" title="PackratParsers.this.LR">LR</a><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#453" title="Unit">Unit</a> = <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#462359" title="PackratParsers.this.LR">recDetect</a>.<a href="#462686" title="=&gt; Option[PackratParsers.this.Head]">head</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../Option.scala.html#1729" title="object None">None</a><span class="delimiter">)</span> <a href="#462359" title="PackratParsers.this.LR">recDetect</a>.<a href="#462686" title="(x$1: Option[PackratParsers.this.Head])Unit">head</a> = <a href="../../../Option.scala.html#35203" title="(x: PackratParsers.this.Head)Some[PackratParsers.this.Head]">Some</a><span class="delimiter">(</span><a href="#462091" title="(headParser: PackratParsers.this.Parser[_], involvedSet: List[PackratParsers.this.Parser[_]], evalSet: List[PackratParsers.this.Parser[_]])PackratParsers.this.Head">Head</a><span class="delimiter">(</span><a href="#462357" title="PackratParsers.this.Parser[_]">p</a>, <a href="../../../collection/immutable/List.scala.html#13674" title="object Nil">Nil</a>, <a href="../../../collection/immutable/List.scala.html#13674" title="object Nil">Nil</a><span class="delimiter">)</span><span class="delimiter">)</span>
    
    <a href="#462358" title="PackratParsers.this.PackratReader[_]">in</a>.<a href="#460755" title="=&gt; List[PackratParsers.this.LR]">lrStack</a>.<a href="../../../collection/immutable/List.scala.html#26484" title="(p: PackratParsers.this.LR =&gt; Boolean)List[PackratParsers.this.LR]">takeWhile</a><span class="delimiter">(</span><a href="#462440" title="PackratParsers.this.LR">_</a>.<a href="#462685" title="=&gt; PackratParsers.this.Parser[_]">rule</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#462357" title="PackratParsers.this.Parser[_]">p</a><span class="delimiter">)</span>.<a href="../../../collection/LinearSeqOptimized.scala.html#48364" title="(f: PackratParsers.this.LR =&gt; Option[Unit])Unit">foreach</a> <span class="delimiter">{</span><a title="PackratParsers.this.LR" id="462469">x</a> =&gt;
      <a href="#462469" title="PackratParsers.this.LR">x</a>.<a href="#462686" title="(x$1: Option[PackratParsers.this.Head])Unit">head</a> = <a href="#462359" title="PackratParsers.this.LR">recDetect</a>.<a href="#462686" title="=&gt; Option[PackratParsers.this.Head]">head</a>
      <a href="#462359" title="PackratParsers.this.LR">recDetect</a>.<a href="#462686" title="=&gt; Option[PackratParsers.this.Head]">head</a>.<a href="../../../Option.scala.html#25796" title="(f: PackratParsers.this.Head =&gt; Unit)Option[Unit]">map</a><span class="delimiter">(</span><a title="PackratParsers.this.Head" id="462474">h</a> =&gt; <a href="#462474" title="PackratParsers.this.Head">h</a>.<a href="#462408" title="(x$1: List[PackratParsers.this.Parser[_]])Unit">involvedSet</a> = <a href="#462469" title="PackratParsers.this.LR">x</a>.<a href="#462685" title="=&gt; PackratParsers.this.Parser[_]">rule</a><a href="../../../collection/immutable/List.scala.html#26456" title="(x: PackratParsers.this.Parser[_])List[PackratParsers.this.Parser[_]]">::</a><a href="#462474" title="PackratParsers.this.Head">h</a>.<a href="#462408" title="=&gt; List[PackratParsers.this.Parser[_]]">involvedSet</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/*
   * growing, if needed the recursion
   * check whether the parser we are growing is the head of the rule.
   * Not =&gt; no grow
   */</span>
   
  <span class="comment">/*
   * Once the result of the recall function is known, if it is nil, then we need to store a dummy
failure into the cache (much like in the previous listings) and compute the future parse. If it
is not, however, this means we have detected a recursion, and we use the setupLR function
to update each parser involved in the recursion.
   */</span>
  
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T](p: PackratParsers.this.Parser[T], in: PackratParsers.this.PackratReader[PackratParsers.this.Elem], growable: PackratParsers.this.LR)PackratParsers.this.ParseResult[T]" id="460729">lrAnswer</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460731">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PackratParsers.this.Parser[T]" id="462496">p</a>: <a href="Parsers.scala.html#460325" title="PackratParsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]" id="462497">in</a>: <a href="#460706" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">PackratReader</a><span class="delimiter">[</span>Elem<span class="delimiter">]</span>, <a title="PackratParsers.this.LR" id="462498">growable</a>: <a href="#461620" title="PackratParsers.this.LR">LR</a><span class="delimiter">)</span>: <a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#462498" title="PackratParsers.this.LR">growable</a> <span title="PackratParsers.this.ParseResult[T]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="comment">//growable will always be having a head, we can't enter lrAnswer otherwise</span>
    <span class="keyword">case</span> <span title="PackratParsers.this.ParseResult[T]">LR</span><span class="delimiter">(</span><a title="PackratParsers.this.ParseResult[Any]" id="462536">seed</a> ,<a title="PackratParsers.this.Parser[Any]" id="462542">rule</a>, Some<span class="delimiter">(</span><a title="PackratParsers.this.Head" id="462549">head</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; 
      <span title="PackratParsers.this.ParseResult[T]" class="keyword">if</span><span class="delimiter">(</span><a href="#462549" title="PackratParsers.this.Head">head</a>.<a href="#460832" title="=&gt; PackratParsers.this.Parser[Any]">getHead</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#462496" title="PackratParsers.this.Parser[T]">p</a><span class="delimiter">)</span> <span class="comment">/*not head rule, so not growing*/</span> <a href="#462536" title="PackratParsers.this.ParseResult[Any]">seed</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="PackratParsers.this.ParseResult[T]" class="delimiter">[</span><a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#462497" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">in</a>.<a href="#460749" title="(p: PackratParsers.this.Parser[T], w: PackratParsers.this.MemoEntry[T])PackratParsers.this.MemoEntry[T]">updateCacheAndGet</a><span class="delimiter">(</span><a href="#462496" title="PackratParsers.this.Parser[T]">p</a>, <a href="#461751" title="(r: Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]])PackratParsers.this.MemoEntry[Nothing]">MemoEntry</a><span class="delimiter">(</span><a href="../../../Either.scala.html#49290" title="[A, B](b: B)Right[A,B]">Right</a><span title="(b: PackratParsers.this.ParseResult[T])Right[PackratParsers.this.LR,PackratParsers.this.ParseResult[T]]" class="delimiter">[</span><a href="#461620" title="PackratParsers.this.LR">LR</a>, <a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#462536" title="PackratParsers.this.ParseResult[Any]">seed</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="PackratParsers.this.ParseResult[T]" class="delimiter">[</span><a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#462536" title="PackratParsers.this.ParseResult[Any]">seed</a> <span title="PackratParsers.this.ParseResult[T]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="PackratParsers.this.Failure" id="462566">f</a>@Failure<span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt; <a href="#462566" title="PackratParsers.this.Failure">f</a>
          <span class="keyword">case</span> <a title="PackratParsers.this.Error" id="462594">e</a>@Error<span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt; <a href="#462594" title="PackratParsers.this.Error">e</a>
          <span class="keyword">case</span> <a title="PackratParsers.this.ParseResult[T]" id="462638">s</a>@Success<span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt; <span class="comment">/*growing*/</span> <a href="#460735" title="(p: PackratParsers.this.Parser[T], rest: PackratParsers.this.PackratReader[PackratParsers.this.Elem], head: PackratParsers.this.Head)PackratParsers.this.ParseResult[T]">grow</a><span class="delimiter">(</span><a href="#462496" title="PackratParsers.this.Parser[T]">p</a>, <a href="#462497" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">in</a>, <a href="#462549" title="PackratParsers.this.Head">head</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> <span title="Nothing">_</span>=&gt; <span title="Nothing" class="keyword">throw</span> <span title="(x$1: java.lang.String)java.lang.Exception" class="keyword">new</span> <a href="../../../package.scala.html#24942" title="java.lang.Exception">Exception</a><span class="delimiter">(</span><span title="java.lang.String(&quot;lrAnswer with no head !!&quot;)" class="string">&quot;lrAnswer with no head !!&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">//p here should be strict (cannot be non-strict) !!</span>
  <span class="comment">//failing left-recursive grammars: This is done by simply storing a failure if nothing is found</span>

  <span class="comment">/** 
   * Explicitly convert a given parser to a memoizing packrat parser.
   * In most cases, client code should avoid calling &lt;code&gt;memo&lt;/code&gt; directly
   * and rely on implicit conversion instead.
   */</span>
  <span class="keyword">def</span> <a title="[T](p: PackratParsers.this.Parser[T])PackratParsers.this.PackratParser[T]" id="460732">memo</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460734">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PackratParsers.this.Parser[T]" id="462168">p</a>: <span class="keyword">super</span>.<a href="Parsers.scala.html#460325" title="PackratParsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460722" title="PackratParsers.this.PackratParser[T]">PackratParser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#462662" title="PackratParsers.this.PackratParser[T]" class="keyword">new</a> <a title="anonymous class $anon extends PackratParsers.this.PackratParser[T]" id="462662">PackratParser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(in: PackratParsers.this.Input)PackratParsers.this.ParseResult[T]" id="462668">apply</a><span class="delimiter">(</span><a title="PackratParsers.this.Input" id="462669">in</a>: <a href="../input/Reader.scala.html#22947" title="PackratParsers.this.Input">Input</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span class="comment">/*
         * transformed reader
         */</span>
        <span class="keyword">val</span> <a title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]" id="462678">inMem</a> = <a href="#462669" title="PackratParsers.this.Input">in</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]" class="delimiter">[</span><a href="#460706" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">PackratReader</a><span class="delimiter">[</span>Elem<span class="delimiter">]</span><span class="delimiter">]</span>
        
        <span class="comment">//look in the global cache if in a recursion</span>
        <span class="keyword">val</span> <a title="Option[PackratParsers.this.MemoEntry[_]]" id="462679">m</a> = <a href="#460727" title="(p: PackratParsers.this.Parser[_], in: PackratParsers.this.PackratReader[PackratParsers.this.Elem])Option[PackratParsers.this.MemoEntry[_]]">recall</a><span class="delimiter">(</span><a href="#462168" title="PackratParsers.this.Parser[T]">p</a>, <a href="#462678" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a><span class="delimiter">)</span>
        <a href="#462679" title="Option[PackratParsers.this.MemoEntry[_]]">m</a> <span title="PackratParsers.this.ParseResult[T]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="comment">//nothing has been done due to recall</span>
          <span class="keyword">case</span> <a href="../../../Option.scala.html#1729" title="PackratParsers.this.ParseResult[T]">None</a> =&gt;
            <span class="keyword">val</span> <a title="PackratParsers.this.LR" id="462682">base</a> = <a href="#461620" title="(seed: PackratParsers.this.ParseResult[_], rule: PackratParsers.this.Parser[_], head: Option[PackratParsers.this.Head])PackratParsers.this.LR">LR</a><span class="delimiter">(</span><a href="Parsers.scala.html#461387" title="(msg: String, next: PackratParsers.this.Input)PackratParsers.this.Failure">Failure</a><span class="delimiter">(</span><span title="java.lang.String(&quot;Base Failure&quot;)" class="string">&quot;Base Failure&quot;</span>,<a href="#462669" title="PackratParsers.this.Input">in</a><span class="delimiter">)</span>, <a href="#462168" title="PackratParsers.this.Parser[T]">p</a>, <a href="../../../Option.scala.html#1729" title="object None">None</a><span class="delimiter">)</span>
            <a href="#462678" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a>.<a href="#460755" title="(x$1: List[PackratParsers.this.LR])Unit">lrStack</a> = <a href="#462682" title="PackratParsers.this.LR">base</a><a href="../../../collection/immutable/List.scala.html#26456" title="(x: PackratParsers.this.LR)List[PackratParsers.this.LR]">::</a><a href="#462678" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a>.<a href="#460755" title="=&gt; List[PackratParsers.this.LR]">lrStack</a>
            <span class="comment">//cache base result</span>
            <a href="#462678" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a>.<a href="#460749" title="(p: PackratParsers.this.Parser[T], w: PackratParsers.this.MemoEntry[T])PackratParsers.this.MemoEntry[T]">updateCacheAndGet</a><span class="delimiter">(</span><a href="#462168" title="PackratParsers.this.Parser[T]">p</a>,<a href="#461751" title="(r: Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]])PackratParsers.this.MemoEntry[Nothing]">MemoEntry</a><span class="delimiter">(</span><a href="../../../Either.scala.html#49245" title="(a: PackratParsers.this.LR)Left[PackratParsers.this.LR,Nothing]">Left</a><span class="delimiter">(</span><a href="#462682" title="PackratParsers.this.LR">base</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="comment">//parse the input</span>
            <span class="keyword">val</span> <a title="PackratParsers.this.ParseResult[T]" id="462683">tempRes</a> = <a href="Parsers.scala.html#460616" title="(in: PackratParsers.this.Input)PackratParsers.this.ParseResult[T]">p</a><span class="delimiter">(</span><a href="#462669" title="PackratParsers.this.Input">in</a><span class="delimiter">)</span>
            <span class="comment">//the base variable has passed equality tests with the cache</span>
            <a href="#462678" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a>.<a href="#460755" title="(x$1: List[PackratParsers.this.LR])Unit">lrStack</a> = <a href="#462678" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a>.<a href="#460755" title="=&gt; List[PackratParsers.this.LR]">lrStack</a>.<a href="../../../collection/TraversableLike.scala.html#26398" title="=&gt; List[PackratParsers.this.LR]">tail</a>
            <span class="comment">//check whether base has changed, if yes, we will have a head</span>
            <a href="#462682" title="PackratParsers.this.LR">base</a>.<a href="#462686" title="=&gt; Option[PackratParsers.this.Head]">head</a> <span title="PackratParsers.this.ParseResult[T]" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <a href="../../../Option.scala.html#1729" title="PackratParsers.this.ParseResult[T]">None</a> =&gt; 
                <span class="comment">/*simple result*/</span>
                <a href="#462678" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a>.<a href="#460749" title="(p: PackratParsers.this.Parser[T], w: PackratParsers.this.MemoEntry[T])PackratParsers.this.MemoEntry[T]">updateCacheAndGet</a><span class="delimiter">(</span><a href="#462168" title="PackratParsers.this.Parser[T]">p</a>,<a href="#461751" title="(r: Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]])PackratParsers.this.MemoEntry[Nothing]">MemoEntry</a><span class="delimiter">(</span><a href="../../../Either.scala.html#49290" title="(b: PackratParsers.this.ParseResult[T])Right[Nothing,PackratParsers.this.ParseResult[T]]">Right</a><span class="delimiter">(</span><a href="#462683" title="PackratParsers.this.ParseResult[T]">tempRes</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#462683" title="PackratParsers.this.ParseResult[T]">tempRes</a>
              <span class="keyword">case</span> <a title="PackratParsers.this.ParseResult[T]" id="462747">s</a>@Some<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
                <span class="comment">/*non simple result*/</span>
                <a href="#462682" title="PackratParsers.this.LR">base</a>.<a href="#462684" title="(x$1: PackratParsers.this.ParseResult[_])Unit">seed</a> = <a href="#462683" title="PackratParsers.this.ParseResult[T]">tempRes</a>
                <span class="comment">//the base variable has passed equality tests with the cache</span>
                <span class="keyword">val</span> <a title="PackratParsers.this.ParseResult[T]" id="462749">res</a> = <a href="#460729" title="(p: PackratParsers.this.Parser[T], in: PackratParsers.this.PackratReader[PackratParsers.this.Elem], growable: PackratParsers.this.LR)PackratParsers.this.ParseResult[T]">lrAnswer</a><span class="delimiter">(</span><a href="#462168" title="PackratParsers.this.Parser[T]">p</a>, <a href="#462678" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a>, <a href="#462682" title="PackratParsers.this.LR">base</a><span class="delimiter">)</span>
                <a href="#462749" title="PackratParsers.this.ParseResult[T]">res</a>
            <span class="delimiter">}</span>
            
          <span class="keyword">case</span> <span title="PackratParsers.this.ParseResult[T]">Some</span><span class="delimiter">(</span><a title="PackratParsers.this.MemoEntry[Any]" id="462759">mEntry</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
            <span class="comment">//entry found in cache</span>
            <a href="#462759" title="PackratParsers.this.MemoEntry[Any]">mEntry</a> <span title="PackratParsers.this.ParseResult[T]" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <span title="PackratParsers.this.ParseResult[T]">MemoEntry</span><span class="delimiter">(</span>Left<span class="delimiter">(</span><a title="PackratParsers.this.LR" id="462767">recDetect</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
                <a href="#460728" title="(p: PackratParsers.this.Parser[_], in: PackratParsers.this.PackratReader[_], recDetect: PackratParsers.this.LR)Unit">setupLR</a><span class="delimiter">(</span><a href="#462168" title="PackratParsers.this.Parser[T]">p</a>, <a href="#462678" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a>, <a href="#462767" title="PackratParsers.this.LR">recDetect</a><span class="delimiter">)</span>
                <span class="comment">//all setupLR does is change the heads of the recursions, so the seed will stay the same</span>
                <a href="#462767" title="PackratParsers.this.LR">recDetect</a> <span title="PackratParsers.this.ParseResult[T]" class="keyword">match</span> <span class="delimiter">{</span><span class="keyword">case</span> <span title="PackratParsers.this.ParseResult[T]">LR</span><span class="delimiter">(</span><a title="PackratParsers.this.ParseResult[Any]" id="462770">seed</a>, _, _<span class="delimiter">)</span> =&gt; <a href="#462770" title="PackratParsers.this.ParseResult[Any]">seed</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="PackratParsers.this.ParseResult[T]" class="delimiter">[</span><a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span>
              <span class="delimiter">}</span>
              <span class="keyword">case</span> <span title="PackratParsers.this.ParseResult[T]">MemoEntry</span><span class="delimiter">(</span>Right<span class="delimiter">(</span><a title="PackratParsers.this.ParseResult[?&gt;: Nothing &lt;: Any]" id="462780">res</a>: <a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[_]">ParseResult</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#462780" title="PackratParsers.this.ParseResult[?&gt;: Nothing &lt;: Any]">res</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="PackratParsers.this.ParseResult[T]" class="delimiter">[</span><a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span> 
  
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T](p: PackratParsers.this.Parser[T], rest: PackratParsers.this.PackratReader[PackratParsers.this.Elem], head: PackratParsers.this.Head)PackratParsers.this.ParseResult[T]" id="460735">grow</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460737">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PackratParsers.this.Parser[T]" id="462643">p</a>: <span class="keyword">super</span>.<a href="Parsers.scala.html#460325" title="PackratParsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]" id="462644">rest</a>: <a href="#460706" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">PackratReader</a><span class="delimiter">[</span>Elem<span class="delimiter">]</span>, <a title="PackratParsers.this.Head" id="462645">head</a>: <a href="#462091" title="PackratParsers.this.Head">Head</a><span class="delimiter">)</span>: <a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="comment">//store the head into the recursionHeads</span>
    <a href="#462644" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#460752" title="=&gt; scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]">recursionHeads</a>.<a href="../../../collection/mutable/HashMap.scala.html#50490" title="(key: scala.util.parsing.input.Position, value: PackratParsers.this.Head)Option[PackratParsers.this.Head]">put</a><span class="delimiter">(</span><a href="#462644" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#460761" title="=&gt; scala.util.parsing.input.Position">pos</a>, <a href="#462645" title="PackratParsers.this.Head">head</a> <span class="comment">/*match {case Head(hp,involved,_) =&gt; Head(hp,involved,involved)}*/</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="PackratParsers.this.ParseResult[T]" id="462820">oldRes</a>: <a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#462644" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#460746" title="(p: PackratParsers.this.Parser[T])Option[PackratParsers.this.MemoEntry[T]]">getFromCache</a><span class="delimiter">(</span><a href="#462643" title="PackratParsers.this.Parser[T]">p</a><span class="delimiter">)</span>.<a href="../../../Option.scala.html#25789" title="=&gt; PackratParsers.this.MemoEntry[T]">get</a> <span title="PackratParsers.this.ParseResult[T]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="PackratParsers.this.ParseResult[T]">MemoEntry</span><span class="delimiter">(</span>Right<span class="delimiter">(</span><a title="PackratParsers.this.ParseResult[Any]" id="462830">x</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#462830" title="PackratParsers.this.ParseResult[Any]">x</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="PackratParsers.this.ParseResult[T]" class="delimiter">[</span><a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
      <span class="keyword">case</span> <span title="Nothing">_</span> =&gt; <span title="Nothing" class="keyword">throw</span> <span title="(x$1: java.lang.String)java.lang.Exception" class="keyword">new</span> <a href="../../../package.scala.html#24942" title="java.lang.Exception">Exception</a><span class="delimiter">(</span><span title="java.lang.String(&quot;impossible match&quot;)" class="string">&quot;impossible match&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">//resetting the evalSet of the head of the recursion at each beginning of growth</span>
    <a href="#462645" title="PackratParsers.this.Head">head</a>.<a href="#462409" title="(x$1: List[PackratParsers.this.Parser[_]])Unit">evalSet</a> = <a href="#462645" title="PackratParsers.this.Head">head</a>.<a href="#462408" title="=&gt; List[PackratParsers.this.Parser[_]]">involvedSet</a>
    <span class="keyword">val</span> <a title="PackratParsers.this.ParseResult[T]" id="462821">tempRes</a> = <a href="Parsers.scala.html#460616" title="(in: PackratParsers.this.Input)PackratParsers.this.ParseResult[T]">p</a><span class="delimiter">(</span><a href="#462644" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a><span class="delimiter">)</span>; <a href="#462821" title="PackratParsers.this.ParseResult[T]">tempRes</a> <span title="PackratParsers.this.ParseResult[T]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="PackratParsers.this.ParseResult[T]" id="462853">s</a>@Success<span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt; 
        <span title="PackratParsers.this.ParseResult[T]" class="keyword">if</span><span class="delimiter">(</span><a href="#460711" title="(r: PackratParsers.this.ParseResult[_])scala.util.parsing.input.Position">getPosFromResult</a><span class="delimiter">(</span><a href="#462820" title="PackratParsers.this.ParseResult[T]">oldRes</a><span class="delimiter">)</span> <a href="../input/Position.scala.html#461033" title="(that: scala.util.parsing.input.Position)Boolean">&lt;</a> <a href="#460711" title="(r: PackratParsers.this.ParseResult[_])scala.util.parsing.input.Position">getPosFromResult</a><span class="delimiter">(</span><a href="#462821" title="PackratParsers.this.ParseResult[T]">tempRes</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#462644" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#460749" title="(p: PackratParsers.this.Parser[T], w: PackratParsers.this.MemoEntry[T])PackratParsers.this.MemoEntry[T]">updateCacheAndGet</a><span class="delimiter">(</span><a href="#462643" title="PackratParsers.this.Parser[T]">p</a>, <a href="#461751" title="(r: Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]])PackratParsers.this.MemoEntry[Nothing]">MemoEntry</a><span class="delimiter">(</span><a href="../../../Either.scala.html#49290" title="(b: PackratParsers.this.Success[T])Right[Nothing,PackratParsers.this.Success[T]]">Right</a><span class="delimiter">(</span><a href="#462853" title="PackratParsers.this.Success[T]">s</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#460735" title="(p: PackratParsers.this.Parser[T], rest: PackratParsers.this.PackratReader[PackratParsers.this.Elem], head: PackratParsers.this.Head)PackratParsers.this.ParseResult[T]">grow</a><span class="delimiter">(</span><a href="#462643" title="PackratParsers.this.Parser[T]">p</a>, <a href="#462644" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>, <a href="#462645" title="PackratParsers.this.Head">head</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="comment">//we're done with growing, we can remove data from recursion head</span>
          <a href="#462644" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#460752" title="=&gt; scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]">recursionHeads</a> <a href="../../../collection/mutable/HashMap.scala.html#50494" title="(key: scala.util.parsing.input.Position)rest.recursionHeads.type">-=</a> <a href="#462644" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#460761" title="=&gt; scala.util.parsing.input.Position">pos</a>
          <a href="#462644" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#460746" title="(p: PackratParsers.this.Parser[T])Option[PackratParsers.this.MemoEntry[T]]">getFromCache</a><span class="delimiter">(</span><a href="#462643" title="PackratParsers.this.Parser[T]">p</a><span class="delimiter">)</span>.<a href="../../../Option.scala.html#25789" title="=&gt; PackratParsers.this.MemoEntry[T]">get</a> <span title="PackratParsers.this.ParseResult[T]" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="PackratParsers.this.ParseResult[T]">MemoEntry</span><span class="delimiter">(</span>Right<span class="delimiter">(</span><a title="PackratParsers.this.ParseResult[?&gt;: Nothing &lt;: Any]" id="462894">x</a>: <a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[_]">ParseResult</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#462894" title="PackratParsers.this.ParseResult[?&gt;: Nothing &lt;: Any]">x</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="PackratParsers.this.ParseResult[T]" class="delimiter">[</span><a href="Parsers.scala.html#460301" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
            <span class="keyword">case</span> <span title="Nothing">_</span> =&gt; <span title="Nothing" class="keyword">throw</span> <span title="(x$1: java.lang.String)java.lang.Exception" class="keyword">new</span> <a href="../../../package.scala.html#24942" title="java.lang.Exception">Exception</a><span class="delimiter">(</span><span title="java.lang.String(&quot;impossible match&quot;)" class="string">&quot;impossible match&quot;</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="PackratParsers.this.ParseResult[T]" id="462904">f</a> =&gt; 
        <a href="#462644" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#460752" title="=&gt; scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]">recursionHeads</a> <a href="../../../collection/mutable/HashMap.scala.html#50494" title="(key: scala.util.parsing.input.Position)rest.recursionHeads.type">-=</a> <a href="#462644" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#460761" title="=&gt; scala.util.parsing.input.Position">pos</a>
        <span class="comment">/*rest.updateCacheAndGet(p, MemoEntry(Right(f)));*/</span><a href="#462820" title="PackratParsers.this.ParseResult[T]">oldRes</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>