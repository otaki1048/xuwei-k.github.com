<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/util/parsing/combinator/Parsers.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2006-2011, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>


<span class="keyword">package</span> scala.util.parsing.combinator

<span class="keyword">import</span> scala.util.parsing.input._
<span class="keyword">import</span> scala.collection.mutable.ListBuffer
<span class="keyword">import</span> scala.annotation.tailrec
<span class="keyword">import</span> annotation.migration

<span class="comment">// TODO: better error handling (labelling like parsec's &lt;?&gt;)</span>

<span class="comment">/** &lt;p&gt;
 *    &lt;code&gt;Parsers&lt;/code&gt; is a component that &lt;i&gt;provides&lt;/i&gt; generic
 *    parser combinators.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    It &lt;i&gt;requires&lt;/i&gt; the type of the elements these parsers should parse 
 *    (each parser is polymorphic in the type of result it produces).
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    There are two aspects to the result of a parser: (1) success or failure,
 *    and (2) the result. A &lt;code&gt;Parser[T]&lt;/code&gt; provides both kinds of
 *    information.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    The term ``parser combinator'' refers to the fact that these parsers
 *    are constructed from primitive parsers and composition operators, such
 *    as sequencing, alternation, optionality, repetition, lifting, and so on.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    A ``primitive parser'' is a parser that accepts or rejects a single
 *    piece of input, based on a certain criterion, such as whether the
 *    input...
 *  &lt;/p&gt;&lt;ul&gt;
 *    &lt;li&gt; is equal to some given object, &lt;/li&gt;
 *    &lt;li&gt; satisfies a certain predicate, &lt;/li&gt;
 *    &lt;li&gt; is in the domain of a given partial function,.... &lt;/li&gt;
 *  &lt;/ul&gt;
 *  &lt;p&gt;
 *    Even more primitive parsers always produce the same result, irrespective
 *    of the input.
 *  &lt;/p&gt;
 *
 * @author Martin Odersky, Iulian Dragos, Adriaan Moors 
 */</span>
<span class="keyword">trait</span> <a title="trait Parsers extends java.lang.Object with ScalaObject" id="22423">Parsers</a> <a href="../../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
  <span class="comment">/** the type of input elements the provided parsers consume (When consuming invidual characters, a parser is typically
   * called a ``scanner'', which produces ``tokens'' that are consumed by what is normally called a ``parser''.
   * Nonetheless, the same principles apply, regardless of the input type.) */</span>
  <span class="keyword">type</span> <a title="&gt;: Nothing &lt;: Any" id="460249">Elem</a>

  <span class="comment">/** The parser input is an abstract reader of input elements, i.e. the type of input the parsers in this component
   * expect. */</span>
  <span class="keyword">type</span> <a title="scala.util.parsing.input.Reader[Parsers.this.Elem]" id="460250">Input</a> = <a href="../input/Reader.scala.html#22968" title="scala.util.parsing.input.Reader[Parsers.this.Elem]">Reader</a><span class="delimiter">[</span>Elem<span class="delimiter">]</span>

  <span class="comment">/** A base class for parser results. A result is either successful or not (failure may be fatal, i.e., an Error, or
   * not, i.e., a Failure). On success, provides a result of type `T` which consists of some result (and the rest of
   * the input). */</span>
  <span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ParseResult[+T] extends java.lang.Object with ScalaObject" id="460251">ParseResult</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="460252">T</a><span class="delimiter">]</span> <a href="../../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="comment">/** Functional composition of ParseResults
     * 
     * @param `f' the function to be lifted over this result
     * @return `f' applied to the result of this `ParseResult', packaged up as a new `ParseResult'
     */</span>
    <span class="keyword">def</span> <a title="[U](f: T =&gt; U)Parsers.this.ParseResult[U]" id="461212">map</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461214">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; U" id="463279">f</a>: T =&gt; U<span class="delimiter">)</span>: <a href="#460251" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span>
    
    <span class="comment">/** Partial functional composition of ParseResults
     * 
     * @param `f' the partial function to be lifted over this result
     * @param error a function that takes the same argument as `f' and produces an error message 
     *        to explain why `f' wasn't applicable (it is called when this is the case)
     * @return &lt;i&gt;if `f' f is defined at the result in this `ParseResult',&lt;/i&gt;
     *         `f' applied to the result of this `ParseResult', packaged up as a new `ParseResult'.
     *         If `f' is not defined, `Failure'.
     */</span>
    <span class="keyword">def</span> <a title="[U](f: PartialFunction[T,U], error: T =&gt; String)Parsers.this.ParseResult[U]" id="461215">mapPartial</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461217">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[T,U]" id="463282">f</a>: <a href="../../../PartialFunction.scala.html#331" title="PartialFunction[T,U]">PartialFunction</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span>, <a title="T =&gt; String" id="463283">error</a>: T =&gt; String<span class="delimiter">)</span>: <a href="#460251" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span>   
    
    <span class="keyword">def</span> <a title="[U](f: T =&gt; Parsers.this.Input =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="461218">flatMapWithNext</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461220">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; Parsers.this.Input =&gt; Parsers.this.ParseResult[U]" id="463287">f</a>: T =&gt; Input =&gt; ParseResult<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460251" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span>     

    <span class="keyword">def</span> <a title="[U &gt;: T](a: =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="461221">append</a><span class="delimiter">[</span><a title="&gt;: T &lt;: Any" id="461223">U</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.ParseResult[U]" id="463290">a</a>: =&gt; ParseResult<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460251" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span>
    
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="461224">isEmpty</a> = <a href="../../../Boolean.scala.html#32913" title="=&gt; Boolean">!</a><a href="#461230" title="=&gt; Boolean">successful</a>
    
    <span class="comment">/** Returns the embedded result */</span>
    <span class="keyword">def</span> <a title="=&gt; T" id="461225">get</a>: <a href="#460252" title="T">T</a>
    
    <span class="keyword">def</span> <a title="[B &gt;: T](default: =&gt; B)B" id="461226">getOrElse</a><span class="delimiter">[</span><a title="&gt;: T &lt;: Any" id="461228">B</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; B" id="463298">default</a>: =&gt; B<span class="delimiter">)</span>: <a href="#461228" title="B">B</a> = 
        <span title="B" class="keyword">if</span> <span class="delimiter">(</span><a href="#461224" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#463298" title="=&gt; B">default</a> <span class="keyword">else</span> <a href="#460251" title="ParseResult.this.type" class="keyword">this</a>.<a href="#461225" title="=&gt; T">get</a>
    
    <span class="keyword">val</span> <a title="=&gt; Parsers.this.Input" id="461229">next</a>: <a href="../input/Reader.scala.html#22968" title="Parsers.this.Input">Input</a>
    
    <span class="keyword">val</span> <a title="=&gt; Boolean" id="461230">successful</a>: <a href="../../../Boolean.scala.html#61" title="Boolean">Boolean</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The success case of ParseResult: contains the result and the remaining input.
   *
   *  @param result The parser's output 
   *  @param next   The parser's remaining input
   */</span>
  case <span class="keyword">class</span> <a title="class Success[+T] extends Parsers.this.ParseResult[T] with ScalaObject with Product with Serializable" id="461208">Success</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="461210">T</a><span class="delimiter">]</span><a href="../../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">(</a><a title="T" id="463313">result</a>: <a href="#461210" title="T">T</a>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="Parsers.this.Input" id="463314">next</a>: <a href="../input/Reader.scala.html#22968" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#460251" title="Parsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[U](f: T =&gt; U)Parsers.this.Success[U]" id="461238">map</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461240">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; U" id="463304">f</a>: T =&gt; U<span class="delimiter">)</span> = <a href="#461208" title="(result: U, next: Parsers.this.Input)Parsers.this.Success[U]">Success</a><span class="delimiter">(</span><a href="../../../Function1.scala.html#30790" title="(v1: T)U">f</a><span class="delimiter">(</span><a href="#463313" title="=&gt; T">result</a><span class="delimiter">)</span>, <a href="#463314" title="=&gt; Parsers.this.Input">next</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[U](f: PartialFunction[T,U], error: T =&gt; String)Parsers.this.ParseResult[U]" id="461241">mapPartial</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461243">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[T,U]" id="463325">f</a>: <a href="../../../PartialFunction.scala.html#331" title="PartialFunction[T,U]">PartialFunction</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span>, <a title="T =&gt; String" id="463326">error</a>: T =&gt; String<span class="delimiter">)</span>: <a href="#460251" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span> 
       = <span title="Parsers.this.ParseResult[U]" class="keyword">if</span><span class="delimiter">(</span><a href="#463325" title="PartialFunction[T,U]">f</a>.<a href="../../../PartialFunction.scala.html#30799" title="(x: T)Boolean">isDefinedAt</a><span class="delimiter">(</span><a href="#463313" title="=&gt; T">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#461208" title="(result: U, next: Parsers.this.Input)Parsers.this.Success[U]">Success</a><span class="delimiter">(</span><a href="../../../Function1.scala.html#30790" title="(v1: T)U">f</a><span class="delimiter">(</span><a href="#463313" title="=&gt; T">result</a><span class="delimiter">)</span>, <a href="#463314" title="=&gt; Parsers.this.Input">next</a><span class="delimiter">)</span> 
         <span class="keyword">else</span> <a href="#461337" title="(msg: String, next: Parsers.this.Input)Parsers.this.Failure">Failure</a><span class="delimiter">(</span><a href="../../../Function1.scala.html#30790" title="(v1: T)String">error</a><span class="delimiter">(</span><a href="#463313" title="=&gt; T">result</a><span class="delimiter">)</span>, <a href="#463314" title="=&gt; Parsers.this.Input">next</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="[U](f: T =&gt; Parsers.this.Input =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="461244">flatMapWithNext</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461246">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; Parsers.this.Input =&gt; Parsers.this.ParseResult[U]" id="463346">f</a>: T =&gt; Input =&gt; ParseResult<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460251" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span> 
      = <a href="../../../Function1.scala.html#30790" title="(v1: T)Parsers.this.Input =&gt; Parsers.this.ParseResult[U]">f</a><a href="../../../Function1.scala.html#30790" title="(v1: Parsers.this.Input)Parsers.this.ParseResult[U]" class="delimiter">(</a><a href="#463313" title="=&gt; T">result</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#463314" title="=&gt; Parsers.this.Input">next</a><span class="delimiter">)</span> 

    <span class="keyword">def</span> <a title="[U &gt;: T](a: =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="461247">append</a><span class="delimiter">[</span><a title="&gt;: T &lt;: Any" id="461249">U</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.ParseResult[U]" id="463354">a</a>: =&gt; ParseResult<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460251" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#461208" title="Parsers.this.Success[T]" class="keyword">this</a>

    <span class="keyword">def</span> <a title="=&gt; T" id="461250">get</a>: <a href="#461210" title="T">T</a> = <a href="#463313" title="=&gt; T">result</a>
    
    <span class="comment">/** The toString method of a Success */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="461251">toString</a> = <span title="java.lang.String(&quot;[&quot;)" class="string">&quot;[&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#463314" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#460558" title="=&gt; scala.util.parsing.input.Position">pos</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;] parsed: &quot;)" class="string">&quot;] parsed: &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#463313" title="=&gt; T">result</a>
    
    <span class="keyword">val</span> <a title="Boolean" id="461252">successful</a> = <span title="Boolean(true)" class="keyword">true</span>
  <span class="delimiter">}</span>

  <span class="keyword">var</span> <a title="Parsers.this.NoSuccess" id="460258">lastNoSuccess</a>: <a href="#460260" title="Parsers.this.NoSuccess">NoSuccess</a> = <span title="Null(null)" class="keyword">null</span>

  <span class="comment">/** A common super-class for unsuccessful parse results
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class NoSuccess extends Parsers.this.ParseResult[Nothing] with ScalaObject" id="460260">NoSuccess</a><a href="../../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">(</a><span class="keyword">val</span> <a title="String" id="463407">msg</a>: <span title="String">String</span>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="Parsers.this.Input" id="463408">next</a>: <a href="../input/Reader.scala.html#22968" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#460251" title="Parsers.this.ParseResult[Nothing]">ParseResult</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="comment">// when we don't care about the difference between Failure and Error</span>
    <span class="keyword">val</span> <a title="Boolean" id="461297">successful</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#32913" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#460258" title="=&gt; Parsers.this.NoSuccess">lastNoSuccess</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span> <a href="../../../Boolean.scala.html#32917" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#463408" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#460558" title="=&gt; scala.util.parsing.input.Position">pos</a> <a href="../input/Position.scala.html#460983" title="(that: scala.util.parsing.input.Position)Boolean">&lt;</a> <a href="#460258" title="=&gt; Parsers.this.NoSuccess">lastNoSuccess</a>.<a href="#463408" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#460558" title="=&gt; scala.util.parsing.input.Position">pos</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#460258" title="(x$1: Parsers.this.NoSuccess)Unit">lastNoSuccess</a> = <a href="#460260" title="Parsers.this.NoSuccess" class="keyword">this</a>

    <span class="keyword">def</span> <a title="[U](f: Nothing =&gt; U)Parsers.this.NoSuccess" id="461299">map</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461301">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Nothing =&gt; U" id="463415">f</a>: Nothing =&gt; U<span class="delimiter">)</span> = <a href="#460260" title="Parsers.this.NoSuccess" class="keyword">this</a>
    <span class="keyword">def</span> <a title="[U](f: PartialFunction[Nothing,U], error: Nothing =&gt; String)Parsers.this.ParseResult[U]" id="461302">mapPartial</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461304">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[Nothing,U]" id="463425">f</a>: <a href="../../../PartialFunction.scala.html#331" title="PartialFunction[Nothing,U]">PartialFunction</a><span class="delimiter">[</span>Nothing, U<span class="delimiter">]</span>, <a title="Nothing =&gt; String" id="463426">error</a>: Nothing =&gt; String<span class="delimiter">)</span>: <a href="#460251" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#460260" title="Parsers.this.NoSuccess" class="keyword">this</a>

    <span class="keyword">def</span> <a title="[U](f: Nothing =&gt; Parsers.this.Input =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="461305">flatMapWithNext</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461307">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Nothing =&gt; Parsers.this.Input =&gt; Parsers.this.ParseResult[U]" id="463436">f</a>: Nothing =&gt; Input =&gt; ParseResult<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460251" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span> 
      = <a href="#460260" title="Parsers.this.NoSuccess" class="keyword">this</a>

    <span class="keyword">def</span> <a title="=&gt; Nothing" id="461308">get</a>: <span title="Nothing">Nothing</span> = sys.<a href="../../../sys/package.scala.html#25626" title="(message: String)Nothing">error</a><span class="delimiter">(</span><span title="java.lang.String(&quot;No result when parsing failed&quot;)" class="string">&quot;No result when parsing failed&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/** An extractor so NoSuccess(msg, next) can be used in matches.
   */</span>
  <span class="keyword">object</span> <a title="object Parsers.this.NoSuccess" id="460261">NoSuccess</a> <a href="../../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="[T](x: Parsers.this.ParseResult[T])Option[(String, Parsers.this.Input)]" id="463445">unapply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="463447">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Parsers.this.ParseResult[T]" id="463449">x</a>: <a href="#460251" title="Parsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#463449" title="Parsers.this.ParseResult[T]">x</a> <span title="Option[(String, Parsers.this.Input)]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Some[(String, Parsers.this.Input)]">Failure</span><span class="delimiter">(</span><a title="String" id="463452">msg</a>, <a title="Parsers.this.Input" id="463453">next</a><span class="delimiter">)</span>   =&gt; <a href="../../../Option.scala.html#35222" title="(x: (String, Parsers.this.Input))Some[(String, Parsers.this.Input)]">Some</a><a href="../../../Tuple2.scala.html#30727" title="(_1: String, _2: Parsers.this.Input)(String, Parsers.this.Input)" class="delimiter">(</a><a href="#463452" title="String">msg</a>, <a href="#463453" title="Parsers.this.Input">next</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Some[(String, Parsers.this.Input)]">Error</span><span class="delimiter">(</span><a title="String" id="463463">msg</a>, <a title="Parsers.this.Input" id="463464">next</a><span class="delimiter">)</span>     =&gt; <a href="../../../Option.scala.html#35222" title="(x: (String, Parsers.this.Input))Some[(String, Parsers.this.Input)]">Some</a><a href="../../../Tuple2.scala.html#30727" title="(_1: String, _2: Parsers.this.Input)(String, Parsers.this.Input)" class="delimiter">(</a><a href="#463463" title="String">msg</a>, <a href="#463464" title="Parsers.this.Input">next</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="None.type">_</span>                    =&gt; <a href="../../../Option.scala.html#1733" title="object None">None</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/** The failure case of ParseResult: contains an error-message and the remaining input.
   * Parsing will back-track when a failure occurs.
   *
   *  @param msg    An error message string describing the failure.
   *  @param next   The parser's unconsumed input at the point where the failure occurred.
   */</span>
  case <span class="keyword">class</span> <a title="class Failure extends Parsers.this.NoSuccess with ScalaObject with Product with Serializable" id="461337">Failure</a><a href="../../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="String" id="461351">msg</a>: <span title="String">String</span>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="Parsers.this.Input" id="461352">next</a>: <a href="../input/Reader.scala.html#22968" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#460260" title="Parsers.this.NoSuccess">NoSuccess</a><span class="delimiter">(</span><a href="#461351" title="String">msg</a>, <a href="#461352" title="Parsers.this.Input">next</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">/** The toString method of a Failure yields an error message */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="461345">toString</a> = <span title="java.lang.String(&quot;[&quot;)" class="string">&quot;[&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#461352" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#460558" title="=&gt; scala.util.parsing.input.Position">pos</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;] failure: &quot;)" class="string">&quot;] failure: &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#461351" title="=&gt; String">msg</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;\012\012&quot;)" class="string">&quot;\n\n&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#461352" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#460558" title="=&gt; scala.util.parsing.input.Position">pos</a>.<a href="../input/Position.scala.html#460982" title="=&gt; java.lang.String">longString</a>
    
    <span class="keyword">def</span> <a title="[U](a: =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="461346">append</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461348">U</a> &gt;: Nothing<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.ParseResult[U]" id="463735">a</a>: =&gt; ParseResult<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460251" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <span class="delimiter">{</span> <span class="keyword">val</span> <a title="Parsers.this.ParseResult[U]" id="463742">alt</a> = <a href="#463735" title="=&gt; Parsers.this.ParseResult[U]">a</a>; <a href="#463742" title="Parsers.this.ParseResult[U]">alt</a> <span title="Parsers.this.ParseResult[U]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Parsers.this.ParseResult[U]">Success</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#463742" title="Parsers.this.ParseResult[U]">alt</a>
      <span class="keyword">case</span> <a title="Parsers.this.ParseResult[U]" id="463745">ns</a>: <a href="#460260" title="Parsers.this.NoSuccess">NoSuccess</a> =&gt; <span title="Parsers.this.ParseResult[U]" class="keyword">if</span> <span class="delimiter">(</span><a href="#463742" title="Parsers.this.ParseResult[U]">alt</a>.<a href="#461229" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#460558" title="=&gt; scala.util.parsing.input.Position">pos</a> <a href="../input/Position.scala.html#460983" title="(that: scala.util.parsing.input.Position)Boolean">&lt;</a> <a href="#461352" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#460558" title="=&gt; scala.util.parsing.input.Position">pos</a><span class="delimiter">)</span> <a href="#461337" title="Parsers.this.Failure" class="keyword">this</a> <span class="keyword">else</span> <a href="#463742" title="Parsers.this.ParseResult[U]">alt</a>
    <span class="delimiter">}</span><span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/** The fatal failure case of ParseResult: contains an error-message and the remaining input.
   * No back-tracking is done when a parser returns an `Error' 
   *
   *  @param msg    An error message string describing the error.
   *  @param next   The parser's unconsumed input at the point where the error occurred.
   */</span>
  case <span class="keyword">class</span> <a title="class Error extends Parsers.this.NoSuccess with ScalaObject with Product with Serializable" id="462547">Error</a><a href="../../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="String" id="464038">msg</a>: <span title="String">String</span>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="Parsers.this.Input" id="464039">next</a>: <a href="../input/Reader.scala.html#22968" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#460260" title="Parsers.this.NoSuccess">NoSuccess</a><span class="delimiter">(</span><a href="#464038" title="String">msg</a>, <a href="#464039" title="Parsers.this.Input">next</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">/** The toString method of an Error yields an error message */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="462555">toString</a> = <span title="java.lang.String(&quot;[&quot;)" class="string">&quot;[&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#464039" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#460558" title="=&gt; scala.util.parsing.input.Position">pos</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;] error: &quot;)" class="string">&quot;] error: &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#464038" title="=&gt; String">msg</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;\012\012&quot;)" class="string">&quot;\n\n&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#464039" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#460558" title="=&gt; scala.util.parsing.input.Position">pos</a>.<a href="../input/Position.scala.html#460982" title="=&gt; java.lang.String">longString</a>
    <span class="keyword">def</span> <a title="[U](a: =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="462556">append</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="462558">U</a> &gt;: Nothing<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.ParseResult[U]" id="463784">a</a>: =&gt; ParseResult<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460251" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#462547" title="Parsers.this.Error" class="keyword">this</a>
  <span class="delimiter">}</span>
  

  <span class="keyword">def</span> <a title="[T](f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]" id="460269">Parser</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460271">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Parsers.this.Input =&gt; Parsers.this.ParseResult[T]" id="462125">f</a>: Input =&gt; ParseResult<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> 
    = <a href="#463823" title="Parsers.this.Parser[T]" class="keyword">new</a> <a title="anonymous class $anon extends Parsers.this.Parser[T]" id="463823">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">{</span> <span class="keyword">def</span> <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" id="463828">apply</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="463829">in</a>: <a href="../input/Reader.scala.html#22968" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> = <a href="../../../Function1.scala.html#30790" title="(v1: Parsers.this.Input)Parsers.this.ParseResult[T]">f</a><span class="delimiter">(</span><a href="#463829" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  
  <span class="keyword">def</span> <a title="[T](f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T] with Parsers.this.OnceParser[T]" id="460272">OnceParser</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460274">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Parsers.this.Input =&gt; Parsers.this.ParseResult[T]" id="463837">f</a>: Input =&gt; ParseResult<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#463838" title="Parsers extends Parsers.this.Parser[T] with Parsers.this.OnceParser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="keyword">with</span> OnceParser<span class="delimiter">[</span>T<span class="delimiter">]</span> 
    = <a href="#463846" title="Parsers.this.Parser[T] with Parsers.this.OnceParser[T]" class="keyword">new</a> <a title="anonymous class $anon extends Parsers.this.Parser[T] with Parsers.this.OnceParser[T]" id="463846">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="keyword">with</span> <a href="#460358" title="Parsers.this.OnceParser[T]">OnceParser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" id="463861">apply</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="463862">in</a>: <a href="../input/Reader.scala.html#22968" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> = <a href="../../../Function1.scala.html#30790" title="(v1: Parsers.this.Input)Parsers.this.ParseResult[T]">f</a><span class="delimiter">(</span><a href="#463862" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  
  <span class="comment">/** The root class of parsers. 
   *  Parsers are functions from the Input type to ParseResult 
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Parser[+T] extends java.lang.Object with Parsers.this.Input =&gt; Parsers.this.ParseResult[T] with ScalaObject" id="460275">Parser</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="460276">T</a><span class="delimiter">]</span> <a href="../../../ScalaObject.scala.html#460" title="ScalaObject" class="keyword">extends</a> <span class="delimiter">(</span>Input =&gt; ParseResult<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="String" id="460562">name</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="keyword">def</span> <a title="(n: String)Parser.this.type" id="460564">named</a><span class="delimiter">(</span><a title="String" id="463873">n</a>: <span title="String">String</span><span class="delimiter">)</span>: <span class="keyword">this</span>.<span class="keyword">type</span> = <span class="delimiter">{</span><a href="#460562" title="(x$1: String)Unit">name</a>=<a href="#463873" title="String">n</a>; <a href="#460275" title="Parser.this.type" class="keyword">this</a><span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="460565">toString</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span title="java.lang.String(&quot;Parser (&quot;)" class="string">&quot;Parser (&quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#460562" title="=&gt; String">name</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
    
    <span class="comment">/** An unspecified method that defines the behaviour of this parser.
     */</span>
    <span class="keyword">def</span> <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" id="460566">apply</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="461192">in</a>: <a href="../input/Reader.scala.html#22968" title="Parsers.this.Input">Input</a><span class="delimiter">)</span>: <a href="#460251" title="Parsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

    <span class="keyword">def</span> <a title="[U](f: T =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="460567">flatMap</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460569">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; Parsers.this.Parser[U]" id="463875">f</a>: T =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span>
      = <a href="#460269" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="463881">in</a> =&gt; <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" class="keyword">this</a><span class="delimiter">(</span><a href="#463881" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <a href="#461218" title="(f: T =&gt; Parsers.this.Input =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]">flatMapWithNext</a><span class="delimiter">(</span><a href="#463875" title="T =&gt; Parsers.this.Parser[U]">f</a><span class="delimiter">)</span><span class="delimiter">}</span>
                                      
    <span class="keyword">def</span> <a title="[U](f: T =&gt; U)Parsers.this.Parser[U]" id="460570">map</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460572">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; U" id="463895">f</a>: T =&gt; U<span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> <span class="comment">//= flatMap{x =&gt; success(f(x))}</span>
      = <a href="#460269" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="463901">in</a> =&gt; <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" class="keyword">this</a><span class="delimiter">(</span><a href="#463901" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <a href="#461212" title="(f: T =&gt; U)Parsers.this.ParseResult[U]">map</a><span class="delimiter">(</span><a href="#463895" title="T =&gt; U">f</a><span class="delimiter">)</span><span class="delimiter">}</span>

    <span class="comment">// no filter yet, dealing with zero is tricky!</span>
  
    @migration<span class="delimiter">(</span><span class="int">2</span>, <span class="int">9</span>, <span class="string">&quot;As of 2.9, the call-by-name argument is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[U &gt;: T](p0: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="460573">append</a><span class="delimiter">[</span><a title="&gt;: T &lt;: Any" id="460575">U</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[U]" id="463915">p0</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <span class="delimiter">{</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Parsers.this.Parser[U]" id="463919">p</a> = <a href="#463915" title="=&gt; Parsers.this.Parser[U]">p0</a> <span class="comment">// lazy argument</span>
      <a href="#460269" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="463923">in</a> =&gt; <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" class="keyword">this</a><span class="delimiter">(</span><a href="#463923" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <a href="#461221" title="(a: =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]">append</a> <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[U]">p</a><span class="delimiter">(</span><a href="#463923" title="Parsers.this.Input">in</a><span class="delimiter">)</span><span class="delimiter">}</span>
    <span class="delimiter">}</span>

                                      
    <span class="comment">// the operator formerly known as +++, ++, &amp;, but now, behold the venerable ~</span>
    <span class="comment">// it's short, light (looks like whitespace), has few overloaded meaning (thanks to the recent change from ~ to unary_~)</span>
    <span class="comment">// and we love it! (or do we like `,` better?)</span>
                                      
    <span class="comment">/** A parser combinator for sequential composition 
     *
     * &lt;p&gt; `p ~ q' succeeds if `p' succeeds and `q' succeeds on the input
     *          left over by `p'.&lt;/p&gt;
     * 
     * @param q a parser that will be executed after `p' (this parser) succeeds -- evaluated at most once, and only when necessary
     * @return a `Parser' that -- on success -- returns a `~' (like a Pair, but easier to pattern match on) 
     *         that contains the result of `p' and that of `q'. 
     *         The resulting parser fails if either `p' or `q' fails.
     */</span>
    @migration<span class="delimiter">(</span><span class="int">2</span>, <span class="int">9</span>, <span class="string">&quot;As of 2.9, the call-by-name argument is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[U](q: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[Parsers.this.~[T,U]]" id="460576">~</a> <span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460578">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[U]" id="463847">q</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[Parsers.this.~[T,U]]">Parser</a><span class="delimiter">[</span>~<span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Parsers.this.Parser[U]" id="463946">p</a> = <a href="#463847" title="=&gt; Parsers.this.Parser[U]">q</a> <span class="comment">// lazy argument</span>
      <span class="delimiter">(</span><span class="keyword">for</span><span class="delimiter">(</span><a title="T" id="463950">a</a> &lt;- <a href="#460567" title="(f: T =&gt; Parsers.this.Parser[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]]" class="keyword">this</a>; <a title="U" id="463955">b</a> &lt;- <a href="#460570" title="(f: U =&gt; Parsers.this.~[T,U])Parsers.this.Parser[Parsers.this.~[T,U]]">p</a><span class="delimiter">)</span> <span class="keyword">yield</span> <span title="Parsers.this.~[T,U]" class="keyword">new</span> <a href="#460382" title="Parsers.this.~[T,U]">~</a><span class="delimiter">(</span><a href="#463950" title="T">a</a>,<a href="#463955" title="U">b</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#460564" title="(n: java.lang.String)Parsers.this.Parser[Parsers.this.~[T,U]]">named</a><span class="delimiter">(</span><span title="java.lang.String(&quot;~&quot;)" class="string">&quot;~&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** A parser combinator for sequential composition which keeps only the right result 
     *
     * &lt;p&gt; `p ~&gt; q' succeeds if `p' succeeds and `q' succeeds on the input
     *           left over by `p'.&lt;/p&gt;
     * 
     * @param q a parser that will be executed after `p' (this parser) succeeds -- evaluated at most once, and only when necessary
     * @return a `Parser' that -- on success -- returns the result of `q'.
     */</span>
    @migration<span class="delimiter">(</span><span class="int">2</span>, <span class="int">9</span>, <span class="string">&quot;As of 2.9, the call-by-name argument is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[U](q: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="460579">~&gt;</a> <span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460581">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[U]" id="463967">q</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <span class="delimiter">{</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Parsers.this.Parser[U]" id="463971">p</a> = <a href="#463967" title="=&gt; Parsers.this.Parser[U]">q</a> <span class="comment">// lazy argument</span>
      <span class="delimiter">(</span><span class="keyword">for</span><span class="delimiter">(</span><a title="T" id="463975">a</a> &lt;- <a href="#460567" title="(f: T =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" class="keyword">this</a>; <a title="U" id="463980">b</a> &lt;- <a href="#460570" title="(f: U =&gt; U)Parsers.this.Parser[U]">p</a><span class="delimiter">)</span> <span class="keyword">yield</span> <a href="#463980" title="U">b</a><span class="delimiter">)</span>.<a href="#460564" title="(n: java.lang.String)Parsers.this.Parser[U]">named</a><span class="delimiter">(</span><span title="java.lang.String(&quot;~&gt;&quot;)" class="string">&quot;~&gt;&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** A parser combinator for sequential composition which keeps only the left result 
     *
     * &lt;p&gt; `p &amp;lt;~ q' succeeds if `p' succeeds and `q' succeeds on the input
     *           left over by `p'.&lt;/p&gt;
     * 
     * &lt;b&gt;Note:&lt;/b&gt; &amp;lt;~ has lower operator precedence than ~ or ~&gt;.
     *
     * @param q a parser that will be executed after `p' (this parser) succeeds -- evaluated at most once, and only when necessary 
     * @return a `Parser' that -- on success -- returns the result of `p'.
     */</span>
    @migration<span class="delimiter">(</span><span class="int">2</span>, <span class="int">9</span>, <span class="string">&quot;As of 2.9, the call-by-name argument is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[U](q: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[T]" id="460582">&lt;~</a> <span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460584">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[U]" id="463986">q</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Parsers.this.Parser[U]" id="463990">p</a> = <a href="#463986" title="=&gt; Parsers.this.Parser[U]">q</a> <span class="comment">// lazy argument</span>
      <span class="delimiter">(</span><span class="keyword">for</span><span class="delimiter">(</span><a title="T" id="463994">a</a> &lt;- <a href="#460567" title="(f: T =&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]" class="keyword">this</a>; <a title="U" id="463999">b</a> &lt;- <a href="#460570" title="(f: U =&gt; T)Parsers.this.Parser[T]">p</a><span class="delimiter">)</span> <span class="keyword">yield</span> <a href="#463994" title="T">a</a><span class="delimiter">)</span>.<a href="#460564" title="(n: java.lang.String)Parsers.this.Parser[T]">named</a><span class="delimiter">(</span><span title="java.lang.String(&quot;&lt;~&quot;)" class="string">&quot;&lt;~&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

     <span class="comment">/* not really useful: V cannot be inferred because Parser is covariant in first type parameter (V is always trivially Nothing)
    def ~~ [U, V](q: =&gt; Parser[U])(implicit combine: (T, U) =&gt; V): Parser[V] = new Parser[V] {
      def apply(in: Input) = seq(Parser.this, q)((x, y) =&gt; combine(x,y))(in)
    }  */</span>   

    <span class="comment">/** A parser combinator for non-back-tracking sequential composition 
     *
     *&lt;p&gt;`p ~! q' succeeds if `p' succeeds and `q' succeeds on the input
     *          left over by `p'. In case of failure, no back-tracking is performed 
     *          (in an earlier parser produced by the | combinator).&lt;/p&gt;
     * 
     * @param q a parser that will be executed after `p' (this parser) succeeds
     * @return a `Parser' that -- on success -- returns a `~' (like a Pair, but easier to pattern match on) 
     *         that contains the result of `p' and that of `q'. 
     *         The resulting parser fails if either `p' or `q' fails, this failure is fatal.
     */</span>
    <span class="keyword">def</span> <a title="[U](p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[Parsers.this.~[T,U]]" id="460585">~!</a> <span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460587">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[U]" id="464005">p</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[Parsers.this.~[T,U]]">Parser</a><span class="delimiter">[</span>~<span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">]</span> 
      = <a href="#460272" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]] with Parsers.this.OnceParser[Parsers.this.~[T,U]]">OnceParser</a><span class="delimiter">{</span> <span class="delimiter">(</span><span class="keyword">for</span><span class="delimiter">(</span><a title="T" id="464015">a</a> &lt;- <a href="#460567" title="(f: T =&gt; Parsers.this.Parser[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]]" class="keyword">this</a>; <a title="U" id="464111">b</a> &lt;- <a href="#460277" title="(p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]">commit</a><a href="#460570" title="(f: U =&gt; Parsers.this.~[T,U])Parsers.this.Parser[Parsers.this.~[T,U]]" class="delimiter">(</a><a href="#464005" title="=&gt; Parsers.this.Parser[U]">p</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">yield</span> <span title="Parsers.this.~[T,U]" class="keyword">new</span> <a href="#460382" title="Parsers.this.~[T,U]">~</a><span class="delimiter">(</span><a href="#464015" title="T">a</a>,<a href="#464111" title="U">b</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#460564" title="(n: java.lang.String)Parsers.this.Parser[Parsers.this.~[T,U]]">named</a><span class="delimiter">(</span><span title="java.lang.String(&quot;~!&quot;)" class="string">&quot;~!&quot;</span><span class="delimiter">)</span> <span class="delimiter">}</span>
        
    <span class="comment">/** A parser combinator for alternative composition 
     *
     *&lt;p&gt;`p | q' succeeds if `p' succeeds or `q' succeeds
     *          Note that `q' is only tried if `p's failure is non-fatal (i.e., back-tracking is
     *          allowed).&lt;/p&gt;
     * 
     * @param q a parser that will be executed if `p' (this parser) fails (and allows back-tracking)
     * @return a `Parser' that returns the result of the first parser to succeed (out of `p' and `q')
     *         The resulting parser succeeds if (and only if) &lt;ul&gt;
     *           &lt;li&gt; `p' succeeds, &lt;i&gt;or&lt;/i&gt;  &lt;/li&gt;
     *           &lt;li&gt; if `p' fails allowing back-tracking and `q' succeeds. &lt;/li&gt; &lt;/ul&gt;
     */</span>
    <span class="keyword">def</span> <a title="[U &gt;: T](q: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="460588">|</a> <span class="delimiter">[</span><a title="&gt;: T &lt;: Any" id="460590">U</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[U]" id="464126">q</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#460573" title="(p0: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]">append</a><span class="delimiter">(</span><a href="#464126" title="=&gt; Parsers.this.Parser[U]">q</a><span class="delimiter">)</span>.<a href="#460564" title="(n: java.lang.String)Parsers.this.Parser[U]">named</a><span class="delimiter">(</span><span title="java.lang.String(&quot;|&quot;)" class="string">&quot;|&quot;</span><span class="delimiter">)</span>

    <span class="comment">// TODO</span>
    <span class="comment">/** A parser combinator for alternative with longest match composition 
     *
     *&lt;p&gt;`p ||| q' succeeds if `p' succeeds or `q' succeeds
     *          If `p' and `q' both succeed, the parser that consumed the most
     *          characters accepts.&lt;/p&gt;
     * 
     * @param q0 a parser that accepts if p consumes less characters. -- evaluated at most once, and only when necessary
     * @return a `Parser' that returns the result of the parser consuming the most characters (out of `p' and `q').
     */</span>
    @migration<span class="delimiter">(</span><span class="int">2</span>, <span class="int">9</span>, <span class="string">&quot;As of 2.9, the call-by-name argument is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[U &gt;: T](q0: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="460591">|||</a> <span class="delimiter">[</span><a title="&gt;: T &lt;: Any" id="460593">U</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[U]" id="464135">q0</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#464138" title="Parsers.this.Parser[U]{}" class="keyword">new</a> <a title="anonymous class $anon extends Parsers.this.Parser[U]" id="464138">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Parsers.this.Parser[U]" id="464144">q</a> = <a href="#464135" title="=&gt; Parsers.this.Parser[U]">q0</a> <span class="comment">// lazy argument</span>
      <span class="keyword">def</span> <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[U]" id="464145">apply</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="464147">in</a>: <a href="../input/Reader.scala.html#22968" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Parsers.this.ParseResult[T]" id="464152">res1</a> = <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">Parser</a>.<span class="keyword">this</span><span class="delimiter">(</span><a href="#464147" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Parsers.this.ParseResult[U]" id="464153">res2</a> = <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[U]">q</a><span class="delimiter">(</span><a href="#464147" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
        
        <a href="../../../Tuple2.scala.html#30727" title="(_1: Parsers.this.ParseResult[T], _2: Parsers.this.ParseResult[U])(Parsers.this.ParseResult[T], Parsers.this.ParseResult[U])" class="delimiter">(</a><a href="#464152" title="Parsers.this.ParseResult[T]">res1</a>, <a href="#464153" title="Parsers.this.ParseResult[U]">res2</a><span class="delimiter">)</span> <span title="Parsers.this.ParseResult[U]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Parsers.this.ParseResult[U]" class="delimiter">(</span><a title="Parsers.this.Success[T]" id="464177">s1</a> @ Success<span class="delimiter">(</span>_, <a title="Parsers.this.Input" id="464180">next1</a><span class="delimiter">)</span>, <a title="Parsers.this.Success[U]" id="464181">s2</a> @ Success<span class="delimiter">(</span>_, <a title="Parsers.this.Input" id="464184">next2</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span title="Parsers.this.ParseResult[U]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464184" title="Parsers.this.Input">next2</a>.<a href="../input/Reader.scala.html#460558" title="=&gt; scala.util.parsing.input.Position">pos</a> <a href="../input/Position.scala.html#460983" title="(that: scala.util.parsing.input.Position)Boolean">&lt;</a> <a href="#464180" title="Parsers.this.Input">next1</a>.<a href="../input/Reader.scala.html#460558" title="=&gt; scala.util.parsing.input.Position">pos</a><span class="delimiter">)</span> <a href="#464177" title="Parsers.this.Success[T]">s1</a> <span class="keyword">else</span> <a href="#464181" title="Parsers.this.Success[U]">s2</a>
          <span class="keyword">case</span> <span title="Parsers.this.Success[T]" class="delimiter">(</span><a title="Parsers.this.Success[T]" id="464187">s1</a> @ Success<span class="delimiter">(</span>_, _<span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#464187" title="Parsers.this.Success[T]">s1</a>
          <span class="keyword">case</span> <span title="Parsers.this.Success[U]" class="delimiter">(</span>_, <a title="Parsers.this.Success[U]" id="464192">s2</a> @ Success<span class="delimiter">(</span>_, _<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#464192" title="Parsers.this.Success[U]">s2</a>
          <span class="keyword">case</span> <span title="Parsers.this.Error" class="delimiter">(</span><a title="Parsers.this.Error" id="464197">e1</a> @ Error<span class="delimiter">(</span>_, _<span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#464197" title="Parsers.this.Error">e1</a>
          <span class="keyword">case</span> <span title="Parsers.this.ParseResult[U]" class="delimiter">(</span><a title="Parsers.this.Failure" id="464200">f1</a> @ Failure<span class="delimiter">(</span>_, <a title="Parsers.this.Input" id="464201">next1</a><span class="delimiter">)</span>, <a title="Parsers.this.ParseResult[U]" id="464202">ns2</a> @ <a href="#463445" title="(x: Parsers.this.ParseResult[U])Option[(String, Parsers.this.Input)]">NoSuccess</a><span class="delimiter">(</span>_, <a title="Parsers.this.Input" id="464209">next2</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span title="Parsers.this.ParseResult[U]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464209" title="Parsers.this.Input">next2</a>.<a href="../input/Reader.scala.html#460558" title="=&gt; scala.util.parsing.input.Position">pos</a> <a href="../input/Position.scala.html#460983" title="(that: scala.util.parsing.input.Position)Boolean">&lt;</a> <a href="#464201" title="Parsers.this.Input">next1</a>.<a href="../input/Reader.scala.html#460558" title="=&gt; scala.util.parsing.input.Position">pos</a><span class="delimiter">)</span> <a href="#464200" title="Parsers.this.Failure">f1</a> <span class="keyword">else</span> <a href="#464202" title="Parsers.this.ParseResult[U]">ns2</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="464146">toString</a> = <span title="java.lang.String(&quot;|||&quot;)" class="string">&quot;|||&quot;</span>
    <span class="delimiter">}</span>

    <span class="comment">/** A parser combinator for function application 
     *
     *&lt;p&gt;`p ^^ f' succeeds if `p' succeeds; it returns `f' applied to the result of `p'.&lt;/p&gt;
     *
     * @param f a function that will be applied to this parser's result (see `map' in `ParseResult').
     * @return a parser that has the same behaviour as the current parser, but whose result is
     *         transformed by `f'.
     */</span>
    <span class="keyword">def</span> <a title="[U](f: T =&gt; U)Parsers.this.Parser[U]" id="460594">^^</a> <span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460596">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; U" id="464215">f</a>: T =&gt; U<span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#460570" title="(f: T =&gt; U)Parsers.this.Parser[U]">map</a><span class="delimiter">(</span><a href="#464215" title="T =&gt; U">f</a><span class="delimiter">)</span>.<a href="#460564" title="(n: java.lang.String)Parsers.this.Parser[U]">named</a><span class="delimiter">(</span><a href="#460565" title="()java.lang.String">toString</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;^^&quot;)" class="string">&quot;^^&quot;</span><span class="delimiter">)</span>
    

    <span class="comment">/** A parser combinator that changes a successful result into the specified value.
     *
     * &lt;p&gt;`p ^^^ v' succeeds if `p' succeeds; discards its result, and returns `v` instead.&lt;/p&gt;
     * @param v The new result for the parser, evaluated at most once (if `p` succeeds), not evaluated at all if `p` fails.
     * @return a parser that has the same behaviour as the current parser, but whose successful result is `v`
     */</span>
    @migration<span class="delimiter">(</span><span class="int">2</span>, <span class="int">9</span>, <span class="string">&quot;As of 2.9, the call-by-name argument is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[U](v: =&gt; U)Parsers.this.Parser[U]" id="460597">^^^</a> <span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460599">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; U" id="464224">v</a>: =&gt; U<span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> =  <a href="#464227" title="Parsers.this.Parser[U]{lazy val v0: U}" class="keyword">new</a> <a title="anonymous class $anon extends Parsers.this.Parser[U]" id="464227">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="U" id="464230">v0</a> = <a href="#464224" title="=&gt; U">v</a> <span class="comment">// lazy argument</span>
      <span class="keyword">def</span> <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[U]" id="464231">apply</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="464232">in</a>: <a href="../input/Reader.scala.html#22968" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> = <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">Parser</a>.<span class="keyword">this</span><span class="delimiter">(</span><a href="#464232" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <a href="#461212" title="(f: T =&gt; U)Parsers.this.ParseResult[U]">map</a> <span class="delimiter">(</span><a title="T" id="464249">x</a> =&gt; <a href="#464229" title="=&gt; U">v0</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>.<a href="#460564" title="(n: java.lang.String)Parsers.this.Parser[U]{lazy val v0: U}">named</a><span class="delimiter">(</span><a href="#460565" title="()java.lang.String">toString</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;^^^&quot;)" class="string">&quot;^^^&quot;</span><span class="delimiter">)</span>
    
    <span class="comment">/** A parser combinator for partial function application 
     *
     *&lt;p&gt;`p ^? (f, error)' succeeds if `p' succeeds AND `f' is defined at the result of `p'; 
     *  in that case, it returns `f' applied to the result of `p'. If `f' is not applicable,
     *  error(the result of `p') should explain why.&lt;/p&gt;
     *
     * @param f a partial function that will be applied to this parser's result 
     *          (see `mapPartial' in `ParseResult').
     * @param error a function that takes the same argument as `f' and produces an error message 
     *        to explain why `f' wasn't applicable
     * @return a parser that succeeds if the current parser succeeds &lt;i&gt;and&lt;/i&gt; `f' is applicable 
     *         to the result. If so, the result will be transformed by `f'.     
     */</span>
    <span class="keyword">def</span> <a title="[U](f: PartialFunction[T,U], error: T =&gt; String)Parsers.this.Parser[U]" id="460600">^?</a> <span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460602">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[T,U]" id="464256">f</a>: <a href="../../../PartialFunction.scala.html#331" title="PartialFunction[T,U]">PartialFunction</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span>, <a title="T =&gt; String" id="464257">error</a>: T =&gt; String<span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#460269" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="464264">in</a> =&gt;
      <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" class="keyword">this</a><span class="delimiter">(</span><a href="#464264" title="Parsers.this.Input">in</a><span class="delimiter">)</span>.<a href="#461215" title="(f: PartialFunction[T,U], error: T =&gt; String)Parsers.this.ParseResult[U]">mapPartial</a><span class="delimiter">(</span><a href="#464256" title="PartialFunction[T,U]">f</a>, <a href="#464257" title="T =&gt; String">error</a><span class="delimiter">)</span><span class="delimiter">}</span>.<a href="#460564" title="(n: java.lang.String)Parsers.this.Parser[U]">named</a><span class="delimiter">(</span><a href="#460565" title="()java.lang.String">toString</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;^?&quot;)" class="string">&quot;^?&quot;</span><span class="delimiter">)</span>
     
    <span class="comment">/** A parser combinator for partial function application 
     *
     *&lt;p&gt;`p ^? f' succeeds if `p' succeeds AND `f' is defined at the result of `p'; 
     *  in that case, it returns `f' applied to the result of `p'.&lt;/p&gt;
     *
     * @param f a partial function that will be applied to this parser's result 
     *          (see `mapPartial' in `ParseResult').
     * @return a parser that succeeds if the current parser succeeds &lt;i&gt;and&lt;/i&gt; `f' is applicable 
     *         to the result. If so, the result will be transformed by `f'.     
     */</span>
    <span class="keyword">def</span> <a title="[U](f: PartialFunction[T,U])Parsers.this.Parser[U]" id="460603">^?</a> <span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460605">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[T,U]" id="464284">f</a>: <a href="../../../PartialFunction.scala.html#331" title="PartialFunction[T,U]">PartialFunction</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#460600" title="(f: PartialFunction[T,U], error: T =&gt; String)Parsers.this.Parser[U]">^?</a><span class="delimiter">(</span><a href="#464284" title="PartialFunction[T,U]">f</a>, <a title="T" id="464301">r</a> =&gt; <span title="java.lang.String(&quot;Constructor function not defined at &quot;)" class="string">&quot;Constructor function not defined at &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#464301" title="T">r</a><span class="delimiter">)</span>
    
       
    <span class="comment">/** A parser combinator that parameterizes a subsequent parser with the result of this one
     *
     *&lt;p&gt;
     * Use this combinator when a parser depends on the result of a previous parser. `p' should be
     * a function that takes the result from the first parser and returns the second parser.&lt;/p&gt;
     *
     *&lt;p&gt; `p into fq' (with `fq' typically `{x =&gt; q}') first applies `p', and then, if `p' successfully  
     *    returned result `r', applies `fq(r)' to the rest of the input. &lt;/p&gt;
     *
     *&lt;p&gt; From: G. Hutton. Higher-order functions for parsing. J. Funct. Program., 2(3):323--343, 1992. &lt;/p&gt;
     *
     * @param fq a function that, given the result from this parser, returns the second parser to be applied
     * @return a parser that succeeds if this parser succeeds (with result `x') and if then `fq(x)' succeeds
     */</span>
    <span class="keyword">def</span> <a title="[U](fq: T =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="460606">into</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460608">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; Parsers.this.Parser[U]" id="464304">fq</a>: T =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#460567" title="(f: T =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]">flatMap</a><span class="delimiter">(</span><a href="#464304" title="T =&gt; Parsers.this.Parser[U]">fq</a><span class="delimiter">)</span>
    
    <span class="comment">// shortcuts for combinators:</span>
    
    <span class="comment">/** Returns into(fq) */</span>
    <span class="keyword">def</span> <a title="[U](fq: T =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="460609">&gt;&gt;</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460611">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; Parsers.this.Parser[U]" id="464310">fq</a>: T =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>=<a href="#460606" title="(fq: T =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]">into</a><span class="delimiter">(</span><a href="#464310" title="T =&gt; Parsers.this.Parser[U]">fq</a><span class="delimiter">)</span>
    
    
    <span class="comment">/** Returns a parser that repeatedly parses what this parser parses
     *
     * @return rep(this) 
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Parsers.this.Parser[List[T]]" id="460612">*</a> = <a href="#460304" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]">rep</a><span class="delimiter">(</span><a href="#460275" title="Parsers.this.Parser[T]" class="keyword">this</a><span class="delimiter">)</span>
    
    <span class="comment">/** Returns a parser that repeatedly parses what this parser parses, interleaved with the `sep' parser.
     * The `sep' parser specifies how the results parsed by this parser should be combined.
     *
     * @return chainl1(this, sep) 
     */</span>    
    <span class="keyword">def</span> <a title="[U &gt;: T](sep: =&gt; Parsers.this.Parser[(U, U) =&gt; U])Parsers.this.Parser[U]" id="460613">*</a><span class="delimiter">[</span><a title="&gt;: T &lt;: Any" id="460615">U</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[(U, U) =&gt; U]" id="464326">sep</a>: =&gt; Parser<span class="delimiter">[</span><span class="delimiter">(</span>U, U<span class="delimiter">)</span> =&gt; U<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#460322" title="(p: =&gt; Parsers.this.Parser[U], q: =&gt; Parsers.this.Parser[(U, U) =&gt; U])Parsers.this.Parser[U]">chainl1</a><span class="delimiter">(</span><a href="#460275" title="Parsers.this.Parser[T]" class="keyword">this</a>, <a href="#464326" title="=&gt; Parsers.this.Parser[(U, U) =&gt; U]">sep</a><span class="delimiter">)</span>
    
    <span class="comment">// TODO: improve precedence? a ~ b*(&quot;,&quot;) = a ~ (b*(&quot;,&quot;))  should be true </span>
    
    <span class="comment">/** Returns a parser that repeatedly (at least once) parses what this parser parses.
     *
     * @return rep1(this) 
     */</span>      
    <span class="keyword">def</span> <a title="=&gt; Parsers.this.Parser[List[T]]" id="460616">+</a> = <a href="#460310" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]">rep1</a><span class="delimiter">(</span><a href="#460275" title="Parsers.this.Parser[T]" class="keyword">this</a><span class="delimiter">)</span>
    
    <span class="comment">/** Returns a parser that optionally parses what this parser parses.
     *
     * @return opt(this) 
     */</span>       
    <span class="keyword">def</span> <a title="=&gt; Parsers.this.Parser[Option[T]]" id="460617">?</a> = <a href="#460335" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[Option[T]]">opt</a><span class="delimiter">(</span><a href="#460275" title="Parsers.this.Parser[T]" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/** Wrap a parser so that its failures become errors (the | combinator will give up as soon as 
   *  it encounters an error, on failure it simply tries the next alternative) 
   */</span>
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]" id="460277">commit</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460279">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="464016">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#460269" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="464022">in</a> =&gt;
    <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a><span class="delimiter">(</span><a href="#464022" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <span title="&lt;none&gt; extends Product with Serializable with Parsers.this.ParseResult[T]" class="keyword">match</span><span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Parsers.this.Success[T]" id="464031">s</a> @ Success<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#464031" title="Parsers.this.Success[T]">s</a>
      <span class="keyword">case</span> <a title="Parsers.this.Error" id="464034">e</a> @ Error<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#464034" title="Parsers.this.Error">e</a>
      <span class="keyword">case</span> <a title="Parsers.this.Error" id="464035">f</a> @ Failure<span class="delimiter">(</span><a title="String" id="464036">msg</a>, <a title="Parsers.this.Input" id="464037">next</a><span class="delimiter">)</span> =&gt; <a href="#462547" title="(msg: String, next: Parsers.this.Input)Parsers.this.Error">Error</a><span class="delimiter">(</span><a href="#464036" title="String">msg</a>, <a href="#464037" title="Parsers.this.Input">next</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
	<span class="comment">/*trait ElemFun
  case class EFCons(hd: Elem =&gt; ElemFun, tl: ElemFun) extends ElemFun
  case class EFNil(res: Boolean) extends ElemFun*/</span>

   
  <span class="comment">/** A parser matching input elements that satisfy a given predicate
   *
   * &lt;p&gt;elem(kind, p) succeeds if the input starts with an element `e' for which p(e) is true.&lt;/p&gt;
   *
   * @param  kind   The element kind, used for error messages
   * @param  p      A predicate that determines which elements match.
   * @return 
   */</span>
  <span class="keyword">def</span> <a title="(kind: String, p: Parsers.this.Elem =&gt; Boolean)Parsers.this.Parser[Parsers.this.Elem]" id="460280">elem</a><span class="delimiter">(</span><a title="String" id="464393">kind</a>: <span title="String">String</span>, <a title="Parsers.this.Elem =&gt; Boolean" id="464394">p</a>: Elem =&gt; Boolean<span class="delimiter">)</span> = <a href="#460289" title="(p: Parsers.this.Elem =&gt; Boolean)(err: Parsers.this.Elem =&gt; String)Parsers.this.Parser[Parsers.this.Elem]">acceptIf</a><span class="delimiter">(</span><a href="#464394" title="Parsers.this.Elem =&gt; Boolean">p</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Parsers.this.Elem" id="464401">inEl</a> =&gt; <a href="#464393" title="String">kind</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; expected&quot;)" class="string">&quot; expected&quot;</span><span class="delimiter">)</span>
   
  <span class="comment">/** A parser that matches only the given element `e'
   *
   * &lt;p&gt;elem(e) succeeds if the input starts with an element `e'&lt;/p&gt;
   *
   * @param e the `Elem' that must be the next piece of input for the returned parser to succeed
   * @return a `Parser' that succeeds if `e' is the next available input (and returns it).
   */</span>
  <span class="keyword">def</span> <a title="(e: Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]" id="460281">elem</a><span class="delimiter">(</span><a title="Parsers.this.Elem" id="464402">e</a>: <a href="#460249" title="Parsers.this.Elem">Elem</a><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[Parsers.this.Elem]">Parser</a><span class="delimiter">[</span>Elem<span class="delimiter">]</span> = <a href="#460282" title="implicit scala.util.parsing.combinator.Parsers.accept : (e: Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]">accept</a><span class="delimiter">(</span><a href="#464402" title="Parsers.this.Elem">e</a><span class="delimiter">)</span>
  
  
  <span class="comment">/** A parser that matches only the given element `e' 
   *&lt;p&gt;
   * The method is implicit so that elements can automatically be lifted to their parsers. 
   * For example, when parsing `Token's, Identifier(&quot;new&quot;) (which is a `Token') can be used directly,
   * instead of first creating a `Parser' using accept(Identifier(&quot;new&quot;)).&lt;/p&gt;
   *
   * @param e the `Elem' that must be the next piece of input for the returned parser to succeed
   * @return a `tParser' that succeeds if `e' is the next available input.
   */</span>
   
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit scala.util.parsing.combinator.Parsers.accept : (e: Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]" id="460282">accept</a><span class="delimiter">(</span><a title="Parsers.this.Elem" id="460626">e</a>: <a href="#460249" title="Parsers.this.Elem">Elem</a><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[Parsers.this.Elem]">Parser</a><span class="delimiter">[</span>Elem<span class="delimiter">]</span> = <a href="#460289" title="(p: Parsers.this.Elem =&gt; Boolean)(err: Parsers.this.Elem =&gt; String)Parsers.this.Parser[Parsers.this.Elem]">acceptIf</a><span class="delimiter">(</span><a href="#464427" title="Parsers.this.Elem">_</a> <span title="(x$1: Any)Boolean">==</span> <a href="#460626" title="Parsers.this.Elem">e</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="java.lang.String(&quot;`&quot;)" class="string">&quot;`&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#460626" title="Parsers.this.Elem">e</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;\' expected but &quot;)" class="string">&quot;' expected but &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#464429" title="Parsers.this.Elem">_</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; found&quot;)" class="string">&quot; found&quot;</span><span class="delimiter">)</span>
  
  <span class="comment">/** A parser that matches only the given list of element `es'
   *
   * &lt;p&gt;accept(es) succeeds if the input subsequently provides the elements in the list `es'.&lt;/p&gt;
   *
   * @param  es the list of expected elements
   * @return a Parser that recognizes a specified list of elements
   */</span>
  <span class="keyword">def</span> <a title="[ES](es: ES)(implicit evidence$1: ES =&gt; List[Parsers.this.Elem])Parsers.this.Parser[List[Parsers.this.Elem]]" id="464417">accept</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460285">ES</a> &lt;% List<span class="delimiter">[</span>Elem<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="ES" id="464416">es</a>: <a href="#460285" title="ES">ES</a><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[List[Parsers.this.Elem]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Elem<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#464431" title="(es: ES)(implicit evidence$2: ES =&gt; Iterable[Parsers.this.Elem])Parsers.this.Parser[List[Parsers.this.Elem]]">acceptSeq</a><a href="#464417" title="ES =&gt; List[Parsers.this.Elem]" class="delimiter">(</a><a href="#464416" title="ES">es</a><span class="delimiter">)</span>

  <span class="comment">/** The parser that matches an element in the domain of the partial function `f'
   *&lt;p&gt;
   * If `f' is defined on the first element in the input, `f' is applied to it to produce 
   * this parser's result.&lt;/p&gt;
   *&lt;p&gt;
   * Example: The parser &lt;code&gt;accept(&quot;name&quot;, {case Identifier(n) =&gt; Name(n)})&lt;/code&gt; 
   *          accepts an &lt;code&gt;Identifier(n)&lt;/code&gt; and returns a &lt;code&gt;Name(n)&lt;/code&gt;.&lt;/p&gt;
   *
   * @param expected a description of the kind of element this parser expects (for error messages)
   * @param f a partial function that determines when this parser is successful and what its output is
   * @return A parser that succeeds if `f' is applicable to the first element of the input, 
   *         applying `f' to it to produce the result.
   */</span>
  <span class="keyword">def</span> <a title="[U](expected: String, f: PartialFunction[Parsers.this.Elem,U])Parsers.this.Parser[U]" id="460286">accept</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460288">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="464408">expected</a>: <span title="String">String</span>, <a title="PartialFunction[Parsers.this.Elem,U]" id="464409">f</a>: <a href="../../../PartialFunction.scala.html#331" title="PartialFunction[Parsers.this.Elem,U]">PartialFunction</a><span class="delimiter">[</span>Elem, U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#460290" title="(expected: String, f: PartialFunction[Parsers.this.Elem,U])Parsers.this.Parser[U]">acceptMatch</a><span class="delimiter">(</span><a href="#464408" title="String">expected</a>, <a href="#464409" title="PartialFunction[Parsers.this.Elem,U]">f</a><span class="delimiter">)</span>


  <span class="keyword">def</span> <a title="(p: Parsers.this.Elem =&gt; Boolean)(err: Parsers.this.Elem =&gt; String)Parsers.this.Parser[Parsers.this.Elem]" id="460289">acceptIf</a><span class="delimiter">(</span><a title="Parsers.this.Elem =&gt; Boolean" id="464397">p</a>: Elem =&gt; Boolean<span class="delimiter">)</span><span class="delimiter">(</span><a title="Parsers.this.Elem =&gt; String" id="464398">err</a>: Elem =&gt; String<span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[Parsers.this.Elem]">Parser</a><span class="delimiter">[</span>Elem<span class="delimiter">]</span> = <a href="#460269" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[Parsers.this.Elem])Parsers.this.Parser[Parsers.this.Elem]">Parser</a> <span class="delimiter">{</span> <a title="Parsers.this.Input" id="464459">in</a> =&gt;
    <span title="Parsers.this.ParseResult[Parsers.this.Elem]" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Function1.scala.html#30790" title="(v1: Parsers.this.Elem)Boolean">p</a><span class="delimiter">(</span><a href="#464459" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#460555" title="=&gt; Parsers.this.Elem">first</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#461208" title="(result: Parsers.this.Elem, next: Parsers.this.Input)Parsers.this.Success[Parsers.this.Elem]">Success</a><span class="delimiter">(</span><a href="#464459" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#460555" title="=&gt; Parsers.this.Elem">first</a>, <a href="#464459" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#460556" title="=&gt; scala.util.parsing.input.Reader[Parsers.this.Elem]">rest</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <a href="#461337" title="(msg: String, next: Parsers.this.Input)Parsers.this.Failure">Failure</a><span class="delimiter">(</span><a href="../../../Function1.scala.html#30790" title="(v1: Parsers.this.Elem)String">err</a><span class="delimiter">(</span><a href="#464459" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#460555" title="=&gt; Parsers.this.Elem">first</a><span class="delimiter">)</span>, <a href="#464459" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">def</span> <a title="[U](expected: String, f: PartialFunction[Parsers.this.Elem,U])Parsers.this.Parser[U]" id="460290">acceptMatch</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460292">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="464446">expected</a>: <span title="String">String</span>, <a title="PartialFunction[Parsers.this.Elem,U]" id="464447">f</a>: <a href="../../../PartialFunction.scala.html#331" title="PartialFunction[Parsers.this.Elem,U]">PartialFunction</a><span class="delimiter">[</span>Elem, U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#460269" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="464473">in</a> =&gt; 
    <span title="Parsers.this.ParseResult[U]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464447" title="PartialFunction[Parsers.this.Elem,U]">f</a>.<a href="../../../PartialFunction.scala.html#30799" title="(x: Parsers.this.Elem)Boolean">isDefinedAt</a><span class="delimiter">(</span><a href="#464473" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#460555" title="=&gt; Parsers.this.Elem">first</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#461208" title="(result: U, next: Parsers.this.Input)Parsers.this.Success[U]">Success</a><span class="delimiter">(</span><a href="../../../Function1.scala.html#30790" title="(v1: Parsers.this.Elem)U">f</a><span class="delimiter">(</span><a href="#464473" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#460555" title="=&gt; Parsers.this.Elem">first</a><span class="delimiter">)</span>, <a href="#464473" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#460556" title="=&gt; scala.util.parsing.input.Reader[Parsers.this.Elem]">rest</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <a href="#461337" title="(msg: String, next: Parsers.this.Input)Parsers.this.Failure">Failure</a><span class="delimiter">(</span><a href="#464446" title="String">expected</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; expected&quot;)" class="string">&quot; expected&quot;</span>, <a href="#464473" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">def</span> <a title="[ES](es: ES)(implicit evidence$2: ES =&gt; Iterable[Parsers.this.Elem])Parsers.this.Parser[List[Parsers.this.Elem]]" id="464431">acceptSeq</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460295">ES</a> &lt;% Iterable<span class="delimiter">[</span>Elem<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="ES" id="464430">es</a>: <a href="#460295" title="ES">ES</a><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[List[Parsers.this.Elem]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Elem<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="../../../Function1.scala.html#30790" title="(v1: ES)Iterable[Parsers.this.Elem]">es</a>.<a href="../../../collection/IterableLike.scala.html#31200" title="[B](z: B)(op: (Parsers.this.Elem, B) =&gt; B)B">foldRight</a><span title="(z: Parsers.this.Parser[List[Parsers.this.Elem]])(op: (Parsers.this.Elem, Parsers.this.Parser[List[Parsers.this.Elem]]) =&gt; Parsers.this.Parser[List[Parsers.this.Elem]])Parsers.this.Parser[List[Parsers.this.Elem]]" class="delimiter">[</span><a href="#460275" title="Parsers.this.Parser[List[Parsers.this.Elem]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Elem<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#460298" title="(v: scala.collection.immutable.Nil.type)Parsers.this.Parser[scala.collection.immutable.Nil.type]">success</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#13695" title="object Nil">Nil</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">{</span><span class="delimiter">(</span><a title="Parsers.this.Elem" id="464995">x</a>, <a title="Parsers.this.Parser[List[Parsers.this.Elem]]" id="464996">pxs</a><span class="delimiter">)</span> =&gt; <a href="#460282" title="implicit scala.util.parsing.combinator.Parsers.accept : (e: Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]">accept</a><span class="delimiter">(</span><a href="#464995" title="Parsers.this.Elem">x</a><span class="delimiter">)</span> <a href="#460576" title="(q: =&gt; Parsers.this.Parser[List[Parsers.this.Elem]])Parsers.this.Parser[Parsers.this.~[Parsers.this.Elem,List[Parsers.this.Elem]]]">~</a> <a href="#464996" title="Parsers.this.Parser[List[Parsers.this.Elem]]">pxs</a> <a href="#460594" title="(f: Parsers.this.~[Parsers.this.Elem,List[Parsers.this.Elem]] =&gt; List[Parsers.this.Elem])Parsers.this.Parser[List[Parsers.this.Elem]]">^^</a> <a href="#460350" title="Parsers.this.~[Parsers.this.Elem,List[Parsers.this.Elem]] =&gt; List[Parsers.this.Elem]">mkList</a><span class="delimiter">}</span>

  <span class="comment">/** A parser that always fails 
   *
   * @param msg The error message describing the failure. 
   * @return A parser that always fails with the specified error message.
   */</span>
  <span class="keyword">def</span> <a title="(msg: String)Parsers.this.Parser[Nothing]" id="460296">failure</a><span class="delimiter">(</span><a title="String" id="465051">msg</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#460269" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[Nothing])Parsers.this.Parser[Nothing]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="465057">in</a> =&gt; <a href="#461337" title="(msg: String, next: Parsers.this.Input)Parsers.this.Failure">Failure</a><span class="delimiter">(</span><a href="#465051" title="String">msg</a>, <a href="#465057" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="comment">/** A parser that results in an error 
   *
   * @param msg The error message describing the failure. 
   * @return A parser that always fails with the specified error message.
   */</span>  
  <span class="keyword">def</span> <a title="(msg: String)Parsers.this.Parser[Nothing]" id="460297">err</a><span class="delimiter">(</span><a title="String" id="465059">msg</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#460269" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[Nothing])Parsers.this.Parser[Nothing]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="465065">in</a> =&gt; <a href="#462547" title="(msg: String, next: Parsers.this.Input)Parsers.this.Error">Error</a><span class="delimiter">(</span><a href="#465059" title="String">msg</a>, <a href="#465065" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <span class="delimiter">}</span>


  <span class="comment">/** A parser that always succeeds 
   *
   * @param v The result for the parser
   * @return A parser that always succeeds, with the given result `v'
   */</span>
  <span class="keyword">def</span> <a title="[T](v: T)Parsers.this.Parser[T]" id="460298">success</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460300">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="464972">v</a>: <a href="#460300" title="T">T</a><span class="delimiter">)</span> = <a href="#460269" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="464978">in</a> =&gt; <a href="#461208" title="(result: T, next: Parsers.this.Input)Parsers.this.Success[T]">Success</a><span class="delimiter">(</span><a href="#464972" title="T">v</a>, <a href="#464978" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T])(name: String)Parsers.this.Parser[T]" id="460301">log</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460303">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="465069">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="String" id="465070">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#460269" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="465076">in</a> =&gt;
    <a href="../../../Predef.scala.html#9588" title="(x: Any)Unit">println</a><span class="delimiter">(</span><span title="java.lang.String(&quot;trying &quot;)" class="string">&quot;trying &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#465070" title="String">name</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; at &quot;)" class="string">&quot; at &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#465076" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Parsers.this.ParseResult[T]" id="465077">r</a> = <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a><span class="delimiter">(</span><a href="#465076" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
    <a href="../../../Predef.scala.html#9588" title="(x: Any)Unit">println</a><span class="delimiter">(</span><a href="#465070" title="String">name</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; --&gt; &quot;)" class="string">&quot; --&gt; &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#465077" title="Parsers.this.ParseResult[T]">r</a><span class="delimiter">)</span>
    <a href="#465077" title="Parsers.this.ParseResult[T]">r</a>
  <span class="delimiter">}</span>
  
  <span class="comment">/** A parser generator for repetitions.
   *  
   * &lt;p&gt; rep(p)   repeatedly uses `p' to parse the input until `p' fails (the result is a List 
   *  of the consecutive results of `p') &lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @return A parser that returns a list of results produced by repeatedly applying `p' to the input.
   */</span>
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]" id="460304">rep</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460306">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="464320">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[List[T]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#460310" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]">rep1</a><span class="delimiter">(</span><a href="#464320" title="=&gt; Parsers.this.Parser[T]">p</a><span class="delimiter">)</span> <a href="#460588" title="(q: =&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[List[T]]">|</a> <a href="#460298" title="(v: List[Nothing])Parsers.this.Parser[List[Nothing]]">success</a><span class="delimiter">(</span>List<a href="../../../collection/immutable/List.scala.html#13695" title="object Nil" class="delimiter">(</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** A parser generator for interleaved repetitions.
   *  
   * &lt;p&gt; repsep(p, q)   repeatedly uses `p' interleaved with `q' to parse the input, until `p' fails.
   *  (The result is a `List' of the results of `p'.) &lt;/p&gt;
   *
   * &lt;p&gt;Example: &lt;code&gt;repsep(term, &quot;,&quot;)&lt;/code&gt; parses a comma-separated list of term's, 
   *          yielding a list of these terms&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @param q a `Parser' that parses the elements that separate the elements parsed by `p'
   * @return A parser that returns a list of results produced by repeatedly applying `p' (interleaved
   *         with `q') to the input. 
   *         The results of `p' are collected in a list. The results of `q' are discarded.    
   */</span>
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T], q: =&gt; Parsers.this.Parser[Any])Parsers.this.Parser[List[T]]" id="460307">repsep</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460309">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="465123">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="=&gt; Parsers.this.Parser[Any]" id="465124">q</a>: =&gt; Parser<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[List[T]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = 
    <a href="#460319" title="(p: =&gt; Parsers.this.Parser[T], q: =&gt; Parsers.this.Parser[Any])Parsers.this.Parser[List[T]]">rep1sep</a><span class="delimiter">(</span><a href="#465123" title="=&gt; Parsers.this.Parser[T]">p</a>, <a href="#465124" title="=&gt; Parsers.this.Parser[Any]">q</a><span class="delimiter">)</span> <a href="#460588" title="(q: =&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[List[T]]">|</a> <a href="#460298" title="(v: List[Nothing])Parsers.this.Parser[List[Nothing]]">success</a><span class="delimiter">(</span>List<a href="../../../collection/immutable/List.scala.html#13695" title="object Nil" class="delimiter">(</a><span class="delimiter">)</span><span class="delimiter">)</span>
  
  <span class="comment">/** A parser generator for non-empty repetitions.
   *  
   * &lt;p&gt; rep1(p) repeatedly uses `p' to parse the input until `p' fails -- `p' must succeed at least
   *             once (the result is a `List' of the consecutive results of `p')&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @return A parser that returns a list of results produced by repeatedly applying `p' to the input
   *        (and that only succeeds if `p' matches at least once).
   */</span>
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]" id="460310">rep1</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460312">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="464374">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[List[T]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#460313" title="(first: =&gt; Parsers.this.Parser[T], p0: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]">rep1</a><span class="delimiter">(</span><a href="#464374" title="=&gt; Parsers.this.Parser[T]">p</a>, <a href="#464374" title="=&gt; Parsers.this.Parser[T]">p</a><span class="delimiter">)</span>
  
  <span class="comment">/** A parser generator for non-empty repetitions.
   *  
   * &lt;p&gt; rep1(f, p) first uses `f' (which must succeed) and then repeatedly uses `p' to 
   *     parse the input until `p' fails 
   *     (the result is a `List' of the consecutive results of `f' and `p')&lt;/p&gt;
   *
   * @param first a `Parser' that parses the first piece of input
   * @param p0 a `Parser' that is to be applied successively to the rest of the input (if any) -- evaluated at most once, and only when necessary
   * @return A parser that returns a list of results produced by first applying `f' and then 
   *         repeatedly `p' to the input (it only succeeds if `f' matches).
   */</span>
  @migration<span class="delimiter">(</span><span class="int">2</span>, <span class="int">9</span>, <span class="string">&quot;As of 2.9, the p0 call-by-name arguments is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.&quot;</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[T](first: =&gt; Parsers.this.Parser[T], p0: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]" id="460313">rep1</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460315">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="464366">first</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="=&gt; Parsers.this.Parser[T]" id="464367">p0</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[List[T]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#460269" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[List[T]])Parsers.this.Parser[List[T]]">Parser</a> <span class="delimiter">{</span> <a title="Parsers.this.Input" id="465180">in</a> =&gt;
    <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Parsers.this.Parser[T]" id="465182">p</a> = <a href="#464367" title="=&gt; Parsers.this.Parser[T]">p0</a> <span class="comment">// lazy argument</span>
    <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[T]" id="465183">elems</a> = <span title="scala.collection.mutable.ListBuffer[T]" class="keyword">new</span> <a href="../../../collection/mutable/ListBuffer.scala.html#15368" title="scala.collection.mutable.ListBuffer[T]">ListBuffer</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

    <span class="keyword">def</span> <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[List[T]]" id="465184">continue</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="465185">in</a>: <a href="../input/Reader.scala.html#22968" title="Parsers.this.Input">Input</a><span class="delimiter">)</span>: <a href="#460251" title="Parsers.this.ParseResult[List[T]]">ParseResult</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Parsers.this.Parser[T]" id="465186">p0</a> = <a href="#465181" title="=&gt; Parsers.this.Parser[T]">p</a>    <span class="comment">// avoid repeatedly re-evaluating by-name parser</span>
      @tailrec <span class="keyword">def</span> <a title="(in0: Parsers.this.Input)Parsers.this.ParseResult[List[T]]" id="465187">applyp</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="465188">in0</a>: <a href="../input/Reader.scala.html#22968" title="Parsers.this.Input">Input</a><span class="delimiter">)</span>: <a href="#460251" title="Parsers.this.ParseResult[List[T]]">ParseResult</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p0</a><span class="delimiter">(</span><a href="#465188" title="Parsers.this.Input">in0</a><span class="delimiter">)</span> <span title="Parsers.this.ParseResult[List[T]]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Parsers.this.ParseResult[List[T]]">Success</span><span class="delimiter">(</span><a title="T" id="465198">x</a>, <a title="Parsers.this.Input" id="465199">rest</a><span class="delimiter">)</span> =&gt; <a href="#465183" title="scala.collection.mutable.ListBuffer[T]">elems</a> <a href="../../../collection/mutable/ListBuffer.scala.html#39118" title="(x: T)elems.type">+=</a> <a href="#465198" title="T">x</a> ; <a href="#465187" title="(in0: Parsers.this.Input)Parsers.this.ParseResult[List[T]]">applyp</a><span class="delimiter">(</span><a href="#465199" title="Parsers.this.Input">rest</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Parsers.this.Success[List[T]]">_</span>                =&gt; <a href="#461208" title="(result: List[T], next: Parsers.this.Input)Parsers.this.Success[List[T]]">Success</a><span class="delimiter">(</span><a href="#465183" title="scala.collection.mutable.ListBuffer[T]">elems</a>.<a href="../../../collection/mutable/ListBuffer.scala.html#39126" title="=&gt; List[T]">toList</a>, <a href="#465188" title="Parsers.this.Input">in0</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      
      <a href="#465187" title="(in0: Parsers.this.Input)Parsers.this.ParseResult[List[T]]">applyp</a><span class="delimiter">(</span><a href="#465185" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">first</a><span class="delimiter">(</span><a href="#465180" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <span title="Parsers.this.ParseResult[List[T]]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Parsers.this.ParseResult[List[T]]">Success</span><span class="delimiter">(</span><a title="T" id="465226">x</a>, <a title="Parsers.this.Input" id="465227">rest</a><span class="delimiter">)</span> =&gt; <a href="#465183" title="scala.collection.mutable.ListBuffer[T]">elems</a> <a href="../../../collection/mutable/ListBuffer.scala.html#39118" title="(x: T)elems.type">+=</a> <a href="#465226" title="T">x</a> ; <a href="#465184" title="(in: Parsers.this.Input)Parsers.this.ParseResult[List[T]]">continue</a><span class="delimiter">(</span><a href="#465227" title="Parsers.this.Input">rest</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Parsers.this.NoSuccess" id="465230">ns</a>: <a href="#460260" title="Parsers.this.NoSuccess">NoSuccess</a>    =&gt; <a href="#465230" title="Parsers.this.NoSuccess">ns</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A parser generator for a specified number of repetitions.
   *  
   * &lt;p&gt; repN(n, p)  uses `p' exactly `n' time to parse the input 
   *       (the result is a `List' of the `n' consecutive results of `p')&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @param n the exact number of times `p' must succeed
   * @return A parser that returns a list of results produced by repeatedly applying `p' to the input
   *        (and that only succeeds if `p' matches exactly `n' times).
   */</span>  
  <span class="keyword">def</span> <a title="[T](num: Int, p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]" id="460316">repN</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460318">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="465232">num</a>: <a href="../../../Int.scala.html#382" title="Int">Int</a>, <a title="=&gt; Parsers.this.Parser[T]" id="465233">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[List[T]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = 
    <span title="Parsers.this.Parser[List[T]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#465232" title="Int">num</a> <a href="../../../Int.scala.html#32084" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#460298" title="(v: scala.collection.immutable.Nil.type)Parsers.this.Parser[scala.collection.immutable.Nil.type]">success</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#13695" title="object Nil">Nil</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#460269" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[List[T]])Parsers.this.Parser[List[T]]">Parser</a> <span class="delimiter">{</span> <a title="Parsers.this.Input" id="465252">in</a> =&gt;
      <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[T]" id="465253">elems</a> = <span title="scala.collection.mutable.ListBuffer[T]" class="keyword">new</span> <a href="../../../collection/mutable/ListBuffer.scala.html#15368" title="scala.collection.mutable.ListBuffer[T]">ListBuffer</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
      <span class="keyword">val</span> <a title="Parsers.this.Parser[T]" id="465254">p0</a> = <a href="#465233" title="=&gt; Parsers.this.Parser[T]">p</a>    <span class="comment">// avoid repeatedly re-evaluating by-name parser</span>
      
      @tailrec <span class="keyword">def</span> <a title="(in0: Parsers.this.Input)Parsers.this.ParseResult[List[T]]" id="465255">applyp</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="465256">in0</a>: <a href="../input/Reader.scala.html#22968" title="Parsers.this.Input">Input</a><span class="delimiter">)</span>: <a href="#460251" title="Parsers.this.ParseResult[List[T]]">ParseResult</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
        <span title="Parsers.this.ParseResult[List[T]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#465253" title="scala.collection.mutable.ListBuffer[T]">elems</a>.<a href="../../../collection/mutable/ListBuffer.scala.html#39115" title="=&gt; Int">length</a> <a href="../../../Int.scala.html#32084" title="(x: Int)Boolean">==</a> <a href="#465232" title="Int">num</a><span class="delimiter">)</span> <a href="#461208" title="(result: List[T], next: Parsers.this.Input)Parsers.this.Success[List[T]]">Success</a><span class="delimiter">(</span><a href="#465253" title="scala.collection.mutable.ListBuffer[T]">elems</a>.<a href="../../../collection/mutable/ListBuffer.scala.html#39126" title="=&gt; List[T]">toList</a>, <a href="#465256" title="Parsers.this.Input">in0</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p0</a><span class="delimiter">(</span><a href="#465256" title="Parsers.this.Input">in0</a><span class="delimiter">)</span> <span title="Parsers.this.ParseResult[List[T]]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Parsers.this.ParseResult[List[T]]">Success</span><span class="delimiter">(</span><a title="T" id="465278">x</a>, <a title="Parsers.this.Input" id="465279">rest</a><span class="delimiter">)</span>   =&gt; <a href="#465253" title="scala.collection.mutable.ListBuffer[T]">elems</a> <a href="../../../collection/mutable/ListBuffer.scala.html#39118" title="(x: T)elems.type">+=</a> <a href="#465278" title="T">x</a> ; <a href="#465255" title="(in0: Parsers.this.Input)Parsers.this.ParseResult[List[T]]">applyp</a><span class="delimiter">(</span><a href="#465279" title="Parsers.this.Input">rest</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <a title="Nothing" id="465289">ns</a>: <a href="#460260" title="Parsers.this.NoSuccess">NoSuccess</a>      =&gt; <span title="Nothing" class="keyword">return</span> <a href="#465289" title="Parsers.this.NoSuccess">ns</a>
        <span class="delimiter">}</span>
      
      <a href="#465255" title="(in0: Parsers.this.Input)Parsers.this.ParseResult[List[T]]">applyp</a><span class="delimiter">(</span><a href="#465252" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  
  <span class="comment">/** A parser generator for non-empty repetitions.
   *  
   *  &lt;p&gt;rep1sep(p, q) repeatedly applies `p' interleaved with `q' to parse the input, until `p' fails.
   *                The parser `p' must succeed at least once.&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @param q a `Parser' that parses the elements that separate the elements parsed by `p' 
   *          (interleaved with `q')   
   * @return A parser that returns a list of results produced by repeatedly applying `p' to the input
   *         (and that only succeeds if `p' matches at least once).
   *         The results of `p' are collected in a list. The results of `q' are discarded.    
   */</span>
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T], q: =&gt; Parsers.this.Parser[Any])Parsers.this.Parser[List[T]]" id="460319">rep1sep</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460321">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="465128">p</a> : =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="=&gt; Parsers.this.Parser[Any]" id="465129">q</a> : =&gt; Parser<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[List[T]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = 
    <a href="#465128" title="=&gt; Parsers.this.Parser[T]">p</a> <a href="#460576" title="(q: =&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[Parsers.this.~[T,List[T]]]">~</a> <a href="#460304" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]">rep</a><span class="delimiter">(</span><a href="#465129" title="=&gt; Parsers.this.Parser[Any]">q</a> <a href="#460579" title="(q: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]">~&gt;</a> <a href="#465128" title="=&gt; Parsers.this.Parser[T]">p</a><span class="delimiter">)</span> <a href="#460594" title="(f: Parsers.this.~[T,List[T]] =&gt; List[T])Parsers.this.Parser[List[T]]">^^</a> <a href="#465309" title="List[T]" class="delimiter">{</a><span class="keyword">case</span> <a title="List[T]" id="465312">x</a>~<a title="List[T]" id="465313">y</a> =&gt; <a href="#465312" title="T">x</a><a href="../../../collection/immutable/List.scala.html#26477" title="(x: T)List[T]">::</a><a href="#465313" title="List[T]">y</a><span class="delimiter">}</span> 
   

  <span class="comment">/** A parser generator that, roughly, generalises the rep1sep generator so that `q', which parses the separator,
   * produces a left-associative function that combines the elements it separates.
   *
   * &lt;p&gt; From: J. Fokker. Functional parsers. In J. Jeuring and E. Meijer, editors, Advanced Functional Programming, volume 925 of Lecture Notes in Computer Science, pages 1--23. Springer, 1995.&lt;/p&gt;
   *
   * @param p a parser that parses the elements
   * @param q a parser that parses the token(s) separating the elements, yielding a left-associative function that 
   *          combines two elements into one 
   */</span>
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T], q: =&gt; Parsers.this.Parser[(T, T) =&gt; T])Parsers.this.Parser[T]" id="460322">chainl1</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460324">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="464345">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="=&gt; Parsers.this.Parser[(T, T) =&gt; T]" id="464346">q</a>: =&gt; Parser<span class="delimiter">[</span><span class="delimiter">(</span>T, T<span class="delimiter">)</span> =&gt; T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>  
    = <a href="#460325" title="(first: =&gt; Parsers.this.Parser[T], p: =&gt; Parsers.this.Parser[T], q: =&gt; Parsers.this.Parser[(T, T) =&gt; T])Parsers.this.Parser[T]">chainl1</a><span class="delimiter">(</span><a href="#464345" title="=&gt; Parsers.this.Parser[T]">p</a>, <a href="#464345" title="=&gt; Parsers.this.Parser[T]">p</a>, <a href="#464346" title="=&gt; Parsers.this.Parser[(T, T) =&gt; T]">q</a><span class="delimiter">)</span>

  <span class="comment">/** A parser generator that, roughly, generalises the rep1sep generator so that `q', which parses the separator,
   * produces a left-associative function that combines the elements it separates.
   *
   * @param first a parser that parses the first element
   * @param p a parser that parses the subsequent elements
   * @param q a parser that parses the token(s) separating the elements, yielding a left-associative function that 
   *          combines two elements into one 
   */</span>
  <span class="keyword">def</span> <a title="[T, U](first: =&gt; Parsers.this.Parser[T], p: =&gt; Parsers.this.Parser[U], q: =&gt; Parsers.this.Parser[(T, U) =&gt; T])Parsers.this.Parser[T]" id="460325">chainl1</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460328">T</a>, <a title="&gt;: Nothing &lt;: Any" id="460329">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="464333">first</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="=&gt; Parsers.this.Parser[U]" id="464334">p</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span>, <a title="=&gt; Parsers.this.Parser[(T, U) =&gt; T]" id="464335">q</a>: =&gt; Parser<span class="delimiter">[</span><span class="delimiter">(</span>T, U<span class="delimiter">)</span> =&gt; T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> 
    = <a href="#464333" title="=&gt; Parsers.this.Parser[T]">first</a> <a href="#460576" title="(q: =&gt; Parsers.this.Parser[List[Parsers.this.~[(T, U) =&gt; T,U]]])Parsers.this.Parser[Parsers.this.~[T,List[Parsers.this.~[(T, U) =&gt; T,U]]]]">~</a> <a href="#460304" title="(p: =&gt; Parsers.this.Parser[Parsers.this.~[(T, U) =&gt; T,U]])Parsers.this.Parser[List[Parsers.this.~[(T, U) =&gt; T,U]]]">rep</a><span class="delimiter">(</span><a href="#464335" title="=&gt; Parsers.this.Parser[(T, U) =&gt; T]">q</a> <a href="#460576" title="(q: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[Parsers.this.~[(T, U) =&gt; T,U]]">~</a> <a href="#464334" title="=&gt; Parsers.this.Parser[U]">p</a><span class="delimiter">)</span> <a href="#460594" title="(f: Parsers.this.~[T,List[Parsers.this.~[(T, U) =&gt; T,U]]] =&gt; T)Parsers.this.Parser[T]">^^</a> <a href="#465354" title="T" class="delimiter">{</a>
        <span class="keyword">case</span> <a title="T" id="465357">x</a> ~ <a title="List[Parsers.this.~[(T, U) =&gt; T,U]]" id="465358">xs</a> =&gt; <a href="#465358" title="List[Parsers.this.~[(T, U) =&gt; T,U]]">xs</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#48371" title="(z: T)(f: (T, Parsers.this.~[(T, U) =&gt; T,U]) =&gt; T)T">foldLeft</a><span class="delimiter">(</span><a href="#465357" title="T">x</a><span class="delimiter">)</span><span class="delimiter">{</span><a href="../../../Tuple2.scala.html#30727" title="(_1: T, _2: Parsers.this.~[(T, U) =&gt; T,U])(T, Parsers.this.~[(T, U) =&gt; T,U])" class="delimiter">(</a><a href="#465376" title="T">_</a>, <a href="#465377" title="Parsers.this.~[(T, U) =&gt; T,U]">_</a><span class="delimiter">)</span> <span title="T" class="keyword">match</span> <span class="delimiter">{</span><span class="keyword">case</span> <span title="T" class="delimiter">(</span><a title="T" id="465386">a</a>, <a title="(T, U) =&gt; T" id="465389">f</a> ~ <a title="U" id="465390">b</a><span class="delimiter">)</span> =&gt; <a href="../../../Function2.scala.html#37184" title="(v1: T, v2: U)T">f</a><span class="delimiter">(</span><a href="#465386" title="T">a</a>, <a href="#465390" title="U">b</a><span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">}</span>
      <span class="delimiter">}</span>
        
  <span class="comment">/** A parser generator that generalises the rep1sep generator so that `q', which parses the separator,
   * produces a right-associative function that combines the elements it separates. Additionally,
   * The right-most (last) element and the left-most combining function have to be supplied.
   * 
   * rep1sep(p: Parser[T], q) corresponds to chainr1(p, q ^^ cons, cons, Nil) (where val cons = (x: T, y: List[T]) =&gt; x :: y)
   *
   * @param p a parser that parses the elements
   * @param q a parser that parses the token(s) separating the elements, yielding a right-associative function that 
   *          combines two elements into one 
   * @param combine the &quot;last&quot; (left-most) combination function to be applied
   * @param first   the &quot;first&quot; (right-most) element to be combined
   */</span>
  <span class="keyword">def</span> <a title="[T, U](p: =&gt; Parsers.this.Parser[T], q: =&gt; Parsers.this.Parser[(T, U) =&gt; U], combine: (T, U) =&gt; U, first: U)Parsers.this.Parser[U]" id="460330">chainr1</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460333">T</a>, <a title="&gt;: Nothing &lt;: Any" id="460334">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="465394">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="=&gt; Parsers.this.Parser[(T, U) =&gt; U]" id="465395">q</a>: =&gt; Parser<span class="delimiter">[</span><span class="delimiter">(</span>T, U<span class="delimiter">)</span> =&gt; U<span class="delimiter">]</span>, <a title="(T, U) =&gt; U" id="465396">combine</a>: <span class="delimiter">(</span>T, U<span class="delimiter">)</span> =&gt; U, <a title="U" id="465397">first</a>: <a href="#460334" title="U">U</a><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span>
    = <a href="#465394" title="=&gt; Parsers.this.Parser[T]">p</a> <a href="#460576" title="(q: =&gt; Parsers.this.Parser[List[Parsers.this.~[(T, U) =&gt; U,T]]])Parsers.this.Parser[Parsers.this.~[T,List[Parsers.this.~[(T, U) =&gt; U,T]]]]">~</a> <a href="#460304" title="(p: =&gt; Parsers.this.Parser[Parsers.this.~[(T, U) =&gt; U,T]])Parsers.this.Parser[List[Parsers.this.~[(T, U) =&gt; U,T]]]">rep</a><span class="delimiter">(</span><a href="#465395" title="=&gt; Parsers.this.Parser[(T, U) =&gt; U]">q</a> <a href="#460576" title="(q: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[Parsers.this.~[(T, U) =&gt; U,T]]">~</a> <a href="#465394" title="=&gt; Parsers.this.Parser[T]">p</a><span class="delimiter">)</span> <a href="#460594" title="(f: Parsers.this.~[T,List[Parsers.this.~[(T, U) =&gt; U,T]]] =&gt; U)Parsers.this.Parser[U]">^^</a> <a href="#465416" title="U" class="delimiter">{</a>
        <span class="keyword">case</span> <a title="U" id="465419">x</a> ~ <a title="List[Parsers.this.~[(T, U) =&gt; U,T]]" id="465420">xs</a> =&gt; <span class="delimiter">(</span><span title="Parsers.this.~[(T, U) =&gt; U,T]" class="keyword">new</span> <a href="#460382" title="Parsers.this.~[(T, U) =&gt; U,T]">~</a><span class="delimiter">(</span><a href="#465396" title="(T, U) =&gt; U">combine</a>, <a href="#465419" title="T">x</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#26477" title="(x: Parsers.this.~[(T, U) =&gt; U,T])List[Parsers.this.~[(T, U) =&gt; U,T]]">::</a> <a href="#465420" title="List[Parsers.this.~[(T, U) =&gt; U,T]]">xs</a><span class="delimiter">)</span>.
                            <a href="../../../collection/LinearSeqOptimized.scala.html#48374" title="(z: U)(f: (Parsers.this.~[(T, U) =&gt; U,T], U) =&gt; U)U">foldRight</a><span class="delimiter">(</span><a href="#465397" title="U">first</a><span class="delimiter">)</span><span class="delimiter">{</span><a href="../../../Tuple2.scala.html#30727" title="(_1: Parsers.this.~[(T, U) =&gt; U,T], _2: U)(Parsers.this.~[(T, U) =&gt; U,T], U)" class="delimiter">(</a><a href="#465461" title="Parsers.this.~[(T, U) =&gt; U,T]">_</a>, <a href="#465462" title="U">_</a><span class="delimiter">)</span> <span title="U" class="keyword">match</span> <span class="delimiter">{</span><span class="keyword">case</span> <span title="U" class="delimiter">(</span><a title="(T, U) =&gt; U" id="465473">f</a> ~ <a title="T" id="465474">a</a>, <a title="U" id="465475">b</a><span class="delimiter">)</span> =&gt; <a href="../../../Function2.scala.html#37184" title="(v1: T, v2: U)U">f</a><span class="delimiter">(</span><a href="#465474" title="T">a</a>, <a href="#465475" title="U">b</a><span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">}</span>
      <span class="delimiter">}</span>
    
  <span class="comment">/** A parser generator for optional sub-phrases.
   *  
   *  &lt;p&gt;opt(p) is a parser that returns `Some(x)' if `p' returns `x' and `None' if `p' fails&lt;/p&gt;
   *
   * @param p A `Parser' that is tried on the input
   * @return a `Parser' that always succeeds: either with the result provided by `p' or 
   *         with the empty result
   */</span>
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[Option[T]]" id="460335">opt</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460337">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="464385">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[Option[T]]">Parser</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = 
    <a href="#464385" title="=&gt; Parsers.this.Parser[T]">p</a> <a href="#460594" title="(f: T =&gt; Some[T])Parsers.this.Parser[Some[T]]">^^</a> <span class="delimiter">(</span><a title="T" id="465483">x</a> =&gt; <a href="../../../Option.scala.html#35222" title="(x: T)Some[T]">Some</a><span class="delimiter">(</span><a href="#465483" title="T">x</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#460588" title="(q: =&gt; Parsers.this.Parser[Option[T]])Parsers.this.Parser[Option[T]]">|</a> <a href="#460298" title="(v: None.type)Parsers.this.Parser[None.type]">success</a><span class="delimiter">(</span><a href="../../../Option.scala.html#1733" title="object None">None</a><span class="delimiter">)</span>

  <span class="comment">/** Wrap a parser so that its failures&amp;errors become success and vice versa -- it never consumes any input 
   */</span>
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[Unit]" id="460338">not</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460340">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="465507">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[Unit]">Parser</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> = <a href="#460269" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[Unit])Parsers.this.Parser[Unit]">Parser</a> <span class="delimiter">{</span> <a title="Parsers.this.Input" id="465513">in</a> =&gt;
    <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a><span class="delimiter">(</span><a href="#465513" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <span title="Parsers.this.ParseResult[Unit]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Parsers.this.Failure">Success</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span>  =&gt; <a href="#461337" title="(msg: String, next: Parsers.this.Input)Parsers.this.Failure">Failure</a><span class="delimiter">(</span><span title="java.lang.String(&quot;Expected failure&quot;)" class="string">&quot;Expected failure&quot;</span>, <a href="#465513" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Parsers.this.Success[Unit]">_</span>              =&gt; <a href="#461208" title="(result: Unit, next: Parsers.this.Input)Parsers.this.Success[Unit]">Success</a><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#465513" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>  

  <span class="comment">/** A parser generator for guard expressions. The resulting parser will fail or succeed 
   * just like the one given as parameter but it will not consume any input.
   *
   * @param p a `Parser' that is to be applied to the input
   * @return A parser that returns success if and only if 'p' succeeds but never consumes any input
   */</span>
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]" id="460341">guard</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460343">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="465532">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#460269" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a> <span class="delimiter">{</span> <a title="Parsers.this.Input" id="465538">in</a> =&gt;
    <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a><span class="delimiter">(</span><a href="#465538" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <span title="Parsers.this.ParseResult[T]" class="keyword">match</span><span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Parsers.this.Success[T]" id="465547">s</a>@ Success<span class="delimiter">(</span><a title="T" id="465550">s1</a>,_<span class="delimiter">)</span> =&gt; <a href="#461208" title="(result: T, next: Parsers.this.Input)Parsers.this.Success[T]">Success</a><span class="delimiter">(</span><a href="#465550" title="T">s1</a>, <a href="#465538" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Parsers.this.ParseResult[T]" id="465556">e</a> =&gt; <a href="#465556" title="Parsers.this.ParseResult[T]">e</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  
  <span class="comment">/** `positioned' decorates a parser's result with the start position of the input it consumed. 
   * 
   * @param p a `Parser' whose result conforms to `Positional'.
   * @return A parser that has the same behaviour as `p', but which marks its result with the 
   *         start position of the input it consumed, if it didn't already have a position.
   */</span>
  <span class="keyword">def</span> <a title="[T &lt;: scala.util.parsing.input.Positional](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]" id="460344">positioned</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scala.util.parsing.input.Positional" id="460346">T</a> &lt;: Positional<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="465558">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#460269" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a> <span class="delimiter">{</span> <a title="Parsers.this.Input" id="465564">in</a> =&gt;
    <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a><span class="delimiter">(</span><a href="#465564" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <span title="Parsers.this.ParseResult[T]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Parsers.this.Success[T]">Success</span><span class="delimiter">(</span><a title="T" id="465575">t</a>, <a title="Parsers.this.Input" id="465576">in1</a><span class="delimiter">)</span> =&gt; <a href="#461208" title="(result: T, next: Parsers.this.Input)Parsers.this.Success[T]">Success</a><span class="delimiter">(</span><span title="T" class="keyword">if</span> <span class="delimiter">(</span><a href="#465575" title="T">t</a>.<a href="../input/Positional.scala.html#458789" title="=&gt; scala.util.parsing.input.Position">pos</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../input/NoPosition.scala.html#22936" title="object scala.util.parsing.input.NoPosition">NoPosition</a><span class="delimiter">)</span> <a href="#465575" title="T">t</a> <a href="../input/Positional.scala.html#458792" title="(newpos: scala.util.parsing.input.Position)t.type">setPos</a> <a href="#465564" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#460558" title="=&gt; scala.util.parsing.input.Position">pos</a> <span class="keyword">else</span> <a href="#465575" title="T">t</a>, <a href="#465576" title="Parsers.this.Input">in1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Parsers.this.NoSuccess" id="465595">ns</a>: <a href="#460260" title="Parsers.this.NoSuccess">NoSuccess</a> =&gt; <a href="#465595" title="Parsers.this.NoSuccess">ns</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** &lt;p&gt;
   *    A parser generator delimiting whole phrases (i.e. programs).
   *  &lt;/p&gt;
   *  &lt;p&gt;
   *    &lt;code&gt;phrase(p)&lt;/code&gt; succeeds if &lt;code&gt;p&lt;/code&gt; succeeds and
   *    no input is left over after &lt;code&gt;p&lt;/code&gt;.
   *  &lt;/p&gt;
   *
   *  @param p the parser that must consume all input for the resulting parser
   *           to succeed.
   *  @return  a parser that has the same result as `p', but that only succeeds
   *           if &lt;code&gt;p&lt;/code&gt; consumed all the input.
   */</span>
  <span class="keyword">def</span> <a title="[T](p: Parsers.this.Parser[T])Parsers.this.Parser[T]" id="460347">phrase</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460349">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Parsers.this.Parser[T]" id="461184">p</a>: <a href="#460275" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#461187" title="Parsers.this.Parser[T]" class="keyword">new</a> <a title="anonymous class $anon extends Parsers.this.Parser[T]" id="461187">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
    <a href="#460258" title="(x$1: Parsers.this.NoSuccess)Unit">lastNoSuccess</a> = <span title="Null(null)" class="keyword">null</span>
    <span class="keyword">def</span> <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" id="461189">apply</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="461190">in</a>: <a href="../input/Reader.scala.html#22968" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> = <a href="#460566" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a><span class="delimiter">(</span><a href="#461190" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <span title="Parsers.this.ParseResult[T]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Parsers.this.ParseResult[T]" id="461205">s</a> @ Success<span class="delimiter">(</span><a title="T" id="461288">out</a>, <a title="Parsers.this.Input" id="461289">in1</a><span class="delimiter">)</span> =&gt;
        <span title="Parsers.this.ParseResult[T]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461289" title="Parsers.this.Input">in1</a>.<a href="../input/Reader.scala.html#460559" title="=&gt; Boolean">atEnd</a><span class="delimiter">)</span> 
          <a href="#461205" title="Parsers.this.Success[T]">s</a>
        <span class="keyword">else</span> <span title="Parsers.this.ParseResult[T]" class="keyword">if</span> <span class="delimiter">(</span><a href="#460258" title="=&gt; Parsers.this.NoSuccess">lastNoSuccess</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span> <a href="../../../Boolean.scala.html#32916" title="(x: Boolean)Boolean">||</a> <a href="#460258" title="=&gt; Parsers.this.NoSuccess">lastNoSuccess</a>.<a href="#463408" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#460558" title="=&gt; scala.util.parsing.input.Position">pos</a> <a href="../input/Position.scala.html#460983" title="(that: scala.util.parsing.input.Position)Boolean">&lt;</a> <a href="#461289" title="Parsers.this.Input">in1</a>.<a href="../input/Reader.scala.html#460558" title="=&gt; scala.util.parsing.input.Position">pos</a><span class="delimiter">)</span>
          <a href="#461337" title="(msg: String, next: Parsers.this.Input)Parsers.this.Failure">Failure</a><span class="delimiter">(</span><span title="java.lang.String(&quot;end of input expected&quot;)" class="string">&quot;end of input expected&quot;</span>, <a href="#461289" title="Parsers.this.Input">in1</a><span class="delimiter">)</span>
        <span class="keyword">else</span> 
          <a href="#460258" title="=&gt; Parsers.this.NoSuccess">lastNoSuccess</a>
      <span class="keyword">case</span> <span title="Parsers.this.NoSuccess">_</span> =&gt; <a href="#460258" title="=&gt; Parsers.this.NoSuccess">lastNoSuccess</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[T]=&gt; Parsers.this.~[T,List[T]] =&gt; List[T]" id="460350">mkList</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="460352">T</a><span class="delimiter">]</span> = <span class="delimiter">(</span><a href="#465036" title="Parsers.this.~[T,List[T]]">_</a>: <a href="#460382" title="Parsers.this.~[T,List[T]]">~</a><span class="delimiter">[</span>T, List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="List[T]" class="keyword">match</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a title="List[T]" id="465039">x</a> ~ <a title="List[T]" id="465040">xs</a> =&gt; <a href="#465039" title="T">x</a> <a href="../../../collection/immutable/List.scala.html#26477" title="(x: T)List[T]">::</a> <a href="#465040" title="List[T]">xs</a> <span class="delimiter">}</span>
  case <span class="keyword">class</span> <a title="class ~[+a, +b] extends java.lang.Object with ScalaObject with Product with Serializable" id="460382">~</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="460385">a</a>, +<a title="&gt;: Nothing &lt;: Any" id="460386">b</a><span class="delimiter">]</span><a href="../../../ScalaObject.scala.html#460" title="ScalaObject" class="delimiter">(</a><a title="a" id="465676">_1</a>: <a href="#460385" title="a">a</a>, <a title="b" id="465677">_2</a>: <a href="#460386" title="b">b</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="460374">toString</a> = <span title="java.lang.String(&quot;(&quot;)" class="string">&quot;(&quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#465676" title="=&gt; a">_1</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;~&quot;)" class="string">&quot;~&quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#465677" title="=&gt; b">_2</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A parser whose ~ combinator disallows back-tracking.
   */</span>
  <span class="keyword">trait</span> <a title="trait OnceParser[+T] extends Parsers.this.Parser[T] with ScalaObject" id="460358">OnceParser</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="460359">T</a><span class="delimiter">]</span> <a href="../../../ScalaObject.scala.html#460" title="ScalaObject" class="keyword">extends</a> <a href="#460275" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[U](p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[Parsers.this.~[T,U]]" id="463843">~</a> <span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="463845">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[U]" id="463850">p</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#460275" title="Parsers.this.Parser[Parsers.this.~[T,U]]">Parser</a><span class="delimiter">[</span>~<span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">]</span>
      = <a href="#460272" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]] with Parsers.this.OnceParser[Parsers.this.~[T,U]]">OnceParser</a><span class="delimiter">{</span> <span class="delimiter">(</span><span class="keyword">for</span><span class="delimiter">(</span><a title="T" id="465650">a</a> &lt;- <a href="#460567" title="(f: T =&gt; Parsers.this.Parser[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]]" class="keyword">this</a>; <a title="U" id="465658">b</a> &lt;- <a href="#460277" title="(p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]">commit</a><a href="#460570" title="(f: U =&gt; Parsers.this.~[T,U])Parsers.this.Parser[Parsers.this.~[T,U]]" class="delimiter">(</a><a href="#463850" title="=&gt; Parsers.this.Parser[U]">p</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">yield</span> <span title="Parsers.this.~[T,U]" class="keyword">new</span> <a href="#460382" title="Parsers.this.~[T,U]">~</a><span class="delimiter">(</span><a href="#465650" title="T">a</a>,<a href="#465658" title="U">b</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#460564" title="(n: java.lang.String)Parsers.this.Parser[Parsers.this.~[T,U]]">named</a><span class="delimiter">(</span><span title="java.lang.String(&quot;~&quot;)" class="string">&quot;~&quot;</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>