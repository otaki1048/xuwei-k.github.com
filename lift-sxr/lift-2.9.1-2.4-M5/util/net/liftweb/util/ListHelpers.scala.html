<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>util/net/liftweb/util/ListHelpers.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright 2006-2011 WorldWide Conferencing, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span class="keyword">package</span> net.liftweb
<span class="keyword">package</span> util

<span class="keyword">import</span> common._

<span class="keyword">object</span> <a title="object net.liftweb.util.ListHelpers" id="13438">ListHelpers</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#13458" title="net.liftweb.util.ListHelpers">ListHelpers</a>

<span class="comment">/**
 * Provide information about the deltas between
 * two lists
 */</span>
<span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait DeltaInfo[T] extends java.lang.Object" id="13440">DeltaInfo</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="13441">T</a><span class="delimiter">]</span>

<span class="comment">/**
 * The new list does not contain the item.  Remove it
 * from the list
 */</span>
<span class="keyword">final</span> case <span class="keyword">class</span> <a title="class RemoveDelta[T] extends java.lang.Object with net.liftweb.util.DeltaInfo[T] with ScalaObject with Product with Serializable" id="304459">RemoveDelta</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="302742">T</a><span class="delimiter">]</span><a href="#304459" title="ScalaObject" class="delimiter">(</a><a title="T" id="303150">item</a>: <a href="#302742" title="T">T</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#13440" title="net.liftweb.util.DeltaInfo[T]">DeltaInfo</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
<span class="keyword">final</span> case <span class="keyword">class</span> <a title="class InsertAtStartDelta[T] extends java.lang.Object with net.liftweb.util.DeltaInfo[T] with ScalaObject with Product with Serializable" id="304454">InsertAtStartDelta</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="302802">T</a><span class="delimiter">]</span><a href="#304454" title="ScalaObject" class="delimiter">(</a><a title="T" id="303243">item</a>: <a href="#302802" title="T">T</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#13440" title="net.liftweb.util.DeltaInfo[T]">DeltaInfo</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
<span class="keyword">final</span> case <span class="keyword">class</span> <a title="class AppendDelta[T] extends java.lang.Object with net.liftweb.util.DeltaInfo[T] with ScalaObject with Product with Serializable" id="304449">AppendDelta</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="302862">T</a><span class="delimiter">]</span><a href="#304449" title="ScalaObject" class="delimiter">(</a><a title="T" id="303194">item</a>: <a href="#302862" title="T">T</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#13440" title="net.liftweb.util.DeltaInfo[T]">DeltaInfo</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
<span class="keyword">final</span> case <span class="keyword">class</span> <a title="class InsertAfterDelta[T] extends java.lang.Object with net.liftweb.util.DeltaInfo[T] with ScalaObject with Product with Serializable" id="304444">InsertAfterDelta</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="302936">T</a><span class="delimiter">]</span><a href="#304444" title="ScalaObject" class="delimiter">(</a><a title="T" id="303184">item</a>: <a href="#302936" title="T">T</a>, <a title="T" id="303185">after</a>: <a href="#302936" title="T">T</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#13440" title="net.liftweb.util.DeltaInfo[T]">DeltaInfo</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

<span class="comment">/**
 * The ListHelpers trait provides useful functions which can be applied to Lists.&lt;p/&gt;
 */</span>
<span class="keyword">trait</span> <a title="trait ListHelpers extends java.lang.Object with ScalaObject" id="13458">ListHelpers</a> <span title="ScalaObject" class="delimiter">{</span>

  <span class="comment">/**
   * Compute the deltas between two sequences of a given type.
   * Apply the function based on the differences between the two
   * lists.  The resulting List of commands will be returned.
   */</span>
  <span class="keyword">def</span> <a title="[T, Res](old: net.liftweb.common.Box[Seq[T]], newList: Seq[T])(f: net.liftweb.util.DeltaInfo[T] =&gt; Res)List[Res]" id="48864">delta</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48867">T</a>, <a title="&gt;: Nothing &lt;: Any" id="48868">Res</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="net.liftweb.common.Box[Seq[T]]" id="302978">old</a>: <a href="../../../../common/net/liftweb/common/Box.scala.html#10575" title="net.liftweb.common.Box[Seq[T]]">Box</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Seq[T]" id="302979">newList</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="net.liftweb.util.DeltaInfo[T] =&gt; Res" id="302980">f</a>: DeltaInfo<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; Res<span class="delimiter">)</span>: <span title="List[Res]">List</span><span class="delimiter">[</span>Res<span class="delimiter">]</span> = <a href="#48869" title="(old: Seq[T], newList: Seq[T])(f: net.liftweb.util.DeltaInfo[T] =&gt; Res)List[Res]">delta</a><span class="delimiter">(</span><a href="#302978" title="net.liftweb.common.Box[Seq[T]]">old</a> <a href="../../../../common/net/liftweb/common/Box.scala.html#27017" title="(default: =&gt; Seq[T])Seq[T]">openOr</a> <span title="object Nil">Nil</span>, <a href="#302979" title="Seq[T]">newList</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#302980" title="net.liftweb.util.DeltaInfo[T] =&gt; Res">f</a><span class="delimiter">)</span>


  <span class="comment">/**
   * Compute the deltas between two sequences of a given type.
   * Apply the function based on the differences between the two
   * lists.  The resulting List of commands will be returned.
   * The algorithm used to calculate the diffs is not very efficient
   * and can degrade to O(n^2), so it's not great for large collections.
   * Internally the Seq[T] are converted to a List[T].  Finally,
   * it's highly recommended that T be immutable and does proper equals
   * testing (e.g., a case class).
   */</span>
  <span class="keyword">def</span> <a title="[T, Res](old: Seq[T], newList: Seq[T])(f: net.liftweb.util.DeltaInfo[T] =&gt; Res)List[Res]" id="48869">delta</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48872">T</a>, <a title="&gt;: Nothing &lt;: Any" id="48873">Res</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[T]" id="302989">old</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Seq[T]" id="302990">newList</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="net.liftweb.util.DeltaInfo[T] =&gt; Res" id="302991">f</a>: DeltaInfo<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; Res<span class="delimiter">)</span>: <span title="List[Res]">List</span><span class="delimiter">[</span>Res<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">import</span> scala.collection.mutable.ListBuffer
    <span class="keyword">import</span> scala.annotation._

    <span class="keyword">val</span> <a title="scala.collection.immutable.Set[T]" id="303090">newSet</a> = <span title="(elems: T*)scala.collection.immutable.Set[T]">Set</span><span class="delimiter">(</span><a href="#302990" title="Seq[T]">newList</a> :_*<span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[Res]" id="303091">ret</a>: <span title="scala.collection.mutable.ListBuffer[Res]">ListBuffer</span><span class="delimiter">[</span>Res<span class="delimiter">]</span> = <span title="scala.collection.mutable.ListBuffer[Res]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[Res]">ListBuffer</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">var</span> <a title="net.liftweb.common.Box[T]" id="303092">insertAfter</a>: <a href="../../../../common/net/liftweb/common/Box.scala.html#10575" title="net.liftweb.common.Box[T]">Box</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="../../../../common/net/liftweb/common/Box.scala.html#10581" title="object net.liftweb.common.Empty">Empty</a>

    @tailrec <span class="keyword">def</span> <a title="(o: List[T], n: List[T])Unit" id="303093">loop</a><span class="delimiter">(</span><a title="List[T]" id="303098">o</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="List[T]" id="303099">n</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(_1: List[T], _2: List[T])(List[T], List[T])" class="delimiter">(</span><a href="#303098" title="List[T]">o</a>, <a href="#303099" title="List[T]">n</a><span class="delimiter">)</span> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Unit" class="delimiter">(</span><a title="List[T]" id="303119">o</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span> =&gt; <a href="#303119" title="List[T]">o</a>.<span title="(f: T =&gt; scala.collection.mutable.ListBuffer[Res])Unit">foreach</span><span class="delimiter">(</span><a title="T" id="303139">t</a> =&gt; <a href="#303091" title="scala.collection.mutable.ListBuffer[Res]">ret</a> <span title="(x: Res)ret.type">+=</span> <a href="#302991" title="(v1: net.liftweb.util.DeltaInfo[T])Res">f</a><span class="delimiter">(</span><a href="#304459" title="(item: T)net.liftweb.util.RemoveDelta[T]">RemoveDelta</a><span class="delimiter">(</span><a href="#303139" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Unit" class="delimiter">(</span><span title="object Nil">Nil</span>, <a title="List[T]" id="303159">n</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
          <a href="#303159" title="List[T]">n</a>.<span title="(f: T =&gt; Unit)Unit">foreach</span><span class="delimiter">{</span>
            <a title="T" id="303179">t</a> =&gt; <a href="#303091" title="scala.collection.mutable.ListBuffer[Res]">ret</a> <span title="(x: Res)ret.type">+=</span> <a href="#302991" title="(v1: net.liftweb.util.DeltaInfo[T])Res">f</a><span class="delimiter">(</span><a href="#303092" title="net.liftweb.common.Box[T]">insertAfter</a> <span title="net.liftweb.util.DeltaInfo[T]" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <span title="net.liftweb.util.InsertAfterDelta[T]">Full</span><span class="delimiter">(</span><a title="T" id="303183">x</a><span class="delimiter">)</span> =&gt; <a href="#304444" title="(item: T, after: T)net.liftweb.util.InsertAfterDelta[T]">InsertAfterDelta</a><span class="delimiter">(</span><a href="#303179" title="T">t</a>, <a href="#303183" title="T">x</a><span class="delimiter">)</span>
              <span class="keyword">case</span> <span title="net.liftweb.util.AppendDelta[T]">_</span> =&gt; <a href="#304449" title="(item: T)net.liftweb.util.AppendDelta[T]">AppendDelta</a><span class="delimiter">(</span><a href="#303179" title="T">t</a><span class="delimiter">)</span>
            <span class="delimiter">}</span><span class="delimiter">)</span>
            <a href="#303092" title="net.liftweb.common.Box[T]">insertAfter</a> = <a href="../../../../common/net/liftweb/common/Box.scala.html#27086" title="(value: T)net.liftweb.common.Full[T]">Full</a><span class="delimiter">(</span><a href="#303179" title="T">t</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        <span class="keyword">case</span> <span title="Unit" class="delimiter">(</span><a title="T" id="303212">o</a> :: <a title="List[T]" id="303213">or</a>, <a title="T" id="303218">n</a> :: <a title="List[T]" id="303219">nr</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#303212" title="T">o</a> <span title="(x$1: Any)Boolean">==</span> <a href="#303218" title="T">n</a> =&gt; <span class="delimiter">{</span>
          <a href="#303092" title="net.liftweb.common.Box[T]">insertAfter</a> = <a href="../../../../common/net/liftweb/common/Box.scala.html#27086" title="(value: T)net.liftweb.common.Full[T]">Full</a><span class="delimiter">(</span><a href="#303218" title="T">n</a><span class="delimiter">)</span>
          <a href="#303093" title="(o: List[T], n: List[T])Unit">loop</a><span class="delimiter">(</span><a href="#303213" title="List[T]">or</a>, <a href="#303219" title="List[T]">nr</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        <span class="keyword">case</span> <span title="Unit" class="delimiter">(</span><a title="List[T]" id="303225">or</a>, <a title="T" id="303230">n</a> :: <a title="List[T]" id="303231">nr</a><span class="delimiter">)</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#303225" title="List[T]">or</a>.<span title="(elem: Any)Boolean">contains</span><span class="delimiter">(</span><a href="#303230" title="T">n</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
          <a href="#303092" title="net.liftweb.common.Box[T]">insertAfter</a> <span title="ret.type" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="ret.type">Full</span><span class="delimiter">(</span><a title="T" id="303233">x</a><span class="delimiter">)</span> =&gt; <a href="#303091" title="scala.collection.mutable.ListBuffer[Res]">ret</a> <span title="(x: Res)ret.type">+=</span> <a href="#302991" title="(v1: net.liftweb.util.DeltaInfo[T])Res">f</a><span class="delimiter">(</span><a href="#304444" title="(item: T, after: T)net.liftweb.util.InsertAfterDelta[T]">InsertAfterDelta</a><span class="delimiter">(</span><a href="#303230" title="T">n</a>, <a href="#303233" title="T">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="ret.type">_</span> =&gt; <a href="#303091" title="scala.collection.mutable.ListBuffer[Res]">ret</a> <span title="(x: Res)ret.type">+=</span> <a href="#302991" title="(v1: net.liftweb.util.DeltaInfo[T])Res">f</a><span class="delimiter">(</span><a href="#304454" title="(item: T)net.liftweb.util.InsertAtStartDelta[T]">InsertAtStartDelta</a><span class="delimiter">(</span><a href="#303230" title="T">n</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <a href="#303092" title="net.liftweb.common.Box[T]">insertAfter</a> = <a href="../../../../common/net/liftweb/common/Box.scala.html#27086" title="(value: T)net.liftweb.common.Full[T]">Full</a><span class="delimiter">(</span><a href="#303230" title="T">n</a><span class="delimiter">)</span>
          <a href="#303093" title="(o: List[T], n: List[T])Unit">loop</a><span class="delimiter">(</span><a href="#303225" title="List[T]">or</a>, <a href="#303231" title="List[T]">nr</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        <span class="keyword">case</span> <span title="Unit" class="delimiter">(</span><a title="T" id="303262">o</a> :: <a title="List[T]" id="303263">or</a>, <a title="List[T]" id="303264">nr</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
          <a href="#303091" title="scala.collection.mutable.ListBuffer[Res]">ret</a> <span title="(x: Res)ret.type">+=</span> <a href="#302991" title="(v1: net.liftweb.util.DeltaInfo[T])Res">f</a><span class="delimiter">(</span><a href="#304459" title="(item: T)net.liftweb.util.RemoveDelta[T]">RemoveDelta</a><span class="delimiter">(</span><a href="#303262" title="T">o</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#303093" title="(o: List[T], n: List[T])Unit">loop</a><span class="delimiter">(</span><a href="#303263" title="List[T]">or</a>, <a href="#303264" title="List[T]">nr</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="#303093" title="(o: List[T], n: List[T])Unit">loop</a><span class="delimiter">(</span><a href="#302989" title="Seq[T]">old</a>.<span title="=&gt; List[T]">toList</span>, <a href="#302990" title="Seq[T]">newList</a>.<span title="=&gt; List[T]">toList</span><span class="delimiter">)</span>
    
    <a href="#303091" title="scala.collection.mutable.ListBuffer[Res]">ret</a>.<span title="=&gt; List[Res]">toList</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a Full can with the first element x of the list in
   * for which f(x) evaluates to true. If f(x) evaluates to false
   * for every x, then an Empty can is returned.
   *
   * @param in  a list of elements to which f can be applied
   * @param f   a function that can be applied to elements of in
   *
   * @return a Box containing the found element (or Empty if not found)
   */</span>
  <span class="keyword">def</span> <a title="[B](in: Seq[B])(f: =&gt; B =&gt; Boolean)net.liftweb.common.Box[B]" id="48874">first_?</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48876">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[B]" id="303270">in</a>: <span title="Seq[B]">Seq</span><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="=&gt; B =&gt; Boolean" id="303271">f</a>: =&gt; B =&gt; Boolean<span class="delimiter">)</span>: <a href="../../../../common/net/liftweb/common/Box.scala.html#10575" title="net.liftweb.common.Box[B]">Box</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =
    <a href="../../../../common/net/liftweb/common/Box.scala.html#28602" title="(in: Option[B])net.liftweb.common.Box[B] with Serializable">Box</a><span class="delimiter">(</span><a href="#303270" title="Seq[B]">in</a>.<span title="(p: B =&gt; Boolean)Option[B]">find</span><span class="delimiter">(</span><a href="#303271" title="=&gt; B =&gt; Boolean">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns the first application of f to an element of in that
   * results in a Full can. If f applied to an element of in results
   * in an Empty can, then f will be applied to the rest of the
   * elements of in until a Full can results. If the list runs out
   * then an Empty can is returned.
   *
   * @param in  a list of elements to which f can be applied
   * @param f   a function that can be applied to elements of in
   *
   * @return a Box containing the first Full can or Empty if f never returns a Full can
   */</span>
  <span class="keyword">def</span> <a title="[B, C](in: Seq[B])(_f: B =&gt; net.liftweb.common.Box[C])net.liftweb.common.Box[C]" id="48877">first</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48880">B</a>, <a title="&gt;: Nothing &lt;: Any" id="48881">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[B]" id="61513">in</a>: <span title="Seq[B]">Seq</span><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="B =&gt; net.liftweb.common.Box[C]" id="61514">_f</a>: B =&gt; Box<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../../common/net/liftweb/common/Box.scala.html#10575" title="net.liftweb.common.Box[C]">Box</a><span class="delimiter">[</span>C<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="B =&gt; Iterable[C]" id="303347">f</a>: B =&gt; Iterable<span class="delimiter">[</span>C<span class="delimiter">]</span> = <a href="#61514" title="B =&gt; net.liftweb.common.Box[C]">_f</a> <span title="(g: net.liftweb.common.Box[C] =&gt; Iterable[C])B =&gt; Iterable[C]">andThen</span> <a href="../../../../common/net/liftweb/common/Box.scala.html#10572" title="object net.liftweb.common.Box">Box</a>.<a href="../../../../common/net/liftweb/common/Box.scala.html#28624" title="[T](in: net.liftweb.common.Box[T])Iterable[T]">box2Iterable</a><a href="#303359" title="(in: net.liftweb.common.Box[C])Iterable[C]" class="delimiter">[</a><a href="#48881" title="C">C</a><span class="delimiter">]</span>
    <span class="comment">// We use toStream here to avoid multiple execution of &quot;f&quot; for each element access (Issue #596)</span>
    <a href="../../../../common/net/liftweb/common/Box.scala.html#28602" title="(in: Option[C])net.liftweb.common.Box[C] with Serializable">Box</a><span class="delimiter">(</span><a href="#61513" title="Seq[B]">in</a>.<span title="=&gt; scala.collection.immutable.Stream[B]">toStream</span>.<span title="(f: B =&gt; scala.collection.GenTraversableOnce[C])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[B],C,scala.collection.immutable.Stream[C]])scala.collection.immutable.Stream[C]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream.Coll,C,scala.collection.immutable.Stream[C]]" class="delimiter">(</span><a href="#303347" title="B =&gt; Iterable[C]">f</a><span class="delimiter">)</span>.<span title="=&gt; Option[C]">headOption</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class add a case insensitive get to a List of Pairs of String, as if it was a Map
   */</span>
  <span class="keyword">class</span> <a title="class ListMapish extends java.lang.Object with ScalaObject" id="48882">ListMapish</a><a href="#48882" title="ScalaObject" class="delimiter">(</a><span class="keyword">val</span> <a title="Seq[(String, String)]" id="303653">theList</a>: <span title="Seq[(String, String)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, String<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">/**
     * Return a Box containing the second element of the first pair having key as the first element
     * The comparison is made ignoring the case of the keys
     *
     * @param key the string to find
     *
     * @return a Full can containing the found value or Empty
     */</span>
    <span class="keyword">def</span> <a title="(swhat: String)net.liftweb.common.Box[String]" id="58424">ciGet</a><span class="delimiter">(</span><a title="String" id="296659">swhat</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="../../../../common/net/liftweb/common/Box.scala.html#10575" title="net.liftweb.common.Box[String]">Box</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="java.lang.String" id="303654">what</a> = <a href="#296659" title="String">swhat</a>.<span title="()java.lang.String">toLowerCase</span>
      <span class="keyword">def</span> <a title="(in: Seq[(String, String)])net.liftweb.common.Box[String]" id="303655">tGet</a><span class="delimiter">(</span><a title="Seq[(String, String)]" id="303658">in</a>: <span title="Seq[(String, String)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, String<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../../common/net/liftweb/common/Box.scala.html#10575" title="net.liftweb.common.Box[String]">Box</a><span class="delimiter">[</span>String<span class="delimiter">]</span> =
        <a href="#303658" title="Seq[(String, String)]">in</a> <span title="net.liftweb.common.Box[String]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="net.liftweb.common.Empty.type">Nil</span> =&gt; <a href="../../../../common/net/liftweb/common/Box.scala.html#10581" title="object net.liftweb.common.Empty">Empty</a>
          <span class="keyword">case</span> <a title="net.liftweb.common.Full[String]" id="303663">x</a> :: <a title="List[(String, String)]" id="303664">xs</a> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#303663" title="(String, String)">x</a>.<span title="=&gt; String">_1</span>.<span title="()java.lang.String">toLowerCase</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#303654" title="java.lang.String">what</a><span class="delimiter">)</span> =&gt; <a href="../../../../common/net/liftweb/common/Box.scala.html#27086" title="(value: String)net.liftweb.common.Full[String]">Full</a><span class="delimiter">(</span><a href="#303663" title="(String, String)">x</a>.<span title="=&gt; String">_2</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <a title="net.liftweb.common.Box[String]" id="303679">x</a> :: <a title="List[(String, String)]" id="303680">xs</a> =&gt; <a href="#303655" title="(in: Seq[(String, String)])net.liftweb.common.Box[String]">tGet</a><span class="delimiter">(</span><a href="#303680" title="List[(String, String)]">xs</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <a href="#303655" title="(in: Seq[(String, String)])net.liftweb.common.Box[String]">tGet</a><span class="delimiter">(</span><a href="#303653" title="=&gt; Seq[(String, String)]">theList</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** adds the ciGet method to a List of Pairs of Strings */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit net.liftweb.util.ListHelpers.listToListMapish : (in: Seq[(String, String)])ListHelpers.this.ListMapish" id="48883">listToListMapish</a><span class="delimiter">(</span><a title="Seq[(String, String)]" id="56261">in</a>: <span title="Seq[(String, String)]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, String<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#48882" title="ListHelpers.this.ListMapish">ListMapish</a> = <span title="ListHelpers.this.ListMapish" class="keyword">new</span> <a href="#48882" title="ListHelpers.this.ListMapish">ListMapish</a><span class="delimiter">(</span><a href="#56261" title="Seq[(String, String)]">in</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Convert a java.util.Enumeration to a List[T]
   */</span>
  <span class="keyword">def</span> <a title="[T](enum: java.util.Enumeration[T])List[T]" id="48884">enumToList</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48886">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="java.util.Enumeration[T]" id="303681">enum</a>: java.util.<span title="java.util.Enumeration[T]">Enumeration</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    scala.collection.<span title="object scala.collection.JavaConversions">JavaConversions</span>.<span title="(i: java.util.Enumeration[T])Iterator[T]">asIterator</span><span class="delimiter">(</span><a href="#303681" title="java.util.Enumeration[T]">enum</a><span class="delimiter">)</span>.<span title="=&gt; List[T]">toList</span>

  <span class="comment">/**
   * Convert a java.util.Enumeration to a List[String] using the toString method on each element
   */</span>
  <span class="keyword">def</span> <a title="[C](enum: java.util.Enumeration[C])List[String]" id="48887">enumToStringList</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48889">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="java.util.Enumeration[C]" id="303704">enum</a>: java.util.<span title="java.util.Enumeration[C]">Enumeration</span><span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[String]">List</span><span class="delimiter">[</span>String<span class="delimiter">]</span> =
    <a href="#48884" title="(enum: java.util.Enumeration[C])List[C]">enumToList</a><span class="delimiter">(</span><a href="#303704" title="java.util.Enumeration[C]">enum</a><span class="delimiter">)</span>.<span title="(f: C =&gt; java.lang.String)(implicit bf: scala.collection.generic.CanBuildFrom[List[C],java.lang.String,List[String]])List[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,java.lang.String,List[java.lang.String]]" class="delimiter">(</span><a href="#303733" title="C">_</a>.<span title="()java.lang.String">toString</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Return the first element of a List or a default value if the list is empty
   */</span>
  <span class="keyword">def</span> <a title="[T](l: Seq[T], deft: =&gt; T)T" id="48890">head</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48892">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[T]" id="303761">l</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span>,
              <a title="=&gt; T" id="303762">deft</a>: =&gt; T<span class="delimiter">)</span> = <a href="#303761" title="Seq[T]">l</a>.<span title="=&gt; Option[T]">headOption</span>.<span title="(default: =&gt; T)T">getOrElse</span><span class="delimiter">(</span><a href="#303762" title="=&gt; T">deft</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Return a list containing the element f if the expression is true
   */</span>
  <span class="keyword">def</span> <a title="[T](expr: Boolean)(f: =&gt; T)List[T]" id="48893">listIf</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48895">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Boolean" id="303772">expr</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="=&gt; T" id="303773">f</a>: =&gt; T<span class="delimiter">)</span>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="List[T]" class="keyword">if</span> <span class="delimiter">(</span><a href="#303772" title="Boolean">expr</a><span class="delimiter">)</span> <span title="(xs: T*)List[T]">List</span><span class="delimiter">(</span><a href="#303773" title="=&gt; T">f</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="object Nil">Nil</span>

  <span class="comment">/**
   * Given an incoming list, return a set of lists that is the original list rotated through all its positions
   *
   * @param in the list to rotate
   *
   * @return all the rotations of the list
   */</span>
  <span class="keyword">def</span> <a title="[T](in: Seq[T])List[List[T]]" id="48896">rotateList</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48898">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[T]" id="303783">in</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[List[T]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(in: List[T], cnt: Int)List[List[T]]" id="303786">doIt</a><span class="delimiter">(</span><a title="List[T]" id="303787">in</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Int" id="303788">cnt</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="List[List[T]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">(</span><span title="(_1: List[T], _2: Int)(List[T], Int)" class="delimiter">(</span><a href="#303787" title="List[T]">in</a>, <a href="#303788" title="Int">cnt</a><span class="delimiter">)</span>: @<span title="(List[T], Int) @unchecked">unchecked</span><span class="delimiter">)</span> <span title="List[List[T]]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="scala.collection.immutable.Nil.type" class="delimiter">(</span>_, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> =&gt; <span title="object Nil">Nil</span>
      <span class="keyword">case</span> <span title="List[List[T]]" class="delimiter">(</span><a title="T" id="303816">x</a> :: <a title="List[T]" id="303817">xs</a>, <a title="Int" id="303818">cnt</a><span class="delimiter">)</span> =&gt; <a href="#303787" title="List[T]">in</a> <a href="#303819" title="(x: List[T])List[List[T]]">::</a> <a href="#303786" title="(in: List[T], cnt: Int)List[List[T]]">doIt</a><span class="delimiter">(</span><a href="#303817" title="List[T]">xs</a> <a href="#303820" title="(prefix: List[T])List[T]">:::</a> <span title="(xs: T*)List[T]">List</span><span class="delimiter">(</span><a href="#303816" title="T">x</a><span class="delimiter">)</span>, <a href="#303818" title="Int">cnt</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#303786" title="(in: List[T], cnt: Int)List[List[T]]">doIt</a><span class="delimiter">(</span><a href="#303783" title="Seq[T]">in</a>.<span title="=&gt; List[T]">toList</span>, <a href="#303783" title="Seq[T]">in</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Given a list, return all the permutations of the list.
   *
   * @param in -- the list
   *
   * @return all the permutations of the list
   */</span>
  <span class="keyword">def</span> <a title="[T](in: Seq[T])List[List[T]]" id="48899">permuteList</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48901">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[T]" id="288583">in</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[List[T]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">(</span><a href="#288583" title="Seq[T]">in</a>.<span title="=&gt; List[T]">toList</span>: @<span title="List[T] @unchecked">unchecked</span><span class="delimiter">)</span> <span title="List[List[T]]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="scala.collection.immutable.Nil.type">Nil</span> =&gt; <span title="object Nil">Nil</span>
    <span class="keyword">case</span> <a title="List[List[T]]" id="303853">x</a> :: <span title="object Nil">Nil</span> =&gt; <span title="(xs: List[T]*)List[List[T]]">List</span><span class="delimiter">(</span><span title="(xs: T*)List[T]">List</span><span class="delimiter">(</span><a href="#303853" title="T">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="List[List[T]]" id="303879">xs</a> =&gt; <a href="#48896" title="(in: Seq[T])List[List[T]]">rotateList</a><span class="delimiter">(</span><a href="#303879" title="List[T] @unchecked">xs</a><span class="delimiter">)</span>.<span title="(f: List[T] =&gt; scala.collection.GenTraversableOnce[List[T]])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[T]],List[T],List[List[T]]])List[List[T]]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,List[T],List[List[T]]]" class="delimiter">(</span><a title="List[T]" id="303926">x</a> =&gt; <span class="delimiter">(</span><a href="#303926" title="List[T]">x</a>: @<span title="List[T] @unchecked">unchecked</span><span class="delimiter">)</span> <span title="List[List[T]]" class="keyword">match</span> <span class="delimiter">{</span><span class="keyword">case</span> <a title="List[List[T]]" id="303931">x</a> :: <a title="List[T]" id="303932">xs</a> =&gt; <a href="#48899" title="(in: Seq[T])List[List[T]]">permuteList</a><span class="delimiter">(</span><a href="#303932" title="List[T]">xs</a><span class="delimiter">)</span>.<span title="(f: List[T] =&gt; List[T])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[T]],List[T],List[List[T]]])List[List[T]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,List[T],List[List[T]]]" class="delimiter">(</span><a href="#303931" title="T">x</a> <a href="#303968" title="(x: T)List[T]">::</a> <a href="#303967" title="List[T]">_</a><span class="delimiter">)</span> <span class="keyword">case</span> <span title="scala.collection.immutable.Nil.type">_</span> =&gt; <span title="object Nil">Nil</span><span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Given a list, return all the permutations including the removal of items (does not return a Nil list unless in is Nil).
   *
   * @param in the list to permute
   *
   * @return all the permutations of the list including sublists, sorted in longest to shortest
   */</span>
  <span class="keyword">def</span> <a title="[T](in: Seq[T])List[List[T]]" id="48902">permuteWithSublists</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48904">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[T]" id="288668">in</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[List[T]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(in: List[T])List[List[T]]" id="304030">internal</a><span class="delimiter">(</span><a title="List[T]" id="304031">in</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[List[T]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#304031" title="List[T]">in</a> <span title="List[List[T]]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="scala.collection.immutable.Nil.type">Nil</span> =&gt; <span title="object Nil">Nil</span>
      <span class="keyword">case</span> <a title="List[List[T]]" id="304038">x</a> :: <span title="object Nil">Nil</span> =&gt; <span title="(xs: List[T]*)List[List[T]]">List</span><span class="delimiter">(</span><span title="(xs: T*)List[T]">List</span><span class="delimiter">(</span><a href="#304038" title="T">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="List[List[T]]" id="304064">xs</a> =&gt; <span class="keyword">val</span> <a title="List[List[T]]" id="304065">rot</a> = <a href="#48896" title="(in: Seq[T])List[List[T]]">rotateList</a><span class="delimiter">(</span><a href="#304064" title="List[T]">xs</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[List[T]]" id="304066">ret</a> = <a href="#304065" title="List[List[T]]">rot</a>.<span title="(f: List[T] =&gt; scala.collection.GenTraversableOnce[List[T]])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[T]],List[T],List[List[T]]])List[List[T]]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,List[T],List[List[T]]]" class="delimiter">(</span><a title="List[T]" id="304095">z</a> =&gt; <span class="delimiter">(</span><a href="#304095" title="List[T]">z</a>: @<span title="List[T] @unchecked">unchecked</span><span class="delimiter">)</span> <span title="List[List[T]]" class="keyword">match</span> <span class="delimiter">{</span><span class="keyword">case</span> <a title="List[List[T]]" id="304100">x</a> :: <a title="List[T]" id="304101">xs</a> =&gt; <a href="#48899" title="(in: Seq[T])List[List[T]]">permuteList</a><span class="delimiter">(</span><a href="#304101" title="List[T]">xs</a><span class="delimiter">)</span>.<span title="(f: List[T] =&gt; List[T])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[T]],List[T],List[List[T]]])List[List[T]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,List[T],List[List[T]]]" class="delimiter">(</span><a href="#304100" title="T">x</a> <a href="#304141" title="(x: T)List[T]">::</a> <a href="#304140" title="List[T]">_</a><span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>
      <a href="#304066" title="List[List[T]]">ret</a> <a href="#304203" title="(prefix: List[List[T]])List[List[T]]">:::</a> <a href="#304065" title="List[List[T]]">rot</a>.<span title="(f: List[T] =&gt; List[T])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[T]],List[T],List[List[T]]])List[List[T]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,List[T],List[List[T]]]" class="delimiter">(</span><a title="List[T]" id="304220">z</a> =&gt; <span class="delimiter">(</span><a href="#304220" title="List[T]">z</a>: @<span title="List[T] @unchecked">unchecked</span><span class="delimiter">)</span> <span title="List[T]" class="keyword">match</span> <span class="delimiter">{</span><span class="keyword">case</span> <a title="List[T]" id="304225">x</a> :: <a title="List[T]" id="304226">xs</a> =&gt; <a href="#304226" title="List[T]">xs</a><span class="delimiter">}</span><span class="delimiter">)</span>.<span title="(f: List[T] =&gt; scala.collection.GenTraversableOnce[List[T]])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[T]],List[T],List[List[T]]])List[List[T]]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,List[T],List[List[T]]]" class="delimiter">(</span><a href="#304030" title="(in: List[T])List[List[T]]">internal</a><span class="delimiter">(</span><a href="#304277" title="List[T]">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#304030" title="(in: List[T])List[List[T]]">internal</a><span class="delimiter">(</span><a href="#288668" title="Seq[T]">in</a>.<span title="=&gt; List[T]">toList</span><span class="delimiter">)</span>.<span title="=&gt; List[List[T]]">distinct</span>.<span title="(lt: (List[T], List[T]) =&gt; Boolean)List[List[T]]">sortWith</span><span class="delimiter">(</span><a href="#304315" title="List[T]">_</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">&gt;</span> <a href="#304316" title="List[T]">_</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Add utility methods to Lists */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](in: List[T])ListHelpers.this.SuperList[T]" id="48905">toSuperList</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48907">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[T]" id="56258">in</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#48908" title="ListHelpers.this.SuperList[T]">SuperList</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="ListHelpers.this.SuperList[T]" class="keyword">new</span> <a href="#48908" title="ListHelpers.this.SuperList[T]">SuperList</a><span class="delimiter">(</span><a href="#56258" title="List[T]">in</a><span class="delimiter">)</span>

  <span class="comment">/** Add utility methods to Lists */</span>
  <span class="keyword">class</span> <a title="class SuperList[T] extends java.lang.Object with ScalaObject" id="48908">SuperList</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48909">T</a><span class="delimiter">]</span><a href="#48908" title="ScalaObject" class="delimiter">(</a><span class="keyword">val</span> <a title="List[T]" id="304322">what</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">/** permute the elements of a list */</span>
    <span class="keyword">def</span> <a title="=&gt; List[List[T]]" id="58410">permute</a> = <a href="#48899" title="(in: Seq[T])List[List[T]]">permuteList</a><span class="delimiter">(</span><a href="#304322" title="=&gt; List[T]">what</a><span class="delimiter">)</span>

    <span class="comment">/** return all the permuations of a list */</span>
    <span class="keyword">def</span> <a title="=&gt; List[List[T]]" id="58411">rotate</a> = <a href="#48896" title="(in: Seq[T])List[List[T]]">rotateList</a><span class="delimiter">(</span><a href="#304322" title="=&gt; List[T]">what</a><span class="delimiter">)</span>

    <span class="comment">/** return all the permuations of a list, including its sublists */</span>
    <span class="keyword">def</span> <a title="=&gt; List[List[T]]" id="58412">permuteAll</a> = <a href="#48902" title="(in: Seq[T])List[List[T]]">permuteWithSublists</a><span class="delimiter">(</span><a href="#304322" title="=&gt; List[T]">what</a><span class="delimiter">)</span>

    <span class="comment">/** return the first element of a list or a default element of the same type */</span>
    <span class="keyword">def</span> <a title="(other: =&gt; T)T" id="58413">headOr</a><span class="delimiter">(</span><a title="=&gt; T" id="304364">other</a>: =&gt; T<span class="delimiter">)</span>: <a href="#48909" title="T">T</a> = <a href="#48890" title="(l: Seq[T], deft: =&gt; T)T">head</a><span class="delimiter">(</span><a href="#304322" title="=&gt; List[T]">what</a>, <a href="#304364" title="=&gt; T">other</a><span class="delimiter">)</span>

    <span class="comment">/** return the list if not empty or another list */</span>
    <span class="keyword">def</span> <a title="(other: =&gt; List[T])List[T]" id="58414">or</a><span class="delimiter">(</span><a title="=&gt; List[T]" id="304380">other</a>: =&gt; List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="List[T]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#304322" title="=&gt; List[T]">what</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#304322" title="=&gt; List[T]">what</a> <span class="keyword">else</span> <a href="#304380" title="=&gt; List[T]">other</a>

    <span class="comment">/** return a string with all elements toString values appended */</span>
    <span class="keyword">def</span> <a title="=&gt; String" id="58415">str</a>: <span title="String">String</span> = <a href="#304322" title="=&gt; List[T]">what</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>

    <span class="comment">/** return all elements separated by a comma */</span>
    <span class="keyword">def</span> <a title="=&gt; String" id="58416">comma</a>: <span title="String">String</span> = <a href="#304322" title="=&gt; List[T]">what</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span>

    <span class="comment">/** alias for mkString */</span>
    <span class="keyword">def</span> <a title="(str: String)String" id="58417">join</a><span class="delimiter">(</span><a title="String" id="304388">str</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#304322" title="=&gt; List[T]">what</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><a href="#304388" title="String">str</a><span class="delimiter">)</span>

    <span class="comment">/** return true if not empty */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="58418">?</a> : <span title="Boolean">Boolean</span> = <span title="=&gt; Boolean">!</span><a href="#304322" title="=&gt; List[T]">what</a>.<span title="=&gt; Boolean">isEmpty</span>

    <span class="comment">/** return a new list where the element at position pos is replaced with another element */</span>
    <span class="keyword">def</span> <a title="(pos: Int, withWhat: T)List[T]" id="58419">replace</a><span class="delimiter">(</span><a title="Int" id="304395">pos</a>: <span title="Int">Int</span>, <a title="T" id="304396">withWhat</a>: <a href="#48909" title="T">T</a><span class="delimiter">)</span>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(pos: Int, withWhat: T, rest: List[T])List[T]" id="304398">repl</a><span class="delimiter">(</span><a title="Int" id="304399">pos</a>: <span title="Int">Int</span>, <a title="T" id="304400">withWhat</a>: <a href="#48909" title="T">T</a>, <a title="List[T]" id="304401">rest</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#304401" title="List[T]">rest</a> <span title="List[T]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="scala.collection.immutable.Nil.type">Nil</span> =&gt; <span title="object Nil">Nil</span>
        <span class="keyword">case</span> <a title="List[T]" id="304408">x</a> :: <a title="List[T]" id="304409">xs</a> <span class="keyword">if</span> <a href="#304399" title="Int">pos</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span> =&gt; <a href="#304400" title="T">withWhat</a> <a href="#304414" title="(x: T)List[T]">::</a> <a href="#304409" title="List[T]">xs</a>
        <span class="keyword">case</span> <a title="List[T]" id="304424">x</a> :: <a title="List[T]" id="304425">xs</a> =&gt; <a href="#304424" title="T">x</a> <a href="#304426" title="(x: T)List[T]">::</a> <a href="#304398" title="(pos: Int, withWhat: T, rest: List[T])List[T]">repl</a><span class="delimiter">(</span><a href="#304399" title="Int">pos</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>, <a href="#304400" title="T">withWhat</a>, <a href="#304425" title="List[T]">xs</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#304398" title="(pos: Int, withWhat: T, rest: List[T])List[T]">repl</a><span class="delimiter">(</span><a href="#304395" title="Int">pos</a>, <a href="#304396" title="T">withWhat</a>, <a href="#304322" title="=&gt; List[T]">what</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>


        </pre>
    </body>
</html>