<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/reflect/api/Types.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scala.reflect
<span class="keyword">package</span> api

<span class="keyword">trait</span> <a title="trait Types extends Object" id="18231">Types</a> <a href="../../Unit.scala.html#2389" title="Unit" class="delimiter">{</a> self: Universe =&gt;

  /** This class declares operations that are visible in a Type.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class AbsType extends Object" id="23481">AbsType</a> <a href="#23481" title="Types.this.AbsType" class="delimiter">{</a>
    /** The type symbol associated with the type, or `NoSymbol` for types
     *  that do not refer to a type symbol.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="424800">typeSymbol</a>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a>

    /** The defined or declared members with name `name` in this type;
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Alternatives of overloaded symbol appear in the order they are declared.
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="424801">declaration</a><span class="delimiter">(</span><a title="Types.this.Name" id="429198">name</a>: <a href="Names.scala.html#23553" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a>

    /** The collection of declarations in this type
     */
    <span class="keyword">def</span> <a title="=&gt; Iterable[Types.this.Symbol]" id="424802">declarations</a>: <a href="../../collection/Iterable.scala.html#5446" title="Iterable[Types.this.Symbol]">Iterable</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    /** The member with given name, either directly declared or inherited,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="424803">member</a><span class="delimiter">(</span><a title="Types.this.Name" id="429213">name</a>: <a href="Names.scala.html#23553" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a>

    /** The non-private member with given name, either directly declared or inherited,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="424804">nonPrivateMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="429216">name</a>: <a href="Names.scala.html#23553" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a>

    /** An iterable containing all members of this type (directly declared or inherited)
     *  Members appear in the linearization order of their owners.
     *  Members with the same owner appear in reverse order of their declarations.
     */
    <span class="keyword">def</span> <a title="=&gt; Iterable[Types.this.Symbol]" id="424805">members</a>: <a href="../../collection/Iterable.scala.html#5446" title="Iterable[Types.this.Symbol]">Iterable</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    /** An iterable containing all non-private members of this type (directly declared or inherited)
     *  Members appear in the linearization order of their owners.
     *  Members with the same owner appear in reverse order of their declarations.
     */
    <span class="keyword">def</span> <a title="=&gt; Iterable[Types.this.Symbol]" id="424806">nonPrivateMembers</a>: <a href="../../collection/Iterable.scala.html#5446" title="Iterable[Types.this.Symbol]">Iterable</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    /** Substitute types in `to` for corresponding occurrences of references to
     *  symbols `from` in this type.
     */
    <span class="keyword">def</span> <a title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type" id="424807">substituteTypes</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="429220">from</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="429221">to</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>

    /** If this is a parameterized types, the type arguments.
     *  Otherwise the empty list
     */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="424808">typeArguments</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>

    /** For a (potentially wrapped) poly type, its type parameters,
     *  the empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="424809">typeParams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    /** Is this type a type constructor that is missing its type arguments?
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="424810">isHigherKinded</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a>   // !!! This should be called &quot;isTypeConstructor&quot;, no?

    /** Returns the corresponding type constructor (e.g. List for List[T] or List[String])
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="424811">typeConstructor</a>: <a href="#23486" title="Types.this.Type">Type</a>

    /** Does this type refer to spliceable types or is a spliceable type?
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="424812">isConcrete</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a>

    /** Is this type an abstract type that needs to be resolved?
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="424813">isSpliceable</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a>

    /**
     *  Expands type aliases and converts higher-kinded TypeRefs to PolyTypes.
     *  Functions on types are also implemented as PolyTypes.
     *
     *  Example: (in the below, &lt;List&gt; is the type constructor of List)
     *    TypeRef(pre, &lt;List&gt;, List()) is replaced by
     *    PolyType(X, TypeRef(pre, &lt;List&gt;, List(X)))
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="424814">normalize</a>: <a href="#23486" title="Types.this.Type">Type</a>     // !!! Alternative name? &quot;normalize&quot; is used to mean too many things.

    /** Does this type conform to given type argument `that`? */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="424815">&lt;:&lt;</a> <span class="delimiter">(</span><a title="Types.this.Type" id="429183">that</a>: <a href="#23486" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a>

    /** Is this type equivalent to given type argument `that`? */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="424816">=:=</a> <span class="delimiter">(</span><a title="Types.this.Type" id="429180">that</a>: <a href="#23486" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a>

    /** The list of all base classes of this type (including its own typeSymbol)
     *  in reverse linearization order, starting with the class itself and ending
     *  in class Any.
     */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="424817">baseClasses</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>   // !!! Alternative name, perhaps linearization?

    /** The least type instance of given class which is a supertype
     *  of this type.  Example:
     *  {{{
     *    class D[T]
     *    class C extends p.D[Int]
     *    ThisType(C).baseType(D) = p.D[Int]
     * }}}
     */
    <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="424818">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="429192">clazz</a>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>

    /** This type as seen from prefix `pre` and class `clazz`. This means:
     *  Replace all thistypes of `clazz` or one of its subclasses
     *  by `pre` and instantiate all parameters by arguments of `pre`.
     *  Proceed analogously for thistypes referring to outer classes.
     *
     *  Example:
     *    class D[T] { def m: T }
     *    class C extends p.D[Int]
     *    T.asSeenFrom(ThisType(C), D)  (where D is owner of m)
     *      = Int
     */
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="424819">asSeenFrom</a><span class="delimiter">(</span><a title="Types.this.Type" id="429187">pre</a>: <a href="#23486" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="429188">clazz</a>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>

    /** The erased type corresponding to this type after
     *  all transformations from Scala to Java have been performed.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="424820">erasure</a>: <a href="#23486" title="Types.this.Type">Type</a>    // !!! &quot;erasedType&quot;, compare with &quot;widen&quot; (so &quot;erase&quot;) or &quot;underlying&quot; (so &quot;erased&quot;)
                         // why not name it &quot;erasure&quot;?

   /** Apply `f` to each part of this type, returning
    *  a new type. children get mapped before their parents */
    <span class="keyword">def</span> <a title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.Type" id="424821">map</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Types.this.Type" id="429210">f</a>: Type =&gt; Type<span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>

    /** Apply `f` to each part of this type, for side effects only */
    <span class="keyword">def</span> <a title="(f: Types.this.Type =&gt; Unit)Unit" id="424822">foreach</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Unit" id="429207">f</a>: Type =&gt; Unit<span class="delimiter">)</span>

    /** Returns optionally first type (in a preorder traversal) which satisfies predicate `p`,
     *  or None if none exists.
     */
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Option[Types.this.Type]" id="424823">find</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="429204">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[Types.this.Type]">Option</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>

    /** Is there part of this type which satisfies predicate `p`? */
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Boolean" id="424824">exists</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="429201">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a>

    /** Does this type contain a reference to given symbol? */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="424825">contains</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="429195">sym</a>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a>

    /** If this is a compound type, the list of its parent types;
     *  otherwise the empty list
     */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="424826">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>

    /** If this is a singleton type, returns the type underlying it;
     *  otherwise returns this type itself.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="424827">underlying</a>: <a href="#23486" title="Types.this.Type">Type</a>

    /** If this is a singleton type, widen it to its nearest underlying non-singleton
     *  base type by applying one or more `underlying` dereferences.
     *  If this is not a singleton type, returns this type itself.
     *
     *  Example:
     *
     *  class Outer { class C ; val x: C }
     *  val o: Outer
     *  &lt;o.x.type&gt;.widen = o.C
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="424828">widen</a>: <a href="#23486" title="Types.this.Type">Type</a>

    /** The kind of this type; used for debugging */
    <span class="keyword">def</span> <a title="=&gt; String" id="424829">kind</a>: <span title="String">String</span>
  <span class="delimiter">}</span>

  /** An object representing an unknown type, used during type inference.
   *  If you see WildcardType outside of inference it is almost certainly a bug.
   */
  <span class="keyword">val</span> <a title="=&gt; Types.this.Type" id="23482">WildcardType</a>: <a href="#23486" title="Types.this.Type">Type</a>

  /** BoundedWildcardTypes, used only during type inference, are created in
   *  two places that I can find:
   *
   *    1. If the expected type of an expression is an existential type,
   *       its hidden symbols are replaced with bounded wildcards.
   *    2. When an implicit conversion is being sought based in part on
   *       the name of a method in the converted type, a HasMethodMatching
   *       type is created: a MethodType with parameters typed as
   *       BoundedWildcardTypes.
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Types.this.Type" id="23483">BoundedWildcardType</a> &gt;: Null &lt;: Type

  <span class="keyword">val</span> <a title="=&gt; Types.this.BoundedWildcardTypeExtractor" id="23484">BoundedWildcardType</a>: <a href="#23485" title="Types.this.BoundedWildcardTypeExtractor">BoundedWildcardTypeExtractor</a>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class BoundedWildcardTypeExtractor extends Object" id="23485">BoundedWildcardTypeExtractor</a> <a href="#23485" title="Types.this.BoundedWildcardTypeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(bounds: Types.this.TypeBounds)Types.this.BoundedWildcardType" id="429018">apply</a><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="429239">bounds</a>: <a href="#23520" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">)</span>: <a href="#23483" title="Types.this.BoundedWildcardType">BoundedWildcardType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.BoundedWildcardType)Option[Types.this.TypeBounds]" id="429019">unapply</a><span class="delimiter">(</span><a title="Types.this.BoundedWildcardType" id="429242">tpe</a>: <a href="#23483" title="Types.this.BoundedWildcardType">BoundedWildcardType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[Types.this.TypeBounds]">Option</a><span class="delimiter">[</span>TypeBounds<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The type of Scala types, and also Scala type signatures.
   *  (No difference is internally made between the two).
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Types.this.AbsType" id="23486">Type</a> &gt;: Null &lt;: AbsType

  /** The type of Scala singleton types, i.e. types that are inhabited
   *  by only one nun-null value. These include types of the forms
   *  {{{
   *    C.this.type
   *    C.super.type
   *    x.type
   *  }}}
   *  as well as constant types.
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Types.this.Type" id="23487">SingletonType</a> &gt;: Null &lt;: Type

  /** This constant is used as a special value that indicates that no meaningful type exists.
   */
  <span class="keyword">val</span> <a title="=&gt; Types.this.Type" id="23488">NoType</a>: <a href="#23486" title="Types.this.Type">Type</a>

  /** This constant is used as a special value denoting the empty prefix in a path dependent type.
   *  For instance `x.type` is represented as `SingleType(NoPrefix, &lt;x&gt;)`, where `&lt;x&gt;` stands for
   *  the symbol for `x`.
   */
  <span class="keyword">val</span> <a title="=&gt; Types.this.Type" id="23489">NoPrefix</a>: <a href="#23486" title="Types.this.Type">Type</a>

  /** The `ThisType` type describes types of the form on the left with the
   *  correspnding ThisType representations to the right.
   *  {{{
   *     C.this.type             ThisType(C)
   *  }}}
   */
  <span class="keyword">type</span> <a title=" &lt;: Types.this.SingletonType" id="23490">ThisType</a> &lt;: SingletonType

  /** The constructor/deconstructor for `ThisType` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.ThisTypeExtractor" id="23491">ThisType</a>: <a href="#23492" title="Types.this.ThisTypeExtractor">ThisTypeExtractor</a>

  /** An extractor class to create and pattern match with syntax `ThisType(sym)`
   *  where `sym` is the class prefix of the this type.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ThisTypeExtractor extends Object" id="23492">ThisTypeExtractor</a> <a href="#23492" title="Types.this.ThisTypeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="429080">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="429344">sym</a>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.ThisType)Option[Types.this.Symbol]" id="429081">unapply</a><span class="delimiter">(</span><a title="Types.this.ThisType" id="429347">tpe</a>: <a href="#23490" title="Types.this.ThisType">ThisType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[Types.this.Symbol]">Option</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The `TypeRef` type describes types of any of the forms on the left,
   *  with their TypeRef representations to the right.
   *  {{{
   *     T # C[T_1, ..., T_n]      TypeRef(T, C, List(T_1, ..., T_n))
   *     p.C[T_1, ..., T_n]        TypeRef(p.type, C, List(T_1, ..., T_n))
   *     C[T_1, ..., T_n]          TypeRef(NoPrefix, C, List(T_1, ..., T_n))
   *     T # C                     TypeRef(T, C, Nil)
   *     p.C                       TypeRef(p.type, C, Nil)
   *     C                         TypeRef(NoPrefix, C, Nil)
   *  }}}
   */
  <span class="keyword">type</span> <a title=" &lt;: Types.this.Type" id="23493">TypeRef</a> &lt;: Type

  /** The constructor/deconstructor for `TypeRef` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.TypeRefExtractor" id="23494">TypeRef</a>: <a href="#23495" title="Types.this.TypeRefExtractor">TypeRefExtractor</a>

  /** An extractor class to create and pattern match with syntax `TypeRef(pre, sym, args)`
   *  Here, `pre` is the prefix of the type reference, `sym` is the symbol
   *  referred to by the type reference, and `args` is a possible empty list of
   *  type argumenrts.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeRefExtractor extends Object" id="23495">TypeRefExtractor</a> <a href="#23495" title="Types.this.TypeRefExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="429092">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="429363">pre</a>: <a href="#23486" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="429364">sym</a>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="429365">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.TypeRef)Option[(Types.this.Type, Types.this.Symbol, List[Types.this.Type])]" id="429093">unapply</a><span class="delimiter">(</span><a title="Types.this.TypeRef" id="429370">tpe</a>: <a href="#23493" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[(Types.this.Type, Types.this.Symbol, List[Types.this.Type])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Type, Symbol, List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The `SingleType` type describes types of any of the forms on the left,
   *  with their TypeRef representations to the right.
   *  {{{
   *     (T # x).type             SingleType(T, x)
   *     p.x.type                 SingleType(p.type, x)
   *     x.type                   SingleType(NoPrefix, x)
   *  }}}
   */
  <span class="keyword">type</span> <a title=" &lt;: Types.this.SingletonType" id="23496">SingleType</a> &lt;: SingletonType

  /** The constructor/deconstructor for `SingleType` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.SingleTypeExtractor" id="23497">SingleType</a>: <a href="#23498" title="Types.this.SingleTypeExtractor">SingleTypeExtractor</a>

  /** An extractor class to create and pattern match with syntax `SingleType(pre, sym)`
   *  Here, `pre` is the prefix of the single-type, and `sym` is the stable value symbol
   *  referred to by the single-type.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SingleTypeExtractor extends Object" id="23498">SingleTypeExtractor</a> <a href="#23498" title="Types.this.SingleTypeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="429068">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="429325">pre</a>: <a href="#23486" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="429326">sym</a>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.SingleType)Option[(Types.this.Type, Types.this.Symbol)]" id="429069">unapply</a><span class="delimiter">(</span><a title="Types.this.SingleType" id="429330">tpe</a>: <a href="#23496" title="Types.this.SingleType">SingleType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[(Types.this.Type, Types.this.Symbol)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Type, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The `SuperType` type is not directly written, but arises when `C.super` is used
   *  as a prefix in a `TypeRef` or `SingleType`. It's internal presentation is
   *  {{{
   *     SuperType(thistpe, supertpe)
   *  }}}
   *  Here, `thistpe` is the type of the corresponding this-type. For instance,
   *  in the type arising from C.super, the `thistpe` part would be `ThisType(C)`.
   *  `supertpe` is the type of the super class referred to by the `super`.
   */
  <span class="keyword">type</span> <a title=" &lt;: Types.this.SingletonType" id="23499">SuperType</a> &lt;: SingletonType

  /** The constructor/deconstructor for `SuperType` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.SuperTypeExtractor" id="23500">SuperType</a>: <a href="#23501" title="Types.this.SuperTypeExtractor">SuperTypeExtractor</a>

  /** An extractor class to create and pattern match with syntax `SingleType(thistpe, supertpe)`
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SuperTypeExtractor extends Object" id="23501">SuperTypeExtractor</a> <a href="#23501" title="Types.this.SuperTypeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(thistpe: Types.this.Type, supertpe: Types.this.Type)Types.this.Type" id="429074">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="429335">thistpe</a>: <a href="#23486" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="429336">supertpe</a>: <a href="#23486" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.SuperType)Option[(Types.this.Type, Types.this.Type)]" id="429075">unapply</a><span class="delimiter">(</span><a title="Types.this.SuperType" id="429340">tpe</a>: <a href="#23499" title="Types.this.SuperType">SuperType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[(Types.this.Type, Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Type, Type<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The `ConstantType` type is not directly written in user programs, but arises as the type of a constant.
   *  The REPL expresses constant types like   Int(11).  Here are some constants with their types.
   *  {{{
   *     1           ConstantType(Constant(1))
   *     &quot;abc&quot;       ConstantType(Constant(&quot;abc&quot;))
   *  }}}
   */
  <span class="keyword">type</span> <a title=" &lt;: Types.this.SingletonType" id="23502">ConstantType</a> &lt;: SingletonType

  /** The constructor/deconstructor for `ConstantType` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.ConstantTypeExtractor" id="23503">ConstantType</a>: <a href="#23504" title="Types.this.ConstantTypeExtractor">ConstantTypeExtractor</a>

  /** An extractor class to create and pattern match with syntax `ConstantType(constant)`
   *  Here, `constant` is the constant value represented by the type.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ConstantTypeExtractor extends Object" id="23504">ConstantTypeExtractor</a> <a href="#23504" title="Types.this.ConstantTypeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(value: Types.this.Constant)Types.this.ConstantType" id="429030">apply</a><span class="delimiter">(</span><a title="Types.this.Constant" id="429259">value</a>: <a href="Constants.scala.html#23544" title="Types.this.Constant">Constant</a><span class="delimiter">)</span>: <a href="#23502" title="Types.this.ConstantType">ConstantType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.ConstantType)Option[Types.this.Constant]" id="429031">unapply</a><span class="delimiter">(</span><a title="Types.this.ConstantType" id="429262">tpe</a>: <a href="#23502" title="Types.this.ConstantType">ConstantType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[Types.this.Constant]">Option</a><span class="delimiter">[</span>Constant<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** A subtype of Type representing refined types as well as `ClassInfo` signatures.
   */
  <span class="keyword">type</span> <a title=" &lt;: Types.this.Type" id="23505">CompoundType</a> &lt;: Type

  /** The `RefinedType` type defines types of any of the forms on the left,
   *  with their RefinedType representations to the right.
   *  {{{
   *     P_1 with ... with P_m { D_1; ...; D_n}      RefinedType(List(P_1, ..., P_m), Scope(D_1, ..., D_n))
   *     P_1 with ... with P_m                       RefinedType(List(P_1, ..., P_m), Scope())
   *     { D_1; ...; D_n}                            RefinedType(List(AnyRef), Scope(D_1, ..., D_n))
   *  }}}
   */
  <span class="keyword">type</span> <a title=" &lt;: Types.this.CompoundType" id="23506">RefinedType</a> &lt;: CompoundType

  /** The constructor/deconstructor for `RefinedType` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.RefinedTypeExtractor" id="23507">RefinedType</a>: <a href="#23508" title="Types.this.RefinedTypeExtractor">RefinedTypeExtractor</a>

  /** An extractor class to create and pattern match with syntax `RefinedType(parents, decls)`
   *  Here, `parents` is the list of parent types of the class, and `decls` is the scope
   *  containing all declarations in the class.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class RefinedTypeExtractor extends Object" id="23508">RefinedTypeExtractor</a> <a href="#23508" title="Types.this.RefinedTypeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.RefinedType" id="429060">apply</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="429311">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="429312">decls</a>: <a href="Scopes.scala.html#23548" title="Types.this.Scope">Scope</a><span class="delimiter">)</span>: <a href="#23506" title="Types.this.RefinedType">RefinedType</a>

    /** An alternative constructor that passes in the synthetic classs symbol
     *  that backs the refined type. (Normally, a fresh class symbol is created automatically).
     */
    <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType" id="429061">apply</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="429305">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="429306">decls</a>: <a href="Scopes.scala.html#23548" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="429307">clazz</a>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#23506" title="Types.this.RefinedType">RefinedType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.RefinedType)Option[(List[Types.this.Type], Types.this.Scope)]" id="429062">unapply</a><span class="delimiter">(</span><a title="Types.this.RefinedType" id="429320">tpe</a>: <a href="#23506" title="Types.this.RefinedType">RefinedType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[(List[Types.this.Type], Types.this.Scope)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span>, Scope<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title=" &lt;: Types.this.Type" id="23509">NullaryMethodType</a> &lt;: Type
  <span class="keyword">val</span> <a title="=&gt; Types.this.NullaryMethodTypeExtractor" id="23510">NullaryMethodType</a>: <a href="#23526" title="Types.this.NullaryMethodTypeExtractor">NullaryMethodTypeExtractor</a>

  <span class="keyword">type</span> <a title=" &lt;: Types.this.Type" id="23511">PolyType</a> &lt;: Type
  <span class="keyword">val</span> <a title="=&gt; Types.this.PolyTypeExtractor" id="23512">PolyType</a>: <a href="#23527" title="Types.this.PolyTypeExtractor">PolyTypeExtractor</a>

  <span class="keyword">type</span> <a title=" &lt;: Types.this.Type" id="23513">ExistentialType</a> &lt;: Type
  <span class="keyword">val</span> <a title="=&gt; Types.this.ExistentialTypeExtractor" id="23514">ExistentialType</a>: <a href="#23528" title="Types.this.ExistentialTypeExtractor">ExistentialTypeExtractor</a>

  <span class="keyword">type</span> <a title=" &lt;: Types.this.Type" id="23515">AnnotatedType</a> &lt;: Type
  <span class="keyword">val</span> <a title="=&gt; Types.this.AnnotatedTypeExtractor" id="23516">AnnotatedType</a>: <a href="#23529" title="Types.this.AnnotatedTypeExtractor">AnnotatedTypeExtractor</a>

  /** The `MethodType` type signature is used to indicate parameters and result type of a method
   */
  <span class="keyword">type</span> <a title=" &lt;: Types.this.Type" id="23517">MethodType</a> &lt;: Type

  /** The constructor/deconstructor for `MethodType` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.MethodTypeExtractor" id="23518">MethodType</a>: <a href="#23519" title="Types.this.MethodTypeExtractor">MethodTypeExtractor</a>

  /** An extractor class to create and pattern match with syntax `MethodType(params, respte)`
   *  Here, `params` is a potentially empty list of parameter symbols of the method,
   *  and `restpe` is the result type of the method. If the method is curried, `restpe` would
   *  be another `MethodType`.
   *  Note: `MethodType(Nil, Int)` would be the type of a method defined with an empty parameter list.
   *  {{{
   *     def f(): Int
   *  }}}
   *  If the method is completely parameterless, as in
   *  {{{
   *     def f: Int
   *  }}}
   *  its type is a `NullaryMethodType`.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class MethodTypeExtractor extends Object" id="23519">MethodTypeExtractor</a> <a href="#23519" title="Types.this.MethodTypeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType" id="429042">apply</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="429277">params</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="429278">resultType</a>: <a href="#23486" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#23517" title="Types.this.MethodType">MethodType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.MethodType)Option[(List[Types.this.Symbol], Types.this.Type)]" id="429043">unapply</a><span class="delimiter">(</span><a title="Types.this.MethodType" id="429282">tpe</a>: <a href="#23517" title="Types.this.MethodType">MethodType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[(List[Types.this.Symbol], Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, Type<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The `TypeBounds` type signature is used to indicate lower and upper type bounds
   *  of type parameters and abstract types. It is not a first-class type.
   *  If an abstract type or type parameter is declared with any of the forms
   *  on the left, its type signature is the TypeBounds type on the right.
   *  {{{
   *     T &gt;: L &lt;: U               TypeBounds(L, U)
   *     T &gt;: L                    TypeBounds(L, Any)
   *     T &lt;: U                    TypeBounds(Nothing, U)
   *  }}}
   */
  <span class="keyword">type</span> <a title=" &lt;: Types.this.Type" id="23520">TypeBounds</a> &lt;: Type

  /** The constructor/deconstructor for `TypeBounds` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.TypeBoundsExtractor" id="23521">TypeBounds</a>: <a href="#23522" title="Types.this.TypeBoundsExtractor">TypeBoundsExtractor</a>

  /** An extractor class to create and pattern match with syntax `TypeBound(lower, upper)`
   *  Here, `lower` is the lower bound of the `TypeBounds` pair, and `upper` is
   *  the upper bound.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeBoundsExtractor extends Object" id="23522">TypeBoundsExtractor</a> <a href="#23522" title="Types.this.TypeBoundsExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds" id="429086">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="429352">lo</a>: <a href="#23486" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="429353">hi</a>: <a href="#23486" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#23520" title="Types.this.TypeBounds">TypeBounds</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.TypeBounds)Option[(Types.this.Type, Types.this.Type)]" id="429087">unapply</a><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="429357">tpe</a>: <a href="#23520" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[(Types.this.Type, Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Type, Type<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The `ClassInfo` type signature is used to define parents and declarations
   *  of classes, traits, and objects. If a class, trait, or object C is declared like this
   *  {{{
   *     C extends P_1 with ... with P_m { D_1; ...; D_n}
   *  }}}
   *  its `ClassInfo` type has the following form:
   *  {{{
   *     ClassInfo(List(P_1, ..., P_m), Scope(D_1, ..., D_n), C)
   *  }}}
   */
  <span class="keyword">type</span> <a title=" &lt;: Types.this.CompoundType" id="23523">ClassInfoType</a> &lt;: CompoundType

  /** The constructor/deconstructor for `ClassInfoType` instances. */
  <span class="keyword">val</span> <a title="=&gt; Types.this.ClassInfoTypeExtractor" id="23524">ClassInfoType</a>: <a href="#23525" title="Types.this.ClassInfoTypeExtractor">ClassInfoTypeExtractor</a>

  /** An extractor class to create and pattern match with syntax `ClassInfo(parents, decls, clazz)`
   *  Here, `parents` is the list of parent types of the class, `decls` is the scope
   *  containing all declarations in the class, and `clazz` is the symbol of the class
   *  itself.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ClassInfoTypeExtractor extends Object" id="23525">ClassInfoTypeExtractor</a> <a href="#23525" title="Types.this.ClassInfoTypeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.ClassInfoType" id="429024">apply</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="429248">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="429249">decls</a>: <a href="Scopes.scala.html#23548" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="429250">clazz</a>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#23523" title="Types.this.ClassInfoType">ClassInfoType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.ClassInfoType)Option[(List[Types.this.Type], Types.this.Scope, Types.this.Symbol)]" id="429025">unapply</a><span class="delimiter">(</span><a title="Types.this.ClassInfoType" id="429255">tpe</a>: <a href="#23523" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[(List[Types.this.Type], Types.this.Scope, Types.this.Symbol)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span>, Scope, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class NullaryMethodTypeExtractor extends Object" id="23526">NullaryMethodTypeExtractor</a> <a href="#23526" title="Types.this.NullaryMethodTypeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(resultType: Types.this.Type)Types.this.NullaryMethodType" id="429048">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="429286">resultType</a>: <a href="#23486" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#23509" title="Types.this.NullaryMethodType">NullaryMethodType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.NullaryMethodType)Option[Types.this.Type]" id="429049">unapply</a><span class="delimiter">(</span><a title="Types.this.NullaryMethodType" id="429289">tpe</a>: <a href="#23509" title="Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[Types.this.Type]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Type<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class PolyTypeExtractor extends Object" id="23527">PolyTypeExtractor</a> <a href="#23527" title="Types.this.PolyTypeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType" id="429054">apply</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="429294">typeParams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="429295">resultType</a>: <a href="#23486" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#23511" title="Types.this.PolyType">PolyType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.PolyType)Option[(List[Types.this.Symbol], Types.this.Type)]" id="429055">unapply</a><span class="delimiter">(</span><a title="Types.this.PolyType" id="429299">tpe</a>: <a href="#23511" title="Types.this.PolyType">PolyType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[(List[Types.this.Symbol], Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, Type<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ExistentialTypeExtractor extends Object" id="23528">ExistentialTypeExtractor</a> <a href="#23528" title="Types.this.ExistentialTypeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType" id="429036">apply</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="429267">quantified</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="429268">underlying</a>: <a href="#23486" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#23513" title="Types.this.ExistentialType">ExistentialType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.ExistentialType)Option[(List[Types.this.Symbol], Types.this.Type)]" id="429037">unapply</a><span class="delimiter">(</span><a title="Types.this.ExistentialType" id="429272">tpe</a>: <a href="#23513" title="Types.this.ExistentialType">ExistentialType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[(List[Types.this.Symbol], Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, Type<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class AnnotatedTypeExtractor extends Object" id="23529">AnnotatedTypeExtractor</a> <a href="#23529" title="Types.this.AnnotatedTypeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType" id="429012">apply</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="429228">annotations</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span>, <a title="Types.this.Type" id="429229">underlying</a>: <a href="#23486" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="429230">selfsym</a>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#23515" title="Types.this.AnnotatedType">AnnotatedType</a>
    <span class="keyword">def</span> <a title="(tpe: Types.this.AnnotatedType)Option[(List[Types.this.AnnotationInfo], Types.this.Type, Types.this.Symbol)]" id="429013">unapply</a><span class="delimiter">(</span><a title="Types.this.AnnotatedType" id="429235">tpe</a>: <a href="#23515" title="Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[(List[Types.this.AnnotationInfo], Types.this.Type, Types.this.Symbol)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span>, Type, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The least upper bound wrt &lt;:&lt; of a list of types */
  <span class="keyword">def</span> <a title="(xs: List[Types.this.Type])Types.this.Type" id="23530">lub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="429130">xs</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>

    /** The greatest lower bound wrt &lt;:&lt; of a list of types */
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="23531">glb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="429113">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>

  // Creators ---------------------------------------------------------------
  // too useful and too non-trivial to be left out of public API
  // [Eugene to Paul] needs review!

  /** The canonical creator for single-types */
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="23532">singleType</a><span class="delimiter">(</span><a title="Types.this.Type" id="429164">pre</a>: <a href="#23486" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="429165">sym</a>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>

  /** the canonical creator for a refined type with a given scope */
  <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type" id="23533">refinedType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="429147">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="429148">owner</a>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Scope" id="429149">decls</a>: <a href="Scopes.scala.html#23548" title="Types.this.Scope">Scope</a>, <a title="Types.this.Position" id="429150">pos</a>: <a href="Positions.scala.html#23793" title="Types.this.Position">Position</a><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>

  /** The canonical creator for a refined type with an initially empty scope.
   *
   *  @param parents ...
   *  @param owner   ...
   *  @return        ...
   */
  <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type" id="23534">refinedType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="429143">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="429144">owner</a>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>

  /** The canonical creator for typerefs
   */
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="23535">typeRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="429172">pre</a>: <a href="#23486" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="429173">sym</a>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="429174">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>

  /** A creator for intersection type where intersections of a single type are
   *  replaced by the type itself. */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type])Types.this.Type" id="23536">intersectionType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="429123">tps</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>

  /** A creator for intersection type where intersections of a single type are
   *  replaced by the type itself, and repeated parent classes are merged.
   *
   *  !!! Repeated parent classes are not merged - is this a bug in the
   *  comment or in the code?
   */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type" id="23537">intersectionType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="429119">tps</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="429120">owner</a>: <a href="Symbols.scala.html#23447" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>

  /** A creator for type applications */
  <span class="keyword">def</span> <a title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type" id="23538">appliedType</a><span class="delimiter">(</span><a title="Types.this.Type" id="429100">tycon</a>: <a href="#23486" title="Types.this.Type">Type</a>, <a title="List[Types.this.Type]" id="429101">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>

  /** A creator for type parameterizations that strips empty type parameter lists.
   *  Use this factory method to indicate the type has kind * (it's a polymorphic value)
   *  until we start tracking explicit kinds equivalent to typeFun (except that the latter requires tparams nonEmpty).
   */
  <span class="keyword">def</span> <a title="(tparams: List[Types.this.Symbol], tpe: Types.this.Type)Types.this.Type" id="23539">polyType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="429135">tparams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="429136">tpe</a>: <a href="#23486" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>

  /** A creator for existential types. This generates:
   *
   *  tpe1 where { tparams }
   *
   *  where `tpe1` is the result of extrapolating `tpe` wrt to `tparams`.
   *  Extrapolating means that type variables in `tparams` occurring
   *  in covariant positions are replaced by upper bounds, (minus any
   *  SingletonClass markers), type variables in `tparams` occurring in
   *  contravariant positions are replaced by upper bounds, provided the
   *  resulting type is legal wrt to stability, and does not contain any type
   *  variable in `tparams`.
   *
   *  The abstraction drops all type parameters that are not directly or
   *  indirectly referenced by type `tpe1`. If there are no remaining type
   *  parameters, simply returns result type `tpe`.
   */
  <span class="keyword">def</span> <a title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type" id="23540">existentialAbstraction</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="429107">tparams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="429108">tpe0</a>: <a href="#23486" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#23486" title="Types.this.Type">Type</a>
<span class="delimiter">}</span>


        </pre>
    </body>
</html>