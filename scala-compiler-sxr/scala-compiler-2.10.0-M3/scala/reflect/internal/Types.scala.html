<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/reflect/internal/Types.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
/* NSC -- new Scala compiler
 * Copyright 2005-2011 LAMP/EPFL
 * @author  Martin Odersky
 */

<span class="keyword">package</span> scala.reflect
<span class="keyword">package</span> internal

<span class="keyword">import</span> scala.collection.<span class="delimiter">{</span> mutable, immutable <span class="delimiter">}</span>
<span class="keyword">import</span> scala.ref.WeakReference
<span class="keyword">import</span> mutable.ListBuffer
<span class="keyword">import</span> <a href="Flags.scala.html#20545" title="scala.reflect.internal.Flags.type">Flags</a>._
<span class="keyword">import</span> scala.util.control.ControlThrowable
<span class="keyword">import</span> scala.annotation.tailrec
<span class="keyword">import</span> util.<a href="util/Statistics.scala.html#23007" title="scala.reflect.internal.util.Statistics.type">Statistics</a>._

/* A standard type pattern match:
  case ErrorType =&gt;
    // internal: error
  case WildcardType =&gt;
    // internal: unknown
  case NoType =&gt;
  case NoPrefix =&gt;
  case ThisType(sym) =&gt;
    // sym.this.type
  case SuperType(thistpe, supertpe) =&gt;
    // super references
  case SingleType(pre, sym) =&gt;
    // pre.sym.type
  case ConstantType(value) =&gt;
    // Int(2)
  case TypeRef(pre, sym, args) =&gt;
    // pre.sym[targs]
    // Outer.this.C would be represented as TypeRef(ThisType(Outer), C, List())
  case RefinedType(parents, defs) =&gt;
    // parent1 with ... with parentn { defs }
  case ExistentialType(tparams, result) =&gt;
    // result forSome { tparams }
  case AnnotatedType(annots, tp, selfsym) =&gt;
    // tp @annots

  // the following are non-value types; you cannot write them down in Scala source.

  case TypeBounds(lo, hi) =&gt;
    // &gt;: lo &lt;: hi
  case ClassInfoType(parents, defs, clazz) =&gt;
    // same as RefinedType except as body of class
  case MethodType(paramtypes, result) =&gt;
    // (paramtypes)result
    // For instance def m(): T is represented as MethodType(List(), T)
  case NullaryMethodType(result) =&gt; // eliminated by uncurry
    // an eval-by-name type
    // For instance def m: T is represented as NullaryMethodType(T)
  case PolyType(tparams, result) =&gt;
    // [tparams]result where result is a (Nullary)MethodType or ClassInfoType

  // The remaining types are not used after phase `typer`.
  case OverloadedType(pre, tparams, alts) =&gt;
    // all alternatives of an overloaded ident
  case AntiPolyType(pre, targs) =&gt;
    // rarely used, disappears when combined with a PolyType
  case TypeVar(inst, constr) =&gt;
    // a type variable
    // Replace occurrences of type parameters with type vars, where
    // inst is the instantiation and constr is a list of bounds.
  case DeBruijnIndex(level, index)
    // for dependent method types: a type referring to a method parameter.
  case ErasedValueType(tp)
    // only used during erasure of derived value classes.
*/

<span class="keyword">trait</span> <a title="trait Types extends Object with scala.reflect.api.Types" id="19179">Types</a> <a href="../../Unit.scala.html#2389" title="Unit" class="keyword">extends</a> api.<a href="../api/Types.scala.html#18231" title="scala.reflect.api.Types">Types</a> <span class="delimiter">{</span> self: SymbolTable =&gt;
  <span class="keyword">import</span> <a href="Definitions.scala.html#441641" title="Types.this.definitions.type">definitions</a>._

  //statistics
  <span class="keyword">def</span> <a title="=&gt; Int" id="441199">uniqueTypeCount</a> = <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#441403" title="=&gt; scala.reflect.internal.util.HashSet[Types.this.Type]">uniques</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> <span class="keyword">else</span> <a href="#441403" title="=&gt; scala.reflect.internal.util.HashSet[Types.this.Type]">uniques</a>.<a href="util/HashSet.scala.html#514479" title="=&gt; Int">size</a>

  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Boolean" id="441201">explainSwitch</a> = <span title="Boolean(false)" class="keyword">false</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="441203">emptySymbolSet</a> = immutable.<a href="../../collection/immutable/Set.scala.html#12290" title="scala.collection.immutable.Set.type">Set</a>.<a href="../../collection/immutable/Set.scala.html#61729" title="[A]=&gt; scala.collection.immutable.Set[A]">empty</a><span title="scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span>

  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="441205">LogPendingSubTypesThreshold</a> = <span title="Int(50)" class="int">50</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="441207">LogPendingBaseTypesThreshold</a> = <span title="Int(50)" class="int">50</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="441209">LogVolatileThreshold</a> = <span title="Int(50)" class="int">50</span>

  /** A don't care value for the depth parameter in lubs/glbs and related operations. */
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(-3)" id="441211">AnyDepth</a> = -<span title="Int(-3)" class="int">3</span>

  /** Decrement depth unless it is a don't care. */
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="(depth: Int)Int" id="441213">decr</a><span class="delimiter">(</span><a title="Int" id="514515">depth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span> = <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#514515" title="Int">depth</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span> <span title="Int(-3)">AnyDepth</span> <span class="keyword">else</span> <a href="#514515" title="Int">depth</a> <a href="../../Int.scala.html#57955" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span>

  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean" id="441214">printLubs</a> = sys.<a href="../../sys/package.scala.html#57159" title="=&gt; scala.sys.SystemProperties">props</a> <a href="../../sys/SystemProperties.scala.html#78387" title="(key: String)Boolean">contains</a> <span title="String(&quot;scalac.debug.lub&quot;)" class="string">&quot;scalac.debug.lub&quot;</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean" id="441216">traceTypeVars</a> = sys.<a href="../../sys/package.scala.html#57159" title="=&gt; scala.sys.SystemProperties">props</a> <a href="../../sys/SystemProperties.scala.html#78387" title="(key: String)Boolean">contains</a> <span title="String(&quot;scalac.debug.tvar&quot;)" class="string">&quot;scalac.debug.tvar&quot;</span>
  /** In case anyone wants to turn off lub verification without reverting anything. */
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean(true)" id="441218">verifyLubs</a> = <span title="Boolean(true)" class="keyword">true</span>
  /** In case anyone wants to turn off type parameter bounds being used
   *  to seed type constraints.
   */
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean" id="441220">propagateParameterBoundsToTypeVars</a> = sys.<a href="../../sys/package.scala.html#57159" title="=&gt; scala.sys.SystemProperties">props</a> <a href="../../sys/SystemProperties.scala.html#78387" title="(key: String)Boolean">contains</a> <span title="String(&quot;scalac.debug.prop-constraints&quot;)" class="string">&quot;scalac.debug.prop-constraints&quot;</span>

  <span class="keyword">protected</span> <span class="keyword">val</span> <a title="Boolean" id="441222">enableTypeVarExperimentals</a> = <a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456429" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">Xexperimental</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456430" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">XoldPatmat</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a>

  /** Empty immutable maps to avoid allocations. */
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]" id="441224">emptySymMap</a>   = immutable.<a href="../../collection/generic/GenMapFactory.scala.html#61654" title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</a><span title="(elems: (Types.this.Symbol, Types.this.Symbol)*)scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Int]" id="441226">emptySymCount</a> = immutable.<a href="../../collection/generic/GenMapFactory.scala.html#61654" title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</a><span title="(elems: (Types.this.Symbol, Int)*)scala.collection.immutable.Map[Types.this.Symbol,Int]" class="delimiter">[</span><a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>

  /** The current skolemization level, needed for the algorithms
   *  in isSameType, isSubType that do constraint solving under a prefix.
   */
  <span class="keyword">var</span> <a title="Int" id="441229">skolemizationLevel</a> = <span title="Int(0)" class="int">0</span>

  /** A log of type variable with their original constraints. Used in order
   *  to undo constraints in the case of isSubType/isSameType failure.
   */
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.UndoLog" id="441232">undoLog</a> = <a href="#441233" title="=&gt; Types.this.UndoLog">newUndoLog</a>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.UndoLog" id="441233">newUndoLog</a> = <span title="Types.this.UndoLog" class="keyword">new</span> <a href="#441234" title="Types.this.UndoLog">UndoLog</a>

  <span class="keyword">class</span> <a title="class UndoLog extends Object" id="441234">UndoLog</a> <a href="#441234" title="Types.this.UndoLog" class="delimiter">{</a>
    <span class="keyword">private</span> <span class="keyword">type</span> <a title="List[(Types.this.TypeVar, Types.this.TypeConstraint)]" id="514530">UndoPairs</a> = <a href="../../collection/immutable/List.scala.html#12322" title="List[(Types.this.TypeVar, Types.this.TypeConstraint)]">List</a><span class="delimiter">[</span><span class="delimiter">(</span>TypeVar, TypeConstraint<span class="delimiter">)</span><span class="delimiter">]</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="UndoLog.this.UndoPairs" id="514532">log</a>: <a href="../../collection/immutable/List.scala.html#12322" title="UndoLog.this.UndoPairs">UndoPairs</a> = List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>

    // register with the auto-clearing cache manager
    <a href="SymbolTable.scala.html#440630" title="Types.this.perRunCaches.type">perRunCaches</a>.<a href="SymbolTable.scala.html#492841" title="(cache: Types.this.UndoLog)Types.this.UndoLog">recordCache</a><span class="delimiter">(</span><a href="#441234" title="Types.this.UndoLog" class="keyword">this</a><span class="delimiter">)</span>

    /** Undo all changes to constraints to type variables upto `limit`. */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(limit: UndoLog.this.UndoPairs)Unit" id="514534">undoTo</a><span class="delimiter">(</span><a title="UndoLog.this.UndoPairs" id="514559">limit</a>: <a href="../../collection/immutable/List.scala.html#12322" title="UndoLog.this.UndoPairs">UndoPairs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#514532" title="=&gt; UndoLog.this.UndoPairs">log</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#514559" title="UndoLog.this.UndoPairs">limit</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#514532" title="=&gt; UndoLog.this.UndoPairs">log</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <a href="#514560" title="()Unit" class="delimiter">{</a>
        <span class="keyword">val</span> <a href="#514582" title="(x: (Types.this.TypeVar, Types.this.TypeConstraint))(Types.this.TypeVar, Types.this.TypeConstraint)" class="delimiter">(</a><a href="../../Tuple2.scala.html#61506" title="Types.this.TypeVar" id="514563">tv</a>, <a href="../../Tuple2.scala.html#61508" title="Types.this.TypeConstraint" id="514564">constr</a><span class="delimiter">)</span> = <a href="#514532" title="=&gt; UndoLog.this.UndoPairs">log</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; (Types.this.TypeVar, Types.this.TypeConstraint)">head</a>
        <a href="#514563" title="Types.this.TypeVar">tv</a>.<a href="#470165" title="(x$1: Types.this.TypeConstraint)Unit">constr</a> = <a href="#514564" title="Types.this.TypeConstraint">constr</a>
        <a href="#514532" title="(x$1: UndoLog.this.UndoPairs)Unit">log</a> = <a href="#514532" title="=&gt; UndoLog.this.UndoPairs">log</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[(Types.this.TypeVar, Types.this.TypeConstraint)]">tail</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** No sync necessary, because record should only
     *  be called from within a undo or undoUnless block,
     *  which is already synchronized.
     */
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(tv: Types.this.TypeVar)Unit" id="514535">record</a><span class="delimiter">(</span><a title="Types.this.TypeVar" id="514588">tv</a>: <a href="#441345" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#514532" title="(x$1: UndoLog.this.UndoPairs)Unit">log</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: (Types.this.TypeVar, Types.this.TypeConstraint))List[(Types.this.TypeVar, Types.this.TypeConstraint)]">::=</a> <span class="delimiter">(</span><a href="../../Tuple2.scala.html#63804" title="(_1: Types.this.TypeVar, _2: Types.this.TypeConstraint)(Types.this.TypeVar, Types.this.TypeConstraint)" class="delimiter">(</a><a href="#514588" title="Types.this.TypeVar">tv</a>, <a href="#514588" title="Types.this.TypeVar">tv</a>.<a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470269" title="=&gt; Types.this.TypeConstraint">cloneInternal</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">private</span><span class="delimiter">[</span>scala<span class="delimiter">]</span> <span class="keyword">def</span> <a title="()Unit" id="514536">clear</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456420" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a><span class="delimiter">)</span>
        <a href="#19179" title="Types.this.type">self</a>.<a href="SymbolTable.scala.html#440548" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="String(&quot;Clearing &quot;)" class="string">&quot;Clearing &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#514532" title="=&gt; UndoLog.this.UndoPairs">log</a>.<a href="../../collection/SeqLike.scala.html#59711" title="=&gt; Int">size</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; entries from the undoLog.&quot;)" class="string">&quot; entries from the undoLog.&quot;</span><span class="delimiter">)</span>

      <a href="#514532" title="(x$1: UndoLog.this.UndoPairs)Unit">log</a> = <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="=&gt; Int" id="514537">size</a> = <a href="#514532" title="=&gt; UndoLog.this.UndoPairs">log</a>.<a href="../../collection/SeqLike.scala.html#59711" title="=&gt; Int">size</a>

    // `block` should not affect constraints on typevars
    <span class="keyword">def</span> <a title="[T](block: =&gt; T)T" id="514538">undo</a><span class="delimiter">[</span><a title="" id="514540">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; T" id="514619">block</a>: =&gt; T<span class="delimiter">)</span>: <a href="#514540" title="T">T</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="UndoLog.this.UndoPairs" id="514621">before</a> = <a href="#514532" title="=&gt; UndoLog.this.UndoPairs">log</a>

      <span class="keyword">try</span> <a href="#514619" title="=&gt; T">block</a>
      <span class="keyword">finally</span> <a href="#514534" title="(limit: UndoLog.this.UndoPairs)Unit">undoTo</a><span class="delimiter">(</span><a href="#514621" title="UndoLog.this.UndoPairs">before</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    // if `block` evaluates to false, it should not affect constraints on typevars
    <span class="keyword">def</span> <a title="(block: =&gt; Boolean)Boolean" id="514541">undoUnless</a><span class="delimiter">(</span><a title="=&gt; Boolean" id="514623">block</a>: =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="UndoLog.this.UndoPairs" id="514624">before</a> = <a href="#514532" title="=&gt; UndoLog.this.UndoPairs">log</a>
      <span class="keyword">var</span> <a title="Boolean" id="514625">result</a> = <span title="Boolean(false)" class="keyword">false</span>

      <span class="keyword">try</span> <a href="#514625" title="Boolean">result</a> = <a href="#514623" title="=&gt; Boolean">block</a>
      <span class="keyword">finally</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#514625" title="Boolean">result</a><span class="delimiter">)</span> <a href="#514534" title="(limit: UndoLog.this.UndoPairs)Unit">undoTo</a><span class="delimiter">(</span><a href="#514624" title="UndoLog.this.UndoPairs">before</a><span class="delimiter">)</span>

      <a href="#514625" title="Boolean">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map from lists to compound types that have the given list as parents.
   *  This is used to avoid duplication in the computation of base type sequences and baseClasses.
   *  It makes use of the fact that these two operations depend only on the parents,
   *  not on the refinement.
   */
  <span class="keyword">val</span> <a title="scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]" id="441235">intersectionWitness</a> = <a href="SymbolTable.scala.html#440630" title="Types.this.perRunCaches.type">perRunCaches</a>.<a href="SymbolTable.scala.html#492845" title="[K, V]()scala.collection.mutable.WeakHashMap[K,V]">newWeakMap</a><span title="()scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]" class="delimiter">[</span><a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a href="../../ref/WeakReference.scala.html#18083" title="scala.ref.WeakReference[Types.this.Type]">WeakReference</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>

  /** A proxy for a type (identified by field `underlying`) that forwards most
   *  operations to it (for exceptions, see WrappingProxy, which forwards even more operations).
   *  every operation that is overridden for some kind of types should be forwarded.
   */
  <span class="keyword">trait</span> <a title="trait SimpleTypeProxy extends Types.this.Type" id="441237">SimpleTypeProxy</a> <a href="../../Unit.scala.html#2389" title="Unit" class="keyword">extends</a> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="445475">underlying</a>: <a href="#441242" title="Types.this.Type">Type</a>

    // the following operations + those in RewrappingTypeProxy are all operations
    // in class Type that are overridden in some subclass
    // Important to keep this up-to-date when new operations are added!
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="445476">isTrivial</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441971" title="=&gt; Boolean">isTrivial</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="445477">isHigherKinded</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441972" title="=&gt; Boolean">isHigherKinded</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="445478">typeConstructor</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441999" title="=&gt; Types.this.Type">typeConstructor</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="445479">isNotNull</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441975" title="=&gt; Boolean">isNotNull</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="445480">isError</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441980" title="=&gt; Boolean">isError</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="445481">isErroneous</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441981" title="=&gt; Boolean">isErroneous</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="445482">isStable</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441973" title="=&gt; Boolean">isStable</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="445483">isVolatile</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441974" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="445484">finalResultType</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442006" title="=&gt; Types.this.Type">finalResultType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="445485">paramSectionCount</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442007" title="=&gt; Int">paramSectionCount</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="445486">paramss</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442008" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="445487">params</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442009" title="=&gt; List[Types.this.Symbol]">params</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="445488">paramTypes</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442010" title="=&gt; List[Types.this.Type]">paramTypes</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="445489">termSymbol</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441985" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="445490">termSymbolDirect</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441987" title="=&gt; Types.this.Symbol">termSymbolDirect</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="445491">typeParams</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442011" title="=&gt; List[Types.this.Symbol]">typeParams</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="445492">boundSyms</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442012" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="445493">typeSymbol</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="445494">typeSymbolDirect</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441988" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="445495">widen</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441990" title="=&gt; Types.this.Type">widen</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="445496">typeOfThis</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441992" title="=&gt; Types.this.Type">typeOfThis</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="445497">bounds</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="445498">parents</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441995" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="445499">prefix</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441997" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="445500">decls</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442019" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="445501">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="514656">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442036" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#514656" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="445502">baseTypeSeq</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442066" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="445503">baseTypeSeqDepth</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442067" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="445504">baseClasses</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442068" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
  <span class="delimiter">}</span>

  /** A proxy for a type (identified by field `underlying`) that forwards most
   *  operations to it. Every operation that is overridden for some kind of types is
   *  forwarded here. Some operations are rewrapped again.
   */
  <span class="keyword">trait</span> <a title="trait RewrappingTypeProxy extends Types.this.Type with Types.this.SimpleTypeProxy" id="441238">RewrappingTypeProxy</a> <a href="../../Unit.scala.html#2389" title="Unit" class="keyword">extends</a> <a href="#441237" title="Types.this.SimpleTypeProxy">SimpleTypeProxy</a> <span class="delimiter">{</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="445506">maybeRewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="514669">newtp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#514669" title="Types.this.Type">newtp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#441989" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span> <a href="#441238" title="Types.this.RewrappingTypeProxy" class="keyword">this</a> <span class="keyword">else</span> <a href="#445507" title="(newtp: Types.this.Type)Types.this.Type">rewrap</a><span class="delimiter">(</span><a href="#514669" title="Types.this.Type">newtp</a><span class="delimiter">)</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="445507">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="514672">newtp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a>

    // the following are all operations in class Type that are overridden in some subclass
    // Important to keep this up-to-date when new operations are added!
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="445508">widen</a> = <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441990" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="445509">narrow</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441993" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="445510">deconst</a> = <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441991" title="=&gt; Types.this.Type">deconst</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="445511">resultType</a> = <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442002" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(actuals: List[Types.this.Type])Types.this.Type" id="445512">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="514694">actuals</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442003" title="(actuals: List[Types.this.Type])Types.this.Type">resultType</a><span class="delimiter">(</span><a href="#514694" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="445513">finalResultType</a> = <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442006" title="=&gt; Types.this.Type">finalResultType</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="445514">paramSectionCount</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="445515">paramss</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[List[Types.this.Symbol]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="445516">params</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="445517">paramTypes</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="445518">typeArgs</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442000" title="=&gt; List[Types.this.Type]">typeArgs</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="445519">notNull</a> = <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442013" title="=&gt; Types.this.Type">notNull</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="445520">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="514742">formals</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="514743">actuals</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442014" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#514742" title="List[Types.this.Symbol]">formals</a>, <a href="#514743" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="445521">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="514746">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="514747">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442015" title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type">skolemizeExistential</a><span class="delimiter">(</span><a href="#514746" title="Types.this.Symbol">owner</a>, <a href="#514747" title="AnyRef">origin</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="445522">normalize</a> = <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="445523">dealias</a> = <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442018" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="445524">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="514764">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442070" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#514764" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="445525">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="514767">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442071" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#514767" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="445526">prefixString</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442075" title="=&gt; String">prefixString</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="445527">isComplete</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441983" title="=&gt; Boolean">isComplete</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="445528">complete</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="514794">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441984" title="(sym: Types.this.Symbol)Unit">complete</a><span class="delimiter">(</span><a href="#514794" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="445529">load</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="514797">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442081" title="(sym: Types.this.Symbol)Unit">load</a><span class="delimiter">(</span><a href="#514797" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="445530">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="514799">annots</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442089" title="(annots: List[Types.this.AnnotationInfo])Types.this.Type">withAnnotations</a><span class="delimiter">(</span><a href="#514799" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="445531">withoutAnnotations</a> = <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442086" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  case <span class="keyword">object</span> <a href="#514834" title="Types.this.UnmappableTree.type" id="514846">UnmappableTree</a> <a href="../../Product.scala.html#304" title="Product" class="keyword">extends</a> <a href="../api/Trees.scala.html#23571" title="Types.this.TermTree">TermTree</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="514811">toString</a> = <span title="String(&quot;&lt;unmappable&gt;&quot;)" class="string">&quot;&lt;unmappable&gt;&quot;</span>
    <span class="keyword">super</span>.<a href="../api/Trees.scala.html#425061" title="(t: Types.this.Type)Unit">tpe_=</a><span class="delimiter">(</span><a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(t: Types.this.Type)Unit" id="514812">tpe_=</a><span class="delimiter">(</span><a title="Types.this.Type" id="514819">t</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#514819" title="Types.this.Type">t</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Nothing" class="keyword">throw</span> <span title="(x$1: String)UnsupportedOperationException" class="keyword">new</span> <a href="../../package.scala.html#56966" title="UnsupportedOperationException">UnsupportedOperationException</a><span class="delimiter">(</span><span title="String(&quot;tpe_=(&quot;)" class="string">&quot;tpe_=(&quot;</span><span title="(x$1: Any)String">+</span><a href="#514819" title="Types.this.Type">t</a><span title="(x$1: Any)String">+</span><span title="String(&quot;) inapplicable for &lt;empty&gt;&quot;)" class="string">&quot;) inapplicable for &lt;empty&gt;&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class AbsTypeImpl extends Types.this.AbsType" id="441241">AbsTypeImpl</a> <a href="#441241" title="Types.this.AbsTypeImpl" class="keyword">extends</a> <a href="../api/Types.scala.html#23481" title="Types.this.AbsType">AbsType</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Type =&gt;
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="441962">declaration</a><span class="delimiter">(</span><a title="Types.this.Name" id="461539">name</a>: <a href="Names.scala.html#440792" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="#442020" title="(name: Types.this.Name)Types.this.Symbol">decl</a><span class="delimiter">(</span><a href="#461539" title="Types.this.Name">name</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="441963">nonPrivateDeclaration</a><span class="delimiter">(</span><a title="Types.this.Name" id="514848">name</a>: <a href="Names.scala.html#440792" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="#442022" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateDecl</a><span class="delimiter">(</span><a href="#514848" title="Types.this.Name">name</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="441964">declarations</a> = <a href="#442019" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="441965">typeArguments</a> = <a href="#442000" title="=&gt; List[Types.this.Type]">typeArgs</a>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="441966">erasure</a> = <a href="#441241" title="Types.this.Type" class="keyword">this</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> ConstantType<a href="#461354" title="Types.this.Type" id="461356" class="delimiter">(</a>value<span class="delimiter">)</span> =&gt; <a href="#441990" title="=&gt; Types.this.Type">widen</a>.<a href="#461357" title="(x: Types.this.Type)Types.this.Type">erasure</a> // [Eugene to Martin] constant types are unaffected by erasure. weird.
      <span class="keyword">case</span> _ =&gt;
        <span class="keyword">var</span> <a title="_567.global.Type forSome { val _567: scala.reflect.internal.transform.Erasure{val global: Types.this.type} }" id="460832">result</a> = <a href="transform/Transforms.scala.html#441744" title="(tpe: Types.this.Type)_567.global.Type forSome { val _567: scala.reflect.internal.transform.Erasure{val global: Types.this.type} }">transformedType</a><span class="delimiter">(</span><a href="#441241" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#460832" title="_567.global.Type forSome { val _567: scala.reflect.internal.transform.Erasure{val global: Types.this.type} }">result</a> = <a href="#460832" title="_567.global.Type forSome { val _567: scala.reflect.internal.transform.Erasure{val global: Types.this.type} }">result</a>.<a href="#442017" title="=&gt; _567.global.Type">normalize</a> <span class="keyword">match</span> <span class="delimiter">{</span> // necessary to deal with erasures of HK types, typeConstructor won't work
          <span class="keyword">case</span> PolyType<a href="#461241" title="Types.this.Type" id="461243" class="delimiter">(</a>undets, underlying<span class="delimiter">)</span> =&gt; <a href="#441386" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><a href="#461244" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>undets, underlying<span class="delimiter">)</span> // we don't want undets in the result
          <span class="keyword">case</span> _ =&gt; <a href="#461244" title="(x: Types.this.Type)Types.this.Type">result</a>
        <span class="delimiter">}</span>
        // [Eugene] erasure screws up all ThisTypes for modules into PackageTypeRefs
        // we need to unscrew them, or certain typechecks will fail mysteriously
        // http://groups.google.com/group/scala-internals/browse_thread/thread/6d3277ae21b6d581
        <a href="#460832" title="_567.global.Type forSome { val _567: scala.reflect.internal.transform.Erasure{val global: Types.this.type} }">result</a> = <a href="#460832" title="_567.global.Type forSome { val _567: scala.reflect.internal.transform.Erasure{val global: Types.this.type} }">result</a>.<a href="#442054" title="(f: _567.global.Type =&gt; _567.global.Type)_567.global.Type">map</a><span class="delimiter">(</span>tpe =&gt; <a href="#461266" title="_567.global.Type">tpe</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#461327" title="_567.global.Type" id="461329">tpe</a>: PackageTypeRef =&gt; <a href="#461307" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><a href="#461330" title="(x: _567.global.Type)_567.global.Type" class="delimiter">(</a>tpe.<a href="#448176" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt; <a href="#461330" title="(x: _567.global.Type)_567.global.Type">tpe</a>
        <span class="delimiter">}</span><span class="delimiter">)</span>
        <a href="#460832" title="_567.global.Type forSome { val _567: scala.reflect.internal.transform.Erasure{val global: Types.this.type} }">result</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type" id="441967">substituteTypes</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="461526">from</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="461527">to</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#442041" title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#461526" title="List[Types.this.Symbol]">from</a>, <a href="#461527" title="List[Types.this.Type]">to</a><span class="delimiter">)</span>

    // [Eugene] to be discussed and refactored
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="441968">isConcrete</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="461379">notConcreteSym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="461381">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
        <a href="#461381" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443233" title="=&gt; Boolean">isAbstractType</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#461381" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443123" title="=&gt; Boolean">isExistential</a>

      <span class="keyword">def</span> <a title="(tpe: Types.this.Type)Boolean" id="461380">notConcreteTpe</a><span class="delimiter">(</span><a title="Types.this.Type" id="461382">tpe</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#461382" title="Types.this.Type">tpe</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> ThisType<a href="#461478" title="Boolean" id="461481" class="delimiter">(</a>_<span class="delimiter">)</span> =&gt; <a href="#461506" title="(x: Boolean)Boolean" class="keyword">false</a>
        <span class="keyword">case</span> SuperType<a href="#461478" title="Boolean" id="461485" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt; <a href="#461506" title="(x: Boolean)Boolean" class="keyword">false</a>
        <span class="keyword">case</span> SingleType<a href="#461478" title="Boolean" id="461487" class="delimiter">(</a>pre, sym<span class="delimiter">)</span> =&gt; <a href="#461379" title="(sym: Types.this.Symbol)Boolean">notConcreteSym</a><a href="#461506" title="(x: Boolean)Boolean" class="delimiter">(</a>sym<span class="delimiter">)</span>
        <span class="keyword">case</span> ConstantType<a href="#461478" title="Boolean" id="461490" class="delimiter">(</a>_<span class="delimiter">)</span> =&gt; <a href="#461506" title="(x: Boolean)Boolean" class="keyword">false</a>
        <span class="keyword">case</span> TypeRef<a href="#461478" title="Boolean" id="461493" class="delimiter">(</a>_, sym, args<span class="delimiter">)</span> =&gt; <a href="#461379" title="(sym: Types.this.Symbol)Boolean">notConcreteSym</a><span class="delimiter">(</span>sym<span class="delimiter">)</span> <a href="#461506" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span>args <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a title="Types.this.Type" id="461475">arg</a> =&gt; <a href="#461380" title="(tpe: Types.this.Type)Boolean">notConcreteTpe</a><span class="delimiter">(</span><a href="#461475" title="Types.this.Type">arg</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> RefinedType<a href="#461478" title="Boolean" id="461497" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt; <a href="#461506" title="(x: Boolean)Boolean" class="keyword">false</a>
        <span class="keyword">case</span> ExistentialType<a href="#461478" title="Boolean" id="461501" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt; <a href="#461506" title="(x: Boolean)Boolean" class="keyword">false</a>
        <span class="keyword">case</span> AnnotatedType<a href="#461478" title="Boolean" id="461505" class="delimiter">(</a>_, tp, _<span class="delimiter">)</span> =&gt; <a href="#461380" title="(tpe: Types.this.Type)Boolean">notConcreteTpe</a><a href="#461506" title="(x: Boolean)Boolean" class="delimiter">(</a>tp<span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt; <a href="#461506" title="(x: Boolean)Boolean" class="keyword">true</a>
      <span class="delimiter">}</span>

      <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#461380" title="(tpe: Types.this.Type)Boolean">notConcreteTpe</a><span class="delimiter">(</span><a href="#441241" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    // [Eugene] is this comprehensive?
    // the only thingies that we want to splice are: 1) type parameters, 2) type members
    // the thingies that we don't want to splice are: 1) concrete types (obviously), 2) existential skolems
    // this check seems to cover them all, right?
    // todo. after we discuss this, move the check to subclasses
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="441969">isSpliceable</a> = <span class="delimiter">{</span>
      <a href="#441241" title="AbsTypeImpl.this.type" class="keyword">this</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#448160" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">]</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443233" title="=&gt; Boolean">isAbstractType</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443123" title="=&gt; Boolean">isExistential</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** The base class for all types */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Type extends Types.this.AbsTypeImpl with Types.this.Annotatable[Types.this.Type]" id="441242">Type</a> <a href="#441242" title="Types.this.Type" class="keyword">extends</a> <a href="#441241" title="Types.this.AbsTypeImpl">AbsTypeImpl</a> <span class="keyword">with</span> <a href="AnnotationInfos.scala.html#441776" title="Types.this.Annotatable[Types.this.Type]">Annotatable</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> <span class="delimiter">{</span>
    /** Types for which asSeenFrom always is the identity, no matter what
     *  prefix or owner.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="441971">isTrivial</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is this type higher-kinded, i.e., is it a type constructor @M */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="441972">isHigherKinded</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Does this type denote a stable reference (i.e. singleton type)? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="441973">isStable</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is this type dangerous (i.e. it might contain conflicting
     *  type information when empty, so that it can be constructed
     *  so that type unsoundness results.) A dangerous type has an underlying
     *  type of the form T_1 with T_n { decls }, where one of the
     *  T_i (i &gt; 1) is an abstract type.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="441974">isVolatile</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is this type guaranteed not to have `null` as a value? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="441975">isNotNull</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is this type a structural refinement type (it ''refines'' members that have not been inherited) */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="441976">isStructuralRefinement</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Does this type depend immediately on an enclosing method parameter?
      * I.e., is it a singleton type whose termSymbol refers to an argument of the symbol's owner (which is a method)?
      */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="441977">isImmediatelyDependent</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Does this depend on an enclosing method parameter? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="441978">isDependent</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#441451" title="Types.this.IsDependentCollector.type">IsDependentCollector</a>.<a href="#514865" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** True for WildcardType or BoundedWildcardType. */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="441979">isWildcard</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is this type produced as a repair for an error? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="441980">isError</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443317" title="=&gt; Boolean">isError</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#441985" title="=&gt; Types.this.Symbol">termSymbol</a>.<a href="Symbols.scala.html#443317" title="=&gt; Boolean">isError</a>

    /** Is this type produced as a repair for an error? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="441981">isErroneous</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#441469" title="Types.this.ErroneousCollector.type">ErroneousCollector</a>.<a href="#514865" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Does this type denote a reference type which can be null? */
    // def isNullable: Boolean = false

    /** Can this type only be subtyped by bottom types?
     *  This is assessed to be the case if the class is final,
     *  and all type parameters (if any) are invariant.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="441982">isFinalType</a> =
      <a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="HasFlags.scala.html#443591" title="=&gt; Boolean">isFinal</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a> <a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a href="#514898" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443377" title="=&gt; Int">variance</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span>

    /** Is this type completed (i.e. not a lazy type)? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="441983">isComplete</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(true)" class="keyword">true</span>

    /** If this is a lazy type, assign a new type to `sym`. */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="441984">complete</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="462714">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>

    /** The term symbol associated with the type
      * Note that the symbol of the normalized type is returned (@see normalize)
      */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="441985">termSymbol</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a>

    /** The type symbol associated with the type
      * Note that the symbol of the normalized type is returned (@see normalize)
      * A type's typeSymbol should if possible not be inspected directly, due to
      * the likelihood that what is true for tp.typeSymbol is not true for
      * tp.sym, due to normalization.
      */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="441986">typeSymbol</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a>

    /** The term symbol ''directly'' associated with the type.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="441987">termSymbolDirect</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="#441985" title="=&gt; Types.this.Symbol">termSymbol</a>

    /** The type symbol ''directly'' associated with the type.
     *  In other words, no normalization is performed: if this is an alias type,
     *  the symbol returned is that of the alias, not the underlying type.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="441988">typeSymbolDirect</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>

    /** The base type underlying a type proxy, identity on all other types */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="441989">underlying</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441242" title="Types.this.Type" class="keyword">this</a>

    /** Widen from singleton type to its underlying non-singleton
     *  base type by applying one or more `underlying` dereferences,
     *  identity for all other types.
     *
     *  class Outer { class C ; val x: C }
     *  val o: Outer
     *  &lt;o.x.type&gt;.widen = o.C
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="441990">widen</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441242" title="Types.this.Type" class="keyword">this</a>

    /** Map a constant type or not-null-type to its underlying base type,
     *  identity for all other types.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="441991">deconst</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441242" title="Types.this.Type" class="keyword">this</a>

    /** The type of `this` of a class type or reference type. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="441992">typeOfThis</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443484" title="=&gt; Types.this.Type">typeOfThis</a>

    /** Map to a singleton type which is a subtype of this type.
     *  The fallback implemented here gives
     *    T.narrow  = T' forSome { type T' &lt;: T with Singleton }
     *  Overridden where we know more about where types come from.
     */
    /*
    Note: this implementation of narrow is theoretically superior to the one
    in use below, but imposed a significant performance penalty.  It was in trunk
    from svn r24960 through r25080.
    */
    /*
    def narrow: Type =
      if (phase.erasedTypes) this
      else commonOwner(this) freshExistential &quot;.type&quot; setInfo singletonBounds(this) tpe
    */

    /** Map to a singleton type which is a subtype of this type.
     *  The fallback implemented here gives:
     *  {{{
     *    T.narrow  =  (T {}).this.type
     *  }}}
     *  Overridden where we know more about where types come from.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="441993">narrow</a>: <a href="#441242" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#441242" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="514904">cowner</a> = <a href="#441471" title="(t: Types.this.Type)Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#441368" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>, <a href="#514904" title="Types.this.Symbol">cowner</a>, <a href="Scopes.scala.html#441634" title="Types.this.EmptyScope.type">EmptyScope</a>, <a href="#514904" title="Types.this.Symbol">cowner</a>.<a href="Symbols.scala.html#443167" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>.<a href="#441993" title="=&gt; Types.this.Type">narrow</a>
      <span class="delimiter">}</span>

    /** For a TypeBounds type, itself;
     *  for a reference denoting an abstract type, its bounds,
     *  for all other types, a TypeBounds type all of whose bounds are this type.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="441994">bounds</a>: <a href="#448315" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#448285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** For a class or intersection type, its parents.
     *  For a TypeBounds type, the parents of its hi bound.
     *  inherited by typerefs, singleton types, and refinement types,
     *  The empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="441995">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>

    /** For a class with nonEmpty parents, the first parent.
     *  Otherwise some specific fixed top type.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="441996">firstParent</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#441995" title="=&gt; List[Types.this.Type]">parents</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <a href="#441995" title="=&gt; List[Types.this.Type]">parents</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a> <span class="keyword">else</span> <a href="Definitions.scala.html#442179" title="=&gt; Types.this.ClassSymbol">ObjectClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a>

    /** For a typeref or single-type, the prefix of the normalized type (@see normalize).
     *  NoType for all other types. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="441997">prefix</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#516490" title="Types.this.NoType.type">NoType</a>

    /** A chain of all typeref or singletype prefixes of this type, longest first.
     *  (Only used from safeToString.)
     */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="441998">prefixChain</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#441242" title="Types.this.Type" class="keyword">this</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> TypeRef<a href="#514959" title="List[Types.this.Type]" id="514963" class="delimiter">(</a>pre, _, _<span class="delimiter">)</span> =&gt; pre <a href="#514967" title="(x: List[Types.this.Type])List[Types.this.Type]">::</a> pre.<a href="#441998" title="=&gt; List[Types.this.Type]">prefixChain</a>
      <span class="keyword">case</span> SingleType<a href="#514959" title="List[Types.this.Type]" id="514966" class="delimiter">(</a>pre, _<span class="delimiter">)</span> =&gt; pre <a href="#514967" title="(x: List[Types.this.Type])List[Types.this.Type]">::</a> pre.<a href="#441998" title="=&gt; List[Types.this.Type]">prefixChain</a>
      <span class="keyword">case</span> _ =&gt; List<a href="#514967" title="(x: List[Types.this.Type])List[Types.this.Type]" class="delimiter">(</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** This type, without its type arguments @M */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="441999">typeConstructor</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441242" title="Types.this.Type" class="keyword">this</a>

    /** For a typeref, its arguments. The empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="442000">typeArgs</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>

    /** A list of placeholder types derived from the type parameters.
     *  Used by RefinedType and TypeRef.
     */
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="442001">dummyArgs</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#442011" title="=&gt; List[Types.this.Symbol]">typeParams</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#515001" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443444" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>

    /** For a (nullary) method or poly type, its direct result type,
     *  the type itself for all other types. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="442002">resultType</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441242" title="Types.this.Type" class="keyword">this</a>

    <span class="keyword">def</span> <a title="(actuals: List[Types.this.Type])Types.this.Type" id="442003">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="459694">actuals</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#441242" title="Types.this.Type" class="keyword">this</a>

    /** Only used for dependent method types. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="442004">resultApprox</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#515037" title="(tp: Types.this.Type)Types.this.Type">ApproximateDependentMap</a><span class="delimiter">(</span><a href="#442002" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>

    /** If this is a TypeRef `clazz`[`T`], return the argument `T`
     *  otherwise return this type
     */
    <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="442005">remove</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="515046">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441242" title="Types.this.Type" class="keyword">this</a>

    /** For a curried/nullary method or poly type its non-method result type,
     *  the type itself for all other types */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="442006">finalResultType</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441242" title="Types.this.Type" class="keyword">this</a>

    /** For a method type, the number of its value parameter sections,
     *  0 for all other types */
    <span class="keyword">def</span> <a title="=&gt; Int" id="442007">paramSectionCount</a>: <a href="../../Int.scala.html#508" title="Int">Int</a> = <span title="Int(0)" class="int">0</span>

    /** For a method or poly type, a list of its value parameter sections,
     *  the empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="442008">paramss</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[List[Types.this.Symbol]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>

    /** For a method or poly type, its first value parameter section,
     *  the empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="442009">params</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>

    /** For a method or poly type, the types of its first value parameter section,
     *  the empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="442010">paramTypes</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>

    /** For a (potentially wrapped) poly type, its type parameters,
     *  the empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="442011">typeParams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>

    /** For a (potentially wrapped) poly or existential type, its bound symbols,
     *  the empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="442012">boundSyms</a>: immutable.<a href="../../collection/immutable/Set.scala.html#12289" title="scala.collection.immutable.Set[Types.this.Symbol]">Set</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#441203" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">emptySymbolSet</a>

    /** Mixin a NotNull trait unless type already has one
     *  ...if the option is given, since it is causing typing bugs.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="442013">notNull</a>: <a href="#441242" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456421" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">Ynotnull</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#441975" title="=&gt; Boolean">isNotNull</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#441242" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#536590" title="(underlying: Types.this.Type)Types.this.NotNullType">NotNullType</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Replace formal type parameter symbols with actual type arguments.
     *
     * Amounts to substitution except for higher-kinded types. (See overridden method in TypeRef) -- @M
     */
    <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="442014">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="481408">formals</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="481409">actuals</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#481408" title="List[Types.this.Symbol]">formals</a>, <a href="#481409" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#441242" title="Type.this.type" class="keyword">this</a>.<a href="#442041" title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#481408" title="List[Types.this.Symbol]">formals</a>, <a href="#481409" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#516388" title="Types.this.ErrorType.type">ErrorType</a>

    /** If this type is an existential, turn all existentially bound variables to type skolems.
     *  @param  owner    The owner of the created type skolems
     *  @param  origin   The tree whose type was an existential for which the skolem was created.
     */
    <span class="keyword">def</span> <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="442015">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="461841">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="461842">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441242" title="Types.this.Type" class="keyword">this</a>

    /** A simple version of skolemizeExistential for situations where
     *  owner or unpack location do not matter (typically used in subtype tests)
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="442016">skolemizeExistential</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#442015" title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type">skolemizeExistential</a><span class="delimiter">(</span><a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a>, <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>

    /** Reduce to beta eta-long normal form.
     *  Expands type aliases and converts higher-kinded TypeRefs to PolyTypes.
     *  Functions on types are also implemented as PolyTypes.
     *
     *  Example: (in the below, &lt;List&gt; is the type constructor of List)
     *    TypeRef(pre, &lt;List&gt;, List()) is replaced by
     *    PolyType(X, TypeRef(pre, &lt;List&gt;, List(X)))
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="442017">normalize</a> = <a href="#441242" title="Types.this.Type" class="keyword">this</a> // @MAT

    /** Expands type aliases. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="442018">dealias</a> = <a href="#441242" title="Types.this.Type" class="keyword">this</a>

    /** For a classtype or refined type, its defined or declared members;
     *  inherited by subtypes and typerefs.
     *  The empty scope for all other types.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="442019">decls</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a> = <a href="Scopes.scala.html#441634" title="Types.this.EmptyScope.type">EmptyScope</a>

    /** The defined or declared members with name `name` in this type;
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Alternatives of overloaded symbol appear in the order they are declared.
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="442020">decl</a><span class="delimiter">(</span><a title="Types.this.Name" id="445833">name</a>: <a href="Names.scala.html#440792" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="#442082" title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol">findDecl</a><span class="delimiter">(</span><a href="#445833" title="Types.this.Name">name</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>

    /** A list of all non-private members defined or declared in this type. */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="442021">nonPrivateDecls</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#442019" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#447350" title="(p: Types.this.Symbol =&gt; Boolean)Types.this.Scope">filter</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="515101">x</a> =&gt; <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#515101" title="Types.this.Symbol">x</a>.<a href="HasFlags.scala.html#443596" title="=&gt; Boolean">isPrivate</a><span class="delimiter">)</span> <a href="Scopes.scala.html#447344" title="=&gt; List[Types.this.Symbol]">toList</a>

    /** The non-private defined or declared members with name `name` in this type;
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Alternatives of overloaded symbol appear in the order they are declared.
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="442022">nonPrivateDecl</a><span class="delimiter">(</span><a title="Types.this.Name" id="460619">name</a>: <a href="Names.scala.html#440792" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="#442082" title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol">findDecl</a><span class="delimiter">(</span><a href="#460619" title="Types.this.Name">name</a>, <span title="Int(4)">PRIVATE</span><span class="delimiter">)</span>

    /** A list of all members of this type (defined or inherited)
     *  Members appear in linearization order of their owners.
     *  Members with the same owner appear in reverse order of their declarations.
     */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="442023">members</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#442034" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(0L)" class="int">0</span>, <span title="Long(0L)" class="int">0</span><span class="delimiter">)</span>

    /** A list of all non-private members of this type (defined or inherited) */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="442024">nonPrivateMembers</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#442034" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619972L)">BridgeAndPrivateFlags</span>, <span title="Long(0L)" class="int">0</span><span class="delimiter">)</span>

    /** A list of all non-private members of this type  (defined or inherited),
     *  admitting members with given flags `admit`
     */
    <span class="keyword">def</span> <a title="(admit: Long)List[Types.this.Symbol]" id="442025">nonPrivateMembersAdmitting</a><span class="delimiter">(</span><a title="Long" id="515106">admit</a>: <a href="../../Long.scala.html#1993" title="Long">Long</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#442034" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619972L)">BridgeAndPrivateFlags</span> <a href="../../Long.scala.html#58301" title="(x: Long)Long">&amp;</a> <a href="../../Long.scala.html#58240" title="=&gt; Long">~</a><a href="#515106" title="Long">admit</a>, <span title="Long(0L)" class="int">0</span><span class="delimiter">)</span>

    /** A list of all implicit symbols of this type  (defined or inherited) */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="442026">implicitMembers</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#442034" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619968L)">BridgeFlags</span>, <span title="Long(512L)">IMPLICIT</span><span class="delimiter">)</span>

    /** A list of all deferred symbols of this type  (defined or inherited) */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="442027">deferredMembers</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#442034" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619968L)">BridgeFlags</span>, <span title="Long(16L)">DEFERRED</span><span class="delimiter">)</span>

    /** The member with given name,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="442028">member</a><span class="delimiter">(</span><a title="Types.this.Name" id="454830">name</a>: <a href="Names.scala.html#440792" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> =
      <a href="#442035" title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol">memberBasedOnName</a><span class="delimiter">(</span><a href="#454830" title="Types.this.Name">name</a>, <span title="Long(4398113619968L)">BridgeFlags</span><span class="delimiter">)</span>

    /** The non-private member with given name,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Bridges are excluded from the result
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="442029">nonPrivateMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="460605">name</a>: <a href="Names.scala.html#440792" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> =
      <a href="#442035" title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol">memberBasedOnName</a><span class="delimiter">(</span><a href="#460605" title="Types.this.Name">name</a>, <span title="Long(4398113619972L)">BridgeAndPrivateFlags</span><span class="delimiter">)</span>

    /** All members with the given flags, excluding bridges.
     */
    <span class="keyword">def</span> <a title="(requiredFlags: Long)List[Types.this.Symbol]" id="442030">membersWithFlags</a><span class="delimiter">(</span><a title="Long" id="515117">requiredFlags</a>: <a href="../../Long.scala.html#1993" title="Long">Long</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#442034" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619968L)">BridgeFlags</span>, <a href="#515117" title="Long">requiredFlags</a><span class="delimiter">)</span>

    /** All non-private members with the given flags, excluding bridges.
     */
    <span class="keyword">def</span> <a title="(requiredFlags: Long)List[Types.this.Symbol]" id="442031">nonPrivateMembersWithFlags</a><span class="delimiter">(</span><a title="Long" id="515119">requiredFlags</a>: <a href="../../Long.scala.html#1993" title="Long">Long</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#442034" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619972L)">BridgeAndPrivateFlags</span>, <a href="#515119" title="Long">requiredFlags</a><span class="delimiter">)</span>

    /** The non-private member with given name, admitting members with given flags `admit`.
     *  &quot;Admitting&quot; refers to the fact that members with a PRIVATE, BRIDGE, or VBRIDGE
     *  flag are usually excluded from findMember results, but supplying any of those flags
     *  to this method disables that exclusion.
     *
     *  An OverloadedSymbol if several exist, NoSymbol if none exists.
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name, admit: Long)Types.this.Symbol" id="442032">nonPrivateMemberAdmitting</a><span class="delimiter">(</span><a title="Types.this.Name" id="497216">name</a>: <a href="Names.scala.html#440792" title="Types.this.Name">Name</a>, <a title="Long" id="497217">admit</a>: <a href="../../Long.scala.html#1993" title="Long">Long</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> =
      <a href="#442035" title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol">memberBasedOnName</a><span class="delimiter">(</span><a href="#497216" title="Types.this.Name">name</a>, <span title="Long(4398113619972L)">BridgeAndPrivateFlags</span> <a href="../../Long.scala.html#58301" title="(x: Long)Long">&amp;</a> <a href="../../Long.scala.html#58240" title="=&gt; Long">~</a><a href="#497217" title="Long">admit</a><span class="delimiter">)</span>

    /** The non-local member with given name,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="442033">nonLocalMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="515125">name</a>: <a href="Names.scala.html#440792" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> =
      <a href="#442035" title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol">memberBasedOnName</a><span class="delimiter">(</span><a href="#515125" title="Types.this.Name">name</a>, BridgeFlags <span title="Long(4398114144256L)">|</span> LOCAL<span class="delimiter">)</span>

    /** Members excluding and requiring the given flags.
     *  Note: unfortunately it doesn't work to exclude DEFERRED this way.
     */
    <span class="keyword">def</span> <a title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]" id="442034">membersBasedOnFlags</a><span class="delimiter">(</span><a title="Long" id="515103">excludedFlags</a>: <a href="../../Long.scala.html#1993" title="Long">Long</a>, <a title="Long" id="515104">requiredFlags</a>: <a href="../../Long.scala.html#1993" title="Long">Long</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#442083" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="StdNames.scala.html#441764" title="Types.this.nme.type">nme</a>.<a href="StdNames.scala.html#446175" title="=&gt; Types.this.nme.NameType">ANYNAME</a>, <a href="#515103" title="Long">excludedFlags</a>, <a href="#515104" title="Long">requiredFlags</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#443472" title="=&gt; List[Types.this.Symbol]">alternatives</a>

    <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol" id="442035">memberBasedOnName</a><span class="delimiter">(</span><a title="Types.this.Name" id="515114">name</a>: <a href="Names.scala.html#440792" title="Types.this.Name">Name</a>, <a title="Long" id="515115">excludedFlags</a>: <a href="../../Long.scala.html#1993" title="Long">Long</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> =
      <a href="#442083" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#515114" title="Types.this.Name">name</a>, <a href="#515115" title="Long">excludedFlags</a>, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

    /** The least type instance of given class which is a supertype
     *  of this type.  Example:
     *    class D[T]
     *    class C extends p.D[Int]
     *    ThisType(C).baseType(D) = p.D[Int]
     */
    <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="442036">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="458839">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#516490" title="Types.this.NoType.type">NoType</a>

    /** This type as seen from prefix `pre` and class `clazz`. This means:
     *  Replace all thistypes of `clazz` or one of its subclasses
     *  by `pre` and instantiate all parameters by arguments of `pre`.
     *  Proceed analogously for thistypes referring to outer classes.
     *
     *  Example:
     *    class D[T] { def m: T }
     *    class C extends p.D[Int]
     *    T.asSeenFrom(ThisType(C), D)  (where D is owner of m)
     *      = Int
     */
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="442037">asSeenFrom</a><span class="delimiter">(</span><a title="Types.this.Type" id="461364">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="461365">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#441971" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#461364" title="Types.this.Type">pre</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#442352" title="=&gt; Types.this.ClassSymbol">ArrayClass</a><span class="delimiter">)</span> <a href="#441242" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
//        scala.tools.nsc.util.trace.when(pre.isInstanceOf[ExistentialType])(&quot;X &quot;+this+&quot;.asSeenfrom(&quot;+pre+&quot;,&quot;+clazz+&quot; = &quot;) {
        <a href="util/StatBase.scala.html#441044" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441076" title="=&gt; scala.reflect.internal.util.Statistics.Counter">asSeenFromCount</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.LongPair" id="515142">start</a> = <a href="util/StatBase.scala.html#441048" title="(tm: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441078" title="=&gt; scala.reflect.internal.util.Statistics.Timer">asSeenFromNanos</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.AsSeenFromMap" id="515143">m</a> = <span title="Types.this.AsSeenFromMap" class="keyword">new</span> <a href="#441443" title="Types.this.AsSeenFromMap">AsSeenFromMap</a><span class="delimiter">(</span><a href="#461364" title="Types.this.Type">pre</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a>, <a href="#461365" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="515144">tp</a> = <a href="#515143" title="Types.this.AsSeenFromMap">m</a> <a href="#515186" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#441242" title="Types.this.Type" class="keyword">this</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="515145">tp1</a> = <a href="#441386" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#515143" title="Types.this.AsSeenFromMap">m</a>.<a href="#515178" title="=&gt; List[Types.this.Symbol]">capturedParams</a>, <a href="#515144" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="515146">result</a>: <a href="#441242" title="Types.this.Type">Type</a> =
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#515143" title="Types.this.AsSeenFromMap">m</a>.<a href="#515175" title="=&gt; List[Types.this.Symbol]">capturedSkolems</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#515145" title="Types.this.Type">tp1</a>
          <span class="keyword">else</span> <a href="Symbols.scala.html#441155" title="(syms: List[Types.this.Symbol], symFn: Types.this.Symbol =&gt; Types.this.Symbol)(tpe: Types.this.Type)Types.this.Type">deriveType</a><span class="delimiter">(</span><a href="#515143" title="Types.this.AsSeenFromMap">m</a>.<a href="#515175" title="=&gt; List[Types.this.Symbol]">capturedSkolems</a>, <a href="#515198" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443475" title="=&gt; x$6.TypeOfClonedSymbol">cloneSymbol</a> <a href="Symbols.scala.html#443305" title="(mask: Long)x$6.TypeOfClonedSymbol">setFlag</a> <span title="Long(65536L)">CAPTURED</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#515145" title="Types.this.Type">tp1</a><span class="delimiter">)</span>

        <a href="util/StatBase.scala.html#441049" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: scala.reflect.internal.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441078" title="=&gt; scala.reflect.internal.util.Statistics.Timer">asSeenFromNanos</a>, <a href="#515142" title="scala.reflect.internal.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
        <a href="#515146" title="Types.this.Type">result</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** The info of `sym`, seen as a member of this type.
     *
     *  Example:
     *  {{{
     *    class D[T] { def m: T }
     *    class C extends p.D[Int]
     *    ThisType(C).memberType(m) = Int
     *  }}}
     */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="442038">memberInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="493565">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#493565" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442037" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#493565" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** The type of `sym`, seen as a member of this type. */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="442039">memberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="493568">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#493568" title="Types.this.Symbol">sym</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#515238" title="Types.this.Type" id="515240">meth</a>: MethodSymbol =&gt;
        meth.<a href="Symbols.scala.html#453559" title="(pre: Types.this.Type)Types.this.Type">typeAsMemberOf</a><a href="#515241" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#442040" title="(sym: Types.this.Symbol)Types.this.Type">computeMemberType</a><a href="#515241" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#493568" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="442040">computeMemberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="498641">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#498641" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443426" title="=&gt; Types.this.Type">tpeHK</a> <span class="keyword">match</span> <span class="delimiter">{</span> //@M don't prematurely instantiate higher-kinded types, they will be instantiated by transform, typedTypeApply, etc. when really necessary
      <span class="keyword">case</span> OverloadedType<a href="#515253" title="Types.this.Type" id="515256" class="delimiter">(</a>_, alts<span class="delimiter">)</span> =&gt;
        <a href="#536594" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.OverloadedType">OverloadedType</a><a href="#515257" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#441242" title="Types.this.Type" class="keyword">this</a>, alts<span class="delimiter">)</span>
      <span class="keyword">case</span> tp =&gt;
        tp.<a href="#442037" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><a href="#515257" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#498641" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Substitute types `to` for occurrences of references to
     *  symbols `from` in this type.
     */
    <span class="keyword">def</span> <a title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type" id="442041">subst</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="467256">from</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="467257">to</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#467256" title="List[Types.this.Symbol]">from</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#441242" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.SubstTypeMap" class="keyword">new</span> <a href="#441447" title="Types.this.SubstTypeMap">SubstTypeMap</a><span class="delimiter">(</span><a href="#467256" title="List[Types.this.Symbol]">from</a>, <a href="#467257" title="List[Types.this.Type]">to</a><span class="delimiter">)</span> <a href="#513532" title="(tp0: Types.this.Type)Types.this.Type">apply</a> <a href="#441242" title="Types.this.Type" class="keyword">this</a>

    /** Substitute symbols `to` for occurrences of symbols `from` in this type.
     *
     * !!! NOTE !!!: If you need to do a substThis and a substSym, the substThis has to come
     * first, as otherwise symbols will immediately get rebound in typeRef to the old
     * symbol.
     */
    <span class="keyword">def</span> <a title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type" id="442042">substSym</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="461792">from</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="461793">to</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#461792" title="List[Types.this.Symbol]">from</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#461793" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#461792" title="List[Types.this.Symbol]">from</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#441242" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.SubstSymMap" class="keyword">new</span> <a href="#441446" title="Types.this.SubstSymMap">SubstSymMap</a><span class="delimiter">(</span><a href="#461792" title="List[Types.this.Symbol]">from</a>, <a href="#461793" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <a href="#513601" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#441242" title="Types.this.Type" class="keyword">this</a>

    /** Substitute all occurrences of `ThisType(from)` in this type by `to`.
     *
     * !!! NOTE !!!: If you need to do a substThis and a substSym, the substThis has to come
     * first, as otherwise symbols will immediately get rebound in typeRef to the old
     * symbol.
     */
    <span class="keyword">def</span> <a title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type" id="442043">substThis</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="461819">from</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="461820">to</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
      <span title="Types.this.SubstThisMap" class="keyword">new</span> <a href="#441448" title="Types.this.SubstThisMap">SubstThisMap</a><span class="delimiter">(</span><a href="#461819" title="Types.this.Symbol">from</a>, <a href="#461820" title="Types.this.Type">to</a><span class="delimiter">)</span> <a href="#515271" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#441242" title="Types.this.Type" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(from: Types.this.Symbol, to: Types.this.Symbol)Types.this.Type" id="442044">substThis</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="461824">from</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="461825">to</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
      <a href="#442043" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#461824" title="Types.this.Symbol">from</a>, <a href="#461825" title="Types.this.Symbol">to</a>.<a href="Symbols.scala.html#443485" title="=&gt; Types.this.Type">thisType</a><span class="delimiter">)</span>

    /** Performs both substThis and substSym in one traversal.
     */
    <span class="keyword">def</span> <a title="(from: Types.this.Symbol, to: Types.this.Type, symsFrom: List[Types.this.Symbol], symsTo: List[Types.this.Symbol])Types.this.Type" id="442045">substThisAndSym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="496724">from</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="496725">to</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="496726">symsFrom</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="496727">symsTo</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#496726" title="List[Types.this.Symbol]">symsFrom</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#496727" title="List[Types.this.Symbol]">symsTo</a><span class="delimiter">)</span> <a href="#442043" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#496724" title="Types.this.Symbol">from</a>, <a href="#496725" title="Types.this.Type">to</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Types.this.SubstThisAndSymMap" class="keyword">new</span> <a href="#441449" title="Types.this.SubstThisAndSymMap">SubstThisAndSymMap</a><span class="delimiter">(</span><a href="#496724" title="Types.this.Symbol">from</a>, <a href="#496725" title="Types.this.Type">to</a>, <a href="#496726" title="List[Types.this.Symbol]">symsFrom</a>, <a href="#496727" title="List[Types.this.Symbol]">symsTo</a><span class="delimiter">)</span> <a href="#515300" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#441242" title="Types.this.Type" class="keyword">this</a>
    <span class="delimiter">}</span>

    /** Returns all parts of this type which satisfy predicate `p` */
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]" id="442046">filter</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="515310">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="Types.this.FilterTypeCollector" class="keyword">new</span> <a href="#441464" title="Types.this.FilterTypeCollector">FilterTypeCollector</a><span class="delimiter">(</span><a href="#515310" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span> <a href="#515316" title="(tp: Types.this.Type)List[Types.this.Type]">collect</a> <a href="#441242" title="Types.this.Type" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Type.this.FilterMapForeach" id="442047">withFilter</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="515322">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> = <span title="Type.this.FilterMapForeach" class="keyword">new</span> <a href="#442048" title="Type.this.FilterMapForeach">FilterMapForeach</a><span class="delimiter">(</span><a href="#515322" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span>

    <span class="keyword">class</span> <a title="class FilterMapForeach extends Types.this.FilterTypeCollector" id="442048">FilterMapForeach</a><a href="#442048" title="Type.this.FilterMapForeach" class="delimiter">(</a><a title="Types.this.Type =&gt; Boolean" id="515334">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441464" title="Types.this.FilterTypeCollector">FilterTypeCollector</a><span class="delimiter">(</span><a href="#515334" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span><span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="[U](f: Types.this.Type =&gt; U)Unit" id="515328">foreach</a><span class="delimiter">[</span><a title="" id="515330">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; U" id="515337">f</a>: Type =&gt; U<span class="delimiter">)</span>: <a href="../../Unit.scala.html#2389" title="Unit">Unit</a> = <a href="#515316" title="(tp: Types.this.Type)List[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type">Type</a>.<span class="keyword">this</span><span class="delimiter">)</span> <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.Type =&gt; U)Unit">foreach</a> <a href="#515337" title="Types.this.Type =&gt; U">f</a>
      <span class="keyword">def</span> <a title="[T](f: Types.this.Type =&gt; T)List[T]" id="515331">map</a><span class="delimiter">[</span><a title="" id="515333">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; T" id="515360">f</a>: Type =&gt; T<span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[T]">List</a><span class="delimiter">[</span>T<span class="delimiter">]</span>  = <a href="#515316" title="(tp: Types.this.Type)List[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type">Type</a>.<span class="keyword">this</span><span class="delimiter">)</span> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; T)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],T,List[T]])List[T]">map</a> <a href="#515360" title="Types.this.Type =&gt; T">f</a>
    <span class="delimiter">}</span>

    /** Returns optionally first type (in a preorder traversal) which satisfies predicate `p`,
     *  or None if none exists.
     */
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Option[Types.this.Type]" id="442049">find</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="460787">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[Types.this.Type]">Option</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="Types.this.FindTypeCollector" class="keyword">new</span> <a href="#441468" title="Types.this.FindTypeCollector">FindTypeCollector</a><span class="delimiter">(</span><a href="#460787" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span>.<a href="#514865" title="(tp: Types.this.Type)Option[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Apply `f` to each part of this type */
    <span class="keyword">def</span> <a title="(f: Types.this.Type =&gt; Unit)Unit" id="442050">foreach</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Unit" id="460792">f</a>: Type =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Types.this.ForEachTypeTraverser" class="keyword">new</span> <a href="#441467" title="Types.this.ForEachTypeTraverser">ForEachTypeTraverser</a><span class="delimiter">(</span><a href="#460792" title="Types.this.Type =&gt; Unit">f</a><span class="delimiter">)</span>.<a href="#515420" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span> <span class="delimiter">}</span>

    /** Apply `pf' to each part of this type on which the function is defined */
    <span class="keyword">def</span> <a title="[T](pf: PartialFunction[Types.this.Type,T])List[T]" id="442051">collect</a><span class="delimiter">[</span><a title="" id="442053">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[Types.this.Type,T]" id="466356">pf</a>: <a href="../../PartialFunction.scala.html#217" title="PartialFunction[Types.this.Type,T]">PartialFunction</a><span class="delimiter">[</span>Type, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[T]">List</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="Types.this.CollectTypeCollector[T]" class="keyword">new</span> <a href="#441465" title="Types.this.CollectTypeCollector[T]">CollectTypeCollector</a><span class="delimiter">(</span><a href="#466356" title="PartialFunction[Types.this.Type,T]">pf</a><span class="delimiter">)</span>.<a href="#515427" title="(tp: Types.this.Type)List[T]">collect</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Apply `f` to each part of this type; children get mapped before their parents */
    <span class="keyword">def</span> <a title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.Type" id="442054">map</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Types.this.Type" id="460797">f</a>: Type =&gt; Type<span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#515440" title="Types.this.TypeMap" class="keyword">new</a> <a href="#441429" title="anonymous class $anon extends Types.this.TypeMap" id="515440">TypeMap</a> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(x: Types.this.Type)Types.this.Type" id="515442">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="515443">x</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="../../Function1.scala.html#59555" title="(v1: Types.this.Type)Types.this.Type">f</a><span class="delimiter">(</span><a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#515443" title="Types.this.Type">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <a href="#515442" title="(x: Types.this.Type)Types.this.Type">apply</a> <a href="#441242" title="Types.this.Type" class="keyword">this</a>

    /** Is there part of this type which satisfies predicate `p`? */
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Boolean" id="442055">exists</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="460782">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#442049" title="(p: Types.this.Type =&gt; Boolean)Option[Types.this.Type]">find</a><span class="delimiter">(</span><a href="#460782" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span>.<a href="../../Option.scala.html#63811" title="=&gt; Boolean">isEmpty</a>

    /** Does this type contain a reference to this symbol? */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="442056">contains</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="460777">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Types.this.ContainsCollector" class="keyword">new</span> <a href="#441462" title="Types.this.ContainsCollector">ContainsCollector</a><span class="delimiter">(</span><a href="#460777" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#514865" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Does this type contain a reference to this type */
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="442057">containsTp</a><span class="delimiter">(</span><a title="Types.this.Type" id="515470">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Types.this.ContainsTypeCollector" class="keyword">new</span> <a href="#441463" title="Types.this.ContainsTypeCollector">ContainsTypeCollector</a><span class="delimiter">(</span><a href="#515470" title="Types.this.Type">tp</a><span class="delimiter">)</span>.<a href="#514865" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Is this type a subtype of that type? */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="442058">&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="458727">that</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span>util.<a href="util/Statistics.scala.html#23007" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/StatBase.scala.html#441040" title="=&gt; Boolean">enabled</a><span class="delimiter">)</span> <a href="#442060" title="(that: Types.this.Type)Boolean">stat_&lt;:&lt;</a><span class="delimiter">(</span><a href="#458727" title="Types.this.Type">that</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="delimiter">(</span><a href="#441242" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#458727" title="Types.this.Type">that</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
        <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#441201" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#441587" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;&lt;:&quot;)" class="string">&quot;&lt;:&quot;</span>, <a href="#441512" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a>, <a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#458727" title="Types.this.Type">that</a><span class="delimiter">)</span>
         <span class="keyword">else</span> <a href="#441513" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#458727" title="Types.this.Type">that</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** Is this type a subtype of that type in a pattern context?
     *  Any type arguments on the right hand side are replaced with
     *  fresh existentials, except for Arrays.
     *
     *  See bug1434.scala for an example of code which would fail
     *  if only a &lt;:&lt; test were applied.
     */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="442059">matchesPattern</a><span class="delimiter">(</span><a title="Types.this.Type" id="515514">that</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      <span class="delimiter">(</span><a href="#441242" title="Type.this.type" class="keyword">this</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#515514" title="Types.this.Type">that</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="../../Tuple2.scala.html#63804" title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</a><a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#515514" title="Types.this.Type">that</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span class="delimiter">(</span>TypeRef<a title="Boolean" id="515609" class="delimiter">(</a>_, <a href="Definitions.scala.html#442352" title="Boolean" id="515631">ArrayClass</a>, <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="515652">List</a><span class="delimiter">(</span>arg1<span class="delimiter">)</span><span class="delimiter">)</span>, TypeRef<a title="Boolean" id="515619" class="delimiter">(</a>_, <a href="Definitions.scala.html#442352" title="Boolean" id="515632">ArrayClass</a>, <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="515651">List</a><span class="delimiter">(</span>arg2<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> arg2.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a> =&gt;
          arg1 <a href="#515633" title="(x: Boolean)Boolean">matchesPattern</a> arg2
        <span class="keyword">case</span> <span class="delimiter">(</span>_, TypeRef<a title="Boolean" id="515630" class="delimiter">(</a>_, _, args<span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="515555">newtp</a> = <a href="#441386" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span>args <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</a> <span class="delimiter">(</span><a href="#515572" title="Types.this.Type">_</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>, <a href="#515514" title="Types.this.Type">that</a><span class="delimiter">)</span>
          <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#515514" title="Types.this.Type">that</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#515555" title="Types.this.Type">newtp</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#441242" title="Type.this.type" class="keyword">this</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#515555" title="Types.this.Type">newtp</a><span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt;
          <a href="#515633" title="(x: Boolean)Boolean" class="keyword">false</a>
      <span class="delimiter">}</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="442060">stat_&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="515481">that</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      <a href="util/StatBase.scala.html#441044" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441080" title="=&gt; scala.reflect.internal.util.Statistics.Counter">subtypeCount</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.LongPair" id="515667">start</a> = <a href="util/StatBase.scala.html#441048" title="(tm: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441082" title="=&gt; scala.reflect.internal.util.Statistics.Timer">subtypeNanos</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Boolean" id="515668">result</a> =
        <span class="delimiter">(</span><a href="#441242" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#515481" title="Types.this.Type">that</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
        <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#441201" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#441587" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;&lt;:&quot;)" class="string">&quot;&lt;:&quot;</span>, <a href="#441512" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a>, <a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#515481" title="Types.this.Type">that</a><span class="delimiter">)</span>
         <span class="keyword">else</span> <a href="#441513" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#515481" title="Types.this.Type">that</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="util/StatBase.scala.html#441049" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: scala.reflect.internal.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441082" title="=&gt; scala.reflect.internal.util.Statistics.Timer">subtypeNanos</a>, <a href="#515667" title="scala.reflect.internal.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
      <a href="#515668" title="Boolean">result</a>
    <span class="delimiter">}</span>

    /** Is this type a weak subtype of that type? True also for numeric types, i.e. Int weak_&lt;:&lt; Long.
     */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="442061">weak_&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="515693">that</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      <a href="util/StatBase.scala.html#441044" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441080" title="=&gt; scala.reflect.internal.util.Statistics.Counter">subtypeCount</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.LongPair" id="515695">start</a> = <a href="util/StatBase.scala.html#441048" title="(tm: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441082" title="=&gt; scala.reflect.internal.util.Statistics.Timer">subtypeNanos</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Boolean" id="515696">result</a> =
        <span class="delimiter">(</span><span class="delimiter">(</span><a href="#441242" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#515693" title="Types.this.Type">that</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
         <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#441201" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#441587" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;weak_&lt;:&quot;)" class="string">&quot;weak_&lt;:&quot;</span>, <a href="#441553" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isWeakSubType</a>, <a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#515693" title="Types.this.Type">that</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#441553" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isWeakSubType</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#515693" title="Types.this.Type">that</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="util/StatBase.scala.html#441049" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: scala.reflect.internal.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441082" title="=&gt; scala.reflect.internal.util.Statistics.Timer">subtypeNanos</a>, <a href="#515695" title="scala.reflect.internal.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
      <a href="#515696" title="Boolean">result</a>
    <span class="delimiter">}</span>

    /** Is this type equivalent to that type? */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="442062">=:=</a><span class="delimiter">(</span><a title="Types.this.Type" id="449405">that</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">(</span>
      <span class="delimiter">(</span><a href="#441242" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#449405" title="Types.this.Type">that</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
      <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#441201" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#441587" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;=&quot;)" class="string">&quot;=&quot;</span>, <a href="#441495" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a>, <a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#449405" title="Types.this.Type">that</a><span class="delimiter">)</span>
       <span class="keyword">else</span> <a href="#441495" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#449405" title="Types.this.Type">that</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>;

    /** Does this type implement symbol `sym` with same or stronger type? */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="442063">specializes</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="515807">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> =
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#441201" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#441587" title="(op: String, p: (Types.this.Type, Types.this.Symbol) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Symbol)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;specializes&quot;)" class="string">&quot;specializes&quot;</span>, <a href="#441526" title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean">specializesSym</a>, <a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#515807" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#441526" title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#515807" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>

    /** Is this type close enough to that type so that members
     *  with the two type would override each other?
     *  This means:
     *    - Either both types are polytypes with the same number of
     *      type parameters and their result types match after renaming
     *      corresponding type parameters
     *    - Or both types are (nullary) method types with equivalent type parameter types
     *      and matching result types
     *    - Or both types are equivalent
     *    - Or phase.erasedTypes is false and both types are neither method nor
     *      poly types.
     */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="442064">matches</a><span class="delimiter">(</span><a title="Types.this.Type" id="469185">that</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#469185" title="Types.this.Type">that</a>, <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>

    /** Same as matches, except that non-method types are always assumed to match. */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="442065">looselyMatches</a><span class="delimiter">(</span><a title="Types.this.Type" id="515843">that</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#515843" title="Types.this.Type">that</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

    /** The shortest sorted upwards closed array of types that contains
     *  this type as first element.
     *
     *  A list or array of types ts is upwards closed if
     *
     *    for all t in ts:
     *      for all typerefs p.s[args] such that t &lt;: p.s[args]
     *      there exists a typeref p'.s[args'] in ts such that
     *      t &lt;: p'.s['args] &lt;: p.s[args],
     *
     *      and
     *
     *      for all singleton types p.s such that t &lt;: p.s
     *      there exists a singleton type p'.s in ts such that
     *      t &lt;: p'.s &lt;: p.s
     *
     *  Sorting is with respect to Symbol.isLess() on type symbols.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="442066">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#441719" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="BaseTypeSeqs.scala.html#441722" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">baseTypeSingletonSeq</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** The maximum depth (@see maxDepth)
     *  of each type in the BaseTypeSeq of this type.
     */
    <span class="keyword">def</span> <a title="=&gt; Int" id="442067">baseTypeSeqDepth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a> = <span title="Int(1)" class="int">1</span>

    /** The list of all baseclasses of this type (including its own typeSymbol)
     *  in reverse linearization order, starting with the class itself and ending
     *  in class Any.
     */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="442068">baseClasses</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>

    /**
     *  @param sym the class symbol
     *  @return    the index of given class symbol in the BaseTypeSeq of this type,
     *             or -1 if no base type with given class symbol exists.
     */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Int" id="442069">baseTypeIndex</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="498792">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Int.scala.html#508" title="Int">Int</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="515853">bts</a> = <a href="#442066" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
      <span class="keyword">var</span> <a title="Int" id="515854">lo</a> = <span title="Int(0)" class="int">0</span>
      <span class="keyword">var</span> <a title="Int" id="515855">hi</a> = <a href="#515853" title="Types.this.BaseTypeSeq">bts</a>.<a href="BaseTypeSeqs.scala.html#447198" title="=&gt; Int">length</a> <a href="../../Int.scala.html#57955" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#515854" title="Int">lo</a> <a href="../../Int.scala.html#57912" title="(x: Int)Boolean">&lt;=</a> <a href="#515855" title="Int">hi</a><span class="delimiter">)</span> <a href="#515856" title="()Unit" class="delimiter">{</a>
        <span class="keyword">val</span> <a title="Int" id="515865">mid</a> = <span class="delimiter">(</span><a href="#515854" title="Int">lo</a> <a href="../../Int.scala.html#57948" title="(x: Int)Int">+</a> <a href="#515855" title="Int">hi</a><span class="delimiter">)</span> <a href="../../Int.scala.html#57969" title="(x: Int)Int">/</a> <span title="Int(2)" class="int">2</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="515866">btssym</a> = <a href="#515853" title="Types.this.BaseTypeSeq">bts</a>.<a href="BaseTypeSeqs.scala.html#447203" title="(i: Int)Types.this.Symbol">typeSymbol</a><span class="delimiter">(</span><a href="#515865" title="Int">mid</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#498792" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#515866" title="Types.this.Symbol">btssym</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#515865" title="Int">mid</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#498792" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#443466" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#515866" title="Types.this.Symbol">btssym</a><span class="delimiter">)</span> <a href="#515855" title="Int">hi</a> = <a href="#515865" title="Int">mid</a> <a href="../../Int.scala.html#57955" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#515866" title="Types.this.Symbol">btssym</a> <a href="Symbols.scala.html#443466" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#498792" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#515854" title="Int">lo</a> = <a href="#515865" title="Int">mid</a> <a href="../../Int.scala.html#57948" title="(x: Int)Int">+</a> <span title="Int(1)" class="int">1</span>
        <span class="keyword">else</span> <a href="SymbolTable.scala.html#440550" title="()Nothing">abort</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      -<span title="Int(-1)" class="int">1</span>
    <span class="delimiter">}</span>

    /** If this is a poly- or methodtype, a copy with cloned type / value parameters
     *  owned by `owner`. Identity for all other types.
     */
    <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="442070">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="461774">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#441242" title="Types.this.Type" class="keyword">this</a>

    /** Make sure this type is correct as the info of given owner; clone it if not. */
    <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="442071">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="461748">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#441242" title="Types.this.Type" class="keyword">this</a>

    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; String" id="442072">objectPrefix</a> = <span title="String(&quot;object &quot;)" class="string">&quot;object &quot;</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; String" id="442073">packagePrefix</a> = <span title="String(&quot;package &quot;)" class="string">&quot;package &quot;</span>
    <span class="keyword">def</span> <a title="(str: String)String" id="442074">trimPrefix</a><span class="delimiter">(</span><a title="String" id="514774">str</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="../../Predef.scala.html#8578" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">str</a> <a href="../../Predef.scala.html#8578" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">stripPrefix</a> <a href="#442072" title="=&gt; String">objectPrefix</a> <a href="../../collection/immutable/StringLike.scala.html#60708" title="(prefix: String)String">stripPrefix</a> <a href="#442073" title="=&gt; String">packagePrefix</a>

    /** The string representation of this type used as a prefix */
    <span class="keyword">def</span> <a title="=&gt; String" id="442075">prefixString</a> = <a href="#442074" title="(str: String)String">trimPrefix</a><span class="delimiter">(</span><a href="#442076" title="()String">toString</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span>

   /** Convert toString avoiding infinite recursions by cutting off
     *  after `maxTostringRecursions` recursion levels. Uses `safeToString`
     *  to produce a string on each level.
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="442076">toString</a>: <span title="String">String</span> = <a href="#441605" title="(tpe: Types.this.Type)String">typeToString</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Method to be implemented in subclasses.
     *  Converts this type to a string in calling toString for its parts.
     */
    <span class="keyword">def</span> <a title="=&gt; String" id="442077">safeToString</a>: <span title="String">String</span> = <a href="#441242" title="Types.this.Type" class="keyword">super</a>.<span title="()String">toString</span>

    /** The string representation of this type, with singletypes explained. */
    <span class="keyword">def</span> <a title="=&gt; String" id="442078">toLongString</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="514263">str</a> = <a href="#442076" title="()String">toString</a>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#514263" title="String">str</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="String(&quot;type&quot;)" class="string">&quot;type&quot;</span><span class="delimiter">)</span> <a href="#441990" title="=&gt; Types.this.Type">widen</a>.<a href="#442076" title="()String">toString</a>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#514263" title="String">str</a> <span title="(x$1: String)Boolean">endsWith</span> <span title="String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443245" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <a href="#514263" title="String">str</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; (with underlying type &quot;)" class="string">&quot; (with underlying type &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#441990" title="=&gt; Types.this.Type">widen</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
      <span class="keyword">else</span> <a href="#514263" title="String">str</a>
    <span class="delimiter">}</span>

    /** The string representation of this type when the direct object in a sentence.
     *  Normally this is no different from the regular representation, but modules
     *  read better as &quot;object Foo&quot; here and &quot;Foo.type&quot; the rest of the time.
     */
    <span class="keyword">def</span> <a title="=&gt; String" id="442079">directObjectString</a> = <a href="#442077" title="=&gt; String">safeToString</a>

    /** A test whether a type contains any unification type variables.
     *  Overridden with custom logic except where trivially true.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="442080">isGround</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#441242" title="Types.this.Type" class="keyword">this</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> ThisType<a href="#515908" title="Boolean" id="515911" class="delimiter">(</a>_<span class="delimiter">)</span> | <a href="#516520" title="Boolean" id="515919">NoPrefix</a> | <a href="#516414" title="Boolean" id="515920">WildcardType</a> | <a href="#516490" title="Boolean" id="515921">NoType</a> | <a href="#516388" title="Boolean" id="515922">ErrorType</a> | ConstantType<a href="#515908" title="Boolean" id="515918" class="delimiter">(</a>_<span class="delimiter">)</span> =&gt;
        <a href="#515923" title="(x: Boolean)Boolean" class="keyword">true</a>
      <span class="keyword">case</span> _ =&gt;
        <a href="#515902" title="(tp: Types.this.Type)Types.this.Type">typeVarToOriginMap</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span> <a href="#515923" title="(x: Boolean)Boolean">eq</a> <a href="#441242" title="Types.this.Type" class="keyword">this</a>
    <span class="delimiter">}</span>

    /** If this is a symbol loader type, load and assign a new type to `sym`. */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="442081">load</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="469158">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol" id="442082">findDecl</a><span class="delimiter">(</span><a title="Types.this.Name" id="515090">name</a>: <a href="Names.scala.html#440792" title="Types.this.Name">Name</a>, <a title="Int" id="515091">excludedFlags</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="515949">alts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="515950">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a>
      <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="515951">e</a>: <a href="Scopes.scala.html#441624" title="Types.this.ScopeEntry">ScopeEntry</a> = <a href="#442019" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#447342" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#515090" title="Types.this.Name">name</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#515951" title="Types.this.ScopeEntry">e</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#515952" title="()Unit" class="delimiter">{</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#515951" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#457240" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443303" title="(mask: Long)Boolean">hasFlag</a><span class="delimiter">(</span><a href="../../Int.scala.html#57875" title="=&gt; Long">excludedFlags</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#515950" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#515950" title="Types.this.Symbol">sym</a> = <a href="#515951" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#457240" title="=&gt; Types.this.Symbol">sym</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#515949" title="List[Types.this.Symbol]">alts</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#515949" title="List[Types.this.Symbol]">alts</a> = <a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</a><span class="delimiter">(</span><a href="#515950" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <a href="#515949" title="List[Types.this.Symbol]">alts</a> = <a href="#515951" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#457240" title="=&gt; Types.this.Symbol">sym</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#515949" title="List[Types.this.Symbol]">alts</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <a href="#515951" title="Types.this.ScopeEntry">e</a> = <a href="#442019" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#447343" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a><span class="delimiter">(</span><a href="#515951" title="Types.this.ScopeEntry">e</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#515949" title="List[Types.this.Symbol]">alts</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#515950" title="Types.this.Symbol">sym</a>
      <span class="keyword">else</span> <span class="delimiter">(</span><a href="#442068" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a>.<a href="Symbols.scala.html#443190" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.TermSymbol">newOverloaded</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#515949" title="List[Types.this.Symbol]">alts</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /**
     *  Find member(s) in this type. If several members matching criteria are found, they are
     *  returned in an OverloadedSymbol
     *
     *  @param name           The member's name, where nme.ANYNAME means `unspecified`
     *  @param excludedFlags  Returned members do not have these flags
     *  @param requiredFlags  Returned members do have these flags
     *  @param stableOnly     If set, return only members that are types or stable values
     */
    //TODO: use narrow only for modules? (correct? efficiency gain?)
    <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol" id="442083">findMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="515131">name</a>: <a href="Names.scala.html#440792" title="Types.this.Name">Name</a>, <a title="Long" id="515132">excludedFlags</a>: <a href="../../Long.scala.html#1993" title="Long">Long</a>, <a title="Long" id="515133">requiredFlags</a>: <a href="../../Long.scala.html#1993" title="Long">Long</a>, <a title="Boolean" id="515134">stableOnly</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      // if this type contains type variables, put them to sleep for a while -- don't just wipe them out by
      // replacing them by the corresponding type parameter, as that messes up (e.g.) type variables in type refinements
      // without this, the matchesType call would lead to type variables on both sides
      // of a subtyping/equality judgement, which can lead to recursive types being constructed.
      // See (t0851) for a situation where this happens.
      <span class="keyword">val</span> <a title="List[Types.this.TypeVar]" id="515986">suspension</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.TypeVar]">List</a><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> = <span title="List[Types.this.TypeVar]" class="keyword">if</span> <span class="delimiter">(</span><a href="#441242" title="Type.this.type" class="keyword">this</a>.<a href="#442080" title="=&gt; Boolean">isGround</a><span class="delimiter">)</span> <span title="Null(null)" class="keyword">null</span> <span class="keyword">else</span> <a href="#441572" title="(tp: Types.this.Type)List[Types.this.TypeVar]">suspendTypeVarsInType</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

      <a href="util/StatBase.scala.html#441044" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441068" title="=&gt; scala.reflect.internal.util.Statistics.Counter">findMemberCount</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.LongPair" id="515987">start</a> = <a href="util/StatBase.scala.html#441048" title="(tm: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441074" title="=&gt; scala.reflect.internal.util.Statistics.Timer">findMemberNanos</a><span class="delimiter">)</span>

      //Console.println(&quot;find member &quot; + name.decode + &quot; in &quot; + this + &quot;:&quot; + this.baseClasses)//DEBUG
      <span class="keyword">var</span> <a title="Types.this.Scope" id="515988">members</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a> = <span title="Null(null)" class="keyword">null</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="515989">member</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a>
      <span class="keyword">var</span> <a title="Long" id="515990">excluded</a> = <a href="#515132" title="Long">excludedFlags</a> <a href="../../Long.scala.html#58295" title="(x: Int)Long">|</a> <span title="Int(16)">DEFERRED</span>
      <span class="keyword">var</span> <a title="Boolean" id="515991">continue</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">var</span> <a title="Types.this.Type" id="515992">self</a>: <a href="#441242" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
      <span class="keyword">var</span> <a title="Types.this.Type" id="515993">membertpe</a>: <a href="#441242" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#515991" title="Boolean">continue</a><span class="delimiter">)</span> <a href="#515994" title="()Unit" class="delimiter">{</a>
        <a href="#515991" title="Boolean">continue</a> = <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="516003">bcs0</a> = <a href="#442068" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
        <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="516004">bcs</a> = <a href="#516003" title="List[Types.this.Symbol]">bcs0</a>
        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#516004" title="List[Types.this.Symbol]">bcs</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#516005" title="()Unit" class="delimiter">{</a>
          <span class="keyword">val</span> <a title="Types.this.Scope" id="516007">decls</a> = <a href="#516004" title="List[Types.this.Symbol]">bcs</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442019" title="=&gt; Types.this.Scope">decls</a>
          <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="516008">entry</a> =
            <span title="Types.this.ScopeEntry" class="keyword">if</span> <span class="delimiter">(</span><a href="#515131" title="Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#441764" title="Types.this.nme.type">nme</a>.<a href="StdNames.scala.html#446175" title="=&gt; Types.this.nme.NameType">ANYNAME</a><span class="delimiter">)</span> <a href="#516007" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#447308" title="=&gt; Types.this.ScopeEntry">elems</a> <span class="keyword">else</span> <a href="#516007" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#447342" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#515131" title="Types.this.Name">name</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#516008" title="Types.this.ScopeEntry">entry</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#516009" title="()Unit" class="delimiter">{</a>
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="516016">sym</a> = <a href="#516008" title="Types.this.ScopeEntry">entry</a>.<a href="Scopes.scala.html#457240" title="=&gt; Types.this.Symbol">sym</a>
            <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#516016" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#443304" title="(mask: Long)Boolean">hasAllFlags</a> <a href="#515133" title="Long">requiredFlags</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Long" id="516017">excl</a> = <a href="#516016" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443302" title="(mask: Long)Long">getFlag</a><span class="delimiter">(</span><a href="#515990" title="Long">excluded</a><span class="delimiter">)</span>
              <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#516017" title="Long">excl</a> <a href="../../Long.scala.html#58254" title="(x: Long)Boolean">==</a> <span title="Long(0L)" class="long">0L</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
                  <span class="delimiter">(</span>// omit PRIVATE LOCALS unless selector class is contained in class owning the def.
                   <span class="delimiter">(</span><a href="#516004" title="List[Types.this.Symbol]">bcs</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516003" title="List[Types.this.Symbol]">bcs0</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
                   <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#516016" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#443600" title="=&gt; Boolean">isPrivateLocal</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
                   <span class="delimiter">(</span><a href="#516003" title="List[Types.this.Symbol]">bcs0</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a>.<a href="Symbols.scala.html#443385" title="(sym: Types.this.Symbol)Boolean">hasTransOwner</a><span class="delimiter">(</span><a href="#516004" title="List[Types.this.Symbol]">bcs</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#515131" title="Types.this.Name">name</a>.<a href="Names.scala.html#444125" title="=&gt; Boolean">isTypeName</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#515134" title="Boolean">stableOnly</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#516016" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443349" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <a href="util/StatBase.scala.html#441049" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: scala.reflect.internal.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441074" title="=&gt; scala.reflect.internal.util.Statistics.Timer">findMemberNanos</a>, <a href="#515987" title="scala.reflect.internal.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
                  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#515986" title="List[Types.this.TypeVar]">suspension</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#515986" title="List[Types.this.TypeVar]">suspension</a> <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.TypeVar =&gt; Unit)Unit">foreach</a> <span class="delimiter">(</span><a href="#516043" title="Types.this.TypeVar">_</a>.<a href="#470180" title="(x$1: Boolean)Unit">suspended</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
                  <span title="Nothing" class="keyword">return</span> <a href="#516016" title="Types.this.Symbol">sym</a>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#515989" title="Types.this.Symbol">member</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <a href="#515989" title="Types.this.Symbol">member</a> = <a href="#516016" title="Types.this.Symbol">sym</a>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#515988" title="Types.this.Scope">members</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#515989" title="Types.this.Symbol">member</a>.<a href="Symbols.scala.html#443152" title="=&gt; Types.this.Symbol#NameType">name</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#516016" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym.NameType">name</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
                      <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#515989" title="Types.this.Symbol">member</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#516016" title="Types.this.Symbol">sym</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
                        <a href="#515989" title="Types.this.Symbol">member</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#516016" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
                        <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#516016" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#443596" title="=&gt; Boolean">isPrivate</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
                          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#515992" title="Types.this.Type">self</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#515992" title="Types.this.Type">self</a> = <a href="#441242" title="Type.this.type" class="keyword">this</a>.<a href="#441993" title="=&gt; Types.this.Type">narrow</a>
                          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#515993" title="Types.this.Type">membertpe</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#515993" title="Types.this.Type">membertpe</a> = <a href="#515992" title="Types.this.Type">self</a>.<a href="#442039" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#515989" title="Types.this.Symbol">member</a><span class="delimiter">)</span>
                          <span class="delimiter">(</span><a href="#515993" title="Types.this.Type">membertpe</a> <a href="#442064" title="(that: Types.this.Type)Boolean">matches</a> <a href="#515992" title="Types.this.Type">self</a>.<a href="#442039" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#516016" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                        <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#515988" title="Types.this.Scope">members</a> = <a href="Scopes.scala.html#441629" title="=&gt; Types.this.Scope">newScope</a>
                    <a href="#515988" title="Types.this.Scope">members</a> <a href="Scopes.scala.html#447331" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#515989" title="Types.this.Symbol">member</a>
                    <a href="#515988" title="Types.this.Scope">members</a> <a href="Scopes.scala.html#447331" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#516016" title="Types.this.Symbol">sym</a>
                  <span class="delimiter">}</span>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                  <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="516086">prevEntry</a> = <a href="#515988" title="Types.this.Scope">members</a>.<a href="Scopes.scala.html#447342" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#516016" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym.NameType">name</a><span class="delimiter">)</span>
                  <span class="keyword">var</span> <a title="Types.this.Type" id="516087">symtpe</a>: <a href="#441242" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
                  <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#516086" title="Types.this.ScopeEntry">prevEntry</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
                         <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#516086" title="Types.this.ScopeEntry">prevEntry</a>.<a href="Scopes.scala.html#457240" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#516016" title="Types.this.Symbol">sym</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
                           <a href="#516086" title="Types.this.ScopeEntry">prevEntry</a>.<a href="Scopes.scala.html#457240" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#516016" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
                           <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#516016" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443303" title="(mask: Long)Boolean">hasFlag</a><span class="delimiter">(</span><span title="Long(4L)">PRIVATE</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
                             <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#515992" title="Types.this.Type">self</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#515992" title="Types.this.Type">self</a> = <a href="#441242" title="Type.this.type" class="keyword">this</a>.<a href="#441993" title="=&gt; Types.this.Type">narrow</a>
                             <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#516087" title="Types.this.Type">symtpe</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#516087" title="Types.this.Type">symtpe</a> = <a href="#515992" title="Types.this.Type">self</a>.<a href="#442039" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#516016" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
                             <a href="#515992" title="Types.this.Type">self</a>.<a href="#442039" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#516086" title="Types.this.ScopeEntry">prevEntry</a>.<a href="Scopes.scala.html#457240" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#442064" title="(that: Types.this.Type)Boolean">matches</a> <a href="#516087" title="Types.this.Type">symtpe</a>
                           <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#516086" title="Types.this.ScopeEntry">prevEntry</a> = <a href="#515988" title="Types.this.Scope">members</a> <a href="Scopes.scala.html#447343" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a> <a href="#516086" title="Types.this.ScopeEntry">prevEntry</a>
                  <span class="delimiter">}</span>
                  <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#516086" title="Types.this.ScopeEntry">prevEntry</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#515988" title="Types.this.Scope">members</a> <a href="Scopes.scala.html#447331" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#516016" title="Types.this.Symbol">sym</a>
                  <span class="delimiter">}</span>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#516017" title="Long">excl</a> <a href="../../Long.scala.html#58254" title="(x: Long)Boolean">==</a> <span title="Int(16)">DEFERRED</span>.<a href="../../Int.scala.html#57875" title="=&gt; Long">toLong</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="#515991" title="Boolean">continue</a> = <span title="Boolean(true)" class="keyword">true</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <a href="#516008" title="Types.this.ScopeEntry">entry</a> = <span title="Types.this.ScopeEntry" class="keyword">if</span> <span class="delimiter">(</span><a href="#515131" title="Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#441764" title="Types.this.nme.type">nme</a>.<a href="StdNames.scala.html#446175" title="=&gt; Types.this.nme.NameType">ANYNAME</a><span class="delimiter">)</span> <a href="#516008" title="Types.this.ScopeEntry">entry</a>.<a href="Scopes.scala.html#457248" title="=&gt; Types.this.ScopeEntry">next</a> <span class="keyword">else</span> <a href="#516007" title="Types.this.Scope">decls</a> <a href="Scopes.scala.html#447343" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a> <a href="#516008" title="Types.this.ScopeEntry">entry</a>
          <span class="delimiter">}</span> // while (entry ne null)
          // excluded = excluded | LOCAL
          <a href="#516004" title="List[Types.this.Symbol]">bcs</a> = <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#515131" title="Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#441764" title="Types.this.nme.type">nme</a>.<a href="StdNames.scala.html#446177" title="=&gt; Types.this.nme.NameType">CONSTRUCTOR</a><span class="delimiter">)</span> <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a> <span class="keyword">else</span> <a href="#516004" title="List[Types.this.Symbol]">bcs</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Symbol]">tail</a>
        <span class="delimiter">}</span> // while (!bcs.isEmpty)
        <a href="#515990" title="Long">excluded</a> = <a href="#515132" title="Long">excludedFlags</a>
      <span class="delimiter">}</span> // while (continue)
      <a href="util/StatBase.scala.html#441049" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: scala.reflect.internal.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441074" title="=&gt; scala.reflect.internal.util.Statistics.Timer">findMemberNanos</a>, <a href="#515987" title="scala.reflect.internal.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#515986" title="List[Types.this.TypeVar]">suspension</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#515986" title="List[Types.this.TypeVar]">suspension</a> <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.TypeVar =&gt; Unit)Unit">foreach</a> <span class="delimiter">(</span><a href="#516136" title="Types.this.TypeVar">_</a>.<a href="#470180" title="(x$1: Boolean)Unit">suspended</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#515988" title="Types.this.Scope">members</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#515989" title="Types.this.Symbol">member</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="util/StatBase.scala.html#441044" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441070" title="=&gt; scala.reflect.internal.util.Statistics.Counter">noMemberCount</a><span class="delimiter">)</span>
        <a href="#515989" title="Types.this.Symbol">member</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="util/StatBase.scala.html#441044" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441072" title="=&gt; scala.reflect.internal.util.Statistics.Counter">multMemberCount</a><span class="delimiter">)</span>
        <a href="#442068" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a>.<a href="Symbols.scala.html#443190" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.TermSymbol">newOverloaded</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a>, <a href="#515988" title="Types.this.Scope">members</a>.<a href="Scopes.scala.html#447344" title="=&gt; List[Types.this.Symbol]">toList</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    /** The (existential or otherwise) skolems and existentially quantified variables which are free in this type */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="442084">skolemsExceptMethodTypeParams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="516151">boundSyms</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="516152">skolems</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span>t &lt;- <a href="#442050" title="(f: Types.this.Type =&gt; Unit)Unit" class="keyword">this</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#516171" title="Types.this.Type">t</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> ExistentialType<a href="#516188" title="Unit" id="516190" class="delimiter">(</a>quantified, qtpe<span class="delimiter">)</span> =&gt;
            <a href="#516151" title="List[Types.this.Symbol]">boundSyms</a> = <a href="#516151" title="List[Types.this.Symbol]">boundSyms</a> <a href="../../collection/immutable/List.scala.html#63646" title="(prefix: List[Types.this.Symbol])List[Types.this.Symbol]">:::</a> quantified
          <span class="keyword">case</span> TypeRef<a href="#516188" title="Unit" id="516194" class="delimiter">(</a>_, sym, _<span class="delimiter">)</span> =&gt;
            <a href="#516195" title="(x: Unit)Unit" class="keyword">if</a> <span class="delimiter">(</span><span class="delimiter">(</span>sym.<a href="Symbols.scala.html#443253" title="=&gt; Boolean">isExistentialSkolem</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> sym.<a href="Symbols.scala.html#443255" title="=&gt; Boolean">isGADTSkolem</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> // treat GADT skolems like existential skolems
                <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#516151" title="List[Types.this.Symbol]">boundSyms</a> <a href="../../collection/SeqLike.scala.html#59768" title="(elem: Any)Boolean">contains</a> sym<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#516152" title="List[Types.this.Symbol]">skolems</a> <a href="../../collection/SeqLike.scala.html#59768" title="(elem: Any)Boolean">contains</a> sym<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#516152" title="List[Types.this.Symbol]">skolems</a> = sym <a href="../../collection/immutable/List.scala.html#63643" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#516152" title="List[Types.this.Symbol]">skolems</a>
          <span class="keyword">case</span> _ =&gt;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#516152" title="List[Types.this.Symbol]">skolems</a>
    <span class="delimiter">}</span>

    // Implementation of Annotatable for all types but AnnotatedType, which
    // overrides these.
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.AnnotationInfo]" id="442085">annotations</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span> = <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="442086">withoutAnnotations</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441242" title="Types.this.Type" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(p: Types.this.AnnotationInfo =&gt; Boolean)Types.this.Type" id="442087">filterAnnotations</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo =&gt; Boolean" id="459328">p</a>: AnnotationInfo =&gt; Boolean<span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441242" title="Types.this.Type" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="442088">setAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="459362">annots</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a>  = <a href="#441349" title="(annots: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.Type">annotatedType</a><span class="delimiter">(</span><a href="#459362" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="442089">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="459345">annots</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441349" title="(annots: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.Type">annotatedType</a><span class="delimiter">(</span><a href="#459345" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Remove any annotations from this type and from any
     *  types embedded in this type. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="442090">stripAnnotations</a> = <a href="#516218" title="(tp: Types.this.Type)Types.this.Type">StripAnnotationsMap</a><span class="delimiter">(</span><a href="#441242" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Set the self symbol of an annotated type, or do nothing
     *  otherwise.  */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="442091">withSelfsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="516223">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#441242" title="Types.this.Type" class="keyword">this</a>

    /** The selfsym of an annotated type, or NoSymbol of anything else */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="442092">selfsym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a>

    /** The kind of this type; used for debugging */
    <span class="keyword">def</span> <a title="=&gt; String" id="442093">kind</a>: <span title="String">String</span> = <span title="String(&quot;unknown type of class &quot;)" class="string">&quot;unknown type of class &quot;</span><span title="(x$1: Any)String">+</span><a href="#441242" title="()Class[_]">getClass</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

// Subclasses ------------------------------------------------------------

  <span class="keyword">trait</span> <a title="trait UniqueType extends AnyRef with Product" id="441243">UniqueType</a> <a href="../../Unit.scala.html#2389" title="Unit" class="keyword">extends</a> <a href="../../Product.scala.html#304" title="Product">Product</a> <span class="delimiter">{</span>
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">val</span> <a title="Int" id="461302">hashCode</a> = scala.runtime.<a href="../../runtime/ScalaRunTime.scala.html#3971" title="scala.runtime.ScalaRunTime.type">ScalaRunTime</a>.<a href="../../runtime/ScalaRunTime.scala.html#58915" title="(x: Product)Int">_hashCode</a><span class="delimiter">(</span><a href="#441243" title="Types.this.UniqueType" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

 /** A base class for types that defer some operations
   *  to their immediate supertype.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SubType extends Types.this.Type" id="441244">SubType</a> <a href="#441244" title="Types.this.SubType" class="keyword">extends</a> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448287">supertype</a>: <a href="#441242" title="Types.this.Type">Type</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="448288">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#448287" title="=&gt; Types.this.Type">supertype</a>.<a href="#441995" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="448289">decls</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a> = <a href="#448287" title="=&gt; Types.this.Type">supertype</a>.<a href="#442019" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="448290">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="516236">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#448287" title="=&gt; Types.this.Type">supertype</a>.<a href="#442036" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#516236" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="448291">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#441719" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#448287" title="=&gt; Types.this.Type">supertype</a>.<a href="#442066" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="448292">baseTypeSeqDepth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a> = <a href="#448287" title="=&gt; Types.this.Type">supertype</a>.<a href="#442067" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="448293">baseClasses</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#448287" title="=&gt; Types.this.Type">supertype</a>.<a href="#442068" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448294">isNotNull</a> = <a href="#448287" title="=&gt; Types.this.Type">supertype</a>.<a href="#441975" title="=&gt; Boolean">isNotNull</a>
  <span class="delimiter">}</span>

  case <span class="keyword">class</span> <a title="class NotNullType extends Types.this.SubType with Types.this.RewrappingTypeProxy with Product with Serializable" id="536590">NotNullType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="470408">underlying</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441244" title="Types.this.SubType">SubType</a> <span class="keyword">with</span> <a href="#441238" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="470381">supertype</a> = <a href="#470408" title="=&gt; Types.this.Type">underlying</a>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="470382">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="516249">newtp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#536590" title="(underlying: Types.this.Type)Types.this.NotNullType">NotNullType</a><span class="delimiter">(</span><a href="#516249" title="Types.this.Type">newtp</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="470383">isNotNull</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.NotNullType" id="470384">notNull</a> = <a href="#536590" title="Types.this.NotNullType" class="keyword">this</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="470385">deconst</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#470408" title="=&gt; Types.this.Type">underlying</a> //todo: needed?
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="470386">safeToString</a>: <span title="String">String</span> = <a href="#470408" title="=&gt; Types.this.Type">underlying</a>.<a href="#442076" title="()String">toString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; with NotNull&quot;)" class="string">&quot; with NotNull&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="470387">kind</a> = <span title="String(&quot;NotNullType&quot;)" class="string">&quot;NotNullType&quot;</span>
  <span class="delimiter">}</span>

  /** A base class for types that represent a single value
   *  (single-types and this-types).
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SingletonType extends Types.this.SubType with Types.this.SimpleTypeProxy" id="441248">SingletonType</a> <a href="#441248" title="Types.this.SingletonType" class="keyword">extends</a> <a href="#441244" title="Types.this.SubType">SubType</a> <span class="keyword">with</span> <a href="#441237" title="Types.this.SimpleTypeProxy">SimpleTypeProxy</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="460804">supertype</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="460805">isTrivial</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="460806">isStable</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="460807">isVolatile</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441974" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="460808">widen</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441990" title="=&gt; Types.this.Type">widen</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="460809">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#441719" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      <a href="util/StatBase.scala.html#441044" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441062" title="=&gt; scala.reflect.internal.util.Statistics.Counter">singletonBaseTypeSeqCount</a><span class="delimiter">)</span>
      <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442066" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#447206" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">prepend</a> <a href="#441248" title="Types.this.SingletonType" class="keyword">this</a>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="460810">isHigherKinded</a> = <span title="Boolean(false)" class="keyword">false</span> // singleton type classifies objects, thus must be kind *
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="460811">safeToString</a>: <span title="String">String</span> = <span class="delimiter">{</span>
      // Avoiding printing Predef.type and scala.package.type as &quot;type&quot;,
      // since in all other cases we omit those prefixes.
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="516329">pre</a> = <a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443329" title="=&gt; Types.this.Symbol">skipPackageObject</a>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#516329" title="Types.this.Symbol">pre</a>.<a href="Symbols.scala.html#443331" title="=&gt; Boolean">isOmittablePrefix</a><span class="delimiter">)</span> <a href="#516329" title="Types.this.Symbol">pre</a>.<a href="Symbols.scala.html#443398" title="=&gt; String">fullName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span>
      <span class="keyword">else</span> <a href="#442075" title="=&gt; String">prefixString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;type&quot;)" class="string">&quot;type&quot;</span>
    <span class="delimiter">}</span>

/*
    override def typeOfThis: Type = typeSymbol.typeOfThis
    override def bounds: TypeBounds = TypeBounds(this, this)
    override def prefix: Type = NoType
    override def typeArgs: List[Type] = List()
    override def typeParams: List[Symbol] = List()
*/
  <span class="delimiter">}</span>

  /** An object representing an erroneous type */
  case <span class="keyword">object</span> <a href="#516375" title="Types.this.ErrorType.type" id="516388">ErrorType</a> <a href="../../Product.scala.html#304" title="Product" class="keyword">extends</a> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    // todo see whether we can do without
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="470480">isError</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="470481">decls</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a> = <span title="Types.this.ErrorScope" class="keyword">new</span> <a href="Scopes.scala.html#441636" title="Types.this.ErrorScope">ErrorScope</a><span class="delimiter">(</span><a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol" id="470482">findMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="516339">name</a>: <a href="Names.scala.html#440792" title="Types.this.Name">Name</a>, <a title="Long" id="516340">excludedFlags</a>: <a href="../../Long.scala.html#1993" title="Long">Long</a>, <a title="Long" id="516341">requiredFlags</a>: <a href="../../Long.scala.html#1993" title="Long">Long</a>, <a title="Boolean" id="516342">stableOnly</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="516344">sym</a> = <a href="#470481" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#447340" title="(name: Types.this.Name)Types.this.Symbol">lookup</a> <a href="#516339" title="Types.this.Name">name</a>
      <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#516344" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#516344" title="Types.this.Symbol">sym</a> = <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a>.<a href="Symbols.scala.html#443215" title="(name: Types.this.Name)Types.this.Symbol">newErrorSymbol</a><span class="delimiter">(</span><a href="#516339" title="Types.this.Name">name</a><span class="delimiter">)</span>
        <a href="#470481" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#447331" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#516344" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span>
      <a href="#516344" title="Types.this.Symbol">sym</a>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="470483">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="516362">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="keyword">this</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="470484">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;&lt;error&gt;&quot;)" class="string">&quot;&lt;error&gt;&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="470485">narrow</a>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="keyword">this</span>
    // override def isNullable: Boolean = true
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="470486">kind</a> = <span title="String(&quot;ErrorType&quot;)" class="string">&quot;ErrorType&quot;</span>
  <span class="delimiter">}</span>

  /** An object representing an unknown type, used during type inference.
   *  If you see WildcardType outside of inference it is almost certainly a bug.
   */
  case <span class="keyword">object</span> <a href="#516401" title="Types.this.WildcardType.type" id="516414">WildcardType</a> <a href="../../Product.scala.html#304" title="Product" class="keyword">extends</a> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="470488">isWildcard</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="470489">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span>
    // override def isNullable: Boolean = true
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="470490">kind</a> = <span title="String(&quot;WildcardType&quot;)" class="string">&quot;WildcardType&quot;</span>
  <span class="delimiter">}</span>
  /** BoundedWildcardTypes, used only during type inference, are created in
   *  two places that I can find:
   *
   *    1. If the expected type of an expression is an existential type,
   *       its hidden symbols are replaced with bounded wildcards.
   *    2. When an implicit conversion is being sought based in part on
   *       the name of a method in the converted type, a HasMethodMatching
   *       type is created: a MethodType with parameters typed as
   *       BoundedWildcardTypes.
   */
  case <span class="keyword">class</span> <a title="class BoundedWildcardType extends Types.this.Type with Product with Serializable" id="469712">BoundedWildcardType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.TypeBounds" id="469721">bounds</a>: <a href="#448315" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="469707">isWildcard</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="469708">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#469721" title="=&gt; Types.this.TypeBounds">bounds</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="469709">kind</a> = <span title="String(&quot;BoundedWildcardType&quot;)" class="string">&quot;BoundedWildcardType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Types.this.BoundedWildcardType.type" id="516465">BoundedWildcardType</a> <a href="#441255" title="Types.this.BoundedWildcardType.type" class="keyword">extends</a> <a href="../api/Types.scala.html#23485" title="Types.this.BoundedWildcardTypeExtractor">BoundedWildcardTypeExtractor</a>

  /** An object representing a non-existing type */
  case <span class="keyword">object</span> <a href="#516477" title="Types.this.NoType.type" id="516490">NoType</a> <a href="../../Product.scala.html#304" title="Product" class="keyword">extends</a> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="447146">isTrivial</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="447147">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;&lt;notype&gt;&quot;)" class="string">&quot;&lt;notype&gt;&quot;</span>
    // override def isNullable: Boolean = true
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="447148">kind</a> = <span title="String(&quot;NoType&quot;)" class="string">&quot;NoType&quot;</span>
  <span class="delimiter">}</span>

  /** An object representing a non-existing prefix */
  case <span class="keyword">object</span> <a href="#516507" title="Types.this.NoPrefix.type" id="516520">NoPrefix</a> <a href="../../Product.scala.html#304" title="Product" class="keyword">extends</a> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="462794">isTrivial</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="462795">isStable</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="462796">prefixString</a> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="462797">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;&lt;noprefix&gt;&quot;)" class="string">&quot;&lt;noprefix&gt;&quot;</span>
    // override def isNullable: Boolean = true
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="462798">kind</a> = <span title="String(&quot;NoPrefixType&quot;)" class="string">&quot;NoPrefixType&quot;</span>
  <span class="delimiter">}</span>

  /** A class for this-types of the form &lt;sym&gt;.this.type
   */
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#516559" title="class ThisType extends Types.this.SingletonType with Product with Serializable" id="461383">ThisType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><a title="Types.this.Symbol" id="461389">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441248" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#8459" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span><a href="#461389" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443231" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span>
    //assert(sym.isClass &amp;&amp; !sym.isModuleClass || sym.isRoot, sym)
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="461312">isTrivial</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#461389" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="461313">isNotNull</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="461314">typeSymbol</a> = <a href="#461389" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="461315">underlying</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#461389" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443484" title="=&gt; Types.this.Type">typeOfThis</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="461316">isVolatile</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="461317">isHigherKinded</a> = <a href="#461389" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443248" title="=&gt; Boolean">isRefinementClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#461315" title="=&gt; Types.this.Type">underlying</a>.<a href="#441972" title="=&gt; Boolean">isHigherKinded</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="461318">prefixString</a> =
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456420" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#461389" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443556" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.this.&quot;)" class="string">&quot;.this.&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#461389" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443239" title="=&gt; Boolean">isAnonOrRefinementClass</a><span class="delimiter">)</span> <span title="String(&quot;this.&quot;)" class="string">&quot;this.&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#461389" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443331" title="=&gt; Boolean">isOmittablePrefix</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#461389" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443245" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <a href="#461389" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443557" title="=&gt; String">fullNameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      <span class="keyword">else</span> <a href="#461389" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443556" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.this.&quot;)" class="string">&quot;.this.&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="461319">safeToString</a>: <span title="String">String</span> =
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#461389" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443297" title="=&gt; Boolean">isEffectiveRoot</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#461389" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443152" title="=&gt; ThisType.this.sym.NameType">name</a>
      <span class="keyword">else</span> <a href="#461383" title="Types.this.ThisType" class="keyword">super</a>.<a href="#460811" title="=&gt; String">safeToString</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="461320">narrow</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#461383" title="Types.this.ThisType" class="keyword">this</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="461321">kind</a> = <span title="String(&quot;ThisType&quot;)" class="string">&quot;ThisType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueThisType extends Types.this.ThisType with Types.this.UniqueType" id="441263">UniqueThisType</a><a href="#441263" title="Types.this.UniqueThisType" class="delimiter">(</a><a title="Types.this.Symbol" id="516594">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#461383" title="Types.this.ThisType">ThisType</a><span class="delimiter">(</span><a href="#516594" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441243" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Types.this.ThisType.type" id="516602">ThisType</a> <a href="#441262" title="Types.this.ThisType.type" class="keyword">extends</a> <a href="../api/Types.scala.html#23492" title="Types.this.ThisTypeExtractor">ThisTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="461307">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="461323">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#441408" title="(tp: Types.this.UniqueThisType)Types.this.UniqueThisType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueThisType" class="keyword">new</span> <a href="#441263" title="Types.this.UniqueThisType">UniqueThisType</a><span class="delimiter">(</span><a href="#461323" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461323" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443243" title="=&gt; Boolean">isImplClass</a><span class="delimiter">)</span> <a href="#461323" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443484" title="=&gt; Types.this.Type">typeOfThis</a>
      <span class="keyword">else</span> <a href="#461323" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A class for singleton types of the form `&lt;prefix&gt;.&lt;sym.name&gt;.type`.
   *  Cannot be created directly; one should always use `singleType` for creation.
   */
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#516665" title="class SingleType extends Types.this.SingletonType with Product with Serializable" id="461451">SingleType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><a title="Types.this.Type" id="461463">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="461464">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441248" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="461432">isTrivial</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#461463" title="=&gt; Types.this.Type">pre</a>.<a href="#441971" title="=&gt; Boolean">isTrivial</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="461434">isGround</a> = <a href="#461464" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#461463" title="=&gt; Types.this.Type">pre</a>.<a href="#442080" title="=&gt; Boolean">isGround</a>

    // override def isNullable = underlying.isNullable
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="461435">isNotNull</a> = <a href="#461442" title="=&gt; Types.this.Type">underlying</a>.<a href="#441975" title="=&gt; Boolean">isNotNull</a>
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Types.this.Type" id="461437">underlyingCache</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#516490" title="Types.this.NoType.type">NoType</a>
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Int" id="461440">underlyingPeriod</a> = <span title="Int(0)">NoPeriod</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="461442">underlying</a>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="516616">cache</a> = <a href="#461437" title="=&gt; Types.this.Type">underlyingCache</a>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461440" title="=&gt; Int">underlyingPeriod</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <a href="SymbolTable.scala.html#440602" title="=&gt; Types.this.Period">currentPeriod</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#516616" title="Types.this.Type">cache</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#516616" title="Types.this.Type">cache</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#441268" title="(tpe: Types.this.SingleType)Unit">defineUnderlyingOfSingleType</a><span class="delimiter">(</span><a href="#461451" title="Types.this.SingleType" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#461437" title="=&gt; Types.this.Type">underlyingCache</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    // more precise conceptually, but causes cyclic errors:    (paramss exists (_ contains sym))
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="461443">isImmediatelyDependent</a> = <span class="delimiter">(</span><a href="#461464" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#461464" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#443282" title="=&gt; Boolean">isMethod</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#461464" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443275" title="=&gt; Boolean">isValueParameter</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="461444">isVolatile</a> : <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#461442" title="=&gt; Types.this.Type">underlying</a>.<a href="#441974" title="=&gt; Boolean">isVolatile</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#461464" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443349" title="=&gt; Boolean">isStable</a>
/*
    override def narrow: Type = {
      if (phase.erasedTypes) this
      else {
        val thissym = refinedType(List(this), sym.owner, EmptyScope).typeSymbol
        if (sym.owner != NoSymbol) {
          //Console.println(&quot;narrowing module &quot; + sym + thissym.owner);
          thissym.typeOfThis = this
        }
        thissym.thisType
      }
    }
*/
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="461445">narrow</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#461451" title="Types.this.SingleType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="461446">termSymbol</a> = <a href="#461464" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="461447">prefix</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#461463" title="=&gt; Types.this.Type">pre</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="461448">prefixString</a> = <span class="delimiter">(</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#461464" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443329" title="=&gt; Types.this.Symbol">skipPackageObject</a>.<a href="Symbols.scala.html#443331" title="=&gt; Boolean">isOmittablePrefix</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#461464" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443290" title="=&gt; Boolean">isPackageObjectOrClass</a><span class="delimiter">)</span> <a href="#461463" title="=&gt; Types.this.Type">pre</a>.<a href="#442075" title="=&gt; String">prefixString</a>
      <span class="keyword">else</span> <a href="#461463" title="=&gt; Types.this.Type">pre</a>.<a href="#442075" title="=&gt; String">prefixString</a> <span title="(x$1: Any)String">+</span> <a href="#461464" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443556" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
    <span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="461449">kind</a> = <span title="String(&quot;SingleType&quot;)" class="string">&quot;SingleType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueSingleType extends Types.this.SingleType with Types.this.UniqueType" id="441267">UniqueSingleType</a><a href="#441267" title="Types.this.UniqueSingleType" class="delimiter">(</a><a title="Types.this.Type" id="516704">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="516705">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#461451" title="Types.this.SingleType">SingleType</a><span class="delimiter">(</span><a href="#516704" title="Types.this.Type">pre</a>, <a href="#516705" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441243" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Types.this.SingleType.type" id="516710">SingleType</a> <a href="#441266" title="Types.this.SingleType.type" class="keyword">extends</a> <a href="../api/Types.scala.html#23498" title="Types.this.SingleTypeExtractor">SingleTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="461424">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="469553">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="469554">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#441408" title="(tp: Types.this.UniqueSingleType)Types.this.UniqueSingleType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueSingleType" class="keyword">new</span> <a href="#441267" title="Types.this.UniqueSingleType">UniqueSingleType</a><span class="delimiter">(</span><a href="#469553" title="Types.this.Type">pre</a>, <a href="#469554" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tpe: Types.this.SingleType)Unit" id="441268">defineUnderlyingOfSingleType</a><span class="delimiter">(</span><a title="Types.this.SingleType" id="516626">tpe</a>: <a href="#461451" title="Types.this.SingleType">SingleType</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Int" id="516629">period</a> = <a href="#516626" title="Types.this.SingleType">tpe</a>.<a href="#461440" title="=&gt; Int">underlyingPeriod</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#516629" title="Int">period</a> <a href="../../Int.scala.html#57898" title="(x: Int)Boolean">!=</a> <a href="SymbolTable.scala.html#440602" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#516626" title="Types.this.SingleType">tpe</a>.<a href="#461440" title="(x$1: Int)Unit">underlyingPeriod</a> = <a href="SymbolTable.scala.html#440602" title="=&gt; Types.this.Period">currentPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#440624" title="(period: Types.this.Period)Boolean">isValid</a><span class="delimiter">(</span><a href="#516629" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        // [Eugene to Paul] needs review
        <a href="#516626" title="Types.this.SingleType">tpe</a>.<a href="#461437" title="(x$1: Types.this.Type)Unit">underlyingCache</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#516626" title="Types.this.SingleType">tpe</a>.<a href="#461464" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#461307" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="Definitions.scala.html#442142" title="Types.this.definitions.RootClass.type">RootClass</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#516626" title="Types.this.SingleType">tpe</a>.<a href="#461463" title="=&gt; Types.this.Type">pre</a>.<a href="#442039" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#516626" title="Types.this.SingleType">tpe</a>.<a href="#461464" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#442002" title="=&gt; Types.this.Type">resultType</a>;
        <a href="../../Predef.scala.html#8460" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#516626" title="Types.this.SingleType">tpe</a>.<a href="#461437" title="=&gt; Types.this.Type">underlyingCache</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#516626" title="Types.this.SingleType">tpe</a>, <a href="#516626" title="Types.this.SingleType">tpe</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#516736" title="class SuperType extends Types.this.SingletonType with Product with Serializable" id="461409">SuperType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><a title="Types.this.Type" id="461421">thistpe</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="461422">supertpe</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441248" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="461399">isTrivial</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#461421" title="=&gt; Types.this.Type">thistpe</a>.<a href="#441971" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#461422" title="=&gt; Types.this.Type">supertpe</a>.<a href="#441971" title="=&gt; Boolean">isTrivial</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="461401">isNotNull</a> = <span title="Boolean(true)" class="keyword">true</span>;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="461402">typeSymbol</a> = <a href="#461421" title="=&gt; Types.this.Type">thistpe</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="461403">underlying</a> = <a href="#461422" title="=&gt; Types.this.Type">supertpe</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="461404">prefix</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#461422" title="=&gt; Types.this.Type">supertpe</a>.<a href="#441997" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="461405">prefixString</a> = <a href="#461421" title="=&gt; Types.this.Type">thistpe</a>.<a href="#442075" title="=&gt; String">prefixString</a>.<span title="(x$1: String, x$2: String)String">replaceAll</span><span class="delimiter">(</span><span title="String(&quot;\\bthis\\.$&quot;)" class="string">&quot;&quot;&quot;\bthis\.$&quot;&quot;&quot;</span>, <span title="String(&quot;super.&quot;)" class="string">&quot;super.&quot;</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="461406">narrow</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#461421" title="=&gt; Types.this.Type">thistpe</a>.<a href="#441993" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="461407">kind</a> = <span title="String(&quot;SuperType&quot;)" class="string">&quot;SuperType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueSuperType extends Types.this.SuperType with Types.this.UniqueType" id="441272">UniqueSuperType</a><a href="#441272" title="Types.this.UniqueSuperType" class="delimiter">(</a><a title="Types.this.Type" id="516775">thistp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="516776">supertp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#461409" title="Types.this.SuperType">SuperType</a><span class="delimiter">(</span><a href="#516775" title="Types.this.Type">thistp</a>, <a href="#516776" title="Types.this.Type">supertp</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441243" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Types.this.SuperType.type" id="516781">SuperType</a> <a href="#441271" title="Types.this.SuperType.type" class="keyword">extends</a> <a href="../api/Types.scala.html#23501" title="Types.this.SuperTypeExtractor">SuperTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(thistp: Types.this.Type, supertp: Types.this.Type)Types.this.Type" id="461391">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="469681">thistp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="469682">supertp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#469682" title="Types.this.Type">supertp</a>
      <span class="keyword">else</span> <a href="#441408" title="(tp: Types.this.UniqueSuperType)Types.this.UniqueSuperType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueSuperType" class="keyword">new</span> <a href="#441272" title="Types.this.UniqueSuperType">UniqueSuperType</a><span class="delimiter">(</span><a href="#469681" title="Types.this.Type">thistp</a>, <a href="#469682" title="Types.this.Type">supertp</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A class for the bounds of abstract types and type parameters
   */
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#516822" title="class TypeBounds extends Types.this.SubType with Product with Serializable" id="448315">TypeBounds</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><a title="Types.this.Type" id="448327">lo</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="448328">hi</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441244" title="Types.this.SubType">SubType</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448302">supertype</a> = <a href="#448328" title="=&gt; Types.this.Type">hi</a>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="448303">isTrivial</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#448327" title="=&gt; Types.this.Type">lo</a>.<a href="#441971" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#448328" title="=&gt; Types.this.Type">hi</a>.<a href="#441971" title="=&gt; Boolean">isTrivial</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="448305">bounds</a>: <a href="#448315" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#448315" title="Types.this.TypeBounds" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="448306">containsType</a><span class="delimiter">(</span><a title="Types.this.Type" id="516790">that</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#516790" title="Types.this.Type">that</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> TypeBounds<a href="#516797" title="Boolean" id="516801" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt; <a href="#516790" title="Types.this.Type">that</a> <a href="#516802" title="(x: Boolean)Boolean">&lt;:&lt;</a> <a href="#448315" title="Types.this.TypeBounds" class="keyword">this</a>
      <span class="keyword">case</span> _                =&gt; <a href="#448327" title="=&gt; Types.this.Type">lo</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#516790" title="Types.this.Type">that</a> <a href="#516802" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#516790" title="Types.this.Type">that</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#448328" title="=&gt; Types.this.Type">hi</a>
    <span class="delimiter">}</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; String" id="448307">lowerString</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#448309" title="=&gt; Boolean">emptyLowerBound</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <span title="String(&quot; &gt;: &quot;)" class="string">&quot; &gt;: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#448327" title="=&gt; Types.this.Type">lo</a>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; String" id="448308">upperString</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#448310" title="=&gt; Boolean">emptyUpperBound</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <span title="String(&quot; &lt;: &quot;)" class="string">&quot; &lt;: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#448328" title="=&gt; Types.this.Type">hi</a>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448309">emptyLowerBound</a> = <a href="#448327" title="=&gt; Types.this.Type">lo</a>.<a href="#441988" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448310">emptyUpperBound</a> = <a href="#448328" title="=&gt; Types.this.Type">hi</a>.<a href="#441988" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="448311">isEmptyBounds</a> = <a href="#448309" title="=&gt; Boolean">emptyLowerBound</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#448310" title="=&gt; Boolean">emptyUpperBound</a>

    // override def isNullable: Boolean = NullClass.tpe &lt;:&lt; lo;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="448312">safeToString</a> = <a href="#448307" title="=&gt; String">lowerString</a> <span title="(x$1: Any)String">+</span> <a href="#448308" title="=&gt; String">upperString</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="448313">kind</a> = <span title="String(&quot;TypeBoundsType&quot;)" class="string">&quot;TypeBoundsType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueTypeBounds extends Types.this.TypeBounds with Types.this.UniqueType" id="441276">UniqueTypeBounds</a><a href="#441276" title="Types.this.UniqueTypeBounds" class="delimiter">(</a><a title="Types.this.Type" id="516861">lo</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="516862">hi</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#448315" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#516861" title="Types.this.Type">lo</a>, <a href="#516862" title="Types.this.Type">hi</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441243" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Types.this.TypeBounds.type" id="516870">TypeBounds</a> <a href="#441275" title="Types.this.TypeBounds.type" class="keyword">extends</a> <a href="../api/Types.scala.html#23522" title="Types.this.TypeBoundsExtractor">TypeBoundsExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="448282">empty</a>: <a href="#448315" title="Types.this.TypeBounds">TypeBounds</a>           = <a href="#448285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a>, <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(hi: Types.this.Type)Types.this.TypeBounds" id="448283">upper</a><span class="delimiter">(</span><a title="Types.this.Type" id="457758">hi</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#448315" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#448285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a>, <a href="#457758" title="Types.this.Type">hi</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(lo: Types.this.Type)Types.this.TypeBounds" id="448284">lower</a><span class="delimiter">(</span><a title="Types.this.Type" id="516866">lo</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#448315" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#448285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="#516866" title="Types.this.Type">lo</a>, <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds" id="448285">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="469693">lo</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="469694">hi</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#448315" title="Types.this.TypeBounds">TypeBounds</a> = <span class="delimiter">{</span>
      <a href="#441408" title="(tp: Types.this.UniqueTypeBounds)Types.this.UniqueTypeBounds">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueTypeBounds" class="keyword">new</span> <a href="#441276" title="Types.this.UniqueTypeBounds">UniqueTypeBounds</a><span class="delimiter">(</span><a href="#469693" title="Types.this.Type">lo</a>, <a href="#469694" title="Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.TypeBounds" class="delimiter">[</span><a href="#448315" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">]</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A common base class for intersection types and class types
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class CompoundType extends Types.this.Type" id="441277">CompoundType</a> <a href="#441277" title="Types.this.CompoundType" class="keyword">extends</a> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>

    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Types.this.BaseTypeSeq" id="447254">baseTypeSeqCache</a>: <a href="BaseTypeSeqs.scala.html#441719" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = _
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Int" id="447257">baseTypeSeqPeriod</a> = <span title="Int(0)">NoPeriod</span>
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="447260">baseClassesCache</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = _
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Int" id="447263">baseClassesPeriod</a> = <span title="Int(0)">NoPeriod</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="447265">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#441719" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="516876">cached</a> = <a href="#447254" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
      <span title="Types.this.BaseTypeSeq" class="keyword">if</span> <span class="delimiter">(</span><a href="#447257" title="=&gt; Int">baseTypeSeqPeriod</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <a href="SymbolTable.scala.html#440602" title="=&gt; Types.this.Period">currentPeriod</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#516876" title="Types.this.BaseTypeSeq">cached</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#516876" title="Types.this.BaseTypeSeq">cached</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="BaseTypeSeqs.scala.html#441720" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
        <a href="#516876" title="Types.this.BaseTypeSeq">cached</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#441278" title="(tpe: Types.this.CompoundType)Unit">defineBaseTypeSeqOfCompoundType</a><span class="delimiter">(</span><a href="#441277" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#447254" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="BaseTypeSeqs.scala.html#441720" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <span title="Types.this.RecoverableCyclicReference" class="keyword">new</span> <a href="#536666" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>

        <a href="#447254" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="447266">baseTypeSeqDepth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a> = <a href="#447265" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#447211" title="=&gt; Int">maxDepth</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="447267">baseClasses</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="517359">cached</a> = <a href="#447260" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a>
      <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#447263" title="=&gt; Int">baseClassesPeriod</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <a href="SymbolTable.scala.html#440602" title="=&gt; Types.this.Period">currentPeriod</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#517359" title="List[Types.this.Symbol]">cached</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#517359" title="List[Types.this.Symbol]">cached</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#441279" title="(tpe: Types.this.CompoundType)Unit">defineBaseClassesOfCompoundType</a><span class="delimiter">(</span><a href="#441277" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#447260" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <span title="Types.this.RecoverableCyclicReference" class="keyword">new</span> <a href="#536666" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>

        <a href="#447260" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** The slightly less idiomatic use of Options is due to
     *  performance considerations. A version using for comprehensions
     *  might be too slow (this is deemed a hotspot of the type checker).
     *
     *  See with Martin before changing this method.
     */
    <span class="keyword">def</span> <a title="[A](op1: =&gt; A)(op2: Types.this.Type =&gt; A)A" id="447268">memo</a><span class="delimiter">[</span><a title="" id="447270">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="517334">op1</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; A" id="517335">op2</a>: Type =&gt; A<span class="delimiter">)</span>: <a href="#447270" title="A">A</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="()A" id="517439">updateCache</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#447270" title="A">A</a> = <span class="delimiter">{</span>
        <a href="../../collection/convert/Wrappers.scala.html#132526" title="(k: List[Types.this.Type], v: scala.ref.WeakReference[Types.this.Type])Unit">intersectionWitness</a><span class="delimiter">(</span><a href="#441995" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> = <a href="../../ref/WeakReference.scala.html#422283" title="(value: Types.this.CompoundType)scala.ref.WeakReference[Types.this.CompoundType]" class="keyword">new</a> <a href="../../ref/WeakReference.scala.html#18083" title="scala.ref.WeakReference[Types.this.CompoundType]">WeakReference</a><span class="delimiter">(</span><a href="#441277" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#517334" title="=&gt; A">op1</a>
      <span class="delimiter">}</span>

      <a href="#441235" title="=&gt; scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]">intersectionWitness</a> <a href="../../collection/convert/Wrappers.scala.html#132522" title="(k: List[Types.this.Type])Option[scala.ref.WeakReference[Types.this.Type]]">get</a> <a href="#441995" title="=&gt; List[Types.this.Type]">parents</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Some<a href="#517473" title="A" id="517474" class="delimiter">(</a>ref<span class="delimiter">)</span> =&gt;
          ref.<a href="#517477" title="(x: A)A">get</a> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> Some<a href="#517460" title="A" id="517461" class="delimiter">(</a>w<span class="delimiter">)</span> =&gt; <a href="#517464" title="(x: A)A" class="keyword">if</a> <span class="delimiter">(</span>w <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#441277" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span> <a href="#517334" title="=&gt; A">op1</a> <span class="keyword">else</span> <a href="../../Function1.scala.html#59555" title="(v1: Types.this.Type)A">op2</a><span class="delimiter">(</span>w<span class="delimiter">)</span>
            <span class="keyword">case</span> <a href="../../Option.scala.html#2498" title="A" id="517463">None</a> =&gt; <a href="#517439" title="()A">updateCache</a><a href="#517464" title="(x: A)A" class="delimiter">(</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="keyword">case</span> <a href="../../Option.scala.html#2498" title="A" id="517476">None</a> =&gt; <a href="#517439" title="()A">updateCache</a><a href="#517477" title="(x: A)A" class="delimiter">(</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="447271">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="517485">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="517488">index</a> = <a href="#442069" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#517485" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#517488" title="Int">index</a> <a href="../../Int.scala.html#57926" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="BaseTypeSeqs.scala.html#447201" title="(i: Int)Types.this.Type">baseTypeSeq</a><span class="delimiter">(</span><a href="#517488" title="Int">index</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#516490" title="Types.this.NoType.type">NoType</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="447272">narrow</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443485" title="=&gt; Types.this.Type">thisType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="447273">isNotNull</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#441995" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#517501" title="Types.this.Type">_</a>.<a href="#441975" title="=&gt; Boolean">isNotNull</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="447274">isStructuralRefinement</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> =
      <a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443239" title="=&gt; Boolean">isAnonOrRefinementClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#442019" title="=&gt; Types.this.Scope">decls</a>.<a href="../../collection/IterableLike.scala.html#59462" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#517509" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443370" title="=&gt; Boolean">isPossibleInRefinement</a><span class="delimiter">)</span>

    // override def isNullable: Boolean =
    // parents forall (p =&gt; p.isNullable &amp;&amp; !p.typeSymbol.isAbstractType);

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="447275">safeToString</a>: <span title="String">String</span> = <a href="Definitions.scala.html#442564" title="(parents: List[Types.this.Type])String">parentsString</a><span class="delimiter">(</span><a href="#441995" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span>
      <span class="delimiter">(</span><span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456420" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#441995" title="=&gt; List[Types.this.Type]">parents</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#442019" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#447308" title="=&gt; Types.this.ScopeEntry">elems</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#442019" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#447351" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;{&quot;)" class="string">&quot;{&quot;</span>, <span title="String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="String(&quot;}&quot;)" class="string">&quot;}&quot;</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tpe: Types.this.CompoundType)Unit" id="441278">defineBaseTypeSeqOfCompoundType</a><span class="delimiter">(</span><a title="Types.this.CompoundType" id="516890">tpe</a>: <a href="#441277" title="Types.this.CompoundType">CompoundType</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Int" id="516893">period</a> = <a href="#516890" title="Types.this.CompoundType">tpe</a>.<a href="#447257" title="=&gt; Int">baseTypeSeqPeriod</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#516893" title="Int">period</a> <a href="../../Int.scala.html#57898" title="(x: Int)Boolean">!=</a> <a href="SymbolTable.scala.html#440602" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#516890" title="Types.this.CompoundType">tpe</a>.<a href="#447257" title="(x$1: Int)Unit">baseTypeSeqPeriod</a> = <a href="SymbolTable.scala.html#440602" title="=&gt; Types.this.Period">currentPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#440625" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#516893" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#516890" title="Types.this.CompoundType">tpe</a>.<a href="#441995" title="=&gt; List[Types.this.Type]">parents</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#516907" title="Types.this.Type">_</a>.<a href="#442055" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#516910" title="Types.this.Type">_</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#441345" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          // rename type vars to fresh type params, take base type sequence of
          // resulting type, and rename back all the entries in that sequence
          <span class="keyword">var</span> <a title="scala.collection.immutable.Set[Types.this.TypeVar]" id="516911">tvs</a> = <a href="../../collection/generic/GenericCompanion.scala.html#60782" title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</a><span title="(elems: Types.this.TypeVar*)scala.collection.immutable.Set[Types.this.TypeVar]" class="delimiter">[</span><a href="#441345" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
          <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="516939">p</a> &lt;- <a href="#516890" title="Types.this.CompoundType">tpe</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.Type =&gt; Unit)Unit">parents</a><span class="delimiter">)</span>
            <span class="keyword">for</span> <span class="delimiter">(</span>t &lt;- <a href="#442050" title="(f: Types.this.Type =&gt; Unit)Unit">p</a><span class="delimiter">)</span> <a href="#516944" title="Types.this.Type">t</a> <span class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <a href="#516962" title="Unit" id="516964">tv</a>: TypeVar =&gt; <a href="#516911" title="scala.collection.immutable.Set[Types.this.TypeVar]">tvs</a> <a href="#516965" title="(x: Unit)Unit">+=</a> tv
              <span class="keyword">case</span> _ =&gt;
            <span class="delimiter">}</span>
          <span class="keyword">val</span> <a title="Map[Types.this.Type,Types.this.Symbol]" id="516912">varToParamMap</a>: <a href="../../collection/immutable/Map.scala.html#11605" title="Map[Types.this.Type,Types.this.Symbol]">Map</a><span class="delimiter">[</span>Type, Symbol<span class="delimiter">]</span> =
            <a href="util/Collections.scala.html#440707" title="[A, A1 &gt;: A, B](xs: List[A])(f: A =&gt; B)Map[A1,B]">mapFrom</a><span title="(xs: List[Types.this.TypeVar])(f: Types.this.TypeVar =&gt; Types.this.Symbol)Map[Types.this.Type,Types.this.Symbol]" class="delimiter">[</span><a href="#441345" title="Types.this.TypeVar">TypeVar</a>, <a href="#441242" title="Types.this.Type">Type</a>, <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#516911" title="scala.collection.immutable.Set[Types.this.TypeVar]">tvs</a>.<a href="../../collection/TraversableOnce.scala.html#59174" title="=&gt; List[Types.this.TypeVar]">toList</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#516981" title="Types.this.TypeVar">_</a>.<a href="#521840" title="=&gt; Types.this.Type">origin</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443475" title="=&gt; Types.this.Symbol#TypeOfClonedSymbol">cloneSymbol</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]" id="516913">paramToVarMap</a> = <a href="#516912" title="Map[Types.this.Type,Types.this.Symbol]">varToParamMap</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: ((Types.this.Type, Types.this.Symbol)) =&gt; (Types.this.Symbol, Types.this.Type))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[Types.this.Type,Types.this.Symbol],(Types.this.Symbol, Types.this.Type),scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]])scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#517029" title="(Types.this.Type, Types.this.Symbol)">_</a>.<a href="../../Tuple2.scala.html#61512" title="=&gt; (Types.this.Symbol, Types.this.Type)">swap</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Types.this.TypeMap" id="516914">varToParam</a> = <a href="#517068" title="Types.this.TypeMap" class="keyword">new</a> <a href="#441429" title="anonymous class $anon extends Types.this.TypeMap" id="517068">TypeMap</a> <span class="delimiter">{</span>
            <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="517070">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="517071">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#516912" title="Map[Types.this.Type,Types.this.Symbol]">varToParamMap</a> <a href="../../collection/MapLike.scala.html#78410" title="(key: Types.this.Type)Option[Types.this.Symbol]">get</a> <a href="#517071" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> Some<a href="#517089" title="Types.this.Type" id="517090" class="delimiter">(</a>sym<span class="delimiter">)</span> =&gt; sym.<a href="#517091" title="(x: Types.this.Type)Types.this.Type">tpe</a>
              <span class="keyword">case</span> _ =&gt; <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#517091" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#517071" title="Types.this.Type">tp</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span class="keyword">val</span> <a title="Types.this.TypeMap" id="516915">paramToVar</a> = <a href="#517110" title="Types.this.TypeMap" class="keyword">new</a> <a href="#441429" title="anonymous class $anon extends Types.this.TypeMap" id="517110">TypeMap</a> <span class="delimiter">{</span>
            <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="517112">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="517113">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#517113" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> TypeRef<a href="#517156" title="Types.this.Type" id="517160" class="delimiter">(</a>_, tsym, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#516913" title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]">paramToVarMap</a>.<a href="../../collection/MapLike.scala.html#78422" title="(key: Types.this.Symbol)Boolean">isDefinedAt</a><span class="delimiter">(</span>tsym<span class="delimiter">)</span> =&gt; <a href="../../collection/MapLike.scala.html#78420" title="(key: Types.this.Symbol)Types.this.Type">paramToVarMap</a><a href="#517161" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>tsym<span class="delimiter">)</span>
              <span class="keyword">case</span> _ =&gt; <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#517161" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#517113" title="Types.this.Type">tp</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="516916">bts</a> = <a href="#441370" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#516890" title="Types.this.CompoundType">tpe</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.RefinedType" class="delimiter">[</span><a href="#447291" title="Types.this.RefinedType">RefinedType</a><span class="delimiter">]</span>, <a href="#516890" title="Types.this.CompoundType">tpe</a>.<a href="#441995" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#516914" title="Types.this.TypeMap">varToParam</a>, <a href="#516914" title="Types.this.TypeMap">varToParam</a> <a href="#460844" title="(scope: Types.this.Scope)Types.this.Scope">mapOver</a> <a href="#516890" title="Types.this.CompoundType">tpe</a>.<a href="#442019" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span>.<a href="#442066" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
          <a href="#516890" title="Types.this.CompoundType">tpe</a>.<a href="#447254" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="#516916" title="Types.this.BaseTypeSeq">bts</a> <a href="BaseTypeSeqs.scala.html#447209" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">lateMap</a> <a href="#516915" title="Types.this.TypeMap">paramToVar</a>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <a href="util/StatBase.scala.html#441044" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441064" title="=&gt; scala.reflect.internal.util.Statistics.Counter">compoundBaseTypeSeqCount</a><span class="delimiter">)</span>
          <a href="#516890" title="Types.this.CompoundType">tpe</a>.<a href="#447254" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="BaseTypeSeqs.scala.html#441720" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a>
          <a href="#516890" title="Types.this.CompoundType">tpe</a>.<a href="#447254" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <span title="Types.this.BaseTypeSeq" class="keyword">if</span> <span class="delimiter">(</span><a href="#516890" title="Types.this.CompoundType">tpe</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443248" title="=&gt; Boolean">isRefinementClass</a><span class="delimiter">)</span>
            <a href="#516890" title="Types.this.CompoundType">tpe</a>.<a href="#447268" title="(op1: =&gt; Types.this.BaseTypeSeq)(op2: Types.this.Type =&gt; Types.this.BaseTypeSeq)Types.this.BaseTypeSeq">memo</a><span class="delimiter">(</span><a href="BaseTypeSeqs.scala.html#441723" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">compoundBaseTypeSeq</a><span class="delimiter">(</span><a href="#516890" title="Types.this.CompoundType">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#517347" title="Types.this.Type">_</a>.<a href="#442066" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#447207" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">updateHead</a> <a href="#516890" title="Types.this.CompoundType">tpe</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
          <span class="keyword">else</span>
            <a href="BaseTypeSeqs.scala.html#441723" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">compoundBaseTypeSeq</a><span class="delimiter">(</span><a href="#516890" title="Types.this.CompoundType">tpe</a><span class="delimiter">)</span>
          // [Martin] suppressing memo-ization solves the problem with &quot;same type after erasure&quot; errors
          // when compiling with
          // scalac scala.collection.IterableViewLike.scala scala.collection.IterableLike.scala
          // I have not yet figured out precisely why this is the case.
          // My current assumption is that taking memos forces baseTypeSeqs to be computed
          // at stale types (i.e. the underlying typeSymbol has already another type).
          // I do not yet see precisely why this would cause a problem, but it looks
          // fishy in any case.
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    //Console.println(&quot;baseTypeSeq(&quot; + typeSymbol + &quot;) = &quot; + baseTypeSeqCache.toList);//DEBUG
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#516890" title="Types.this.CompoundType">tpe</a>.<a href="#447254" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="BaseTypeSeqs.scala.html#441720" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <a href="#448884" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#441578" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic inheritance involving &quot;)" class="string">&quot;illegal cyclic inheritance involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#516890" title="Types.this.CompoundType">tpe</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tpe: Types.this.CompoundType)Unit" id="441279">defineBaseClassesOfCompoundType</a><span class="delimiter">(</span><a title="Types.this.CompoundType" id="517369">tpe</a>: <a href="#441277" title="Types.this.CompoundType">CompoundType</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="517372">computeBaseClasses</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#517369" title="Types.this.CompoundType">tpe</a>.<a href="#441995" title="=&gt; List[Types.this.Type]">parents</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</a><span class="delimiter">(</span><a href="#517369" title="Types.this.CompoundType">tpe</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        //Console.println(&quot;computing base classes of &quot; + typeSymbol + &quot; at phase &quot; + phase);//DEBUG
        // optimized, since this seems to be performance critical
        <span class="keyword">val</span> <a title="Types.this.Type" id="517382">superclazz</a> = <a href="#517369" title="Types.this.CompoundType">tpe</a>.<a href="#441996" title="=&gt; Types.this.Type">firstParent</a>
        <span class="keyword">var</span> <a title="List[Types.this.Type]" id="517383">mixins</a> = <a href="#517369" title="Types.this.CompoundType">tpe</a>.<a href="#441995" title="=&gt; List[Types.this.Type]">parents</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Type]">tail</a>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="517384">sbcs</a> = <a href="#517382" title="Types.this.Type">superclazz</a>.<a href="#442068" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
        <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="517385">bcs</a> = <a href="#517384" title="List[Types.this.Symbol]">sbcs</a>
        <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Boolean" id="517386">isNew</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="517389">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> =
          <a href="#517382" title="Types.this.Type">superclazz</a>.<a href="#442069" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#517389" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <a href="../../Int.scala.html#57905" title="(x: Int)Boolean">&lt;</a> <span title="Int(0)" class="int">0</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
          <span class="delimiter">{</span> <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="517394">p</a> = <a href="#517385" title="List[Types.this.Symbol]">bcs</a>;
            <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#517394" title="List[Types.this.Symbol]">p</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#517384" title="List[Types.this.Symbol]">sbcs</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#517394" title="List[Types.this.Symbol]">p</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#517389" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#517394" title="List[Types.this.Symbol]">p</a> = <a href="#517394" title="List[Types.this.Symbol]">p</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Symbol]">tail</a>;
            <a href="#517394" title="List[Types.this.Symbol]">p</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#517384" title="List[Types.this.Symbol]">sbcs</a>
          <span class="delimiter">}</span>
        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#517383" title="List[Types.this.Type]">mixins</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#517387" title="()Unit" class="delimiter">{</a>
          <span class="keyword">def</span> <a title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]" id="517404">addMixinBaseClasses</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="517405">mbcs</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
            <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#517405" title="List[Types.this.Symbol]">mbcs</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#517385" title="List[Types.this.Symbol]">bcs</a>
            <span class="keyword">else</span> <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#517386" title="(clazz: Types.this.Symbol)Boolean">isNew</a><span class="delimiter">(</span><a href="#517405" title="List[Types.this.Symbol]">mbcs</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#517405" title="List[Types.this.Symbol]">mbcs</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#517404" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#517405" title="List[Types.this.Symbol]">mbcs</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Symbol]">tail</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#517404" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#517405" title="List[Types.this.Symbol]">mbcs</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Symbol]">tail</a><span class="delimiter">)</span>
          <a href="#517385" title="List[Types.this.Symbol]">bcs</a> = <a href="#517404" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#517383" title="List[Types.this.Type]">mixins</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a>.<a href="#442068" title="=&gt; List[Types.this.Symbol]">baseClasses</a><span class="delimiter">)</span>
          <a href="#517383" title="List[Types.this.Type]">mixins</a> = <a href="#517383" title="List[Types.this.Type]">mixins</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Type]">tail</a>
        <span class="delimiter">}</span>
        <a href="#517369" title="Types.this.CompoundType">tpe</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#517385" title="List[Types.this.Symbol]">bcs</a>
      <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="Int" id="517373">period</a> = <a href="#517369" title="Types.this.CompoundType">tpe</a>.<a href="#447263" title="=&gt; Int">baseClassesPeriod</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#517373" title="Int">period</a> <a href="../../Int.scala.html#57898" title="(x: Int)Boolean">!=</a> <a href="SymbolTable.scala.html#440602" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#517369" title="Types.this.CompoundType">tpe</a>.<a href="#447263" title="(x$1: Int)Unit">baseClassesPeriod</a> = <a href="SymbolTable.scala.html#440602" title="=&gt; Types.this.Period">currentPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#440625" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#517373" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#517369" title="Types.this.CompoundType">tpe</a>.<a href="#447260" title="(x$1: List[Types.this.Symbol])Unit">baseClassesCache</a> = <span title="Null(null)" class="keyword">null</span>
        <a href="#517369" title="Types.this.CompoundType">tpe</a>.<a href="#447260" title="(x$1: List[Types.this.Symbol])Unit">baseClassesCache</a> = <a href="#517369" title="Types.this.CompoundType">tpe</a>.<a href="#447268" title="(op1: =&gt; List[Types.this.Symbol])(op2: Types.this.Type =&gt; List[Types.this.Symbol])List[Types.this.Symbol]">memo</a><span class="delimiter">(</span><a href="#517372" title="=&gt; List[Types.this.Symbol]">computeBaseClasses</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#517369" title="Types.this.CompoundType">tpe</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#517429" title="Types.this.Type">_</a>.<a href="#442068" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Symbol]">tail</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#517369" title="Types.this.CompoundType">tpe</a>.<a href="#447260" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <a href="#448884" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#441578" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic reference involving &quot;)" class="string">&quot;illegal cyclic reference involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#517369" title="Types.this.CompoundType">tpe</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** A class representing intersection types with refinements of the form
   *    `&lt;parents_0&gt; with ... with &lt;parents_n&gt; { decls }`
   *  Cannot be created directly;
   *  one should always use `refinedType` for creation.
   */
  case <span class="keyword">class</span> <a title="class RefinedType extends Types.this.CompoundType with Product with Serializable" id="447291">RefinedType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Type]" id="469850">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>,
                         <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Scope" id="469851">decls</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441277" title="Types.this.CompoundType">CompoundType</a> <span class="delimiter">{</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="447283">isHigherKinded</a> = <span class="delimiter">(</span>
      <a href="#469850" title="=&gt; List[Types.this.Type]">parents</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
      <span class="delimiter">(</span><a href="#469850" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a href="#517530" title="Types.this.Type">_</a>.<a href="#441972" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
      <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a>
    <span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="447284">typeParams</a> =
      <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#447283" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#441996" title="=&gt; Types.this.Type">firstParent</a>.<a href="#442011" title="=&gt; List[Types.this.Symbol]">typeParams</a>
      <span class="keyword">else</span> <a href="#447291" title="Types.this.RefinedType" class="keyword">super</a>.<a href="#442011" title="=&gt; List[Types.this.Symbol]">typeParams</a>

    //@M may result in an invalid type (references to higher-order args become dangling )
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="447285">typeConstructor</a> =
      <a href="#441370" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#447291" title="Types.this.RefinedType" class="keyword">this</a>, <a href="#469850" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#517555" title="Types.this.Type">_</a>.<a href="#441999" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>, <a href="#469851" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span>

    /* MO to AM: This is probably not correct
     * If they are several higher-kinded parents with different bounds we need
     * to take the intersection of their bounds
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="447286">normalize</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#447283" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#441385" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span>
          <a href="#447284" title="=&gt; List[Types.this.Symbol]">typeParams</a>,
          <a href="#447250" title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span>
            <a href="#469850" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a title="anonymous class $anonfun extends scala.runtime.AbstractFunction1[Types.this.Type,Types.this.Type] with Serializable" id="517610" class="delimiter">{</a>
              <span class="keyword">case</span> TypeRef<a href="#517631" title="Types.this.Type" id="517634" class="delimiter">(</a>pre, sym, <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="517642">List</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#448096" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><a href="#517638" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>pre, sym, <a href="#442001" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>
              <span class="keyword">case</span> p =&gt; <a href="#517638" title="(x: Types.this.Type)Types.this.Type">p</a>
            <span class="delimiter">}</span>,
            <a href="#469851" title="=&gt; Types.this.Scope">decls</a>,
            <a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#447291" title="Types.this.RefinedType" class="keyword">super</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a>
    <span class="delimiter">}</span>

    /** A refined type P1 with ... with Pn { decls } is volatile if
     *  one of the parent types Pi is an abstract type, and
     *  either i &gt; 1, or decls or a following parent Pj, j &gt; 1, contributes
     *  an abstract member.
     *  A type contributes an abstract member if it has an abstract member which
     *  is also a member of the whole refined type. A scope `decls` contributes
     *  an abstract member if it has an abstract definition which is also
     *  a member of the whole type.
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="447287">isVolatile</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(m: Types.this.Symbol)Boolean" id="517688">isVisible</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="517690">m</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
        <a href="#447291" title="RefinedType.this.type" class="keyword">this</a>.<a href="#442029" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#517690" title="Types.this.Symbol">m</a>.<a href="Symbols.scala.html#443152" title="=&gt; m.NameType">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#443472" title="=&gt; List[Types.this.Symbol]">alternatives</a> <a href="../../collection/SeqLike.scala.html#59768" title="(elem: Any)Boolean">contains</a> <a href="#517690" title="Types.this.Symbol">m</a>
      <span class="keyword">def</span> <a title="(p: Types.this.Type)Boolean" id="517689">contributesAbstractMembers</a><span class="delimiter">(</span><a title="Types.this.Type" id="517693">p</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
        <a href="#517693" title="Types.this.Type">p</a>.<a href="#442027" title="=&gt; List[Types.this.Symbol]">deferredMembers</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a> <a href="#517688" title="(m: Types.this.Symbol)Boolean">isVisible</a>

      <span class="delimiter">(</span><span class="delimiter">(</span><a href="#469850" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#517709" title="Types.this.Type">_</a>.<a href="#441974" title="=&gt; Boolean">isVolatile</a><span class="delimiter">)</span><span class="delimiter">)</span>
       <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
       <span class="delimiter">(</span><a href="#469850" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/immutable/List.scala.html#63672" title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">dropWhile</a> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a> <a href="#517714" title="Types.this.Type">_</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443233" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
         <span class="keyword">case</span> ps @ <span class="delimiter">(</span>_ <a href="#517737" title="Boolean" id="517739">::</a> ps1<span class="delimiter">)</span> =&gt;
           <span class="delimiter">(</span>ps <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#469850" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
           <span class="delimiter">(</span>ps1 <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#517689" title="(p: Types.this.Type)Boolean">contributesAbstractMembers</a><span class="delimiter">)</span> <a href="#517740" title="(x: Boolean)Boolean">||</a>
           <span class="delimiter">(</span><a href="#469851" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#447346" title="=&gt; Iterator[Types.this.Symbol]">iterator</a> <a href="../../collection/Iterator.scala.html#65244" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="517735">m</a> =&gt; <a href="#517735" title="Types.this.Symbol">m</a>.<a href="HasFlags.scala.html#443608" title="=&gt; Boolean">isDeferred</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#517688" title="(m: Types.this.Symbol)Boolean">isVisible</a><span class="delimiter">(</span><a href="#517735" title="Types.this.Symbol">m</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
         <span class="keyword">case</span> _ =&gt;
           <a href="#517740" title="(x: Boolean)Boolean" class="keyword">false</a>
       <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="447288">kind</a> = <span title="String(&quot;RefinedType&quot;)" class="string">&quot;RefinedType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class RefinedType0 extends Types.this.RefinedType" id="441283">RefinedType0</a><a href="#441283" title="Types.this.RefinedType0" class="delimiter">(</a><a title="List[Types.this.Type]" id="517805">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="517806">decls</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="517807">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#447291" title="Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#517805" title="List[Types.this.Type]">parents</a>, <a href="#517806" title="Types.this.Scope">decls</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="517800">typeSymbol</a> = <a href="#517807" title="Types.this.Symbol">clazz</a>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Types.this.RefinedType.type" id="517812">RefinedType</a> <a href="#441282" title="Types.this.RefinedType.type" class="keyword">extends</a> <a href="../api/Types.scala.html#23508" title="Types.this.RefinedTypeExtractor">RefinedTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType" id="447250">apply</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="469836">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="469837">decls</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="469838">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#447291" title="Types.this.RefinedType">RefinedType</a> =
      <span title="Types.this.RefinedType0" class="keyword">new</span> <a href="#441283" title="Types.this.RefinedType0">RefinedType0</a><span class="delimiter">(</span><a href="#469836" title="List[Types.this.Type]">parents</a>, <a href="#469837" title="Types.this.Scope">decls</a>, <a href="#469838" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Overridden in reflection compiler */
  <span class="keyword">def</span> <a title="(tp: Types.this.ClassInfoType)Unit" id="441284">validateClassInfo</a><span class="delimiter">(</span><a title="Types.this.ClassInfoType" id="517813">tp</a>: <a href="#454759" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>

  /** A class representing a class info
   */
  case <span class="keyword">class</span> <a title="class ClassInfoType extends Types.this.CompoundType with Product with Serializable" id="454759">ClassInfoType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Type]" id="453519">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>,
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Scope" id="453520">decls</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a>,
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Symbol" id="453521">typeSymbol</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441277" title="Types.this.CompoundType">CompoundType</a>
  <span class="delimiter">{</span>
    <a href="#441284" title="(tp: Types.this.ClassInfoType)Unit">validateClassInfo</a><span class="delimiter">(</span><a href="#454759" title="Types.this.ClassInfoType" class="keyword">this</a><span class="delimiter">)</span>

    /** refs indices */
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(0)" id="453488">NonExpansive</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(1)" id="453490">Expansive</a> = <span title="Int(1)" class="int">1</span>

    /** initialization states */
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(0)" id="453492">UnInitialized</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(1)" id="453494">Initializing</a> = <span title="Int(1)" class="int">1</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(2)" id="453496">Initialized</a> = <span title="Int(2)" class="int">2</span>

    <span class="keyword">private</span> <span class="keyword">type</span> <a title="Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]" id="453498">RefMap</a> = <a href="../../collection/immutable/Map.scala.html#11605" title="Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">Map</a><span class="delimiter">[</span>Symbol, immutable.Set<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span>

    /** All type parameters reachable from given type parameter
     *  by a path which contains at least one expansive reference.
     *  @See Kennedy, Pierce: On Decidability of Nominal Subtyping with Variance
     */
    <span class="keyword">private</span><span class="delimiter">[</span>scala<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Set[Types.this.Symbol]" id="453499">expansiveRefs</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="517821">tparam</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#453504" title="=&gt; Int">state</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(0)">UnInitialized</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#453512" title="()Unit">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#453504" title="=&gt; Int">state</a> <a href="../../Int.scala.html#57898" title="(x: Int)Boolean">!=</a> <span title="Int(2)">Initialized</span><span class="delimiter">)</span> <a href="#453513" title="()Boolean">propagate</a><a href="#517830" title="()Unit" class="delimiter">(</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#453506" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#517821" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /* The rest of this class is auxiliary code for `expansiveRefs`
     */

    /** The type parameters which are referenced type parameters of this class.
     *  Two entries: refs(0): Non-expansive references
     *               refs(1): Expansive references
     *  Syncnote: This var need not be protected with synchronized, because
     *  it is accessed only from expansiveRefs, which is called only from
     *  Typer.
     */
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Array[ClassInfoType.this.RefMap]" id="453501">refs</a>: <a href="../../Array.scala.html#292" title="Array[ClassInfoType.this.RefMap]">Array</a><span class="delimiter">[</span>RefMap<span class="delimiter">]</span> = _

    /** The initialization state of the class: UnInialized --&gt; Initializing --&gt; Initialized
     *  Syncnote: This var need not be protected with synchronized, because
     *  it is accessed only from expansiveRefs, which is called only from
     *  Typer.
     */
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="453504">state</a> = <span title="Int(0)">UnInitialized</span>

    /** Get references for given type parameter
     *  @param  which in {NonExpansive, Expansive}
     *  @param  from  The type parameter from which references originate.
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]" id="453506">getRefs</a><span class="delimiter">(</span><a title="Int" id="517837">which</a>: <a href="../../Int.scala.html#508" title="Int">Int</a>, <a title="Types.this.Symbol" id="517838">from</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../collection/immutable/Set.scala.html#12289" title="Set[Types.this.Symbol]">Set</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="../../Array.scala.html#57450" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#517837" title="Int">which</a><span class="delimiter">)</span> <a href="../../collection/MapLike.scala.html#78410" title="(key: Types.this.Symbol)Option[scala.collection.immutable.Set[Types.this.Symbol]]">get</a> <a href="#517838" title="Types.this.Symbol">from</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Some<a href="#517861" title="Set[Types.this.Symbol]" id="517862" class="delimiter">(</a>set<span class="delimiter">)</span> =&gt; <a href="#517863" title="(x: Set[Types.this.Symbol])Set[Types.this.Symbol]">set</a>
      <span class="keyword">case</span> none =&gt; <a href="../../collection/generic/GenericCompanion.scala.html#60782" title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]">Set</a><a href="#517863" title="(x: Set[Types.this.Symbol])Set[Types.this.Symbol]" class="delimiter">(</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Augment existing refs map with reference &lt;pre&gt;from -&gt; to&lt;/pre&gt;
     *  @param  which &lt;- {NonExpansive, Expansive}
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit" id="453507">addRef</a><span class="delimiter">(</span><a title="Int" id="517868">which</a>: <a href="../../Int.scala.html#508" title="Int">Int</a>, <a title="Types.this.Symbol" id="517869">from</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="517870">to</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../../Array.scala.html#57451" title="(i: Int, x: ClassInfoType.this.RefMap)Unit">refs</a><span class="delimiter">(</span><a href="#517868" title="Int">which</a><span class="delimiter">)</span> = <a href="../../Array.scala.html#57450" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#517868" title="Int">which</a><span class="delimiter">)</span> <a href="../../collection/immutable/Map.scala.html#63373" title="(kv: (Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol]))scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">+</a> <span class="delimiter">(</span><a href="../../Predef.scala.html#8484" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">from</a> <a href="../../Predef.scala.html#63591" title="(y: scala.collection.immutable.Set[Types.this.Symbol])(Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])">-&gt;</a> <span class="delimiter">(</span><a href="#453506" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><a href="#517868" title="Int">which</a>, <a href="#517869" title="Types.this.Symbol">from</a><span class="delimiter">)</span> <a href="../../collection/SetLike.scala.html#71319" title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">+</a> <a href="#517870" title="Types.this.Symbol">to</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Augment existing refs map with references &lt;pre&gt;from -&gt; sym&lt;/pre&gt;, for
     *  all elements &lt;pre&gt;sym&lt;/pre&gt; of set `to`.
     *  @param  which &lt;- {NonExpansive, Expansive}
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit" id="453508">addRefs</a><span class="delimiter">(</span><a title="Int" id="517968">which</a>: <a href="../../Int.scala.html#508" title="Int">Int</a>, <a title="Types.this.Symbol" id="517969">from</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Set[Types.this.Symbol]" id="517970">to</a>: <a href="../../collection/immutable/Set.scala.html#12289" title="Set[Types.this.Symbol]">Set</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../../Array.scala.html#57451" title="(i: Int, x: ClassInfoType.this.RefMap)Unit">refs</a><span class="delimiter">(</span><a href="#517968" title="Int">which</a><span class="delimiter">)</span> = <a href="../../Array.scala.html#57450" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#517968" title="Int">which</a><span class="delimiter">)</span> <a href="../../collection/immutable/Map.scala.html#63373" title="(kv: (Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol]))scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">+</a> <span class="delimiter">(</span><a href="../../Predef.scala.html#8484" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">from</a> <a href="../../Predef.scala.html#63591" title="(y: scala.collection.immutable.Set[Types.this.Symbol])(Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])">-&gt;</a> <span class="delimiter">(</span><a href="#453506" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><a href="#517968" title="Int">which</a>, <a href="#517969" title="Types.this.Symbol">from</a><span class="delimiter">)</span> <a href="../../collection/SetLike.scala.html#71321" title="(elems: scala.collection.GenTraversableOnce[Types.this.Symbol])scala.collection.immutable.Set[Types.this.Symbol]">++</a> <a href="#517970" title="Set[Types.this.Symbol]">to</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** The ClassInfoType which belongs to the class containing given type parameter
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Types.this.ClassInfoType" id="453509">classInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="518106">tparam</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#454759" title="Types.this.ClassInfoType">ClassInfoType</a> =
      <a href="#518106" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442002" title="=&gt; Types.this.Type">resultType</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="#518112" title="Types.this.ClassInfoType" id="518114">ci</a>: ClassInfoType =&gt; <a href="#518115" title="(x: Types.this.ClassInfoType)Types.this.ClassInfoType">ci</a>
        <span class="keyword">case</span> _ =&gt; <a href="#453509" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><a href="#518115" title="(x: Types.this.ClassInfoType)Types.this.ClassInfoType" class="delimiter">(</a><a href="Definitions.scala.html#442179" title="=&gt; Types.this.ClassSymbol">ObjectClass</a><span class="delimiter">)</span> // something's wrong; fall back to safe value
                                         // (this can happen only for erroneous programs).
      <span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">object</span> <a title="ClassInfoType.this.enterRefs.type" id="453510">enterRefs</a> <a href="#453511" title="ClassInfoType.this.enterRefs.type" class="keyword">extends</a> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
      <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Symbol" id="518122">tparam</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = _

      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="518124">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="518128">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
        <a href="#518128" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> tr @ TypeRef<a href="#518175" title="Unit" id="518178" class="delimiter">(</a>_, sym, args<span class="delimiter">)</span> <span class="keyword">if</span> args.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a> =&gt;
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="518134">tparams</a> = tr.<a href="#448130" title="=&gt; List[Types.this.Symbol]">initializedTypeParams</a>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456420" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#518134" title="List[Types.this.Symbol]">tparams</a>, args<span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="SymbolTable.scala.html#440552" title="(msg: =&gt; String)Unit">debugwarn</a><span class="delimiter">(</span><span title="String(&quot;Mismatched zip in computeRefs(): &quot;)" class="string">&quot;Mismatched zip in computeRefs(): &quot;</span> <span title="(x$1: Any)String">+</span> sym.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442011" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)String">+</span> args<span class="delimiter">)</span>

            <a href="util/Collections.scala.html#440726" title="(xs1: List[Types.this.Symbol], xs2: List[Types.this.Type])(f: (Types.this.Symbol, Types.this.Type) =&gt; Unit)Unit">foreach2</a><span class="delimiter">(</span><a href="#518134" title="List[Types.this.Symbol]">tparams</a>, args<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="518166">tparam1</a>, <a title="Types.this.Type" id="518167">arg</a><span class="delimiter">)</span> =&gt;
              <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#518167" title="Types.this.Type">arg</a> <a href="#442056" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#518122" title="=&gt; Types.this.Symbol">tparam</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="#453507" title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit">addRef</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#518122" title="=&gt; Types.this.Symbol">tparam</a>, <a href="#518166" title="Types.this.Symbol">tparam1</a><span class="delimiter">)</span>
                <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#518167" title="Types.this.Type">arg</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#518122" title="=&gt; Types.this.Symbol">tparam</a><span class="delimiter">)</span>
                  <a href="#453507" title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit">addRef</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#518122" title="=&gt; Types.this.Symbol">tparam</a>, <a href="#518166" title="Types.this.Symbol">tparam1</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> _ =&gt;
        <span class="delimiter">}</span>
        <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#518128" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="(tparam0: Types.this.Symbol, parent: Types.this.Type)Unit" id="518125">enter</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="518192">tparam0</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="518193">parent</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">this</span>.<a href="#518122" title="(x$1: Types.this.Symbol)Unit">tparam</a> = <a href="#518192" title="Types.this.Symbol">tparam0</a>
        <a href="#518124" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span title="Unit" class="delimiter">(</span><a href="#518193" title="Types.this.Type">parent</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** Compute initial (one-step) references and set state to `Initializing`.
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="()Unit" id="453512">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#453501" title="(x$1: Array[ClassInfoType.this.RefMap])Unit">refs</a> = <a href="../../Array.scala.html#68728" title="(xs: ClassInfoType.this.RefMap*)(implicit evidence$2: scala.reflect.ArrayTag[ClassInfoType.this.RefMap])Array[ClassInfoType.this.RefMap]">Array</a><a href="../ClassTag.scala.html#61898" title="(erasure1: Class[_])scala.reflect.ClassTag[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" class="delimiter">(</a><a href="../../collection/generic/GenMapFactory.scala.html#61654" title="(elems: (Types.this.Symbol, Nothing)*)scala.collection.immutable.Map[Types.this.Symbol,Nothing]">Map</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="../../collection/generic/GenMapFactory.scala.html#61654" title="(elems: (Types.this.Symbol, Nothing)*)scala.collection.immutable.Map[Types.this.Symbol,Nothing]">Map</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#453521" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a> <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.Symbol =&gt; Unit)Unit">foreach</a> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="518313">tparam</a> =&gt;
        <a href="#453519" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.Type =&gt; Unit)Unit">foreach</a> <span class="delimiter">{</span> <a title="Types.this.Type" id="518333">p</a> =&gt;
          <a href="#453510" title="ClassInfoType.this.enterRefs.type">enterRefs</a>.<a href="#518125" title="(tparam0: Types.this.Symbol, parent: Types.this.Type)Unit">enter</a><span class="delimiter">(</span><a href="#518313" title="Types.this.Symbol">tparam</a>, <a href="#518333" title="Types.this.Type">p</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#453504" title="(x$1: Int)Unit">state</a> = <span title="Int(1)">Initializing</span>
    <span class="delimiter">}</span>

    /** Propagate to form transitive closure.
     *  Set state to Initialized if no change resulted from propagation.
     *  @return   true iff there as a change in last iteration
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="()Boolean" id="453513">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#453504" title="=&gt; Int">state</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(0)">UnInitialized</span><span class="delimiter">)</span> <a href="#453512" title="()Unit">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span>
      //Console.println(&quot;Propagate &quot;+symbol+&quot;, initial expansive = &quot;+refs(Expansive)+&quot;, nonexpansive = &quot;+refs(NonExpansive))//DEBUG
      <span class="keyword">val</span> <a title="Array[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" id="518336">lastRefs</a> = <a href="../../Array.scala.html#68728" title="(xs: ClassInfoType.this.RefMap*)(implicit evidence$2: scala.reflect.ArrayTag[ClassInfoType.this.RefMap])Array[ClassInfoType.this.RefMap]">Array</a><a href="../ClassTag.scala.html#61898" title="(erasure1: Class[_])scala.reflect.ClassTag[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" class="delimiter">(</a><a href="../../Array.scala.html#57450" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>, <a href="../../Array.scala.html#57450" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#453504" title="(x$1: Int)Unit">state</a> = <span title="Int(2)">Initialized</span>
      <span class="keyword">var</span> <a title="Boolean" id="518337">change</a> = <span title="Boolean(false)" class="keyword">false</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span>from, targets<span class="delimiter">)</span> &lt;- <a href="../../Array.scala.html#57450" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span><span class="delimiter">)</span>.<a href="../../collection/Iterator.scala.html#65240" title="(f: ((Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])) =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="518468">target</a> &lt;- <a href="../../collection/IterableLike.scala.html#59458" title="(f: Types.this.Symbol =&gt; Unit)Unit">targets</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">var</span> <a title="Types.this.ClassInfoType" id="518469">thatInfo</a> = <a href="#453509" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><a href="#518468" title="Types.this.Symbol">target</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#518469" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#453504" title="=&gt; Int">state</a> <a href="../../Int.scala.html#57898" title="(x: Int)Boolean">!=</a> <span title="Int(2)">Initialized</span><span class="delimiter">)</span>
            <a href="#518337" title="Boolean">change</a> = <a href="#518337" title="Boolean">change</a> <a href="../../Boolean.scala.html#58726" title="(x: Boolean)Boolean">|</a> <a href="#518469" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#453513" title="()Boolean">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#453508" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, from, <a href="#518469" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#453506" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#518468" title="Types.this.Symbol">target</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#453508" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, from, <a href="#518469" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#453506" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#518468" title="Types.this.Symbol">target</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span>from, targets<span class="delimiter">)</span> &lt;- <a href="../../Array.scala.html#57450" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span><span class="delimiter">)</span>.<a href="../../collection/Iterator.scala.html#65240" title="(f: ((Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])) =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="518527">target</a> &lt;- <a href="../../collection/IterableLike.scala.html#59458" title="(f: Types.this.Symbol =&gt; Unit)Unit">targets</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">var</span> <a title="Types.this.ClassInfoType" id="518528">thatInfo</a> = <a href="#453509" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><a href="#518527" title="Types.this.Symbol">target</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#518528" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#453504" title="=&gt; Int">state</a> <a href="../../Int.scala.html#57898" title="(x: Int)Boolean">!=</a> <span title="Int(2)">Initialized</span><span class="delimiter">)</span>
            <a href="#518337" title="Boolean">change</a> = <a href="#518337" title="Boolean">change</a> <a href="../../Boolean.scala.html#58726" title="(x: Boolean)Boolean">|</a> <a href="#518528" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#453513" title="()Boolean">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#453508" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, from, <a href="#518528" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#453506" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#518527" title="Types.this.Symbol">target</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <a href="#518337" title="Boolean">change</a> = <a href="#518337" title="Boolean">change</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="../../Array.scala.html#57450" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="../../Array.scala.html#57450" title="(i: Int)scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">lastRefs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="../../Array.scala.html#57450" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="../../Array.scala.html#57450" title="(i: Int)scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">lastRefs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#518337" title="Boolean">change</a><span class="delimiter">)</span> <a href="#453504" title="(x$1: Int)Unit">state</a> = <span title="Int(1)">Initializing</span>
      //else Console.println(&quot;Propagate &quot;+symbol+&quot;, final expansive = &quot;+refs(Expansive)+&quot;, nonexpansive = &quot;+refs(NonExpansive))//DEBUG
      <a href="#518337" title="Boolean">change</a>
    <span class="delimiter">}</span>

    // override def isNullable: Boolean =
    // symbol == AnyClass ||
    // symbol != NothingClass &amp;&amp; (symbol isSubClass ObjectClass) &amp;&amp; !(symbol isSubClass NonNullClass);

    // override def isNonNull: Boolean = symbol == NonNullClass || super.isNonNull;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="453514">kind</a> = <span title="String(&quot;ClassInfoType&quot;)" class="string">&quot;ClassInfoType&quot;</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="453515">safeToString</a> =
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456420" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#453520" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#447328" title="=&gt; Int">size</a> <a href="../../Int.scala.html#57919" title="(x: Int)Boolean">&gt;</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
        <a href="#453516" title="=&gt; String">formattedToString</a>
      <span class="keyword">else</span>
        <a href="#454759" title="Types.this.ClassInfoType" class="keyword">super</a>.<a href="#447275" title="=&gt; String">safeToString</a>

    /** A nicely formatted string with newlines and such.
     */
    <span class="keyword">def</span> <a title="=&gt; String" id="453516">formattedToString</a>: <span title="String">String</span> =
      <a href="#453519" title="=&gt; List[Types.this.Type]">parents</a>.<a href="../../collection/TraversableOnce.scala.html#59190" title="(sep: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;\n        with &quot;)" class="string">&quot;\n        with &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span>
      <span class="delimiter">(</span><span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456420" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#453519" title="=&gt; List[Types.this.Type]">parents</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#453520" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#447308" title="=&gt; Types.this.ScopeEntry">elems</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#453520" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#447351" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot; {\n  &quot;)" class="string">&quot; {\n  &quot;</span>, <span title="String(&quot;\n  &quot;)" class="string">&quot;\n  &quot;</span>, <span title="String(&quot;\n}&quot;)" class="string">&quot;\n}&quot;</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Types.this.ClassInfoType.type" id="518632">ClassInfoType</a> <a href="#441287" title="Types.this.ClassInfoType.type" class="keyword">extends</a> <a href="../api/Types.scala.html#23525" title="Types.this.ClassInfoTypeExtractor">ClassInfoTypeExtractor</a>

  <span class="keyword">class</span> <a title="class PackageClassInfoType extends Types.this.ClassInfoType" id="441288">PackageClassInfoType</a><a href="#441288" title="Types.this.PackageClassInfoType" class="delimiter">(</a><a title="Types.this.Scope" id="518641">decls</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="518642">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="#454759" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">(</span>List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>, <a href="#518641" title="Types.this.Scope">decls</a>, <a href="#518642" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>

  /** A class representing a constant type.
   *
   *  @param value ...
   */
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#518678" title="class ConstantType extends Types.this.SingletonType with Product with Serializable" id="460823">ConstantType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><a title="Types.this.Constant" id="460829">value</a>: <a href="Constants.scala.html#441712" title="Types.this.Constant">Constant</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441248" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="460816">underlying</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#460829" title="=&gt; Types.this.Constant">value</a>.<a href="Constants.scala.html#443090" title="=&gt; Types.this.Type">tpe</a>
    <a href="../../Predef.scala.html#8459" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span><a href="#460816" title="=&gt; Types.this.Type">underlying</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#442841" title="=&gt; Types.this.ClassSymbol">UnitClass</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="460817">isTrivial</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="460818">isNotNull</a> = <a href="#460829" title="=&gt; Types.this.Constant">value</a>.<a href="Constants.scala.html#443076" title="=&gt; Any">value</a> <span title="(x$1: Any)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="460819">deconst</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#460816" title="=&gt; Types.this.Type">underlying</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="460820">safeToString</a>: <span title="String">String</span> =
      <a href="#460816" title="=&gt; Types.this.Type">underlying</a>.<a href="#442076" title="()String">toString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#460829" title="=&gt; Types.this.Constant">value</a>.<a href="Constants.scala.html#443104" title="=&gt; String">escapedStringValue</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
    // override def isNullable: Boolean = value.value eq null
    // override def isNonNull: Boolean = value.value ne null
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="460821">kind</a> = <span title="String(&quot;ConstantType&quot;)" class="string">&quot;ConstantType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueConstantType extends Types.this.ConstantType with Types.this.UniqueType" id="441292">UniqueConstantType</a><a href="#441292" title="Types.this.UniqueConstantType" class="delimiter">(</a><a title="Types.this.Constant" id="518716">value</a>: <a href="Constants.scala.html#441712" title="Types.this.Constant">Constant</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#460823" title="Types.this.ConstantType">ConstantType</a><span class="delimiter">(</span><a href="#518716" title="Types.this.Constant">value</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441243" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span>
    /** Save the type of `value`. For Java enums, it depends on finding the linked class,
     *  which might not be found after `flatten`. */
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.Type" id="518712">_tpe</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#518716" title="Types.this.Constant">value</a>.<a href="Constants.scala.html#443090" title="=&gt; Types.this.Type">tpe</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="518713">underlying</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#518711" title="=&gt; Types.this.Type">_tpe</a>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Types.this.ConstantType.type" id="519033">ConstantType</a> <a href="#441291" title="Types.this.ConstantType.type" class="keyword">extends</a> <a href="../api/Types.scala.html#23504" title="Types.this.ConstantTypeExtractor">ConstantTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(value: Types.this.Constant)Types.this.ConstantType" id="460802">apply</a><span class="delimiter">(</span><a title="Types.this.Constant" id="469671">value</a>: <a href="Constants.scala.html#441712" title="Types.this.Constant">Constant</a><span class="delimiter">)</span>: <a href="#460823" title="Types.this.ConstantType">ConstantType</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.UniqueConstantType" id="518720">tpe</a> = <span title="Types.this.UniqueConstantType" class="keyword">new</span> <a href="#441292" title="Types.this.UniqueConstantType">UniqueConstantType</a><span class="delimiter">(</span><a href="#469671" title="Types.this.Constant">value</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#469671" title="Types.this.Constant">value</a>.<a href="Constants.scala.html#443079" title="=&gt; Int">tag</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(12)">ClazzTag</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        // if we carry a classOf, we might be in trouble
        // http://groups.google.com/group/scala-internals/browse_thread/thread/45185b341aeb6a30
        // I don't have time for a thorough fix, so I put a hacky workaround here
        <span class="keyword">val</span> <a title="Types.this.Type" id="518725">alreadyThere</a> = <a href="#441403" title="=&gt; scala.reflect.internal.util.HashSet[Types.this.Type]">uniques</a> <a href="util/HashSet.scala.html#514482" title="(x: Types.this.Type)Types.this.Type">findEntry</a> <a href="#518720" title="Types.this.UniqueConstantType">tpe</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#518725" title="Types.this.Type">alreadyThere</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#518725" title="Types.this.Type">alreadyThere</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#518720" title="Types.this.UniqueConstantType">tpe</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#518725" title="Types.this.Type">alreadyThere</a>.<a href="#442076" title="()String">toString</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#518720" title="Types.this.UniqueConstantType">tpe</a>.<a href="#442076" title="()String">toString</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          // we need to remove a stale type that has the same hashcode as we do
          // HashSet doesn't support removal, and this makes our task non-trivial
          // also we cannot simply recreate it, because that'd skew hashcodes (that change over time, omg!)
          // the only solution I can see is getting into the underlying array and sneakily manipulating it
          <span class="keyword">val</span> <a title="java.lang.reflect.Field" id="518738">ftable</a> = <a href="#441403" title="=&gt; scala.reflect.internal.util.HashSet[Types.this.Type]">uniques</a>.<span title="()Class[_]">getClass</span>.<span title="()Array[java.lang.reflect.Field]">getDeclaredFields</span><a href="../../Predef.scala.html#8521" title="(xs: Array[java.lang.reflect.Field])scala.collection.mutable.ArrayOps[java.lang.reflect.Field]" class="delimiter">(</a><span class="delimiter">)</span>.<a href="../../collection/IndexedSeqOptimized.scala.html#60084" title="(p: java.lang.reflect.Field =&gt; Boolean)Option[java.lang.reflect.Field]">find</a><span class="delimiter">(</span><a title="java.lang.reflect.Field" id="519006">f</a> =&gt; <a href="#519006" title="java.lang.reflect.Field">f</a>.<span title="()String">getName</span> <span title="(x$1: String)Boolean">endsWith</span> <span title="String(&quot;table&quot;)" class="string">&quot;table&quot;</span><span class="delimiter">)</span>.<a href="../../Option.scala.html#63813" title="=&gt; java.lang.reflect.Field">get</a>
          <a href="#518738" title="java.lang.reflect.Field">ftable</a>.<span title="(x$1: Boolean)Unit">setAccessible</span><span class="delimiter">(</span><span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Array[AnyRef]" id="518739">table</a> = <a href="#518738" title="java.lang.reflect.Field">ftable</a>.<span title="(x$1: Any)Object">get</span><span class="delimiter">(</span><a href="#441403" title="=&gt; scala.reflect.internal.util.HashSet[Types.this.Type]">uniques</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Array[AnyRef]" class="delimiter">[</span><a href="../../Array.scala.html#292" title="Array[AnyRef]">Array</a><span class="delimiter">[</span>AnyRef<span class="delimiter">]</span><span class="delimiter">]</span>
          <span class="keyword">def</span> <a title="(hc: Int, x: Types.this.Type)Unit" id="518740">overwrite</a><span class="delimiter">(</span><a title="Int" id="519007">hc</a>: <a href="../../Int.scala.html#508" title="Int">Int</a>, <a title="Types.this.Type" id="519008">x</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">def</span> <a title="(x: Int)Int" id="519009">index</a><span class="delimiter">(</span><a title="Int" id="519012">x</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Int.scala.html#508" title="Int">Int</a> = math.<a href="../../math/package.scala.html#56924" title="(x: Int)Int">abs</a><span class="delimiter">(</span><a href="#519012" title="Int">x</a> <a href="../../Int.scala.html#57976" title="(x: Int)Int">%</a> <a href="#518739" title="Array[AnyRef]">table</a>.<a href="../../Array.scala.html#57449" title="=&gt; Int">length</a><span class="delimiter">)</span>
            <span class="keyword">var</span> <a title="Int" id="519010">h</a> = <a href="#519009" title="(x: Int)Int">index</a><span class="delimiter">(</span><a href="#519007" title="Int">hc</a><span class="delimiter">)</span>
            <span class="keyword">var</span> <a title="AnyRef" id="519011">entry</a> = <a href="../../Array.scala.html#57450" title="(i: Int)AnyRef">table</a><span class="delimiter">(</span><a href="#519010" title="Int">h</a><span class="delimiter">)</span>
            <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#519011" title="AnyRef">entry</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#519019" title="()Unit" class="delimiter">{</a>
              <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#519008" title="Types.this.Type">x</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#519011" title="AnyRef">entry</a><span class="delimiter">)</span>
                <a href="../../Array.scala.html#57451" title="(i: Int, x: AnyRef)Unit">table</a><span class="delimiter">(</span><a href="#519010" title="Int">h</a><span class="delimiter">)</span> = <a href="#519008" title="Types.this.Type">x</a>
              <a href="#519010" title="Int">h</a> = <a href="#519009" title="(x: Int)Int">index</a><span class="delimiter">(</span><a href="#519010" title="Int">h</a> <a href="../../Int.scala.html#57948" title="(x: Int)Int">+</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
              <a href="#519011" title="AnyRef">entry</a> = <a href="../../Array.scala.html#57450" title="(i: Int)AnyRef">table</a><span class="delimiter">(</span><a href="#519010" title="Int">h</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <a href="#518740" title="(hc: Int, x: Types.this.Type)Unit">overwrite</a><span class="delimiter">(</span><a href="#518720" title="Types.this.UniqueConstantType">tpe</a>.<span title="()Int">##</span>, <a href="#518720" title="Types.this.UniqueConstantType">tpe</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#441408" title="(tp: Types.this.UniqueConstantType)Types.this.UniqueConstantType">unique</a><span class="delimiter">(</span><a href="#518720" title="Types.this.UniqueConstantType">tpe</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.ConstantType" class="delimiter">[</span><a href="#460823" title="Types.this.ConstantType">ConstantType</a><span class="delimiter">]</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /* Syncnote: The `volatile` var and `pendingVolatiles` mutable set need not be protected
   * with synchronized, because they are accessed only from isVolatile, which is called only from
   * Typer.
   */
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="441294">volatileRecursions</a>: <a href="../../Int.scala.html#508" title="Int">Int</a> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.Symbol]" id="441296">pendingVolatiles</a> = <a href="../../collection/mutable/HashSet.scala.html#141566" title="()scala.collection.mutable.HashSet[Types.this.Symbol]" class="keyword">new</a> mutable.<a href="../../collection/mutable/HashSet.scala.html#13456" title="scala.collection.mutable.HashSet[Types.this.Symbol]">HashSet</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

  <span class="keyword">class</span> <a title="class ArgsTypeRef extends Types.this.TypeRef with Types.this.UniqueType" id="441298">ArgsTypeRef</a><a href="#441298" title="Types.this.ArgsTypeRef" class="delimiter">(</a><a title="Types.this.Type" id="519049">pre0</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="519050">sym0</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="519051">args0</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#448160" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">(</span><a href="#519049" title="Types.this.Type">pre0</a>, <a href="#519050" title="Types.this.Symbol">sym0</a>, <a href="#519051" title="List[Types.this.Type]">args0</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441243" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#8464" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#519051" title="List[Types.this.Type]">args0</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a>, <a href="#441298" title="Types.this.ArgsTypeRef" class="keyword">this</a><span class="delimiter">)</span>

    /** No unapplied type params size it has (should have) equally as many args. */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="519041">isHigherKinded</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Nil.type" id="519042">typeParams</a> = <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="519043">transform</a><span class="delimiter">(</span><a title="Types.this.Type" id="519060">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      // This situation arises when a typevar is encountered for which
      // too little information is known to determine its kind, and
      // it later turns out not to have kind *. See SI-4070.  Only
      // logging it for now.
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<a href="../../collection/SeqLike.scala.html#59711" title="=&gt; Int">size</a> <a href="../../Int.scala.html#57898" title="(x: Int)Boolean">!=</a> <a href="#448177" title="=&gt; List[Types.this.Type]">args</a>.<a href="../../collection/SeqLike.scala.html#59711" title="=&gt; Int">size</a><span class="delimiter">)</span>
        <a href="SymbolTable.scala.html#440548" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><a href="../../Predef.scala.html#8578" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;!!! %s.transform(%s), but tparams.isEmpty and args=&quot;</a>.<a href="../../collection/immutable/StringLike.scala.html#60730" title="(args: Any*)String">format</a><span class="delimiter">(</span><a href="#441298" title="Types.this.ArgsTypeRef" class="keyword">this</a>, <a href="#519060" title="Types.this.Type">tp</a>, <a href="#448177" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <a href="#448132" title="(tp: Types.this.Type)Types.this.Type">asSeenFromOwner</a><span class="delimiter">(</span><a href="#519060" title="Types.this.Type">tp</a><span class="delimiter">)</span>.<a href="#442014" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#448177" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    // note: does not go through typeRef. There's no need to because
    // neither `pre` nor `sym` changes.  And there's a performance
    // advantage to call TypeRef directly.
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="519044">typeConstructor</a> = <a href="#448096" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#448175" title="=&gt; Types.this.Type">pre</a>, <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>, <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class ModuleTypeRef extends Types.this.NoArgsTypeRef with Types.this.ClassTypeRef" id="441299">ModuleTypeRef</a><a href="#441299" title="Types.this.ModuleTypeRef" class="delimiter">(</a><a title="Types.this.Type" id="519084">pre0</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="519085">sym0</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441302" title="Types.this.NoArgsTypeRef">NoArgsTypeRef</a><span class="delimiter">(</span><a href="#519084" title="Types.this.Type">pre0</a>, <a href="#519085" title="Types.this.Symbol">sym0</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441303" title="Types.this.ClassTypeRef">ClassTypeRef</a> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#8464" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443245" title="=&gt; Boolean">isModuleClass</a>, <a href="#448176" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">var</span> <a title="Types.this.Type" id="461287">narrowedCache</a>: <a href="#441242" title="Types.this.Type">Type</a> = _
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="461288">isStable</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="461289">narrow</a> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#461287" title="Types.this.Type">narrowedCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
        <a href="#461287" title="Types.this.Type">narrowedCache</a> = <a href="#441367" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#448175" title="=&gt; Types.this.Type">pre</a>, <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443490" title="=&gt; Types.this.Symbol">sourceModule</a><span class="delimiter">)</span>

      <a href="#461287" title="Types.this.Type">narrowedCache</a>
    <span class="delimiter">}</span>
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="461290">isNotNull</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(rest: String)String" id="461291">finishPrefix</a><span class="delimiter">(</span><a title="String" id="519115">rest</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#442072" title="=&gt; String">objectPrefix</a> <span title="(x$1: Any)String">+</span> <a href="#519115" title="String">rest</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="461292">directObjectString</a> = <a href="#441299" title="Types.this.ModuleTypeRef" class="keyword">super</a>.<a href="#448156" title="=&gt; String">safeToString</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="461293">toLongString</a> = <a href="#442076" title="()String">toString</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="461294">safeToString</a> = <a href="#461289" title="=&gt; Types.this.Type">narrow</a>.<a href="#442076" title="()String">toString</a>
  <span class="delimiter">}</span>
  <span class="keyword">class</span> <a title="class PackageTypeRef extends Types.this.ModuleTypeRef" id="441300">PackageTypeRef</a><a href="#441300" title="Types.this.PackageTypeRef" class="delimiter">(</a><a title="Types.this.Type" id="519328">pre0</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="519329">sym0</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441299" title="Types.this.ModuleTypeRef">ModuleTypeRef</a><span class="delimiter">(</span><a href="#519328" title="Types.this.Type">pre0</a>, <a href="#519329" title="Types.this.Symbol">sym0</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#8464" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a>, <a href="#448176" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(rest: String)String" id="461300">finishPrefix</a><span class="delimiter">(</span><a title="String" id="519332">rest</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#442073" title="=&gt; String">packagePrefix</a> <span title="(x$1: Any)String">+</span> <a href="#519332" title="String">rest</a>
  <span class="delimiter">}</span>
  <span class="keyword">class</span> <a title="class RefinementTypeRef extends Types.this.NoArgsTypeRef with Types.this.ClassTypeRef" id="441301">RefinementTypeRef</a><a href="#441301" title="Types.this.RefinementTypeRef" class="delimiter">(</a><a title="Types.this.Symbol" id="519342">sym0</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441302" title="Types.this.NoArgsTypeRef">NoArgsTypeRef</a><span class="delimiter">(</span><a href="#516490" title="Types.this.NoType.type">NoType</a>, <a href="#519342" title="Types.this.Symbol">sym0</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441303" title="Types.this.ClassTypeRef">ClassTypeRef</a> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#8464" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443248" title="=&gt; Boolean">isRefinementClass</a>, <a href="#448176" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

    // I think this is okay, but see #1241 (r12414), #2208, and typedTypeConstructor in Typers
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="519338">normalizeImpl</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a>
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(rest: String)String" id="519339">finishPrefix</a><span class="delimiter">(</span><a title="String" id="519352">rest</a>: <span title="String">String</span><span class="delimiter">)</span> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#448129" title="=&gt; Types.this.Type">thisInfo</a>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class NoArgsTypeRef extends Types.this.TypeRef with Types.this.UniqueType" id="441302">NoArgsTypeRef</a><a href="#441302" title="Types.this.NoArgsTypeRef" class="delimiter">(</a><a title="Types.this.Type" id="519086">pre0</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="519087">sym0</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#448160" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">(</span><a href="#519086" title="Types.this.Type">pre0</a>, <a href="#519087" title="Types.this.Symbol">sym0</a>, <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441243" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span>
    // A reference (in a Scala program) to a type that has type parameters, but where the reference
    // does not include type arguments. Note that it doesn't matter whether the symbol refers
    // to a java or scala symbol, but it does matter whether it occurs in java or scala code.
    // TypeRefs w/o type params that occur in java signatures/code are considered raw types, and are
    // represented as existential types.
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="461273">isHigherKinded</a> = <a href="#461274" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="461274">typeParams</a>     = <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#442134" title="=&gt; Boolean">isDefinitionsInitialized</a><span class="delimiter">)</span> <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span class="keyword">else</span> <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443446" title="=&gt; List[Types.this.Symbol]">unsafeTypeParams</a>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="461275">isRaw</a>           = <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441437" title="(sym: Types.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="461276">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="519368">formals</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="519369">actuals</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461273" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#519368" title="List[Types.this.Symbol]">formals</a> <a href="../../collection/SeqLike.scala.html#59780" title="(that: scala.collection.GenSeq[Types.this.Symbol])List[Types.this.Symbol]">intersect</a> <a href="#461274" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#461274" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#441372" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#441302" title="Types.this.NoArgsTypeRef" class="keyword">this</a>, <a href="#448175" title="=&gt; Types.this.Type">pre</a>, <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>, <a href="#519369" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
        // partial application (needed in infer when bunching type arguments from classes and methods together)
        <span class="keyword">else</span>
          <a href="#441372" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#441302" title="Types.this.NoArgsTypeRef" class="keyword">this</a>, <a href="#448175" title="=&gt; Types.this.Type">pre</a>, <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>, <a href="#442001" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>.<a href="#442014" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#519368" title="List[Types.this.Symbol]">formals</a>, <a href="#519369" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span>
        <a href="#441302" title="Types.this.NoArgsTypeRef" class="keyword">super</a>.<a href="#442014" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#519368" title="List[Types.this.Symbol]">formals</a>, <a href="#519369" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="461277">transform</a><span class="delimiter">(</span><a title="Types.this.Type" id="519385">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="519387">res</a> = <a href="#448132" title="(tp: Types.this.Type)Types.this.Type">asSeenFromOwner</a><span class="delimiter">(</span><a href="#519385" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461273" title="=&gt; Boolean">isHigherKinded</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#461275" title="=&gt; Boolean">isRaw</a><span class="delimiter">)</span>
        <a href="#519387" title="Types.this.Type">res</a>.<a href="#442014" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#461274" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#442001" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <a href="#519387" title="Types.this.Type">res</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="461278">transformInfo</a><span class="delimiter">(</span><a title="Types.this.Type" id="519388">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
      <a href="#441377" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#448132" title="(tp: Types.this.Type)Types.this.Type">asSeenFromOwner</a><span class="delimiter">(</span><a href="#519388" title="Types.this.Type">tp</a><span class="delimiter">)</span>, <a href="#442001" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="461279">narrow</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443245" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <a href="#441367" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#448175" title="=&gt; Types.this.Type">pre</a>, <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443490" title="=&gt; Types.this.Symbol">sourceModule</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#441302" title="Types.this.NoArgsTypeRef" class="keyword">super</a>.<a href="#441993" title="=&gt; Types.this.Type">narrow</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.NoArgsTypeRef" id="461280">typeConstructor</a> = <a href="#441302" title="Types.this.NoArgsTypeRef" class="keyword">this</a>
    // eta-expand, subtyping relies on eta-expansion of higher-kinded types

    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="461281">normalizeImpl</a>: <a href="#441242" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461273" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#448126" title="=&gt; Types.this.Type">etaExpand</a> <span class="keyword">else</span> <a href="#441302" title="Types.this.NoArgsTypeRef" class="keyword">super</a>.<a href="#448123" title="=&gt; Types.this.Type">normalizeImpl</a>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait ClassTypeRef extends Types.this.TypeRef" id="441303">ClassTypeRef</a> <a href="../../Unit.scala.html#2389" title="Unit" class="keyword">extends</a> <a href="#448160" title="Types.this.TypeRef">TypeRef</a> <span class="delimiter">{</span>
    // !!! There are scaladoc-created symbols arriving which violate this require.
    // require(sym.isClass, sym)

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="461305">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="519408">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#519408" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <a href="#441303" title="Types.this.ClassTypeRef" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#448122" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442036" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#519408" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait NonClassTypeRef extends Types.this.TypeRef" id="441304">NonClassTypeRef</a> <a href="../../Unit.scala.html#2389" title="Unit" class="keyword">extends</a> <a href="#448160" title="Types.this.TypeRef">TypeRef</a> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#8464" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443235" title="=&gt; Boolean">isNonClassType</a>, <a href="#448176" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

    /* Syncnote: These are pure caches for performance; no problem to evaluate these
     * several times. Hence, no need to protected with synchronzied in a mutli-threaded
     * usage scenario.
     */
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="519419">relativeInfoCache</a>: <a href="#441242" title="Types.this.Type">Type</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="519422">memberInfoCache</a>: <a href="#441242" title="Types.this.Type">Type</a> = _

    <span class="keyword">private</span><span class="delimiter">[</span>Types<span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="519424">relativeInfo</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="519432">memberInfo</a> = <a href="#448175" title="=&gt; Types.this.Type">pre</a>.<a href="#442038" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#519419" title="=&gt; Types.this.Type">relativeInfoCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#519432" title="Types.this.Type">memberInfo</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#519422" title="=&gt; Types.this.Type">memberInfoCache</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#519422" title="(x$1: Types.this.Type)Unit">memberInfoCache</a> = <a href="#519432" title="Types.this.Type">memberInfo</a>
        <a href="#519419" title="(x$1: Types.this.Type)Unit">relativeInfoCache</a> = <a href="#448128" title="(tp: Types.this.Type)Types.this.Type">transformInfo</a><span class="delimiter">(</span><a href="#519432" title="Types.this.Type">memberInfo</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#519419" title="=&gt; Types.this.Type">relativeInfoCache</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="519425">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="519438">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#519438" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <a href="#441304" title="Types.this.NonClassTypeRef" class="keyword">this</a> <span class="keyword">else</span> <a href="#441305" title="(tpe: Types.this.NonClassTypeRef, clazz: Types.this.Symbol)Types.this.Type">baseTypeOfNonClassTypeRef</a><span class="delimiter">(</span><a href="#441304" title="Types.this.NonClassTypeRef" class="keyword">this</a>, <a href="#519438" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tpe: Types.this.NonClassTypeRef, clazz: Types.this.Symbol)Types.this.Type" id="441305">baseTypeOfNonClassTypeRef</a><span class="delimiter">(</span><a title="Types.this.NonClassTypeRef" id="519445">tpe</a>: <a href="#441304" title="Types.this.NonClassTypeRef">NonClassTypeRef</a>, <a title="Types.this.Symbol" id="519446">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="#441508" title="(x$1: Int)Unit">basetypeRecursions</a> <a href="../../Int.scala.html#57948" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#441508" title="=&gt; Int">basetypeRecursions</a> <a href="../../Int.scala.html#57905" title="(x: Int)Boolean">&lt;</a> <span title="Int(50)">LogPendingBaseTypesThreshold</span><span class="delimiter">)</span>
      <a href="#519445" title="Types.this.NonClassTypeRef">tpe</a>.<a href="#519424" title="=&gt; Types.this.Type">relativeInfo</a>.<a href="#442036" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#519446" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#441510" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <a href="../../collection/mutable/HashSet.scala.html#141569" title="(elem: Types.this.Type)Boolean">contains</a> <a href="#519445" title="Types.this.NonClassTypeRef">tpe</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#519446" title="Types.this.Symbol">clazz</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a><span class="delimiter">)</span> <a href="#519446" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#516490" title="Types.this.NoType.type">NoType</a>
    <span class="keyword">else</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#441510" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <a href="../../collection/mutable/HashSet.scala.html#141570" title="(elem: Types.this.Type)Types.this.pendingBaseTypes.type">+=</a> <a href="#519445" title="Types.this.NonClassTypeRef">tpe</a>
        <a href="#519445" title="Types.this.NonClassTypeRef">tpe</a>.<a href="#519424" title="=&gt; Types.this.Type">relativeInfo</a>.<a href="#442036" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#519446" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
        <a href="#441510" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <a href="../../collection/mutable/HashSet.scala.html#141571" title="(elem: Types.this.Type)Types.this.pendingBaseTypes.type">-=</a> <a href="#519445" title="Types.this.NonClassTypeRef">tpe</a>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#441508" title="(x$1: Int)Unit">basetypeRecursions</a> <a href="../../Int.scala.html#57955" title="(x: Int)Int">-=</a> <span title="Int(1)" class="int">1</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait AliasTypeRef extends Types.this.TypeRef with Types.this.NonClassTypeRef" id="441306">AliasTypeRef</a> <a href="../../Unit.scala.html#2389" title="Unit" class="keyword">extends</a> <a href="#441304" title="Types.this.NonClassTypeRef">NonClassTypeRef</a> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#8464" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443232" title="=&gt; Boolean">isAliasType</a>, <a href="#448176" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="519496">dealias</a>    = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#448131" title="=&gt; Boolean">typeParamsMatchArgs</a><span class="delimiter">)</span> <a href="#519505" title="=&gt; Types.this.Type">betaReduce</a>.<a href="#442018" title="=&gt; Types.this.Type">dealias</a> <span class="keyword">else</span> <a href="#441306" title="Types.this.AliasTypeRef" class="keyword">super</a>.<a href="#442018" title="=&gt; Types.this.Type">dealias</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="519497">isStable</a>   = <a href="#448124" title="=&gt; Types.this.Type">normalize</a>.<a href="#441973" title="=&gt; Boolean">isStable</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="519498">isVolatile</a> = <a href="#448124" title="=&gt; Types.this.Type">normalize</a>.<a href="#441974" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="519499">narrow</a>     = <a href="#448124" title="=&gt; Types.this.Type">normalize</a>.<a href="#441993" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="519500">thisInfo</a>   = <a href="#448124" title="=&gt; Types.this.Type">normalize</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="519501">prefix</a>     = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#441306" title="AliasTypeRef.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#448124" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#448124" title="=&gt; Types.this.Type">normalize</a>.<a href="#441997" title="=&gt; Types.this.Type">prefix</a> <span class="keyword">else</span> <a href="#448175" title="=&gt; Types.this.Type">pre</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="519502">termSymbol</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#441306" title="AliasTypeRef.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#448124" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#448124" title="=&gt; Types.this.Type">normalize</a>.<a href="#441985" title="=&gt; Types.this.Symbol">termSymbol</a> <span class="keyword">else</span> <a href="#441306" title="Types.this.AliasTypeRef" class="keyword">super</a>.<a href="#448137" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="519503">typeSymbol</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#441306" title="AliasTypeRef.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#448124" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#448124" title="=&gt; Types.this.Type">normalize</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span class="keyword">else</span> <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>

    // beta-reduce, but don't do partial application -- cycles have been checked in typeRef
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="519504">normalizeImpl</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#448131" title="=&gt; Boolean">typeParamsMatchArgs</a><span class="delimiter">)</span> <a href="#519505" title="=&gt; Types.this.Type">betaReduce</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#441972" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#441306" title="Types.this.AliasTypeRef" class="keyword">super</a>.<a href="#448123" title="=&gt; Types.this.Type">normalizeImpl</a>
      <span class="keyword">else</span> <a href="#516388" title="Types.this.ErrorType.type">ErrorType</a>

    // isHKSubType0 introduces synthetic type params so that
    // betaReduce can first apply sym.info to typeArgs before calling
    // asSeenFrom.  asSeenFrom then skips synthetic type params, which
    // are used to reduce HO subtyping to first-order subtyping, but
    // which can't be instantiated from the given prefix and class.
    //
    // this crashes pos/depmet_implicit_tpbetareduce.scala
    // appliedType(sym.info, typeArgs).asSeenFrom(pre, sym.owner)
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="519505">betaReduce</a> = <a href="#448122" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442002" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>

    // #3731: return sym1 for which holds: pre bound sym.name to sym and
    // pre1 now binds sym.name to sym1, conceptually exactly the same
    // symbol as sym.  The selection of sym on pre must be updated to the
    // selection of sym1 on pre1, since sym's info was probably updated
    // by the TypeMap to yield a new symbol, sym1 with transformed info.
    // @returns sym1
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(pre1: Types.this.Type)Types.this.Symbol" id="519506">coevolveSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="519564">pre1</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> =
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#448175" title="=&gt; Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#519564" title="Types.this.Type">pre1</a><span class="delimiter">)</span> <a href="#448176" title="=&gt; Types.this.Symbol">sym</a> <span class="keyword">else</span> <a href="../../Tuple2.scala.html#63804" title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</a><a href="#448175" title="=&gt; Types.this.Type">pre</a>, <a href="#519564" title="Types.this.Type">pre1</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
        // don't look at parents -- it would be an error to override alias types anyway
        <span class="keyword">case</span> <span class="delimiter">(</span>RefinedType<a title="Types.this.Symbol" id="519585" class="delimiter">(</a>_, _<span class="delimiter">)</span>, RefinedType<a title="Types.this.Symbol" id="519588" class="delimiter">(</a>_, decls1<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; decls1 <a href="#519589" title="(x: Types.this.Symbol)Types.this.Symbol">lookup</a> <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443152" title="=&gt; AliasTypeRef.this.sym.NameType">name</a>
        // TODO: is there another way a typeref's symbol can refer to a symbol defined in its pre?
        <span class="keyword">case</span> _                                           =&gt; <a href="#519589" title="(x: Types.this.Symbol)Types.this.Symbol">sym</a>
      <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="519507">kind</a> = <span title="String(&quot;AliasTypeRef&quot;)" class="string">&quot;AliasTypeRef&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait AbstractTypeRef extends Types.this.TypeRef with Types.this.NonClassTypeRef" id="441307">AbstractTypeRef</a> <a href="../../Unit.scala.html#2389" title="Unit" class="keyword">extends</a> <a href="#441304" title="Types.this.NonClassTypeRef">NonClassTypeRef</a> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#8464" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443233" title="=&gt; Boolean">isAbstractType</a>, <a href="#448176" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

    /** Syncnote: Pure performance caches; no need to synchronize in multi-threaded environment
     */
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="519602">symInfoCache</a>: <a href="#441242" title="Types.this.Type">Type</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="519605">thisInfoCache</a>: <a href="#441242" title="Types.this.Type">Type</a> = _

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="519607">isVolatile</a> = <span class="delimiter">{</span>
      // need to be careful not to fall into an infinite recursion here
      // because volatile checking is done before all cycles are detected.
      // the case to avoid is an abstract type directly or
      // indirectly upper-bounded by itself. See #2918
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#441294" title="(x$1: Int)Unit">volatileRecursions</a> <a href="../../Int.scala.html#57948" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#441294" title="=&gt; Int">volatileRecursions</a> <a href="../../Int.scala.html#57905" title="(x: Int)Boolean">&lt;</a> <span title="Int(50)">LogVolatileThreshold</span><span class="delimiter">)</span>
          <a href="#519610" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a>.<a href="#441974" title="=&gt; Boolean">isVolatile</a>
        <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="../../collection/GenSetLike.scala.html#65156" title="(elem: Types.this.Symbol)Boolean">pendingVolatiles</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="Boolean(true)" class="keyword">true</span> // we can return true here, because a cycle will be detected
               // here afterwards and an error will result anyway.
        <span class="keyword">else</span>
          <span class="keyword">try</span> <span class="delimiter">{</span>
            <a href="#441296" title="=&gt; scala.collection.mutable.HashSet[Types.this.Symbol]">pendingVolatiles</a> <a href="../../collection/mutable/HashSet.scala.html#141570" title="(elem: Types.this.Symbol)Types.this.pendingVolatiles.type">+=</a> <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>
            <a href="#519610" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a>.<a href="#441974" title="=&gt; Boolean">isVolatile</a>
          <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            <a href="#441296" title="=&gt; scala.collection.mutable.HashSet[Types.this.Symbol]">pendingVolatiles</a> <a href="../../collection/mutable/HashSet.scala.html#141571" title="(elem: Types.this.Symbol)Types.this.pendingVolatiles.type">-=</a> <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
        <a href="#441294" title="(x$1: Int)Unit">volatileRecursions</a> <a href="../../Int.scala.html#57955" title="(x: Int)Int">-=</a> <span title="Int(1)" class="int">1</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="519608">thisInfo</a>   = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="519638">symInfo</a> = <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#519605" title="=&gt; Types.this.Type">thisInfoCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#519638" title="Types.this.Type">symInfo</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#519602" title="=&gt; Types.this.Type">symInfoCache</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#519602" title="(x$1: Types.this.Type)Unit">symInfoCache</a> = <a href="#519638" title="Types.this.Type">symInfo</a>
        <a href="#519605" title="(x$1: Types.this.Type)Unit">thisInfoCache</a> = <a href="#448128" title="(tp: Types.this.Type)Types.this.Type">transformInfo</a><a href="#519649" title="Types.this.SubType" class="delimiter">(</a><a href="#519638" title="Types.this.Type">symInfo</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
          // If a subtyping cycle is not detected here, we'll likely enter an infinite
          // loop before a sensible error can be issued.  SI-5093 is one example.
          <span class="keyword">case</span> <a href="#519647" title="Types.this.Type" id="519649">x</a>: SubType <span class="keyword">if</span> x.<a href="#448287" title="=&gt; Types.this.Type">supertype</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#441307" title="Types.this.AbstractTypeRef" class="keyword">this</a> =&gt;
            <a href="#519650" title="(x: Types.this.Type)Types.this.Type" class="keyword">throw</a> <span title="Types.this.RecoverableCyclicReference" class="keyword">new</span> <a href="#536666" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <span class="keyword">case</span> tp =&gt; <a href="#519650" title="(x: Types.this.Type)Types.this.Type">tp</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#519605" title="=&gt; Types.this.Type">thisInfoCache</a>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="519609">isStable</a> = <a href="#519610" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#443469" title="(that: Types.this.Symbol)Boolean">isSubClass</a> <a href="Definitions.scala.html#442283" title="=&gt; Types.this.ClassSymbol">SingletonClass</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="519610">bounds</a>   = <a href="#519608" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>
    // def transformInfo(tp: Type): Type = appliedType(tp.asSeenFrom(pre, sym.owner), typeArgsOrDummies)
    <span class="keyword">override</span> <span class="keyword">protected</span><span class="delimiter">[</span>Types<span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="519611">baseTypeSeqImpl</a>: <a href="BaseTypeSeqs.scala.html#441719" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#448122" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#519610" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>.<a href="#442066" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#447206" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">prepend</a> <a href="#441307" title="Types.this.AbstractTypeRef" class="keyword">this</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="519612">kind</a> = <span title="String(&quot;AbstractTypeRef&quot;)" class="string">&quot;AbstractTypeRef&quot;</span>
  <span class="delimiter">}</span>

  /** A class for named types of the form
   *    `&lt;prefix&gt;.&lt;sym.name&gt;[args]`
   *  Cannot be created directly; one should always use `typeRef`
   *  for creation. (@M: Otherwise hashing breaks)
   *
   * @M: a higher-kinded type is represented as a TypeRef with sym.typeParams.nonEmpty, but args.isEmpty
   */
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#519962" title="class TypeRef extends Types.this.Type with Product with Serializable" id="448160">TypeRef</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><a title="Types.this.Type" id="448175">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="448176">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="448177">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="List[Types.this.Type]" id="448108">parentsCache</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>      = _
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Int" id="448111">parentsPeriod</a>                 = <span title="Int(0)">NoPeriod</span>
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Types.this.BaseTypeSeq" id="448114">baseTypeSeqCache</a>: <a href="BaseTypeSeqs.scala.html#441719" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = _
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Int" id="448117">baseTypeSeqPeriod</a>             = <span title="Int(0)">NoPeriod</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="448120">normalized</a>: <a href="#441242" title="Types.this.Type">Type</a>                       = _

    // @M: propagate actual type params (args) to `tp`, by replacing
    // formal type parameters with actual ones. If tp is higher kinded,
    // the &quot;actual&quot; type arguments are types that simply reference the
    // corresponding type parameters (unbound type variables)
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="448122">transform</a><span class="delimiter">(</span><a title="Types.this.Type" id="519062">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a>

    // eta-expand, subtyping relies on eta-expansion of higher-kinded types
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448123">normalizeImpl</a>: <a href="#441242" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#441972" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#448126" title="=&gt; Types.this.Type">etaExpand</a> <span class="keyword">else</span> <a href="#448160" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a>

    // TODO: test case that is compiled in a specific order and in different runs
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448124">normalize</a>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      // arises when argument-dependent types are approximated (see def depoly in implicits)
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#448175" title="=&gt; Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516414" title="Types.this.WildcardType.type">WildcardType</a><span class="delimiter">)</span> <a href="#516414" title="Types.this.WildcardType.type">WildcardType</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#448123" title="=&gt; Types.this.Type">normalizeImpl</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#448120" title="=&gt; Types.this.Type">normalized</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
          <a href="#448120" title="(x$1: Types.this.Type)Unit">normalized</a> = <a href="#448123" title="=&gt; Types.this.Type">normalizeImpl</a>
        <a href="#448120" title="=&gt; Types.this.Type">normalized</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448125">isGround</a> = <span class="delimiter">(</span>
         <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a>
      <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#448175" title="=&gt; Types.this.Type">pre</a>.<a href="#442080" title="=&gt; Boolean">isGround</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#448177" title="=&gt; List[Types.this.Type]">args</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a href="#519726" title="Types.this.Type">_</a>.<a href="#442080" title="=&gt; Boolean">isGround</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448126">etaExpand</a>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      // must initialise symbol, see test/files/pos/ticket0137.scala
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="519727">tpars</a> = <a href="#448130" title="=&gt; List[Types.this.Symbol]">initializedTypeParams</a>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#519727" title="List[Types.this.Symbol]">tpars</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#448160" title="Types.this.TypeRef" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#441384" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFunAnon</a><span class="delimiter">(</span><a href="#519727" title="List[Types.this.Symbol]">tpars</a>, <a href="#441372" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#448160" title="Types.this.TypeRef" class="keyword">this</a>, <a href="#448175" title="=&gt; Types.this.Type">pre</a>, <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>, <a href="#519727" title="List[Types.this.Symbol]">tpars</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#519747" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443426" title="=&gt; Types.this.Type">tpeHK</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> // todo: also beta-reduce?
    <span class="delimiter">}</span>

    // only need to rebind type aliases, as typeRef already handles abstract types
    // (they are allowed to be rebound more liberally)
    <span class="keyword">def</span> <a title="(pre1: Types.this.Type)Types.this.Symbol" id="448127">coevolveSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="519566">pre1</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>

    //@M! use appliedType on the polytype that represents the bounds (or if aliastype, the rhs)
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="448128">transformInfo</a><span class="delimiter">(</span><a title="Types.this.Type" id="519390">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441377" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#448132" title="(tp: Types.this.Type)Types.this.Type">asSeenFromOwner</a><span class="delimiter">(</span><a href="#519390" title="Types.this.Type">tp</a><span class="delimiter">)</span>, <a href="#448177" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448129">thisInfo</a>                  = <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="448130">initializedTypeParams</a>     = <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442011" title="=&gt; List[Types.this.Symbol]">typeParams</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="448131">typeParamsMatchArgs</a>       = <a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#448130" title="=&gt; List[Types.this.Symbol]">initializedTypeParams</a>, <a href="#448177" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="448132">asSeenFromOwner</a><span class="delimiter">(</span><a title="Types.this.Type" id="519073">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#519073" title="Types.this.Type">tp</a>.<a href="#442037" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#448175" title="=&gt; Types.this.Type">pre</a>, <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="448133">baseClasses</a>      = <a href="#448129" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#442068" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="448134">baseTypeSeqDepth</a> = <a href="#448149" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#447211" title="=&gt; Int">maxDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448135">isStable</a>         = <span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#442283" title="=&gt; Types.this.ClassSymbol">SingletonClass</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448136">prefix</a>           = <a href="#448175" title="=&gt; Types.this.Type">pre</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="448137">termSymbol</a>       = <a href="#448160" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#441985" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="448138">termSymbolDirect</a> = <a href="#448160" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#441985" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="448139">typeArgs</a>         = <a href="#448177" title="=&gt; List[Types.this.Type]">args</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448140">typeOfThis</a>       = <a href="#448122" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443484" title="=&gt; Types.this.Type">typeOfThis</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="448141">typeSymbol</a>       = <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="448142">typeSymbolDirect</a> = <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>

    <span class="keyword">override</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="448144">isTrivial</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> =
      <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443256" title="=&gt; Boolean">isTypeParameter</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#448175" title="=&gt; Types.this.Type">pre</a>.<a href="#441971" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#448177" title="=&gt; List[Types.this.Type]">args</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a href="#519804" title="Types.this.Type">_</a>.<a href="#441971" title="=&gt; Boolean">isTrivial</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448145">isNotNull</a> =
      <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443245" title="=&gt; Boolean">isModuleClass</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#448176" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a> <a href="Symbols.scala.html#443468" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="Definitions.scala.html#442272" title="=&gt; Types.this.ClassSymbol">NotNullClass</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#448160" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#441975" title="=&gt; Boolean">isNotNull</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="448146">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="519807">cache</a> = <a href="#448108" title="=&gt; List[Types.this.Type]">parentsCache</a>
      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#448111" title="=&gt; Int">parentsPeriod</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <a href="SymbolTable.scala.html#440602" title="=&gt; Types.this.Period">currentPeriod</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#519807" title="List[Types.this.Type]">cache</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#519807" title="List[Types.this.Type]">cache</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#441311" title="(tpe: Types.this.TypeRef)Unit">defineParentsOfTypeRef</a><span class="delimiter">(</span><a href="#448160" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#448108" title="=&gt; List[Types.this.Type]">parentsCache</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="448147">decls</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a> = <span class="delimiter">{</span>
      <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> TypeRef<a href="#519893" title="Unit" id="519897" class="delimiter">(</a>_, sym1, _<span class="delimiter">)</span> =&gt;
          <a href="../../Predef.scala.html#8460" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><a href="#519898" title="(x: Unit)Unit" class="delimiter">(</a>sym1 <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>, <a href="#448160" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span> // @MAT was != typeSymbol
        <span class="keyword">case</span> _ =&gt;
      <span class="delimiter">}</span>
      <a href="#448129" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#442019" title="=&gt; Types.this.Scope">decls</a>
    <span class="delimiter">}</span>

    <span class="keyword">protected</span><span class="delimiter">[</span>Types<span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="448148">baseTypeSeqImpl</a>: <a href="BaseTypeSeqs.scala.html#441719" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442066" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#447208" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">map</a> <a href="#448122" title="(tp: Types.this.Type)Types.this.Type">transform</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="448149">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#441719" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="519906">cache</a> = <a href="#448114" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
      <span title="Types.this.BaseTypeSeq" class="keyword">if</span> <span class="delimiter">(</span><a href="#448117" title="=&gt; Int">baseTypeSeqPeriod</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <a href="SymbolTable.scala.html#440602" title="=&gt; Types.this.Period">currentPeriod</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#519906" title="Types.this.BaseTypeSeq">cache</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#519906" title="Types.this.BaseTypeSeq">cache</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="BaseTypeSeqs.scala.html#441720" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
        <a href="#519906" title="Types.this.BaseTypeSeq">cache</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#441312" title="(tpe: Types.this.TypeRef)Unit">defineBaseTypeSeqOfTypeRef</a><span class="delimiter">(</span><a href="#448160" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#448114" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="BaseTypeSeqs.scala.html#441720" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <span title="Types.this.RecoverableCyclicReference" class="keyword">new</span> <a href="#536666" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

        <a href="#448114" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    // ensure that symbol is not a local copy with a name coincidence
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448150">needsPreString</a> = <span class="delimiter">(</span>
         <a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456420" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a>
      <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="../../collection/GenSetLike.scala.html#65156" title="(elem: String)Boolean">shorthands</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443398" title="=&gt; String">fullName</a><span class="delimiter">)</span>
      <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443381" title="=&gt; List[Types.this.Symbol]">ownerChain</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="519312">s</a> =&gt; <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#519312" title="Types.this.Symbol">s</a>.<a href="Symbols.scala.html#443231" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; String" id="448151">preString</a>  = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#448150" title="=&gt; Boolean">needsPreString</a><span class="delimiter">)</span> <a href="#448175" title="=&gt; Types.this.Type">pre</a>.<a href="#442075" title="=&gt; String">prefixString</a> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; String" id="448152">argsString</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#448177" title="=&gt; List[Types.this.Type]">args</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="#448177" title="=&gt; List[Types.this.Type]">args</a>.<a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="=&gt; String" id="448153">refinementString</a> = <span class="delimiter">(</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443367" title="=&gt; Boolean">isStructuralRefinement</a><span class="delimiter">)</span> <span class="delimiter">(</span>
        <a href="#448147" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#447350" title="(p: Types.this.Symbol =&gt; Boolean)Types.this.Scope">filter</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="519135">sym</a> =&gt; <a href="#519135" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443370" title="=&gt; Boolean">isPossibleInRefinement</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#519135" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#443606" title="=&gt; Boolean">isPublic</a><span class="delimiter">)</span>
          <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[Types.this.Symbol],String,Iterable[String]])Iterable[String]">map</a> <span class="delimiter">(</span><a href="#519155" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443568" title="=&gt; String">defString</a><span class="delimiter">)</span>
          <a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;{&quot;)" class="string">&quot;{&quot;</span>, <span title="String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="String(&quot;}&quot;)" class="string">&quot;}&quot;</span><span class="delimiter">)</span>
      <span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="delimiter">)</span>

    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(rest: String)String" id="448154">finishPrefix</a><span class="delimiter">(</span><a title="String" id="519117">rest</a>: <span title="String">String</span><span class="delimiter">)</span> = <span class="delimiter">(</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443374" title="=&gt; Boolean">isInitialized</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443240" title="=&gt; Boolean">isAnonymousClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
        <a href="Definitions.scala.html#442564" title="(parents: List[Types.this.Type])String">parentsString</a><span class="delimiter">(</span><a href="#448129" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#441995" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#448153" title="=&gt; String">refinementString</a>
      <span class="keyword">else</span> <a href="#519117" title="String">rest</a>
    <span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; String" id="448155">customToString</a> = <a href="#448176" title="=&gt; Types.this.Symbol">sym</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="Definitions.scala.html#442303" title="String" id="519262">RepeatedParamClass</a> =&gt; <a href="#448177" title="=&gt; List[Types.this.Type]">args</a>.<a href="../../Predef.scala.html#8576" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">head</a> <a href="#519264" title="(x: String)String">+</a> <span title="String(&quot;*&quot;)" class="string">&quot;*&quot;</span>
      <span class="keyword">case</span> <a href="Definitions.scala.html#442297" title="String" id="519263">ByNameParamClass</a>   =&gt; <span title="String(&quot;=&gt; &quot;)" class="string">&quot;=&gt; &quot;</span> <a href="#519264" title="(x: String)String">+</a> <a href="#448177" title="=&gt; List[Types.this.Type]">args</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a>
      <span class="keyword">case</span> _                  =&gt;
        <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="519192">targs</a> = <a href="#448124" title="=&gt; Types.this.Type">normalize</a>.<a href="#442000" title="=&gt; List[Types.this.Type]">typeArgs</a>

        <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#442506" title="(tp: Types.this.Type)Boolean">isFunctionType</a><span class="delimiter">(</span><a href="#448160" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          // Aesthetics: printing Function1 as T =&gt; R rather than (T) =&gt; R
          // ...but only if it's not a tuple, so ((T1, T2)) =&gt; R is distinguishable
          // from (T1, T2) =&gt; R.
          <a href="#519192" title="=&gt; List[Types.this.Type]">targs</a> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> in <a href="#519217" title="String" id="519219">::</a> out <a title="String" id="519221">::</a> <a href="../../collection/immutable/List.scala.html#11552" title="String" id="519223">Nil</a> <span class="keyword">if</span> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="Definitions.scala.html#442491" title="(tp: Types.this.Type)Boolean">isTupleType</a><span class="delimiter">(</span>in<span class="delimiter">)</span> =&gt;
              // A =&gt; B =&gt; C should be (A =&gt; B) =&gt; C or A =&gt; (B =&gt; C)
              <span class="keyword">val</span> <a title="String" id="519210">in_s</a>  = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#442506" title="(tp: Types.this.Type)Boolean">isFunctionType</a><span class="delimiter">(</span>in<span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> in <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> in
              <span class="keyword">val</span> <a title="String" id="519211">out_s</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#442506" title="(tp: Types.this.Type)Boolean">isFunctionType</a><span class="delimiter">(</span>out<span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> out <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> out
              <a href="#519210" title="String">in_s</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; =&gt; &quot;)" class="string">&quot; =&gt; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#519211" title="String">out_s</a>
            <span class="keyword">case</span> xs =&gt;
              xs.<a href="../../collection/TraversableLike.scala.html#59015" title="=&gt; List[Types.this.Type]">init</a>.<a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; =&gt; &quot;)" class="string">&quot; =&gt; &quot;</span> <a href="#519224" title="(x: String)String">+</a> xs.<a href="../../collection/LinearSeqOptimized.scala.html#76185" title="=&gt; Types.this.Type">last</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#442491" title="(tp: Types.this.Type)Boolean">isTupleType</a><span class="delimiter">(</span><a href="#448160" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#519192" title="=&gt; List[Types.this.Type]">targs</a>.<a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#441504" title="(xs: List[_], len: Int)Boolean">hasLength</a><span class="delimiter">(</span><a href="#519192" title="=&gt; List[Types.this.Type]">targs</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;,)&quot;)" class="string">&quot;,)&quot;</span> <span class="keyword">else</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443232" title="=&gt; Boolean">isAliasType</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441998" title="=&gt; List[Types.this.Type]">prefixChain</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#519255" title="Types.this.Type">_</a>.<a href="#441985" title="=&gt; Types.this.Symbol">termSymbol</a>.<a href="HasFlags.scala.html#443598" title="=&gt; Boolean">isSynthetic</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#448160" title="TypeRef.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#448160" title="TypeRef.this.type" class="keyword">this</a>.<a href="#448124" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#448124" title="=&gt; Types.this.Type">normalize</a>
        <span class="keyword">else</span>
          <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="448156">safeToString</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="519183">custom</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456420" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="#448155" title="=&gt; String">customToString</a>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#519183" title="String">custom</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span> <a href="#519183" title="String">custom</a>
      <span class="keyword">else</span> <a href="#448154" title="(rest: String)String">finishPrefix</a><span class="delimiter">(</span><a href="#448151" title="=&gt; String">preString</a> <span title="(x$1: Any)String">+</span> <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443556" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <a href="#448152" title="=&gt; String">argsString</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="448157">prefixString</a> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span>
      <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456420" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a><span class="delimiter">)</span>
        <a href="#448160" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#442075" title="=&gt; String">prefixString</a>
      <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443331" title="=&gt; Boolean">isOmittablePrefix</a><span class="delimiter">)</span>
        <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443290" title="=&gt; Boolean">isPackageObjectOrClass</a><span class="delimiter">)</span>
        <a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443329" title="=&gt; Types.this.Symbol">skipPackageObject</a>.<a href="Symbols.scala.html#443398" title="=&gt; String">fullName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#448135" title="=&gt; Boolean">isStable</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="StdNames.scala.html#441764" title="Types.this.nme.type">nme</a>.<a href="StdNames.scala.html#446234" title="(name: Types.this.Name)Boolean">isSingletonName</a><span class="delimiter">(</span><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443152" title="=&gt; TypeRef.this.sym.NameType">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="StdNames.scala.html#441756" title="Types.this.tpnme.type">tpnme</a>.<a href="StdNames.scala.html#449279" title="(name: Types.this.Name)Types.this.TypeName">dropSingletonName</a><a href="../../Predef.scala.html#8576" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd" class="delimiter">(</a><a href="#448176" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443152" title="=&gt; TypeRef.this.sym.NameType">name</a><span class="delimiter">)</span> <a href="../../runtime/StringAdd.scala.html#60949" title="(other: String)String">+</a> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      <span class="keyword">else</span>
        <a href="#448160" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#442075" title="=&gt; String">prefixString</a>
    <span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="448158">kind</a> = <span title="String(&quot;TypeRef&quot;)" class="string">&quot;TypeRef&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Types.this.TypeRef.type" id="520180">TypeRef</a> <a href="#441310" title="Types.this.TypeRef.type" class="keyword">extends</a> <a href="../api/Types.scala.html#23495" title="Types.this.TypeRefExtractor">TypeRefExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="448096">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="469484">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="469485">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="469486">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441408" title="(tp: Types.this.Type)Types.this.Type">unique</a><span class="delimiter">(</span><span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#469486" title="List[Types.this.Type]">args</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#469485" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443232" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span>              <a href="#520005" title="Types.this.ArgsTypeRef with Types.this.AliasTypeRef" class="keyword">new</a> <a href="#441298" title="anonymous class $anon extends Types.this.ArgsTypeRef with Types.this.AliasTypeRef" id="520005">ArgsTypeRef</a><span class="delimiter">(</span><a href="#469484" title="Types.this.Type">pre</a>, <a href="#469485" title="Types.this.Symbol">sym</a>, <a href="#469486" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441306" title="Types.this.AliasTypeRef">AliasTypeRef</a>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#469485" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443233" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span>      <a href="#520029" title="Types.this.ArgsTypeRef with Types.this.AbstractTypeRef" class="keyword">new</a> <a href="#441298" title="anonymous class $anon extends Types.this.ArgsTypeRef with Types.this.AbstractTypeRef" id="520029">ArgsTypeRef</a><span class="delimiter">(</span><a href="#469484" title="Types.this.Type">pre</a>, <a href="#469485" title="Types.this.Symbol">sym</a>, <a href="#469486" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441307" title="Types.this.AbstractTypeRef">AbstractTypeRef</a>
        <span class="keyword">else</span>                              <a href="#520053" title="Types.this.ArgsTypeRef with Types.this.ClassTypeRef" class="keyword">new</a> <a href="#441298" title="anonymous class $anon extends Types.this.ArgsTypeRef with Types.this.ClassTypeRef" id="520053">ArgsTypeRef</a><span class="delimiter">(</span><a href="#469484" title="Types.this.Type">pre</a>, <a href="#469485" title="Types.this.Symbol">sym</a>, <a href="#469486" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441303" title="Types.this.ClassTypeRef">ClassTypeRef</a>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#469485" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443232" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span>              <a href="#520092" title="Types.this.NoArgsTypeRef with Types.this.AliasTypeRef" class="keyword">new</a> <a href="#441302" title="anonymous class $anon extends Types.this.NoArgsTypeRef with Types.this.AliasTypeRef" id="520092">NoArgsTypeRef</a><span class="delimiter">(</span><a href="#469484" title="Types.this.Type">pre</a>, <a href="#469485" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441306" title="Types.this.AliasTypeRef">AliasTypeRef</a>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#469485" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443233" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span>      <a href="#520116" title="Types.this.NoArgsTypeRef with Types.this.AbstractTypeRef" class="keyword">new</a> <a href="#441302" title="anonymous class $anon extends Types.this.NoArgsTypeRef with Types.this.AbstractTypeRef" id="520116">NoArgsTypeRef</a><span class="delimiter">(</span><a href="#469484" title="Types.this.Type">pre</a>, <a href="#469485" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441307" title="Types.this.AbstractTypeRef">AbstractTypeRef</a>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#469485" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443248" title="=&gt; Boolean">isRefinementClass</a><span class="delimiter">)</span>   <span title="Types.this.RefinementTypeRef" class="keyword">new</span> <a href="#441301" title="Types.this.RefinementTypeRef">RefinementTypeRef</a><span class="delimiter">(</span><a href="#469485" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#469485" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span>      <span title="Types.this.PackageTypeRef" class="keyword">new</span> <a href="#441300" title="Types.this.PackageTypeRef">PackageTypeRef</a><span class="delimiter">(</span><a href="#469484" title="Types.this.Type">pre</a>, <a href="#469485" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#469485" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443245" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span>       <span title="Types.this.ModuleTypeRef" class="keyword">new</span> <a href="#441299" title="Types.this.ModuleTypeRef">ModuleTypeRef</a><span class="delimiter">(</span><a href="#469484" title="Types.this.Type">pre</a>, <a href="#469485" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="keyword">else</span>                              <a href="#520140" title="Types.this.NoArgsTypeRef with Types.this.ClassTypeRef" class="keyword">new</a> <a href="#441302" title="anonymous class $anon extends Types.this.NoArgsTypeRef with Types.this.ClassTypeRef" id="520140">NoArgsTypeRef</a><span class="delimiter">(</span><a href="#469484" title="Types.this.Type">pre</a>, <a href="#469485" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441303" title="Types.this.ClassTypeRef">ClassTypeRef</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tpe: Types.this.TypeRef)Unit" id="441311">defineParentsOfTypeRef</a><span class="delimiter">(</span><a title="Types.this.TypeRef" id="519817">tpe</a>: <a href="#448160" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Int" id="519820">period</a> = <a href="#519817" title="Types.this.TypeRef">tpe</a>.<a href="#448111" title="=&gt; Int">parentsPeriod</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#519820" title="Int">period</a> <a href="../../Int.scala.html#57898" title="(x: Int)Boolean">!=</a> <a href="SymbolTable.scala.html#440602" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#519817" title="Types.this.TypeRef">tpe</a>.<a href="#448111" title="(x$1: Int)Unit">parentsPeriod</a> = <a href="SymbolTable.scala.html#440602" title="=&gt; Types.this.Period">currentPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#440625" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#519820" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#519817" title="Types.this.TypeRef">tpe</a>.<a href="#448108" title="(x$1: List[Types.this.Type])Unit">parentsCache</a> = <a href="#519817" title="Types.this.TypeRef">tpe</a>.<a href="#448129" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#441995" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#519817" title="Types.this.TypeRef">tpe</a>.<a href="#448122" title="(tp: Types.this.Type)Types.this.Type">transform</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#519817" title="Types.this.TypeRef">tpe</a>.<a href="#448108" title="=&gt; List[Types.this.Type]">parentsCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span> // seems this can happen if things are corrupted enough, see #2641
        <a href="#519817" title="Types.this.TypeRef">tpe</a>.<a href="#448108" title="(x$1: List[Types.this.Type])Unit">parentsCache</a> = <a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tpe: Types.this.TypeRef)Unit" id="441312">defineBaseTypeSeqOfTypeRef</a><span class="delimiter">(</span><a title="Types.this.TypeRef" id="519920">tpe</a>: <a href="#448160" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Int" id="519923">period</a> = <a href="#519920" title="Types.this.TypeRef">tpe</a>.<a href="#448117" title="=&gt; Int">baseTypeSeqPeriod</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#519923" title="Int">period</a> <a href="../../Int.scala.html#57898" title="(x: Int)Boolean">!=</a> <a href="SymbolTable.scala.html#440602" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#519920" title="Types.this.TypeRef">tpe</a>.<a href="#448117" title="(x$1: Int)Unit">baseTypeSeqPeriod</a> = <a href="SymbolTable.scala.html#440602" title="=&gt; Types.this.Period">currentPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#440625" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#519923" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="util/StatBase.scala.html#441044" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441066" title="=&gt; scala.reflect.internal.util.Statistics.Counter">typerefBaseTypeSeqCount</a><span class="delimiter">)</span>
        <a href="#519920" title="Types.this.TypeRef">tpe</a>.<a href="#448114" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="BaseTypeSeqs.scala.html#441720" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a>
        <a href="#519920" title="Types.this.TypeRef">tpe</a>.<a href="#448114" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="#519920" title="Types.this.TypeRef">tpe</a>.<a href="#448148" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqImpl</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#519920" title="Types.this.TypeRef">tpe</a>.<a href="#448114" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="BaseTypeSeqs.scala.html#441720" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <a href="#448884" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#441578" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic inheritance involving &quot;)" class="string">&quot;illegal cyclic inheritance involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#519920" title="Types.this.TypeRef">tpe</a>.<a href="#448176" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** A class representing a method type with parameters.
   *  Note that a parameterless method is represented by a NullaryMethodType:
   *
   *    def m(): Int        MethodType(Nil, Int)
   *    def m: Int          NullaryMethodType(Int)
   */
  case <span class="keyword">class</span> <a title="class MethodType extends Types.this.Type with Product with Serializable" id="448374">MethodType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="453586">params</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
                        <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="453587">resultType</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448356">isTrivial</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#448357" title="=&gt; Boolean">isTrivial0</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#453587" title="=&gt; Types.this.Type">resultType</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#453587" title="=&gt; Types.this.Type">resultType</a>.<a href="#442086" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="448358">isTrivial0</a> =
      <a href="#453587" title="=&gt; Types.this.Type">resultType</a>.<a href="#441971" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</a><span class="delimiter">{</span><a title="Types.this.Symbol" id="520203">p</a> =&gt; <a href="#520203" title="Types.this.Symbol">p</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a>.<a href="#441971" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>  <span class="delimiter">(</span>
        <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#520210" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a>.<a href="#442056" title="(sym: Types.this.Symbol)Boolean">contains</a><span class="delimiter">(</span><a href="#520203" title="Types.this.Symbol">p</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#453587" title="=&gt; Types.this.Type">resultType</a>.<a href="#442056" title="(sym: Types.this.Symbol)Boolean">contains</a><span class="delimiter">(</span><a href="#520203" title="Types.this.Symbol">p</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="=&gt; Boolean" id="448359">isImplicit</a> = <a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a>.<a href="HasFlags.scala.html#443592" title="=&gt; Boolean">isImplicit</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="448360">isJava</a> = <span title="Boolean(false)" class="keyword">false</span> // can we do something like for implicits? I.e. do Java methods without parameters need to be recognized?

    //assert(paramTypes forall (pt =&gt; !pt.typeSymbol.isImplClass))//DEBUG
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="448361">paramSectionCount</a>: <a href="../../Int.scala.html#508" title="Int">Int</a> = <a href="#453587" title="=&gt; Types.this.Type">resultType</a>.<a href="#442007" title="=&gt; Int">paramSectionCount</a> <a href="../../Int.scala.html#57948" title="(x: Int)Int">+</a> <span title="Int(1)" class="int">1</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="448362">paramss</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[List[Types.this.Symbol]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: List[Types.this.Symbol])List[List[Types.this.Symbol]]">::</a> <a href="#453587" title="=&gt; Types.this.Type">resultType</a>.<a href="#442008" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="448363">paramTypes</a> = <a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#461934" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="448364">boundSyms</a> = <a href="#453587" title="=&gt; Types.this.Type">resultType</a>.<a href="#442012" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a> <a href="../../collection/SetLike.scala.html#71321" title="(elems: scala.collection.GenTraversableOnce[Types.this.Symbol])scala.collection.immutable.Set[Types.this.Symbol]">++</a> <a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(actuals: List[Types.this.Type])Types.this.Type" id="448365">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461659">actuals</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#448356" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#453587" title="=&gt; Types.this.Type">resultType</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#461659" title="List[Types.this.Type]">actuals</a>, <a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.InstantiateDependentMap" id="461696">idm</a> = <span title="Types.this.InstantiateDependentMap" class="keyword">new</span> <a href="#441455" title="Types.this.InstantiateDependentMap">InstantiateDependentMap</a><span class="delimiter">(</span><a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#461659" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="461697">res</a> = <a href="#461712" title="(tp: Types.this.Type)Types.this.Type">idm</a><span class="delimiter">(</span><a href="#453587" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
        <a href="#441386" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#461696" title="Types.this.InstantiateDependentMap">idm</a>.<a href="#461707" title="=&gt; List[Types.this.Symbol]">existentialsNeeded</a>, <a href="#461697" title="Types.this.Type">res</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#441386" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#453587" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>

    // implicit args can only be depended on in result type:
    //TODO this may be generalised so that the only constraint is dependencies are acyclic
    <span class="keyword">def</span> <a title="=&gt; Types.this.MethodType" id="448366">approximate</a>: <a href="#448374" title="Types.this.MethodType">MethodType</a> = <a href="#448374" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#442004" title="=&gt; Types.this.Type">resultApprox</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448367">finalResultType</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#453587" title="=&gt; Types.this.Type">resultType</a>.<a href="#442006" title="=&gt; Types.this.Type">finalResultType</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="448368">safeToString</a> = <a href="TypeDebugging.scala.html#441897" title="(tp: Types.this.Type)String">paramString</a><span class="delimiter">(</span><a href="#448374" title="Types.this.MethodType" class="keyword">this</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#453587" title="=&gt; Types.this.Type">resultType</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="448369">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="461772">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="461778">vparams</a> = <a href="Symbols.scala.html#441158" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)List[Types.this.Symbol]">cloneSymbolsAtOwner</a><span class="delimiter">(</span><a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#461772" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#441374" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#448374" title="Types.this.MethodType" class="keyword">this</a>, <a href="#461778" title="List[Types.this.Symbol]">vparams</a>, <a href="#453587" title="=&gt; Types.this.Type">resultType</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#461778" title="List[Types.this.Symbol]">vparams</a><span class="delimiter">)</span>.<a href="#442070" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#461772" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="448370">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="461746">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#461758" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#461746" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#453587" title="=&gt; Types.this.Type">resultType</a>.<a href="#442071" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#461746" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#453587" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#448369" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#461746" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <a href="#448374" title="Types.this.MethodType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="448371">kind</a> = <span title="String(&quot;MethodType&quot;)" class="string">&quot;MethodType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Types.this.MethodType.type" id="520305">MethodType</a> <a href="#441315" title="Types.this.MethodType.type" class="keyword">extends</a> <a href="../api/Types.scala.html#23519" title="Types.this.MethodTypeExtractor">MethodTypeExtractor</a>

  <span class="keyword">class</span> <a title="class JavaMethodType extends Types.this.MethodType" id="441316">JavaMethodType</a><a href="#441316" title="Types.this.JavaMethodType" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="520315">ps</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="520316">rt</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#448374" title="Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#520315" title="List[Types.this.Symbol]">ps</a>, <a href="#520316" title="Types.this.Type">rt</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="520311">isJava</a> = <span title="Boolean(true)" class="keyword">true</span>
  <span class="delimiter">}</span>

  case <span class="keyword">class</span> <a title="class NullaryMethodType extends Types.this.Type with Product with Serializable" id="448427">NullaryMethodType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="454263">resultType</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448409">isTrivial</a> = <a href="#454263" title="=&gt; Types.this.Type">resultType</a>.<a href="#441971" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#454263" title="=&gt; Types.this.Type">resultType</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#454263" title="=&gt; Types.this.Type">resultType</a>.<a href="#442086" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448410">prefix</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#454263" title="=&gt; Types.this.Type">resultType</a>.<a href="#441997" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448411">narrow</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#454263" title="=&gt; Types.this.Type">resultType</a>.<a href="#441993" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448412">finalResultType</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#454263" title="=&gt; Types.this.Type">resultType</a>.<a href="#442006" title="=&gt; Types.this.Type">finalResultType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="448413">termSymbol</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="#454263" title="=&gt; Types.this.Type">resultType</a>.<a href="#441985" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="448414">typeSymbol</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="#454263" title="=&gt; Types.this.Type">resultType</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="448415">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#454263" title="=&gt; Types.this.Type">resultType</a>.<a href="#441995" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="448416">decls</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a> = <a href="#454263" title="=&gt; Types.this.Type">resultType</a>.<a href="#442019" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="448417">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#441719" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#454263" title="=&gt; Types.this.Type">resultType</a>.<a href="#442066" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="448418">baseTypeSeqDepth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a> = <a href="#454263" title="=&gt; Types.this.Type">resultType</a>.<a href="#442067" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="448419">baseClasses</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#454263" title="=&gt; Types.this.Type">resultType</a>.<a href="#442068" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="448420">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="520396">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#454263" title="=&gt; Types.this.Type">resultType</a>.<a href="#442036" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#520396" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="448421">boundSyms</a> = <a href="#454263" title="=&gt; Types.this.Type">resultType</a>.<a href="#442012" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448422">isVolatile</a> = <a href="#454263" title="=&gt; Types.this.Type">resultType</a>.<a href="#441974" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="448423">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;=&gt; &quot;)" class="string">&quot;=&gt; &quot;</span><span title="(x$1: Any)String">+</span> <a href="#454263" title="=&gt; Types.this.Type">resultType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="448424">kind</a> = <span title="String(&quot;NullaryMethodType&quot;)" class="string">&quot;NullaryMethodType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Types.this.NullaryMethodType.type" id="520471">NullaryMethodType</a> <a href="#441319" title="Types.this.NullaryMethodType.type" class="keyword">extends</a> <a href="../api/Types.scala.html#23526" title="Types.this.NullaryMethodTypeExtractor">NullaryMethodTypeExtractor</a>

  /** A type function or the type of a polymorphic value (and thus of kind *).
   *
   * Before the introduction of NullaryMethodType, a polymorphic nullary method (e.g, def isInstanceOf[T]: Boolean)
   * used to be typed as PolyType(tps, restpe), and a monomorphic one as PolyType(Nil, restpe)
   * This is now: PolyType(tps, NullaryMethodType(restpe)) and NullaryMethodType(restpe)
   * by symmetry to MethodTypes: PolyType(tps, MethodType(params, restpe)) and MethodType(params, restpe)
   *
   * Thus, a PolyType(tps, TypeRef(...)) unambiguously indicates a type function (which results from eta-expanding a type constructor alias).
   * Similarly, PolyType(tps, ClassInfoType(...)) is a type constructor.
   *
   * A polytype is of kind * iff its resultType is a (nullary) method type.
   */
  case <span class="keyword">class</span> <a title="class PolyType extends Types.this.Type with Product with Serializable" id="448476">PolyType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="454807">typeParams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="454808">resultType</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>
       <span class="keyword">extends</span> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    //assert(!(typeParams contains NoSymbol), this)
    <a href="../../Predef.scala.html#8460" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#454807" title="=&gt; List[Types.this.Symbol]">typeParams</a> <a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a>, <a href="#448476" title="Types.this.PolyType" class="keyword">this</a><span class="delimiter">)</span> // used to be a marker for nullary method type, illegal now (see @NullaryMethodType)

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="448451">paramSectionCount</a>: <a href="../../Int.scala.html#508" title="Int">Int</a> = <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#442007" title="=&gt; Int">paramSectionCount</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="448452">paramss</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[List[Types.this.Symbol]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#442008" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="448453">params</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#442009" title="=&gt; List[Types.this.Symbol]">params</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="448454">paramTypes</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#442010" title="=&gt; List[Types.this.Type]">paramTypes</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="448455">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#441995" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="448456">decls</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a> = <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#442019" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="448457">termSymbol</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#441985" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="448458">typeSymbol</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="448459">boundSyms</a> = immutable.<a href="../../collection/generic/GenericCompanion.scala.html#60782" title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</a><span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#454807" title="=&gt; List[Types.this.Symbol]">typeParams</a> <a href="../../collection/immutable/List.scala.html#63655" title="(that: scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">++</a> <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#442012" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>: _*<span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448460">prefix</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#441997" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="448461">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#441719" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#442066" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="448462">baseTypeSeqDepth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a> = <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#442067" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="448463">baseClasses</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#442068" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="448464">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="520610">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#442036" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#520610" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448465">narrow</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#441993" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448466">isVolatile</a> = <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#441974" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448467">finalResultType</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#442006" title="=&gt; Types.this.Type">finalResultType</a>

    /** @M: typeDefSig wraps a TypeBounds in a PolyType
     *  to represent a higher-kinded type parameter
     *  wrap lo&amp;hi in polytypes to bind variables
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="448468">bounds</a>: <a href="#448315" title="Types.this.TypeBounds">TypeBounds</a> =
      <a href="#448285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#441385" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#454807" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448327" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>,
                 <a href="#441385" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#454807" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448469">isHigherKinded</a> = <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#454807" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="448470">safeToString</a> = <a href="TypeDebugging.scala.html#441898" title="(tp: Types.this.Type)String">typeParamsString</a><span class="delimiter">(</span><a href="#448476" title="Types.this.PolyType" class="keyword">this</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#454808" title="=&gt; Types.this.Type">resultType</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.PolyType" id="448471">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="520660">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="520663">tparams</a> = <a href="Symbols.scala.html#441158" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)List[Types.this.Symbol]">cloneSymbolsAtOwner</a><span class="delimiter">(</span><a href="#454807" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#520660" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#448476" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#520663" title="List[Types.this.Symbol]">tparams</a>, <a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#454807" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#520663" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>.<a href="#442070" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#520660" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.PolyType" id="448472">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="520672">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      <span title="Types.this.PolyType" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#454807" title="=&gt; List[Types.this.Symbol]">typeParams</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#520681" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#520672" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#454808" title="=&gt; Types.this.Type">resultType</a>.<a href="#442071" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#520672" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#454808" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#448471" title="(owner: Types.this.Symbol)Types.this.PolyType">cloneInfo</a><span class="delimiter">(</span><a href="#520672" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <a href="#448476" title="Types.this.PolyType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="448473">kind</a> = <span title="String(&quot;PolyType&quot;)" class="string">&quot;PolyType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Types.this.PolyType.type" id="520748">PolyType</a> <a href="#441322" title="Types.this.PolyType.type" class="keyword">extends</a> <a href="../api/Types.scala.html#23527" title="Types.this.PolyTypeExtractor">PolyTypeExtractor</a>

  /** A creator for existential types which flattens nested existentials.
   */
  <span class="keyword">def</span> <a title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type" id="441323">newExistentialType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="459203">quantified</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="459204">underlying</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459203" title="List[Types.this.Symbol]">quantified</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#459204" title="Types.this.Type">underlying</a>
    <span class="keyword">else</span> <a href="#459204" title="Types.this.Type">underlying</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> ExistentialType<a href="#520766" title="Types.this.Type" id="520768" class="delimiter">(</a>qs, restpe<span class="delimiter">)</span> =&gt; <a href="#441323" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><a href="#520769" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#459203" title="List[Types.this.Symbol]">quantified</a> <a href="../../collection/immutable/List.scala.html#63646" title="(prefix: List[Types.this.Symbol])List[Types.this.Symbol]">:::</a> qs, restpe<span class="delimiter">)</span>
      <span class="keyword">case</span> _                           =&gt; <a href="#448594" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">ExistentialType</a><a href="#520769" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#459203" title="List[Types.this.Symbol]">quantified</a>, <a href="#459204" title="Types.this.Type">underlying</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  case <span class="keyword">class</span> <a title="class ExistentialType extends Types.this.Type with Types.this.RewrappingTypeProxy with Product with Serializable" id="448594">ExistentialType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="520759">quantified</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
                             <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="520760">underlying</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441238" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a>
  <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="448569">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="520777">newtp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#441386" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#520759" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#520777" title="Types.this.Type">newtp</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448570">isTrivial</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448571">isStable</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="448572">bounds</a> = <a href="#448285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#520760" title="=&gt; Types.this.Type">underlying</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448327" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#520760" title="=&gt; Types.this.Type">underlying</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="448573">parents</a> = <a href="#520760" title="=&gt; Types.this.Type">underlying</a>.<a href="#441995" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="448574">boundSyms</a> = <a href="#520759" title="=&gt; List[Types.this.Symbol]">quantified</a>.<a href="../../collection/TraversableOnce.scala.html#59181" title="scala.collection.immutable.Set[Types.this.Symbol]">toSet</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448575">prefix</a> = <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#520760" title="=&gt; Types.this.Type">underlying</a>.<a href="#441997" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="448576">typeArgs</a> = <a href="#520760" title="=&gt; Types.this.Type">underlying</a>.<a href="#442000" title="=&gt; List[Types.this.Type]">typeArgs</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="448577">params</a> = <a href="#520760" title="=&gt; Types.this.Type">underlying</a>.<a href="#442009" title="=&gt; List[Types.this.Symbol]">params</a> <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)List[Types.this.Symbol]">mapConserve</a> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="520907">param</a> =&gt;
      <span class="keyword">val</span> <a title="Types.this.Type" id="520908">tpe1</a> = <a href="#448569" title="(newtp: Types.this.Type)Types.this.Type">rewrap</a><span class="delimiter">(</span><a href="#520907" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#520908" title="Types.this.Type">tpe1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#520907" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span> <a href="#520907" title="Types.this.Symbol">param</a> <span class="keyword">else</span> <a href="#520907" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#443475" title="=&gt; param.TypeOfClonedSymbol">cloneSymbol</a>.<a href="Symbols.scala.html#443429" title="(info: Types.this.Type)param.TypeOfClonedSymbol">setInfo</a><span class="delimiter">(</span><a href="#520908" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="448578">paramTypes</a> = <a href="#520760" title="=&gt; Types.this.Type">underlying</a>.<a href="#442010" title="=&gt; List[Types.this.Type]">paramTypes</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="448579">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="520987">formals</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="520988">actuals</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
//      maybeRewrap(underlying.instantiateTypeParams(formals, actuals))

      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="520991">quantified1</a> = <span title="Types.this.SubstTypeMap" class="keyword">new</span> <a href="#441447" title="Types.this.SubstTypeMap">SubstTypeMap</a><span class="delimiter">(</span><a href="#520987" title="List[Types.this.Symbol]">formals</a>, <a href="#520988" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span> <a href="#460845" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a> <a href="#520759" title="=&gt; List[Types.this.Symbol]">quantified</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="520992">underlying1</a> = <a href="#520760" title="=&gt; Types.this.Type">underlying</a>.<a href="#442014" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#520987" title="List[Types.this.Symbol]">formals</a>, <a href="#520988" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#520991" title="List[Types.this.Symbol]">quantified1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#520759" title="=&gt; List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#520992" title="Types.this.Type">underlying1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#520760" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#448594" title="Types.this.ExistentialType" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#441386" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#520991" title="List[Types.this.Symbol]">quantified1</a>, <a href="#520992" title="Types.this.Type">underlying1</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#520759" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#520991" title="List[Types.this.Symbol]">quantified1</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="448580">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="521001">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#520760" title="=&gt; Types.this.Type">underlying</a>.<a href="#442036" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#521001" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="448581">baseTypeSeq</a> = <a href="#520760" title="=&gt; Types.this.Type">underlying</a>.<a href="#442066" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#447208" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">map</a> <a href="#445506" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448582">isHigherKinded</a> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="448583">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="521015">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="521016">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span> =
      <a href="Symbols.scala.html#441155" title="(syms: List[Types.this.Symbol], symFn: Types.this.Symbol =&gt; Types.this.Symbol)(tpe: Types.this.Type)Types.this.Type">deriveType</a><span class="delimiter">(</span><a href="#520759" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a title="Types.this.Symbol" id="521022">tparam</a> =&gt; <span class="delimiter">(</span><a href="#521015" title="Types.this.Symbol">owner</a> <a href="Symbols.scala.html#443540" title="(alt: =&gt; Types.this.Symbol)Types.this.Symbol">orElse</a> <a href="#521022" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#443200" title="(basis: Types.this.Symbol, origin: AnyRef)Types.this.TypeSkolem">newExistentialSkolem</a><span class="delimiter">(</span><a href="#521022" title="Types.this.Symbol">tparam</a>, <a href="#521016" title="AnyRef">origin</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#520760" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(qset: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]" id="448584">wildcardArgsString</a><span class="delimiter">(</span><a title="Set[Types.this.Symbol]" id="521028">qset</a>: <a href="../../collection/immutable/Set.scala.html#12289" title="Set[Types.this.Symbol]">Set</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="521029">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[String]">List</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="#521029" title="List[Types.this.Type]">args</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],String,List[String]])List[String]">map</a> <a title="anonymous class $anonfun extends scala.runtime.AbstractFunction1[Types.this.Type,String] with Serializable" id="521047" class="delimiter">{</a>
      <span class="keyword">case</span> TypeRef<a href="#521055" title="String" id="521059" class="delimiter">(</a>_, sym, _<span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#521028" title="Set[Types.this.Symbol]">qset</a> <a href="../../collection/SetLike.scala.html#71318" title="(elem: Types.this.Symbol)Boolean">contains</a> sym<span class="delimiter">)</span> =&gt;
        <span title="String(&quot;_&quot;)" class="string">&quot;_&quot;</span><a href="#521060" title="(x: String)String">+</a>sym.<a href="Symbols.scala.html#443564" title="(tp: Types.this.Type)String">infoString</a><span class="delimiter">(</span>sym.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span>
      <span class="keyword">case</span> arg =&gt;
        arg.<a href="#521060" title="(x: String)String">toString</a>
    <span class="delimiter">}</span>

    /** An existential can only be printed with wildcards if:
     *   - the underlying type is a typeref
     *   - every quantified variable appears at most once as a type argument and
     *     nowhere inside a type argument
     *   - no quantified type argument contains a quantified variable in its bound
     *   - the typeref's symbol is not itself quantified
     *   - the prefix is not quanitified
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="448585">isRepresentableWithWildcards</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="521110">qset</a> = <a href="#520759" title="=&gt; List[Types.this.Symbol]">quantified</a>.<a href="../../collection/TraversableOnce.scala.html#59181" title="scala.collection.immutable.Set[Types.this.Symbol]">toSet</a>
      <a href="#520760" title="=&gt; Types.this.Type">underlying</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> TypeRef<a href="#521175" title="Boolean" id="521177" class="delimiter">(</a>pre, sym, args<span class="delimiter">)</span> =&gt;
          <span class="keyword">def</span> <a title="(tpe: Types.this.Type)Boolean" id="521116">isQuantified</a><span class="delimiter">(</span><a title="Types.this.Type" id="521120">tpe</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
            <span class="delimiter">(</span><a href="#521120" title="Types.this.Type">tpe</a> <a href="#442055" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a title="Types.this.Type" id="521123">t</a> =&gt; <a href="#521110" title="scala.collection.immutable.Set[Types.this.Symbol]">qset</a> <a href="../../collection/SetLike.scala.html#71318" title="(elem: Types.this.Symbol)Boolean">contains</a> <a href="#521123" title="Types.this.Type">t</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
            <a href="#521120" title="Types.this.Type">tpe</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443248" title="=&gt; Boolean">isRefinementClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#521120" title="Types.this.Type">tpe</a>.<a href="#441995" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#521116" title="(tpe: Types.this.Type)Boolean">isQuantified</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <span class="keyword">val</span> <a href="#521151" title="(x: (List[Types.this.Type], List[Types.this.Type]))(List[Types.this.Type], List[Types.this.Type])" class="delimiter">(</a><a href="../../Tuple2.scala.html#61506" title="List[Types.this.Type]" id="521118">wildcardArgs</a>, <a href="../../Tuple2.scala.html#61508" title="List[Types.this.Type]" id="521119">otherArgs</a><span class="delimiter">)</span> = args <a href="../../collection/TraversableLike.scala.html#58988" title="(p: Types.this.Type =&gt; Boolean)(List[Types.this.Type], List[Types.this.Type])">partition</a> <span class="delimiter">(</span><a title="Types.this.Type" id="521138">arg</a> =&gt; <a href="#521110" title="scala.collection.immutable.Set[Types.this.Symbol]">qset</a> <a href="../../collection/SetLike.scala.html#71318" title="(elem: Types.this.Symbol)Boolean">contains</a> <a href="#521138" title="Types.this.Type">arg</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
          <a href="#521118" title="List[Types.this.Type]">wildcardArgs</a>.<a href="../../collection/SeqLike.scala.html#59789" title="=&gt; List[Types.this.Type]">distinct</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#521118" title="List[Types.this.Type]">wildcardArgs</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
          <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#521119" title="List[Types.this.Type]">otherArgs</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a title="Types.this.Type" id="521166">arg</a> =&gt; <a href="#521116" title="(tpe: Types.this.Type)Boolean">isQuantified</a><span class="delimiter">(</span><a href="#521166" title="Types.this.Type">arg</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
          <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#521118" title="List[Types.this.Type]">wildcardArgs</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a title="Types.this.Type" id="521173">arg</a> =&gt; <a href="#521116" title="(tpe: Types.this.Type)Boolean">isQuantified</a><span class="delimiter">(</span><a href="#521173" title="Types.this.Type">arg</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
          <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#521110" title="scala.collection.immutable.Set[Types.this.Symbol]">qset</a> <a href="../../collection/SetLike.scala.html#71318" title="(elem: Types.this.Symbol)Boolean">contains</a> sym<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
          <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#521116" title="(tpe: Types.this.Type)Boolean">isQuantified</a><span class="delimiter">(</span>pre<span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt; <a href="#521178" title="(x: Boolean)Boolean" class="keyword">false</a>
    <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="448586">safeToString</a>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="=&gt; String" id="521185">clauses</a> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="String" id="521186">str</a> = <a href="#520759" title="=&gt; List[Types.this.Symbol]">quantified</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],String,List[String]])List[String]">map</a> <span class="delimiter">(</span><a href="#521203" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443572" title="=&gt; String">existentialToString</a><span class="delimiter">)</span> <a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a> <span class="delimiter">(</span><span title="String(&quot; forSome { &quot;)" class="string">&quot; forSome { &quot;</span>, <span title="String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="String(&quot; }&quot;)" class="string">&quot; }&quot;</span><span class="delimiter">)</span>
        <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456422" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">explaintypes</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#521186" title="String">str</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <span class="keyword">else</span> <a href="#521186" title="String">str</a>
      <span class="delimiter">}</span>
      <a href="#520760" title="=&gt; Types.this.Type">underlying</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> TypeRef<a href="#521253" title="String" id="521255" class="delimiter">(</a>pre, sym, args<span class="delimiter">)</span> <span class="keyword">if</span> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456420" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#448585" title="=&gt; Boolean">isRepresentableWithWildcards</a> =&gt;
          <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#448096" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span>pre, sym, <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <a href="#521267" title="(x: String)String">+</a> <a href="#448584" title="(qset: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]">wildcardArgsString</a><span class="delimiter">(</span><a href="#520759" title="=&gt; List[Types.this.Symbol]">quantified</a>.<a href="../../collection/TraversableOnce.scala.html#59181" title="scala.collection.immutable.Set[Types.this.Symbol]">toSet</a>, args<span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
        <span class="keyword">case</span> MethodType<a href="#521253" title="String" id="521259" class="delimiter">(</a>_, _<span class="delimiter">)</span> | NullaryMethodType<a href="#521253" title="Boolean" id="521262" class="delimiter">(</a>_<span class="delimiter">)</span> | PolyType<a href="#521253" title="Boolean" id="521266" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt;
          <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#520760" title="=&gt; Types.this.Type">underlying</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <a href="#521267" title="(x: String)String">+</a> <a href="#521185" title="=&gt; String">clauses</a>
        <span class="keyword">case</span> _ =&gt;
          <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#520760" title="=&gt; Types.this.Type">underlying</a> <a href="#521267" title="(x: String)String">+</a> <a href="#521185" title="=&gt; String">clauses</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="448587">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="521279">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      <a href="Symbols.scala.html#441164" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol, tpe: Types.this.Type)(creator: (List[Types.this.Symbol], Types.this.Type) =&gt; Types.this.Type)Types.this.Type">createFromClonedSymbolsAtOwner</a><span class="delimiter">(</span><a href="#520759" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#521279" title="Types.this.Symbol">owner</a>, <a href="#520760" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#441323" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="448588">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="521295">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#520759" title="=&gt; List[Types.this.Symbol]">quantified</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#521304" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#521295" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#448587" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#521295" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#448594" title="Types.this.ExistentialType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="448589">kind</a> = <span title="String(&quot;ExistentialType&quot;)" class="string">&quot;ExistentialType&quot;</span>

    <span class="keyword">def</span> <a title="(op: Types.this.Type =&gt; Boolean)Boolean" id="448590">withTypeVars</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="521313">op</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#448591" title="(op: Types.this.Type =&gt; Boolean, depth: Int)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#521313" title="Types.this.Type =&gt; Boolean">op</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="(op: Types.this.Type =&gt; Boolean, depth: Int)Boolean" id="448591">withTypeVars</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="521319">op</a>: Type =&gt; Boolean, <a title="Int" id="521320">depth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="521322">quantifiedFresh</a> = <a href="Symbols.scala.html#441157" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#520759" title="=&gt; List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.TypeVar]" id="521323">tvars</a> = <a href="#521322" title="List[Types.this.Symbol]">quantifiedFresh</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.TypeVar)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.TypeVar,List[Types.this.TypeVar]])List[Types.this.TypeVar]">map</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="521342">tparam</a> =&gt; <a href="#470207" title="(tparam: Types.this.Symbol)Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#521342" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="521324">underlying1</a> = <a href="#520760" title="=&gt; Types.this.Type">underlying</a>.<a href="#442014" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#520759" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#521323" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span> // fuse subst quantified -&gt; quantifiedFresh -&gt; tvars
      <a href="../../Function1.scala.html#59555" title="(v1: Types.this.Type)Boolean">op</a><span class="delimiter">(</span><a href="#521324" title="Types.this.Type">underlying1</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
        <a href="#441536" title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean, depth: Int)Boolean">solve</a><span class="delimiter">(</span><a href="#521323" title="List[Types.this.TypeVar]">tvars</a>, <a href="#521322" title="List[Types.this.Symbol]">quantifiedFresh</a>, <a href="#521322" title="List[Types.this.Symbol]">quantifiedFresh</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Int,List[Int]])List[Int]">map</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="521391">x</a> =&gt; <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span>, <a href="#521320" title="Int">depth</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
        <a href="#441537" title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])Boolean">isWithinBounds</a><span class="delimiter">(</span><a href="#516520" title="Types.this.NoPrefix.type">NoPrefix</a>, <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a>, <a href="#521322" title="List[Types.this.Symbol]">quantifiedFresh</a>, <a href="#521323" title="List[Types.this.TypeVar]">tvars</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.TypeVar =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeVar],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#521445" title="Types.this.TypeVar">_</a>.<a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470266" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Types.this.ExistentialType.type" id="521519">ExistentialType</a> <a href="#441326" title="Types.this.ExistentialType.type" class="keyword">extends</a> <a href="../api/Types.scala.html#23528" title="Types.this.ExistentialTypeExtractor">ExistentialTypeExtractor</a>

  /** A class containing the alternatives and type prefix of an overloaded symbol.
   *  Not used after phase `typer`.
   */
  case <span class="keyword">class</span> <a title="class OverloadedType extends Types.this.Type with Product with Serializable" id="536594">OverloadedType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><a title="Types.this.Type" id="470006">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="470007">alternatives</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="469974">prefix</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#470006" title="=&gt; Types.this.Type">pre</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="469975">safeToString</a> =
      <span class="delimiter">(</span><a href="#470007" title="=&gt; List[Types.this.Symbol]">alternatives</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#470006" title="=&gt; Types.this.Type">pre</a>.<a href="#442039" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="String(&quot; &lt;and&gt; &quot;)" class="string">&quot; &lt;and&gt; &quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="469976">kind</a> = <span title="String(&quot;OverloadedType&quot;)" class="string">&quot;OverloadedType&quot;</span>
  <span class="delimiter">}</span>

  /** A class remembering a type instantiation for some a set of overloaded
   *  polymorphic symbols.
   *  Not used after phase `typer`.
   */
  case <span class="keyword">class</span> <a title="class AntiPolyType extends Types.this.Type with Product with Serializable" id="536598">AntiPolyType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><a title="Types.this.Type" id="470100">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="List[Types.this.Type]" id="470101">targs</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="470068">safeToString</a> =
      <a href="#470100" title="=&gt; Types.this.Type">pre</a>.<a href="#442076" title="()String">toString</a> <span title="(x$1: Any)String">+</span> <a href="#470101" title="=&gt; List[Types.this.Type]">targs</a>.<a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;(with type arguments &quot;)" class="string">&quot;(with type arguments &quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="470069">memberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="521631">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#441377" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#470100" title="=&gt; Types.this.Type">pre</a>.<a href="#442039" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#521631" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>, <a href="#470101" title="=&gt; List[Types.this.Type]">targs</a><span class="delimiter">)</span>
//     override def memberType(sym: Symbol) = pre.memberType(sym) match {
//       case PolyType(tparams, restp) =&gt;
//         restp.subst(tparams, targs)
// /* I don't think this is needed, as existential types close only over value types
//       case ExistentialType(tparams, qtpe) =&gt;
//         existentialAbstraction(tparams, qtpe.memberType(sym))
// */
//       case ErrorType =&gt;
//         ErrorType
//     }
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="470070">kind</a> = <span title="String(&quot;AntiPolyType&quot;)" class="string">&quot;AntiPolyType&quot;</span>
  <span class="delimiter">}</span>

  //private var tidCount = 0  //DEBUG

  <span class="keyword">object</span> <a title="Types.this.HasTypeMember.type" id="441333">HasTypeMember</a> <a href="#441334" title="Types.this.HasTypeMember.type" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(name: Types.this.TypeName, tp: Types.this.Type)Types.this.Type" id="521689">apply</a><span class="delimiter">(</span><a title="Types.this.TypeName" id="521692">name</a>: <a href="Names.scala.html#440799" title="Types.this.TypeName">TypeName</a>, <a title="Types.this.Type" id="521693">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="521694">bound</a> = <a href="#441369" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.WildcardType.type*)List[Types.this.WildcardType.type]">List</a><span class="delimiter">(</span><a href="#516414" title="Types.this.WildcardType.type">WildcardType</a><span class="delimiter">)</span>, <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.AliasTypeSymbol" id="521695">bsym</a> = <a href="#521694" title="Types.this.Type">bound</a>.<a href="#441986" title="Types.this.Symbol" id="521714">typeSymbol</a>.<a href="Symbols.scala.html#457616" title="Types.this.Position" id="521717">newAliasType</a><span class="delimiter">(</span><a href="#521692" title="Types.this.TypeName" id="521715">name</a><span class="delimiter">)</span>
      <a href="#521695" title="Types.this.AliasTypeSymbol">bsym</a> <a href="Symbols.scala.html#443429" title="(info: Types.this.Type)bsym.type">setInfo</a> <a href="#521693" title="Types.this.Type">tp</a>
      <a href="#521694" title="Types.this.Type">bound</a>.<a href="#442019" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#447331" title="(sym: Types.this.AliasTypeSymbol)Types.this.AliasTypeSymbol">enter</a> <a href="#521695" title="Types.this.AliasTypeSymbol">bsym</a>
      <a href="#521694" title="Types.this.Type">bound</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Option[(Types.this.TypeName, Types.this.Type)]" id="521690">unapply</a><span class="delimiter">(</span><a title="Types.this.Type" id="521723">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[(Types.this.TypeName, Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>TypeName, Type<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#521723" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> RefinedType<a href="#521751" title="Option[(Types.this.TypeName, Types.this.Type)]" id="521755" class="delimiter">(</a><a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="521785">List</a><span class="delimiter">(</span><a href="#516414" title="Option[(Types.this.TypeName, Types.this.Type)]" id="521763">WildcardType</a><span class="delimiter">)</span>, <a href="Scopes.scala.html#462769" title="Option[Seq[Types.this.Symbol]]" id="521777">Scope</a><span class="delimiter">(</span>sym<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="../../Option.scala.html#64111" title="(x: (Types.this.TypeName, Types.this.Type))Some[(Types.this.TypeName, Types.this.Type)]">Some</a><a href="#521764" title="(x: Option[(Types.this.TypeName, Types.this.Type)])Option[(Types.this.TypeName, Types.this.Type)]" class="delimiter">(</a><a href="../../Tuple2.scala.html#63804" title="(_1: Types.this.TypeName, _2: Types.this.Type)(Types.this.TypeName, Types.this.Type)" class="delimiter">(</a>sym.<a href="Symbols.scala.html#443152" title="=&gt; Types.this.Symbol#NameType">name</a>.<a href="Names.scala.html#444127" title="=&gt; Types.this.TypeName">toTypeName</a>, sym.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt; <a href="#521764" title="(x: Option[(Types.this.TypeName, Types.this.Type)])Option[(Types.this.TypeName, Types.this.Type)]">None</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  // Not used yet.
  <span class="keyword">object</span> <a title="Types.this.HasTypeParams.type" id="441335">HasTypeParams</a> <a href="#441336" title="Types.this.HasTypeParams.type" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Option[(List[Types.this.Symbol], Types.this.Type)]" id="521797">unapply</a><span class="delimiter">(</span><a title="Types.this.Type" id="521799">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[(List[Types.this.Symbol], Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, Type<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#521799" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> AnnotatedType<a href="#521824" title="Option[(List[Types.this.Symbol], Types.this.Type)]" id="521828" class="delimiter">(</a>_, tp, _<span class="delimiter">)</span>        =&gt; <a href="#521797" title="(tp: Types.this.Type)Option[(List[Types.this.Symbol], Types.this.Type)]">unapply</a><a href="#521833" title="(x: Option[(List[Types.this.Symbol], Types.this.Type)])Option[(List[Types.this.Symbol], Types.this.Type)]" class="delimiter">(</a>tp<span class="delimiter">)</span>
      <span class="keyword">case</span> ExistentialType<a href="#521824" title="Option[(List[Types.this.Symbol], Types.this.Type)]" id="521830" class="delimiter">(</a>tparams, qtpe<span class="delimiter">)</span> =&gt; <a href="../../Option.scala.html#64111" title="(x: (List[Types.this.Symbol], Types.this.Type))Some[(List[Types.this.Symbol], Types.this.Type)]">Some</a><a href="#521833" title="(x: Option[(List[Types.this.Symbol], Types.this.Type)])Option[(List[Types.this.Symbol], Types.this.Type)]" class="delimiter">(</a><a href="../../Tuple2.scala.html#63804" title="(_1: List[Types.this.Symbol], _2: Types.this.Type)(List[Types.this.Symbol], Types.this.Type)" class="delimiter">(</a>tparams, qtpe<span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> PolyType<a href="#521824" title="Option[(List[Types.this.Symbol], Types.this.Type)]" id="521832" class="delimiter">(</a>tparams, restpe<span class="delimiter">)</span>      =&gt; <a href="../../Option.scala.html#64111" title="(x: (List[Types.this.Symbol], Types.this.Type))Some[(List[Types.this.Symbol], Types.this.Type)]">Some</a><a href="#521833" title="(x: Option[(List[Types.this.Symbol], Types.this.Type)])Option[(List[Types.this.Symbol], Types.this.Type)]" class="delimiter">(</a><a href="../../Tuple2.scala.html#63804" title="(_1: List[Types.this.Symbol], _2: Types.this.Type)(List[Types.this.Symbol], Types.this.Type)" class="delimiter">(</a>tparams, restpe<span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> _                              =&gt; <a href="#521833" title="(x: Option[(List[Types.this.Symbol], Types.this.Type)])Option[(List[Types.this.Symbol], Types.this.Type)]">None</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  //@M
  // a TypeVar used to be a case class with only an origin and a constr
  // then, constr became mutable (to support UndoLog, I guess),
  // but pattern-matching returned the original constr0 (a bug)
  // now, pattern-matching returns the most recent constr
  <span class="keyword">object</span> <a title="Types.this.TypeVar.type" id="441337">TypeVar</a> <a href="#441338" title="Types.this.TypeVar.type" class="delimiter">{</a>
    @inline <span class="keyword">final</span> <span class="keyword">def</span> <a title="[T](action: String, msg: =&gt; String)(value: T)T" id="470201">trace</a><span class="delimiter">[</span><a title="" id="470203">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="521843">action</a>: <span title="String">String</span>, <a title="=&gt; String" id="521844">msg</a>: =&gt; String<span class="delimiter">)</span><span class="delimiter">(</span><a title="T" id="521845">value</a>: <a href="#470203" title="T">T</a><span class="delimiter">)</span>: <a href="#470203" title="T">T</a> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#441216" title="=&gt; Boolean">traceTypeVars</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="String" id="521847">s</a> = <a href="#521844" title="=&gt; String">msg</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#521850" title="String" id="521853" class="string">&quot;&quot;</a>   =&gt; <a href="#521854" title="(x: String)String" class="string">&quot;&quot;</a>
          <span class="keyword">case</span> str  =&gt; <span title="String(&quot;( &quot;)" class="string">&quot;( &quot;</span> <span title="(x$1: Any)String">+</span> str <a href="#521854" title="(x: String)String">+</a> <span title="String(&quot; )&quot;)" class="string">&quot; )&quot;</span>
        <span class="delimiter">}</span>
        <a href="../../Console.scala.html#227" title="Console.type">Console</a>.<a href="../../Console.scala.html#64272" title="=&gt; java.io.PrintStream">err</a>.<span title="(x$1: String)Unit">println</span><span class="delimiter">(</span><a href="../../Predef.scala.html#8578" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;[%10s] %-25s%s&quot;</a>.<a href="../../collection/immutable/StringLike.scala.html#60730" title="(args: Any*)String">format</a><span class="delimiter">(</span><a href="#521843" title="String">action</a>, <a href="#521845" title="T">value</a>, <a href="#521847" title="String">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#521845" title="T">value</a>
    <span class="delimiter">}</span>

    /** Create a new TypeConstraint based on the given symbol.
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Types.this.TypeConstraint" id="470204">deriveConstraint</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="521869">tparam</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441416" title="Types.this.TypeConstraint">TypeConstraint</a> = <span class="delimiter">{</span>
      /** Must force the type parameter's info at this point
       *  or things don't end well for higher-order type params.
       *  See SI-5359.
       */
      <span class="keyword">val</span> <a title="Types.this.TypeBounds" id="521870">bounds</a>  = <a href="#521869" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>
      /** We can seed the type constraint with the type parameter
       *  bounds as long as the types are concrete.  This should lower
       *  the complexity of the search even if it doesn't improve
       *  any results.
       */
      <span title="Types.this.TypeConstraint" class="keyword">if</span> <span class="delimiter">(</span><a href="#441220" title="=&gt; Boolean">propagateParameterBoundsToTypeVars</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Boolean" id="521871">exclude</a> = <a href="#521870" title="Types.this.TypeBounds">bounds</a>.<a href="#448311" title="=&gt; Boolean">isEmptyBounds</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#521870" title="Types.this.TypeBounds">bounds</a>.<a href="#442055" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#521874" title="Types.this.Type">_</a>.<a href="#441988" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>.<a href="Symbols.scala.html#443235" title="=&gt; Boolean">isNonClassType</a><span class="delimiter">)</span>

        <span title="Types.this.TypeConstraint" class="keyword">if</span> <span class="delimiter">(</span><a href="#521871" title="Boolean">exclude</a><span class="delimiter">)</span> <a href="#470242" title="()Types.this.TypeConstraint" class="keyword">new</a> <a href="#441416" title="Types.this.TypeConstraint">TypeConstraint</a>
        <span class="keyword">else</span> <a href="#441337" title="Types.this.TypeVar.type">TypeVar</a>.<a href="#470201" title="(action: String, msg: =&gt; String)(value: Types.this.TypeConstraint)Types.this.TypeConstraint">trace</a><span class="delimiter">(</span><span title="String(&quot;constraint&quot;)" class="string">&quot;constraint&quot;</span>, <span title="String(&quot;For &quot;)" class="string">&quot;For &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#521869" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443562" title="=&gt; String">fullLocationString</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#470241" title="(bounds: Types.this.TypeBounds)Types.this.TypeConstraint" class="keyword">new</a> <a href="#441416" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">(</span><a href="#521870" title="Types.this.TypeBounds">bounds</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#470242" title="()Types.this.TypeConstraint" class="keyword">new</a> <a href="#441416" title="Types.this.TypeConstraint">TypeConstraint</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]" id="470205">unapply</a><span class="delimiter">(</span><a title="Types.this.TypeVar" id="514301">tv</a>: <a href="#441345" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#910" title="Some[(Types.this.Type, Types.this.TypeConstraint)]">Some</a><span class="delimiter">[</span><span class="delimiter">(</span>Type, TypeConstraint<span class="delimiter">)</span><span class="delimiter">]</span>   = <a href="../../Option.scala.html#64111" title="(x: (Types.this.Type, Types.this.TypeConstraint))Some[(Types.this.Type, Types.this.TypeConstraint)]">Some</a><span class="delimiter">(</span><a href="../../Tuple2.scala.html#63804" title="(_1: Types.this.Type, _2: Types.this.TypeConstraint)(Types.this.Type, Types.this.TypeConstraint)" class="delimiter">(</a><a href="#514301" title="Types.this.TypeVar">tv</a>.<a href="#521840" title="=&gt; Types.this.Type">origin</a>, <a href="#514301" title="Types.this.TypeVar">tv</a>.<a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Types.this.TypeVar" id="470206">untouchable</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="521896">tparam</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441345" title="Types.this.TypeVar">TypeVar</a>                 = <a href="#470211" title="(tparam: Types.this.Symbol, untouchable: Boolean)Types.this.TypeVar">createTypeVar</a><span class="delimiter">(</span><a href="#521896" title="Types.this.Symbol">tparam</a>, untouchable = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Types.this.TypeVar" id="470207">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="470220">tparam</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441345" title="Types.this.TypeVar">TypeVar</a>                       = <a href="#470211" title="(tparam: Types.this.Symbol, untouchable: Boolean)Types.this.TypeVar">createTypeVar</a><span class="delimiter">(</span><a href="#470220" title="Types.this.Symbol">tparam</a>, untouchable = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(origin: Types.this.Type, constr: Types.this.TypeConstraint)Types.this.TypeVar" id="470208">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="470218">origin</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.TypeConstraint" id="470219">constr</a>: <a href="#441416" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">)</span>: <a href="#441345" title="Types.this.TypeVar">TypeVar</a> = <a href="#470209" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">apply</a><span class="delimiter">(</span><a href="#470218" title="Types.this.Type">origin</a>, <a href="#470219" title="Types.this.TypeConstraint">constr</a>, <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar" id="470209">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="470214">origin</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.TypeConstraint" id="470215">constr</a>: <a href="#441416" title="Types.this.TypeConstraint">TypeConstraint</a>, <a title="List[Types.this.Type]" id="470216">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="470217">params</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441345" title="Types.this.TypeVar">TypeVar</a> =
      <a href="#470210" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol], untouchable: Boolean)Types.this.TypeVar">createTypeVar</a><span class="delimiter">(</span><a href="#470214" title="Types.this.Type">origin</a>, <a href="#470215" title="Types.this.TypeConstraint">constr</a>, <a href="#470216" title="List[Types.this.Type]">args</a>, <a href="#470217" title="List[Types.this.Symbol]">params</a>, untouchable = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

    /** This is the only place TypeVars should be instantiated.
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol], untouchable: Boolean)Types.this.TypeVar" id="470210">createTypeVar</a><span class="delimiter">(</span><a title="Types.this.Type" id="521903">origin</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.TypeConstraint" id="521904">constr</a>: <a href="#441416" title="Types.this.TypeConstraint">TypeConstraint</a>, <a title="List[Types.this.Type]" id="521905">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="521906">params</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Boolean" id="521907">untouchable</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="#441345" title="Types.this.TypeVar">TypeVar</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.TypeVar" id="521920">tv</a> = <span class="delimiter">(</span>
        <span title="Types.this.TypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#521905" title="List[Types.this.Type]">args</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#521906" title="List[Types.this.Symbol]">params</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Types.this.TypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#521907" title="Boolean">untouchable</a><span class="delimiter">)</span> <a href="#521921" title="Types.this.TypeVar with Types.this.UntouchableTypeVar" class="keyword">new</a> <a href="#441345" title="anonymous class $anon extends Types.this.TypeVar with Types.this.UntouchableTypeVar" id="521921">TypeVar</a><span class="delimiter">(</span><a href="#521903" title="Types.this.Type">origin</a>, <a href="#521904" title="Types.this.TypeConstraint">constr</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441344" title="Types.this.UntouchableTypeVar">UntouchableTypeVar</a>
          <span class="keyword">else</span> <span title="Types.this.TypeVar" class="keyword">new</span> <a href="#441345" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#521903" title="Types.this.Type">origin</a>, <a href="#521904" title="Types.this.TypeConstraint">constr</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <span title="Types.this.TypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#521905" title="List[Types.this.Type]">args</a>.<a href="../../collection/SeqLike.scala.html#59711" title="=&gt; Int">size</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <a href="#521906" title="List[Types.this.Symbol]">params</a>.<a href="../../collection/SeqLike.scala.html#59711" title="=&gt; Int">size</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Types.this.AppliedTypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#521907" title="Boolean">untouchable</a><span class="delimiter">)</span> <a href="#521940" title="Types.this.AppliedTypeVar with Types.this.UntouchableTypeVar" class="keyword">new</a> <a href="#441343" title="anonymous class $anon extends Types.this.AppliedTypeVar with Types.this.UntouchableTypeVar" id="521940">AppliedTypeVar</a><span class="delimiter">(</span><a href="#521903" title="Types.this.Type">origin</a>, <a href="#521904" title="Types.this.TypeConstraint">constr</a>, <a href="#521906" title="List[Types.this.Symbol]">params</a> <a href="../../collection/IterableLike.scala.html#59486" title="(that: scala.collection.GenIterable[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],(Types.this.Symbol, Types.this.Type),List[(Types.this.Symbol, Types.this.Type)]])List[(Types.this.Symbol, Types.this.Type)]">zip</a> <a href="#521905" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441344" title="Types.this.UntouchableTypeVar">UntouchableTypeVar</a>
          <span class="keyword">else</span> <span title="Types.this.AppliedTypeVar" class="keyword">new</span> <a href="#441343" title="Types.this.AppliedTypeVar">AppliedTypeVar</a><span class="delimiter">(</span><a href="#521903" title="Types.this.Type">origin</a>, <a href="#521904" title="Types.this.TypeConstraint">constr</a>, <a href="#521906" title="List[Types.this.Symbol]">params</a> <a href="../../collection/IterableLike.scala.html#59486" title="(that: scala.collection.GenIterable[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],(Types.this.Symbol, Types.this.Type),List[(Types.this.Symbol, Types.this.Type)]])List[(Types.this.Symbol, Types.this.Type)]">zip</a> <a href="#521905" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <span title="Types.this.HKTypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#521905" title="List[Types.this.Type]">args</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Types.this.HKTypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#521907" title="Boolean">untouchable</a><span class="delimiter">)</span> <a href="#522051" title="Types.this.HKTypeVar with Types.this.UntouchableTypeVar" class="keyword">new</a> <a href="#441342" title="anonymous class $anon extends Types.this.HKTypeVar with Types.this.UntouchableTypeVar" id="522051">HKTypeVar</a><span class="delimiter">(</span><a href="#521903" title="Types.this.Type">origin</a>, <a href="#521904" title="Types.this.TypeConstraint">constr</a>, <a href="#521906" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441344" title="Types.this.UntouchableTypeVar">UntouchableTypeVar</a>
          <span class="keyword">else</span> <span title="Types.this.HKTypeVar" class="keyword">new</span> <a href="#441342" title="Types.this.HKTypeVar">HKTypeVar</a><span class="delimiter">(</span><a href="#521903" title="Types.this.Type">origin</a>, <a href="#521904" title="Types.this.TypeConstraint">constr</a>, <a href="#521906" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <span title="(x$1: String)Error" class="keyword">new</span> <a href="../../package.scala.html#56959" title="Error">Error</a><span class="delimiter">(</span><span title="String(&quot;Invalid TypeVar construction: &quot;)" class="string">&quot;Invalid TypeVar construction: &quot;</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="../../Tuple4.scala.html#73680" title="(_1: Types.this.Type, _2: Types.this.TypeConstraint, _3: List[Types.this.Type], _4: List[Types.this.Symbol])(Types.this.Type, Types.this.TypeConstraint, List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</a><a href="#521903" title="Types.this.Type">origin</a>, <a href="#521904" title="Types.this.TypeConstraint">constr</a>, <a href="#521905" title="List[Types.this.Type]">args</a>, <a href="#521906" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">)</span>

      <a href="#470201" title="(action: String, msg: =&gt; String)(value: Types.this.TypeVar)Types.this.TypeVar">trace</a><span class="delimiter">(</span><span title="String(&quot;create&quot;)" class="string">&quot;create&quot;</span>, <span title="String(&quot;In &quot;)" class="string">&quot;In &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#521920" title="Types.this.TypeVar">tv</a>.<a href="#470194" title="=&gt; String">originLocation</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#521920" title="Types.this.TypeVar">tv</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol, untouchable: Boolean)Types.this.TypeVar" id="470211">createTypeVar</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="521901">tparam</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Boolean" id="521902">untouchable</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="#441345" title="Types.this.TypeVar">TypeVar</a> =
      <a href="#470210" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol], untouchable: Boolean)Types.this.TypeVar">createTypeVar</a><span class="delimiter">(</span><a href="#521901" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443426" title="=&gt; Types.this.Type">tpeHK</a>, <a href="#470204" title="(tparam: Types.this.Symbol)Types.this.TypeConstraint">deriveConstraint</a><span class="delimiter">(</span><a href="#521901" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span>, <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="#521901" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#521902" title="Boolean">untouchable</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Repack existential types, otherwise they sometimes get unpacked in the
   *  wrong location (type inference comes up with an unexpected skolem)
   */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="441339">repackExistential</a><span class="delimiter">(</span><a title="Types.this.Type" id="522370">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">(</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#522370" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="#522370" title="Types.this.Type">tp</a>
    <span class="keyword">else</span> <a href="#441386" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#441341" title="(tpe: Types.this.Type)List[Types.this.Symbol]">existentialsInType</a><span class="delimiter">(</span><a href="#522370" title="Types.this.Type">tp</a><span class="delimiter">)</span>, <a href="#522370" title="Types.this.Type">tp</a><span class="delimiter">)</span>
  <span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(tpe: Types.this.Type)Boolean" id="441340">containsExistential</a><span class="delimiter">(</span><a title="Types.this.Type" id="522386">tpe</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
    <a href="#522386" title="Types.this.Type">tpe</a> <a href="#442055" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#522391" title="Types.this.Type">_</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443254" title="=&gt; Boolean">isExistentiallyBound</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tpe: Types.this.Type)List[Types.this.Symbol]" id="441341">existentialsInType</a><span class="delimiter">(</span><a title="Types.this.Type" id="522376">tpe</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
    <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="522384">tp</a> &lt;- <a href="#515331" title="(f: Types.this.Type =&gt; Types.this.Symbol)List[Types.this.Symbol]">tpe</a> ; <span class="keyword">if</span> <a href="#522384" title="Types.this.Type">tp</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443254" title="=&gt; Boolean">isExistentiallyBound</a><span class="delimiter">)</span> <span class="keyword">yield</span>
      <a href="#522384" title="Types.this.Type">tp</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>
  <span class="delimiter">)</span>

  /** Precondition: params.nonEmpty.  (args.nonEmpty enforced structurally.)
   */
  <span class="keyword">class</span> <a title="class HKTypeVar extends Types.this.TypeVar" id="441342">HKTypeVar</a><a href="#441342" title="Types.this.HKTypeVar" class="delimiter">(</a>
    <a title="Types.this.Type" id="522065">_origin</a>: <a href="#441242" title="Types.this.Type">Type</a>,
    <a title="Types.this.TypeConstraint" id="522066">_constr</a>: <a href="#441416" title="Types.this.TypeConstraint">TypeConstraint</a>,
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="522067">params</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
  <span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441345" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#522065" title="Types.this.Type">_origin</a>, <a href="#522066" title="Types.this.TypeConstraint">_constr</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <a href="../../Predef.scala.html#8464" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#522067" title="=&gt; List[Types.this.Symbol]">params</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a>, <a href="#441342" title="Types.this.HKTypeVar" class="keyword">this</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="522060">isHigherKinded</a>          = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; String" id="522061">typeVarString</a> = <a href="#522067" title="=&gt; List[Types.this.Symbol]">params</a>.<a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.Symbol#NameType)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol#NameType,List[Types.this.Symbol#NameType]])List[Types.this.Symbol#NameType]">map</a><a href="../../collection/immutable/List.scala.html#63282" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.Symbol#NameType,List[Types.this.Symbol#NameType]]" class="delimiter">(</a><a href="#522417" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443152" title="=&gt; x$47.NameType">name</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;]=&gt;&quot;)" class="string">&quot;]=&gt;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#470193" title="=&gt; String">originName</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Precondition: zipped params/args nonEmpty.  (Size equivalence enforced structurally.)
   */
  <span class="keyword">class</span> <a title="class AppliedTypeVar extends Types.this.TypeVar" id="441343">AppliedTypeVar</a><a href="#441343" title="Types.this.AppliedTypeVar" class="delimiter">(</a>
    <a title="Types.this.Type" id="521954">_origin</a>: <a href="#441242" title="Types.this.Type">Type</a>,
    <a title="Types.this.TypeConstraint" id="521955">_constr</a>: <a href="#441416" title="Types.this.TypeConstraint">TypeConstraint</a>,
    <a title="List[(Types.this.Symbol, Types.this.Type)]" id="521956">zippedArgs</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[(Types.this.Symbol, Types.this.Type)]">List</a><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Type<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441345" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#521954" title="Types.this.Type">_origin</a>, <a href="#521955" title="Types.this.TypeConstraint">_constr</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <a href="../../Predef.scala.html#8464" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#521956" title="List[(Types.this.Symbol, Types.this.Type)]">zippedArgs</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a>, <a href="#441343" title="Types.this.AppliedTypeVar" class="keyword">this</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="521948">params</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#521956" title="List[(Types.this.Symbol, Types.this.Type)]">zippedArgs</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: ((Types.this.Symbol, Types.this.Type)) =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Symbol, Types.this.Type)],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</a> <span class="delimiter">(</span><a href="#522474" title="(Types.this.Symbol, Types.this.Type)">_</a>.<a href="../../Tuple2.scala.html#61506" title="=&gt; Types.this.Symbol">_1</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="521949">typeArgs</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#521956" title="List[(Types.this.Symbol, Types.this.Type)]">zippedArgs</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: ((Types.this.Symbol, Types.this.Type)) =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Symbol, Types.this.Type)],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#522512" title="(Types.this.Symbol, Types.this.Type)">_</a>.<a href="../../Tuple2.scala.html#61508" title="=&gt; Types.this.Type">_2</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; String" id="521950">typeVarString</a> = <span class="delimiter">(</span>
      <a href="#521956" title="List[(Types.this.Symbol, Types.this.Type)]">zippedArgs</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: ((Types.this.Symbol, Types.this.Type)) =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Symbol, Types.this.Type)],String,List[String]])List[String]">map</a> <a title="anonymous class $anonfun extends scala.runtime.AbstractFunction1[(Types.this.Symbol, Types.this.Type),String] with Serializable" id="522550" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span>p, a<span class="delimiter">)</span> =&gt; p.<a href="../../Predef.scala.html#8576" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">name</a> <a href="../../runtime/StringAdd.scala.html#60949" title="(other: String)String">+</a> <span title="String(&quot;=&quot;)" class="string">&quot;=&quot;</span> <a href="#522574" title="(x: String)String">+</a> a <span class="delimiter">}</span> <a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a> <span class="delimiter">(</span><a href="../../Predef.scala.html#8576" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">origin</a> <a href="../../runtime/StringAdd.scala.html#60949" title="(other: String)String">+</a> <span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait UntouchableTypeVar extends Types.this.TypeVar" id="441344">UntouchableTypeVar</a> <a href="../../Unit.scala.html#2389" title="Unit" class="keyword">extends</a> <a href="#441345" title="Types.this.TypeVar">TypeVar</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="521926">untouchable</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="521927">isGround</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean" id="521928">registerTypeEquality</a><span class="delimiter">(</span><a title="Types.this.Type" id="522624">tp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Boolean" id="522625">typeVarLHS</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a><span class="delimiter">)</span> = <a href="#522624" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#522630" title="Boolean" id="522632">t</a>: TypeVar <span class="keyword">if</span> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a>t.<a href="#470160" title="=&gt; Boolean">untouchable</a> =&gt;
        t.<a href="#470183" title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean">registerTypeEquality</a><a href="#522633" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#441344" title="Types.this.UntouchableTypeVar" class="keyword">this</a>, <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#522625" title="Boolean">typeVarLHS</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#441344" title="Types.this.UntouchableTypeVar" class="keyword">super</a>.<a href="#470183" title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean">registerTypeEquality</a><a href="#522633" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#522624" title="Types.this.Type">tp</a>, <a href="#522625" title="Boolean">typeVarLHS</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean" id="521929">registerBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="522638">tp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Boolean" id="522639">isLowerBound</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a>, <a title="Boolean" id="522641">isNumericBound</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#522638" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#522644" title="Boolean" id="522646">t</a>: TypeVar <span class="keyword">if</span> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a>t.<a href="#470160" title="=&gt; Boolean">untouchable</a> =&gt;
        t.<a href="#470182" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><a href="#522647" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#441344" title="Types.this.UntouchableTypeVar" class="keyword">this</a>, <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#522639" title="Boolean">isLowerBound</a>, <a href="#522641" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#441344" title="Types.this.UntouchableTypeVar" class="keyword">super</a>.<a href="#470182" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><a href="#522647" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#522638" title="Types.this.Type">tp</a>, <a href="#522639" title="Boolean">isLowerBound</a>, <a href="#522641" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A class representing a type variable: not used after phase `typer`.
   *
   *  A higher-kinded TypeVar has params (Symbols) and typeArgs (Types).
   *  A TypeVar with nonEmpty typeArgs can only be instantiated by a higher-kinded
   *  type that can be applied to those args.  A TypeVar is much like a TypeRef,
   *  except it has special logic for equality and subtyping.
   *
   *  Precondition for this class, enforced structurally: args.isEmpty &amp;&amp; params.isEmpty.
   */
  <span class="keyword">class</span> <a title="class TypeVar extends Types.this.Type" id="441345">TypeVar</a><a href="#441345" title="Types.this.TypeVar" class="delimiter">(</a>
    <span class="keyword">val</span> <a title="Types.this.Type" id="521840">origin</a>: <a href="#441242" title="Types.this.Type">Type</a>,
    <span class="keyword">val</span> <a title="Types.this.TypeConstraint" id="521841">constr0</a>: <a href="#441416" title="Types.this.TypeConstraint">TypeConstraint</a>
  <span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="470160">untouchable</a> = <span title="Boolean(false)" class="keyword">false</span>   // by other typevars
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="470161">params</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="470162">typeArgs</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="470163">isHigherKinded</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** The constraint associated with the variable
     *  Syncnote: Type variables are assumed to be used from only one
     *  thread. They are not exposed in api.Types and are used only locally
     *  in operations that are exposed from types. Hence, no syncing of `constr`
     *  or `encounteredHigherLevel` or `suspended` accesses should be necessary.
     */
    <span class="keyword">var</span> <a title="Types.this.TypeConstraint" id="470165">constr</a> = <a href="#521841" title="=&gt; Types.this.TypeConstraint">constr0</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="470167">instValid</a> = <a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470268" title="=&gt; Boolean">instValid</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="470168">isGround</a> = <a href="#470167" title="=&gt; Boolean">instValid</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470266" title="=&gt; Types.this.Type">inst</a>.<a href="#442080" title="=&gt; Boolean">isGround</a>

    /** The variable's skolemization level */
    <span class="keyword">val</span> <a title="Int" id="470169">level</a> = <a href="#441229" title="=&gt; Int">skolemizationLevel</a>

    /** Two occurrences of a higher-kinded typevar, e.g. `?CC[Int]` and `?CC[String]`, correspond to
     *  ''two instances'' of `TypeVar` that share the ''same'' `TypeConstraint`.
     *
     *  `constr` for `?CC` only tracks type constructors anyway,
     *   so when `?CC[Int] &lt;:&lt; List[Int]` and `?CC[String] &lt;:&lt; Iterable[String]`
     *  `?CC's` hibounds contains List and Iterable.
     */
    <span class="keyword">def</span> <a title="(newArgs: List[Types.this.Type])Types.this.TypeVar" id="470171">applyArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="522656">newArgs</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441345" title="Types.this.TypeVar">TypeVar</a> = <span class="delimiter">(</span>
      <span title="Types.this.TypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#522656" title="List[Types.this.Type]">newArgs</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#470162" title="=&gt; List[Types.this.Type]">typeArgs</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span>
        <a href="#441345" title="Types.this.TypeVar" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.TypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#522656" title="List[Types.this.Type]">newArgs</a>.<a href="../../collection/SeqLike.scala.html#59711" title="=&gt; Int">size</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <a href="#470161" title="=&gt; List[Types.this.Symbol]">params</a>.<a href="../../collection/SeqLike.scala.html#59711" title="=&gt; Int">size</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.TypeVar" id="522664">tv</a> = <a href="#470209" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#521840" title="=&gt; Types.this.Type">origin</a>, <a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>, <a href="#522656" title="List[Types.this.Type]">newArgs</a>, <a href="#470161" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
        <a href="#441337" title="Types.this.TypeVar.type">TypeVar</a>.<a href="#470201" title="(action: String, msg: =&gt; String)(value: Types.this.TypeVar)Types.this.TypeVar">trace</a><span class="delimiter">(</span><span title="String(&quot;applyArgs&quot;)" class="string">&quot;applyArgs&quot;</span>, <span title="String(&quot;In &quot;)" class="string">&quot;In &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#470194" title="=&gt; String">originLocation</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, apply args &quot;)" class="string">&quot;, apply args &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#522656" title="List[Types.this.Type]">newArgs</a>.<a href="../../collection/TraversableOnce.scala.html#59190" title="(sep: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; to &quot;)" class="string">&quot; to &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#470193" title="=&gt; String">originName</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#522664" title="Types.this.TypeVar">tv</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span>
        <span title="Nothing" class="keyword">throw</span> <span title="(x$1: String)Error" class="keyword">new</span> <a href="../../package.scala.html#56959" title="Error">Error</a><span class="delimiter">(</span><span title="String(&quot;Invalid type application in TypeVar: &quot;)" class="string">&quot;Invalid type application in TypeVar: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#470161" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#522656" title="List[Types.this.Type]">newArgs</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    // newArgs.length may differ from args.length (could've been empty before)
    //
    // !!! @PP - I need an example of this, since this exception never triggers
    // even though I am requiring the size match.
    //
    // example: when making new typevars, you start out with C[A], then you replace C by ?C, which should yield ?C[A], then A by ?A, ?C[?A]
    // we need to track a TypeVar's arguments, and map over them (see TypeMap::mapOver)
    // TypeVars get applied to different arguments over time (in asSeenFrom)
     // -- see pos/tcpoly_infer_implicit_tuplewrapper.scala
    // thus: make new TypeVar's for every application of a TV to args,
    // inference may generate several TypeVar's for a single type parameter that must be inferred,
    // only one of them is in the set of tvars that need to be solved, but
    // they share the same TypeConstraint instance

    // When comparing to types containing skolems, remember the highest level
    // of skolemization. If that highest level is higher than our initial
    // skolemizationLevel, we can't re-use those skolems as the solution of this
    // typevar, which means we'll need to repack our constr.inst into a fresh
    // existential.
    // were we compared to skolems at a higher skolemizationLevel?
    // EXPERIMENTAL: value will not be considered unless enableTypeVarExperimentals is true
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Boolean" id="470173">encounteredHigherLevel</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="470175">shouldRepackType</a> = <a href="#441222" title="=&gt; Boolean">enableTypeVarExperimentals</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#470173" title="=&gt; Boolean">encounteredHigherLevel</a>

    // &lt;region name=&quot;constraint mutators + undoLog&quot;&gt;
    // invariant: before mutating constr, save old state in undoLog
    // (undoLog is used to reset constraints to avoid piling up unrelated ones)
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="470176">setInst</a><span class="delimiter">(</span><a title="Types.this.Type" id="522683">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
//      assert(!(tp containsTp this), this)
      <a href="#441231" title="=&gt; Types.this.UndoLog">undoLog</a> <a href="#514535" title="(tv: Types.this.TypeVar)Unit">record</a> <a href="#441345" title="Types.this.TypeVar" class="keyword">this</a>
      // if we were compared against later typeskolems, repack the existential,
      // because skolems are only compatible if they were created at the same level
      <span class="keyword">val</span> <a title="Types.this.Type" id="522684">res</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#470175" title="=&gt; Boolean">shouldRepackType</a><span class="delimiter">)</span> <a href="#441339" title="(tp: Types.this.Type)Types.this.Type">repackExistential</a><span class="delimiter">(</span><a href="#522683" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#522683" title="Types.this.Type">tp</a>
      <a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470266" title="(x$1: Types.this.Type)Unit">inst</a> = <a href="#441337" title="Types.this.TypeVar.type">TypeVar</a>.<a href="#470201" title="(action: String, msg: =&gt; String)(value: Types.this.Type)Types.this.Type">trace</a><span class="delimiter">(</span><span title="String(&quot;setInst&quot;)" class="string">&quot;setInst&quot;</span>, <span title="String(&quot;In &quot;)" class="string">&quot;In &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#470194" title="=&gt; String">originLocation</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#470193" title="=&gt; String">originName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;=&quot;)" class="string">&quot;=&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#522684" title="Types.this.Type">res</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#522684" title="Types.this.Type">res</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="470177">addLoBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="522691">tp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Boolean" id="522693">isNumericBound</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../../Predef.scala.html#8460" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#522691" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#441345" title="Types.this.TypeVar" class="keyword">this</a>, <a href="#522691" title="Types.this.Type">tp</a><span class="delimiter">)</span> // implies there is a cycle somewhere (?)
      //println(&quot;addLoBound: &quot;+(safeToString, debugString(tp))) //DEBUG
      <a href="#441231" title="=&gt; Types.this.UndoLog">undoLog</a> <a href="#514535" title="(tv: Types.this.TypeVar)Unit">record</a> <a href="#441345" title="Types.this.TypeVar" class="keyword">this</a>
      <a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470261" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a><span class="delimiter">(</span><a href="#522691" title="Types.this.Type">tp</a>, <a href="#522693" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="470178">addHiBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="522703">tp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Boolean" id="522705">isNumericBound</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      // assert(tp != this)
      //println(&quot;addHiBound: &quot;+(safeToString, debugString(tp))) //DEBUG
      <a href="#441231" title="=&gt; Types.this.UndoLog">undoLog</a> <a href="#514535" title="(tv: Types.this.TypeVar)Unit">record</a> <a href="#441345" title="Types.this.TypeVar" class="keyword">this</a>
      <a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470263" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a><span class="delimiter">(</span><a href="#522703" title="Types.this.Type">tp</a>, <a href="#522705" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    // &lt;/region&gt;

    // ignore subtyping&amp;equality checks while true -- see findMember
    <span class="keyword">private</span><span class="delimiter">[</span>Types<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Boolean" id="470180">suspended</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Called when a TypeVar is involved in a subtyping check.  Result is whether
     *  this TypeVar could plausibly be a [super/sub]type of argument `tp` and if so,
     *  tracks tp as a [lower/upper] bound of this TypeVar.
     *
     *  if (isLowerBound)   this typevar could be a subtype, track tp as a lower bound
     *  if (!isLowerBound)  this typevar could be a supertype, track tp as an upper bound
     *
     *  If isNumericBound is true, the subtype check is performed with weak_&lt;:&lt; instead of &lt;:&lt;.
     */
    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean" id="470182">registerBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="515718">tp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Boolean" id="515719">isLowerBound</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a>, <a title="Boolean" id="515721">isNumericBound</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      // println(&quot;regBound: &quot;+(safeToString, debugString(tp), isLowerBound)) //@MDEBUG
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#515719" title="Boolean">isLowerBound</a><span class="delimiter">)</span>
        <a href="../../Predef.scala.html#8459" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span><a href="#515718" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#441345" title="Types.this.TypeVar" class="keyword">this</a><span class="delimiter">)</span>

      // side effect: adds the type to upper or lower bounds
      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="522709">addBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="522719">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#515719" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#470177" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a><span class="delimiter">(</span><a href="#522719" title="Types.this.Type">tp</a>, <a href="#515721" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#470178" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a><span class="delimiter">(</span><a href="#522719" title="Types.this.Type">tp</a>, <a href="#515721" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      // swaps the arguments if it's an upper bound
      <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="522710">checkSubtype</a><span class="delimiter">(</span><a title="Types.this.Type" id="522720">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="522721">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="522722">lhs</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#515719" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#522720" title="Types.this.Type">tp1</a> <span class="keyword">else</span> <a href="#522721" title="Types.this.Type">tp2</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="522723">rhs</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#515719" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#522721" title="Types.this.Type">tp2</a> <span class="keyword">else</span> <a href="#522720" title="Types.this.Type">tp1</a>

        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#515721" title="Boolean">isNumericBound</a><span class="delimiter">)</span> <a href="#522722" title="Types.this.Type">lhs</a> <a href="#442061" title="(that: Types.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#522723" title="Types.this.Type">rhs</a>
        <span class="keyword">else</span> <a href="#522722" title="Types.this.Type">lhs</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#522723" title="Types.this.Type">rhs</a>
      <span class="delimiter">}</span>

      /** Simple case: type arguments can be ignored, because either this typevar has
       *  no type parameters, or we are comparing to Any/Nothing.
       *
       *  The latter condition is needed because HK unification is limited to constraints of the shape
       *  {{{
       *    TC1[T1,..., TN] &lt;: TC2[T'1,...,T'N]
       *  }}}
       *  which would preclude the following important constraints:
       *  {{{
       *    Nothing &lt;: ?TC[?T]
       *    ?TC[?T] &lt;: Any
       *  }}}
       */
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="522711">unifySimple</a> = <span class="delimiter">(</span>
        <span class="delimiter">(</span><a href="#470161" title="=&gt; List[Types.this.Symbol]">params</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#515718" title="Types.this.Type">tp</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#515718" title="Types.this.Type">tp</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
          <a href="#522709" title="(tp: Types.this.Type)Unit">addBound</a><span class="delimiter">(</span><a href="#515718" title="Types.this.Type">tp</a><span class="delimiter">)</span>
          <span title="Boolean(true)" class="keyword">true</span>
        <span class="delimiter">}</span>
      <span class="delimiter">)</span>

      /** Full case: involving a check of the form
       *  {{{
       *    TC1[T1,..., TN] &lt;: TC2[T'1,...,T'N]
       *  }}}
       *  Checks subtyping of higher-order type vars, and uses variances as defined in the
       *  type parameter we're trying to infer (the result will be sanity-checked later).
       */
      <span class="keyword">def</span> <a title="(tpe: Types.this.Type)Boolean" id="522712">unifyFull</a><span class="delimiter">(</span><a title="Types.this.Type" id="522736">tpe</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        // The alias/widen variations are often no-ops.
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="522737">tpes</a> = <span class="delimiter">(</span>
          <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#515719" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><a href="#522736" title="Types.this.Type">tpe</a>, <a href="#522736" title="Types.this.Type">tpe</a>.<a href="#441990" title="=&gt; Types.this.Type">widen</a>, <a href="#522736" title="Types.this.Type">tpe</a>.<a href="#442018" title="=&gt; Types.this.Type">dealias</a>, <a href="#522736" title="Types.this.Type">tpe</a>.<a href="#441990" title="=&gt; Types.this.Type">widen</a>.<a href="#442018" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span>.<a href="../../collection/SeqLike.scala.html#59789" title="=&gt; List[Types.this.Type]">distinct</a>
          <span class="keyword">else</span> <a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><a href="#522736" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
        <span class="delimiter">)</span>
        <a href="#522737" title="List[Types.this.Type]">tpes</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">{</span> <a title="Types.this.Type" id="522759">tp</a> =&gt;
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="522760">lhs</a> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#515719" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#522759" title="Types.this.Type">tp</a>.<a href="#442000" title="=&gt; List[Types.this.Type]">typeArgs</a> <span class="keyword">else</span> <a href="#470162" title="=&gt; List[Types.this.Type]">typeArgs</a>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="522761">rhs</a> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#515719" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#470162" title="=&gt; List[Types.this.Type]">typeArgs</a> <span class="keyword">else</span> <a href="#522759" title="Types.this.Type">tp</a>.<a href="#442000" title="=&gt; List[Types.this.Type]">typeArgs</a>

          <a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#522760" title="List[Types.this.Type]">lhs</a>, <a href="#522761" title="List[Types.this.Type]">rhs</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
            // this is a higher-kinded type var with same arity as tp.
            // side effect: adds the type constructor itself as a bound
            <a href="#522709" title="(tp: Types.this.Type)Unit">addBound</a><span class="delimiter">(</span><a href="#522759" title="Types.this.Type">tp</a>.<a href="#441999" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>
            <a href="#441521" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean">isSubArgs</a><span class="delimiter">(</span><a href="#522760" title="List[Types.this.Type]">lhs</a>, <a href="#522761" title="List[Types.this.Type]">rhs</a>, <a href="#470161" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      // There's a &lt;: test taking place right now, where tp is a concrete type and this is a typevar
      // attempting to satisfy that test. Either the test will be unsatisfiable, in which case
      // registerBound will return false; or the upper or lower bounds of this type var will be
      // supplemented with the type being tested against.
      //
      // Eventually the types which have accumulated in the upper and lower bounds will be lubbed
      // (resp. glbbed) to instantiate the typevar.
      //
      // The only types which are eligible for unification are those with the same number of
      // typeArgs as this typevar, or Any/Nothing, which are kind-polymorphic. For the upper bound,
      // any parent or base type of `tp` may be tested here (leading to a corresponding relaxation
      // in the upper bound.) The universe of possible glbs, being somewhat more infinite, is not
      // addressed here: all lower bounds are retained and their intersection calculated when the
      // bounds are solved.
      //
      // In a side-effect free universe, checking tp and tp.parents beofre checking tp.baseTypeSeq
      // would be pointless. In this case, each check we perform causes us to lose specificity: in
      // the end the best we'll do is the least specific type we tested against, since the typevar
      // does not see these checks as &quot;probes&quot; but as requirements to fulfill.
      // TODO: can the `suspended` flag be used to poke around without leaving a trace?
      //
      // So the strategy used here is to test first the type, then the direct parents, and finally
      // to fall back on the individual base types. This warrants eventual re-examination.

      // AM: I think we could use the `suspended` flag to avoid side-effecting during unification
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#470180" title="=&gt; Boolean">suspended</a><span class="delimiter">)</span>         // constraint accumulation is disabled
        <a href="#522710" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">checkSubtype</a><span class="delimiter">(</span><a href="#515718" title="Types.this.Type">tp</a>, <a href="#521840" title="=&gt; Types.this.Type">origin</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470268" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span>  // type var is already set
        <a href="#522710" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">checkSubtype</a><span class="delimiter">(</span><a href="#515718" title="Types.this.Type">tp</a>, <a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470266" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#470187" title="(tp: Types.this.Type)Boolean">isRelatable</a><span class="delimiter">(</span><a href="#515718" title="Types.this.Type">tp</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
        <a href="#522711" title="=&gt; Boolean">unifySimple</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#522712" title="(tpe: Types.this.Type)Boolean">unifyFull</a><span class="delimiter">(</span><a href="#515718" title="Types.this.Type">tp</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span>
          // only look harder if our gaze is oriented toward Any
          <a href="#515719" title="Boolean">isLowerBound</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span>
            <span class="delimiter">(</span><a href="#515718" title="Types.this.Type">tp</a>.<a href="#441995" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#522712" title="(tpe: Types.this.Type)Boolean">unifyFull</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span>
              // @PP: Is it going to be faster to filter out the parents we just checked?
              // That's what's done here but I'm not sure it matters.
              <a href="#515718" title="Types.this.Type">tp</a>.<a href="#442066" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#447204" title="=&gt; List[Types.this.Type]">toList</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Type]">tail</a> <a href="../../collection/TraversableLike.scala.html#58982" title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</a> <span class="delimiter">(</span><a href="#515718" title="Types.this.Type">tp</a>.<a href="#441995" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/SeqLike.scala.html#59768" title="(elem: Any)Boolean">contains</a> <a href="#522803" title="Types.this.Type">_</a><span class="delimiter">)</span> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#522712" title="(tpe: Types.this.Type)Boolean">unifyFull</a>
            <span class="delimiter">)</span>
          <span class="delimiter">)</span>
        <span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean" id="470183">registerTypeEquality</a><span class="delimiter">(</span><a title="Types.this.Type" id="522626">tp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Boolean" id="522627">typeVarLHS</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      //println(&quot;regTypeEq: &quot;+(safeToString, debugString(tp), typeVarLHS)) //@MDEBUG
      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="522813">checkIsSameType</a><span class="delimiter">(</span><a title="Types.this.Type" id="522814">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
        <span title="Boolean" class="keyword">if</span><span class="delimiter">(</span><a href="#522627" title="Boolean">typeVarLHS</a><span class="delimiter">)</span> <a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470266" title="=&gt; Types.this.Type">inst</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#522814" title="Types.this.Type">tp</a>
        <span class="keyword">else</span>           <a href="#522814" title="Types.this.Type">tp</a>          <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470266" title="=&gt; Types.this.Type">inst</a>

      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#470180" title="=&gt; Boolean">suspended</a><span class="delimiter">)</span> <a href="#522626" title="Types.this.Type">tp</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#521840" title="=&gt; Types.this.Type">origin</a>
      <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470268" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#522813" title="(tp: Types.this.Type)Boolean">checkIsSameType</a><span class="delimiter">(</span><a href="#522626" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#470187" title="(tp: Types.this.Type)Boolean">isRelatable</a><span class="delimiter">(</span><a href="#522626" title="Types.this.Type">tp</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="522819">newInst</a> = <a href="#522821" title="(tp: Types.this.Type)Types.this.Type">wildcardToTypeVarMap</a><span class="delimiter">(</span><a href="#522626" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a> <a href="#470264" title="(tp: Types.this.Type)Boolean">isWithinBounds</a> <a href="#522819" title="Types.this.Type">newInst</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span> <a href="#470176" title="(tp: Types.this.Type)Unit">setInst</a><span class="delimiter">(</span><a href="#522626" title="Types.this.Type">tp</a><span class="delimiter">)</span>; <span title="Boolean(true)" class="keyword">true</span> <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /**
     * `?A.T =:= tp` is rewritten as the constraint `?A &lt;: {type T = tp}`
     *
     * TODO: make these constraints count (incorporate them into implicit search in `applyImplicitArgs`)
     * (`T` corresponds to @param sym)
     */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, tp: Types.this.Type)Boolean" id="470184">registerTypeSelection</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="522827">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="522828">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      <a href="#470182" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#521689" title="(name: Types.this.TypeName, tp: Types.this.Type)Types.this.Type">HasTypeMember</a><span class="delimiter">(</span><a href="#522827" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym.NameType">name</a>.<a href="Names.scala.html#444127" title="=&gt; Types.this.TypeName">toTypeName</a>, <a href="#522828" title="Types.this.Type">tp</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="470185">isSkolemAboveLevel</a><span class="delimiter">(</span><a title="Types.this.Type" id="522771">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#522771" title="Types.this.Type">tp</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#522778" title="Boolean" id="522780">ts</a>: TypeSkolem =&gt; ts.<a href="Symbols.scala.html#462659" title="=&gt; Int">level</a> <a href="#522781" title="(x: Boolean)Boolean">&gt;</a> <a href="#470169" title="=&gt; Int">level</a>
      <span class="keyword">case</span> _              =&gt; <a href="#522781" title="(x: Boolean)Boolean" class="keyword">false</a>
    <span class="delimiter">}</span>
    // side-effects encounteredHigherLevel
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="470186">containsSkolemAboveLevel</a><span class="delimiter">(</span><a title="Types.this.Type" id="522769">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
      <span class="delimiter">(</span><a href="#522769" title="Types.this.Type">tp</a> <a href="#442055" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#470185" title="(tp: Types.this.Type)Boolean">isSkolemAboveLevel</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span> <a href="#470173" title="(x$1: Boolean)Unit">encounteredHigherLevel</a> = <span title="Boolean(true)" class="keyword">true</span> ; <span title="Boolean(true)" class="keyword">true</span> <span class="delimiter">}</span>

     /** Can this variable be related in a constraint to type `tp`?
      *  This is not the case if `tp` contains type skolems whose
      *  skolemization level is higher than the level of this variable.
      */
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="470187">isRelatable</a><span class="delimiter">(</span><a title="Types.this.Type" id="522768">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
         <a href="#470175" title="=&gt; Boolean">shouldRepackType</a>               // short circuit if we already know we've seen higher levels
      <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#470186" title="(tp: Types.this.Type)Boolean">containsSkolemAboveLevel</a><span class="delimiter">(</span><a href="#522768" title="Types.this.Type">tp</a><span class="delimiter">)</span>  // side-effects tracking boolean
      <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#441222" title="=&gt; Boolean">enableTypeVarExperimentals</a>     // -Xexperimental: always say we're relatable, track consequences
    <span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="470188">normalize</a>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">(</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470268" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470266" title="=&gt; Types.this.Type">inst</a>
      // get here when checking higher-order subtyping of the typevar by itself
      // TODO: check whether this ever happens?
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#470163" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#441385" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#470161" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#470171" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#470161" title="=&gt; List[Types.this.Symbol]">params</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#522849" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443444" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#441345" title="Types.this.TypeVar" class="keyword">super</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a>
    <span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="470189">typeSymbol</a> = <a href="#521840" title="=&gt; Types.this.Type">origin</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="470190">isStable</a> = <a href="#521840" title="=&gt; Types.this.Type">origin</a>.<a href="#441973" title="=&gt; Boolean">isStable</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="470191">isVolatile</a> = <a href="#521840" title="=&gt; Types.this.Type">origin</a>.<a href="#441974" title="=&gt; Boolean">isVolatile</a>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)String" id="470192">tparamsOfSym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="522274">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#522274" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> PolyType<a href="#522324" title="String" id="522327" class="delimiter">(</a>tparams, _<span class="delimiter">)</span> <span class="keyword">if</span> tparams.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a> =&gt;
        tparams <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],String,List[String]])List[String]">map</a> <span class="delimiter">(</span><a href="#522292" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443568" title="=&gt; String">defString</a><span class="delimiter">)</span> <a href="#522328" title="(x: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt; <a href="#522328" title="(x: String)String" class="string">&quot;&quot;</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="=&gt; String" id="470193">originName</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="522096">name</a> = <a href="#521840" title="=&gt; Types.this.Type">origin</a>.<a href="#441988" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>.<a href="Symbols.scala.html#443388" title="=&gt; String">decodedName</a>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#522096" title="String">name</a> <span title="(x$1: CharSequence)Boolean">contains</span> <span title="String(&quot;_$&quot;)" class="string">&quot;_$&quot;</span><span class="delimiter">)</span> <a href="#521840" title="=&gt; Types.this.Type">origin</a>.<a href="#441988" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>.<a href="Symbols.scala.html#443388" title="=&gt; String">decodedName</a> <span class="keyword">else</span> <a href="#522096" title="String">name</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="=&gt; String" id="470194">originLocation</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="522172">sym</a>  = <a href="#521840" title="=&gt; Types.this.Type">origin</a>.<a href="#441988" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="522173">encl</a> = <a href="#522172" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#443505" title="=&gt; Types.this.Symbol">logicallyEnclosingMember</a>

      // This should display somewhere between one and three
      // things which enclose the origin: at most, a class, a
      // a method, and a term.  At least, a class.
      <a href="../../collection/immutable/List.scala.html#63291" title="(xs: Option[Types.this.Symbol]*)List[Option[Types.this.Symbol]]">List</a><span class="delimiter">(</span>
        <a href="../../Option.scala.html#64111" title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</a><span class="delimiter">(</span><a href="#522173" title="Types.this.Symbol">encl</a>.<a href="Symbols.scala.html#443480" title="=&gt; Types.this.Symbol">enclClass</a><span class="delimiter">)</span>,
        <span title="Option[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#522173" title="Types.this.Symbol">encl</a>.<a href="Symbols.scala.html#443282" title="=&gt; Boolean">isMethod</a><span class="delimiter">)</span> <a href="../../Option.scala.html#64111" title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</a><span class="delimiter">(</span><a href="#522173" title="Types.this.Symbol">encl</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="../../Option.scala.html#2498" title="None.type">None</a>,
        <span title="Option[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#522172" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#443229" title="=&gt; Boolean">isTerm</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#522172" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#522173" title="Types.this.Symbol">encl</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Option.scala.html#64111" title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</a><span class="delimiter">(</span><a href="#522172" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="../../Option.scala.html#2498" title="None.type">None</a>
      <span class="delimiter">)</span>.<a href="../../collection/generic/GenericTraversableTemplate.scala.html#59386" title="(implicit asTraversable: Option[Types.this.Symbol] =&gt; scala.collection.GenTraversableOnce[Types.this.Symbol])List[Types.this.Symbol]">flatten</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],String,List[String]])List[String]">map</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="522273">s</a> =&gt; <a href="#522273" title="Types.this.Symbol">s</a>.<a href="Symbols.scala.html#443388" title="=&gt; String">decodedName</a> <span title="(x$1: Any)String">+</span> <a href="#470192" title="(sym: Types.this.Symbol)String">tparamsOfSym</a><span class="delimiter">(</span><a href="#522273" title="Types.this.Symbol">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../collection/TraversableOnce.scala.html#59190" title="(sep: String)String">mkString</a> <span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span>
    <span class="delimiter">}</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Any" id="470195">levelString</a> = <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456422" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">explaintypes</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#470169" title="=&gt; Int">level</a> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; String" id="470196">typeVarString</a> = <a href="#470193" title="=&gt; String">originName</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="470197">safeToString</a> = <span class="delimiter">(</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470266" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;TVar&lt;&quot;)" class="string">&quot;TVar&lt;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#470193" title="=&gt; String">originName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;=null&gt;&quot;)" class="string">&quot;=null&gt;&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470266" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470266" title="=&gt; Types.this.Type">inst</a>
      <span class="keyword">else</span> <span class="delimiter">(</span><span title="String" class="keyword">if</span><span class="delimiter">(</span><a href="#470160" title="=&gt; Boolean">untouchable</a><span class="delimiter">)</span> <span title="String(&quot;!?&quot;)" class="string">&quot;!?&quot;</span> <span class="keyword">else</span> <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#470195" title="=&gt; Any">levelString</a> <span title="(x$1: Any)String">+</span> <a href="#470193" title="=&gt; String">originName</a>
    <span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="470198">kind</a> = <span title="String(&quot;TypeVar&quot;)" class="string">&quot;TypeVar&quot;</span>

    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeVar" id="470199">cloneInternal</a> = <span class="delimiter">{</span>
      // cloning a suspended type variable when it's suspended will cause the clone
      // to never be resumed with the current implementation
      <a href="../../Predef.scala.html#8460" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#470180" title="=&gt; Boolean">suspended</a>, <a href="#441345" title="Types.this.TypeVar" class="keyword">this</a><span class="delimiter">)</span>
      <a href="#441337" title="Types.this.TypeVar.type">TypeVar</a>.<a href="#470201" title="(action: String, msg: =&gt; String)(value: Types.this.TypeVar)Types.this.TypeVar">trace</a><span class="delimiter">(</span><span title="String(&quot;clone&quot;)" class="string">&quot;clone&quot;</span>, <a href="#470194" title="=&gt; String">originLocation</a><span class="delimiter">)</span><span class="delimiter">(</span>
        <a href="#470209" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#521840" title="=&gt; Types.this.Type">origin</a>, <a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a> <a href="#470269" title="=&gt; Types.this.TypeConstraint">cloneInternal</a>, <a href="#470162" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#470161" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span> // @M TODO: clone args/params?
      <span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A type carrying some annotations. Created by the typechecker
   *  when eliminating ''Annotated'' trees (see typedAnnotated).
   *
   *  @param annotations the list of annotations on the type
   *  @param underlying the type without the annotation
   *  @param selfsym a &quot;self&quot; symbol with type `underlying`;
   *    only available if -Yself-in-annots is turned on. Can be `NoSymbol`
   *    if it is not used.
   */
  case <span class="keyword">class</span> <a title="class AnnotatedType extends Types.this.Type with Types.this.RewrappingTypeProxy with Product with Serializable" id="445558">AnnotatedType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="470418">annotations</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span>,
                           <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="470419">underlying</a>: <a href="#441242" title="Types.this.Type">Type</a>,
                           <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Symbol" id="470420">selfsym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="#441238" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a> <span class="delimiter">{</span>

    <a href="../../Predef.scala.html#8460" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#470418" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#470419" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.AnnotatedType" id="445542">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="522897">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#470418" title="List[Types.this.AnnotationInfo]" id="522915">copy</a><span class="delimiter">(</span>underlying = <a href="#522897" title="Types.this.Type" id="522913">tp</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="445543">isTrivial</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#445544" title="=&gt; Boolean">isTrivial0</a>
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="445545">isTrivial0</a> = <a href="#470419" title="=&gt; Types.this.Type">underlying</a>.<a href="#441971" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#470418" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.AnnotationInfo =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a href="#522924" title="Types.this.AnnotationInfo">_</a>.<a href="AnnotationInfos.scala.html#443796" title="=&gt; Boolean">isTrivial</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="445546">safeToString</a> = <a href="#470418" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><a href="../../Predef.scala.html#8576" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">underlying</a> <a href="../../runtime/StringAdd.scala.html#60949" title="(other: String)String">+</a> <span title="String(&quot; @&quot;)" class="string">&quot; @&quot;</span>, <span title="String(&quot; @&quot;)" class="string">&quot; @&quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(p: Types.this.AnnotationInfo =&gt; Boolean)Types.this.Type" id="445547">filterAnnotations</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo =&gt; Boolean" id="522932">p</a>: AnnotationInfo =&gt; Boolean<span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#522954" title="(x: (List[Types.this.AnnotationInfo], List[Types.this.AnnotationInfo]))(List[Types.this.AnnotationInfo], List[Types.this.AnnotationInfo])" class="delimiter">(</a><a href="../../Tuple2.scala.html#61506" title="List[Types.this.AnnotationInfo]" id="522936">yes</a>, <a href="../../Tuple2.scala.html#61508" title="List[Types.this.AnnotationInfo]" id="522937">no</a><span class="delimiter">)</span> = <a href="#470418" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a> <a href="../../collection/TraversableLike.scala.html#58988" title="(p: Types.this.AnnotationInfo =&gt; Boolean)(List[Types.this.AnnotationInfo], List[Types.this.AnnotationInfo])">partition</a> <a href="#522932" title="Types.this.AnnotationInfo =&gt; Boolean">p</a>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#522936" title="List[Types.this.AnnotationInfo]">yes</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#470419" title="=&gt; Types.this.Type">underlying</a>
      <span class="keyword">else</span> <span title="Types.this.AnnotatedType" class="keyword">if</span> <span class="delimiter">(</span><a href="#522937" title="List[Types.this.AnnotationInfo]">no</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#445558" title="Types.this.AnnotatedType" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#445558" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">copy</a><span class="delimiter">(</span>annotations = <a href="#522936" title="List[Types.this.AnnotationInfo]">yes</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="445548">setAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="522961">annots</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#522961" title="List[Types.this.AnnotationInfo]">annots</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#470419" title="=&gt; Types.this.Type">underlying</a>
      <span class="keyword">else</span> <a href="#445558" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">copy</a><span class="delimiter">(</span>annotations = <a href="#522961" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span>

    /** Add a number of annotations to this type */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="445549">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="522964">annots</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
      <span title="Types.this.AnnotatedType" class="keyword">if</span> <span class="delimiter">(</span><a href="#522964" title="List[Types.this.AnnotationInfo]">annots</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#445558" title="Types.this.AnnotatedType" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#445558" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">copy</a><span class="delimiter">(</span><a href="#522964" title="List[Types.this.AnnotationInfo]">annots</a> <a href="../../collection/immutable/List.scala.html#63646" title="(prefix: List[Types.this.AnnotationInfo])List[Types.this.AnnotationInfo]">:::</a> <a href="#445558" title="AnnotatedType.this.type" class="keyword">this</a>.<a href="#470418" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a><span class="delimiter">)</span>

    /** Remove any annotations from this type.
     *  TODO - is it allowed to nest AnnotatedTypes? If not then let's enforce
     *  that at creation.  At the moment if they do ever turn up nested this
     *  recursively calls withoutAnnotations.
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="445550">withoutAnnotations</a> = <a href="#470419" title="=&gt; Types.this.Type">underlying</a>.<a href="#442086" title="=&gt; Types.this.Type">withoutAnnotations</a>

    /** Set the self symbol */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.AnnotatedType" id="445551">withSelfsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="522978">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#470418" title="List[Types.this.AnnotationInfo]" id="522983">copy</a><span class="delimiter">(</span>selfsym = <a href="#522978" title="Types.this.Symbol" id="522981">sym</a><span class="delimiter">)</span>

    /** Drop the annotations on the bounds, unless the low and high
     *  bounds are exactly tp.
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="445552">bounds</a>: <a href="#448315" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#470419" title="=&gt; Types.this.Type">underlying</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> TypeBounds<span class="delimiter">(</span>_: <span class="keyword">this</span>.<span class="keyword">type</span>, _: <span class="keyword">this</span>.<span class="keyword">type</span><span class="delimiter">)</span> =&gt; <a href="#448285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><a href="#522993" title="(x: Types.this.TypeBounds)Types.this.TypeBounds" class="delimiter">(</a><a href="#445558" title="Types.this.AnnotatedType" class="keyword">this</a>, <a href="#445558" title="Types.this.AnnotatedType" class="keyword">this</a><span class="delimiter">)</span>
      <span class="keyword">case</span> oftp                                   =&gt; <a href="#522993" title="(x: Types.this.TypeBounds)Types.this.TypeBounds">oftp</a>
    <span class="delimiter">}</span>

    // ** Replace formal type parameter symbols with actual type arguments. * /
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.AnnotatedType" id="445553">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="522998">formals</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="522999">actuals</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="523002">annotations1</a> = <a href="#470418" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.AnnotationInfo =&gt; Types.this.AnnotationInfo)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.AnnotationInfo],Types.this.AnnotationInfo,List[Types.this.AnnotationInfo]])List[Types.this.AnnotationInfo]">map</a><a href="../../collection/immutable/List.scala.html#63282" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.AnnotationInfo,List[Types.this.AnnotationInfo]]" class="delimiter">(</a><a title="Types.this.AnnotationInfo" id="523020">info</a> =&gt; <a href="AnnotationInfos.scala.html#443059" title="(atp: Types.this.Type, args: List[Types.this.Tree], assocs: List[(Types.this.Name, Types.this.ClassfileAnnotArg)])Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">(</span><a href="#523020" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#443791" title="=&gt; Types.this.Type">atp</a>.<a href="#442014" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span>
          <a href="#522998" title="List[Types.this.Symbol]">formals</a>, <a href="#522999" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>, <a href="#523020" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#443792" title="=&gt; List[Types.this.Tree]">args</a>, <a href="#523020" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#443793" title="=&gt; List[(Types.this.Name, Types.this.ClassfileAnnotArg)]">assocs</a><span class="delimiter">)</span>.<a href="AnnotationInfos.scala.html#443802" title="(pos: scala.tools.nsc.util.Position)Types.this.AnnotationInfo">setPos</a><span class="delimiter">(</span><a href="#523020" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#443801" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="523003">underlying1</a> = <a href="#470419" title="=&gt; Types.this.Type">underlying</a>.<a href="#442014" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#522998" title="List[Types.this.Symbol]">formals</a>, <a href="#522999" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
      <span title="Types.this.AnnotatedType" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#523002" title="List[Types.this.AnnotationInfo]">annotations1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#470418" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#523003" title="Types.this.Type">underlying1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#470419" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#445558" title="Types.this.AnnotatedType" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#445558" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#523002" title="List[Types.this.AnnotationInfo]">annotations1</a>, <a href="#523003" title="Types.this.Type">underlying1</a>, <a href="#470420" title="=&gt; Types.this.Symbol">selfsym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Return the base type sequence of tp, dropping the annotations, unless the base type sequence of tp
      * is precisely tp itself. */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="445554">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#441719" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
       <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="523063">oftp</a> = <a href="#470419" title="=&gt; Types.this.Type">underlying</a>.<a href="#442066" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
       <span title="Types.this.BaseTypeSeq" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#523063" title="Types.this.BaseTypeSeq">oftp</a>.<a href="BaseTypeSeqs.scala.html#447198" title="=&gt; Int">length</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="BaseTypeSeqs.scala.html#447201" title="(i: Int)Types.this.Type">oftp</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#470419" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span>
         <a href="BaseTypeSeqs.scala.html#441722" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">baseTypeSingletonSeq</a><span class="delimiter">(</span><a href="#445558" title="Types.this.AnnotatedType" class="keyword">this</a><span class="delimiter">)</span>
       <span class="keyword">else</span>
         <a href="#523063" title="Types.this.BaseTypeSeq">oftp</a>
     <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="445555">kind</a> = <span title="String(&quot;AnnotatedType&quot;)" class="string">&quot;AnnotatedType&quot;</span>
  <span class="delimiter">}</span>

  /** Creator for AnnotatedTypes.  It returns the underlying type if annotations.isEmpty
   *  rather than walking into the assertion.
   */
  <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.Type" id="441349">annotatedType</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="516207">annots</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span>, <a title="Types.this.Type" id="516208">underlying</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="516211">selfsym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#516207" title="List[Types.this.AnnotationInfo]">annots</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#516208" title="Types.this.Type">underlying</a>
    <span class="keyword">else</span> <a href="#445558" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#516207" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#516208" title="Types.this.Type">underlying</a>, <a href="#516211" title="Types.this.Symbol">selfsym</a><span class="delimiter">)</span>

  <span class="keyword">object</span> <a title="Types.this.AnnotatedType.type" id="523116">AnnotatedType</a> <a href="#441348" title="Types.this.AnnotatedType.type" class="keyword">extends</a> <a href="../api/Types.scala.html#23529" title="Types.this.AnnotatedTypeExtractor">AnnotatedTypeExtractor</a> <span class="delimiter">{</span> <span class="delimiter">}</span>

  /** A class representing types with a name. When an application uses
   *  named arguments, the named argument types for calling isApplicable
   *  are represented as NamedType.
   */
  case <span class="keyword">class</span> <a title="class NamedType extends Types.this.Type with Product with Serializable" id="536631">NamedType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><a title="Types.this.Name" id="536606">name</a>: <a href="Names.scala.html#440792" title="Types.this.Name">Name</a>, <a title="Types.this.Type" id="536607">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="523124">safeToString</a>: <span title="String">String</span> = <a href="#536606" title="=&gt; Types.this.Name">name</a>.<a href="../../Function1.scala.html#59562" title="()String">toString</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;: &quot;)" class="string">&quot;: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#536607" title="=&gt; Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  /** A De Bruijn index referring to a previous type argument. Only used
   *  as a serialization format.
   */
  case <span class="keyword">class</span> <a title="class DeBruijnIndex extends Types.this.Type with Product with Serializable" id="536635">DeBruijnIndex</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><a title="Int" id="524470">level</a>: <a href="../../Int.scala.html#508" title="Int">Int</a>, <a title="Int" id="524471">idx</a>: <a href="../../Int.scala.html#508" title="Int">Int</a>, <a title="List[Types.this.Type]" id="524472">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="523188">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;De Bruijn index(&quot;)" class="string">&quot;De Bruijn index(&quot;</span><span title="(x$1: Any)String">+</span><a href="#524470" title="=&gt; Int">level</a><span title="(x$1: Any)String">+</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span title="(x$1: Any)String">+</span><a href="#524471" title="=&gt; Int">idx</a><span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
  <span class="delimiter">}</span>

  /** A binder defining data associated with De Bruijn indices. Only used
   *  as a serialization format.
   */
  case <span class="keyword">class</span> <a title="class DeBruijnBinder extends Types.this.Type with Product with Serializable" id="536639">DeBruijnBinder</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><a title="List[Types.this.Name]" id="524322">pnames</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Name]">List</a><span class="delimiter">[</span>Name<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="524323">ptypes</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Type" id="524324">restpe</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="523268">safeToString</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="523280">kind</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#524322" title="=&gt; List[Types.this.Name]">pnames</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Name">head</a>.<a href="Names.scala.html#444125" title="=&gt; Boolean">isTypeName</a><span class="delimiter">)</span> <span title="String(&quot;poly&quot;)" class="string">&quot;poly&quot;</span> <span class="keyword">else</span> <span title="String(&quot;method&quot;)" class="string">&quot;method&quot;</span>
      <span title="String(&quot;De Bruijn &quot;)" class="string">&quot;De Bruijn &quot;</span><span title="(x$1: Any)String">+</span><a href="#523280" title="String">kind</a><span title="(x$1: Any)String">+</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span><span title="(x$1: Any)String">+</span><span class="delimiter">(</span><a href="#524322" title="=&gt; List[Types.this.Name]">pnames</a> <a href="../../collection/TraversableOnce.scala.html#59190" title="(sep: String)String">mkString</a> <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span title="(x$1: Any)String">+</span><span title="String(&quot;;&quot;)" class="string">&quot;;&quot;</span><span title="(x$1: Any)String">+</span><span class="delimiter">(</span><a href="#524323" title="=&gt; List[Types.this.Type]">ptypes</a> <a href="../../collection/TraversableOnce.scala.html#59190" title="(sep: String)String">mkString</a> <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span title="(x$1: Any)String">+</span><span title="String(&quot;;&quot;)" class="string">&quot;;&quot;</span><span title="(x$1: Any)String">+</span><a href="#524324" title="=&gt; Types.this.Type">restpe</a><span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#523375" title="class ErasedValueType extends Types.this.Type with Product with Serializable" id="523419">ErasedValueType</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><a title="Types.this.Symbol" id="523352">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="523349">safeToString</a> = <a href="#523352" title="=&gt; Types.this.Symbol">sym</a>.<a href="../../Predef.scala.html#8576" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">name</a><a href="../../runtime/StringAdd.scala.html#60949" title="(other: String)String">+</a><span title="String(&quot;$unboxed&quot;)" class="string">&quot;$unboxed&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueErasedValueType extends Types.this.ErasedValueType with Types.this.UniqueType" id="441362">UniqueErasedValueType</a><a href="#441362" title="Types.this.UniqueErasedValueType" class="delimiter">(</a><a title="Types.this.Symbol" id="523410">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#523419" title="Types.this.ErasedValueType">ErasedValueType</a><span class="delimiter">(</span><a href="#523410" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#441243" title="Types.this.UniqueType">UniqueType</a>

  <span class="keyword">object</span> <a title="Types.this.ErasedValueType.type" id="523434">ErasedValueType</a> <a href="#441361" title="Types.this.ErasedValueType.type" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="523412">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="523415">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
      <a href="#441408" title="(tp: Types.this.UniqueErasedValueType)Types.this.UniqueErasedValueType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueErasedValueType" class="keyword">new</span> <a href="#441362" title="Types.this.UniqueErasedValueType">UniqueErasedValueType</a><span class="delimiter">(</span><a href="#523415" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** A class representing an as-yet unevaluated type.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class LazyType extends Types.this.Type" id="441363">LazyType</a> <a href="#441363" title="Types.this.LazyType" class="keyword">extends</a> <a href="#441242" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="454355">isComplete</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="454356">complete</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="462717">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="454357">safeToString</a> = <span title="String(&quot;&lt;?&gt;&quot;)" class="string">&quot;&lt;?&gt;&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="454358">kind</a> = <span title="String(&quot;LazyType&quot;)" class="string">&quot;LazyType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class LazyPolyType extends Types.this.LazyType" id="441364">LazyPolyType</a><a href="#441364" title="Types.this.LazyPolyType" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="469049">typeParams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441363" title="Types.this.LazyType">LazyType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="469001">safeToString</a> =
      <span class="delimiter">(</span><span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#469049" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="TypeDebugging.scala.html#441898" title="(tp: Types.this.Type)String">typeParamsString</a><span class="delimiter">(</span><a href="#441364" title="Types.this.LazyPolyType" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#441364" title="Types.this.LazyPolyType" class="keyword">super</a>.<a href="#454357" title="=&gt; String">safeToString</a>
  <span class="delimiter">}</span>

  // def mkLazyType(tparams: Symbol*)(f: Symbol =&gt; Unit): LazyType = (
  //   if (tparams.isEmpty) new LazyType { override def complete(sym: Symbol) = f(sym) }
  //   else new LazyPolyType(tparams.toList) { override def complete(sym: Symbol) = f(sym) }
  // )

// Creators ---------------------------------------------------------------

  /** Rebind symbol `sym` to an overriding member in type `pre`. */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol" id="441365">rebind</a><span class="delimiter">(</span><a title="Types.this.Type" id="523444">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="523445">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
    <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#523445" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443300" title="=&gt; Boolean">isOverridableMember</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#523445" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#523444" title="Types.this.Type">pre</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span> <a href="#523445" title="Types.this.Symbol">sym</a>
    <span class="keyword">else</span> <a href="#523444" title="Types.this.Type">pre</a>.<a href="#442029" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#523445" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym.NameType">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#443474" title="(cond: Types.this.Symbol =&gt; Boolean)Types.this.Symbol">suchThat</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="523458">sym</a> =&gt; <a href="#523458" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443230" title="=&gt; Boolean">isType</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#523458" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443349" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="Symbols.scala.html#443540" title="(alt: =&gt; Types.this.Symbol)Types.this.Symbol">orElse</a> <a href="#523445" title="Types.this.Symbol">sym</a>
  <span class="delimiter">}</span>

  /** Convert a `super` prefix to a this-type if `sym` is abstract or final. */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="441366">removeSuper</a><span class="delimiter">(</span><a title="Types.this.Type" id="523464">tp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="523465">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#523464" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> SuperType<a href="#523469" title="Types.this.Type" id="523472" class="delimiter">(</a>thistp, _<span class="delimiter">)</span> =&gt;
      <a href="#523473" title="(x: Types.this.Type)Types.this.Type" class="keyword">if</a> <span class="delimiter">(</span><a href="#523465" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443361" title="=&gt; Boolean">isEffectivelyFinal</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#523465" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#443608" title="=&gt; Boolean">isDeferred</a><span class="delimiter">)</span> thistp
      <span class="keyword">else</span> <a href="#523464" title="Types.this.Type">tp</a>
    <span class="keyword">case</span> _ =&gt;
      <a href="#523473" title="(x: Types.this.Type)Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  /** The canonical creator for single-types */
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="441367">singleType</a><span class="delimiter">(</span><a title="Types.this.Type" id="455709">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="455710">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
      <a href="#455710" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a>.<a href="#442002" title="=&gt; Types.this.Type">resultType</a>
    <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#455710" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443293" title="=&gt; Boolean">isRootPackage</a><span class="delimiter">)</span>
      <a href="#461307" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="Definitions.scala.html#442142" title="Types.this.definitions.RootClass.type">RootClass</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="523480">sym1</a> = <a href="#441365" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#455709" title="Types.this.Type">pre</a>, <a href="#455710" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="523481">pre1</a> = <a href="#441366" title="(tp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">removeSuper</a><span class="delimiter">(</span><a href="#455709" title="Types.this.Type">pre</a>, <a href="#523480" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#523481" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#455709" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#523480" title="Types.this.Symbol">sym1</a> = <a href="#441365" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#523481" title="Types.this.Type">pre1</a>, <a href="#523480" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      <a href="#461424" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">SingleType</a><span class="delimiter">(</span><a href="#523481" title="Types.this.Type">pre1</a>, <a href="#523480" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** the canonical creator for a refined type with a given scope */
  <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type" id="441368">refinedType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="496582">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="496583">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Scope" id="496584">decls</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a>, <a title="Types.this.Position" id="496585">pos</a>: <a href="../../tools/nsc/util/Position.scala.html#52230" title="Types.this.Position">Position</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#496582" title="List[Types.this.Type]">parents</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="Definitions.scala.html#442179" title="=&gt; Types.this.ClassSymbol">ObjectClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#496582" title="List[Types.this.Type]">parents</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.RefinementClassSymbol" id="523484">clazz</a> = <a href="#496583" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#443213" title="(pos: Types.this.Position)Types.this.RefinementClassSymbol">newRefinementClass</a><span class="delimiter">(</span><a href="Positions.scala.html#441880" title="=&gt; tools.nsc.util.NoPosition.type">NoPosition</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.RefinedType" id="523485">result</a> = <a href="#447250" title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#496582" title="List[Types.this.Type]">parents</a>, <a href="#496584" title="Types.this.Scope">decls</a>, <a href="#523484" title="Types.this.RefinementClassSymbol">clazz</a><span class="delimiter">)</span>
      <a href="#523484" title="Types.this.RefinementClassSymbol">clazz</a>.<a href="Symbols.scala.html#443429" title="(info: Types.this.Type)clazz.type">setInfo</a><span class="delimiter">(</span><a href="#523485" title="Types.this.RefinedType">result</a><span class="delimiter">)</span>
      <a href="#523485" title="Types.this.RefinedType">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** The canonical creator for a refined type with an initially empty scope.
   *
   *  @param parents ...
   *  @param owner   ...
   *  @return        ...
   */
  <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type" id="441369">refinedType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="496598">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="496599">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
    <a href="#441368" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#496598" title="List[Types.this.Type]">parents</a>, <a href="#496599" title="Types.this.Symbol">owner</a>, <a href="Scopes.scala.html#441629" title="=&gt; Types.this.Scope">newScope</a>, <a href="#496599" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#443167" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type" id="441370">copyRefinedType</a><span class="delimiter">(</span><a title="Types.this.RefinedType" id="517180">original</a>: <a href="#447291" title="Types.this.RefinedType">RefinedType</a>, <a title="List[Types.this.Type]" id="517181">parents</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="517182">decls</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a><span class="delimiter">)</span> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#517181" title="List[Types.this.Type]">parents</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#517180" title="Types.this.RefinedType">original</a>.<a href="#469850" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#517182" title="Types.this.Scope">decls</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#517180" title="Types.this.RefinedType">original</a>.<a href="#469851" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#517180" title="Types.this.RefinedType">original</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="517185">owner</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#517180" title="Types.this.RefinedType">original</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a> <span class="keyword">else</span> <a href="#517180" title="Types.this.RefinedType">original</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="517186">result</a> = <a href="#441369" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#517181" title="List[Types.this.Type]">parents</a>, <a href="#517185" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="517187">syms1</a> = <a href="#517182" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#447344" title="=&gt; List[Types.this.Symbol]">toList</a>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="517219">sym</a> &lt;- <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.Symbol =&gt; Types.this.Symbol#TypeOfClonedSymbol)Unit">syms1</a><span class="delimiter">)</span>
        <a href="#517186" title="Types.this.Type">result</a>.<a href="#442019" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#447331" title="(sym: sym.TypeOfClonedSymbol)sym.TypeOfClonedSymbol">enter</a><span class="delimiter">(</span><a href="#517219" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443476" title="(newOwner: Types.this.Symbol)sym.TypeOfClonedSymbol">cloneSymbol</a><span class="delimiter">(</span><a href="#517186" title="Types.this.Type">result</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="517188">syms2</a> = <a href="#517186" title="Types.this.Type">result</a>.<a href="#442019" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#447344" title="=&gt; List[Types.this.Symbol]">toList</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="517189">resultThis</a> = <a href="#517186" title="Types.this.Type">result</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443485" title="=&gt; Types.this.Type">thisType</a>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="517273">sym</a> &lt;- <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)Unit">syms2</a><span class="delimiter">)</span>
        <a href="#517273" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#443430" title="(f: Types.this.Type =&gt; Types.this.Type)sym.type">modifyInfo</a> <span class="delimiter">(</span><a href="#517276" title="Types.this.Type">_</a> <a href="#442045" title="(from: Types.this.Symbol, to: Types.this.Type, symsFrom: List[Types.this.Symbol], symsTo: List[Types.this.Symbol])Types.this.Type">substThisAndSym</a><span class="delimiter">(</span><a href="#517180" title="Types.this.RefinedType">original</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#517189" title="Types.this.Type">resultThis</a>, <a href="#517187" title="List[Types.this.Symbol]">syms1</a>, <a href="#517188" title="List[Types.this.Symbol]">syms2</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <a href="#517186" title="Types.this.Type">result</a>
    <span class="delimiter">}</span>

  /** The canonical creator for typerefs
   *  todo: see how we can clean this up a bit
   */
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="441371">typeRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="462780">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="462781">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="462782">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    // type alias selections are rebound in TypeMap (&quot;coevolved&quot;,
    // actually -- see #3731) e.g., when type parameters that are
    // referenced by the alias are instantiated in the prefix. See
    // pos/depmet_rebind_typealias.

    <span class="keyword">val</span> <a title="Types.this.Symbol" id="523498">sym1</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#462781" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443233" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span> <a href="#441365" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#462780" title="Types.this.Type">pre</a>, <a href="#462781" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#462781" title="Types.this.Symbol">sym</a>
    // don't expand cyclical type alias
    // we require that object is initialized, thus info.typeParams instead of typeParams.
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#523498" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443232" title="=&gt; Boolean">isAliasType</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#523498" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442011" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#462782" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#523498" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443226" title="=&gt; Boolean">lockOK</a><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <span title="Types.this.RecoverableCyclicReference" class="keyword">new</span> <a href="#536666" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#523498" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="Types.this.Type" id="523499">pre1</a> = <a href="#462780" title="Types.this.Type">pre</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#523538" title="Types.this.Type" id="523541">x</a>: SuperType <span class="keyword">if</span> <a href="#523498" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443361" title="=&gt; Boolean">isEffectivelyFinal</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#523498" title="Types.this.Symbol">sym1</a>.<a href="HasFlags.scala.html#443608" title="=&gt; Boolean">isDeferred</a> =&gt;
        x.<a href="#523543" title="(x: Types.this.Type)Types.this.Type">thistpe</a>
      <span class="keyword">case</span> _: CompoundType <span class="keyword">if</span> <a href="#523498" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443231" title="=&gt; Boolean">isClass</a> =&gt;
        // sharpen prefix so that it is maximal and still contains the class.
        <a href="#462780" title="Types.this.Type">pre</a>.<a href="#441995" title="=&gt; List[Types.this.Type]">parents</a>.<a href="../../collection/immutable/List.scala.html#63674" title="=&gt; List[Types.this.Type]">reverse</a> <a href="#523543" title="(x: Types.this.Type)Types.this.Type">dropWhile</a> <span class="delimiter">(</span><a href="#523511" title="Types.this.Type">_</a>.<a href="#442028" title="(name: Types.this.Name)Types.this.Symbol">member</a><span class="delimiter">(</span><a href="#523498" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym1.NameType">name</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#523498" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="../../collection/immutable/List.scala.html#11552" title="Types.this.Type" id="523528">Nil</a>         =&gt; <a href="#523529" title="(x: Types.this.Type)Types.this.Type">pre</a>
          <span class="keyword">case</span> parent <a href="#523524" title="Types.this.Type" id="523527">::</a> _ =&gt; <a href="#523529" title="(x: Types.this.Type)Types.this.Type">parent</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> _ =&gt; <a href="#523543" title="(x: Types.this.Type)Types.this.Type">pre</a>
    <span class="delimiter">}</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#462780" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#523499" title="Types.this.Type">pre1</a><span class="delimiter">)</span>                                <a href="#448096" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#462780" title="Types.this.Type">pre</a>, <a href="#523498" title="Types.this.Symbol">sym1</a>, <a href="#462782" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#523498" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443233" title="=&gt; Boolean">isAbstractType</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#523498" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443231" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span>  <a href="#441371" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#523499" title="Types.this.Type">pre1</a>, <a href="#441365" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#523499" title="Types.this.Type">pre1</a>, <a href="#523498" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>, <a href="#462782" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">else</span>                                            <a href="#441371" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#523499" title="Types.this.Type">pre1</a>, <a href="#523498" title="Types.this.Symbol">sym1</a>, <a href="#462782" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  // Optimization to avoid creating unnecessary new typerefs.
  <span class="keyword">def</span> <a title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="441372">copyTypeRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="510561">tp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="510562">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="510563">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="510564">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#510561" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> TypeRef<a href="#523567" title="Types.this.Type" id="523570" class="delimiter">(</a>pre0, sym0, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#510562" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">==</span> pre0 <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> sym0.<a href="Symbols.scala.html#443152" title="=&gt; Types.this.Symbol#NameType">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#510563" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym.NameType">name</a> =&gt;
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#510563" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443232" title="=&gt; Boolean">isAliasType</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#510563" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442011" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#510564" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#510563" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443226" title="=&gt; Boolean">lockOK</a><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">throw</span> <span title="Types.this.RecoverableCyclicReference" class="keyword">new</span> <a href="#536666" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#510563" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>

      <a href="#448096" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#510562" title="Types.this.Type">pre</a>, <a href="#510563" title="Types.this.Symbol">sym</a>, <a href="#510564" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">case</span> _ =&gt;
      <a href="#441371" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><a href="#523571" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#510562" title="Types.this.Type">pre</a>, <a href="#510563" title="Types.this.Symbol">sym</a>, <a href="#510564" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** The canonical creator for implicit method types */
  <span class="keyword">def</span> <a title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.JavaMethodType" id="441373">JavaMethodType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="523576">params</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="523577">resultType</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441316" title="Types.this.JavaMethodType">JavaMethodType</a> =
    <span title="Types.this.JavaMethodType" class="keyword">new</span> <a href="#441316" title="Types.this.JavaMethodType">JavaMethodType</a><span class="delimiter">(</span><a href="#523576" title="List[Types.this.Symbol]">params</a>, <a href="#523577" title="Types.this.Type">resultType</a><span class="delimiter">)</span> // don't unique this!

  /** Create a new MethodType of the same class as tp, i.e. keep JavaMethodType */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type" id="441374">copyMethodType</a><span class="delimiter">(</span><a title="Types.this.Type" id="461784">tp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="461785">params</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="461786">restpe</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#461784" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> _: JavaMethodType =&gt; <a href="#441373" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.JavaMethodType">JavaMethodType</a><a href="#523583" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#461785" title="List[Types.this.Symbol]">params</a>, <a href="#461786" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
    <span class="keyword">case</span> _                 =&gt; <a href="#448374" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><a href="#523583" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#461785" title="List[Types.this.Symbol]">params</a>, <a href="#461786" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** A creator for intersection type where intersections of a single type are
   *  replaced by the type itself, and repeated parent classes are merged.
   *
   *  !!! Repeated parent classes are not merged - is this a bug in the
   *  comment or in the code?
   */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type" id="441375">intersectionType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="449458">tps</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="449459">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#449458" title="List[Types.this.Type]">tps</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> tp <a href="#523598" title="Types.this.Type" id="523600">::</a> <a href="../../collection/immutable/List.scala.html#11552" title="Types.this.Type" id="523602">Nil</a> =&gt; <a href="#523603" title="(x: Types.this.Type)Types.this.Type">tp</a>
    <span class="keyword">case</span> _         =&gt; <a href="#441369" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><a href="#523603" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#449458" title="List[Types.this.Type]">tps</a>, <a href="#449459" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  /** A creator for intersection type where intersections of a single type are
   *  replaced by the type itself.
   */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type])Types.this.Type" id="441376">intersectionType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="449468">tps</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#449468" title="List[Types.this.Type]">tps</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> tp <a href="#523627" title="Types.this.Type" id="523629">::</a> <a href="../../collection/immutable/List.scala.html#11552" title="Types.this.Type" id="523631">Nil</a>  =&gt; <a href="#523632" title="(x: Types.this.Type)Types.this.Type">tp</a>
    <span class="keyword">case</span> _          =&gt; <a href="#441369" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><a href="#523632" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#449468" title="List[Types.this.Type]">tps</a>, <a href="#441472" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#449468" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

/**** This implementation to merge parents was checked in in commented-out
      form and has languished unaltered for five years.  I think we should
      use it or lose it.

      def merge(tps: List[Type]): List[Type] = tps match {
        case tp :: tps1 =&gt;
          val tps1a = tps1 filter (_.typeSymbol.==(tp.typeSymbol))
          val tps1b = tps1 filter (_.typeSymbol.!=(tp.typeSymbol))
          mergePrefixAndArgs(tps1a, -1) match {
            case Some(tp1) =&gt; tp1 :: merge(tps1b)
            case None =&gt; throw new MalformedType(
              &quot;malformed type: &quot;+refinedType(tps, owner)+&quot; has repeated parent class &quot;+
              tp.typeSymbol+&quot; with incompatible prefixes or type arguments&quot;)
          }
        case _ =&gt; tps
      }
      refinedType(merge(tps), owner)
*/

  /** A creator for type applications */
  <span class="keyword">def</span> <a title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type" id="441377">appliedType</a><span class="delimiter">(</span><a title="Types.this.Type" id="451572">tycon</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="List[Types.this.Type]" id="451573">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#451573" title="List[Types.this.Type]">args</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#451572" title="Types.this.Type">tycon</a> //@M! `if (args.isEmpty) tycon' is crucial (otherwise we create new types in phases after typer and then they don't get adapted (??))
    <span class="keyword">else</span> <a href="#451572" title="Types.this.Type">tycon</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> TypeRef<a href="#523750" title="Boolean" id="523753" class="delimiter">(</a>pre, sym @ <span class="delimiter">(</span><a href="Definitions.scala.html#442193" title="Types.this.Type" id="523778">NothingClass</a>|<a href="Definitions.scala.html#442175" title="Boolean" id="523779">AnyClass</a><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#441372" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><a href="#523784" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#451572" title="Types.this.Type">tycon</a>, pre, sym, <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>   //@M drop type args to Any/Nothing
      <span class="keyword">case</span> TypeRef<span class="delimiter">(</span>pre, sym, _<span class="delimiter">)</span>                           =&gt; <a href="#441372" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><a href="#523784" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#451572" title="Types.this.Type">tycon</a>, pre, sym, <a href="#451573" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> PolyType<a href="#523750" title="Types.this.Type" id="523761" class="delimiter">(</a>tparams, restpe<span class="delimiter">)</span>                      =&gt; restpe.<a href="#442014" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><a href="#523784" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>tparams, <a href="#451573" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> ExistentialType<a href="#523750" title="Types.this.Type" id="523763" class="delimiter">(</a>tparams, restpe<span class="delimiter">)</span>               =&gt; <a href="#441323" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><a href="#523784" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>tparams, <a href="#441377" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span>restpe, <a href="#451573" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="#523750" title="Types.this.Type" id="523780">st</a>: SingletonType                              =&gt; <a href="#441377" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><a href="#523784" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>st.<a href="#460808" title="=&gt; Types.this.Type">widen</a>, <a href="#451573" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> // @M TODO: what to do? see bug1
      <span class="keyword">case</span> RefinedType<a href="#523750" title="Types.this.Type" id="523766" class="delimiter">(</a>parents, decls<span class="delimiter">)</span>                    =&gt; <a href="#447291" title="(parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.RefinedType">RefinedType</a><a href="#523784" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>parents <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#441377" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#523685" title="Types.this.Type">_</a>, <a href="#451573" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>, decls<span class="delimiter">)</span> // MO to AM: please check
      <span class="keyword">case</span> TypeBounds<a href="#523750" title="Types.this.Type" id="523768" class="delimiter">(</a>lo, hi<span class="delimiter">)</span>                             =&gt; <a href="#448285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><a href="#523784" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#441377" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span>lo, <a href="#451573" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, <a href="#441377" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span>hi, <a href="#451573" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> tv@<a href="#470205" title="Option[(Types.this.Type, Types.this.TypeConstraint)]" id="523800">TypeVar</a><a href="#523750" title="Types.this.Type" id="523772" class="delimiter">(</a>_, _<span class="delimiter">)</span>                               =&gt; tv.<a href="#470171" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><a href="#523784" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#451573" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> AnnotatedType<a href="#523750" title="Types.this.Type" id="523775" class="delimiter">(</a>annots, underlying, self<span class="delimiter">)</span>        =&gt; <a href="#445558" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><a href="#523784" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>annots, <a href="#441377" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span>underlying, <a href="#451573" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, self<span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="#516388" title="Types.this.Type" id="523781">ErrorType</a>                                      =&gt; <a href="#523784" title="(x: Types.this.Type)Types.this.Type">tycon</a>
      <span class="keyword">case</span> <a href="#516414" title="Types.this.Type" id="523782">WildcardType</a>                                   =&gt; <a href="#523784" title="(x: Types.this.Type)Types.this.Type">tycon</a> // needed for neg/t0226
      <span class="keyword">case</span> _                                              =&gt; <a href="SymbolTable.scala.html#440549" title="(msg: String)Nothing">abort</a><a href="#523784" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="TypeDebugging.scala.html#441900" title="(tp: Types.this.Type)String">debugString</a><span class="delimiter">(</span><a href="#451572" title="Types.this.Type">tycon</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  /** Very convenient. */
  <span class="keyword">def</span> <a title="(tyconSym: Types.this.Symbol, args: Types.this.Type*)Types.this.Type" id="441378">appliedType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="451583">tyconSym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type*" id="451584">args</a>: <span title="Types.this.Type*">Type</span>*<span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
    <a href="#441377" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#451583" title="Types.this.Symbol">tyconSym</a>.<a href="Symbols.scala.html#443444" title="=&gt; Types.this.Type">typeConstructor</a>, <a href="#451584" title="Types.this.Type*">args</a>.<a href="../../collection/TraversableOnce.scala.html#59174" title="=&gt; List[Types.this.Type]">toList</a><span class="delimiter">)</span>

  /** A creator for existential types where the type arguments,
   *  rather than being applied directly, are interpreted as the
   *  upper bounds of unknown types.  For instance if the type argument
   *  list given is List(AnyRefClass), the resulting type would be
   *  e.g. Set[_ &lt;: AnyRef] rather than Set[AnyRef] .
   */
  <span class="keyword">def</span> <a title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type" id="441379">appliedTypeAsUpperBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="459211">tycon</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="List[Types.this.Type]" id="459212">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <a href="#459211" title="Types.this.Type">tycon</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> TypeRef<a href="#523954" title="Types.this.Type" id="523957" class="delimiter">(</a>pre, sym, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span>sym.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#459212" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="523827">eparams</a>  = <a href="#441436" title="(clazz: Types.this.Symbol)List[Types.this.Symbol]">typeParamsToExistentials</a><span class="delimiter">(</span>sym<span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.TypeBounds]" id="523828">bounds</a>   = <a href="#459212" title="List[Types.this.Type]">args</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.TypeBounds)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.TypeBounds,List[Types.this.TypeBounds]])List[Types.this.TypeBounds]">map</a> <span class="delimiter">(</span><a href="#516870" title="Types.this.TypeBounds.type">TypeBounds</a> <a href="#448283" title="(hi: Types.this.Type)Types.this.TypeBounds">upper</a> <a href="#523849" title="Types.this.Type">_</a><span class="delimiter">)</span>
        <a href="util/Collections.scala.html#440726" title="(xs1: List[Types.this.Symbol], xs2: List[Types.this.TypeBounds])(f: (Types.this.Symbol, Types.this.TypeBounds) =&gt; Unit)Unit">foreach2</a><span class="delimiter">(</span><a href="#523827" title="List[Types.this.Symbol]">eparams</a>, <a href="#523828" title="List[Types.this.TypeBounds]">bounds</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#523900" title="Types.this.Symbol">_</a> <a href="Symbols.scala.html#443429" title="(info: Types.this.Type)x$60.type">setInfo</a> <a href="#523901" title="Types.this.TypeBounds">_</a><span class="delimiter">)</span>

        <a href="#441323" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">(</span><a href="#523827" title="List[Types.this.Symbol]">eparams</a>, <a href="#441371" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span>pre, sym, <a href="#523827" title="List[Types.this.Symbol]">eparams</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#523919" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#441377" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><a href="#523958" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#459211" title="Types.this.Type">tycon</a>, <a href="#459212" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A creator and extractor for type parameterizations that strips empty type parameter lists.
   *  Use this factory method to indicate the type has kind * (it's a polymorphic value)
   *  until we start tracking explicit kinds equivalent to typeFun (except that the latter requires tparams nonEmpty).
   *
   *  PP to AM: I've co-opted this for where I know tparams may well be empty, and
   *  expecting to get back `tpe` in such cases.  Re being &quot;forgiving&quot; below,
   *  can we instead say this is the canonical creator for polyTypes which
   *  may or may not be poly? (It filched the standard &quot;canonical creator&quot; name.)
   */
  <span class="keyword">object</span> <a title="Types.this.GenPolyType.type" id="441380">GenPolyType</a> <a href="#441381" title="Types.this.GenPolyType.type" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(tparams: List[Types.this.Symbol], tpe: Types.this.Type)Types.this.Type" id="457750">apply</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="457752">tparams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="457753">tpe</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">(</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#457752" title="List[Types.this.Symbol]">tparams</a> <a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <a href="#441385" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#457752" title="List[Types.this.Symbol]">tparams</a>, <a href="#457753" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#457753" title="Types.this.Type">tpe</a> // it's okay to be forgiving here
    <span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(tpe: Types.this.Type)Option[(List[Types.this.Symbol], Types.this.Type)]" id="457751">unapply</a><span class="delimiter">(</span><a title="Types.this.Type" id="523964">tpe</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[(List[Types.this.Symbol], Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, Type<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#523964" title="Types.this.Type">tpe</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> PolyType<a href="#523986" title="Option[(List[Types.this.Symbol], Types.this.Type)]" id="523988" class="delimiter">(</a>tparams, restpe<span class="delimiter">)</span> =&gt; <a href="../../Option.scala.html#64111" title="(x: (List[Types.this.Symbol], Types.this.Type))Some[(List[Types.this.Symbol], Types.this.Type)]">Some</a><a href="#523989" title="(x: Option[(List[Types.this.Symbol], Types.this.Type)])Option[(List[Types.this.Symbol], Types.this.Type)]" class="delimiter">(</a><a href="../../Tuple2.scala.html#63804" title="(_1: List[Types.this.Symbol], _2: Types.this.Type)(List[Types.this.Symbol], Types.this.Type)" class="delimiter">(</a>tparams, restpe<span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> _                         =&gt; <a href="../../Option.scala.html#64111" title="(x: (scala.collection.immutable.Nil.type, Types.this.Type))Some[(scala.collection.immutable.Nil.type, Types.this.Type)]">Some</a><a href="#523989" title="(x: Option[(List[Types.this.Symbol], Types.this.Type)])Option[(List[Types.this.Symbol], Types.this.Type)]" class="delimiter">(</a><a href="../../Tuple2.scala.html#63804" title="(_1: scala.collection.immutable.Nil.type, _2: Types.this.Type)(scala.collection.immutable.Nil.type, Types.this.Type)" class="delimiter">(</a><a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="#523964" title="Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(params: List[Types.this.Symbol], tpe: Types.this.Type)Types.this.Type" id="441382">genPolyType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="462003">params</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="462004">tpe</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#457750" title="(tparams: List[Types.this.Symbol], tpe: Types.this.Type)Types.this.Type">GenPolyType</a><span class="delimiter">(</span><a href="#462003" title="List[Types.this.Symbol]">params</a>, <a href="#462004" title="Types.this.Type">tpe</a><span class="delimiter">)</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;use genPolyType(...) instead&quot;</span>, <span class="string">&quot;2.10.0&quot;</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(params: List[Types.this.Symbol], tpe: Types.this.Type)Types.this.Type" id="441383">polyType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="523994">params</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="523995">tpe</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#457750" title="(tparams: List[Types.this.Symbol], tpe: Types.this.Type)Types.this.Type">GenPolyType</a><span class="delimiter">(</span><a href="#523994" title="List[Types.this.Symbol]">params</a>, <a href="#523995" title="Types.this.Type">tpe</a><span class="delimiter">)</span>

  /** A creator for anonymous type functions, where the symbol for the type function still needs to be created.
   *
   * TODO:
   * type params of anonymous type functions, which currently can only arise from normalising type aliases, are owned by the type alias of which they are the eta-expansion
   * higher-order subtyping expects eta-expansion of type constructors that arise from a class; here, the type params are owned by that class, but is that the right thing to do?
   */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type" id="441384">typeFunAnon</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="519728">tps</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="519729">body</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441385" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#519728" title="List[Types.this.Symbol]">tps</a>, <a href="#519729" title="Types.this.Type">body</a><span class="delimiter">)</span>

  /** A creator for a type functions, assuming the type parameters tps already have the right owner. */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type" id="441385">typeFun</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="517586">tps</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="517587">body</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#448476" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#517586" title="List[Types.this.Symbol]">tps</a>, <a href="#517587" title="Types.this.Type">body</a><span class="delimiter">)</span>

  /** A creator for existential types. This generates:
   *
   *  tpe1 where { tparams }
   *
   *  where `tpe1` is the result of extrapolating `tpe` wrt to `tparams`.
   *  Extrapolating means that type variables in `tparams` occurring
   *  in covariant positions are replaced by upper bounds, (minus any
   *  SingletonClass markers), type variables in `tparams` occurring in
   *  contravariant positions are replaced by upper bounds, provided the
   *  resulting type is legal wrt to stability, and does not contain any type
   *  variable in `tparams`.
   *
   *  The abstraction drops all type parameters that are not directly or
   *  indirectly referenced by type `tpe1`. If there are no remaining type
   *  parameters, simply returns result type `tpe`.
   */
  <span class="keyword">def</span> <a title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type" id="441386">existentialAbstraction</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="459814">tparams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="459815">tpe0</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459814" title="List[Types.this.Symbol]">tparams</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#459815" title="Types.this.Type">tpe0</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="523999">tpe</a>      = <a href="#524005" title="(tp: Types.this.Type)Types.this.Type">deAlias</a><span class="delimiter">(</span><a href="#459815" title="Types.this.Type">tpe0</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="524000">tpe1</a>     = <span title="Types.this.ExistentialExtrapolation" class="keyword">new</span> <a href="#441441" title="Types.this.ExistentialExtrapolation">ExistentialExtrapolation</a><span class="delimiter">(</span><a href="#459814" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <a href="#524023" title="(tpe: Types.this.Type)Types.this.Type">extrapolate</a> <a href="#523999" title="Types.this.Type">tpe</a>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="524001">tparams0</a> = <a href="#459814" title="List[Types.this.Symbol]">tparams</a>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="524002">tparams1</a> = <a href="#524001" title="List[Types.this.Symbol]">tparams0</a> <a href="../../collection/TraversableLike.scala.html#58981" title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">filter</a> <a href="#524000" title="Types.this.Type">tpe1</a>.<a href="#442056" title="(sym: Types.this.Symbol)Boolean">contains</a>

      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#524002" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#524001" title="List[Types.this.Symbol]">tparams0</a><span class="delimiter">)</span> <a href="#524003" title="()Unit" class="delimiter">{</a>
        <a href="#524001" title="List[Types.this.Symbol]">tparams0</a> = <a href="#524002" title="List[Types.this.Symbol]">tparams1</a>
        <a href="#524002" title="List[Types.this.Symbol]">tparams1</a> = <a href="#459814" title="List[Types.this.Symbol]">tparams</a> <a href="../../collection/TraversableLike.scala.html#58981" title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">filter</a> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="524045">p</a> =&gt;
          <a href="#524002" title="List[Types.this.Symbol]">tparams1</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="524054">p1</a> =&gt; <a href="#524054" title="Types.this.Symbol">p1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#524045" title="Types.this.Symbol">p</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#524054" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a> <a href="#442056" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#524045" title="Types.this.Symbol">p</a><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#441323" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">(</span><a href="#524002" title="List[Types.this.Symbol]">tparams1</a>, <a href="#524000" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  /** Remove any occurrences of type aliases from this type */
  <span class="keyword">object</span> <a title="Types.this.deAlias.type" id="441387">deAlias</a> <a href="#441388" title="Types.this.deAlias.type" class="keyword">extends</a> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="524005">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="524006">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a> <span class="delimiter">{</span>
      <a href="#524006" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> TypeRef<a href="#524074" title="Types.this.Type" id="524076" class="delimiter">(</a>pre, sym, args<span class="delimiter">)</span> <span class="keyword">if</span> sym.<a href="Symbols.scala.html#443232" title="=&gt; Boolean">isAliasType</a> =&gt; <a href="#524006" title="Types.this.Type">tp</a>.<a href="#524077" title="(x: Types.this.Type)Types.this.Type">normalize</a>
        <span class="keyword">case</span> _ =&gt; <a href="#524077" title="(x: Types.this.Type)Types.this.Type">tp</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Remove any occurrence of type &lt;singleton&gt; from this type and its parents */
  <span class="keyword">object</span> <a title="Types.this.dropSingletonType.type" id="441389">dropSingletonType</a> <a href="#441390" title="Types.this.dropSingletonType.type" class="keyword">extends</a> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="498055">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="498056">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#498056" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> TypeRef<a href="#524133" title="Types.this.Type" id="524138" class="delimiter">(</a>_, <a href="Definitions.scala.html#442283" title="Types.this.Type" id="524143">SingletonClass</a>, _<span class="delimiter">)</span> =&gt;
          <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a>.<a href="#524144" title="(x: Types.this.Type)Types.this.Type">tpe</a>
        <span class="keyword">case</span> tp1 @ RefinedType<a href="#524133" title="Types.this.Type" id="524142" class="delimiter">(</a>parents, decls<span class="delimiter">)</span> =&gt;
          <span class="keyword">var</span> <a title="List[Types.this.Type]" id="524086">parents1</a> = parents <a href="../../collection/TraversableLike.scala.html#58981" title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</a> <span class="delimiter">(</span><a href="#524090" title="Types.this.Type">_</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#442283" title="=&gt; Types.this.ClassSymbol">SingletonClass</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#524086" title="List[Types.this.Type]">parents1</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#524086" title="List[Types.this.Type]">parents1</a> = <a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#524086" title="List[Types.this.Type]">parents1</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Type]">tail</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> decls.<a href="Scopes.scala.html#447327" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#524086" title="List[Types.this.Type]">parents1</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#441370" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span>tp1, <a href="#524086" title="List[Types.this.Type]">parents1</a>, decls<span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> tp1 =&gt;
          <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#524144" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>tp1<span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Substitutes the empty scope for any non-empty decls in the type. */
  <span class="keyword">object</span> <a title="Types.this.dropAllRefinements.type" id="441391">dropAllRefinements</a> <a href="#441392" title="Types.this.dropAllRefinements.type" class="keyword">extends</a> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="524154">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="524156">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#524156" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> rt @ RefinedType<a href="#524193" title="Types.this.Type" id="524195" class="delimiter">(</a>parents, decls<span class="delimiter">)</span> <span class="keyword">if</span> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a>decls.<a href="Scopes.scala.html#447327" title="=&gt; Boolean">isEmpty</a> =&gt;
        <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#524198" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#441370" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span>rt, parents, <a href="Scopes.scala.html#441634" title="Types.this.EmptyScope.type">EmptyScope</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> ClassInfoType<a href="#524193" title="Types.this.Type" id="524197" class="delimiter">(</a>parents, decls, clazz<span class="delimiter">)</span> <span class="keyword">if</span> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a>decls.<a href="Scopes.scala.html#447327" title="=&gt; Boolean">isEmpty</a> =&gt;
        <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#524198" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#454759" title="(parents: List[Types.this.Type], decls: Types.this.Scope, typeSymbol: Types.this.Symbol)Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">(</span>parents, <a href="Scopes.scala.html#441634" title="Types.this.EmptyScope.type">EmptyScope</a>, clazz<span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#524198" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#524156" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Type with all top-level occurrences of abstract types replaced by their bounds */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="441393">abstractTypesToBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="524204">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#524204" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span> // @M don't normalize here (compiler loops on pos/bug1090.scala )
    <span class="keyword">case</span> TypeRef<a href="#524221" title="Boolean" id="524225" class="delimiter">(</a>_, sym, _<span class="delimiter">)</span> <span class="keyword">if</span> sym.<a href="Symbols.scala.html#443233" title="=&gt; Boolean">isAbstractType</a> =&gt;
      <a href="#441393" title="(tp: Types.this.Type)Types.this.Type">abstractTypesToBounds</a><a href="#524237" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#524204" title="Types.this.Type">tp</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>
    <span class="keyword">case</span> TypeRef<span class="delimiter">(</span>_, sym, _<span class="delimiter">)</span> <span class="keyword">if</span> sym.<a href="Symbols.scala.html#443232" title="=&gt; Boolean">isAliasType</a> =&gt;
      <a href="#441393" title="(tp: Types.this.Type)Types.this.Type">abstractTypesToBounds</a><a href="#524237" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#524204" title="Types.this.Type">tp</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
    <span class="keyword">case</span> rtp @ RefinedType<a href="#524221" title="Types.this.Type" id="524231" class="delimiter">(</a>parents, decls<span class="delimiter">)</span> =&gt;
      <a href="#441370" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><a href="#524237" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>rtp, parents <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</a> <a href="#441393" title="(tp: Types.this.Type)Types.this.Type">abstractTypesToBounds</a>, decls<span class="delimiter">)</span>
    <span class="keyword">case</span> AnnotatedType<a href="#524221" title="Types.this.Type" id="524235" class="delimiter">(</a>_, underlying, _<span class="delimiter">)</span> =&gt;
      <a href="#441393" title="(tp: Types.this.Type)Types.this.Type">abstractTypesToBounds</a><a href="#524237" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>underlying<span class="delimiter">)</span>
    <span class="keyword">case</span> _ =&gt;
      <a href="#524237" title="(x: Types.this.Type)Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  // Set to true for A* =&gt; Seq[A]
  //   (And it will only rewrite A* in method result types.)
  //   This is the pre-existing behavior.
  // Or false for Seq[A] =&gt; Seq[A]
  //   (It will rewrite A* everywhere but method parameters.)
  //   This is the specified behavior.
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="441394">etaExpandKeepsStar</a> = <span title="Boolean(false)" class="keyword">false</span>

  <span class="keyword">object</span> <a title="Types.this.dropRepeatedParamType.type" id="441395">dropRepeatedParamType</a> <a href="#441396" title="Types.this.dropRepeatedParamType.type" class="keyword">extends</a> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="524249">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="524251">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#524251" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> MethodType<a href="#524274" title="Types.this.Type" id="524276" class="delimiter">(</a>params, restpe<span class="delimiter">)</span> =&gt;
        <a href="#448374" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><a href="#524291" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>params, <a href="#524249" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span>restpe<span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> PolyType<a href="#524274" title="Types.this.Type" id="524278" class="delimiter">(</a>tparams, restpe<span class="delimiter">)</span> =&gt;
        <a href="#448476" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><a href="#524291" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>tparams, <a href="#524249" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span>restpe<span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> TypeRef<a href="#524274" title="Types.this.Type" id="524283" class="delimiter">(</a>_, <a href="Definitions.scala.html#442303" title="Types.this.Type" id="524289">RepeatedParamClass</a>, arg <a title="Types.this.Type" id="524287">::</a> <a href="../../collection/immutable/List.scala.html#11552" title="Types.this.Type" id="524290">Nil</a><span class="delimiter">)</span> =&gt;
        <a href="Definitions.scala.html#442516" title="(arg: Types.this.Type)Types.this.Type">seqType</a><a href="#524291" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>arg<span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#524291" title="(x: Types.this.Type)Types.this.Type" class="keyword">if</a> <span class="delimiter">(</span><a href="#441394" title="=&gt; Boolean">etaExpandKeepsStar</a><span class="delimiter">)</span> <a href="#524251" title="Types.this.Type">tp</a> <span class="keyword">else</span> <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#524251" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Types.this.toDeBruijn.type" id="441397">toDeBruijn</a> <a href="#441398" title="Types.this.toDeBruijn.type" class="keyword">extends</a> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[List[Types.this.Symbol]]" id="524306">paramStack</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[List[Types.this.Symbol]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a>
    <span class="keyword">def</span> <a title="(params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.DeBruijnBinder" id="524308">mkDebruijnBinder</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="524312">params</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="524313">restpe</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#524306" title="(x$1: List[List[Types.this.Symbol]])Unit">paramStack</a> = <a href="#524312" title="List[Types.this.Symbol]">params</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: List[Types.this.Symbol])List[List[Types.this.Symbol]]">::</a> <a href="#524306" title="=&gt; List[List[Types.this.Symbol]]">paramStack</a>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#536639" title="(pnames: List[Types.this.Name], ptypes: List[Types.this.Type], restpe: Types.this.Type)Types.this.DeBruijnBinder">DeBruijnBinder</a><span class="delimiter">(</span><a href="#524312" title="List[Types.this.Symbol]">params</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.Symbol#NameType)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol#NameType,List[Types.this.Name]])List[Types.this.Name]">map</a> <span class="delimiter">(</span><a href="#524347" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443152" title="=&gt; x$65.NameType">name</a><span class="delimiter">)</span>, <a href="#524312" title="List[Types.this.Symbol]">params</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="524394">p</a> =&gt; <a href="#524309" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#524394" title="Types.this.Symbol">p</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#524309" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#524313" title="Types.this.Type">restpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <a href="#524306" title="(x$1: List[List[Types.this.Symbol]])Unit">paramStack</a> = <a href="#524306" title="=&gt; List[List[Types.this.Symbol]]">paramStack</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[List[Types.this.Symbol]]">tail</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="524309">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="524395">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#524395" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> PolyType<a href="#524517" title="Types.this.Type" id="524519" class="delimiter">(</a>tparams, restpe<span class="delimiter">)</span> =&gt;
        <a href="#524308" title="(params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.DeBruijnBinder">mkDebruijnBinder</a><a href="#524527" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>tparams, restpe<span class="delimiter">)</span>
      <span class="keyword">case</span> MethodType<a href="#524517" title="Types.this.Type" id="524521" class="delimiter">(</a>params, restpe<span class="delimiter">)</span> =&gt;
        <a href="#524308" title="(params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.DeBruijnBinder">mkDebruijnBinder</a><a href="#524527" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>params, restpe<span class="delimiter">)</span>
      <span class="keyword">case</span> TypeRef<a href="#524517" title="Types.this.Type" id="524524" class="delimiter">(</a><a href="#516520" title="Types.this.Type" id="524526">NoPrefix</a>, sym, args<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Int" id="524438">level</a> = <a href="#524306" title="=&gt; List[List[Types.this.Symbol]]">paramStack</a> <a href="../../collection/GenSeqLike.scala.html#59604" title="(p: List[Types.this.Symbol] =&gt; Boolean)Int">indexWhere</a> <span class="delimiter">(</span><a href="#524453" title="List[Types.this.Symbol]">_</a> <a href="../../collection/SeqLike.scala.html#59768" title="(elem: Any)Boolean">contains</a> sym<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#524438" title="Int">level</a> <a href="../../Int.scala.html#57905" title="(x: Int)Boolean">&lt;</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#524395" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#536635" title="(level: Int, idx: Int, args: List[Types.this.Type])Types.this.DeBruijnIndex">DeBruijnIndex</a><span class="delimiter">(</span><a href="#524438" title="Int">level</a>, <a href="../../collection/LinearSeqOptimized.scala.html#76165" title="(n: Int)List[Types.this.Symbol]">paramStack</a><span class="delimiter">(</span><a href="#524438" title="Int">level</a><span class="delimiter">)</span> <a href="../../collection/GenSeqLike.scala.html#59605" title="(elem: Types.this.Symbol)Int">indexOf</a> sym, args <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</a> <span class="keyword">this</span><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#524527" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#524395" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.TypeMap" id="441399">fromDeBruijn</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="524537">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#524540" title="Types.this.TypeMap{}" class="keyword">new</a> <a href="#441429" title="anonymous class $anon extends Types.this.TypeMap" id="524540">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[List[Types.this.Symbol]]" id="524543">paramStack</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[List[Types.this.Symbol]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="524545">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="524546">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#524546" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> DeBruijnBinder<a href="#525542" title="Types.this.Type" id="525544" class="delimiter">(</a>pnames, ptypes, restpe<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Boolean" id="524578">isType</a> = pnames.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Name">head</a>.<a href="Names.scala.html#444125" title="=&gt; Boolean">isTypeName</a>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol{def name: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; def rawname: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type TypeOfClonedSymbol &gt;: Null &lt;: Types.this.Symbol{type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}}]" id="524579">newParams</a> = <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Name" id="524597">name</a> &lt;- <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Name =&gt; Types.this.Symbol{def name: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; def rawname: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type TypeOfClonedSymbol &gt;: Null &lt;: Types.this.Symbol{type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}})(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Name],Types.this.Symbol{def name: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; def rawname: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type TypeOfClonedSymbol &gt;: Null &lt;: Types.this.Symbol{type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}},List[Types.this.Symbol{def name: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; def rawname: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type TypeOfClonedSymbol &gt;: Null &lt;: Types.this.Symbol{type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}}]])List[Types.this.Symbol{def name: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; def rawname: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type TypeOfClonedSymbol &gt;: Null &lt;: Types.this.Symbol{type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}}]">pnames</a><span class="delimiter">)</span> <span class="keyword">yield</span>
          <span title="Types extends Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#524578" title="Boolean">isType</a><span class="delimiter">)</span> <a href="#524537" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#443194" title="(name: Types.this.TypeName, pos: Types.this.Position, newFlags: Long)Types.this.TypeSymbol">newTypeParameter</a><span class="delimiter">(</span><a href="#524597" title="Types.this.Name">name</a>.<a href="Names.scala.html#444127" title="=&gt; Types.this.TypeName">toTypeName</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#524537" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#443175" title="(name: Types.this.TermName, pos: Types.this.Position, newFlags: Long)Types.this.TermSymbol">newValueParameter</a><span class="delimiter">(</span><a href="#524597" title="Types.this.Name">name</a>.<a href="Names.scala.html#444126" title="=&gt; Types.this.TermName">toTermName</a><span class="delimiter">)</span>
        <a href="#524543" title="(x$1: List[List[Types.this.Symbol]])Unit">paramStack</a> = <a href="#524579" title="List[Types.this.Symbol{def name: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; def rawname: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type TypeOfClonedSymbol &gt;: Null &lt;: Types.this.Symbol{type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}}]">newParams</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: List[Types.this.Symbol])List[List[Types.this.Symbol]]">::</a> <a href="#524543" title="=&gt; List[List[Types.this.Symbol]]">paramStack</a>
        <span class="keyword">try</span> <span class="delimiter">{</span>
          <a href="util/Collections.scala.html#440726" title="(xs1: List[Types.this.Symbol{def name: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; def rawname: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type TypeOfClonedSymbol &gt;: Null &lt;: Types.this.Symbol{type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}}], xs2: List[Types.this.Type])(f: (Types.this.Symbol{def name: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; def rawname: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type TypeOfClonedSymbol &gt;: Null &lt;: Types.this.Symbol{type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}}, Types.this.Type) =&gt; Unit)Unit">foreach2</a><span class="delimiter">(</span><a href="#524579" title="List[Types.this.Symbol{def name: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; def rawname: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type TypeOfClonedSymbol &gt;: Null &lt;: Types.this.Symbol{type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}}]">newParams</a>, ptypes<span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types extends Types.this.Symbol" id="525423">p</a>, <a title="Types.this.Type" id="525424">t</a><span class="delimiter">)</span> =&gt; <a href="#525423" title="Types extends Types.this.Symbol">p</a> <a href="Symbols.scala.html#443429" title="(info: Types.this.Type)scala.reflect.internal.Types.&lt;refinement&gt;.type">setInfo</a> <a href="#524545" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#525424" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="525401">restpe1</a> = <a href="#524545" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>restpe<span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#524578" title="Boolean">isType</a><span class="delimiter">)</span> <a href="#448476" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#524579" title="List[Types.this.Symbol{def name: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; def rawname: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type TypeOfClonedSymbol &gt;: Null &lt;: Types.this.Symbol{type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}}]">newParams</a>, <a href="#525401" title="Types.this.Type">restpe1</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#448374" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#524579" title="List[Types.this.Symbol{def name: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; def rawname: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type TypeOfClonedSymbol &gt;: Null &lt;: Types.this.Symbol{type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}; type NameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name{type ThisNameType &gt;: Types.this.TypeName with Types.this.TermName &lt;: Types.this.Name}}]">newParams</a>, <a href="#525401" title="Types.this.Type">restpe1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <a href="#524543" title="(x$1: List[List[Types.this.Symbol]])Unit">paramStack</a> = <a href="#524543" title="=&gt; List[List[Types.this.Symbol]]">paramStack</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[List[Types.this.Symbol]]">tail</a>
      <span class="keyword">case</span> DeBruijnIndex<a href="#525542" title="Types.this.Type" id="525546" class="delimiter">(</a>level, idx, args<span class="delimiter">)</span> =&gt;
        <a href="#448096" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><a href="#525547" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#516520" title="Types.this.NoPrefix.type">NoPrefix</a>, <a href="../../collection/LinearSeqOptimized.scala.html#76165" title="(n: Int)List[Types.this.Symbol]">paramStack</a><a href="../../collection/LinearSeqOptimized.scala.html#76165" title="(n: Int)Types.this.Symbol" class="delimiter">(</a>level<span class="delimiter">)</span><span class="delimiter">(</span>idx<span class="delimiter">)</span>, args <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#524540" title="Types.this.TypeMap{}" class="keyword">this</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#525547" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#524546" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

// Hash consing --------------------------------------------------------------

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="Int" id="441400">initialUniquesCapacity</a> = <span title="Int(4096)" class="int">4096</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="scala.reflect.internal.util.HashSet[Types.this.Type]" id="441403">uniques</a>: util.<a href="util/HashSet.scala.html#23099" title="scala.reflect.internal.util.HashSet[Types.this.Type]">HashSet</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = _
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="441406">uniqueRunId</a> = <span title="Int(0)">NoRunId</span>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="[T &lt;: Types.this.Type](tp: T)T" id="441408">unique</a><span class="delimiter">[</span><a title=" &lt;: Types.this.Type" id="441410">T</a> &lt;: Type<span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="516596">tp</a>: <a href="#441410" title="T">T</a><span class="delimiter">)</span>: <a href="#441410" title="T">T</a> = <span class="delimiter">{</span>
    <a href="util/StatBase.scala.html#441044" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441086" title="=&gt; scala.reflect.internal.util.Statistics.Counter">rawTypeCount</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#441406" title="=&gt; Int">uniqueRunId</a> <a href="../../Int.scala.html#57898" title="(x: Int)Boolean">!=</a> <a href="SymbolTable.scala.html#440598" title="=&gt; Types.this.RunId">currentRunId</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#441403" title="(x$1: scala.reflect.internal.util.HashSet[Types.this.Type])Unit">uniques</a> = util.<a href="util/HashSet.scala.html#525583" title="[T &gt;: Null &lt;: AnyRef](label: String, initialCapacity: Int)scala.reflect.internal.util.HashSet[T]">HashSet</a><span title="(label: String, initialCapacity: Int)scala.reflect.internal.util.HashSet[Types.this.Type]" class="delimiter">[</span><a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="String(&quot;uniques&quot;)" class="string">&quot;uniques&quot;</span>, <a href="#441400" title="=&gt; Int">initialUniquesCapacity</a><span class="delimiter">)</span>
      <a href="#441406" title="(x$1: Int)Unit">uniqueRunId</a> = <a href="SymbolTable.scala.html#440598" title="=&gt; Types.this.RunId">currentRunId</a>
    <span class="delimiter">}</span>
    <span class="delimiter">(</span><a href="#441403" title="=&gt; scala.reflect.internal.util.HashSet[Types.this.Type]">uniques</a> <a href="util/HashSet.scala.html#514481" title="(x: Types.this.Type)Types.this.Type">findEntryOrUpdate</a> <a href="#516596" title="T">tp</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#441410" title="T">T</a><span class="delimiter">]</span>
  <span class="delimiter">}</span>

// Helper Classes ---------------------------------------------------------

  /** @PP: Unable to see why these apparently constant types should need vals
   *  in every TypeConstraint, I lifted them out.
   */
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.Type" id="441412">numericLoBound</a> = <a href="Definitions.scala.html#442849" title="=&gt; Types.this.ClassSymbol">IntClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a>
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.Type" id="441414">numericHiBound</a> = <a href="#441375" title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><a href="Definitions.scala.html#442843" title="=&gt; Types.this.ClassSymbol">ByteClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a>, <a href="Definitions.scala.html#442847" title="=&gt; Types.this.ClassSymbol">CharClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>, <a href="Definitions.scala.html#442154" title="=&gt; Types.this.Symbol">ScalaPackageClass</a><span class="delimiter">)</span>

  /** A class expressing upper and lower bounds constraints of type variables,
   * as well as their instantiations.
   */
  <span class="keyword">class</span> <a title="class TypeConstraint extends Object" id="441416">TypeConstraint</a><a href="#441416" title="Types.this.TypeConstraint" class="delimiter">(</a><a title="List[Types.this.Type]" id="471310">lo0</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="471311">hi0</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Type" id="471312">numlo0</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="471313">numhi0</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Boolean" id="471316">avoidWidening0</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(lo0: List[Types.this.Type], hi0: List[Types.this.Type])Types.this.TypeConstraint" id="470240" class="keyword">this</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="471306">lo0</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="471307">hi0</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#441416" title="TypeConstraint.this.type" class="keyword">this</a><span class="delimiter">(</span><a href="#471306" title="List[Types.this.Type]">lo0</a>, <a href="#471307" title="List[Types.this.Type]">hi0</a>, <a href="#516490" title="Types.this.NoType.type">NoType</a>, <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(bounds: Types.this.TypeBounds)Types.this.TypeConstraint" id="470241" class="keyword">this</a><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="471304">bounds</a>: <a href="#448315" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">)</span> = <a href="#470240" title="(lo0: List[Types.this.Type], hi0: List[Types.this.Type])Types.this.TypeConstraint" class="keyword">this</a><span class="delimiter">(</span><a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><a href="#471304" title="Types.this.TypeBounds">bounds</a>.<a href="#448327" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><a href="#471304" title="Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="()Types.this.TypeConstraint" id="470242" class="keyword">this</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="#470240" title="(lo0: List[Types.this.Type], hi0: List[Types.this.Type])Types.this.TypeConstraint" class="keyword">this</a><span class="delimiter">(</span>List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>, List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span><span class="delimiter">)</span>

    /*  Syncnote: Type constraints are assumed to be used from only one
     *  thread. They are not exposed in api.Types and are used only locally
     *  in operations that are exposed from types. Hence, no syncing of any
     *  variables should be ncessesary.
     */

    /** Guard these lists against AnyClass and NothingClass appearing,
     *  else loBounds.isEmpty will have different results for an empty
     *  constraint and one with Nothing as a lower bound.  [Actually
     *  guarding addLoBound/addHiBound somehow broke raw types so it
     *  only guards against being created with them.]
     */
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[Types.this.Type]" id="470244">lobounds</a> = <a href="#471310" title="List[Types.this.Type]">lo0</a> <a href="../../collection/TraversableLike.scala.html#58982" title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</a> <span class="delimiter">(</span><a href="#514607" title="Types.this.Type">_</a>.<a href="#441988" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[Types.this.Type]" id="470247">hibounds</a> = <a href="#471311" title="List[Types.this.Type]">hi0</a> <a href="../../collection/TraversableLike.scala.html#58982" title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</a> <span class="delimiter">(</span><a href="#514611" title="Types.this.Type">_</a>.<a href="#441988" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="470250">numlo</a> = <a href="#471312" title="Types.this.Type">numlo0</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="470253">numhi</a> = <a href="#471313" title="Types.this.Type">numhi0</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Boolean" id="470256">avoidWidening</a> = <a href="#471316" title="Boolean">avoidWidening0</a>

    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="470258">loBounds</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#470250" title="=&gt; Types.this.Type">numlo</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="#470244" title="=&gt; List[Types.this.Type]">lobounds</a> <span class="keyword">else</span> <a href="#470250" title="=&gt; Types.this.Type">numlo</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#470244" title="=&gt; List[Types.this.Type]">lobounds</a>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="470259">hiBounds</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#470253" title="=&gt; Types.this.Type">numhi</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="#470247" title="=&gt; List[Types.this.Type]">hibounds</a> <span class="keyword">else</span> <a href="#470253" title="=&gt; Types.this.Type">numhi</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#470247" title="=&gt; List[Types.this.Type]">hibounds</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="470260">avoidWiden</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#470256" title="=&gt; Boolean">avoidWidening</a>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="470261">addLoBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="522700">tp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Boolean" id="522702">isNumericBound</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#522702" title="Boolean">isNumericBound</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="Definitions.scala.html#442791" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#522700" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#470250" title="=&gt; Types.this.Type">numlo</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#516490" title="Types.this.NoType.type">NoType</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#441554" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#470250" title="=&gt; Types.this.Type">numlo</a>, <a href="#522700" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#470250" title="(x$1: Types.this.Type)Unit">numlo</a> = <a href="#522700" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#441554" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#522700" title="Types.this.Type">tp</a>, <a href="#470250" title="=&gt; Types.this.Type">numlo</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#470250" title="(x$1: Types.this.Type)Unit">numlo</a> = <a href="#441411" title="=&gt; Types.this.Type">numericLoBound</a>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#470244" title="(x$1: List[Types.this.Type])Unit">lobounds</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: Types.this.Type)List[Types.this.Type]">::=</a> <a href="#522700" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="470262">checkWidening</a><span class="delimiter">(</span><a title="Types.this.Type" id="525712">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#525712" title="Types.this.Type">tp</a>.<a href="#441973" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#470256" title="(x$1: Boolean)Unit">avoidWidening</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">else</span> <a href="#525712" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="#521690" title="Option[(Types.this.TypeName, Types.this.Type)]" id="525723">HasTypeMember</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#470256" title="(x$1: Boolean)Unit">avoidWidening</a> = <span title="Boolean(true)" class="keyword">true</span>
        <span class="keyword">case</span> _ =&gt;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="470263">addHiBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="522706">tp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Boolean" id="522708">isNumericBound</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#470262" title="(tp: Types.this.Type)Unit">checkWidening</a><span class="delimiter">(</span><a href="#522706" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#522708" title="Boolean">isNumericBound</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="Definitions.scala.html#442791" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#522706" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#470253" title="=&gt; Types.this.Type">numhi</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#516490" title="Types.this.NoType.type">NoType</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#441554" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#522706" title="Types.this.Type">tp</a>, <a href="#470253" title="=&gt; Types.this.Type">numhi</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#470253" title="(x$1: Types.this.Type)Unit">numhi</a> = <a href="#522706" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#441554" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#470253" title="=&gt; Types.this.Type">numhi</a>, <a href="#522706" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#470253" title="(x$1: Types.this.Type)Unit">numhi</a> = <a href="#441413" title="=&gt; Types.this.Type">numericHiBound</a>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#470247" title="(x$1: List[Types.this.Type])Unit">hibounds</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: Types.this.Type)List[Types.this.Type]">::=</a> <a href="#522706" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="470264">isWithinBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="522826">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> =
      <a href="#470244" title="=&gt; List[Types.this.Type]">lobounds</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a href="#525745" title="Types.this.Type">_</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#522826" title="Types.this.Type">tp</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
      <a href="#470247" title="=&gt; List[Types.this.Type]">hibounds</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a href="#522826" title="Types.this.Type">tp</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#525755" title="Types.this.Type">_</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
      <span class="delimiter">(</span><a href="#470250" title="=&gt; Types.this.Type">numlo</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#516490" title="Types.this.NoType.type">NoType</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#470250" title="=&gt; Types.this.Type">numlo</a> <a href="#442061" title="(that: Types.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#522826" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
      <span class="delimiter">(</span><a href="#470253" title="=&gt; Types.this.Type">numhi</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#516490" title="Types.this.NoType.type">NoType</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#522826" title="Types.this.Type">tp</a> <a href="#442061" title="(that: Types.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#470253" title="=&gt; Types.this.Type">numhi</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">var</span> <a title="Types.this.Type" id="470266">inst</a>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#516490" title="Types.this.NoType.type">NoType</a> // @M reduce visibility?

    <span class="keyword">def</span> <a title="=&gt; Boolean" id="470268">instValid</a> = <span class="delimiter">(</span><a href="#470266" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#470266" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeConstraint" id="470269">cloneInternal</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.TypeConstraint" id="514601">tc</a> = <span title="Types.this.TypeConstraint" class="keyword">new</span> <a href="#441416" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">(</span><a href="#470244" title="=&gt; List[Types.this.Type]">lobounds</a>, <a href="#470247" title="=&gt; List[Types.this.Type]">hibounds</a>, <a href="#470250" title="=&gt; Types.this.Type">numlo</a>, <a href="#470253" title="=&gt; Types.this.Type">numhi</a>, <a href="#470256" title="=&gt; Boolean">avoidWidening</a><span class="delimiter">)</span>
      <a href="#514601" title="Types.this.TypeConstraint">tc</a>.<a href="#470266" title="(x$1: Types.this.Type)Unit">inst</a> = <a href="#470266" title="=&gt; Types.this.Type">inst</a>
      <a href="#514601" title="Types.this.TypeConstraint">tc</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="470270">toString</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="525770">boundsStr</a> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="525771">lo</a>    = <a href="#470258" title="=&gt; List[Types.this.Type]">loBounds</a> <a href="../../collection/TraversableLike.scala.html#58982" title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</a> <span class="delimiter">(</span><a href="#525780" title="Types.this.Type">_</a>.<a href="#441988" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="525772">hi</a>    = <a href="#470259" title="=&gt; List[Types.this.Type]">hiBounds</a> <a href="../../collection/TraversableLike.scala.html#58982" title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</a> <span class="delimiter">(</span><a href="#525786" title="Types.this.Type">_</a>.<a href="#441988" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[String]" id="525773">lostr</a> = <span title="List[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#525771" title="List[Types.this.Type]">lo</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a> <span class="keyword">else</span> <a href="../../collection/immutable/List.scala.html#63291" title="(xs: String*)List[String]">List</a><span class="delimiter">(</span><a href="#525771" title="List[Types.this.Type]">lo</a>.<a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot; &gt;: (&quot;)" class="string">&quot; &gt;: (&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[String]" id="525774">histr</a> = <span title="List[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#525772" title="List[Types.this.Type]">hi</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a> <span class="keyword">else</span> <a href="../../collection/immutable/List.scala.html#63291" title="(xs: String*)List[String]">List</a><span class="delimiter">(</span><a href="#525772" title="List[Types.this.Type]">hi</a>.<a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot; &lt;: (&quot;)" class="string">&quot; &lt;: (&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

        <a href="#525773" title="List[String]">lostr</a> <a href="../../collection/immutable/List.scala.html#63655" title="(that: scala.collection.GenTraversableOnce[String])(implicit bf: scala.collection.generic.CanBuildFrom[List[String],String,List[String]])List[String]">++</a> <a href="#525774" title="List[String]">histr</a> <a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a> <span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot; | &quot;)" class="string">&quot; | &quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#470266" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="#525770" title="String">boundsStr</a>
      <span class="keyword">else</span> <a href="#525770" title="String">boundsStr</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; _= &quot;)" class="string">&quot; _= &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#470266" title="=&gt; Types.this.Type">inst</a>.<a href="#442077" title="=&gt; String">safeToString</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class TypeUnwrapper extends Object with Types.this.Type =&gt; Types.this.Type" id="441418">TypeUnwrapper</a><a href="#441418" title="Types.this.TypeUnwrapper" class="delimiter">(</a><a title="Boolean" id="525876">poly</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a>, <a title="Boolean" id="525877">existential</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a>, <a title="Boolean" id="525878">annotated</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a>, <a title="Boolean" id="525879">nullary</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a><span class="delimiter">)</span> <span class="keyword">extends</span> <span class="delimiter">(</span>Type =&gt; Type<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="525870">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="525880">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#525880" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> AnnotatedType<a href="#525889" title="Types.this.Type" id="525893" class="delimiter">(</a>_, underlying, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#525878" title="Boolean">annotated</a>   =&gt; <a href="#525870" title="(tp: Types.this.Type)Types.this.Type">apply</a><a href="#525902" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>underlying<span class="delimiter">)</span>
      <span class="keyword">case</span> ExistentialType<a href="#525889" title="Types.this.Type" id="525896" class="delimiter">(</a>_, underlying<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#525877" title="Boolean">existential</a>  =&gt; <a href="#525870" title="(tp: Types.this.Type)Types.this.Type">apply</a><a href="#525902" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>underlying<span class="delimiter">)</span>
      <span class="keyword">case</span> PolyType<a href="#525889" title="Types.this.Type" id="525899" class="delimiter">(</a>_, underlying<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#525876" title="Boolean">poly</a>                =&gt; <a href="#525870" title="(tp: Types.this.Type)Types.this.Type">apply</a><a href="#525902" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>underlying<span class="delimiter">)</span>
      <span class="keyword">case</span> NullaryMethodType<a href="#525889" title="Types.this.Type" id="525901" class="delimiter">(</a>underlying<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#525879" title="Boolean">nullary</a>       =&gt; <a href="#525870" title="(tp: Types.this.Type)Types.this.Type">apply</a><a href="#525902" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>underlying<span class="delimiter">)</span>
      <span class="keyword">case</span> tp                                             =&gt; <a href="#525902" title="(x: Types.this.Type)Types.this.Type">tp</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">class</span> <a title="class ClassUnwrapper extends Types.this.TypeUnwrapper" id="441419">ClassUnwrapper</a><a href="#441419" title="Types.this.ClassUnwrapper" class="delimiter">(</a><a title="Boolean" id="525916">existential</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441418" title="Types.this.TypeUnwrapper">TypeUnwrapper</a><span class="delimiter">(</span>poly = <span title="Boolean(true)" class="keyword">true</span>, <a href="#525916" title="Boolean">existential</a>, annotated = <span title="Boolean(true)" class="keyword">true</span>, nullary = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="525913">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="525917">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#441419" title="Types.this.ClassUnwrapper" class="keyword">super</a>.<a href="#525870" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#525917" title="Types.this.Type">tp</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span>        <a title="Types.this.unwrapToClass.type" id="441420">unwrapToClass</a> <a href="#441421" title="Types.this.unwrapToClass.type" class="keyword">extends</a> <a href="#441419" title="Types.this.ClassUnwrapper">ClassUnwrapper</a><span class="delimiter">(</span>existential = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">}</span>
  <span class="keyword">object</span>  <a title="Types.this.unwrapToStableClass.type" id="441422">unwrapToStableClass</a> <a href="#441423" title="Types.this.unwrapToStableClass.type" class="keyword">extends</a> <a href="#441419" title="Types.this.ClassUnwrapper">ClassUnwrapper</a><span class="delimiter">(</span>existential = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">}</span>
  <span class="keyword">object</span>   <a title="Types.this.unwrapWrapperTypes.type" id="441424">unwrapWrapperTypes</a> <a href="#441425" title="Types.this.unwrapWrapperTypes.type" class="keyword">extends</a>  <a href="#441418" title="Types.this.TypeUnwrapper">TypeUnwrapper</a><span class="delimiter">(</span><span title="Boolean(true)" class="keyword">true</span>, <span title="Boolean(true)" class="keyword">true</span>, <span title="Boolean(true)" class="keyword">true</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait AnnotationFilter extends Types.this.TypeMap" id="441426">AnnotationFilter</a> <a href="../../Unit.scala.html#2389" title="Unit" class="keyword">extends</a> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(annot: Types.this.AnnotationInfo)Boolean" id="461716">keepAnnotation</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="525930">annot</a>: <a href="AnnotationInfos.scala.html#441795" title="Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(annot: Types.this.AnnotationInfo)Types.this.AnnotationInfo" id="461717">mapOver</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="525931">annot</a>: <a href="AnnotationInfos.scala.html#441795" title="Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span> =
      <span title="Types.this.AnnotationInfo" class="keyword">if</span> <span class="delimiter">(</span><a href="#461716" title="(annot: Types.this.AnnotationInfo)Boolean">keepAnnotation</a><span class="delimiter">(</span><a href="#525931" title="Types.this.AnnotationInfo">annot</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#441426" title="Types.this.AnnotationFilter" class="keyword">super</a>.<a href="#460846" title="(annot: Types.this.AnnotationInfo)Types.this.AnnotationInfo">mapOver</a><span class="delimiter">(</span><a href="#525931" title="Types.this.AnnotationInfo">annot</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="AnnotationInfos.scala.html#441798" title="Types.this.UnmappableAnnotation.type">UnmappableAnnotation</a>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait KeepOnlyTypeConstraints extends Types.this.TypeMap with Types.this.AnnotationFilter" id="441427">KeepOnlyTypeConstraints</a> <a href="../../Unit.scala.html#2389" title="Unit" class="keyword">extends</a> <a href="#441426" title="Types.this.AnnotationFilter">AnnotationFilter</a> <span class="delimiter">{</span>
    // filter keeps only type constraint annotations
    <span class="keyword">def</span> <a title="(annot: Types.this.AnnotationInfo)Boolean" id="461719">keepAnnotation</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="525942">annot</a>: <a href="AnnotationInfos.scala.html#441795" title="Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span> = <a href="#525942" title="Types.this.AnnotationInfo">annot</a> <a href="AnnotationInfos.scala.html#443806" title="(clazz: Types.this.Symbol)Boolean">matches</a> <a href="Definitions.scala.html#442281" title="=&gt; Types.this.ClassSymbol">TypeConstraintClass</a>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait VariantTypeMap extends Types.this.TypeMap" id="441428">VariantTypeMap</a> <a href="../../Unit.scala.html#2389" title="Unit" class="keyword">extends</a> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">var</span> <a title="Int" id="524011">_variance</a> = <span title="Int(1)" class="int">1</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="524012">variance</a> = <a href="#524011" title="Int">_variance</a>
    <span class="keyword">def</span> <a title="(x: Int)Unit" id="524013">variance_=</a><span class="delimiter">(</span><a title="Int" id="525950">x</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span> = <a href="#524011" title="Int">_variance</a> = <a href="#525950" title="Int">x</a>

    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(origSyms: List[Types.this.Symbol])Boolean" id="524014">noChangeToSymbols</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="525951">origSyms</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#525951" title="List[Types.this.Symbol]">origSyms</a> <a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</a> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="525976">sym</a> =&gt;
        <span class="keyword">val</span> <a title="Int" id="525977">v</a> = <a href="#524012" title="=&gt; Int">variance</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#525976" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443232" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span> <a href="#524013" title="(x: Int)Unit">variance</a> = <span title="Int(0)" class="int">0</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="525978">result</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#525976" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span>
        <a href="#524013" title="(x: Int)Unit">variance</a> = <a href="#525977" title="Int">v</a>
        <a href="#525978" title="Types.this.Type">result</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#525976" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]" id="524015">mapOverArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="525987">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="525988">tparams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> =
      <a href="#441530" title="(xs: List[Types.this.Type], ys: List[Types.this.Symbol])(f: (Types.this.Type, Types.this.Symbol) =&gt; Types.this.Type)List[Types.this.Type]">map2Conserve</a><span class="delimiter">(</span><a href="#525987" title="List[Types.this.Type]">args</a>, <a href="#525988" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Type" id="526020">arg</a>, <a title="Types.this.Symbol" id="526021">tparam</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Int" id="526022">v</a> = <a href="#524012" title="=&gt; Int">variance</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#526021" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443250" title="=&gt; Boolean">isContravariant</a><span class="delimiter">)</span> <a href="#524013" title="(x: Int)Unit">variance</a> = <a href="../../Int.scala.html#57880" title="=&gt; Int">-</a><a href="#524012" title="=&gt; Int">variance</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#526021" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443251" title="=&gt; Boolean">isCovariant</a><span class="delimiter">)</span> <a href="#524013" title="(x: Int)Unit">variance</a> = <span title="Int(0)" class="int">0</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="526023">arg1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#526020" title="Types.this.Type">arg</a><span class="delimiter">)</span>
        <a href="#524013" title="(x: Int)Unit">variance</a> = <a href="#526022" title="Int">v</a>
        <a href="#526023" title="Types.this.Type">arg1</a>
      <span class="delimiter">}</span>

    /** Map this function over given type */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="524016">mapOver</a><span class="delimiter">(</span><a title="Types.this.Type" id="526032">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#526032" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> MethodType<a href="#526123" title="Types.this.Type" id="526125" class="delimiter">(</a>params, result<span class="delimiter">)</span> =&gt;
        <a href="#524013" title="(x: Int)Unit">variance</a> = <a href="../../Int.scala.html#57880" title="=&gt; Int">-</a><a href="#524012" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="526036">params1</a> = <a href="#460845" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span>params<span class="delimiter">)</span>
        <a href="#524013" title="(x: Int)Unit">variance</a> = <a href="../../Int.scala.html#57880" title="=&gt; Int">-</a><a href="#524012" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="526037">result1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>result<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#526036" title="List[Types.this.Symbol]">params1</a> <span title="(x$1: AnyRef)Boolean">eq</span> params<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#526037" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> result<span class="delimiter">)</span><span class="delimiter">)</span> <a href="#526032" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#441374" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#526032" title="Types.this.Type">tp</a>, <a href="#526036" title="List[Types.this.Symbol]">params1</a>, <a href="#526037" title="Types.this.Type">result1</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>params, <a href="#526036" title="List[Types.this.Symbol]">params1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> PolyType<a href="#526123" title="Types.this.Type" id="526127" class="delimiter">(</a>tparams, result<span class="delimiter">)</span> =&gt;
        <a href="#524013" title="(x: Int)Unit">variance</a> = <a href="../../Int.scala.html#57880" title="=&gt; Int">-</a><a href="#524012" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="526054">tparams1</a> = <a href="#460845" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span>tparams<span class="delimiter">)</span>
        <a href="#524013" title="(x: Int)Unit">variance</a> = <a href="../../Int.scala.html#57880" title="=&gt; Int">-</a><a href="#524012" title="=&gt; Int">variance</a>
        <span class="keyword">var</span> <a title="Types.this.Type" id="526055">result1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>result<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#526054" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">eq</span> tparams<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#526055" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> result<span class="delimiter">)</span><span class="delimiter">)</span> <a href="#526032" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#448476" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#526054" title="List[Types.this.Symbol]">tparams1</a>, <a href="#526055" title="Types.this.Type">result1</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>tparams, <a href="#526054" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> TypeBounds<a href="#526123" title="Types.this.Type" id="526129" class="delimiter">(</a>lo, hi<span class="delimiter">)</span> =&gt;
        <a href="#524013" title="(x: Int)Unit">variance</a> = <a href="../../Int.scala.html#57880" title="=&gt; Int">-</a><a href="#524012" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="526072">lo1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>lo<span class="delimiter">)</span>
        <a href="#524013" title="(x: Int)Unit">variance</a> = <a href="../../Int.scala.html#57880" title="=&gt; Int">-</a><a href="#524012" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="526073">hi1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>hi<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#526072" title="Types.this.Type">lo1</a> <span title="(x$1: AnyRef)Boolean">eq</span> lo<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#526073" title="Types.this.Type">hi1</a> <span title="(x$1: AnyRef)Boolean">eq</span> hi<span class="delimiter">)</span><span class="delimiter">)</span> <a href="#526032" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#448285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#526072" title="Types.this.Type">lo1</a>, <a href="#526073" title="Types.this.Type">hi1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> tr @ TypeRef<a href="#526123" title="Types.this.Type" id="526131" class="delimiter">(</a>pre, sym, args<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="526094">pre1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>pre<span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="526095">args1</a> =
          <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span>args.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span>
            args
          <span class="keyword">else</span> <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#524012" title="=&gt; Int">variance</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> // fast &amp; safe path: don't need to look at typeparams
            args <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</a> <a href="#441428" title="Types.this.VariantTypeMap" class="keyword">this</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="526115">tparams</a> = sym.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a>
            <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#526115" title="List[Types.this.Symbol]">tparams</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> args
            <span class="keyword">else</span> <a href="#524015" title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">mapOverArgs</a><span class="delimiter">(</span>args, <a href="#526115" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#526094" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> pre<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#526095" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> args<span class="delimiter">)</span><span class="delimiter">)</span> <a href="#526032" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#441372" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#526032" title="Types.this.Type">tp</a>, <a href="#526094" title="Types.this.Type">pre1</a>, tr.<a href="#448127" title="(pre1: Types.this.Type)Types.this.Symbol">coevolveSym</a><span class="delimiter">(</span><a href="#526094" title="Types.this.Type">pre1</a><span class="delimiter">)</span>, <a href="#526095" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#441428" title="Types.this.VariantTypeMap" class="keyword">super</a>.<a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#526132" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#526032" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  // todo. move these into scala.reflect.api

  /** A prototype for mapping a function over all possible types
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeMap extends Object with Types.this.Type =&gt; Types.this.Type" id="441429">TypeMap</a> <a href="#441429" title="Types.this.TypeMap" class="keyword">extends</a> <span class="delimiter">(</span>Type =&gt; Type<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="460839">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="460869">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a>

    /** Mix in VariantTypeMap if you want variances to be significant.
     */
    <span class="keyword">def</span> <a title="=&gt; Int" id="460840">variance</a> = <span title="Int(0)" class="int">0</span>

    /** Map this function over given type */
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="460841">mapOver</a><span class="delimiter">(</span><a title="Types.this.Type" id="462777">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#462777" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> tr @ TypeRef<a href="#526386" title="Types.this.Type" id="526388" class="delimiter">(</a>pre, sym, args<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="526145">pre1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>pre<span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="526146">args1</a> = args <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</a> <a href="#441429" title="Types.this.TypeMap" class="keyword">this</a>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#526145" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> pre<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#526146" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> args<span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462777" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#441372" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#462777" title="Types.this.Type">tp</a>, <a href="#526145" title="Types.this.Type">pre1</a>, tr.<a href="#448127" title="(pre1: Types.this.Type)Types.this.Symbol">coevolveSym</a><span class="delimiter">(</span><a href="#526145" title="Types.this.Type">pre1</a><span class="delimiter">)</span>, <a href="#526146" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> ThisType<a href="#526386" title="Types.this.Type" id="526391" class="delimiter">(</a>_<span class="delimiter">)</span> =&gt; <a href="#526427" title="(x: Types.this.Type)Types.this.Type">tp</a>
      <span class="keyword">case</span> SingleType<a href="#526386" title="Types.this.Type" id="526393" class="delimiter">(</a>pre, sym<span class="delimiter">)</span> =&gt;
        <a href="#526427" title="(x: Types.this.Type)Types.this.Type" class="keyword">if</a> <span class="delimiter">(</span>sym.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#462777" title="Types.this.Type">tp</a> // short path
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="526163">pre1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>pre<span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#526163" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> pre<span class="delimiter">)</span> <a href="#462777" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#441367" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#526163" title="Types.this.Type">pre1</a>, sym<span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> MethodType<a href="#526386" title="Types.this.Type" id="526395" class="delimiter">(</a>params, result<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="526174">params1</a> = <a href="#460845" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span>params<span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="526175">result1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>result<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#526174" title="List[Types.this.Symbol]">params1</a> <span title="(x$1: AnyRef)Boolean">eq</span> params<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#526175" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> result<span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462777" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#441374" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#462777" title="Types.this.Type">tp</a>, <a href="#526174" title="List[Types.this.Symbol]">params1</a>, <a href="#526175" title="Types.this.Type">result1</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>params, <a href="#526174" title="List[Types.this.Symbol]">params1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> PolyType<a href="#526386" title="Types.this.Type" id="526397" class="delimiter">(</a>tparams, result<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="526192">tparams1</a> = <a href="#460845" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span>tparams<span class="delimiter">)</span>
        <span class="keyword">var</span> <a title="Types.this.Type" id="526193">result1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>result<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#526192" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">eq</span> tparams<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#526193" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> result<span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462777" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#448476" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#526192" title="List[Types.this.Symbol]">tparams1</a>, <a href="#526193" title="Types.this.Type">result1</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>tparams, <a href="#526192" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> NullaryMethodType<a href="#526386" title="Types.this.Type" id="526399" class="delimiter">(</a>result<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="526209">result1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>result<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#526209" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> result<span class="delimiter">)</span> <a href="#462777" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#448427" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#526209" title="Types.this.Type">result1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> ConstantType<a href="#526386" title="Types.this.Type" id="526402" class="delimiter">(</a>_<span class="delimiter">)</span> =&gt; <a href="#526427" title="(x: Types.this.Type)Types.this.Type">tp</a>
      <span class="keyword">case</span> SuperType<a href="#526386" title="Types.this.Type" id="526404" class="delimiter">(</a>thistp, supertp<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="526221">thistp1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>thistp<span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="526222">supertp1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>supertp<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#526221" title="Types.this.Type">thistp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> thistp<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#526222" title="Types.this.Type">supertp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> supertp<span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462777" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#461391" title="(thistp: Types.this.Type, supertp: Types.this.Type)Types.this.Type">SuperType</a><span class="delimiter">(</span><a href="#526221" title="Types.this.Type">thistp1</a>, <a href="#526222" title="Types.this.Type">supertp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> TypeBounds<a href="#526386" title="Types.this.Type" id="526406" class="delimiter">(</a>lo, hi<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="526243">lo1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>lo<span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="526244">hi1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>hi<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#526243" title="Types.this.Type">lo1</a> <span title="(x$1: AnyRef)Boolean">eq</span> lo<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#526244" title="Types.this.Type">hi1</a> <span title="(x$1: AnyRef)Boolean">eq</span> hi<span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462777" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#448285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#526243" title="Types.this.Type">lo1</a>, <a href="#526244" title="Types.this.Type">hi1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> BoundedWildcardType<a href="#526386" title="Types.this.Type" id="526408" class="delimiter">(</a>bounds<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="526262">bounds1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>bounds<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#526262" title="Types.this.Type">bounds1</a> <span title="(x$1: AnyRef)Boolean">eq</span> bounds<span class="delimiter">)</span> <a href="#462777" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#469712" title="(bounds: Types.this.TypeBounds)Types.this.BoundedWildcardType">BoundedWildcardType</a><span class="delimiter">(</span><a href="#526262" title="Types.this.Type">bounds1</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.TypeBounds" class="delimiter">[</span><a href="#448315" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">]</span><span class="delimiter">)</span>
      <span class="keyword">case</span> rtp @ RefinedType<a href="#526386" title="Types.this.Type" id="526410" class="delimiter">(</a>parents, decls<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="526275">parents1</a> = parents <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</a> <a href="#441429" title="Types.this.TypeMap" class="keyword">this</a>
        <span class="keyword">val</span> <a title="Types.this.Scope" id="526276">decls1</a> = <a href="#460844" title="(scope: Types.this.Scope)Types.this.Scope">mapOver</a><span class="delimiter">(</span>decls<span class="delimiter">)</span>
        //if ((parents1 eq parents) &amp;&amp; (decls1 eq decls)) tp
        //else refinementOfClass(tp.typeSymbol, parents1, decls1)
        <a href="#441370" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span>rtp, <a href="#526275" title="List[Types.this.Type]">parents1</a>, <a href="#526276" title="Types.this.Scope">decls1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> ExistentialType<a href="#526386" title="Types.this.Type" id="526412" class="delimiter">(</a>tparams, result<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="526291">tparams1</a> = <a href="#460845" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span>tparams<span class="delimiter">)</span>
        <span class="keyword">var</span> <a title="Types.this.Type" id="526292">result1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>result<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#526291" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">eq</span> tparams<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#526292" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> result<span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462777" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#441323" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">(</span><a href="#526291" title="List[Types.this.Symbol]">tparams1</a>, <a href="#526292" title="Types.this.Type">result1</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>tparams, <a href="#526291" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> OverloadedType<a href="#526386" title="Types.this.Type" id="526414" class="delimiter">(</a>pre, alts<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="526309">pre1</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span>pre.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#454759" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">]</span><span class="delimiter">)</span> pre <span class="keyword">else</span> <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>pre<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#526309" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> pre<span class="delimiter">)</span> <a href="#462777" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#536594" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.OverloadedType">OverloadedType</a><span class="delimiter">(</span><a href="#526309" title="Types.this.Type">pre1</a>, alts<span class="delimiter">)</span>
      <span class="keyword">case</span> AntiPolyType<a href="#526386" title="Types.this.Type" id="526416" class="delimiter">(</a>pre, args<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="526320">pre1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>pre<span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="526321">args1</a> = args <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</a> <span class="delimiter">(</span><a href="#441429" title="Types.this.TypeMap" class="keyword">this</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#526320" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> pre<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#526321" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> args<span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462777" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#536598" title="(pre: Types.this.Type, targs: List[Types.this.Type])Types.this.AntiPolyType">AntiPolyType</a><span class="delimiter">(</span><a href="#526320" title="Types.this.Type">pre1</a>, <a href="#526321" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> tv@<a href="#470205" title="Option[(Types.this.Type, Types.this.TypeConstraint)]" id="526447">TypeVar</a><a href="#526386" title="Types.this.Type" id="526419" class="delimiter">(</a>_, constr<span class="delimiter">)</span> =&gt;
        <a href="#526427" title="(x: Types.this.Type)Types.this.Type" class="keyword">if</a> <span class="delimiter">(</span>constr.<a href="#470268" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>constr.<a href="#470266" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
        <span class="keyword">else</span> tv.<a href="#470171" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#460842" title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">mapOverArgs</a><span class="delimiter">(</span>tv.<a href="#470162" title="=&gt; List[Types.this.Type]">typeArgs</a>, tv.<a href="#470161" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span>  //@M !args.isEmpty implies !typeParams.isEmpty
      <span class="keyword">case</span> NotNullType<a href="#526386" title="Types.this.Type" id="526422" class="delimiter">(</a>tp<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="526350">tp1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>tp<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#526350" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> tp<span class="delimiter">)</span> tp
        <span class="keyword">else</span> <a href="#536590" title="(underlying: Types.this.Type)Types.this.NotNullType">NotNullType</a><span class="delimiter">(</span><a href="#526350" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> AnnotatedType<a href="#526386" title="Types.this.Type" id="526424" class="delimiter">(</a>annots, atp, selfsym<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="526363">annots1</a> = <a href="#460847" title="(annots: List[Types.this.AnnotationInfo])List[Types.this.AnnotationInfo]">mapOverAnnotations</a><span class="delimiter">(</span>annots<span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="526364">atp1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>atp<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#526363" title="List[Types.this.AnnotationInfo]">annots1</a> <span title="(x$1: AnyRef)Boolean">eq</span> annots<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#526364" title="Types.this.Type">atp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> atp<span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462777" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#526363" title="List[Types.this.AnnotationInfo]">annots1</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#526364" title="Types.this.Type">atp1</a>
        <span class="keyword">else</span> <a href="#445558" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#526363" title="List[Types.this.AnnotationInfo]">annots1</a>, <a href="#526364" title="Types.this.Type">atp1</a>, selfsym<span class="delimiter">)</span>
      <span class="keyword">case</span> DeBruijnIndex<a href="#526386" title="Types.this.Type" id="526426" class="delimiter">(</a>shift, idx, args<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="526378">args1</a> = args <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</a> <a href="#441429" title="Types.this.TypeMap" class="keyword">this</a>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#526378" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> args<span class="delimiter">)</span> <a href="#462777" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#536635" title="(level: Int, idx: Int, args: List[Types.this.Type])Types.this.DeBruijnIndex">DeBruijnIndex</a><span class="delimiter">(</span>shift, idx, <a href="#526378" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
/*
      case ErrorType =&gt; tp
      case WildcardType =&gt; tp
      case NoType =&gt; tp
      case NoPrefix =&gt; tp
      case ErasedSingleType(sym) =&gt; tp
*/
      <span class="keyword">case</span> _ =&gt;
        <a href="#526427" title="(x: Types.this.Type)Types.this.Type">tp</a>
        // throw new Error(&quot;mapOver inapplicable for &quot; + tp);
    <span class="delimiter">}</span>

    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]" id="460842">mapOverArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="525989">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="525990">tparams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> =
      <a href="#525989" title="List[Types.this.Type]">args</a> <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</a> <a href="#441429" title="Types.this.TypeMap" class="keyword">this</a>

    /** Called by mapOver to determine whether the original symbols can
     *  be returned, or whether they must be cloned.  Overridden in VariantTypeMap.
     */
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(origSyms: List[Types.this.Symbol])Boolean" id="460843">noChangeToSymbols</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="525952">origSyms</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#525952" title="List[Types.this.Symbol]">origSyms</a> <a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="525961">sym</a> =&gt; <a href="#525961" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#460839" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#525961" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span>

    /** Map this function over given scope */
    <span class="keyword">def</span> <a title="(scope: Types.this.Scope)Types.this.Scope" id="460844">mapOver</a><span class="delimiter">(</span><a title="Types.this.Scope" id="462765">scope</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a><span class="delimiter">)</span>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="526458">elems</a> = <a href="#462765" title="Types.this.Scope">scope</a>.<a href="Scopes.scala.html#447344" title="=&gt; List[Types.this.Symbol]">toList</a>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="526459">elems1</a> = <a href="#460845" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#526458" title="List[Types.this.Symbol]">elems</a><span class="delimiter">)</span>
      <span title="Types.this.Scope" class="keyword">if</span> <span class="delimiter">(</span><a href="#526459" title="List[Types.this.Symbol]">elems1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#526458" title="List[Types.this.Symbol]">elems</a><span class="delimiter">)</span> <a href="#462765" title="Types.this.Scope">scope</a>
      <span class="keyword">else</span> <a href="Scopes.scala.html#441631" title="(elems: Types.this.Symbol*)Types.this.Scope">newScopeWith</a><span class="delimiter">(</span><a href="#526459" title="List[Types.this.Symbol]">elems1</a>: _*<span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Map this function over given list of symbols */
    <span class="keyword">def</span> <a title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]" id="460845">mapOver</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="462760">origSyms</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      // fast path in case nothing changes due to map
      <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#460843" title="(origSyms: List[Types.this.Symbol])Boolean">noChangeToSymbols</a><span class="delimiter">(</span><a href="#462760" title="List[Types.this.Symbol]">origSyms</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462760" title="List[Types.this.Symbol]">origSyms</a>
      // map is not the identity --&gt; do cloning properly
      <span class="keyword">else</span> <a href="Symbols.scala.html#441159" title="(syms: List[Types.this.Symbol], infoFn: Types.this.Type =&gt; Types.this.Type)List[Types.this.Symbol]">cloneSymbolsAndModify</a><span class="delimiter">(</span><a href="#462760" title="List[Types.this.Symbol]">origSyms</a>, <a href="#441429" title="Types.this.TypeMap">TypeMap</a>.<span class="keyword">this</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(annot: Types.this.AnnotationInfo)Types.this.AnnotationInfo" id="460846">mapOver</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="462757">annot</a>: <a href="AnnotationInfos.scala.html#441795" title="Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span>: <a href="AnnotationInfos.scala.html#441795" title="Types.this.AnnotationInfo">AnnotationInfo</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="AnnotationInfos.scala.html#443060" title="Option[(Types.this.Type, List[Types.this.Tree], List[(Types.this.Name, Types.this.ClassfileAnnotArg)])]" id="526513">AnnotationInfo</a><a href="#526506" title="(x: (Types.this.Type, List[Types.this.Tree], List[(Types.this.Name, Types.this.ClassfileAnnotArg)]))(Types.this.Type, List[Types.this.Tree], List[(Types.this.Name, Types.this.ClassfileAnnotArg)])" class="delimiter">(</a><a href="../../Tuple3.scala.html#61402" title="Types.this.Type" id="526471">atp</a>, <a href="../../Tuple3.scala.html#61404" title="List[Types.this.Tree]" id="526472">args</a>, <a href="../../Tuple3.scala.html#61406" title="List[(Types.this.Name, Types.this.ClassfileAnnotArg)]" id="526473">assocs</a><span class="delimiter">)</span> = <a href="#462757" title="Types.this.AnnotationInfo">annot</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="526474">atp1</a>  = <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#526471" title="Types.this.Type">atp</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Tree]" id="526475">args1</a> = <a href="#460848" title="(args: List[Types.this.Tree])List[Types.this.Tree]">mapOverAnnotArgs</a><span class="delimiter">(</span><a href="#526472" title="List[Types.this.Tree]">args</a><span class="delimiter">)</span>
      // there is no need to rewrite assocs, as they are constants

      <span title="Types.this.AnnotationInfo" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#526472" title="List[Types.this.Tree]">args</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#526475" title="List[Types.this.Tree]">args1</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#526471" title="Types.this.Type">atp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#526474" title="Types.this.Type">atp1</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462757" title="Types.this.AnnotationInfo">annot</a>
      <span class="keyword">else</span> <span title="Types.this.AnnotationInfo" class="keyword">if</span> <span class="delimiter">(</span><a href="#526475" title="List[Types.this.Tree]">args1</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#526472" title="List[Types.this.Tree]">args</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <a href="AnnotationInfos.scala.html#441798" title="Types.this.UnmappableAnnotation.type">UnmappableAnnotation</a>  // some annotation arg was unmappable
      <span class="keyword">else</span> <a href="AnnotationInfos.scala.html#443059" title="(atp: Types.this.Type, args: List[Types.this.Tree], assocs: List[(Types.this.Name, Types.this.ClassfileAnnotArg)])Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">(</span><a href="#526474" title="Types.this.Type">atp1</a>, <a href="#526475" title="List[Types.this.Tree]">args1</a>, <a href="#526473" title="List[(Types.this.Name, Types.this.ClassfileAnnotArg)]">assocs</a><span class="delimiter">)</span> <a href="AnnotationInfos.scala.html#443802" title="(pos: scala.tools.nsc.util.Position)Types.this.AnnotationInfo">setPos</a> <a href="#462757" title="Types.this.AnnotationInfo">annot</a>.<a href="AnnotationInfos.scala.html#443801" title="=&gt; Types.this.Position">pos</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])List[Types.this.AnnotationInfo]" id="460847">mapOverAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="526365">annots</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="526522">annots1</a> = <a href="#526365" title="List[Types.this.AnnotationInfo]">annots</a> <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.AnnotationInfo =&gt; Types.this.AnnotationInfo)List[Types.this.AnnotationInfo]">mapConserve</a> <a href="#460846" title="(annot: Types.this.AnnotationInfo)Types.this.AnnotationInfo">mapOver</a>
      <span title="List[Types.this.AnnotationInfo]" class="keyword">if</span> <span class="delimiter">(</span><a href="#526522" title="List[Types.this.AnnotationInfo]">annots1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#526365" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span> <a href="#526365" title="List[Types.this.AnnotationInfo]">annots</a>
      <span class="keyword">else</span> <a href="#526522" title="List[Types.this.AnnotationInfo]">annots1</a> <a href="../../collection/TraversableLike.scala.html#58982" title="(p: Types.this.AnnotationInfo =&gt; Boolean)List[Types.this.AnnotationInfo]">filterNot</a> <span class="delimiter">(</span><a href="#526542" title="Types.this.AnnotationInfo">_</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="AnnotationInfos.scala.html#441798" title="Types.this.UnmappableAnnotation.type">UnmappableAnnotation</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Map over a set of annotation arguments.  If any
     *  of the arguments cannot be mapped, then return Nil.  */
    <span class="keyword">def</span> <a title="(args: List[Types.this.Tree])List[Types.this.Tree]" id="460848">mapOverAnnotArgs</a><span class="delimiter">(</span><a title="List[Types.this.Tree]" id="526520">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Tree]" id="526543">args1</a> = <a href="#526520" title="List[Types.this.Tree]">args</a> <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Tree =&gt; Types.this.Tree)List[Types.this.Tree]">mapConserve</a> <a href="#460849" title="(tree: Types.this.Tree)Types.this.Tree">mapOver</a>
      <span title="List[Types.this.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#526543" title="List[Types.this.Tree]">args1</a> <a href="../../collection/SeqLike.scala.html#59768" title="(elem: Any)Boolean">contains</a> <a href="#514846" title="Types.this.UnmappableTree.type">UnmappableTree</a><span class="delimiter">)</span> <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a>
      <span class="keyword">else</span> <a href="#526543" title="List[Types.this.Tree]">args1</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="460849">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="462754">tree</a>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a> =
      <a href="#460850" title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree">mapOver</a><span class="delimiter">(</span><a href="#462754" title="Types.this.Tree">tree</a>, <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <span title="Nothing" class="keyword">return</span> <a href="#514846" title="Types.this.UnmappableTree.type">UnmappableTree</a><span class="delimiter">)</span>

    /** Map a tree that is part of an annotation argument.
     *  If the tree cannot be mapped, then invoke giveup().
     *  The default is to transform the tree with
     *  TypeMapTransformer.
     */
    <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="460850">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="462749">tree</a>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a>, <a title="() =&gt; Nothing" id="462750">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a> =
      <span class="delimiter">(</span><span title="TypeMap.this.TypeMapTransformer" class="keyword">new</span> <a href="#460851" title="TypeMap.this.TypeMapTransformer">TypeMapTransformer</a><span class="delimiter">)</span>.<a href="#526566" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#462749" title="Types.this.Tree">tree</a><span class="delimiter">)</span>

    /** This transformer leaves the tree alone except to remap
     *  its types. */
    <span class="keyword">class</span> <a title="class TypeMapTransformer extends Types.this.Transformer" id="460851">TypeMapTransformer</a> <a href="#460851" title="TypeMap.this.TypeMapTransformer" class="keyword">extends</a> <a href="../api/Trees.scala.html#23768" title="Types.this.Transformer">Transformer</a> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="526566">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="526568">tree</a>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Tree" id="526570">tree1</a> = <a href="#460851" title="TypeMap.this.TypeMapTransformer" class="keyword">super</a>.<a href="../api/Trees.scala.html#438847" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#526568" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="526571">tpe1</a> = <a href="#460839" title="(tp: Types.this.Type)Types.this.Type">TypeMap</a>.<span class="keyword">this</span><span class="delimiter">(</span><a href="#526570" title="Types.this.Tree">tree1</a>.<a href="../api/Trees.scala.html#425060" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
        <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#526568" title="Types.this.Tree">tree</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#526570" title="Types.this.Tree">tree1</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#526568" title="Types.this.Tree">tree</a>.<a href="../api/Trees.scala.html#425060" title="=&gt; Types.this.Type">tpe</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#526571" title="Types.this.Type">tpe1</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#526568" title="Types.this.Tree">tree</a>
        <span class="keyword">else</span>
          <a href="Trees.scala.html#441814" title="implicit scala.reflect.internal.Trees.TreeOps : (tree: Types.this.Tree)Types.this.TreeOps">tree1</a>.<a href="Trees.scala.html#443961" title="=&gt; Types.this.Tree">shallowDuplicate</a>.<a href="../api/Trees.scala.html#425062" title="(tp: Types.this.Type)Types.this.Tree">setType</a><span class="delimiter">(</span><a href="#526571" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeTraverser extends Types.this.TypeMap" id="441430">TypeTraverser</a> <a href="#441430" title="Types.this.TypeTraverser" class="keyword">extends</a> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="514857">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="514874">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#2389" title="Unit">Unit</a>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="514858">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="526589">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span> <a href="#514857" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#526589" title="Types.this.Type">tp</a><span class="delimiter">)</span>; <a href="#526589" title="Types.this.Type">tp</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeTraverserWithResult[T] extends Types.this.TypeTraverser" id="441431">TypeTraverserWithResult</a><span class="delimiter">[</span><a title="" id="441432">T</a><span class="delimiter">]</span> <a href="#441431" title="Types.this.TypeTraverserWithResult[T]" class="keyword">extends</a> <a href="#441430" title="Types.this.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; T" id="526593">result</a>: <a href="#441432" title="T">T</a>
    <span class="keyword">def</span> <a title="()Unit" id="526594">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../../Unit.scala.html#2389" title="Unit">Unit</a>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeCollector[T] extends Types.this.TypeTraverser" id="441433">TypeCollector</a><span class="delimiter">[</span><a title="" id="441434">T</a><span class="delimiter">]</span><a href="#441433" title="Types.this.TypeCollector[T]" class="delimiter">(</a><a title="T" id="514867">initial</a>: <a href="#441434" title="T">T</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441430" title="Types.this.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="T" id="514863">result</a>: <a href="#441434" title="T">T</a> = _
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)T" id="514865">collect</a><span class="delimiter">(</span><a title="Types.this.Type" id="514872">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#514863" title="(x$1: T)Unit">result</a> = <a href="#514867" title="T">initial</a>
      <a href="#514857" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#514872" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <a href="#514863" title="=&gt; T">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A collector that tests for existential types appearing at given variance in a type
   *  @PP: Commenting out due to not being used anywhere.
   */
  // class ContainsVariantExistentialCollector(v: Int) extends TypeCollector(false) with VariantTypeMap {
  //   variance = v
  //
  //   def traverse(tp: Type) = tp match {
  //     case ExistentialType(_, _) if (variance == v) =&gt; result = true
  //     case _ =&gt; mapOver(tp)
  //   }
  // }
  //
  // val containsCovariantExistentialCollector = new ContainsVariantExistentialCollector(1)
  // val containsContravariantExistentialCollector = new ContainsVariantExistentialCollector(-1)

  <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol, tparams: List[Types.this.Symbol])List[Types.this.Symbol]" id="441435">typeParamsToExistentials</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="459715">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="459716">tparams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="List[Types.this.TypeSymbol]" id="526598">eparams</a> = <a href="util/Collections.scala.html#440714" title="(xs: List[Types.this.Symbol])(f: (Types.this.Symbol, Int) =&gt; Types.this.TypeSymbol)List[Types.this.TypeSymbol]">mapWithIndex</a><span class="delimiter">(</span><a href="#459716" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="526617">tparam</a>, <a title="Int" id="526618">i</a><span class="delimiter">)</span> =&gt;
      <a href="#459715" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#443195" title="(name: Types.this.TypeName, pos: Types.this.Position, newFlags: Long)Types.this.TypeSymbol">newExistential</a><span class="delimiter">(</span><a href="Names.scala.html#440784" title="(s: String)Types.this.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span><span title="(x$1: Any)String">+</span><a href="#526618" title="Int">i</a><span class="delimiter">)</span>, <a href="#459715" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#443167" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span> <a href="Symbols.scala.html#443429" title="(info: Types.this.Type)Types.this.TypeSymbol">setInfo</a> <a href="#526617" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>

    <a href="#526598" title="List[Types.this.TypeSymbol]">eparams</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.TypeSymbol =&gt; Types.this.TypeSymbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeSymbol],Types.this.TypeSymbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</a> <span class="delimiter">(</span><a href="#526655" title="Types.this.TypeSymbol">_</a> <a href="Symbols.scala.html#443431" title="(syms0: List[Types.this.Symbol], syms1: List[Types.this.Symbol])x$78.type">substInfo</a> <span class="delimiter">(</span><a href="#459716" title="List[Types.this.Symbol]">tparams</a>, <a href="#526598" title="List[Types.this.TypeSymbol]">eparams</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)List[Types.this.Symbol]" id="441436">typeParamsToExistentials</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="459712">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
    <a href="#441435" title="(clazz: Types.this.Symbol, tparams: List[Types.this.Symbol])List[Types.this.Symbol]">typeParamsToExistentials</a><span class="delimiter">(</span><a href="#459712" title="Types.this.Symbol">clazz</a>, <a href="#459712" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span>

  //  note: it's important to write the two tests in this order,
  //  as only typeParams forces the classfile to be read. See #400
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="441437">isRawIfWithoutArgs</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="498379">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
    <a href="#498379" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443231" title="=&gt; Boolean">isClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#498379" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#498379" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#443623" title="=&gt; Boolean">isJavaDefined</a>

  <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean" id="441438">isRaw</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="526693">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="526694">args</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441437" title="(sym: Types.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span><a href="#526693" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#526694" title="List[Types.this.Type]">args</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a>

  /** Is type tp a ''raw type''? */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="441439">isRawType</a><span class="delimiter">(</span><a title="Types.this.Type" id="526697">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#526697" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> TypeRef<a href="#526703" title="Boolean" id="526706" class="delimiter">(</a>_, sym, args<span class="delimiter">)</span> =&gt; <a href="#441438" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><a href="#526707" title="(x: Boolean)Boolean" class="delimiter">(</a>sym, args<span class="delimiter">)</span>
    <span class="keyword">case</span> _ =&gt; <a href="#526707" title="(x: Boolean)Boolean" class="keyword">false</a>
  <span class="delimiter">}</span>

  /** The raw to existential map converts a ''raw type'' to an existential type.
   *  It is necessary because we might have read a raw type of a
   *  parameterized Java class from a class file. At the time we read the type
   *  the corresponding class file might still not be read, so we do not
   *  know what the type parameters of the type are. Therefore
   *  the conversion of raw types to existential types might not have taken place
   *  in ClassFileparser.sigToType (where it is usually done).
   */
  <span class="keyword">def</span> <a title="=&gt; Types.this.TypeMap" id="441440">rawToExistential</a> = <a href="#498353" title="Types.this.TypeMap{}" class="keyword">new</a> <a href="#441429" title="anonymous class $anon extends Types.this.TypeMap" id="498353">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="498356">expanded</a> = immutable.<a href="../../collection/generic/GenericCompanion.scala.html#60782" title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</a><span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="498358">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="498359">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#498359" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> TypeRef<a href="#498486" title="Types.this.Type" id="498489" class="delimiter">(</a>pre, sym, <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="498497">List</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#441437" title="(sym: Types.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span>sym<span class="delimiter">)</span> =&gt;
        <a href="#498493" title="(x: Types.this.Type)Types.this.Type" class="keyword">if</a> <span class="delimiter">(</span><a href="#498356" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">expanded</a> <a href="../../collection/SetLike.scala.html#71318" title="(elem: Types.this.Symbol)Boolean">contains</a> sym<span class="delimiter">)</span> <a href="Definitions.scala.html#442177" title="=&gt; Types.this.AliasTypeSymbol">AnyRefClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a>
        <span class="keyword">else</span> <span class="keyword">try</span> <span class="delimiter">{</span>
          <a href="#498356" title="(x$1: scala.collection.immutable.Set[Types.this.Symbol])Unit">expanded</a> <a href="../../collection/SetLike.scala.html#71319" title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">+=</a> sym
          <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="498387">eparams</a> = <a href="#460845" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#441436" title="(clazz: Types.this.Symbol)List[Types.this.Symbol]">typeParamsToExistentials</a><span class="delimiter">(</span>sym<span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#441386" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#498387" title="List[Types.this.Symbol]">eparams</a>, <a href="#441371" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#498358" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span>pre<span class="delimiter">)</span>, sym, <a href="#498387" title="List[Types.this.Symbol]">eparams</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#498431" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
          <a href="#498356" title="(x$1: scala.collection.immutable.Set[Types.this.Symbol])Unit">expanded</a> <a href="../../collection/SetLike.scala.html#71323" title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">-=</a> sym
        <span class="delimiter">}</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#498493" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#498359" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Used by existentialAbstraction.
   */
  <span class="keyword">class</span> <a title="class ExistentialExtrapolation extends Types.this.TypeMap with Types.this.VariantTypeMap" id="441441">ExistentialExtrapolation</a><a href="#441441" title="Types.this.ExistentialExtrapolation" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="524027">tparams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441428" title="Types.this.VariantTypeMap">VariantTypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[Types.this.Symbol,Int]" id="524020">occurCount</a> = mutable.<a href="../../collection/generic/GenMapFactory.scala.html#61654" title="[A, B](elems: (A, B)*)scala.collection.mutable.HashMap[A,B]">HashMap</a><span title="(elems: (Types.this.Symbol, Int)*)scala.collection.mutable.HashMap[Types.this.Symbol,Int]" class="delimiter">[</span><a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="524022">countOccs</a><span class="delimiter">(</span><a title="Types.this.Type" id="526715">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#526715" title="Types.this.Type">tp</a> <a href="#442050" title="(f: Types.this.Type =&gt; Unit)Unit">foreach</a> <a title="anonymous class $anonfun extends scala.runtime.AbstractFunction1[Types.this.Type,Unit] with Serializable" id="526720" class="delimiter">{</a>
        <span class="keyword">case</span> TypeRef<a href="#526786" title="Unit" id="526790" class="delimiter">(</a>_, sym, _<span class="delimiter">)</span> =&gt;
          <a href="#526791" title="(x: Unit)Unit" class="keyword">if</a> <span class="delimiter">(</span><a href="#524027" title="List[Types.this.Symbol]">tparams</a> <a href="../../collection/SeqLike.scala.html#59768" title="(elem: Any)Boolean">contains</a> sym<span class="delimiter">)</span>
            <a href="../../collection/mutable/HashMap.scala.html#79209" title="(key: Types.this.Symbol, value: Int)Unit">occurCount</a><span class="delimiter">(</span>sym<span class="delimiter">)</span> <a href="../../Int.scala.html#57948" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
        <span class="keyword">case</span> _ =&gt; <a href="#526791" title="(x: Unit)Unit" class="delimiter">(</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tpe: Types.this.Type)Types.this.Type" id="524023">extrapolate</a><span class="delimiter">(</span><a title="Types.this.Type" id="524028">tpe</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#524027" title="List[Types.this.Symbol]">tparams</a> <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.Symbol =&gt; Unit)Unit">foreach</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="526821">t</a> =&gt; <a href="../../collection/mutable/HashMap.scala.html#79209" title="(key: Types.this.Symbol, value: Int)Unit">occurCount</a><span class="delimiter">(</span><a href="#526821" title="Types.this.Symbol">t</a><span class="delimiter">)</span> = <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      <a href="#524022" title="(tp: Types.this.Type)Unit">countOccs</a><span class="delimiter">(</span><a href="#524028" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="526834">tparam</a> &lt;- <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span>
        <a href="#524022" title="(tp: Types.this.Type)Unit">countOccs</a><span class="delimiter">(</span><a href="#526834" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span>

      <a href="#524024" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#524028" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="524024">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="526836">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="526840">tp1</a> = <a href="#524025" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#526836" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#524012" title="=&gt; Int">variance</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#526840" title="Types.this.Type">tp1</a>
      <span class="keyword">else</span> <a href="#526840" title="Types.this.Type">tp1</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> TypeRef<a href="#526924" title="Types.this.Type" id="526926" class="delimiter">(</a>pre, sym, args<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#524027" title="List[Types.this.Symbol]">tparams</a> <a href="../../collection/SeqLike.scala.html#59768" title="(elem: Any)Boolean">contains</a> sym =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="526884">repl</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#524012" title="=&gt; Int">variance</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#498055" title="(tp: Types.this.Type)Types.this.Type">dropSingletonType</a><span class="delimiter">(</span><a href="#526840" title="Types.this.Type">tp1</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#526840" title="Types.this.Type">tp1</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448327" title="=&gt; Types.this.Type">lo</a>
          //println(&quot;eliminate &quot;+sym+&quot;/&quot;+repl+&quot;/&quot;+occurCount(sym)+&quot;/&quot;+(tparams exists (repl.contains)))//DEBUG
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#526884" title="Types.this.Type">repl</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443236" title="=&gt; Boolean">isBottomClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../collection/mutable/HashMap.scala.html#79206" title="(key: Types.this.Symbol)Int">occurCount</a><span class="delimiter">(</span>sym<span class="delimiter">)</span> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(1)" class="int">1</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#524027" title="List[Types.this.Symbol]">tparams</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#526884" title="Types.this.Type">repl</a>.<a href="#442056" title="(sym: Types.this.Symbol)Boolean">contains</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#526884" title="Types.this.Type">repl</a>
          <span class="keyword">else</span> <a href="#526840" title="Types.this.Type">tp1</a>
        <span class="keyword">case</span> _ =&gt;
          <a href="#526927" title="(x: Types.this.Type)Types.this.Type">tp1</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="524025">mapOver</a><span class="delimiter">(</span><a title="Types.this.Type" id="526841">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#526841" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> SingleType<a href="#526951" title="Types.this.Type" id="526953" class="delimiter">(</a>pre, sym<span class="delimiter">)</span> =&gt;
        <a href="#526954" title="(x: Types.this.Type)Types.this.Type" class="keyword">if</a> <span class="delimiter">(</span>sym.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#526841" title="Types.this.Type">tp</a> // short path
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="526934">pre1</a> = <a href="#524024" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>pre<span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#526934" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> pre<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#526934" title="Types.this.Type">pre1</a>.<a href="#441973" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#526841" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#441367" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#526934" title="Types.this.Type">pre1</a>, sym<span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> _ =&gt; <a href="#441441" title="Types.this.ExistentialExtrapolation" class="keyword">super</a>.<a href="#524016" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#526954" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#526841" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    // Do not discard the types of existential ident's. The
    // symbol of the Ident itself cannot be listed in the
    // existential's parameters, so the resulting existential
    // type would be ill-formed.
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="524026">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="526844">tree</a>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a><span class="delimiter">)</span> = <a href="#526844" title="Types.this.Tree">tree</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Ident<a href="#526861" title="Types.this.Tree" id="526864" class="delimiter">(</a>_<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#526844" title="Types.this.Tree">tree</a>.<a href="../api/Trees.scala.html#425060" title="=&gt; Types.this.Type">tpe</a>.<a href="#441973" title="=&gt; Boolean">isStable</a> =&gt; <a href="#526865" title="(x: Types.this.Tree)Types.this.Tree">tree</a>
      <span class="keyword">case</span> _                             =&gt; <a href="#441441" title="Types.this.ExistentialExtrapolation" class="keyword">super</a>.<a href="#460849" title="(tree: Types.this.Tree)Types.this.Tree">mapOver</a><a href="#526865" title="(x: Types.this.Tree)Types.this.Tree" class="delimiter">(</a><a href="#526844" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(hi: Types.this.Type)Types.this.TypeBounds" id="441442">singletonBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="466556">hi</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#516870" title="Types.this.TypeBounds.type">TypeBounds</a>.<a href="#448283" title="(hi: Types.this.Type)Types.this.TypeBounds">upper</a><span class="delimiter">(</span><a href="#441376" title="(tps: List[Types.this.Type])Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><a href="#466556" title="Types.this.Type">hi</a>, <a href="Definitions.scala.html#442283" title="=&gt; Types.this.ClassSymbol">SingletonClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  /** A map to compute the asSeenFrom method  */
  <span class="keyword">class</span> <a title="class AsSeenFromMap extends Types.this.TypeMap with Types.this.KeepOnlyTypeConstraints" id="441443">AsSeenFromMap</a><a href="#441443" title="Types.this.AsSeenFromMap" class="delimiter">(</a><a title="Types.this.Type" id="515187">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="515188">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="keyword">with</span> <a href="#441427" title="Types.this.KeepOnlyTypeConstraints">KeepOnlyTypeConstraints</a> <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="515175">capturedSkolems</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>
    <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="515178">capturedParams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>
    <span class="keyword">var</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]" id="515181">capturedPre</a> = <a href="#441224" title="=&gt; scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]">emptySymMap</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="515183">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="526979">tree</a>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a>, <a title="() =&gt; Nothing" id="526980">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="annotationArgRewriter.type" id="526983">annotationArgRewriter</a> <a href="#526984" title="annotationArgRewriter.type" class="keyword">extends</a> <a href="#460851" title="AsSeenFromMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>
        /** Rewrite `This` trees in annotation argument trees */
        <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="526986">rewriteThis</a><span class="delimiter">(</span><a title="Types.this.Tree" id="526989">tree</a>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a> =
          <a href="#526989" title="Types.this.Tree">tree</a> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> This<a href="#527056" title="Types.this.Tree" id="527059" class="delimiter">(</a>_<span class="delimiter">)</span>
            <span class="keyword">if</span> <span class="delimiter">(</span><a href="#526989" title="Types.this.Tree">tree</a>.<a href="../api/Trees.scala.html#425064" title="=&gt; Types.this.Symbol">symbol</a> <a href="Symbols.scala.html#443468" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#515188" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
               <span class="delimiter">(</span><a href="#515187" title="Types.this.Type">pre</a>.<a href="#441990" title="=&gt; Types.this.Type">widen</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#443468" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#526989" title="Types.this.Tree">tree</a>.<a href="../api/Trees.scala.html#425064" title="=&gt; Types.this.Symbol">symbol</a><span class="delimiter">)</span> =&gt;
              <a href="#527060" title="(x: Types.this.Tree)Types.this.Tree" class="keyword">if</a> <span class="delimiter">(</span><a href="#515187" title="Types.this.Type">pre</a>.<a href="#441973" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <span class="delimiter">{</span> // XXX why is this in this method? pull it out and guard the call `annotationArgRewriter.transform(tree)`?
                <span class="keyword">val</span> <a title="Types.this.TermSymbol" id="526996">termSym</a> = <span class="delimiter">(</span>
                  <a href="#515187" title="Types.this.Type">pre</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443379" title="Types.this.Symbol" id="527007">owner</a>.<a href="Symbols.scala.html#457650" title="Long" id="527010">newValue</a><span class="delimiter">(</span><a href="#515187" title="Types.this.Type">pre</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443152" title="=&gt; Types.this.Symbol#NameType">name</a>.<a href="Names.scala.html#444126" title="Types.this.TermName" id="527008">toTermName</a>, <a href="#515187" title="Types.this.Type">pre</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443167" title="Types.this.Position" id="527009">pos</a><span class="delimiter">)</span> // what symbol should really be used?
                    <a href="Symbols.scala.html#443429" title="(info: Types.this.Type)Types.this.TermSymbol">setInfo</a> <a href="#515187" title="Types.this.Type">pre</a>
                <span class="delimiter">)</span>
                <a href="TreeBuildUtil.scala.html#441926" title="=&gt; Types.this.TreeGen{val global: Types.this.type}">gen</a>.<a href="../api/TreeBuildUtil.scala.html#426849" title="((tpe: _2604.global.Type, termSym: _2604.global.Symbol)_2604.global.Tree) forSome { val _2604: Types.this.TreeGen{val global: Types.this.type} }">mkAttributedQualifier</a><span class="delimiter">(</span><a href="#515187" title="Types.this.Type">pre</a>, <a href="#526996" title="Types.this.TermSymbol">termSym</a><span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">else</span>
                <a href="../../Function0.scala.html#68359" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span>

            <span class="keyword">case</span> tree =&gt; <a href="#527060" title="(x: Types.this.Tree)Types.this.Tree">tree</a>
          <span class="delimiter">}</span>

        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="526987">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="527065">tree</a>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a> = <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Tree" id="527068">tree1</a> = <a href="#526986" title="(tree: Types.this.Tree)Types.this.Tree">rewriteThis</a><span class="delimiter">(</span><span class="keyword">super</span>.<a href="#526566" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#527065" title="Types.this.Tree">tree</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#527068" title="Types.this.Tree">tree1</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#526983" title="annotationArgRewriter.type">annotationArgRewriter</a>.<a href="#526987" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#526979" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="515184">stabilize</a><span class="delimiter">(</span><a title="Types.this.Type" id="527071">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="527072">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
      <a href="#515181" title="=&gt; scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]">capturedPre</a>.<a href="../../collection/MapLike.scala.html#78417" title="(key: Types.this.Symbol, default: =&gt; Types.this.Symbol)Types.this.Symbol">getOrElse</a><span class="delimiter">(</span><a href="#527072" title="Types.this.Symbol">clazz</a>, <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.TypeSymbol" id="527105">qvar</a> = <a href="#527072" title="Types.this.Symbol">clazz</a> <a href="Symbols.scala.html#443202" title="(suffix: String)Types.this.TypeSymbol">freshExistential</a> <span title="String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span> <a href="Symbols.scala.html#443429" title="(info: Types.this.Type)Types.this.TypeSymbol">setInfo</a> <a href="#441442" title="(hi: Types.this.Type)Types.this.TypeBounds">singletonBounds</a><span class="delimiter">(</span><a href="#527071" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <a href="#515181" title="(x$1: scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol])Unit">capturedPre</a> <a href="../../collection/immutable/Map.scala.html#63373" title="(kv: (Types.this.Symbol, Types.this.Symbol))scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]">+=</a> <span class="delimiter">(</span><a href="../../Predef.scala.html#8484" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">clazz</a> <a href="../../Predef.scala.html#63591" title="(y: Types.this.TypeSymbol)(Types.this.Symbol, Types.this.TypeSymbol)">-&gt;</a> <a href="#527105" title="Types.this.TypeSymbol">qvar</a><span class="delimiter">)</span>
          <a href="#515178" title="(x$1: List[Types.this.Symbol])Unit">capturedParams</a> = <a href="#527105" title="Types.this.TypeSymbol">qvar</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#515178" title="=&gt; List[Types.this.Symbol]">capturedParams</a>
          <a href="#527105" title="Types.this.TypeSymbol">qvar</a>
      <span class="delimiter">}</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a>

    /** Return `pre.baseType(clazz)`, or if that's `NoType` and `clazz` is a refinement, `pre` itself.
     *  See bug397.scala for an example where the second alternative is needed.
     *  The problem is that when forming the base type sequence of an abstract type,
     *  any refinements in the base type list might be regenerated, and thus acquire
     *  new class symbols. However, since refinements always have non-interesting prefixes
     *  it looks OK to me to just take the prefix directly. */
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="515185">base</a><span class="delimiter">(</span><a title="Types.this.Type" id="527201">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="527202">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="527205">b</a> = <a href="#527201" title="Types.this.Type">pre</a>.<a href="#442036" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#527202" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#527205" title="Types.this.Type">b</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#516490" title="Types.this.NoType.type">NoType</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#527202" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#443248" title="=&gt; Boolean">isRefinementClass</a><span class="delimiter">)</span> <a href="#527201" title="Types.this.Type">pre</a>
      <span class="keyword">else</span> <a href="#527205" title="Types.this.Type">b</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="515186">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="515189">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#515187" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#515187" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516520" title="Types.this.NoPrefix.type">NoPrefix</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#515188" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#443231" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span> <a href="#515189" title="Types.this.Type">tp</a>
      <span class="keyword">else</span> <a href="#515189" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> ThisType<a href="#527487" title="Types.this.Type" id="527489" class="delimiter">(</a>sym<span class="delimiter">)</span> =&gt;
          <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="527212">toPrefix</a><span class="delimiter">(</span><a title="Types.this.Type" id="527213">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="527214">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#527213" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#527213" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516520" title="Types.this.NoPrefix.type">NoPrefix</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#527214" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#443231" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span> <a href="#515189" title="Types.this.Type">tp</a>
            <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span>sym <a href="Symbols.scala.html#443468" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#527214" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
                     <span class="delimiter">(</span><a href="#527213" title="Types.this.Type">pre</a>.<a href="#441990" title="=&gt; Types.this.Type">widen</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#443468" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> sym<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="527218">pre1</a> = <a href="#527213" title="Types.this.Type">pre</a> <span class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> SuperType<a href="#527221" title="Types.this.Type" id="527224" class="delimiter">(</a>thistp, _<span class="delimiter">)</span> =&gt; <a href="#527225" title="(x: Types.this.Type)Types.this.Type">thistp</a>
                <span class="keyword">case</span> _ =&gt; <a href="#527225" title="(x: Types.this.Type)Types.this.Type">pre</a>
              <span class="delimiter">}</span>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#527218" title="Types.this.Type">pre1</a>.<a href="#441973" title="=&gt; Boolean">isStable</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
                    <a href="#527218" title="Types.this.Type">pre1</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
                    <a href="#527218" title="Types.this.Type">pre1</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443245" title="=&gt; Boolean">isModuleClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#527218" title="Types.this.Type">pre1</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443356" title="=&gt; Boolean">isStatic</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="#515184" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">stabilize</a><span class="delimiter">(</span><a href="#527218" title="Types.this.Type">pre1</a>, sym<span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                <a href="#527218" title="Types.this.Type">pre1</a>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <a href="#527212" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toPrefix</a><span class="delimiter">(</span><a href="#515185" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">base</a><span class="delimiter">(</span><a href="#527213" title="Types.this.Type">pre</a>, <a href="#527214" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>.<a href="#441997" title="=&gt; Types.this.Type">prefix</a>, <a href="#527214" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <a href="#527212" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toPrefix</a><span class="delimiter">(</span><a href="#515187" title="Types.this.Type">pre</a>, <a href="#515188" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="keyword">case</span> SingleType<a href="#527487" title="Types.this.Type" id="527491" class="delimiter">(</a>pre, sym<span class="delimiter">)</span> =&gt;
          <a href="#527494" title="(x: Types.this.Type)Types.this.Type" class="keyword">if</a> <span class="delimiter">(</span>sym.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#515189" title="Types.this.Type">tp</a> // short path
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="527233">pre1</a> = <a href="#515186" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>pre<span class="delimiter">)</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#527233" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> pre<span class="delimiter">)</span> <a href="#515189" title="Types.this.Type">tp</a>
            <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#527233" title="Types.this.Type">pre1</a>.<a href="#441973" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#441367" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#527233" title="Types.this.Type">pre1</a>, sym<span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#527233" title="Types.this.Type">pre1</a>.<a href="#442039" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span>sym<span class="delimiter">)</span>.<a href="#442002" title="=&gt; Types.this.Type">resultType</a> //todo: this should be rolled into existential abstraction
          <span class="delimiter">}</span>
        // AM: Martin, is this description accurate?
        // walk the owner chain of `clazz` (the original argument to asSeenFrom) until we find the type param's owner (while rewriting pre as we crawl up the owner chain)
        // once we're at the owner, extract the information that pre encodes about the type param,
        // by minimally subsuming pre to the type instance of the class that owns the type param,
        // the type we're looking for is the type instance's type argument at the position corresponding to the type parameter
        // optimisation: skip this type parameter if it's not owned by a class, as those params are not influenced by the prefix through which they are seen
        // (concretely: type params of anonymous type functions, which currently can only arise from normalising type aliases, are owned by the type alias of which they are the eta-expansion)
        // (skolems also aren't affected: they are ruled out by the isTypeParameter check)
        <span class="keyword">case</span> TypeRef<a href="#527487" title="Types.this.Type" id="527493" class="delimiter">(</a>prefix, sym, args<span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span>sym.<a href="Symbols.scala.html#443256" title="=&gt; Boolean">isTypeParameter</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> sym.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#443231" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="527248">toInstance</a><span class="delimiter">(</span><a title="Types.this.Type" id="527249">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="527250">clazz</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#527249" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#527249" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516520" title="Types.this.NoPrefix.type">NoPrefix</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#527250" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#443231" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span> <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#515189" title="Types.this.Type">tp</a><span class="delimiter">)</span>
            //@M! see test pos/tcpoly_return_overriding.scala why mapOver is necessary
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span class="keyword">def</span> <a title="=&gt; Nothing" id="527259">throwError</a> = <a href="SymbolTable.scala.html#440549" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#515189" title="Types.this.Type">tp</a> <span title="(x$1: Any)String">+</span> sym.<a href="Symbols.scala.html#443561" title="=&gt; String">locationString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; cannot be instantiated from &quot;)" class="string">&quot; cannot be instantiated from &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#527249" title="Types.this.Type">pre</a>.<a href="#441990" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>

              <span class="keyword">val</span> <a title="Types.this.Symbol" id="527260">symclazz</a> = sym.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#527260" title="Types.this.Symbol">symclazz</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#527250" title="Types.this.Symbol">clazz</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#527249" title="Types.this.Type">pre</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#441345" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#527249" title="Types.this.Type">pre</a>.<a href="#441990" title="=&gt; Types.this.Type">widen</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#443468" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#527260" title="Types.this.Symbol">symclazz</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                // have to deconst because it may be a Class[T].
                <a href="#527249" title="Types.this.Type">pre</a>.<a href="#442036" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#527260" title="Types.this.Symbol">symclazz</a><span class="delimiter">)</span>.<a href="#441991" title="=&gt; Types.this.Type">deconst</a> <span class="keyword">match</span> <span class="delimiter">{</span>
                  <span class="keyword">case</span> TypeRef<a href="#527466" title="Types.this.Type" id="527469" class="delimiter">(</a>_, basesym, baseargs<span class="delimiter">)</span> =&gt;

                   <span class="keyword">def</span> <a title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type" id="527273">instParam</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="527275">ps</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="527276">as</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
                      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#527275" title="List[Types.this.Symbol]">ps</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#441909" title="=&gt; Boolean">forInteractive</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                          <span class="keyword">val</span> <a title="Boolean" id="527277">saved</a> = <a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456424" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">uniqid</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a>
                          <span class="keyword">try</span> <span class="delimiter">{</span>
                            <a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456424" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">uniqid</a>.<a href="settings/MutableSettings.scala.html#456450" title="(arg: Boolean)Unit">value</a> = <span title="Boolean(true)" class="keyword">true</span>
                            <a href="../../Predef.scala.html#8489" title="(x: Any)Unit">println</a><span class="delimiter">(</span><span title="String(&quot;*** stale type parameter: &quot;)" class="string">&quot;*** stale type parameter: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#515189" title="Types.this.Type">tp</a> <span title="(x$1: Any)String">+</span> sym.<a href="Symbols.scala.html#443561" title="=&gt; String">locationString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; cannot be instantiated from &quot;)" class="string">&quot; cannot be instantiated from &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#527249" title="Types.this.Type">pre</a>.<a href="#441990" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
                            <a href="../../Predef.scala.html#8489" title="(x: Any)Unit">println</a><span class="delimiter">(</span><span title="String(&quot;*** confused with params: &quot;)" class="string">&quot;*** confused with params: &quot;</span> <span title="(x$1: Any)String">+</span> sym <span title="(x$1: Any)String">+</span> <span title="String(&quot; in &quot;)" class="string">&quot; in &quot;</span> <span title="(x$1: Any)String">+</span> sym.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; not in &quot;)" class="string">&quot; not in &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#527275" title="List[Types.this.Symbol]">ps</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; of &quot;)" class="string">&quot; of &quot;</span> <span title="(x$1: Any)String">+</span> basesym<span class="delimiter">)</span>
                            <a href="../../Predef.scala.html#8489" title="(x: Any)Unit">println</a><span class="delimiter">(</span><span title="String(&quot;*** stacktrace = &quot;)" class="string">&quot;*** stacktrace = &quot;</span><span class="delimiter">)</span>
                            <span title="Error" class="keyword">new</span> <a href="../../package.scala.html#56959" title="Error">Error</a><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="()Unit">printStackTrace</span><span class="delimiter">(</span><span class="delimiter">)</span>
                          <span class="delimiter">}</span> <span class="keyword">finally</span> <a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456424" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">uniqid</a>.<a href="settings/MutableSettings.scala.html#456450" title="(arg: Boolean)Unit">value</a> = <a href="#527277" title="Boolean">saved</a>
                          <a href="#527274" title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type">instParamRelaxed</a><span class="delimiter">(</span>basesym.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a>, baseargs<span class="delimiter">)</span>
                        <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#527259" title="=&gt; Nothing">throwError</a>
                      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span>sym <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#527275" title="List[Types.this.Symbol]">ps</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a><span class="delimiter">)</span>
                        // @M! don't just replace the whole thing, might be followed by type application
                        <a href="#441377" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#527276" title="List[Types.this.Type]">as</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a>, args <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</a> <span class="delimiter">(</span><a href="#441443" title="Types.this.AsSeenFromMap" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> // @M: was as.head
                      <span class="keyword">else</span> <a href="#527273" title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type">instParam</a><span class="delimiter">(</span><a href="#527275" title="List[Types.this.Symbol]">ps</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Symbol]">tail</a>, <a href="#527276" title="List[Types.this.Type]">as</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Type]">tail</a><span class="delimiter">)</span>

                    /** Relaxed version of instParams which matches on names not symbols.
                     *  This is a last fallback in interactive mode because races in calls
                     *  from the IDE to the compiler may in rare cases lead to symbols referring
                     *  to type parameters that are no longer current.
                     */
                    <span class="keyword">def</span> <a title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type" id="527274">instParamRelaxed</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="527308">ps</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="527309">as</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
                      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#527308" title="List[Types.this.Symbol]">ps</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#527259" title="=&gt; Nothing">throwError</a>
                      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span>sym.<a href="Symbols.scala.html#443152" title="=&gt; Types.this.Symbol#NameType">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#527308" title="List[Types.this.Symbol]">ps</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a>.<a href="Symbols.scala.html#443152" title="=&gt; Types.this.Symbol#NameType">name</a><span class="delimiter">)</span>
                        // @M! don't just replace the whole thing, might be followed by type application
                        <a href="#441377" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#527309" title="List[Types.this.Type]">as</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a>, args <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</a> <span class="delimiter">(</span><a href="#441443" title="Types.this.AsSeenFromMap" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> // @M: was as.head
                      <span class="keyword">else</span> <a href="#527274" title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type">instParamRelaxed</a><span class="delimiter">(</span><a href="#527308" title="List[Types.this.Symbol]">ps</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Symbol]">tail</a>, <a href="#527309" title="List[Types.this.Type]">as</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Type]">tail</a><span class="delimiter">)</span>

                    //Console.println(&quot;instantiating &quot; + sym + &quot; from &quot; + basesym + &quot; with &quot; + basesym.typeParams + &quot; and &quot; + baseargs+&quot;, pre = &quot;+pre+&quot;, symclazz = &quot;+symclazz);//DEBUG
                    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span>basesym.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a>, baseargs<span class="delimiter">)</span><span class="delimiter">)</span>
                      <a href="#527273" title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type">instParam</a><span class="delimiter">(</span>basesym.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a>, baseargs<span class="delimiter">)</span>
                    <span class="keyword">else</span>
                      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#527260" title="Types.this.Symbol">symclazz</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a>.<a href="#441995" title="=&gt; List[Types.this.Type]">parents</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#527350" title="Types.this.Type">_</a>.<a href="#441981" title="=&gt; Boolean">isErroneous</a><span class="delimiter">)</span><span class="delimiter">)</span>
                        <a href="#516388" title="Types.this.ErrorType.type">ErrorType</a> // don't be to overzealous with throwing exceptions, see #2641
                      <span class="keyword">else</span>
                        <span title="Nothing" class="keyword">throw</span> <span title="(x$1: String)Error" class="keyword">new</span> <a href="../../package.scala.html#56959" title="Error">Error</a><span class="delimiter">(</span>
                          <span title="String(&quot;something is wrong (wrong class file?): &quot;)" class="string">&quot;something is wrong (wrong class file?): &quot;</span><span title="(x$1: Any)String">+</span>basesym<span title="(x$1: Any)String">+</span>
                          <span title="String(&quot; with type parameters &quot;)" class="string">&quot; with type parameters &quot;</span><span title="(x$1: Any)String">+</span>
                          basesym.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.Symbol#NameType)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol#NameType,List[Types.this.Symbol#NameType]])List[Types.this.Symbol#NameType]">map</a><a href="../../collection/immutable/List.scala.html#63282" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.Symbol#NameType,List[Types.this.Symbol#NameType]]" class="delimiter">(</a><a href="#527374" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443152" title="=&gt; x$82.NameType">name</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>,<span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>,<span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span><span title="(x$1: Any)String">+</span>
                          <span title="String(&quot; gets applied to arguments &quot;)" class="string">&quot; gets applied to arguments &quot;</span><span title="(x$1: Any)String">+</span>baseargs.<a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>,<span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>,<span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span><span title="(x$1: Any)String">+</span><span title="String(&quot;, phase = &quot;)" class="string">&quot;, phase = &quot;</span><span title="(x$1: Any)String">+</span><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a><span class="delimiter">)</span>
                  <span class="keyword">case</span> ExistentialType<a href="#527466" title="Types.this.Type" id="527471" class="delimiter">(</a>tparams, qtpe<span class="delimiter">)</span> =&gt;
                    <a href="#515175" title="(x$1: List[Types.this.Symbol])Unit">capturedSkolems</a> = <a href="#515175" title="=&gt; List[Types.this.Symbol]">capturedSkolems</a> <a href="../../collection/SeqLike.scala.html#59769" title="(that: scala.collection.GenSeq[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">union</a> tparams
                    <a href="#527248" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toInstance</a><span class="delimiter">(</span>qtpe, <a href="#527250" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
                  <span class="keyword">case</span> t =&gt;
                    <a href="#527472" title="(x: Types.this.Type)Types.this.Type">throwError</a>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#527248" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toInstance</a><span class="delimiter">(</span><a href="#515185" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">base</a><span class="delimiter">(</span><a href="#527249" title="Types.this.Type">pre</a>, <a href="#527250" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>.<a href="#441997" title="=&gt; Types.this.Type">prefix</a>, <a href="#527250" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <a href="#527248" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toInstance</a><span class="delimiter">(</span><a href="#515187" title="Types.this.Type">pre</a>, <a href="#515188" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt;
          <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#527494" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#515189" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A base class to compute all substitutions */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SubstMap[T] extends Types.this.TypeMap" id="441444">SubstMap</a><span class="delimiter">[</span><a title="" id="441445">T</a><span class="delimiter">]</span><a href="#441444" title="Types.this.SubstMap[T]" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="513536">from</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[T]" id="513537">to</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[T]">List</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#8460" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#513536" title="List[Types.this.Symbol]">from</a>, <a href="#513537" title="List[T]">to</a><span class="delimiter">)</span>, <span title="String(&quot;Unsound substitution from &quot;)" class="string">&quot;Unsound substitution from &quot;</span><span title="(x$1: Any)String">+</span> <a href="#513536" title="List[Types.this.Symbol]">from</a> <span title="(x$1: Any)String">+</span><span title="String(&quot; to &quot;)" class="string">&quot; to &quot;</span><span title="(x$1: Any)String">+</span> <a href="#513537" title="List[T]">to</a><span class="delimiter">)</span>

    /** Are `sym` and `sym1` the same? Can be tuned by subclasses. */
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, sym1: Types.this.Symbol)Boolean" id="513529">matches</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="527508">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="527509">sym1</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#527508" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#527509" title="Types.this.Symbol">sym1</a>

    /** Map target to type, can be tuned by subclasses */
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(fromtp: Types.this.Type, tp: T)Types.this.Type" id="513530">toType</a><span class="delimiter">(</span><a title="Types.this.Type" id="527510">fromtp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="T" id="527511">tp</a>: <a href="#441445" title="T">T</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a>

    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="513531">renameBoundSyms</a><span class="delimiter">(</span><a title="Types.this.Type" id="527512">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#527512" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> MethodType<a href="#527550" title="Types.this.Type" id="527552" class="delimiter">(</a>ps, restp<span class="delimiter">)</span> =&gt;
        <a href="Symbols.scala.html#441161" title="(syms: List[Types.this.Symbol], tpe: Types.this.Type)(creator: (List[Types.this.Symbol], Types.this.Type) =&gt; Types.this.Type)Types.this.Type">createFromClonedSymbols</a><span class="delimiter">(</span>ps, restp<span class="delimiter">)</span><a href="#527557" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="527523">ps1</a>, <a title="Types.this.Type" id="527524">tp1</a><span class="delimiter">)</span> =&gt; <a href="#441374" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#527512" title="Types.this.Type">tp</a>, <a href="#527523" title="List[Types.this.Symbol]">ps1</a>, <a href="#513531" title="(tp: Types.this.Type)Types.this.Type">renameBoundSyms</a><span class="delimiter">(</span><a href="#527524" title="Types.this.Type">tp1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> PolyType<a href="#527550" title="Types.this.Type" id="527554" class="delimiter">(</a>bs, restp<span class="delimiter">)</span> =&gt;
        <a href="Symbols.scala.html#441161" title="(syms: List[Types.this.Symbol], tpe: Types.this.Type)(creator: (List[Types.this.Symbol], Types.this.Type) =&gt; Types.this.PolyType)Types.this.PolyType">createFromClonedSymbols</a><span class="delimiter">(</span>bs, restp<span class="delimiter">)</span><a href="#527557" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="527534">ps1</a>, <a title="Types.this.Type" id="527535">tp1</a><span class="delimiter">)</span> =&gt; <a href="#448476" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#527534" title="List[Types.this.Symbol]">ps1</a>, <a href="#513531" title="(tp: Types.this.Type)Types.this.Type">renameBoundSyms</a><span class="delimiter">(</span><a href="#527535" title="Types.this.Type">tp1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> ExistentialType<a href="#527550" title="Types.this.Type" id="527556" class="delimiter">(</a>bs, restp<span class="delimiter">)</span> =&gt;
        <a href="Symbols.scala.html#441161" title="(syms: List[Types.this.Symbol], tpe: Types.this.Type)(creator: (List[Types.this.Symbol], Types.this.Type) =&gt; Types.this.Type)Types.this.Type">createFromClonedSymbols</a><span class="delimiter">(</span>bs, restp<span class="delimiter">)</span><a href="#527557" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#441323" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#527557" title="(x: Types.this.Type)Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp0: Types.this.Type)Types.this.Type" id="513532">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="513627">tp0</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#513536" title="List[Types.this.Symbol]">from</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#513627" title="Types.this.Type">tp0</a> <span class="keyword">else</span> <span class="delimiter">{</span>
      @tailrec <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type" id="527564">subst</a><span class="delimiter">(</span><a title="Types.this.Type" id="527568">tp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="527569">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="527570">from</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[T]" id="527571">to</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[T]">List</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#527570" title="List[Types.this.Symbol]">from</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#527568" title="Types.this.Type">tp</a>
        // else if (to.isEmpty) error(&quot;Unexpected substitution on '%s': from = %s but to == Nil&quot;.format(tp, from))
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#513529" title="(sym: Types.this.Symbol, sym1: Types.this.Symbol)Boolean">matches</a><span class="delimiter">(</span><a href="#527570" title="List[Types.this.Symbol]">from</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a>, <a href="#527569" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#513530" title="(fromtp: Types.this.Type, tp: T)Types.this.Type">toType</a><span class="delimiter">(</span><a href="#527568" title="Types.this.Type">tp</a>, <a href="#527571" title="List[T]">to</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; T">head</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#527564" title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#527568" title="Types.this.Type">tp</a>, <a href="#527569" title="Types.this.Symbol">sym</a>, <a href="#527570" title="List[Types.this.Symbol]">from</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Symbol]">tail</a>, <a href="#527571" title="List[T]">to</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[T]">tail</a><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="527565">boundSyms</a> = <a href="#513627" title="Types.this.Type">tp0</a>.<a href="#442012" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="527566">tp1</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#527565" title="scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a> <a href="../../collection/IterableLike.scala.html#59462" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a> <a href="#513536" title="List[Types.this.Symbol]">from</a>.<a href="../../collection/SeqLike.scala.html#59768" title="(elem: Any)Boolean">contains</a><span class="delimiter">)</span> <a href="#513531" title="(tp: Types.this.Type)Types.this.Type">renameBoundSyms</a><span class="delimiter">(</span><a href="#513627" title="Types.this.Type">tp0</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#513627" title="Types.this.Type">tp0</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="527567">tp</a> = <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#527566" title="Types.this.Type">tp1</a><span class="delimiter">)</span>

      <a href="#527567" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        // @M
        // 1) arguments must also be substituted (even when the &quot;head&quot; of the
        // applied type has already been substituted)
        // example: (subst RBound[RT] from [type RT,type RBound] to
        // [type RT&amp;,type RBound&amp;]) = RBound&amp;[RT&amp;]
        // 2) avoid loops (which occur because alpha-conversion is
        // not performed properly imo)
        // e.g. if in class Iterable[a] there is a new Iterable[(a,b)],
        // we must replace the a in Iterable[a] by (a,b)
        // (must not recurse --&gt; loops)
        // 3) replacing m by List in m[Int] should yield List[Int], not just List
        <span class="keyword">case</span> TypeRef<a href="#527594" title="Types.this.Type" id="527597" class="delimiter">(</a><a href="#516520" title="Types.this.Type" id="527603">NoPrefix</a>, sym, args<span class="delimiter">)</span> =&gt;
          <a href="#441377" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><a href="#527605" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#527564" title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#527567" title="Types.this.Type">tp</a>, sym, <a href="#513536" title="List[Types.this.Symbol]">from</a>, <a href="#513537" title="List[T]">to</a><span class="delimiter">)</span>, args<span class="delimiter">)</span> // if args.isEmpty, appliedType is the identity
        <span class="keyword">case</span> SingleType<a href="#527594" title="Types.this.Type" id="527601" class="delimiter">(</a><a href="#516520" title="Types.this.Type" id="527604">NoPrefix</a>, sym<span class="delimiter">)</span> =&gt;
          <a href="#527564" title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type">subst</a><a href="#527605" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#527567" title="Types.this.Type">tp</a>, sym, <a href="#513536" title="List[Types.this.Symbol]">from</a>, <a href="#513537" title="List[T]">to</a><span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt;
          <a href="#527605" title="(x: Types.this.Type)Types.this.Type">tp</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `substSym` method. */
  <span class="keyword">class</span> <a title="class SubstSymMap extends Types.this.SubstMap[Types.this.Symbol]" id="441446">SubstSymMap</a><a href="#441446" title="Types.this.SubstSymMap" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="513603">from</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="513604">to</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441444" title="Types.this.SubstMap[Types.this.Symbol]">SubstMap</a><span class="delimiter">(</span><a href="#513603" title="List[Types.this.Symbol]">from</a>, <a href="#513604" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(fromtp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="513600">toType</a><span class="delimiter">(</span><a title="Types.this.Type" id="527632">fromtp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="527633">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#527632" title="Types.this.Type">fromtp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> TypeRef<a href="#527640" title="Types.this.Type" id="527643" class="delimiter">(</a>pre, _, args<span class="delimiter">)</span> =&gt; <a href="#441372" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><a href="#527647" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#527632" title="Types.this.Type">fromtp</a>, pre, <a href="#527633" title="Types.this.Symbol">sym</a>, args<span class="delimiter">)</span>
      <span class="keyword">case</span> SingleType<a href="#527640" title="Types.this.Type" id="527646" class="delimiter">(</a>pre, _<span class="delimiter">)</span> =&gt; <a href="#441367" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><a href="#527647" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>pre, <a href="#527633" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="513601">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="513625">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#513603" title="List[Types.this.Symbol]">from</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#513625" title="Types.this.Type">tp</a> <span class="keyword">else</span> <span class="delimiter">{</span>
      @tailrec <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol" id="527652">subst</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="527653">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="527654">from</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="527655">to</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> =
        <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#527654" title="List[Types.this.Symbol]">from</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#527653" title="Types.this.Symbol">sym</a>
        // else if (to.isEmpty) error(&quot;Unexpected substitution on '%s': from = %s but to == Nil&quot;.format(sym, from))
        <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#513529" title="(sym: Types.this.Symbol, sym1: Types.this.Symbol)Boolean">matches</a><span class="delimiter">(</span><a href="#527654" title="List[Types.this.Symbol]">from</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a>, <a href="#527653" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#527655" title="List[Types.this.Symbol]">to</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a>
        <span class="keyword">else</span> <a href="#527652" title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol">subst</a><span class="delimiter">(</span><a href="#527653" title="Types.this.Symbol">sym</a>, <a href="#527654" title="List[Types.this.Symbol]">from</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Symbol]">tail</a>, <a href="#527655" title="List[Types.this.Symbol]">to</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Symbol]">tail</a><span class="delimiter">)</span>
      <a href="#513625" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> TypeRef<a href="#527683" title="Types.this.Type" id="527685" class="delimiter">(</a>pre, sym, args<span class="delimiter">)</span> <span class="keyword">if</span> pre <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#516520" title="Types.this.NoPrefix.type">NoPrefix</a> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="527659">newSym</a> = <a href="#527652" title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol">subst</a><span class="delimiter">(</span>sym, <a href="#513603" title="List[Types.this.Symbol]">from</a>, <a href="#513604" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span>
          // assert(newSym.typeParams.length == sym.typeParams.length, &quot;typars mismatch in SubstSymMap: &quot;+(sym, sym.typeParams, newSym, newSym.typeParams))
          <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#441372" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#513625" title="Types.this.Type">tp</a>, pre, <a href="#527659" title="Types.this.Symbol">newSym</a>, args<span class="delimiter">)</span><span class="delimiter">)</span> // mapOver takes care of subst'ing in args
        <span class="keyword">case</span> SingleType<a href="#527683" title="Types.this.Type" id="527687" class="delimiter">(</a>pre, sym<span class="delimiter">)</span> <span class="keyword">if</span> pre <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#516520" title="Types.this.NoPrefix.type">NoPrefix</a> =&gt;
          <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#527688" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#441367" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span>pre, <a href="#527652" title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol">subst</a><span class="delimiter">(</span>sym, <a href="#513603" title="List[Types.this.Symbol]">from</a>, <a href="#513604" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt;
          <a href="#441446" title="Types.this.SubstSymMap" class="keyword">super</a>.<a href="#513532" title="(tp0: Types.this.Type)Types.this.Type">apply</a><a href="#527688" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#513625" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="513602">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="527660">tree</a>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a>, <a title="() =&gt; Nothing" id="527661">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="trans.type" id="527694">trans</a> <a href="#527695" title="trans.type" class="keyword">extends</a> <a href="#460851" title="SubstSymMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>

        <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Option[Types.this.Symbol]" id="527697">termMapsTo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="527700">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#513603" title="List[Types.this.Symbol]">from</a> <a href="../../collection/GenSeqLike.scala.html#59605" title="(elem: Types.this.Symbol)Int">indexOf</a> <a href="#527700" title="Types.this.Symbol">sym</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="../../Int.scala.html#57891" title="Option[Types.this.Symbol]" id="527742">-</a><span class="int">1</span>   =&gt; <a href="#527743" title="(x: Option[Types.this.Symbol])Option[Types.this.Symbol]">None</a>
          <span class="keyword">case</span> idx  =&gt; <a href="../../Option.scala.html#64111" title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</a><a href="#527743" title="(x: Option[Types.this.Symbol])Option[Types.this.Symbol]" class="delimiter">(</a><a href="../../collection/LinearSeqOptimized.scala.html#76165" title="(n: Int)Types.this.Symbol">to</a><span class="delimiter">(</span>idx<span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="527698">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="527751">tree</a>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a><span class="delimiter">)</span> =
          <a href="#527751" title="Types.this.Tree">tree</a> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> tree@Ident<a href="#527798" title="Types.this.Tree" id="527801" class="delimiter">(</a>_<span class="delimiter">)</span> =&gt;
              <a href="#527697" title="(sym: Types.this.Symbol)Option[Types.this.Symbol]">termMapsTo</a><a href="#527802" title="(x: Types.this.Tree)Types.this.Tree" class="delimiter">(</a>tree.<a href="../api/Trees.scala.html#427232" title="=&gt; Types.this.Symbol">symbol</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> Some<a href="#527789" title="Types.this.Tree" id="527790" class="delimiter">(</a>tosym<span class="delimiter">)</span> =&gt;
                  <a href="#527791" title="(x: Types.this.Tree)Types.this.Tree" class="keyword">if</a> <span class="delimiter">(</span>tosym.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#443469" title="(that: Types.this.Symbol)Boolean">isSubClass</a> <a href="Definitions.scala.html#442283" title="=&gt; Types.this.ClassSymbol">SingletonClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="Trees.scala.html#441841" title="(name: String)Types.this.Ident">Ident</a><span class="delimiter">(</span>tosym.<a href="Symbols.scala.html#443572" title="=&gt; String">existentialToString</a><span class="delimiter">)</span>
                      .<a href="../api/Trees.scala.html#425066" title="(sym: Types.this.Symbol)Types.this.Ident">setSymbol</a><span class="delimiter">(</span>tosym<span class="delimiter">)</span>
                      .<a href="../api/Trees.scala.html#425044" title="(newpos: scala.tools.nsc.util.Position)Types.this.Ident">setPos</a><span class="delimiter">(</span>tosym.<a href="Symbols.scala.html#443167" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>
                      .<a href="../api/Trees.scala.html#425062" title="(tp: Types.this.Type)Types.this.Ident">setType</a><span class="delimiter">(</span><a href="#498055" title="(tp: Types.this.Type)Types.this.Type">dropSingletonType</a><span class="delimiter">(</span>tosym.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                    <a href="../../Function0.scala.html#68359" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span>
                  <span class="delimiter">}</span>
                <span class="keyword">case</span> none =&gt; <span class="keyword">super</span>.<a href="#526566" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><a href="#527791" title="(x: Types.this.Tree)Types.this.Tree" class="delimiter">(</a>tree<span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="keyword">case</span> tree =&gt; <span class="keyword">super</span>.<a href="#526566" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><a href="#527802" title="(x: Types.this.Tree)Types.this.Tree" class="delimiter">(</a>tree<span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#527694" title="trans.type">trans</a>.<a href="#527698" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#527660" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `subst` method. */
  <span class="keyword">class</span> <a title="class SubstTypeMap extends Types.this.SubstMap[Types.this.Type]" id="441447">SubstTypeMap</a><a href="#441447" title="Types.this.SubstTypeMap" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="513552">from</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="513553">to</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="#441444" title="Types.this.SubstMap[Types.this.Type]">SubstMap</a><span class="delimiter">(</span><a href="#513552" title="List[Types.this.Symbol]">from</a>, <a href="#513553" title="List[Types.this.Type]">to</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(fromtp: Types.this.Type, tp: Types.this.Type)Types.this.Type" id="513550">toType</a><span class="delimiter">(</span><a title="Types.this.Type" id="527823">fromtp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="527824">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#527824" title="Types.this.Type">tp</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="513551">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="520994">tree</a>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a>, <a title="() =&gt; Nothing" id="520995">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Nothing<span class="delimiter">)</span>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="trans.type" id="527827">trans</a> <a href="#527828" title="trans.type" class="keyword">extends</a> <a href="#460851" title="SubstTypeMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="527830">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="527832">tree</a>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a><span class="delimiter">)</span> = <a href="#527832" title="Types.this.Tree">tree</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> Ident<a href="#527880" title="Types.this.Tree" id="527882" class="delimiter">(</a>name<span class="delimiter">)</span> =&gt;
            <a href="#513552" title="List[Types.this.Symbol]">from</a> <a href="#527883" title="(x: Types.this.Tree)Types.this.Tree">indexOf</a> <a href="#527832" title="Types.this.Tree">tree</a>.<a href="../api/Trees.scala.html#425064" title="=&gt; Types.this.Symbol">symbol</a> <span class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <a href="../../Int.scala.html#57891" title="Types.this.Tree" id="527870">-</a><span class="int">1</span>   =&gt; <span class="keyword">super</span>.<a href="#526566" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><a href="#527871" title="(x: Types.this.Tree)Types.this.Tree" class="delimiter">(</a><a href="#527832" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
              <span class="keyword">case</span> idx  =&gt;
                <span class="keyword">val</span> <a title="Types.this.Type" id="527857">totpe</a> = <a href="../../collection/LinearSeqOptimized.scala.html#76165" title="(n: Int)Types.this.Type">to</a><span class="delimiter">(</span>idx<span class="delimiter">)</span>
                <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#527857" title="Types.this.Type">totpe</a>.<a href="#441973" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#527832" title="Types.this.Tree">tree</a>.<a href="../api/Trees.scala.html#425086" title="=&gt; tree.type">duplicate</a> <a href="../api/Trees.scala.html#425062" title="(tp: Types.this.Type)tree.type">setType</a> <a href="#527857" title="Types.this.Type">totpe</a>
                <span class="keyword">else</span> <a href="../../Function0.scala.html#68359" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> _ =&gt;
            <span class="keyword">super</span>.<a href="#526566" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><a href="#527883" title="(x: Types.this.Tree)Types.this.Tree" class="delimiter">(</a><a href="#527832" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#527827" title="trans.type">trans</a>.<a href="#527830" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#520994" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `substThis` method. */
  <span class="keyword">class</span> <a title="class SubstThisMap extends Types.this.TypeMap" id="441448">SubstThisMap</a><a href="#441448" title="Types.this.SubstThisMap" class="delimiter">(</a><a title="Types.this.Symbol" id="515272">from</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="515273">to</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="515271">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="515275">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#515275" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> ThisType<a href="#527906" title="Types.this.Type" id="527908" class="delimiter">(</a>sym<span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span>sym <span title="(x$1: AnyRef)Boolean">==</span> <a href="#515272" title="Types.this.Symbol">from</a><span class="delimiter">)</span> =&gt; <a href="#527909" title="(x: Types.this.Type)Types.this.Type">to</a>
      <span class="keyword">case</span> _ =&gt; <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#527909" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#515275" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">class</span> <a title="class SubstThisAndSymMap extends Types.this.SubstSymMap" id="441449">SubstThisAndSymMap</a><a href="#441449" title="Types.this.SubstThisAndSymMap" class="delimiter">(</a><a title="Types.this.Symbol" id="515301">fromThis</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="515302">toThis</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="515303">fromSyms</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="515304">toSyms</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="#441446" title="Types.this.SubstSymMap">SubstSymMap</a><span class="delimiter">(</span><a href="#515303" title="List[Types.this.Symbol]">fromSyms</a>, <a href="#515304" title="List[Types.this.Symbol]">toSyms</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="515300">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="515306">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#515306" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> ThisType<a href="#527926" title="Types.this.Type" id="527928" class="delimiter">(</a>sym<span class="delimiter">)</span> <span class="keyword">if</span> sym <span title="(x$1: AnyRef)Boolean">==</span> <a href="#515301" title="Types.this.Symbol">fromThis</a> =&gt; <a href="#515300" title="(tp: Types.this.Type)Types.this.Type">apply</a><a href="#527929" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#515302" title="Types.this.Type">toThis</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _                                =&gt; <a href="#441449" title="Types.this.SubstThisAndSymMap" class="keyword">super</a>.<a href="#513601" title="(tp: Types.this.Type)Types.this.Type">apply</a><a href="#527929" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#515306" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class SubstWildcardMap extends Types.this.TypeMap" id="441450">SubstWildcardMap</a><a href="#441450" title="Types.this.SubstWildcardMap" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="527940">from</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="527937">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="527941">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
      <a href="#527941" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> TypeRef<a href="#527954" title="Types.this.Type" id="527958" class="delimiter">(</a>_, sym, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#527940" title="List[Types.this.Symbol]">from</a> <a href="../../collection/SeqLike.scala.html#59768" title="(elem: Any)Boolean">contains</a> sym =&gt;
          <a href="#469712" title="(bounds: Types.this.TypeBounds)Types.this.BoundedWildcardType">BoundedWildcardType</a><a href="#527959" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>sym.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt;
          <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#527959" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#527941" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Types.this.WildcardType.type" id="527964">ex</a>: <a href="#441583" title="Types.this.MalformedType">MalformedType</a> =&gt;
        <a href="#516414" title="Types.this.WildcardType.type">WildcardType</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

// dependent method types
  <span class="keyword">object</span> <a title="Types.this.IsDependentCollector.type" id="441451">IsDependentCollector</a> <a href="#441452" title="Types.this.IsDependentCollector.type" class="keyword">extends</a> <a href="#441433" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="514871">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="527975">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#527975" title="Types.this.Type">tp</a> <a href="#441977" title="=&gt; Boolean">isImmediatelyDependent</a><span class="delimiter">)</span> <a href="#514863" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#514863" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#527975" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Types.this.ApproximateDependentMap.type" id="441453">ApproximateDependentMap</a> <a href="#441454" title="Types.this.ApproximateDependentMap.type" class="keyword">extends</a> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="515037">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="515038">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span><span class="delimiter">(</span><a href="#515038" title="Types.this.Type">tp</a> <a href="#441977" title="=&gt; Boolean">isImmediatelyDependent</a><span class="delimiter">)</span> <a href="#516414" title="Types.this.WildcardType.type">WildcardType</a>
      <span class="keyword">else</span> <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#515038" title="Types.this.Type">tp</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class InstantiateDependentMap extends Types.this.TypeMap with Types.this.KeepOnlyTypeConstraints" id="441455">InstantiateDependentMap</a><a href="#441455" title="Types.this.InstantiateDependentMap" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="461720">params</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="461721">actuals0</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="keyword">with</span> <a href="#441427" title="Types.this.KeepOnlyTypeConstraints">KeepOnlyTypeConstraints</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.IndexedSeq[Types.this.Type]" id="461703">actuals</a>      = <a href="#461721" title="List[Types.this.Type]">actuals0</a>.<a href="../../collection/TraversableOnce.scala.html#59177" title="=&gt; scala.collection.immutable.IndexedSeq[Types.this.Type]">toIndexedSeq</a>
    <span class="keyword">private</span> <span class="keyword">val</span> <a title="Array[Types.this.Symbol]" id="461705">existentials</a> = <span title="Array[Types.this.Symbol]" class="keyword">new</span> <a href="../../Array.scala.html#292" title="Array[Types.this.Symbol]">Array</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">(</span><a href="#461703" title="=&gt; scala.collection.immutable.IndexedSeq[Types.this.Type]">actuals</a>.<a href="../../collection/SeqLike.scala.html#59711" title="=&gt; Int">size</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="461707">existentialsNeeded</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="../../Predef.scala.html#8521" title="(xs: Array[Types.this.Symbol])scala.collection.mutable.ArrayOps[Types.this.Symbol]">existentials</a>.<a href="../../collection/TraversableLike.scala.html#58981" title="(p: Types.this.Symbol =&gt; Boolean)Array[Types.this.Symbol]">filter</a><a href="../../Predef.scala.html#8521" title="(xs: Array[Types.this.Symbol])scala.collection.mutable.ArrayOps[Types.this.Symbol]" class="delimiter">(</a><a href="#528183" title="Types.this.Symbol">_</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#59174" title="=&gt; List[Types.this.Symbol]">toList</a>

    <span class="keyword">private</span> <span class="keyword">object</span> <a title="InstantiateDependentMap.this.StableArg.type" id="461708">StableArg</a> <a href="#461709" title="InstantiateDependentMap.this.StableArg.type" class="delimiter">{</a>
      <span class="keyword">def</span> <a title="(param: Types.this.Symbol)Option[Types.this.Type]" id="528280">unapply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="528282">param</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#461710" title="InstantiateDependentMap.this.Arg.type">Arg</a> <a href="#528284" title="(param: Types.this.Symbol)Option[Int]">unapply</a> <a href="#528282" title="Types.this.Symbol">param</a> <a href="../../Option.scala.html#63820" title="(f: Int =&gt; Types.this.Type)Option[Types.this.Type]">map</a> <a href="#461703" title="=&gt; scala.collection.immutable.IndexedSeq[Types.this.Type]">actuals</a> <a href="../../Option.scala.html#63832" title="(p: Types.this.Type =&gt; Boolean)Option[Types.this.Type]">filter</a> <span class="delimiter">(</span><a title="Types.this.Type" id="528321">tp</a> =&gt;
        <a href="#528321" title="Types.this.Type">tp</a>.<a href="#441973" title="=&gt; Boolean">isStable</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#528321" title="Types.this.Type">tp</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a><span class="delimiter">)</span>
      <span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">private</span> <span class="keyword">object</span> <a title="InstantiateDependentMap.this.Arg.type" id="461710">Arg</a> <a href="#461711" title="InstantiateDependentMap.this.Arg.type" class="delimiter">{</a>
      <span class="keyword">def</span> <a title="(param: Types.this.Symbol)Option[Int]" id="528284">unapply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="528285">param</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="../../Option.scala.html#64111" title="(x: Int)Some[Int]">Some</a><span class="delimiter">(</span><a href="#461720" title="List[Types.this.Symbol]">params</a> <a href="../../collection/GenSeqLike.scala.html#59605" title="(elem: Types.this.Symbol)Int">indexOf</a> <a href="#528285" title="Types.this.Symbol">param</a><span class="delimiter">)</span> <a href="../../Option.scala.html#63832" title="(p: Int =&gt; Boolean)Option[Int]">filter</a> <span class="delimiter">(</span><a href="#528306" title="Int">_</a> <a href="../../Int.scala.html#57926" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="461712">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="461723">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#461463" title="=&gt; Types.this.Type" class="delimiter">(</a><a href="#461723" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
      // unsound to replace args by unstable actual #3873
      <span class="keyword">case</span> SingleType<a href="#528361" title="Types.this.Type" id="528365" class="delimiter">(</a><a href="#516520" title="Types.this.Type" id="528377">NoPrefix</a>, <a href="#528280" title="Option[Types.this.Type]" id="528383">StableArg</a><span class="delimiter">(</span>arg<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#528379" title="(x: Types.this.Type)Types.this.Type">arg</a>
      // (soundly) expand type alias selections on implicit arguments,
      // see depmet_implicit_oopsla* test cases -- typically, `param.isImplicit`
      <span class="keyword">case</span> tp1 @ TypeRef<a href="#528361" title="Types.this.Type" id="528370" class="delimiter">(</a>SingleType<a title="Types.this.Type" id="528374" class="delimiter">(</a><a href="#516520" title="Types.this.Type" id="528378">NoPrefix</a>, <a href="#528284" title="Option[Int]" id="528385">Arg</a><span class="delimiter">(</span>pid<span class="delimiter">)</span><span class="delimiter">)</span>, sym, targs<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="528345">arg</a> = <a href="../../collection/SeqLike.scala.html#59708" title="(idx: Int)Types.this.Type">actuals</a><span class="delimiter">(</span>pid<span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="528346">res</a> = <a href="#441371" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#528345" title="Types.this.Type">arg</a>, sym, targs<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#528346" title="Types.this.Type">res</a>.<a href="#441988" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>.<a href="Symbols.scala.html#443232" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span> <a href="#528346" title="Types.this.Type">res</a>.<a href="#442018" title="=&gt; Types.this.Type">dealias</a> <span class="keyword">else</span> tp1
      // don't return the original `tp`, which may be different from `tp1`,
      // due to dropping annotations
      <span class="keyword">case</span> tp1 =&gt; <a href="#528379" title="(x: Types.this.Type)Types.this.Type">tp1</a>
    <span class="delimiter">}</span>

    /* Return the type symbol for referencing a parameter inside the existential quantifier.
     * (Only needed if the actual is unstable.)
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(pid: Int)Types.this.Symbol" id="461713">existentialFor</a><span class="delimiter">(</span><a title="Int" id="528393">pid</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Array.scala.html#57450" title="(i: Int)Types.this.Symbol">existentials</a><span class="delimiter">(</span><a href="#528393" title="Int">pid</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="528396">param</a> = <a href="../../collection/LinearSeqOptimized.scala.html#76165" title="(n: Int)Types.this.Symbol">params</a><span class="delimiter">(</span><a href="#528393" title="Int">pid</a><span class="delimiter">)</span>
        <a href="../../Array.scala.html#57451" title="(i: Int, x: Types.this.Symbol)Unit">existentials</a><span class="delimiter">(</span><a href="#528393" title="Int">pid</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
          <a href="#528396" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#443195" title="(name: Types.this.TypeName, pos: Types.this.Position, newFlags: Long)Types.this.TypeSymbol">newExistential</a><span class="delimiter">(</span><a href="Names.scala.html#440784" title="(s: String)Types.this.TypeName">newTypeName</a><span class="delimiter">(</span><a href="#528396" title="Types.this.Symbol">param</a>.<a href="../../Predef.scala.html#8576" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">name</a> <a href="../../runtime/StringAdd.scala.html#60949" title="(other: String)String">+</a> <span title="String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span><span class="delimiter">)</span>, <a href="#528396" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#443167" title="=&gt; Types.this.Position">pos</a>, <a href="#528396" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#443310" title="=&gt; Long">flags</a><span class="delimiter">)</span>
            <a href="Symbols.scala.html#443429" title="(info: Types.this.Type)Types.this.TypeSymbol">setInfo</a> <a href="#441442" title="(hi: Types.this.Type)Types.this.TypeBounds">singletonBounds</a><span class="delimiter">(</span><a href="../../collection/SeqLike.scala.html#59708" title="(idx: Int)Types.this.Type">actuals</a><span class="delimiter">(</span><a href="#528393" title="Int">pid</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="../../Array.scala.html#57450" title="(i: Int)Types.this.Symbol">existentials</a><span class="delimiter">(</span><a href="#528393" title="Int">pid</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    //AM propagate more info to annotations -- this seems a bit ad-hoc... (based on code by spoon)
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(arg: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="461714">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="528328">arg</a>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a>, <a title="() =&gt; Nothing" id="528329">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a> = <span class="delimiter">{</span>
      // TODO: this should be simplified; in the stable case, one can
      // probably just use an Ident to the tree.symbol.
      //
      // @PP: That leads to failure here, where stuff no longer has type
      // 'String @Annot(&quot;stuff&quot;)' but 'String @Annot(x)'.
      //
      //   def m(x: String): String @Annot(x) = x
      //   val stuff = m(&quot;stuff&quot;)
      //
      // (TODO cont.) Why an existential in the non-stable case?
      //
      // @PP: In the following:
      //
      //   def m = { val x = &quot;three&quot; ; val y: String @Annot(x) = x; y }
      //
      // m is typed as 'String @Annot(x) forSome { val x: String }'.
      //
      // Both examples are from run/constrained-types.scala.
      <span class="keyword">object</span> <a title="treeTrans.type" id="528442">treeTrans</a> <a href="#528443" title="treeTrans.type" class="keyword">extends</a> <a href="../api/Trees.scala.html#23768" title="Types.this.Transformer">Transformer</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="528445">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="528447">tree</a>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a> = <a href="#528447" title="Types.this.Tree">tree</a>.<a href="../api/Trees.scala.html#425064" title="=&gt; Types.this.Symbol">symbol</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#528280" title="Option[Types.this.Type]" id="528500">StableArg</a><span class="delimiter">(</span>actual<span class="delimiter">)</span> =&gt;
            <a href="TreeBuildUtil.scala.html#441926" title="=&gt; Types.this.TreeGen{val global: Types.this.type}">gen</a>.<a href="../api/TreeBuildUtil.scala.html#426849" title="((tpe: _2604.global.Type, termSym: _2604.global.Symbol)_2604.global.Tree) forSome { val _2604: Types.this.TreeGen{val global: Types.this.type} }">mkAttributedQualifier</a><a href="#528496" title="(x: Types.this.Tree)Types.this.Tree" class="delimiter">(</a>actual, <a href="#528447" title="Types.this.Tree">tree</a>.<a href="../api/Trees.scala.html#425064" title="=&gt; Types.this.Symbol">symbol</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <a href="#528284" title="Option[Int]" id="528502">Arg</a><span class="delimiter">(</span>pid<span class="delimiter">)</span> =&gt;
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="528469">sym</a> = <a href="#461713" title="(pid: Int)Types.this.Symbol">existentialFor</a><span class="delimiter">(</span>pid<span class="delimiter">)</span>
            <a href="Trees.scala.html#441842" title="(sym: Types.this.Symbol)Types.this.Ident">Ident</a><span class="delimiter">(</span><a href="#528469" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="../api/Trees.scala.html#425087" title="(tree: Types.this.Tree)Types.this.Ident">copyAttrs</a> <a href="#528447" title="Types.this.Tree">tree</a> <a href="../api/Trees.scala.html#425062" title="(tp: Types.this.Type)Types.this.Ident">setType</a> <a href="#441371" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#516520" title="Types.this.NoPrefix.type">NoPrefix</a>, <a href="#528469" title="Types.this.Symbol">sym</a>, <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
            <span class="keyword">super</span>.<a href="../api/Trees.scala.html#438847" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><a href="#528496" title="(x: Types.this.Tree)Types.this.Tree" class="delimiter">(</a><a href="#528447" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#528442" title="treeTrans.type">treeTrans</a> <a href="#528445" title="(tree: Types.this.Tree)Types.this.Tree">transform</a> <a href="#528328" title="Types.this.Tree">arg</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="Types.this.StripAnnotationsMap.type" id="441456">StripAnnotationsMap</a> <a href="#441457" title="Types.this.StripAnnotationsMap.type" class="keyword">extends</a> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="516218">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="516219">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#516219" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> AnnotatedType<a href="#528525" title="Types.this.Type" id="528529" class="delimiter">(</a>_, atp, _<span class="delimiter">)</span> =&gt;
        <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#528530" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>atp<span class="delimiter">)</span>
      <span class="keyword">case</span> tp =&gt;
        <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#528530" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>tp<span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to convert every occurrence of a wildcard type to a fresh
   *  type variable */
  <span class="keyword">object</span> <a title="Types.this.wildcardToTypeVarMap.type" id="441458">wildcardToTypeVarMap</a> <a href="#441459" title="Types.this.wildcardToTypeVarMap.type" class="keyword">extends</a> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="522821">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="522822">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#522822" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#516414" title="Types.this.Type" id="528566">WildcardType</a> =&gt;
        <a href="#470208" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint)Types.this.TypeVar">TypeVar</a><a href="#528567" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#522822" title="Types.this.Type">tp</a>, <a href="#470242" title="()Types.this.TypeConstraint" class="keyword">new</a> <a href="#441416" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">)</span>
      <span class="keyword">case</span> BoundedWildcardType<a href="#528562" title="Types.this.Type" id="528565" class="delimiter">(</a>bounds<span class="delimiter">)</span> =&gt;
        <a href="#470208" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint)Types.this.TypeVar">TypeVar</a><a href="#528567" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#522822" title="Types.this.Type">tp</a>, <a href="#470241" title="(bounds: Types.this.TypeBounds)Types.this.TypeConstraint" class="keyword">new</a> <a href="#441416" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">(</span>bounds<span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#528567" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#522822" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to convert every occurrence of a type variable to a wildcard type. */
  <span class="keyword">object</span> <a title="Types.this.typeVarToOriginMap.type" id="441460">typeVarToOriginMap</a> <a href="#441461" title="Types.this.typeVarToOriginMap.type" class="keyword">extends</a> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="515902">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="515903">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#515903" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#470205" title="Option[(Types.this.Type, Types.this.TypeConstraint)]" id="528598">TypeVar</a><a href="#528588" title="Types.this.Type" id="528591" class="delimiter">(</a>origin, _<span class="delimiter">)</span> =&gt; <a href="#528593" title="(x: Types.this.Type)Types.this.Type">origin</a>
      <span class="keyword">case</span> _ =&gt; <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#528593" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#515903" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `contains` method. */
  <span class="keyword">class</span> <a title="class ContainsCollector extends Types.this.TypeCollector[Boolean]" id="441462">ContainsCollector</a><a href="#441462" title="Types.this.ContainsCollector" class="delimiter">(</a><a title="Types.this.Symbol" id="515469">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441433" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="515467">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="528606">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#514863" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#528606" title="Types.this.Type">tp</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> TypeRef<a href="#528636" title="Unit" id="528640" class="delimiter">(</a>_, sym1, _<span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#515469" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> sym1<span class="delimiter">)</span> =&gt; <a href="#514863" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> SingleType<a href="#528636" title="Unit" id="528643" class="delimiter">(</a>_, sym1<span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#515469" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> sym1<span class="delimiter">)</span> =&gt; <a href="#514863" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> _ =&gt; <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#528644" title="(x: Unit)Unit" class="delimiter">(</a><a href="#528606" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(arg: Types.this.Tree)Types.this.Tree" id="515468">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="528618">arg</a>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Tree" id="528623">t</a> &lt;- <a href="../api/Trees.scala.html#425074" title="(f: Types.this.Tree =&gt; Unit)Unit">arg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#515467" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#528623" title="Types.this.Tree">t</a>.<a href="../api/Trees.scala.html#425060" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#528623" title="Types.this.Tree">t</a>.<a href="../api/Trees.scala.html#425064" title="=&gt; Types.this.Symbol">symbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#515469" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <a href="#514863" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="delimiter">}</span>
      <a href="#528618" title="Types.this.Tree">arg</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `contains` method. */
  <span class="keyword">class</span> <a title="class ContainsTypeCollector extends Types.this.TypeCollector[Boolean]" id="441463">ContainsTypeCollector</a><a href="#441463" title="Types.this.ContainsTypeCollector" class="delimiter">(</a><a title="Types.this.Type" id="515480">t</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441433" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="515478">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="528656">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#514863" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#528656" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#515480" title="Types.this.Type">t</a><span class="delimiter">)</span> <a href="#514863" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
        <span class="keyword">else</span> <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#528656" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(arg: Types.this.Tree)Types.this.Tree" id="515479">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="528658">arg</a>: <a href="../api/Trees.scala.html#23570" title="Types.this.Tree">Tree</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Tree" id="528663">t</a> &lt;- <a href="../api/Trees.scala.html#425074" title="(f: Types.this.Tree =&gt; Unit)Unit">arg</a><span class="delimiter">)</span>
        <a href="#515478" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#528663" title="Types.this.Tree">t</a>.<a href="../api/Trees.scala.html#425060" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>

      <a href="#528658" title="Types.this.Tree">arg</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `filter` method. */
  <span class="keyword">class</span> <a title="class FilterTypeCollector extends Types.this.TypeCollector[List[Types.this.Type]]" id="441464">FilterTypeCollector</a><a href="#441464" title="Types.this.FilterTypeCollector" class="delimiter">(</a><a title="Types.this.Type =&gt; Boolean" id="515318">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441433" title="Types.this.TypeCollector[List[Types.this.Type]]">TypeCollector</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(q: Types.this.Type =&gt; Boolean)Types.this.FilterTypeCollector" id="515315">withFilter</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="528673">q</a>: Type =&gt; Boolean<span class="delimiter">)</span> = <span title="Types.this.FilterTypeCollector" class="keyword">new</span> <a href="#441464" title="Types.this.FilterTypeCollector">FilterTypeCollector</a><span class="delimiter">(</span><a title="Types.this.Type" id="528675">tp</a> =&gt; <a href="../../Function1.scala.html#59555" title="(v1: Types.this.Type)Boolean">p</a><span class="delimiter">(</span><a href="#528675" title="Types.this.Type">tp</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Function1.scala.html#59555" title="(v1: Types.this.Type)Boolean">q</a><span class="delimiter">(</span><a href="#528675" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)List[Types.this.Type]" id="515316">collect</a><span class="delimiter">(</span><a title="Types.this.Type" id="515320">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#441464" title="Types.this.FilterTypeCollector" class="keyword">super</a>.<a href="#514865" title="(tp: Types.this.Type)List[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#515320" title="Types.this.Type">tp</a><span class="delimiter">)</span>.<a href="../../collection/immutable/List.scala.html#63674" title="=&gt; List[Types.this.Type]">reverse</a>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="515317">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="528678">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Function1.scala.html#59555" title="(v1: Types.this.Type)Boolean">p</a><span class="delimiter">(</span><a href="#528678" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#514863" title="(x$1: List[Types.this.Type])Unit">result</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: Types.this.Type)List[Types.this.Type]">::=</a> <a href="#528678" title="Types.this.Type">tp</a>
      <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#528678" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `collect` method. */
  <span class="keyword">class</span> <a title="class CollectTypeCollector[T] extends Types.this.TypeCollector[List[T]]" id="441465">CollectTypeCollector</a><span class="delimiter">[</span><a title="" id="441466">T</a><span class="delimiter">]</span><a href="#441465" title="Types.this.CollectTypeCollector[T]" class="delimiter">(</a><a title="PartialFunction[Types.this.Type,T]" id="515430">pf</a>: <a href="../../PartialFunction.scala.html#217" title="PartialFunction[Types.this.Type,T]">PartialFunction</a><span class="delimiter">[</span>Type, T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441433" title="Types.this.TypeCollector[List[T]]">TypeCollector</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)List[T]" id="515427">collect</a><span class="delimiter">(</span><a title="Types.this.Type" id="515434">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#441465" title="Types.this.CollectTypeCollector[T]" class="keyword">super</a>.<a href="#514865" title="(tp: Types.this.Type)List[T]">collect</a><span class="delimiter">(</span><a href="#515434" title="Types.this.Type">tp</a><span class="delimiter">)</span>.<a href="../../collection/immutable/List.scala.html#63674" title="=&gt; List[T]">reverse</a>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="515428">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="528699">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#515430" title="PartialFunction[Types.this.Type,T]">pf</a>.<a href="../../PartialFunction.scala.html#59566" title="(x: Types.this.Type)Boolean">isDefinedAt</a><span class="delimiter">(</span><a href="#528699" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#514863" title="(x$1: List[T])Unit">result</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: T)List[T]">::=</a> <a href="../../Function1.scala.html#59555" title="(v1: Types.this.Type)T">pf</a><span class="delimiter">(</span><a href="#528699" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#528699" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class ForEachTypeTraverser extends Types.this.TypeTraverser" id="441467">ForEachTypeTraverser</a><a href="#441467" title="Types.this.ForEachTypeTraverser" class="delimiter">(</a><a title="Types.this.Type =&gt; Unit" id="515421">f</a>: Type =&gt; Unit<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441430" title="Types.this.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="515420">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="515423">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../../Function1.scala.html#59555" title="(v1: Types.this.Type)Unit">f</a><span class="delimiter">(</span><a href="#515423" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#515423" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `filter` method. */
  <span class="keyword">class</span> <a title="class FindTypeCollector extends Types.this.TypeCollector[Option[Types.this.Type]]" id="441468">FindTypeCollector</a><a href="#441468" title="Types.this.FindTypeCollector" class="delimiter">(</a><a title="Types.this.Type =&gt; Boolean" id="515416">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441433" title="Types.this.TypeCollector[Option[Types.this.Type]]">TypeCollector</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="../../Option.scala.html#2498" title="None.type">None</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="515415">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="528730">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#514863" title="=&gt; Option[Types.this.Type]">result</a>.<a href="../../Option.scala.html#63811" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Function1.scala.html#59555" title="(v1: Types.this.Type)Boolean">p</a><span class="delimiter">(</span><a href="#528730" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#514863" title="(x$1: Option[Types.this.Type])Unit">result</a> = <a href="../../Option.scala.html#64111" title="(x: Types.this.Type)Some[Types.this.Type]">Some</a><span class="delimiter">(</span><a href="#528730" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#528730" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `contains` method. */
  <span class="keyword">object</span> <a title="Types.this.ErroneousCollector.type" id="441469">ErroneousCollector</a> <a href="#441470" title="Types.this.ErroneousCollector.type" class="keyword">extends</a> <a href="#441433" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="514882">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="528747">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#514863" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#514863" title="(x$1: Boolean)Unit">result</a> = <a href="#528747" title="Types.this.Type">tp</a>.<a href="#441980" title="=&gt; Boolean">isError</a>
        <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#528747" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** The most deeply nested owner that contains all the symbols
   *  of thistype or prefixless typerefs/singletype occurrences in given type.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(t: Types.this.Type)Types.this.Symbol" id="441471">commonOwner</a><span class="delimiter">(</span><a title="Types.this.Type" id="514911">t</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <a href="#441472" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#514911" title="Types.this.Type">t</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>

  /** The most deeply nested owner that contains all the symbols
   *  of thistype or prefixless typerefs/singletype occurrences in given list
   *  of types.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type])Types.this.Symbol" id="441472">commonOwner</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="514909">tps</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
    <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#514909" title="List[Types.this.Type]">tps</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <a href="#441473" title="=&gt; Types.this.CommonOwnerMap">commonOwnerMap</a>.<a href="#528774" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#514909" title="List[Types.this.Type]">tps</a> <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.Type =&gt; Unit)Unit">foreach</a> <span class="delimiter">(</span><a href="#441473" title="=&gt; Types.this.CommonOwnerMap">commonOwnerMap</a> <a href="#528776" title="(tp: Types.this.Type)Unit">traverse</a> <a href="#528797" title="Types.this.Type">_</a><span class="delimiter">)</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#441473" title="=&gt; Types.this.CommonOwnerMap">commonOwnerMap</a>.<a href="#528772" title="=&gt; Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#441473" title="=&gt; Types.this.CommonOwnerMap">commonOwnerMap</a>.<a href="#528772" title="=&gt; Types.this.Symbol">result</a> <span class="keyword">else</span> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.CommonOwnerMap" id="441473">commonOwnerMap</a>: <a href="#441474" title="Types.this.CommonOwnerMap">CommonOwnerMap</a> = <a href="#441475" title="=&gt; Types.this.CommonOwnerMap">commonOwnerMapObj</a>

  <span class="keyword">protected</span> <span class="keyword">class</span> <a title="class CommonOwnerMap extends Types.this.TypeTraverserWithResult[Types.this.Symbol]" id="441474">CommonOwnerMap</a> <a href="#441474" title="Types.this.CommonOwnerMap" class="keyword">extends</a> <a href="#441431" title="Types.this.TypeTraverserWithResult[Types.this.Symbol]">TypeTraverserWithResult</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="Types.this.Symbol" id="528772">result</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = _

    <span class="keyword">def</span> <a title="()Unit" id="528774">clear</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#528772" title="(x$1: Types.this.Symbol)Unit">result</a> = <span title="Null(null)" class="keyword">null</span> <span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="528775">register</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="528801">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      // First considered type is the trivial result.
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#528772" title="=&gt; Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#528801" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#528772" title="(x$1: Types.this.Symbol)Unit">result</a> = <a href="#528801" title="Types.this.Symbol">sym</a>
      <span class="keyword">else</span>
        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#528772" title="=&gt; Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#528772" title="=&gt; Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#528801" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#528801" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#443467" title="(that: Types.this.Symbol)Boolean">isNestedIn</a> <a href="#528772" title="=&gt; Types.this.Symbol">result</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#528772" title="(x$1: Types.this.Symbol)Unit">result</a> = <a href="#528772" title="=&gt; Types.this.Symbol">result</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="528776">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="528799">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#528799" title="Types.this.Type">tp</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> ThisType<a href="#528833" title="Unit" id="528835" class="delimiter">(</a>sym<span class="delimiter">)</span>                =&gt; <a href="#528775" title="(sym: Types.this.Symbol)Unit">register</a><a href="#528846" title="(x: Unit)Unit" class="delimiter">(</a>sym<span class="delimiter">)</span>
      <span class="keyword">case</span> TypeRef<a href="#528833" title="Unit" id="528838" class="delimiter">(</a><a href="#516520" title="Unit" id="528844">NoPrefix</a>, sym, args<span class="delimiter">)</span> =&gt; <a href="#528775" title="(sym: Types.this.Symbol)Unit">register</a><span class="delimiter">(</span>sym.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span> ; args <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.Type =&gt; Unit)Unit">foreach</a> <a href="#528776" title="(tp: Types.this.Type)Unit">traverse</a>
      <span class="keyword">case</span> SingleType<a href="#528833" title="Unit" id="528842" class="delimiter">(</a><a href="#516520" title="Unit" id="528845">NoPrefix</a>, sym<span class="delimiter">)</span>    =&gt; <a href="#528775" title="(sym: Types.this.Symbol)Unit">register</a><a href="#528846" title="(x: Unit)Unit" class="delimiter">(</a>sym.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _                            =&gt; <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#528846" title="(x: Unit)Unit" class="delimiter">(</a><a href="#528799" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.CommonOwnerMap" id="441476">commonOwnerMapObj</a> = <span title="Types.this.CommonOwnerMap" class="keyword">new</span> <a href="#441474" title="Types.this.CommonOwnerMap">CommonOwnerMap</a>

  <span class="keyword">class</span> <a title="class MissingAliasControl extends Throwable with scala.util.control.ControlThrowable" id="441477">MissingAliasControl</a> <a href="#441477" title="Types.this.MissingAliasControl" class="keyword">extends</a> <a href="../../util/control/ControlThrowable.scala.html#53835" title="scala.util.control.ControlThrowable">ControlThrowable</a>
  <span class="keyword">val</span> <a title="Types.this.MissingAliasControl" id="441478">missingAliasException</a> = <span title="Types.this.MissingAliasControl" class="keyword">new</span> <a href="#441477" title="Types.this.MissingAliasControl">MissingAliasControl</a>
  <span class="keyword">class</span> <a title="class MissingTypeControl extends Throwable with scala.util.control.ControlThrowable" id="441480">MissingTypeControl</a> <a href="#441480" title="Types.this.MissingTypeControl" class="keyword">extends</a> <a href="../../util/control/ControlThrowable.scala.html#53835" title="scala.util.control.ControlThrowable">ControlThrowable</a>

  <span class="keyword">object</span> <a title="Types.this.adaptToNewRunMap.type" id="441481">adaptToNewRunMap</a> <a href="#441482" title="Types.this.adaptToNewRunMap.type" class="keyword">extends</a> <a href="#441429" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol" id="496445">adaptToNewRun</a><span class="delimiter">(</span><a title="Types.this.Type" id="528877">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="528878">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452456" title="=&gt; Boolean">flatClasses</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443294" title="=&gt; Boolean">isRootSymbol</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#528877" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516520" title="Types.this.NoPrefix.type">NoPrefix</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#528877" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span>
        <a href="#528878" title="Types.this.Symbol">sym</a>
      <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443245" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="528879">sourceModule1</a> = <a href="#496445" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#528877" title="Types.this.Type">pre</a>, <a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443490" title="=&gt; Types.this.Symbol">sourceModule</a><span class="delimiter">)</span>

        <a href="#528879" title="Types.this.Symbol">sourceModule1</a>.<a href="Symbols.scala.html#443515" title="=&gt; Types.this.Symbol">moduleClass</a> <a href="Symbols.scala.html#443540" title="(alt: =&gt; Types.this.Symbol)Types.this.Symbol">orElse</a> <a href="#528879" title="Types.this.Symbol">sourceModule1</a>.<a href="Symbols.scala.html#443439" title="=&gt; sourceModule1.type">initialize</a>.<a href="Symbols.scala.html#443515" title="=&gt; Types.this.Symbol">moduleClass</a> <a href="Symbols.scala.html#443540" title="(alt: =&gt; Types.this.Symbol)Types.this.Symbol">orElse</a> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="String" id="528890">msg</a> = <span title="String(&quot;Cannot adapt module class; sym = %s, sourceModule = %s, sourceModule.moduleClass = %s =&gt; sourceModule1 = %s, sourceModule1.moduleClass = %s&quot;)" class="string">&quot;Cannot adapt module class; sym = %s, sourceModule = %s, sourceModule.moduleClass = %s =&gt; sourceModule1 = %s, sourceModule1.moduleClass = %s&quot;</span>
          <a href="SymbolTable.scala.html#440551" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="../../Predef.scala.html#8578" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">msg</a>.<a href="../../collection/immutable/StringLike.scala.html#60730" title="(args: Any*)String">format</a><span class="delimiter">(</span><a href="#528878" title="Types.this.Symbol">sym</a>, <a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443490" title="=&gt; Types.this.Symbol">sourceModule</a>, <a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443490" title="=&gt; Types.this.Symbol">sourceModule</a>.<a href="Symbols.scala.html#443515" title="=&gt; Types.this.Symbol">moduleClass</a>, <a href="#528879" title="Types.this.Symbol">sourceModule1</a>, <a href="#528879" title="Types.this.Symbol">sourceModule1</a>.<a href="Symbols.scala.html#443515" title="=&gt; Types.this.Symbol">moduleClass</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#528878" title="Types.this.Symbol">sym</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">var</span> <a title="Types.this.Symbol" id="528895">rebind0</a> = <a href="#528877" title="Types.this.Type">pre</a>.<a href="#442083" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym.NameType">name</a>, <span title="Long(67108864L)">BRIDGE</span>, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span> <a href="Symbols.scala.html#443540" title="(alt: =&gt; Types.this.Symbol)Types.this.Symbol">orElse</a> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443232" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <a href="#441478" title="=&gt; Types.this.MissingAliasControl">missingAliasException</a>
          <a href="SymbolTable.scala.html#440552" title="(msg: =&gt; String)Unit">debugwarn</a><span class="delimiter">(</span><a href="../../Predef.scala.html#8576" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">pre</a><a href="../../runtime/StringAdd.scala.html#60949" title="(other: String)String">+</a><span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span><span title="(x$1: Any)String">+</span><a href="#528878" title="Types.this.Symbol">sym</a><span title="(x$1: Any)String">+</span><span title="String(&quot; does no longer exist, phase = &quot;)" class="string">&quot; does no longer exist, phase = &quot;</span><span title="(x$1: Any)String">+</span><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <span title="Types.this.MissingTypeControl" class="keyword">new</span> <a href="#441480" title="Types.this.MissingTypeControl">MissingTypeControl</a> // For build manager and presentation compiler purposes
        <span class="delimiter">}</span>
        /** The two symbols have the same fully qualified name */
        <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean" id="528896">corresponds</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="528904">sym1</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="528905">sym2</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> =
          <a href="#528904" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym1.NameType">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#528905" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym2.NameType">name</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#528904" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#528896" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#528904" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>, <a href="#528905" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#528896" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>, <a href="#528895" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="SymbolTable.scala.html#440551" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><span title="String(&quot;ADAPT1 pre = &quot;)" class="string">&quot;ADAPT1 pre = &quot;</span><span title="(x$1: Any)String">+</span><a href="#528877" title="Types.this.Type">pre</a><span title="(x$1: Any)String">+</span><span title="String(&quot;, sym = &quot;)" class="string">&quot;, sym = &quot;</span><span title="(x$1: Any)String">+</span><a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443562" title="=&gt; String">fullLocationString</a><span title="(x$1: Any)String">+</span><span title="String(&quot;, rebind = &quot;)" class="string">&quot;, rebind = &quot;</span><span title="(x$1: Any)String">+</span><a href="#528895" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#443562" title="=&gt; String">fullLocationString</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="528912">bcs</a> = <a href="#528877" title="Types.this.Type">pre</a>.<a href="#442068" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<a href="../../collection/immutable/List.scala.html#63672" title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">dropWhile</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="528919">bc</a> =&gt; <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#528896" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#528919" title="Types.this.Symbol">bc</a>, <a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>;
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#528912" title="List[Types.this.Symbol]">bcs</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span>
            <a href="../../Predef.scala.html#8460" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#528877" title="Types.this.Type">pre</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443248" title="=&gt; Boolean">isRefinementClass</a>, <a href="#528877" title="Types.this.Type">pre</a><span class="delimiter">)</span> // if pre is a refinementclass it might be a structural type =&gt; OK to leave it in.
          <span class="keyword">else</span>
            <a href="#528895" title="Types.this.Symbol">rebind0</a> = <a href="#528877" title="Types.this.Type">pre</a>.<a href="#442036" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#528912" title="List[Types.this.Symbol]">bcs</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a><span class="delimiter">)</span>.<a href="#442028" title="(name: Types.this.Name)Types.this.Symbol">member</a><span class="delimiter">(</span><a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym.NameType">name</a><span class="delimiter">)</span>
          <a href="SymbolTable.scala.html#440551" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span>
            <span title="String(&quot;ADAPT2 pre = &quot;)" class="string">&quot;ADAPT2 pre = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#528877" title="Types.this.Type">pre</a> <span title="(x$1: Any)String">+</span>
            <span title="String(&quot;, bcs.head = &quot;)" class="string">&quot;, bcs.head = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#528912" title="List[Types.this.Symbol]">bcs</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a> <span title="(x$1: Any)String">+</span>
            <span title="String(&quot;, sym = &quot;)" class="string">&quot;, sym = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443562" title="=&gt; String">fullLocationString</a> <span title="(x$1: Any)String">+</span>
            <span title="String(&quot;, rebind = &quot;)" class="string">&quot;, rebind = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#528895" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#443562" title="=&gt; String">fullLocationString</a>
          <span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#528895" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#443474" title="(cond: Types.this.Symbol =&gt; Boolean)Types.this.Symbol">suchThat</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="528930">sym</a> =&gt; <a href="#528930" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443230" title="=&gt; Boolean">isType</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#528930" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443349" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="Symbols.scala.html#443540" title="(alt: =&gt; Types.this.Symbol)Types.this.Symbol">orElse</a> <span class="delimiter">{</span>
          <a href="SymbolTable.scala.html#440551" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)String">+</span><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452456" title="=&gt; Boolean">flatClasses</a><span title="(x$1: Any)String">+</span><a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span title="(x$1: Any)String">+</span><a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym.NameType">name</a><span title="(x$1: Any)String">+</span><span title="String(&quot; &quot;)" class="string">&quot; &quot;</span><span title="(x$1: Any)String">+</span><a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443230" title="=&gt; Boolean">isType</a><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <a href="#527968" title="(pre: Types.this.Type, tp: String)Types.this.MalformedType" class="keyword">new</a> <a href="#441583" title="Types.this.MalformedType">MalformedType</a><span class="delimiter">(</span><a href="#528877" title="Types.this.Type">pre</a>, <a href="#528878" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443556" title="=&gt; String">nameString</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="496446">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="496447">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#496447" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> ThisType<a href="#529059" title="Types.this.Type" id="529061" class="delimiter">(</a>sym<span class="delimiter">)</span> =&gt;
        <a href="#529101" title="(x: Types.this.Type)Types.this.Type" class="keyword">try</a> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="528942">sym1</a> = <a href="#496445" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span>sym.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#443485" title="=&gt; Types.this.Type">thisType</a>, sym<span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#528942" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> sym<span class="delimiter">)</span> <a href="#496447" title="Types.this.Type">tp</a> <span class="keyword">else</span> <a href="#461307" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="#528942" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Types.this.Type" id="528947">ex</a>: <a href="#441480" title="Types.this.MissingTypeControl">MissingTypeControl</a> =&gt;
            <a href="#496447" title="Types.this.Type">tp</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> SingleType<a href="#529059" title="Types.this.Type" id="529063" class="delimiter">(</a>pre, sym<span class="delimiter">)</span> =&gt;
        <a href="#529101" title="(x: Types.this.Type)Types.this.Type" class="keyword">if</a> <span class="delimiter">(</span>sym.<a href="Symbols.scala.html#443286" title="=&gt; Boolean">isPackage</a><span class="delimiter">)</span> <a href="#496447" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="528951">pre1</a> = <a href="#496446" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>pre<span class="delimiter">)</span>
          <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="528953">sym1</a> = <a href="#496445" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#528951" title="Types.this.Type">pre1</a>, sym<span class="delimiter">)</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#528951" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> pre<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#528953" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">eq</span> sym<span class="delimiter">)</span><span class="delimiter">)</span> <a href="#496447" title="Types.this.Type">tp</a>
            <span class="keyword">else</span> <a href="#441367" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#528951" title="Types.this.Type">pre1</a>, <a href="#528953" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Types.this.Type">_</span>: <a href="#441480" title="Types.this.MissingTypeControl">MissingTypeControl</a> =&gt;
              <a href="#496447" title="Types.this.Type">tp</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> TypeRef<a href="#529059" title="Types.this.Type" id="529065" class="delimiter">(</a>pre, sym, args<span class="delimiter">)</span> =&gt;
        <a href="#529101" title="(x: Types.this.Type)Types.this.Type" class="keyword">if</a> <span class="delimiter">(</span>sym.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#496447" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="528958">pre1</a> = <a href="#496446" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>pre<span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="528959">args1</a> = args <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</a> <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>
          <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="528966">sym1</a> = <a href="#496445" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#528958" title="Types.this.Type">pre1</a>, sym<span class="delimiter">)</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#528958" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> pre<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#528966" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">eq</span> sym<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#528959" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> args<span class="delimiter">)</span>/* &amp;&amp; sym.isExternal*/<span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#496447" title="Types.this.Type">tp</a>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#528966" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="SymbolTable.scala.html#440552" title="(msg: =&gt; String)Unit">debugwarn</a><span class="delimiter">(</span><span title="String(&quot;adapt fail: &quot;)" class="string">&quot;adapt fail: &quot;</span><span title="(x$1: Any)String">+</span>pre<span title="(x$1: Any)String">+</span><span title="String(&quot; &quot;)" class="string">&quot; &quot;</span><span title="(x$1: Any)String">+</span><a href="#528958" title="Types.this.Type">pre1</a><span title="(x$1: Any)String">+</span><span title="String(&quot; &quot;)" class="string">&quot; &quot;</span><span title="(x$1: Any)String">+</span>sym<span class="delimiter">)</span>
              <a href="#496447" title="Types.this.Type">tp</a>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <a href="#441372" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#496447" title="Types.this.Type">tp</a>, <a href="#528958" title="Types.this.Type">pre1</a>, <a href="#528966" title="Types.this.Symbol">sym1</a>, <a href="#528959" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a title="Types.this.Type" id="528971">ex</a>: <a href="#441477" title="Types.this.MissingAliasControl">MissingAliasControl</a> =&gt;
              <a href="#496446" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#496447" title="Types.this.Type">tp</a>.<a href="#442018" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="Types.this.Type">_</span>: <a href="#441480" title="Types.this.MissingTypeControl">MissingTypeControl</a> =&gt;
              <a href="#496447" title="Types.this.Type">tp</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> MethodType<a href="#529059" title="Types.this.Type" id="529067" class="delimiter">(</a>params, restp<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="528976">restp1</a> = <a href="#496446" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>restp<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#528976" title="Types.this.Type">restp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> restp<span class="delimiter">)</span> <a href="#496447" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#441374" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#496447" title="Types.this.Type">tp</a>, params, <a href="#528976" title="Types.this.Type">restp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> NullaryMethodType<a href="#529059" title="Types.this.Type" id="529069" class="delimiter">(</a>restp<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="528979">restp1</a> = <a href="#496446" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>restp<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#528979" title="Types.this.Type">restp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> restp<span class="delimiter">)</span> <a href="#496447" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#448427" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#528979" title="Types.this.Type">restp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> PolyType<a href="#529059" title="Types.this.Type" id="529071" class="delimiter">(</a>tparams, restp<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="528982">restp1</a> = <a href="#496446" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span>restp<span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#528982" title="Types.this.Type">restp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> restp<span class="delimiter">)</span> <a href="#496447" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#448476" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span>tparams, <a href="#528982" title="Types.this.Type">restp1</a><span class="delimiter">)</span>

      // Lukas: we need to check (together) whether we should also include parameter types
      // of PolyType and MethodType in adaptToNewRun

      <span class="keyword">case</span> ClassInfoType<a href="#529059" title="Types.this.Type" id="529073" class="delimiter">(</a>parents, decls, clazz<span class="delimiter">)</span> =&gt;
        <a href="#529101" title="(x: Types.this.Type)Types.this.Type" class="keyword">if</a> <span class="delimiter">(</span>clazz.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#496447" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="528986">parents1</a> = parents <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</a> <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#528986" title="List[Types.this.Type]">parents1</a> <span title="(x$1: AnyRef)Boolean">eq</span> parents<span class="delimiter">)</span> <a href="#496447" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#454759" title="(parents: List[Types.this.Type], decls: Types.this.Scope, typeSymbol: Types.this.Symbol)Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">(</span><a href="#528986" title="List[Types.this.Type]">parents1</a>, decls, clazz<span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> RefinedType<a href="#529059" title="Types.this.Type" id="529075" class="delimiter">(</a>parents, decls<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="528995">parents1</a> = parents <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</a> <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#528995" title="List[Types.this.Type]">parents1</a> <span title="(x$1: AnyRef)Boolean">eq</span> parents<span class="delimiter">)</span> <a href="#496447" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#441368" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#528995" title="List[Types.this.Type]">parents1</a>, <a href="#496447" title="Types.this.Type">tp</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>, decls, <a href="#496447" title="Types.this.Type">tp</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#443167" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>
      <span class="keyword">case</span> SuperType<a href="#529059" title="Types.this.Type" id="529079" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt; <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#529101" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#496447" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> TypeBounds<a href="#529059" title="Types.this.Type" id="529083" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt; <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#529101" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#496447" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="#470205" title="Option[(Types.this.Type, Types.this.TypeConstraint)]" id="529115">TypeVar</a><a href="#529059" title="Types.this.Type" id="529087" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt; <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#529101" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#496447" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> AnnotatedType<a href="#529059" title="Types.this.Type" id="529093" class="delimiter">(</a>_,_,_<span class="delimiter">)</span> =&gt; <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#529101" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#496447" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> NotNullType<a href="#529059" title="Types.this.Type" id="529096" class="delimiter">(</a>_<span class="delimiter">)</span> =&gt; <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#529101" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#496447" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> ExistentialType<a href="#529059" title="Types.this.Type" id="529100" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt; <a href="#460841" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><a href="#529101" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#496447" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt; <a href="#529101" title="(x: Types.this.Type)Types.this.Type">tp</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class SubTypePair extends Object" id="441483">SubTypePair</a><a href="#441483" title="Types.this.SubTypePair" class="delimiter">(</a><span class="keyword">val</span> <a title="Types.this.Type" id="529133">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <span class="keyword">val</span> <a title="Types.this.Type" id="529134">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()Int" id="529127">hashCode</a> = <a href="#529133" title="=&gt; Types.this.Type">tp1</a>.<span title="()Int">hashCode</span> <a href="../../Int.scala.html#57962" title="(x: Int)Int">*</a> <span title="Int(41)" class="int">41</span> <a href="../../Int.scala.html#57948" title="(x: Int)Int">+</a> <a href="#529134" title="=&gt; Types.this.Type">tp2</a>.<span title="()Int">hashCode</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(other: Any)Boolean" id="529128">equals</a><span class="delimiter">(</span><a title="Any" id="529146">other</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <a href="#529146" title="Any">other</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="../../Boolean.scala.html#58725" title="Boolean" id="529156">stp</a>: SubTypePair =&gt;
        <span class="delimiter">(</span><a href="#529133" title="=&gt; Types.this.Type">tp1</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> stp.<a href="#529133" title="=&gt; Types.this.Type">tp1</a><span class="delimiter">)</span> <a href="#529157" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#529134" title="=&gt; Types.this.Type">tp2</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> stp.<a href="#529134" title="=&gt; Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#529157" title="(x: Boolean)Boolean" class="keyword">false</a>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="529129">toString</a> = <a href="../../Predef.scala.html#8576" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">tp1</a><a href="../../runtime/StringAdd.scala.html#60949" title="(other: String)String">+</a><span title="String(&quot; &lt;:&lt;? &quot;)" class="string">&quot; &lt;:&lt;? &quot;</span><span title="(x$1: Any)String">+</span><a href="#529134" title="=&gt; Types.this.Type">tp2</a>
  <span class="delimiter">}</span>

// Helper Methods  -------------------------------------------------------------

  <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(0)" id="441484">LubGlbMargin</a> = <span title="Int(0)" class="int">0</span>

  /** The maximum allowable depth of lubs or glbs over types `ts`.
    * This is the maximum depth of all types in the base type sequences
    * of each of the types `ts`, plus LubGlbMargin.
    */
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Int" id="441486">lubDepth</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="447393">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="Int" id="447396">d</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="447416">tp</a> &lt;- <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.Type =&gt; Unit)Unit">ts</a><span class="delimiter">)</span> <a href="#447396" title="Int">d</a> = math.<a href="../../math/package.scala.html#56928" title="(x: Int, y: Int)Int">max</a><span class="delimiter">(</span><a href="#447396" title="Int">d</a>, <a href="#447416" title="Types.this.Type">tp</a>.<a href="#442067" title="=&gt; Int">baseTypeSeqDepth</a><span class="delimiter">)</span>
    <a href="#447396" title="Int">d</a> <a href="../../Int.scala.html#57948" title="(x: Int)Int">+</a> <span title="Int(0)">LubGlbMargin</span>
  <span class="delimiter">}</span>

  /** Is intersection of given types populated? That is,
   *  for all types tp1, tp2 in intersection
   *    for all common base classes bc of tp1 and tp2
   *      let bt1, bt2 be the base types of tp1, tp2 relative to class bc
   *      Then:
   *        bt1 and bt2 have the same prefix, and
   *        any corresponding non-variant type arguments of bt1 and bt2 are the same
   */
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="441487">isPopulated</a><span class="delimiter">(</span><a title="Types.this.Type" id="510558">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="510559">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="529167">isConsistent</a><span class="delimiter">(</span><a title="Types.this.Type" id="529169">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="529170">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="../../Tuple2.scala.html#63804" title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</a><a href="#529169" title="Types.this.Type">tp1</a>, <a href="#529170" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>TypeRef<a title="Boolean" id="529263" class="delimiter">(</a>pre1, sym1, args1<span class="delimiter">)</span>, TypeRef<a title="Boolean" id="529265" class="delimiter">(</a>pre2, sym2, args2<span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <a href="../../Predef.scala.html#8459" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span>sym1 <span title="(x$1: AnyRef)Boolean">==</span> sym2<span class="delimiter">)</span>
        pre1 <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> pre2 <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
        <a href="util/Collections.scala.html#440748" title="(xs1: List[Types.this.Type], xs2: List[Types.this.Type], xs3: List[Types.this.Symbol])(f: (Types.this.Type, Types.this.Type, Types.this.Symbol) =&gt; Boolean)Boolean">forall3</a><span class="delimiter">(</span>args1, args2, sym1.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Type" id="529229">arg1</a>, <a title="Types.this.Type" id="529230">arg2</a>, <a title="Types.this.Symbol" id="529231">tparam</a><span class="delimiter">)</span> =&gt;
            //if (tparam.variance == 0 &amp;&amp; !(arg1 =:= arg2)) Console.println(&quot;inconsistent: &quot;+arg1+&quot;!=&quot;+arg2)//DEBUG
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#529231" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443377" title="=&gt; Int">variance</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#529229" title="Types.this.Type">arg1</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#529230" title="Types.this.Type">arg2</a>
          <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#529229" title="Types.this.Type">arg1</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#441345" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span><span class="delimiter">)</span>
            // if left-hand argument is a typevar, make it compatible with variance
            // this is for more precise pattern matching
            // todo: work this in the spec of this method
            // also: think what happens if there are embedded typevars?
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#529231" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443377" title="=&gt; Int">variance</a> <a href="../../Int.scala.html#57905" title="(x: Int)Boolean">&lt;</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#529229" title="Types.this.Type">arg1</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#529230" title="Types.this.Type">arg2</a> <span class="keyword">else</span> <a href="#529230" title="Types.this.Type">arg2</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#529229" title="Types.this.Type">arg1</a>
          <span class="keyword">else</span> <span title="Boolean(true)" class="keyword">true</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>et: ExistentialType, _<span class="delimiter">)</span> =&gt;
        et.<a href="#448590" title="(op: Types.this.Type =&gt; Boolean)Boolean">withTypeVars</a><a href="#529272" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#529167" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#529250" title="Types.this.Type">_</a>, <a href="#529170" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>_, et: ExistentialType<span class="delimiter">)</span> =&gt;
        et.<a href="#448590" title="(op: Types.this.Type =&gt; Boolean)Boolean">withTypeVars</a><a href="#529272" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#529167" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#529169" title="Types.this.Type">tp1</a>, <a href="#529257" title="Types.this.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="529168">check</a><span class="delimiter">(</span><a title="Types.this.Type" id="529278">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="529279">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#529278" title="Types.this.Type">tp1</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443231" title="=&gt; Boolean">isClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#529278" title="Types.this.Type">tp1</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443303" title="(mask: Long)Boolean">hasFlag</a><span class="delimiter">(</span><span title="Long(32L)">FINAL</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#529278" title="Types.this.Type">tp1</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#529279" title="Types.this.Type">tp2</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="Definitions.scala.html#442839" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#529278" title="Types.this.Type">tp1</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="Definitions.scala.html#442839" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#529279" title="Types.this.Type">tp2</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#529278" title="Types.this.Type">tp1</a>.<a href="#442068" title="=&gt; List[Types.this.Symbol]">baseClasses</a> <a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="529291">bc</a> =&gt;
        <a href="#529279" title="Types.this.Type">tp2</a>.<a href="#442069" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#529291" title="Types.this.Symbol">bc</a><span class="delimiter">)</span> <a href="../../Int.scala.html#57905" title="(x: Int)Boolean">&lt;</a> <span title="Int(0)" class="int">0</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#529167" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#529278" title="Types.this.Type">tp1</a>.<a href="#442036" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#529291" title="Types.this.Symbol">bc</a><span class="delimiter">)</span>, <a href="#529279" title="Types.this.Type">tp2</a>.<a href="#442036" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#529291" title="Types.this.Symbol">bc</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <a href="#529168" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">check</a><span class="delimiter">(</span><a href="#510558" title="Types.this.Type">tp1</a>, <a href="#510559" title="Types.this.Type">tp2</a><span class="delimiter">)</span>/* &amp;&amp; check(tp2, tp1)*/ // need to investgate why this can't be made symmetric -- neg/gadts1 fails, and run/existials also.
  <span class="delimiter">}</span>

  /** Does a pattern of type `patType` need an outer test when executed against
   *  selector type `selType` in context defined by `currentOwner`?
   */
  <span class="keyword">def</span> <a title="(patType: Types.this.Type, selType: Types.this.Type, currentOwner: Types.this.Symbol)Boolean" id="441488">needsOuterTest</a><span class="delimiter">(</span><a title="Types.this.Type" id="510495">patType</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="510496">selType</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="510497">currentOwner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type)Types.this.Type" id="510500">createDummyClone</a><span class="delimiter">(</span><a title="Types.this.Type" id="510502">pre</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.TermSymbol" id="510503">dummy</a> = <a href="#510497" title="Types.this.Symbol">currentOwner</a>.<a href="Symbols.scala.html#443480" title="Types.this.Symbol" id="510511">enclClass</a>.<a href="Symbols.scala.html#457649" title="Types.this.Position" id="510514">newValue</a><span class="delimiter">(</span><a href="StdNames.scala.html#441764" title="Types.this.nme.type">nme</a>.<a href="StdNames.scala.html#446175" title="Types.this.nme.NameType" id="510512">ANYNAME</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#443429" title="(info: Types.this.Type)Types.this.TermSymbol">setInfo</a><span class="delimiter">(</span><a href="#510502" title="Types.this.Type">pre</a>.<a href="#441990" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
      <a href="#441367" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#461307" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="#510497" title="Types.this.Symbol">currentOwner</a>.<a href="Symbols.scala.html#443480" title="=&gt; Types.this.Symbol">enclClass</a><span class="delimiter">)</span>, <a href="#510503" title="Types.this.TermSymbol">dummy</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="510501">maybeCreateDummyClone</a><span class="delimiter">(</span><a title="Types.this.Type" id="510521">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="510522">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#510521" title="Types.this.Type">pre</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> SingleType<a href="#510543" title="Types.this.Type" id="510545" class="delimiter">(</a>pre1, sym1<span class="delimiter">)</span> =&gt;
        <a href="#510548" title="(x: Types.this.Type)Types.this.Type" class="keyword">if</a> <span class="delimiter">(</span>sym1.<a href="Symbols.scala.html#443270" title="=&gt; Boolean">isModule</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> sym1.<a href="Symbols.scala.html#443356" title="=&gt; Boolean">isStatic</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#516490" title="Types.this.NoType.type">NoType</a>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span>sym1.<a href="Symbols.scala.html#443270" title="=&gt; Boolean">isModule</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#510522" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> sym1.<a href="Symbols.scala.html#443515" title="=&gt; Types.this.Symbol">moduleClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="510530">pre2</a> = <a href="#510501" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span>pre1, sym1<span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#510530" title="Types.this.Type">pre2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="#510530" title="Types.this.Type">pre2</a>
          <span class="keyword">else</span> <a href="#441367" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#510530" title="Types.this.Type">pre2</a>, sym1<span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <a href="#510500" title="(pre: Types.this.Type)Types.this.Type">createDummyClone</a><span class="delimiter">(</span><a href="#510521" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> ThisType<a href="#510543" title="Types.this.Type" id="510547" class="delimiter">(</a>clazz<span class="delimiter">)</span> =&gt;
        <a href="#510548" title="(x: Types.this.Type)Types.this.Type" class="keyword">if</a> <span class="delimiter">(</span>clazz.<a href="Symbols.scala.html#443245" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span>
          <a href="#510501" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span>clazz.<a href="Symbols.scala.html#443484" title="=&gt; Types.this.Type">typeOfThis</a>, <a href="#510522" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#510522" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> clazz <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#510522" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443303" title="(mask: Long)Boolean">hasFlag</a><span class="delimiter">(</span><span title="Long(4L)">PRIVATE</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#510522" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443417" title="=&gt; Types.this.Symbol">privateWithin</a> <span title="(x$1: AnyRef)Boolean">==</span> clazz<span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#516490" title="Types.this.NoType.type">NoType</a>
        <span class="keyword">else</span>
          <a href="#510500" title="(pre: Types.this.Type)Types.this.Type">createDummyClone</a><span class="delimiter">(</span><a href="#510521" title="Types.this.Type">pre</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#510548" title="(x: Types.this.Type)Types.this.Type">NoType</a>
    <span class="delimiter">}</span>
    <a href="#510495" title="Types.this.Type">patType</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> TypeRef<a href="#510567" title="Boolean" id="510569" class="delimiter">(</a>pre, sym, args<span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="510557">pre1</a> = <a href="#510501" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span>pre, sym<span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="#510557" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441487" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isPopulated</a><span class="delimiter">(</span><a href="#441372" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#510495" title="Types.this.Type">patType</a>, <a href="#510557" title="Types.this.Type">pre1</a>, sym, args<span class="delimiter">)</span>, <a href="#510496" title="Types.this.Type">selType</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#510570" title="(x: Boolean)Boolean" class="keyword">false</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="441490">subsametypeRecursions</a>: <a href="../../Int.scala.html#508" title="Int">Int</a> = <span title="Int(0)" class="int">0</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(pre1: Types.this.Type, pre2: Types.this.Type)Boolean" id="441492">isUnifiable</a><span class="delimiter">(</span><a title="Types.this.Type" id="529298">pre1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="529299">pre2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
    <span class="delimiter">(</span><a href="#441514" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#529298" title="Types.this.Type">pre1</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#441514" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#529299" title="Types.this.Type">pre2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#529298" title="Types.this.Type">pre1</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#529299" title="Types.this.Type">pre2</a><span class="delimiter">)</span>

  /** Returns true iff we are past phase specialize,
   *  sym1 and sym2 are two existential skolems with equal names and bounds,
   *  and pre1 and pre2 are equal prefixes
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol, pre1: Types.this.Type, pre2: Types.this.Type)Boolean" id="441493">isSameSpecializedSkolem</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="529305">sym1</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="529306">sym2</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="529307">pre1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="529308">pre2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#529305" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443253" title="=&gt; Boolean">isExistentialSkolem</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#529306" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443253" title="=&gt; Boolean">isExistentialSkolem</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
    <a href="#529305" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym1.NameType">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#529306" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym2.NameType">name</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
    <a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452454" title="=&gt; Boolean">specialized</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
    <a href="#529305" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#529306" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
    <a href="#529307" title="Types.this.Type">pre1</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#529308" title="Types.this.Type">pre2</a>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean" id="441494">equalSymsAndPrefixes</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="529319">sym1</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="529320">pre1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="529321">sym2</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="529322">pre2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> =
    <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#529319" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#529321" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> <a href="#529319" title="Types.this.Symbol">sym1</a>.<a href="HasFlags.scala.html#443617" title="=&gt; Boolean">hasPackageFlag</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#529320" title="Types.this.Type">pre1</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#529322" title="Types.this.Type">pre2</a>
    <span class="keyword">else</span> <span class="delimiter">(</span><a href="#529319" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym1.NameType">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#529321" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym2.NameType">name</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441492" title="(pre1: Types.this.Type, pre2: Types.this.Type)Boolean">isUnifiable</a><span class="delimiter">(</span><a href="#529320" title="Types.this.Type">pre1</a>, <a href="#529322" title="Types.this.Type">pre2</a><span class="delimiter">)</span>

  /** Do `tp1` and `tp2` denote equivalent types? */
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="441495">isSameType</a><span class="delimiter">(</span><a title="Types.this.Type" id="515797">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="515798">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="util/StatBase.scala.html#441044" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#441084" title="=&gt; scala.reflect.internal.util.Statistics.Counter">sametypeCount</a><span class="delimiter">)</span>
    <a href="#441490" title="(x$1: Int)Unit">subsametypeRecursions</a> <a href="../../Int.scala.html#57948" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
    <a href="#441231" title="=&gt; Types.this.UndoLog">undoLog</a> <a href="#514541" title="(block: =&gt; Boolean)Boolean">undoUnless</a> <span class="delimiter">{</span>
      <a href="#441499" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType1</a><span class="delimiter">(</span><a href="#515797" title="Types.this.Type">tp1</a>, <a href="#515798" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#441490" title="(x$1: Int)Unit">subsametypeRecursions</a> <a href="../../Int.scala.html#57955" title="(x: Int)Int">-=</a> <span title="Int(1)" class="int">1</span>
    // XXX AM TODO: figure out when it is safe and needed to clear the log -- the commented approach below is too eager (it breaks #3281, #3866)
    // it doesn't help to keep separate recursion counts for the three methods that now share it
    // if (subsametypeRecursions == 0) undoLog.clear()
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="441496">isDifferentType</a><span class="delimiter">(</span><a title="Types.this.Type" id="529352">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="529353">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="#441490" title="(x$1: Int)Unit">subsametypeRecursions</a> <a href="../../Int.scala.html#57948" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
    <a href="#441231" title="=&gt; Types.this.UndoLog">undoLog</a> <a href="#514538" title="(block: =&gt; Boolean)Boolean">undo</a> <span class="delimiter">{</span> // undo type constraints that arise from operations in this block
      <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#441499" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType1</a><span class="delimiter">(</span><a href="#529352" title="Types.this.Type">tp1</a>, <a href="#529353" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#441490" title="(x$1: Int)Unit">subsametypeRecursions</a> <a href="../../Int.scala.html#57955" title="(x: Int)Int">-=</a> <span title="Int(1)" class="int">1</span>
    // XXX AM TODO: figure out when it is safe and needed to clear the log -- the commented approach below is too eager (it breaks #3281, #3866)
    // it doesn't help to keep separate recursion counts for the three methods that now share it
    // if (subsametypeRecursions == 0) undoLog.clear()
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="441497">isDifferentTypeConstructor</a><span class="delimiter">(</span><a title="Types.this.Type" id="529371">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="529372">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#529371" title="Types.this.Type">tp1</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> TypeRef<a href="#529393" title="Boolean" id="529396" class="delimiter">(</a>pre1, sym1, _<span class="delimiter">)</span> =&gt;
      <a href="#529397" title="(x: Boolean)Boolean">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> TypeRef<a href="#529383" title="Boolean" id="529386" class="delimiter">(</a>pre2, sym2, _<span class="delimiter">)</span> =&gt; sym1 <span title="(x$1: AnyRef)Boolean">!=</span> sym2 <a href="#529387" title="(x: Boolean)Boolean">||</a> <a href="#441496" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isDifferentType</a><span class="delimiter">(</span>pre1, pre2<span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt; <a href="#529387" title="(x: Boolean)Boolean" class="keyword">true</a>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> _ =&gt; <a href="#529397" title="(x: Boolean)Boolean" class="keyword">true</a>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="441498">normalizePlus</a><span class="delimiter">(</span><a title="Types.this.Type" id="529402">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#441439" title="(tp: Types.this.Type)Boolean">isRawType</a><span class="delimiter">(</span><a href="#529402" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#460839" title="(tp: Types.this.Type)Types.this.Type">rawToExistential</a><span class="delimiter">(</span><a href="#529402" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <a href="#529402" title="Types.this.Type">tp</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a>

  /*
  todo: change to:
  def normalizePlus(tp: Type) = tp match {
    case TypeRef(pre, sym, List()) =&gt;
      if (!sym.isInitialized) sym.rawInfo.load(sym)
      if (sym.isJavaDefined &amp;&amp; !sym.typeParams.isEmpty) rawToExistential(tp)
      else tp.normalize
    case _ =&gt; tp.normalize
  }
  */
/*
  private def isSameType0(tp1: Type, tp2: Type): Boolean = {
    if (tp1 eq tp2) return true
    ((tp1, tp2) match {
      case (ErrorType, _) =&gt; true
      case (WildcardType, _) =&gt; true
      case (_, ErrorType) =&gt; true
      case (_, WildcardType) =&gt; true

      case (NoType, _) =&gt; false
      case (NoPrefix, _) =&gt; tp2.typeSymbol.isPackageClass
      case (_, NoType) =&gt; false
      case (_, NoPrefix) =&gt; tp1.typeSymbol.isPackageClass

      case (ThisType(sym1), ThisType(sym2))
      if (sym1 == sym2) =&gt;
        true
      case (SingleType(pre1, sym1), SingleType(pre2, sym2))
      if (equalSymsAndPrefixes(sym1, pre1, sym2, pre2)) =&gt;
        true
/*
      case (SingleType(pre1, sym1), ThisType(sym2))
      if (sym1.isModule &amp;&amp;
          sym1.moduleClass == sym2 &amp;&amp;
          pre1 =:= sym2.owner.thisType) =&gt;
        true
      case (ThisType(sym1), SingleType(pre2, sym2))
      if (sym2.isModule &amp;&amp;
          sym2.moduleClass == sym1 &amp;&amp;
          pre2 =:= sym1.owner.thisType) =&gt;
        true
*/
      case (ConstantType(value1), ConstantType(value2)) =&gt;
        value1 == value2
      case (TypeRef(pre1, sym1, args1), TypeRef(pre2, sym2, args2)) =&gt;
        equalSymsAndPrefixes(sym1, pre1, sym2, pre2) &amp;&amp;
        ((tp1.isHigherKinded &amp;&amp; tp2.isHigherKinded &amp;&amp; tp1.normalize =:= tp2.normalize) ||
         isSameTypes(args1, args2))
         // @M! normalize reduces higher-kinded case to PolyType's
      case (RefinedType(parents1, ref1), RefinedType(parents2, ref2)) =&gt;
        def isSubScope(s1: Scope, s2: Scope): Boolean = s2.toList.forall {
          sym2 =&gt;
            var e1 = s1.lookupEntry(sym2.name)
            (e1 ne null) &amp;&amp; {
              val substSym = sym2.info.substThis(sym2.owner, e1.sym.owner.thisType)
              var isEqual = false
              while (!isEqual &amp;&amp; (e1 ne null)) {
                isEqual = e1.sym.info =:= substSym
                e1 = s1.lookupNextEntry(e1)
              }
              isEqual
            }
        }
        //Console.println(&quot;is same? &quot; + tp1 + &quot; &quot; + tp2 + &quot; &quot; + tp1.typeSymbol.owner + &quot; &quot; + tp2.typeSymbol.owner)//DEBUG
        isSameTypes(parents1, parents2) &amp;&amp; isSubScope(ref1, ref2) &amp;&amp; isSubScope(ref2, ref1)
      case (MethodType(params1, res1), MethodType(params2, res2)) =&gt;
        // new dependent types: probably fix this, use substSym as done for PolyType
        (isSameTypes(tp1.paramTypes, tp2.paramTypes) &amp;&amp;
         res1 =:= res2 &amp;&amp;
         tp1.isImplicit == tp2.isImplicit)
      case (PolyType(tparams1, res1), PolyType(tparams2, res2)) =&gt;
        // assert((tparams1 map (_.typeParams.length)) == (tparams2 map (_.typeParams.length)))
        (tparams1.length == tparams2.length) &amp;&amp; (tparams1 corresponds tparams2)(_.info =:= _.info.substSym(tparams2, tparams1)) &amp;&amp; // @M looks like it might suffer from same problem as #2210
          res1 =:= res2.substSym(tparams2, tparams1)
      case (ExistentialType(tparams1, res1), ExistentialType(tparams2, res2)) =&gt;
        (tparams1.length == tparams2.length) &amp;&amp; (tparams1 corresponds tparams2)(_.info =:= _.info.substSym(tparams2, tparams1)) &amp;&amp; // @M looks like it might suffer from same problem as #2210
          res1 =:= res2.substSym(tparams2, tparams1)
      case (TypeBounds(lo1, hi1), TypeBounds(lo2, hi2)) =&gt;
        lo1 =:= lo2 &amp;&amp; hi1 =:= hi2
      case (BoundedWildcardType(bounds), _) =&gt;
        bounds containsType tp2
      case (_, BoundedWildcardType(bounds)) =&gt;
        bounds containsType tp1
      case (tv @ TypeVar(_,_), tp) =&gt;
        tv.registerTypeEquality(tp, true)
      case (tp, tv @ TypeVar(_,_)) =&gt;
        tv.registerTypeEquality(tp, false)
      case (AnnotatedType(_,_,_), _) =&gt;
        annotationsConform(tp1, tp2) &amp;&amp; annotationsConform(tp2, tp1) &amp;&amp; tp1.withoutAnnotations =:= tp2.withoutAnnotations
      case (_, AnnotatedType(_,_,_)) =&gt;
        annotationsConform(tp1, tp2) &amp;&amp; annotationsConform(tp2, tp1) &amp;&amp; tp1.withoutAnnotations =:= tp2.withoutAnnotations
      case (_: SingletonType, _: SingletonType) =&gt;
        var origin1 = tp1
        while (origin1.underlying.isInstanceOf[SingletonType]) {
          assert(origin1 ne origin1.underlying, origin1)
          origin1 = origin1.underlying
        }
        var origin2 = tp2
        while (origin2.underlying.isInstanceOf[SingletonType]) {
          assert(origin2 ne origin2.underlying, origin2)
          origin2 = origin2.underlying
        }
        ((origin1 ne tp1) || (origin2 ne tp2)) &amp;&amp; (origin1 =:= origin2)
      case _ =&gt;
        false
    }) || {
      val tp1n = normalizePlus(tp1)
      val tp2n = normalizePlus(tp2)
      ((tp1n ne tp1) || (tp2n ne tp2)) &amp;&amp; isSameType(tp1n, tp2n)
    }
  }
*/
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="441499">isSameType1</a><span class="delimiter">(</span><a title="Types.this.Type" id="529342">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="529343">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
    <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#529342" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#529343" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
        <span class="delimiter">(</span><a href="#529342" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516388" title="Types.this.ErrorType.type">ErrorType</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#529342" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516414" title="Types.this.WildcardType.type">WildcardType</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
        <span class="delimiter">(</span><a href="#529343" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516388" title="Types.this.ErrorType.type">ErrorType</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#529343" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516414" title="Types.this.WildcardType.type">WildcardType</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#529342" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#529343" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#529342" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516520" title="Types.this.NoPrefix.type">NoPrefix</a><span class="delimiter">)</span>
      <a href="#529343" title="Types.this.Type">tp2</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a>
    <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#529343" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516520" title="Types.this.NoPrefix.type">NoPrefix</a><span class="delimiter">)</span>
      <a href="#529342" title="Types.this.Type">tp1</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <a href="#441500" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType2</a><span class="delimiter">(</span><a href="#529342" title="Types.this.Type">tp1</a>, <a href="#529343" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="529418">tp1n</a> = <a href="#441498" title="(tp: Types.this.Type)Types.this.Type">normalizePlus</a><span class="delimiter">(</span><a href="#529342" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="529419">tp2n</a> = <a href="#441498" title="(tp: Types.this.Type)Types.this.Type">normalizePlus</a><span class="delimiter">(</span><a href="#529343" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><span class="delimiter">(</span><a href="#529418" title="Types.this.Type">tp1n</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#529342" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#529419" title="Types.this.Type">tp2n</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#529343" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441495" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a><span class="delimiter">(</span><a href="#529418" title="Types.this.Type">tp1n</a>, <a href="#529419" title="Types.this.Type">tp2n</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="441500">isSameType2</a><span class="delimiter">(</span><a title="Types.this.Type" id="529415">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="529416">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
    <a href="#529415" title="Types.this.Type">tp1</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#529691" title="Unit" id="529708">tr1</a>: TypeRef =&gt;
        <a href="#529714" title="(x: Unit)Unit">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#529464" title="Unit" id="529467">tr2</a>: TypeRef =&gt;
            <a href="#529469" title="(x: Unit)Unit" class="keyword">return</a> <span class="delimiter">(</span><a href="#441494" title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean">equalSymsAndPrefixes</a><span class="delimiter">(</span>tr1.<a href="#448176" title="=&gt; Types.this.Symbol">sym</a>, tr1.<a href="#448175" title="=&gt; Types.this.Type">pre</a>, tr2.<a href="#448176" title="=&gt; Types.this.Symbol">sym</a>, tr2.<a href="#448175" title="=&gt; Types.this.Type">pre</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
              <span class="delimiter">(</span><span class="delimiter">(</span><a href="#529415" title="Types.this.Type">tp1</a>.<a href="#441972" title="=&gt; Boolean">isHigherKinded</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#529416" title="Types.this.Type">tp2</a>.<a href="#441972" title="=&gt; Boolean">isHigherKinded</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#529415" title="Types.this.Type">tp1</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#529416" title="Types.this.Type">tp2</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
               <a href="#441501" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span>tr1.<a href="#448177" title="=&gt; List[Types.this.Type]">args</a>, tr2.<a href="#448177" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
               <span class="delimiter">(</span><a href="../../Tuple2.scala.html#63804" title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</a>tr1.<a href="#448175" title="=&gt; Types.this.Type">pre</a>, tr2.<a href="#448175" title="=&gt; Types.this.Type">pre</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
                 <span class="keyword">case</span> <span class="delimiter">(</span>tv @ <a href="#470205" title="Option[(Types.this.Type, Types.this.TypeConstraint)]" id="529459">TypeVar</a><a href="#529458" title="Boolean" id="529447" class="delimiter">(</a>_,_<span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; tv.<a href="#470184" title="(sym: Types.this.Symbol, tp: Types.this.Type)Boolean">registerTypeSelection</a><a href="#529455" title="(x: Boolean)Boolean" class="delimiter">(</a>tr1.<a href="#448176" title="=&gt; Types.this.Symbol">sym</a>, tr2<span class="delimiter">)</span>
                 <span class="keyword">case</span> <span class="delimiter">(</span>_, tv @ <a href="#470205" title="Option[(Types.this.Type, Types.this.TypeConstraint)]" id="529461">TypeVar</a><a href="#529460" title="Boolean" id="529453" class="delimiter">(</a>_,_<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; tv.<a href="#470184" title="(sym: Types.this.Symbol, tp: Types.this.Type)Boolean">registerTypeSelection</a><a href="#529455" title="(x: Boolean)Boolean" class="delimiter">(</a>tr2.<a href="#448176" title="=&gt; Types.this.Symbol">sym</a>, tr1<span class="delimiter">)</span>
                 <span class="keyword">case</span> _ =&gt; <a href="#529455" title="(x: Boolean)Boolean" class="keyword">false</a>
               <span class="delimiter">}</span><span class="delimiter">)</span>
          <span class="keyword">case</span> _: SingleType =&gt;
            <a href="#529469" title="(x: Unit)Unit" class="keyword">return</a> <a href="#441500" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType2</a><span class="delimiter">(</span><a href="#529416" title="Types.this.Type">tp2</a>, <a href="#529415" title="Types.this.Type">tp1</a><span class="delimiter">)</span>  // put singleton type on the left, caught below
          <span class="keyword">case</span> _ =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a href="#529691" title="Unit" id="529709">tt1</a>: ThisType =&gt;
        <a href="#529714" title="(x: Unit)Unit">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#529482" title="Unit" id="529484">tt2</a>: ThisType =&gt;
            <a href="#529485" title="(x: Unit)Unit" class="keyword">if</a> <span class="delimiter">(</span>tt1.<a href="#461389" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> tt2.<a href="#461389" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> _ =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a href="#529691" title="Unit" id="529710">st1</a>: SingleType =&gt;
        <a href="#529714" title="(x: Unit)Unit">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#529495" title="Unit" id="529501">st2</a>: SingleType =&gt;
            <a href="#529503" title="(x: Unit)Unit" class="keyword">if</a> <span class="delimiter">(</span><a href="#441494" title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean">equalSymsAndPrefixes</a><span class="delimiter">(</span>st1.<a href="#461464" title="=&gt; Types.this.Symbol">sym</a>, st1.<a href="#461463" title="=&gt; Types.this.Type">pre</a>, st2.<a href="#461464" title="=&gt; Types.this.Symbol">sym</a>, st2.<a href="#461463" title="=&gt; Types.this.Type">pre</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> TypeRef<a href="#529495" title="Unit" id="529499" class="delimiter">(</a>pre2, sym2, <a href="../../collection/immutable/List.scala.html#11552" title="Unit" id="529502">Nil</a><span class="delimiter">)</span> =&gt;
            <a href="#529503" title="(x: Unit)Unit" class="keyword">if</a> <span class="delimiter">(</span>sym2.<a href="Symbols.scala.html#443245" title="=&gt; Boolean">isModuleClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441494" title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean">equalSymsAndPrefixes</a><span class="delimiter">(</span>st1.<a href="#461464" title="=&gt; Types.this.Symbol">sym</a>, st1.<a href="#461463" title="=&gt; Types.this.Type">pre</a>, sym2.<a href="Symbols.scala.html#443490" title="=&gt; Types.this.Symbol">sourceModule</a>, pre2<span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> _ =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a href="#529691" title="Unit" id="529711">ct1</a>: ConstantType =&gt;
        <a href="#529714" title="(x: Unit)Unit">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#529519" title="Unit" id="529521">ct2</a>: ConstantType =&gt;
            <a href="#529522" title="(x: Unit)Unit" class="keyword">return</a> <span class="delimiter">(</span>ct1.<a href="#460829" title="=&gt; Types.this.Constant">value</a> <span title="(x$1: AnyRef)Boolean">==</span> ct2.<a href="#460829" title="=&gt; Types.this.Constant">value</a><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a href="#529691" title="Unit" id="529712">rt1</a>: RefinedType =&gt;
        <a href="#529714" title="(x: Unit)Unit">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#529557" title="Unit" id="529559">rt2</a>: RefinedType =&gt; //
            <span class="keyword">def</span> <a title="(s1: Types.this.Scope, s2: Types.this.Scope)Boolean" id="529529">isSubScope</a><span class="delimiter">(</span><a title="Types.this.Scope" id="529530">s1</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a>, <a title="Types.this.Scope" id="529531">s2</a>: <a href="Scopes.scala.html#441628" title="Types.this.Scope">Scope</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#529531" title="Types.this.Scope">s2</a>.<a href="Scopes.scala.html#447344" title="=&gt; List[Types.this.Symbol]">toList</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</a> <span class="delimiter">{</span>
              <a title="Types.this.Symbol" id="529540">sym2</a> =&gt;
                <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="529541">e1</a> = <a href="#529530" title="Types.this.Scope">s1</a>.<a href="Scopes.scala.html#447342" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#529540" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym2.NameType">name</a><span class="delimiter">)</span>
                <span class="delimiter">(</span><a href="#529541" title="Types.this.ScopeEntry">e1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
                  <span class="keyword">val</span> <a title="Types.this.Type" id="529543">substSym</a> = <a href="#529540" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442044" title="(from: Types.this.Symbol, to: Types.this.Symbol)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#529540" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>, <a href="#529541" title="Types.this.ScopeEntry">e1</a>.<a href="Scopes.scala.html#457240" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
                  <span class="keyword">var</span> <a title="Boolean" id="529544">isEqual</a> = <span title="Boolean(false)" class="keyword">false</span>
                  <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#529544" title="Boolean">isEqual</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#529541" title="Types.this.ScopeEntry">e1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#529545" title="()Unit" class="delimiter">{</a>
                    <a href="#529544" title="Boolean">isEqual</a> = <a href="#529541" title="Types.this.ScopeEntry">e1</a>.<a href="Scopes.scala.html#457240" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#529543" title="Types.this.Type">substSym</a>
                    <a href="#529541" title="Types.this.ScopeEntry">e1</a> = <a href="#529530" title="Types.this.Scope">s1</a>.<a href="Scopes.scala.html#447343" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a><span class="delimiter">(</span><a href="#529541" title="Types.this.ScopeEntry">e1</a><span class="delimiter">)</span>
                  <span class="delimiter">}</span>
                  <a href="#529544" title="Boolean">isEqual</a>
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            //Console.println(&quot;is same? &quot; + tp1 + &quot; &quot; + tp2 + &quot; &quot; + tp1.typeSymbol.owner + &quot; &quot; + tp2.typeSymbol.owner)//DEBUG
            <span title="Nothing" class="keyword">return</span> <a href="#441501" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span>rt1.<a href="#469850" title="=&gt; List[Types.this.Type]">parents</a>, rt2.<a href="#469850" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Scope" id="529554">decls1</a> = rt1.<a href="#469851" title="=&gt; Types.this.Scope">decls</a>
              <span class="keyword">val</span> <a title="Types.this.Scope" id="529555">decls2</a> = rt2.<a href="#469851" title="=&gt; Types.this.Scope">decls</a>
              <a href="#529529" title="(s1: Types.this.Scope, s2: Types.this.Scope)Boolean">isSubScope</a><span class="delimiter">(</span><a href="#529554" title="Types.this.Scope">decls1</a>, <a href="#529555" title="Types.this.Scope">decls2</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#529529" title="(s1: Types.this.Scope, s2: Types.this.Scope)Boolean">isSubScope</a><span class="delimiter">(</span><a href="#529555" title="Types.this.Scope">decls2</a>, <a href="#529554" title="Types.this.Scope">decls1</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> _ =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a href="#529691" title="Unit" id="529713">mt1</a>: MethodType =&gt;
        <a href="#529714" title="(x: Unit)Unit">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#529578" title="Unit" id="529580">mt2</a>: MethodType =&gt;
            <a href="#529581" title="(x: Unit)Unit" class="keyword">return</a> <a href="#441501" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span>mt1.<a href="#448363" title="=&gt; List[Types.this.Type]">paramTypes</a>, mt2.<a href="#448363" title="=&gt; List[Types.this.Type]">paramTypes</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
              mt1.<a href="#453587" title="=&gt; Types.this.Type">resultType</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> mt2.<a href="#453587" title="=&gt; Types.this.Type">resultType</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>mt2.<a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a>, mt1.<a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
              mt1.<a href="#448359" title="=&gt; Boolean">isImplicit</a> <a href="../../Boolean.scala.html#58722" title="(x: Boolean)Boolean">==</a> mt2.<a href="#448359" title="=&gt; Boolean">isImplicit</a>
          // note: no case NullaryMethodType(restpe) =&gt; return mt1.params.isEmpty &amp;&amp; mt1.resultType =:= restpe
          <span class="keyword">case</span> _ =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> NullaryMethodType<a href="#529691" title="Unit" id="529699" class="delimiter">(</a>restpe1<span class="delimiter">)</span> =&gt;
        <a href="#529714" title="(x: Unit)Unit">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          // note: no case mt2: MethodType =&gt; return mt2.params.isEmpty &amp;&amp; restpe  =:= mt2.resultType
          <span class="keyword">case</span> NullaryMethodType<a href="#529590" title="Unit" id="529592" class="delimiter">(</a>restpe2<span class="delimiter">)</span> =&gt;
            <a href="#529593" title="(x: Unit)Unit" class="keyword">return</a> restpe1 <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> restpe2
          <span class="keyword">case</span> _ =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> PolyType<a href="#529691" title="Unit" id="529701" class="delimiter">(</a>tparams1, res1<span class="delimiter">)</span> =&gt;
        <a href="#529714" title="(x: Unit)Unit">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> PolyType<a href="#529628" title="Unit" id="529630" class="delimiter">(</a>tparams2, res2<span class="delimiter">)</span> =&gt;
//            assert((tparams1 map (_.typeParams.length)) == (tparams2 map (_.typeParams.length)))
              // @M looks like it might suffer from same problem as #2210
              <a href="#529631" title="(x: Unit)Unit" class="keyword">return</a> <span class="delimiter">(</span>
                <span class="delimiter">(</span><a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span>tparams1, tparams2<span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> // corresponds does not check length of two sequences before checking the predicate
                <span class="delimiter">(</span>tparams1 <a href="../../collection/LinearSeqLike.scala.html#76110" title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</a> tparams2<span class="delimiter">)</span><span class="delimiter">(</span><a href="#529622" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#529623" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>tparams2, tparams1<span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
                res1 <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> res2.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>tparams2, tparams1<span class="delimiter">)</span>
              <span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> ExistentialType<a href="#529691" title="Unit" id="529703" class="delimiter">(</a>tparams1, res1<span class="delimiter">)</span> =&gt;
        <a href="#529714" title="(x: Unit)Unit">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> ExistentialType<a href="#529666" title="Unit" id="529668" class="delimiter">(</a>tparams2, res2<span class="delimiter">)</span> =&gt;
            // @M looks like it might suffer from same problem as #2210
            <a href="#529669" title="(x: Unit)Unit" class="keyword">return</a> <span class="delimiter">(</span>
              // corresponds does not check length of two sequences before checking the predicate -- faster &amp; needed to avoid crasher in #2956
              <a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span>tparams1, tparams2<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
              <span class="delimiter">(</span>tparams1 <a href="../../collection/LinearSeqLike.scala.html#76110" title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</a> tparams2<span class="delimiter">)</span><span class="delimiter">(</span><a href="#529660" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#529661" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>tparams2, tparams1<span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
              res1 <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> res2.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>tparams2, tparams1<span class="delimiter">)</span>
            <span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> TypeBounds<a href="#529691" title="Unit" id="529705" class="delimiter">(</a>lo1, hi1<span class="delimiter">)</span> =&gt;
        <a href="#529714" title="(x: Unit)Unit">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> TypeBounds<a href="#529681" title="Unit" id="529683" class="delimiter">(</a>lo2, hi2<span class="delimiter">)</span> =&gt;
            <a href="#529684" title="(x: Unit)Unit" class="keyword">return</a> lo1 <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> lo2 <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> hi1 <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> hi2
          <span class="keyword">case</span> _ =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> BoundedWildcardType<a href="#529691" title="Unit" id="529707" class="delimiter">(</a>bounds<span class="delimiter">)</span> =&gt;
        <a href="#529714" title="(x: Unit)Unit" class="keyword">return</a> bounds <a href="#448306" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#529416" title="Types.this.Type">tp2</a>
      <span class="keyword">case</span> _ =&gt;
    <span class="delimiter">}</span>
    <a href="#529416" title="Types.this.Type">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> BoundedWildcardType<a href="#529731" title="Unit" id="529733" class="delimiter">(</a>bounds<span class="delimiter">)</span> =&gt;
        <a href="#529734" title="(x: Unit)Unit" class="keyword">return</a> bounds <a href="#448306" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#529415" title="Types.this.Type">tp1</a>
      <span class="keyword">case</span> _ =&gt;
    <span class="delimiter">}</span>
    <a href="#529415" title="Types.this.Type">tp1</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> tv @ <a href="#470205" title="Option[(Types.this.Type, Types.this.TypeConstraint)]" id="529752">TypeVar</a><a href="#529742" title="Unit" id="529746" class="delimiter">(</a>_,_<span class="delimiter">)</span> =&gt;
        <a href="#529748" title="(x: Unit)Unit" class="keyword">return</a> tv.<a href="#470183" title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean">registerTypeEquality</a><span class="delimiter">(</span><a href="#529416" title="Types.this.Type">tp2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
    <span class="delimiter">}</span>
    <a href="#529416" title="Types.this.Type">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> tv @ <a href="#470205" title="Option[(Types.this.Type, Types.this.TypeConstraint)]" id="529767">TypeVar</a><a href="#529757" title="Unit" id="529761" class="delimiter">(</a>_,_<span class="delimiter">)</span> =&gt;
        <a href="#529763" title="(x: Unit)Unit" class="keyword">return</a> tv.<a href="#470183" title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean">registerTypeEquality</a><span class="delimiter">(</span><a href="#529415" title="Types.this.Type">tp1</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt;
    <span class="delimiter">}</span>
    <a href="#529415" title="Types.this.Type">tp1</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> _: AnnotatedType =&gt;
        <a href="#529777" title="(x: Unit)Unit" class="keyword">return</a> <a href="AnnotationCheckers.scala.html#440538" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#529415" title="Types.this.Type">tp1</a>, <a href="#529416" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="AnnotationCheckers.scala.html#440538" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#529416" title="Types.this.Type">tp2</a>, <a href="#529415" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#529415" title="Types.this.Type">tp1</a>.<a href="#442086" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#529416" title="Types.this.Type">tp2</a>.<a href="#442086" title="=&gt; Types.this.Type">withoutAnnotations</a>
      <span class="keyword">case</span> _ =&gt;
    <span class="delimiter">}</span>
    <a href="#529416" title="Types.this.Type">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> _: AnnotatedType =&gt;
        <a href="#529788" title="(x: Unit)Unit" class="keyword">return</a> <a href="AnnotationCheckers.scala.html#440538" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#529415" title="Types.this.Type">tp1</a>, <a href="#529416" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="AnnotationCheckers.scala.html#440538" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#529416" title="Types.this.Type">tp2</a>, <a href="#529415" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#529415" title="Types.this.Type">tp1</a>.<a href="#442086" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#529416" title="Types.this.Type">tp2</a>.<a href="#442086" title="=&gt; Types.this.Type">withoutAnnotations</a>
      <span class="keyword">case</span> _ =&gt;
    <span class="delimiter">}</span>
    <a href="#529415" title="Types.this.Type">tp1</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> _: SingletonType =&gt;
        <a href="#529818" title="(x: Boolean)Boolean">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> _: SingletonType =&gt;
            @inline <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="529793">chaseDealiasedUnderlying</a><span class="delimiter">(</span><a title="Types.this.Type" id="529796">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
              <span class="keyword">var</span> <a title="Types.this.Type" id="529797">origin</a> = <a href="#529796" title="Types.this.Type">tp</a>
              <span class="keyword">var</span> <a title="Types.this.Type" id="529798">next</a> = <a href="#529797" title="Types.this.Type">origin</a>.<a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442018" title="=&gt; Types.this.Type">dealias</a>
              <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#529798" title="Types.this.Type">next</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#441248" title="Types.this.SingletonType">SingletonType</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#529799" title="()Unit" class="delimiter">{</a>
                <a href="../../Predef.scala.html#8460" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#529797" title="Types.this.Type">origin</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#529798" title="Types.this.Type">next</a>, <a href="#529797" title="Types.this.Type">origin</a><span class="delimiter">)</span>
                <a href="#529797" title="Types.this.Type">origin</a> = <a href="#529798" title="Types.this.Type">next</a>
                <a href="#529798" title="Types.this.Type">next</a> = <a href="#529797" title="Types.this.Type">origin</a>.<a href="#441989" title="=&gt; Types.this.Type">underlying</a>.<a href="#442018" title="=&gt; Types.this.Type">dealias</a>
              <span class="delimiter">}</span>
              <a href="#529797" title="Types.this.Type">origin</a>
            <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="529794">origin1</a> = <a href="#529793" title="(tp: Types.this.Type)Types.this.Type">chaseDealiasedUnderlying</a><span class="delimiter">(</span><a href="#529415" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="529795">origin2</a> = <a href="#529793" title="(tp: Types.this.Type)Types.this.Type">chaseDealiasedUnderlying</a><span class="delimiter">(</span><a href="#529416" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
            <span class="delimiter">(</span><span class="delimiter">(</span><a href="#529794" title="Types.this.Type">origin1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#529415" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#529795" title="Types.this.Type">origin2</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#529416" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#529794" title="Types.this.Type">origin1</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#529795" title="Types.this.Type">origin2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
            <a href="#529809" title="(x: Boolean)Boolean" class="keyword">false</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#529818" title="(x: Boolean)Boolean" class="keyword">false</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Are `tps1` and `tps2` lists of pairwise equivalent types? */
  <span class="keyword">def</span> <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean" id="441501">isSameTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="529424">tps1</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="529425">tps2</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">(</span><a href="#529424" title="List[Types.this.Type]">tps1</a> <a href="../../collection/LinearSeqLike.scala.html#76110" title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.Type, Types.this.Type) =&gt; Boolean)Boolean">corresponds</a> <a href="#529425" title="List[Types.this.Type]">tps2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#529841" title="Types.this.Type">_</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#529842" title="Types.this.Type">_</a><span class="delimiter">)</span>

  /** True if two lists have the same length.  Since calling length on linear sequences
   *  is O(n), it is an inadvisable way to test length equality.
   */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(xs1: List[_], xs2: List[_])Boolean" id="441502">sameLength</a><span class="delimiter">(</span><a title="List[_]" id="461670">xs1</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[_]">List</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="List[_]" id="461671">xs2</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[_]">List</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#441503" title="(xs1: List[_], xs2: List[_])Int">compareLengths</a><span class="delimiter">(</span><a href="#461670" title="List[_]">xs1</a>, <a href="#461671" title="List[_]">xs2</a><span class="delimiter">)</span> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span>
  @tailrec <span class="keyword">final</span> <span class="keyword">def</span> <a title="(xs1: List[_], xs2: List[_])Int" id="441503">compareLengths</a><span class="delimiter">(</span><a title="List[_]" id="461674">xs1</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[_]">List</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="List[_]" id="461675">xs2</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[_]">List</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Int.scala.html#508" title="Int">Int</a> =
    <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#461674" title="List[_]">xs1</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#461675" title="List[_]">xs2</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> <span class="keyword">else</span> -<span title="Int(-1)" class="int">1</span> <span class="delimiter">}</span>
    <span class="keyword">else</span> <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#461675" title="List[_]">xs2</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span title="Int(1)" class="int">1</span>
    <span class="keyword">else</span> <a href="#441503" title="(xs1: List[_], xs2: List[_])Int">compareLengths</a><span class="delimiter">(</span><a href="#461674" title="List[_]">xs1</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[_$3]">tail</a>, <a href="#461675" title="List[_]">xs2</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[_$4]">tail</a><span class="delimiter">)</span>

  /** Again avoiding calling length, but the lengthCompare interface is clunky.
   */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(xs: List[_], len: Int)Boolean" id="441504">hasLength</a><span class="delimiter">(</span><a title="List[_]" id="519235">xs</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[_]">List</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Int" id="519236">len</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span> = <a href="#519235" title="List[_]">xs</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76195" title="(len: Int)Int">lengthCompare</a><span class="delimiter">(</span><a href="#519236" title="Int">len</a><span class="delimiter">)</span> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.SubTypePair]" id="441505">pendingSubTypes</a> = <a href="../../collection/mutable/HashSet.scala.html#141566" title="()scala.collection.mutable.HashSet[Types.this.SubTypePair]" class="keyword">new</a> mutable.<a href="../../collection/mutable/HashSet.scala.html#13456" title="scala.collection.mutable.HashSet[Types.this.SubTypePair]">HashSet</a><span class="delimiter">[</span>SubTypePair<span class="delimiter">]</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="441508">basetypeRecursions</a>: <a href="../../Int.scala.html#508" title="Int">Int</a> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.Type]" id="441510">pendingBaseTypes</a> = <a href="../../collection/mutable/HashSet.scala.html#141566" title="()scala.collection.mutable.HashSet[Types.this.Type]" class="keyword">new</a> mutable.<a href="../../collection/mutable/HashSet.scala.html#13456" title="scala.collection.mutable.HashSet[Types.this.Type]">HashSet</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="441512">isSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="459260">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="459261">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#441513" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#459260" title="Types.this.Type">tp1</a>, <a href="#459261" title="Types.this.Type">tp2</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean" id="441513">isSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="459253">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="459254">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Int" id="459255">depth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="#441490" title="(x$1: Int)Unit">subsametypeRecursions</a> <a href="../../Int.scala.html#57948" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>

    <a href="#441231" title="=&gt; Types.this.UndoLog">undoLog</a> <a href="#514541" title="(block: =&gt; Boolean)Boolean">undoUnless</a> <span class="delimiter">{</span> // if subtype test fails, it should not affect constraints on typevars
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#441490" title="=&gt; Int">subsametypeRecursions</a> <a href="../../Int.scala.html#57926" title="(x: Int)Boolean">&gt;=</a> <span title="Int(50)">LogPendingSubTypesThreshold</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.SubTypePair" id="529871">p</a> = <span title="Types.this.SubTypePair" class="keyword">new</span> <a href="#441483" title="Types.this.SubTypePair">SubTypePair</a><span class="delimiter">(</span><a href="#459253" title="Types.this.Type">tp1</a>, <a href="#459254" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="../../collection/GenSetLike.scala.html#65156" title="(elem: Types.this.SubTypePair)Boolean">pendingSubTypes</a><span class="delimiter">(</span><a href="#529871" title="Types.this.SubTypePair">p</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">else</span>
          <span class="keyword">try</span> <span class="delimiter">{</span>
            <a href="#441505" title="=&gt; scala.collection.mutable.HashSet[Types.this.SubTypePair]">pendingSubTypes</a> <a href="../../collection/mutable/HashSet.scala.html#141570" title="(elem: Types.this.SubTypePair)Types.this.pendingSubTypes.type">+=</a> <a href="#529871" title="Types.this.SubTypePair">p</a>
            <a href="#441523" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType2</a><span class="delimiter">(</span><a href="#459253" title="Types.this.Type">tp1</a>, <a href="#459254" title="Types.this.Type">tp2</a>, <a href="#459255" title="Int">depth</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            <a href="#441505" title="=&gt; scala.collection.mutable.HashSet[Types.this.SubTypePair]">pendingSubTypes</a> <a href="../../collection/mutable/HashSet.scala.html#141571" title="(elem: Types.this.SubTypePair)Types.this.pendingSubTypes.type">-=</a> <a href="#529871" title="Types.this.SubTypePair">p</a>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#441523" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType2</a><span class="delimiter">(</span><a href="#459253" title="Types.this.Type">tp1</a>, <a href="#459254" title="Types.this.Type">tp2</a>, <a href="#459255" title="Int">depth</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#441490" title="(x$1: Int)Unit">subsametypeRecursions</a> <a href="../../Int.scala.html#57955" title="(x: Int)Int">-=</a> <span title="Int(1)" class="int">1</span>
    // XXX AM TODO: figure out when it is safe and needed to clear the log -- the commented approach below is too eager (it breaks #3281, #3866)
    // it doesn't help to keep separate recursion counts for the three methods that now share it
    // if (subsametypeRecursions == 0) undoLog.clear()
  <span class="delimiter">}</span>

  /** Does this type have a prefix that begins with a type variable,
   *  or is it a refinement type? For type prefixes that fulfil this condition,
   *  type selections with the same name of equal (wrt) =:= prefixes are
   *  considered equal wrt =:=
   */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="441514">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a title="Types.this.Type" id="529302">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#529302" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> SingleType<a href="#529922" title="Boolean" id="529924" class="delimiter">(</a>pre, sym<span class="delimiter">)</span> =&gt;
      <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span>sym <a href="Symbols.scala.html#443303" title="(mask: Long)Boolean">hasFlag</a> <span title="Long(16384L)">PACKAGE</span><span class="delimiter">)</span> <a href="#529933" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441514" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span>pre<span class="delimiter">)</span>
    <span class="keyword">case</span> tv@<a href="#470205" title="Option[(Types.this.Type, Types.this.TypeConstraint)]" id="529939">TypeVar</a><a href="#529922" title="Boolean" id="529927" class="delimiter">(</a>_, constr<span class="delimiter">)</span> =&gt;
      <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a>tv.<a href="#470167" title="=&gt; Boolean">instValid</a> <a href="#529933" title="(x: Boolean)Boolean">||</a> <a href="#441514" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span>constr.<a href="#470266" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
    <span class="keyword">case</span> RefinedType<a href="#529922" title="Boolean" id="529932" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt;
      <a href="#529933" title="(x: Boolean)Boolean" class="keyword">true</a>
    <span class="keyword">case</span> _ =&gt;
      <a href="#529933" title="(x: Boolean)Boolean" class="keyword">false</a>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="441515">instTypeVar</a><span class="delimiter">(</span><a title="Types.this.Type" id="529942">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#529942" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> TypeRef<a href="#529952" title="Types.this.Type" id="529954" class="delimiter">(</a>pre, sym, args<span class="delimiter">)</span> =&gt;
      <a href="#441372" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><a href="#529961" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#529942" title="Types.this.Type">tp</a>, <a href="#441515" title="(tp: Types.this.Type)Types.this.Type">instTypeVar</a><span class="delimiter">(</span>pre<span class="delimiter">)</span>, sym, args<span class="delimiter">)</span>
    <span class="keyword">case</span> SingleType<a href="#529952" title="Types.this.Type" id="529956" class="delimiter">(</a>pre, sym<span class="delimiter">)</span> =&gt;
      <a href="#441367" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><a href="#529961" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#441515" title="(tp: Types.this.Type)Types.this.Type">instTypeVar</a><span class="delimiter">(</span>pre<span class="delimiter">)</span>, sym<span class="delimiter">)</span>
    <span class="keyword">case</span> <a href="#470205" title="Option[(Types.this.Type, Types.this.TypeConstraint)]" id="529968">TypeVar</a><a href="#529952" title="Types.this.Type" id="529959" class="delimiter">(</a>_, constr<span class="delimiter">)</span> =&gt;
      <a href="#441515" title="(tp: Types.this.Type)Types.this.Type">instTypeVar</a><a href="#529961" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>constr.<a href="#470266" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
    <span class="keyword">case</span> _ =&gt;
      <a href="#529961" title="(x: Types.this.Type)Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="441516">isErrorOrWildcard</a><span class="delimiter">(</span><a title="Types.this.Type" id="529970">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#529970" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516388" title="Types.this.ErrorType.type">ErrorType</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#529970" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516414" title="Types.this.WildcardType.type">WildcardType</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="441517">isSingleType</a><span class="delimiter">(</span><a title="Types.this.Type" id="529973">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#529973" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> ThisType<a href="#529977" title="Boolean" id="529980" class="delimiter">(</a>_<span class="delimiter">)</span> | SuperType<a href="#529977" title="Boolean" id="529984" class="delimiter">(</a>_, _<span class="delimiter">)</span> | SingleType<a href="#529977" title="Boolean" id="529988" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt; <a href="#529989" title="(x: Boolean)Boolean" class="keyword">true</a>
    <span class="keyword">case</span> _ =&gt; <a href="#529989" title="(x: Boolean)Boolean" class="keyword">false</a>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="441518">isConstantType</a><span class="delimiter">(</span><a title="Types.this.Type" id="495658">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#495658" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> ConstantType<a href="#495662" title="Boolean" id="495665" class="delimiter">(</a>_<span class="delimiter">)</span> =&gt; <a href="#495666" title="(x: Boolean)Boolean" class="keyword">true</a>
    <span class="keyword">case</span> _ =&gt; <a href="#495666" title="(x: Boolean)Boolean" class="keyword">false</a>
  <span class="delimiter">}</span>

  // @assume tp1.isHigherKinded || tp2.isHigherKinded
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean" id="441519">isHKSubType0</a><span class="delimiter">(</span><a title="Types.this.Type" id="530000">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="530001">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Int" id="530002">depth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">(</span>
    <a href="#530000" title="Types.this.Type">tp1</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a>
    <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
    <a href="#530001" title="Types.this.Type">tp2</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a> // @M Any and Nothing are super-type resp. subtype of every well-kinded type
    <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> // @M! normalize reduces higher-kinded case to PolyType's
    <span class="delimiter">(</span><a href="../../Tuple2.scala.html#63804" title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</a><a href="#530000" title="Types.this.Type">tp1</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a>.<a href="#442086" title="=&gt; Types.this.Type">withoutAnnotations</a> , <a href="#530001" title="Types.this.Type">tp2</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a>.<a href="#442086" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>PolyType<a title="Boolean" id="530084" class="delimiter">(</a>tparams1, res1<span class="delimiter">)</span>, PolyType<a title="Boolean" id="530086" class="delimiter">(</a>tparams2, res2<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; // @assume tp1.isHigherKinded &amp;&amp; tp2.isHigherKinded (as they were both normalized to PolyType)
        <a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span>tparams1, tparams2<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span>tparams1.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Symbol">head</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#443282" title="=&gt; Boolean">isMethod</a><span class="delimiter">)</span> <span class="delimiter">{</span>  // fast-path: polymorphic method type -- type params cannot be captured
            <span class="delimiter">(</span>tparams1 <a href="../../collection/LinearSeqLike.scala.html#76110" title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</a> tparams2<span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="530050">p1</a>, <a title="Types.this.Symbol" id="530051">p2</a><span class="delimiter">)</span> =&gt; <a href="#530051" title="Types.this.Symbol">p2</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>tparams2, tparams1<span class="delimiter">)</span> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#530050" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
            res1 <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> res2.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>tparams2, tparams1<span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span> // normalized higher-kinded type
            //@M for an example of why we need to generate fresh symbols, see neg/tcpoly_ticket2101.scala
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="530055">tpsFresh</a> = <a href="Symbols.scala.html#441157" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span>tparams1<span class="delimiter">)</span>

            <span class="delimiter">(</span>tparams1 <a href="../../collection/LinearSeqLike.scala.html#76110" title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</a> tparams2<span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="530071">p1</a>, <a title="Types.this.Symbol" id="530072">p2</a><span class="delimiter">)</span> =&gt;
              <a href="#530072" title="Types.this.Symbol">p2</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>tparams2, <a href="#530055" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#530071" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>tparams1, <a href="#530055" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
            res1.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>tparams1, <a href="#530055" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> res2.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>tparams2, <a href="#530055" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span>

            //@M the forall in the previous test could be optimised to the following,
            // but not worth the extra complexity since it only shaves 1s from quick.comp
            //   (List.forall2(tpsFresh/*optimisation*/, tparams2)((p1, p2) =&gt;
            //   p2.info.substSym(tparams2, tpsFresh) &lt;:&lt; p1.info /*optimisation, == (p1 from tparams1).info.substSym(tparams1, tpsFresh)*/) &amp;&amp;
            // this optimisation holds because inlining cloneSymbols in `val tpsFresh = cloneSymbols(tparams1)` gives:
            // val tpsFresh = tparams1 map (_.cloneSymbol)
            // for (tpFresh &lt;- tpsFresh) tpFresh.setInfo(tpFresh.info.substSym(tparams1, tpsFresh))
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> <a href="#530089" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="AnnotationCheckers.scala.html#440538" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#530000" title="Types.this.Type">tp1</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a>, <a href="#530001" title="Types.this.Type">tp2</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#530089" title="(x: Boolean)Boolean" class="keyword">false</a> // @assume !tp1.isHigherKinded || !tp2.isHigherKinded
      // --&gt; thus, cannot be subtypes (Any/Nothing has already been checked)
    <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(t1: Types.this.Type, t2: Types.this.Type, variance: Int)Boolean" id="441520">isSubArg</a><span class="delimiter">(</span><a title="Types.this.Type" id="530094">t1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="530095">t2</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Int" id="530096">variance</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span> =
    <span class="delimiter">(</span><a href="#530096" title="Int">variance</a> <a href="../../Int.scala.html#57919" title="(x: Int)Boolean">&gt;</a> <span title="Int(0)" class="int">0</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#530095" title="Types.this.Type">t2</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#530094" title="Types.this.Type">t1</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#530096" title="Int">variance</a> <a href="../../Int.scala.html#57905" title="(x: Int)Boolean">&lt;</a> <span title="Int(0)" class="int">0</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#530094" title="Types.this.Type">t1</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#530095" title="Types.this.Type">t2</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean" id="441521">isSubArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="522764">tps1</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="522765">tps2</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="522766">tparams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> =
    <a href="util/Collections.scala.html#440638" title="(xs1: List[Types.this.Type], xs2: List[Types.this.Type], xs3: List[Int])(f: (Types.this.Type, Types.this.Type, Int) =&gt; Boolean)Boolean">corresponds3</a><span class="delimiter">(</span><a href="#522764" title="List[Types.this.Type]">tps1</a>, <a href="#522765" title="List[Types.this.Type]">tps2</a>, <a href="#522766" title="List[Types.this.Symbol]">tparams</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Int,List[Int]])List[Int]">map</a> <span class="delimiter">(</span><a href="#530141" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443377" title="=&gt; Int">variance</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#441520" title="(t1: Types.this.Type, t2: Types.this.Type, variance: Int)Boolean">isSubArg</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Types.this.Type" id="441522">differentOrNone</a><span class="delimiter">(</span><a title="Types.this.Type" id="530198">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="530199">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#530198" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#530199" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <a href="#516490" title="Types.this.NoType.type">NoType</a> <span class="keyword">else</span> <a href="#530198" title="Types.this.Type">tp1</a>

  /** Does type `tp1` conform to `tp2`? */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean" id="441523">isSubType2</a><span class="delimiter">(</span><a title="Types.this.Type" id="529896">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="529897">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Int" id="529898">depth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#529896" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#529897" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#441516" title="(tp: Types.this.Type)Boolean">isErrorOrWildcard</a><span class="delimiter">(</span><a href="#529896" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#441516" title="(tp: Types.this.Type)Boolean">isErrorOrWildcard</a><span class="delimiter">(</span><a href="#529897" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(true)" class="keyword">true</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#529896" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#529897" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(false)" class="keyword">false</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#529896" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516520" title="Types.this.NoPrefix.type">NoPrefix</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span><a href="#529897" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516520" title="Types.this.NoPrefix.type">NoPrefix</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#529897" title="Types.this.Type">tp2</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#529897" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#516520" title="Types.this.NoPrefix.type">NoPrefix</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#529896" title="Types.this.Type">tp1</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443287" title="=&gt; Boolean">isPackageClass</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#441517" title="(tp: Types.this.Type)Boolean">isSingleType</a><span class="delimiter">(</span><a href="#529896" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441517" title="(tp: Types.this.Type)Boolean">isSingleType</a><span class="delimiter">(</span><a href="#529897" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#441518" title="(tp: Types.this.Type)Boolean">isConstantType</a><span class="delimiter">(</span><a href="#529896" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441518" title="(tp: Types.this.Type)Boolean">isConstantType</a><span class="delimiter">(</span><a href="#529897" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#529896" title="Types.this.Type">tp1</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#529897" title="Types.this.Type">tp2</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#529896" title="Types.this.Type">tp1</a>.<a href="#441972" title="=&gt; Boolean">isHigherKinded</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#529897" title="Types.this.Type">tp2</a>.<a href="#441972" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#441519" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isHKSubType0</a><span class="delimiter">(</span><a href="#529896" title="Types.this.Type">tp1</a>, <a href="#529897" title="Types.this.Type">tp2</a>, <a href="#529898" title="Int">depth</a><span class="delimiter">)</span>

    /** First try, on the right:
     *   - unwrap Annotated types, BoundedWildcardTypes,
     *   - bind TypeVars  on the right, if lhs is not Annotated nor BoundedWildcard
     *   - handle common cases for first-kind TypeRefs on both sides as a fast path.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="530202">firstTry</a> = <a href="#529897" title="Types.this.Type">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      // fast path: two typerefs, none of them HK
      <span class="keyword">case</span> <a href="#530541" title="Boolean" id="530554">tr2</a>: TypeRef =&gt;
        <a href="#530555" title="(x: Boolean)Boolean">tp1</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#530505" title="Boolean" id="530507">tr1</a>: TypeRef =&gt;
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="530212">sym1</a> = tr1.<a href="#448176" title="=&gt; Types.this.Symbol">sym</a>
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="530213">sym2</a> = tr2.<a href="#448176" title="=&gt; Types.this.Symbol">sym</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="530214">pre1</a> = tr1.<a href="#448175" title="=&gt; Types.this.Type">pre</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="530215">pre2</a> = tr2.<a href="#448175" title="=&gt; Types.this.Type">pre</a>
            <span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#530212" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#530213" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> <a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#530214" title="Types.this.Type">pre1</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#530215" title="Types.this.Type">pre2</a>
               <span class="keyword">else</span> <span class="delimiter">(</span><a href="#530212" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym1.NameType">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#530213" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym2.NameType">name</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#530212" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443245" title="=&gt; Boolean">isModuleClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#530213" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443245" title="=&gt; Boolean">isModuleClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
                     <span class="delimiter">(</span><a href="#441492" title="(pre1: Types.this.Type, pre2: Types.this.Type)Boolean">isUnifiable</a><span class="delimiter">(</span><a href="#530214" title="Types.this.Type">pre1</a>, <a href="#530215" title="Types.this.Type">pre2</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#441493" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol, pre1: Types.this.Type, pre2: Types.this.Type)Boolean">isSameSpecializedSkolem</a><span class="delimiter">(</span><a href="#530212" title="Types.this.Symbol">sym1</a>, <a href="#530213" title="Types.this.Symbol">sym2</a>, <a href="#530214" title="Types.this.Type">pre1</a>, <a href="#530215" title="Types.this.Type">pre2</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
                    <a href="#441521" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean">isSubArgs</a><span class="delimiter">(</span>tr1.<a href="#448177" title="=&gt; List[Types.this.Type]">args</a>, tr2.<a href="#448177" title="=&gt; List[Types.this.Type]">args</a>, <a href="#530212" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span><span class="delimiter">)</span>
             <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
             <a href="#530213" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443231" title="=&gt; Boolean">isClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
               <span class="keyword">val</span> <a title="Types.this.Type" id="530226">base</a> = tr1 <a href="#442036" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a> <a href="#530213" title="Types.this.Symbol">sym2</a>
               <span class="delimiter">(</span><a href="#530226" title="Types.this.Type">base</a> <span title="(x$1: AnyRef)Boolean">ne</span> tr1<span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#530226" title="Types.this.Type">base</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> tr2
             <span class="delimiter">}</span>
             <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
             <a href="#530204" title="(tp1: Types.this.Type, tp2: Types.this.TypeRef)Boolean">thirdTryRef</a><span class="delimiter">(</span>tr1, tr2<span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
            <a href="#530508" title="(x: Boolean)Boolean">secondTry</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> AnnotatedType<a href="#530541" title="Boolean" id="530547" class="delimiter">(</a>_, _, _<span class="delimiter">)</span> =&gt;
        <a href="#529896" title="Types.this.Type">tp1</a>.<a href="#442086" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#529897" title="Types.this.Type">tp2</a>.<a href="#442086" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#530555" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="AnnotationCheckers.scala.html#440538" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#529896" title="Types.this.Type">tp1</a>, <a href="#529897" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> BoundedWildcardType<a href="#530541" title="Boolean" id="530549" class="delimiter">(</a>bounds<span class="delimiter">)</span> =&gt;
        <a href="#529896" title="Types.this.Type">tp1</a> <a href="#530555" title="(x: Boolean)Boolean">&lt;:&lt;</a> bounds.<a href="#448328" title="=&gt; Types.this.Type">hi</a>
      <span class="keyword">case</span> tv2 @ <a href="#470205" title="Option[(Types.this.Type, Types.this.TypeConstraint)]" id="530562">TypeVar</a><a href="#530541" title="Boolean" id="530552" class="delimiter">(</a>_, constr2<span class="delimiter">)</span> =&gt;
        <a href="#530555" title="(x: Boolean)Boolean">tp1</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> AnnotatedType<a href="#530521" title="Boolean" id="530526" class="delimiter">(</a>_, _, _<span class="delimiter">)</span> | BoundedWildcardType<a href="#530521" title="Boolean" id="530529" class="delimiter">(</a>_<span class="delimiter">)</span> =&gt;
            <a href="#530530" title="(x: Boolean)Boolean">secondTry</a>
          <span class="keyword">case</span> _ =&gt;
            tv2.<a href="#470182" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><a href="#530530" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#529896" title="Types.this.Type">tp1</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#530555" title="(x: Boolean)Boolean">secondTry</a>
    <span class="delimiter">}</span>

    /** Second try, on the left:
     *   - unwrap AnnotatedTypes, BoundedWildcardTypes,
     *   - bind typevars,
     *   - handle existential types by skolemization.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="530203">secondTry</a> = <a href="#529896" title="Types.this.Type">tp1</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> AnnotatedType<a href="#530478" title="Boolean" id="530483" class="delimiter">(</a>_, _, _<span class="delimiter">)</span> =&gt;
        <a href="#529896" title="Types.this.Type">tp1</a>.<a href="#442086" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#529897" title="Types.this.Type">tp2</a>.<a href="#442086" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#530495" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="AnnotationCheckers.scala.html#440538" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#529896" title="Types.this.Type">tp1</a>, <a href="#529897" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> BoundedWildcardType<a href="#530478" title="Boolean" id="530485" class="delimiter">(</a>bounds<span class="delimiter">)</span> =&gt;
        <a href="#529896" title="Types.this.Type">tp1</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448327" title="=&gt; Types.this.Type">lo</a> <a href="#530495" title="(x: Boolean)Boolean">&lt;:&lt;</a> <a href="#529897" title="Types.this.Type">tp2</a>
      <span class="keyword">case</span> tv @ <a href="#470205" title="Option[(Types.this.Type, Types.this.TypeConstraint)]" id="530501">TypeVar</a><a href="#530478" title="Boolean" id="530489" class="delimiter">(</a>_,_<span class="delimiter">)</span> =&gt;
        tv.<a href="#470182" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><a href="#530495" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#529897" title="Types.this.Type">tp2</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      <span class="keyword">case</span> ExistentialType<a href="#530478" title="Boolean" id="530494" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt;
        <a href="#530495" title="(x: Boolean)Boolean" class="keyword">try</a> <span class="delimiter">{</span>
          <a href="#441229" title="(x$1: Int)Unit">skolemizationLevel</a> <a href="../../Int.scala.html#57948" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
          <a href="#529896" title="Types.this.Type">tp1</a>.<a href="#442016" title="=&gt; Types.this.Type">skolemizeExistential</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#529897" title="Types.this.Type">tp2</a>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
          <a href="#441229" title="(x$1: Int)Unit">skolemizationLevel</a> <a href="../../Int.scala.html#57955" title="(x: Int)Int">-=</a> <span title="Int(1)" class="int">1</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#530495" title="(x: Boolean)Boolean">thirdTry</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.TypeRef)Boolean" id="530204">thirdTryRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="530229">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.TypeRef" id="530230">tp2</a>: <a href="#448160" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="530564">sym2</a> = <a href="#530230" title="Types.this.TypeRef">tp2</a>.<a href="#448176" title="=&gt; Types.this.Symbol">sym</a>
      <a href="#530564" title="Types.this.Symbol">sym2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="Definitions.scala.html#442272" title="Boolean" id="530600">NotNullClass</a> =&gt; <a href="#530229" title="Types.this.Type">tp1</a>.<a href="#530604" title="(x: Boolean)Boolean">isNotNull</a>
        <span class="keyword">case</span> <a href="Definitions.scala.html#442283" title="Boolean" id="530601">SingletonClass</a> =&gt; <a href="#530229" title="Types.this.Type">tp1</a>.<a href="#441973" title="=&gt; Boolean">isStable</a> <a href="#530604" title="(x: Boolean)Boolean">||</a> <a href="#530206" title="=&gt; Boolean">fourthTry</a>
        <span class="keyword">case</span> _: ClassSymbol =&gt;
          <a href="#530604" title="(x: Boolean)Boolean" class="keyword">if</a> <span class="delimiter">(</span><a href="#441438" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><span class="delimiter">(</span><a href="#530564" title="Types.this.Symbol">sym2</a>, <a href="#530230" title="Types.this.TypeRef">tp2</a>.<a href="#448177" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#441513" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#530229" title="Types.this.Type">tp1</a>, <a href="#460839" title="(tp: Types.this.Type)Types.this.Type">rawToExistential</a><span class="delimiter">(</span><a href="#530230" title="Types.this.TypeRef">tp2</a><span class="delimiter">)</span>, <a href="#529898" title="Int">depth</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#530564" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym2.NameType">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#441756" title="Types.this.tpnme.type">tpnme</a>.<a href="StdNames.scala.html#449193" title="=&gt; Types.this.tpnme.NameType">REFINE_CLASS_NAME</a><span class="delimiter">)</span>
            <a href="#441513" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#530229" title="Types.this.Type">tp1</a>, <a href="#530564" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>, <a href="#529898" title="Int">depth</a><span class="delimiter">)</span>
          <span class="keyword">else</span>
            <a href="#530206" title="=&gt; Boolean">fourthTry</a>
        <span class="keyword">case</span> _: TypeSymbol =&gt;
          <a href="#530604" title="(x: Boolean)Boolean" class="keyword">if</a> <span class="delimiter">(</span><a href="#530564" title="Types.this.Symbol">sym2</a> <a href="Symbols.scala.html#443303" title="(mask: Long)Boolean">hasFlag</a> <span title="Long(16L)">DEFERRED</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="530586">tp2a</a> = <a href="#530230" title="Types.this.TypeRef">tp2</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448327" title="=&gt; Types.this.Type">lo</a>
            <a href="#441497" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isDifferentTypeConstructor</a><span class="delimiter">(</span><a href="#530230" title="Types.this.TypeRef">tp2</a>, <a href="#530586" title="Types.this.Type">tp2a</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#530229" title="Types.this.Type">tp1</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#530586" title="Types.this.Type">tp2a</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#530206" title="=&gt; Boolean">fourthTry</a>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <a href="#441513" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#530229" title="Types.this.Type">tp1</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a>, <a href="#530230" title="Types.this.TypeRef">tp2</a>.<a href="#448124" title="=&gt; Types.this.Type">normalize</a>, <a href="#529898" title="Int">depth</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="keyword">case</span> _ =&gt;
          <a href="#530604" title="(x: Boolean)Boolean">fourthTry</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** Third try, on the right:
     *   - decompose refined types.
     *   - handle typerefs, existentials, and notnull types.
     *   - handle left+right method types, polytypes, typebounds
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="530205">thirdTry</a> = <a href="#529897" title="Types.this.Type">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#530450" title="Boolean" id="530461">tr2</a>: TypeRef =&gt;
        <a href="#530204" title="(tp1: Types.this.Type, tp2: Types.this.TypeRef)Boolean">thirdTryRef</a><a href="#530466" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#529896" title="Types.this.Type">tp1</a>, tr2<span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="#530450" title="Boolean" id="530462">rt2</a>: RefinedType =&gt;
        <span class="delimiter">(</span>rt2.<a href="#469850" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a href="#529896" title="Types.this.Type">tp1</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#530263" title="Types.this.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#530466" title="(x: Boolean)Boolean">&amp;&amp;</a>
        <span class="delimiter">(</span>rt2.<a href="#469851" title="=&gt; Types.this.Scope">decls</a> <a href="../../collection/IterableLike.scala.html#59461" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</a> <a href="#529896" title="Types.this.Type">tp1</a>.<a href="#442063" title="(sym: Types.this.Symbol)Boolean">specializes</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="#530450" title="Boolean" id="530463">et2</a>: ExistentialType =&gt;
        et2.<a href="#448591" title="(op: Types.this.Type =&gt; Boolean, depth: Int)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#529896" title="Types.this.Type">tp1</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#530275" title="Types.this.Type">_</a>, <a href="#529898" title="Int">depth</a><span class="delimiter">)</span> <a href="#530466" title="(x: Boolean)Boolean">||</a> <a href="#530206" title="=&gt; Boolean">fourthTry</a>
      <span class="keyword">case</span> <a href="#530450" title="Boolean" id="530464">nn2</a>: NotNullType =&gt;
        <a href="#529896" title="Types.this.Type">tp1</a>.<a href="#441975" title="=&gt; Boolean">isNotNull</a> <a href="#530466" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#529896" title="Types.this.Type">tp1</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> nn2.<a href="#470408" title="=&gt; Types.this.Type">underlying</a>
      <span class="keyword">case</span> <a href="#530450" title="Boolean" id="530465">mt2</a>: MethodType =&gt;
        <a href="#530466" title="(x: Boolean)Boolean">tp1</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> mt1 @ MethodType<a href="#530409" title="Boolean" id="530411" class="delimiter">(</a>params1, res1<span class="delimiter">)</span> =&gt;
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="530391">params2</a> = mt2.<a href="#453586" title="=&gt; List[Types.this.Symbol]">params</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="530392">res2</a> = mt2.<a href="#453587" title="=&gt; Types.this.Type">resultType</a>
            <span class="delimiter">(</span><a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span>params1, <a href="#530391" title="List[Types.this.Symbol]">params2</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
             mt1.<a href="#448359" title="=&gt; Boolean">isImplicit</a> <a href="../../Boolean.scala.html#58722" title="(x: Boolean)Boolean">==</a> mt2.<a href="#448359" title="=&gt; Boolean">isImplicit</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
             <a href="#441529" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span>params1, <a href="#530391" title="List[Types.this.Symbol]">params2</a>, mt1.<a href="#448360" title="=&gt; Boolean">isJava</a>, mt2.<a href="#448360" title="=&gt; Boolean">isJava</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
             <span class="delimiter">(</span>res1 <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#530392" title="Types.this.Type">res2</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#530391" title="List[Types.this.Symbol]">params2</a>, params1<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          // TODO: if mt1.params.isEmpty, consider NullaryMethodType?
          <span class="keyword">case</span> _ =&gt;
            <a href="#530412" title="(x: Boolean)Boolean" class="keyword">false</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> pt2 @ NullaryMethodType<a href="#530450" title="Boolean" id="530458" class="delimiter">(</a>_<span class="delimiter">)</span> =&gt;
        <a href="#530466" title="(x: Boolean)Boolean">tp1</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          // TODO: consider MethodType mt for which mt.params.isEmpty??
          <span class="keyword">case</span> pt1 @ NullaryMethodType<a href="#530425" title="Boolean" id="530428" class="delimiter">(</a>_<span class="delimiter">)</span> =&gt;
            pt1.<a href="#454263" title="=&gt; Types.this.Type">resultType</a> <a href="#530429" title="(x: Boolean)Boolean">&lt;:&lt;</a> pt2.<a href="#454263" title="=&gt; Types.this.Type">resultType</a>
          <span class="keyword">case</span> _ =&gt;
            <a href="#530429" title="(x: Boolean)Boolean" class="keyword">false</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> TypeBounds<a href="#530450" title="Boolean" id="530460" class="delimiter">(</a>lo2, hi2<span class="delimiter">)</span> =&gt;
        <a href="#530466" title="(x: Boolean)Boolean">tp1</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> TypeBounds<a href="#530441" title="Boolean" id="530443" class="delimiter">(</a>lo1, hi1<span class="delimiter">)</span> =&gt;
            lo2 <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> lo1 <a href="#530444" title="(x: Boolean)Boolean">&amp;&amp;</a> hi1 <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> hi2
          <span class="keyword">case</span> _ =&gt;
            <a href="#530444" title="(x: Boolean)Boolean" class="keyword">false</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#530466" title="(x: Boolean)Boolean">fourthTry</a>
    <span class="delimiter">}</span>

    /** Fourth try, on the left:
     *   - handle typerefs, refined types, notnull and singleton types.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="530206">fourthTry</a> = <a href="#529896" title="Types.this.Type">tp1</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> tr1 @ TypeRef<a href="#530362" title="Boolean" id="530365" class="delimiter">(</a>pre1, sym1, _<span class="delimiter">)</span> =&gt;
        <a href="#530373" title="(x: Boolean)Boolean">sym1</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="Definitions.scala.html#442193" title="Boolean" id="530332">NothingClass</a> =&gt; <a href="#530336" title="(x: Boolean)Boolean" class="keyword">true</a>
          <span class="keyword">case</span> <a href="Definitions.scala.html#442195" title="Boolean" id="530333">NullClass</a> =&gt;
            <a href="#530336" title="(x: Boolean)Boolean">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> TypeRef<a href="#530283" title="Boolean" id="530287" class="delimiter">(</a>_, sym2, _<span class="delimiter">)</span> =&gt;
                <a href="#441524" title="(sym: Types.this.Symbol)Boolean">containsNull</a><a href="#530288" title="(x: Boolean)Boolean" class="delimiter">(</a>sym2<span class="delimiter">)</span>
              <span class="keyword">case</span> _ =&gt;
                <a href="#441517" title="(tp: Types.this.Type)Boolean">isSingleType</a><span class="delimiter">(</span><a href="#529897" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <a href="#530288" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#529896" title="Types.this.Type">tp1</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#529897" title="Types.this.Type">tp2</a>.<a href="#441990" title="=&gt; Types.this.Type">widen</a>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> _: ClassSymbol =&gt;
            <a href="#530336" title="(x: Boolean)Boolean" class="keyword">if</a> <span class="delimiter">(</span><a href="#441438" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><span class="delimiter">(</span>sym1, tr1.<a href="#448177" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#441513" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#460839" title="(tp: Types.this.Type)Types.this.Type">rawToExistential</a><span class="delimiter">(</span><a href="#529896" title="Types.this.Type">tp1</a><span class="delimiter">)</span>, <a href="#529897" title="Types.this.Type">tp2</a>, <a href="#529898" title="Int">depth</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span>sym1.<a href="Symbols.scala.html#443245" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <a href="#529897" title="Types.this.Type">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> SingleType<a href="#530308" title="Boolean" id="530310" class="delimiter">(</a>pre2, sym2<span class="delimiter">)</span> =&gt; <a href="#441494" title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean">equalSymsAndPrefixes</a><a href="#530311" title="(x: Boolean)Boolean" class="delimiter">(</a>sym1.<a href="Symbols.scala.html#443490" title="=&gt; Types.this.Symbol">sourceModule</a>, pre1, sym2, pre2<span class="delimiter">)</span>
              <span class="keyword">case</span> _                      =&gt; <a href="#530311" title="(x: Boolean)Boolean" class="keyword">false</a>
            <span class="delimiter">}</span>
            <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span>sym1.<a href="Symbols.scala.html#443248" title="=&gt; Boolean">isRefinementClass</a><span class="delimiter">)</span>
              <a href="#441513" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span>sym1.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>, <a href="#529897" title="Types.this.Type">tp2</a>, <a href="#529898" title="Int">depth</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <span title="Boolean(false)" class="keyword">false</span>

          <span class="keyword">case</span> _: TypeSymbol =&gt;
            <a href="#530336" title="(x: Boolean)Boolean" class="keyword">if</a> <span class="delimiter">(</span>sym1 <a href="Symbols.scala.html#443303" title="(mask: Long)Boolean">hasFlag</a> <span title="Long(16L)">DEFERRED</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="530320">tp1a</a> = <a href="#529896" title="Types.this.Type">tp1</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a>
              <a href="#441497" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isDifferentTypeConstructor</a><span class="delimiter">(</span><a href="#529896" title="Types.this.Type">tp1</a>, <a href="#530320" title="Types.this.Type">tp1a</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#530320" title="Types.this.Type">tp1a</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#529897" title="Types.this.Type">tp2</a>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <a href="#441513" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#529896" title="Types.this.Type">tp1</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a>, <a href="#529897" title="Types.this.Type">tp2</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a>, <a href="#529898" title="Int">depth</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> _ =&gt;
            <a href="#530336" title="(x: Boolean)Boolean" class="keyword">false</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> RefinedType<a href="#530362" title="Boolean" id="530368" class="delimiter">(</a>parents1, _<span class="delimiter">)</span> =&gt;
        parents1 <a href="#530373" title="(x: Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#530357" title="Types.this.Type">_</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#529897" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _: SingletonType | _: NotNullType =&gt;
        <a href="#529896" title="Types.this.Type">tp1</a>.<a href="#441989" title="=&gt; Types.this.Type">underlying</a> <a href="#530373" title="(x: Boolean)Boolean">&lt;:&lt;</a> <a href="#529897" title="Types.this.Type">tp2</a>
      <span class="keyword">case</span> _ =&gt;
        <a href="#530373" title="(x: Boolean)Boolean" class="keyword">false</a>
    <span class="delimiter">}</span>

    <a href="#530202" title="=&gt; Boolean">firstTry</a>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="441524">containsNull</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="530280">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> =
    <a href="#530280" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443231" title="=&gt; Boolean">isClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#530280" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
    <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#530280" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#443468" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="Definitions.scala.html#442184" title="=&gt; Types.this.ClassSymbol">AnyValClass</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
    <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#530280" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#443468" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="Definitions.scala.html#442272" title="=&gt; Types.this.ClassSymbol">NotNullClass</a><span class="delimiter">)</span>

  /** Are `tps1` and `tps2` lists of equal length such that all elements
   *  of `tps1` conform to corresponding elements of `tps2`?
   */
  <span class="keyword">def</span> <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean" id="441525">isSubTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="530623">tps1</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="530624">tps2</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">(</span><a href="#530623" title="List[Types.this.Type]">tps1</a> <a href="../../collection/LinearSeqLike.scala.html#76110" title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.Type, Types.this.Type) =&gt; Boolean)Boolean">corresponds</a> <a href="#530624" title="List[Types.this.Type]">tps2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#530644" title="Types.this.Type">_</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#530645" title="Types.this.Type">_</a><span class="delimiter">)</span>

  /** Does type `tp` implement symbol `sym` with same or
   *  stronger type? Exact only if `sym` is a member of some
   *  refinement type, otherwise we might return false negatives.
   */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean" id="441526">specializesSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="515823">tp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="515824">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> =
    <a href="#515823" title="Types.this.Type">tp</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
    <a href="#515823" title="Types.this.Type">tp</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#442195" title="Types.this.definitions.NullClass.type">NullClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441524" title="(sym: Types.this.Symbol)Boolean">containsNull</a><span class="delimiter">(</span><a href="#515824" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
    <span class="delimiter">(</span><a href="#515823" title="Types.this.Type">tp</a>.<a href="#442029" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#515824" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym.NameType">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#443472" title="=&gt; List[Types.this.Symbol]">alternatives</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a>
      <span class="delimiter">(</span><a title="Types.this.Symbol" id="530667">alt</a> =&gt; <a href="#515824" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#530667" title="Types.this.Symbol">alt</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#441527" title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#515823" title="Types.this.Type">tp</a>.<a href="#441993" title="=&gt; Types.this.Type">narrow</a>, <a href="#530667" title="Types.this.Symbol">alt</a>, <a href="#515824" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#443485" title="=&gt; Types.this.Type">thisType</a>, <a href="#515824" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  /** Does member `sym1` of `tp1` have a stronger type
   *  than member `sym2` of `tp2`?
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean" id="441527">specializesSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="515818">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="515819">sym1</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="515820">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="515821">sym2</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Types.this.Type" id="530676">info1</a> = <a href="#515818" title="Types.this.Type">tp1</a>.<a href="#442038" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#515819" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Types.this.Type" id="530677">info2</a> = <a href="#515820" title="Types.this.Type">tp2</a>.<a href="#442038" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#515821" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>.<a href="#442043" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#515820" title="Types.this.Type">tp2</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#515818" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
    //System.out.println(&quot;specializes &quot;+tp1+&quot;.&quot;+sym1+&quot;:&quot;+info1+sym1.locationString+&quot; AND &quot;+tp2+&quot;.&quot;+sym2+&quot;:&quot;+info2)//DEBUG
    <a href="#515821" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443229" title="=&gt; Boolean">isTerm</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#530676" title="Types.this.Type">info1</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#530677" title="Types.this.Type">info2</a><span class="delimiter">)</span> /*&amp;&amp; (!sym2.isStable || sym1.isStable) */ <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
    <a href="#515821" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443233" title="=&gt; Boolean">isAbstractType</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="530685">memberTp1</a> = <a href="#515818" title="Types.this.Type">tp1</a>.<a href="#442039" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#515819" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      // println(&quot;kinds conform? &quot;+(memberTp1, tp1, sym2, kindsConform(List(sym2), List(memberTp1), tp2, sym2.owner)))
      <a href="#530677" title="Types.this.Type">info2</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448306" title="(that: Types.this.Type)Boolean">containsType</a><span class="delimiter">(</span><a href="#530685" title="Types.this.Type">memberTp1</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
      <a href="Kinds.scala.html#441615" title="(tparams: List[Types.this.Symbol], targs: List[Types.this.Type], pre: Types.this.Type, owner: Types.this.Symbol)Boolean">kindsConform</a><span class="delimiter">(</span><a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</a><span class="delimiter">(</span><a href="#515821" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>, <a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><a href="#530685" title="Types.this.Type">memberTp1</a><span class="delimiter">)</span>, <a href="#515818" title="Types.this.Type">tp1</a>, <a href="#515819" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
    <a href="#515821" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#443232" title="=&gt; Boolean">isAliasType</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#515820" title="Types.this.Type">tp2</a>.<a href="#442039" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#515821" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>.<a href="#442043" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#515820" title="Types.this.Type">tp2</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#515818" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#515818" title="Types.this.Type">tp1</a>.<a href="#442039" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#515819" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> //@MAT ok
  <span class="delimiter">}</span>

  /** A function implementing `tp1` matches `tp2`. */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean" id="441528">matchesType</a><span class="delimiter">(</span><a title="Types.this.Type" id="515839">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="515840">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Boolean" id="515841">alwaysMatchSimple</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean" id="530711">matchesQuantified</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="530713">tparams1</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="530714">tparams2</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="530715">res1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="530716">res2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">(</span>
      <a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#530713" title="List[Types.this.Symbol]">tparams1</a>, <a href="#530714" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
      <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#530715" title="Types.this.Type">res1</a>, <a href="#530716" title="Types.this.Type">res2</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#530714" title="List[Types.this.Symbol]">tparams2</a>, <a href="#530713" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>, <a href="#515841" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="530712">lastTry</a> =
      <a href="#515840" title="Types.this.Type">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> ExistentialType<a href="#530722" title="Boolean" id="530725" class="delimiter">(</a>_, res2<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#515841" title="Boolean">alwaysMatchSimple</a> =&gt;
          <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><a href="#530734" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#515839" title="Types.this.Type">tp1</a>, res2, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
        <span class="keyword">case</span> MethodType<a href="#530722" title="Boolean" id="530729" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt;
          <a href="#530734" title="(x: Boolean)Boolean" class="keyword">false</a>
        <span class="keyword">case</span> PolyType<a href="#530722" title="Boolean" id="530733" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt;
          <a href="#530734" title="(x: Boolean)Boolean" class="keyword">false</a>
        <span class="keyword">case</span> _ =&gt;
          <a href="#515841" title="Boolean">alwaysMatchSimple</a> <a href="#530734" title="(x: Boolean)Boolean">||</a> <a href="#515839" title="Types.this.Type">tp1</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#515840" title="Types.this.Type">tp2</a>
      <span class="delimiter">}</span>
    <a href="#515839" title="Types.this.Type">tp1</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> mt1 @ MethodType<a href="#530893" title="Boolean" id="530895" class="delimiter">(</a>params1, res1<span class="delimiter">)</span> =&gt;
        <a href="#530908" title="(x: Boolean)Boolean">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> mt2 @ MethodType<a href="#530756" title="Boolean" id="530758" class="delimiter">(</a>params2, res2<span class="delimiter">)</span> =&gt;
            // sameLength(params1, params2) was used directly as pre-screening optimization (now done by matchesQuantified -- is that ok, performancewise?)
            mt1.<a href="#448359" title="=&gt; Boolean">isImplicit</a> <a href="../../Boolean.scala.html#58722" title="(x: Boolean)Boolean">==</a> mt2.<a href="#448359" title="=&gt; Boolean">isImplicit</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
            <a href="#441529" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span>params1, params2, mt1.<a href="#448360" title="=&gt; Boolean">isJava</a>, mt2.<a href="#448360" title="=&gt; Boolean">isJava</a><span class="delimiter">)</span> <a href="#530770" title="(x: Boolean)Boolean">&amp;&amp;</a>
            <a href="#530711" title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean">matchesQuantified</a><span class="delimiter">(</span>params1, params2, res1, res2<span class="delimiter">)</span>
          <span class="keyword">case</span> NullaryMethodType<a href="#530756" title="Boolean" id="530760" class="delimiter">(</a>res2<span class="delimiter">)</span> =&gt;
            <a href="#530770" title="(x: Boolean)Boolean" class="keyword">if</a> <span class="delimiter">(</span>params1.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span>res1, res2, <a href="#515841" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#515839" title="Types.this.Type">tp1</a>, res2, <a href="#515841" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> ExistentialType<a href="#530756" title="Boolean" id="530763" class="delimiter">(</a>_, res2<span class="delimiter">)</span> =&gt;
            <a href="#515841" title="Boolean">alwaysMatchSimple</a> <a href="#530770" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#515839" title="Types.this.Type">tp1</a>, res2, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> TypeRef<a href="#530756" title="Boolean" id="530767" class="delimiter">(</a>_, sym, <a href="../../collection/immutable/List.scala.html#11552" title="Boolean" id="530769">Nil</a><span class="delimiter">)</span> =&gt;
            params1.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> sym.<a href="Symbols.scala.html#443245" title="=&gt; Boolean">isModuleClass</a> <a href="#530770" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span>res1, <a href="#515840" title="Types.this.Type">tp2</a>, <a href="#515841" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
            <a href="#530770" title="(x: Boolean)Boolean" class="keyword">false</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> mt1 @ NullaryMethodType<a href="#530893" title="Boolean" id="530897" class="delimiter">(</a>res1<span class="delimiter">)</span> =&gt;
        <a href="#530908" title="(x: Boolean)Boolean">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> mt2 @ MethodType<a href="#530789" title="Boolean" id="530792" class="delimiter">(</a><a href="../../collection/immutable/List.scala.html#11552" title="Boolean" id="530804">Nil</a>, res2<span class="delimiter">)</span>  =&gt; // could never match if params nonEmpty, and !mt2.isImplicit is implied by empty param list
            <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><a href="#530806" title="(x: Boolean)Boolean" class="delimiter">(</a>res1, res2, <a href="#515841" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> NullaryMethodType<a href="#530789" title="Boolean" id="530795" class="delimiter">(</a>res2<span class="delimiter">)</span> =&gt;
            <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><a href="#530806" title="(x: Boolean)Boolean" class="delimiter">(</a>res1, res2, <a href="#515841" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> ExistentialType<a href="#530789" title="Boolean" id="530798" class="delimiter">(</a>_, res2<span class="delimiter">)</span> =&gt;
            <a href="#515841" title="Boolean">alwaysMatchSimple</a> <a href="#530806" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#515839" title="Types.this.Type">tp1</a>, res2, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> TypeRef<a href="#530789" title="Boolean" id="530802" class="delimiter">(</a>_, sym, <a href="../../collection/immutable/List.scala.html#11552" title="Boolean" id="530805">Nil</a><span class="delimiter">)</span> <span class="keyword">if</span> sym.<a href="Symbols.scala.html#443245" title="=&gt; Boolean">isModuleClass</a> =&gt;
            <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><a href="#530806" title="(x: Boolean)Boolean" class="delimiter">(</a>res1, <a href="#515840" title="Types.this.Type">tp2</a>, <a href="#515841" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
            <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><a href="#530806" title="(x: Boolean)Boolean" class="delimiter">(</a>res1, <a href="#515840" title="Types.this.Type">tp2</a>, <a href="#515841" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> PolyType<a href="#530893" title="Boolean" id="530899" class="delimiter">(</a>tparams1, res1<span class="delimiter">)</span> =&gt;
        <a href="#530908" title="(x: Boolean)Boolean">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> PolyType<a href="#530846" title="Boolean" id="530848" class="delimiter">(</a>tparams2, res2<span class="delimiter">)</span> =&gt;
            <a href="#530852" title="(x: Boolean)Boolean" class="keyword">if</a> <span class="delimiter">(</span><span class="delimiter">(</span>tparams1 <a href="../../collection/LinearSeqLike.scala.html#76110" title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</a> tparams2<span class="delimiter">)</span><span class="delimiter">(</span><a href="#530842" title="Types.this.Symbol">_</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#530843" title="Types.this.Symbol">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span>res1, res2, <a href="#515841" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
            <span class="keyword">else</span>
              <a href="#530711" title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean">matchesQuantified</a><span class="delimiter">(</span>tparams1, tparams2, res1, res2<span class="delimiter">)</span>
          <span class="keyword">case</span> ExistentialType<a href="#530846" title="Boolean" id="530851" class="delimiter">(</a>_, res2<span class="delimiter">)</span> =&gt;
            <a href="#515841" title="Boolean">alwaysMatchSimple</a> <a href="#530852" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#515839" title="Types.this.Type">tp1</a>, res2, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
            <a href="#530852" title="(x: Boolean)Boolean" class="keyword">false</a> // remember that tparams1.nonEmpty is now an invariant of PolyType
        <span class="delimiter">}</span>
      <span class="keyword">case</span> ExistentialType<a href="#530893" title="Boolean" id="530901" class="delimiter">(</a>tparams1, res1<span class="delimiter">)</span> =&gt;
        <a href="#530908" title="(x: Boolean)Boolean">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> ExistentialType<a href="#530863" title="Boolean" id="530865" class="delimiter">(</a>tparams2, res2<span class="delimiter">)</span> =&gt;
            <a href="#530711" title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean">matchesQuantified</a><a href="#530866" title="(x: Boolean)Boolean" class="delimiter">(</a>tparams1, tparams2, res1, res2<span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
            <a href="#530866" title="(x: Boolean)Boolean" class="keyword">if</a> <span class="delimiter">(</span><a href="#515841" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span> <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span>res1, <a href="#515840" title="Types.this.Type">tp2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#530712" title="=&gt; Boolean">lastTry</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> TypeRef<a href="#530893" title="Boolean" id="530905" class="delimiter">(</a>_, sym, <a href="../../collection/immutable/List.scala.html#11552" title="Boolean" id="530907">Nil</a><span class="delimiter">)</span> <span class="keyword">if</span> sym.<a href="Symbols.scala.html#443245" title="=&gt; Boolean">isModuleClass</a> =&gt;
        <a href="#530908" title="(x: Boolean)Boolean">tp2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> MethodType<a href="#530875" title="Boolean" id="530878" class="delimiter">(</a><a href="../../collection/immutable/List.scala.html#11552" title="Boolean" id="530882">Nil</a>, res2<span class="delimiter">)</span>   =&gt; <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><a href="#530883" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#515839" title="Types.this.Type">tp1</a>, res2, <a href="#515841" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> NullaryMethodType<a href="#530875" title="Boolean" id="530881" class="delimiter">(</a>res2<span class="delimiter">)</span> =&gt; <a href="#441528" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><a href="#530883" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#515839" title="Types.this.Type">tp1</a>, res2, <a href="#515841" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> _                       =&gt; <a href="#530883" title="(x: Boolean)Boolean">lastTry</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#530908" title="(x: Boolean)Boolean">lastTry</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

/** matchesType above is an optimized version of the following implementation:

  def matchesType2(tp1: Type, tp2: Type, alwaysMatchSimple: Boolean): Boolean = {
    def matchesQuantified(tparams1: List[Symbol], tparams2: List[Symbol], res1: Type, res2: Type): Boolean =
      tparams1.length == tparams2.length &amp;&amp;
      matchesType(res1, res2.substSym(tparams2, tparams1), alwaysMatchSimple)
    (tp1, tp2) match {
      case (MethodType(params1, res1), MethodType(params2, res2)) =&gt;
        params1.length == params2.length &amp;&amp; // useful pre-secreening optimization
        matchingParams(params1, params2, tp1.isInstanceOf[JavaMethodType], tp2.isInstanceOf[JavaMethodType]) &amp;&amp;
        matchesType(res1, res2, alwaysMatchSimple) &amp;&amp;
        tp1.isImplicit == tp2.isImplicit
      case (PolyType(tparams1, res1), PolyType(tparams2, res2)) =&gt;
        matchesQuantified(tparams1, tparams2, res1, res2)
      case (NullaryMethodType(rtp1), MethodType(List(), rtp2)) =&gt;
        matchesType(rtp1, rtp2, alwaysMatchSimple)
      case (MethodType(List(), rtp1), NullaryMethodType(rtp2)) =&gt;
        matchesType(rtp1, rtp2, alwaysMatchSimple)
      case (ExistentialType(tparams1, res1), ExistentialType(tparams2, res2)) =&gt;
        matchesQuantified(tparams1, tparams2, res1, res2)
      case (ExistentialType(_, res1), _) if alwaysMatchSimple =&gt;
        matchesType(res1, tp2, alwaysMatchSimple)
      case (_, ExistentialType(_, res2)) if alwaysMatchSimple =&gt;
        matchesType(tp1, res2, alwaysMatchSimple)
      case (NullaryMethodType(rtp1), _) =&gt;
        matchesType(rtp1, tp2, alwaysMatchSimple)
      case (_, NullaryMethodType(rtp2)) =&gt;
        matchesType(tp1, rtp2, alwaysMatchSimple)
      case (MethodType(_, _), _) =&gt; false
      case (PolyType(_, _), _)   =&gt; false
      case (_, MethodType(_, _)) =&gt; false
      case (_, PolyType(_, _))   =&gt; false
      case _ =&gt;
        alwaysMatchSimple || tp1 =:= tp2
    }
  }
*/

  /** Are `syms1` and `syms2` parameter lists with pairwise equivalent types? */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean" id="441529">matchingParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="530402">syms1</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="530403">syms2</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Boolean" id="530404">syms1isJava</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a>, <a title="Boolean" id="530405">syms2isJava</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <a href="#530402" title="List[Types.this.Symbol]">syms1</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="../../collection/immutable/List.scala.html#11552" title="Boolean" id="530972">Nil</a> =&gt;
      <a href="#530403" title="List[Types.this.Symbol]">syms2</a>.<a href="#530973" title="(x: Boolean)Boolean">isEmpty</a>
    <span class="keyword">case</span> sym1 <a href="#530969" title="Boolean" id="530971">::</a> rest1 =&gt;
      <a href="#530973" title="(x: Boolean)Boolean">syms2</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="../../collection/immutable/List.scala.html#11552" title="Boolean" id="530959">Nil</a> =&gt;
          <a href="#530960" title="(x: Boolean)Boolean" class="keyword">false</a>
        <span class="keyword">case</span> sym2 <a href="#530956" title="Boolean" id="530958">::</a> rest2 =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="530932">tp1</a> = sym1.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a>
          <span class="keyword">val</span> <a title="Types.this.Type" id="530933">tp2</a> = sym2.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a>
          <span class="delimiter">(</span><a href="#530932" title="Types.this.Type">tp1</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#530933" title="Types.this.Type">tp2</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
           <a href="#530404" title="Boolean">syms1isJava</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#530933" title="Types.this.Type">tp2</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#442179" title="=&gt; Types.this.ClassSymbol">ObjectClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#530932" title="Types.this.Type">tp1</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>
           <a href="#530405" title="Boolean">syms2isJava</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#530932" title="Types.this.Type">tp1</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#442179" title="=&gt; Types.this.ClassSymbol">ObjectClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#530933" title="Types.this.Type">tp2</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a>
          <a href="#441529" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span>rest1, rest2, <a href="#530404" title="Boolean">syms1isJava</a>, <a href="#530405" title="Boolean">syms2isJava</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** like map2, but returns list `xs` itself - instead of a copy - if function
   *  `f` maps all elements to themselves.
   */
  <span class="keyword">def</span> <a title="[A &lt;: AnyRef, B](xs: List[A], ys: List[B])(f: (A, B) =&gt; A)List[A]" id="441530">map2Conserve</a><span class="delimiter">[</span><a title=" &lt;: AnyRef" id="441533">A</a> &lt;: AnyRef, <a title="" id="441534">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[A]" id="525992">xs</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="List[B]" id="525993">ys</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[B]">List</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; A" id="525994">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <span title="List[A]" class="keyword">if</span> <span class="delimiter">(</span><a href="#525992" title="List[A]">xs</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#525992" title="List[A]">xs</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="A" id="530981">x1</a> = <a href="../../Function2.scala.html#65847" title="(v1: A, v2: B)A">f</a><span class="delimiter">(</span><a href="#525992" title="List[A]">xs</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; A">head</a>, <a href="#525993" title="List[B]">ys</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; B">head</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[A]" id="530982">xs1</a> = <a href="#441530" title="(xs: List[A], ys: List[B])(f: (A, B) =&gt; A)List[A]">map2Conserve</a><span class="delimiter">(</span><a href="#525992" title="List[A]">xs</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[A]">tail</a>, <a href="#525993" title="List[B]">ys</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[B]">tail</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#525994" title="(A, B) =&gt; A">f</a><span class="delimiter">)</span>
      <span title="List[A]" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#530981" title="A">x1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#525992" title="List[A]">xs</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; A">head</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#530982" title="List[A]">xs1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#525992" title="List[A]">xs</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[A]">tail</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#525992" title="List[A]">xs</a>
      <span class="keyword">else</span> <a href="#530981" title="A">x1</a> <a href="../../collection/immutable/List.scala.html#63643" title="(x: A)List[A]">::</a> <a href="#530982" title="List[A]">xs1</a>
    <span class="delimiter">}</span>

  /** Solve constraint collected in types `tvars`.
   *
   *  @param tvars      All type variables to be instantiated.
   *  @param tparams    The type parameters corresponding to `tvars`
   *  @param variances  The variances of type parameters; need to reverse
   *                    solution direction for all contravariant variables.
   *  @param upper      When `true` search for max solution else min.
   */
  <span class="keyword">def</span> <a title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean)Boolean" id="441535">solve</a><span class="delimiter">(</span><a title="List[Types.this.TypeVar]" id="494025">tvars</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.TypeVar]">List</a><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="494026">tparams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
            <a title="List[Int]" id="494027">variances</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Int]">List</a><span class="delimiter">[</span>Int<span class="delimiter">]</span>, <a title="Boolean" id="494028">upper</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> =
     <a href="#441536" title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean, depth: Int)Boolean">solve</a><span class="delimiter">(</span><a href="#494025" title="List[Types.this.TypeVar]">tvars</a>, <a href="#494026" title="List[Types.this.Symbol]">tparams</a>, <a href="#494027" title="List[Int]">variances</a>, <a href="#494028" title="Boolean">upper</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean, depth: Int)Boolean" id="441536">solve</a><span class="delimiter">(</span><a title="List[Types.this.TypeVar]" id="494014">tvars</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.TypeVar]">List</a><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="494015">tparams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
            <a title="List[Int]" id="494016">variances</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Int]">List</a><span class="delimiter">[</span>Int<span class="delimiter">]</span>, <a title="Boolean" id="494017">upper</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a>, <a title="Int" id="494018">depth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>

    <span class="keyword">def</span> <a title="(tvar: Types.this.TypeVar, tparam: Types.this.Symbol, variance: Int)Unit" id="531019">solveOne</a><span class="delimiter">(</span><a title="Types.this.TypeVar" id="531020">tvar</a>: <a href="#441345" title="Types.this.TypeVar">TypeVar</a>, <a title="Types.this.Symbol" id="531021">tparam</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="Int" id="531022">variance</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#531020" title="Types.this.TypeVar">tvar</a>.<a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470266" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Boolean" id="531028">up</a> = <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#531022" title="Int">variance</a> <a href="../../Int.scala.html#57898" title="(x: Int)Boolean">!=</a> <span title="Int(131072)">CONTRAVARIANT</span><span class="delimiter">)</span> <a href="#494017" title="Boolean">upper</a> <span class="keyword">else</span> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#494017" title="Boolean">upper</a>
        <a href="#531020" title="Types.this.TypeVar">tvar</a>.<a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470266" title="(x$1: Types.this.Type)Unit">inst</a> = <span title="Null(null)" class="keyword">null</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="531029">bound</a>: <a href="#441242" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#531028" title="Boolean">up</a><span class="delimiter">)</span> <a href="#531021" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a> <span class="keyword">else</span> <a href="#531021" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448327" title="=&gt; Types.this.Type">lo</a>
        //Console.println(&quot;solveOne0(tv, tp, v, b)=&quot;+(tvar, tparam, variance, bound))
        <span class="keyword">var</span> <a title="Boolean" id="531030">cyclic</a> = <a href="#531029" title="Types.this.Type">bound</a> <a href="#442056" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#531021" title="Types.this.Symbol">tparam</a>
        <a href="util/Collections.scala.html#440731" title="(xs1: List[Types.this.TypeVar], xs2: List[Types.this.Symbol], xs3: List[Int])(f: (Types.this.TypeVar, Types.this.Symbol, Int) =&gt; Unit)Unit">foreach3</a><span class="delimiter">(</span><a href="#494014" title="List[Types.this.TypeVar]">tvars</a>, <a href="#494015" title="List[Types.this.Symbol]">tparams</a>, <a href="#494016" title="List[Int]">variances</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.TypeVar" id="531078">tvar2</a>, <a title="Types.this.Symbol" id="531079">tparam2</a>, <a title="Int" id="531080">variance2</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Boolean" id="531081">ok</a> = <span class="delimiter">(</span><a href="#531079" title="Types.this.Symbol">tparam2</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#531021" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span>
               <span class="delimiter">(</span><a href="#531029" title="Types.this.Type">bound</a> <a href="#442056" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#531079" title="Types.this.Symbol">tparam2</a><span class="delimiter">)</span>
            <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a>  <a href="#531028" title="Boolean">up</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#531079" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448327" title="=&gt; Types.this.Type">lo</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#531021" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
            <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#531028" title="Boolean">up</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#531079" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#531021" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
          <span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#531081" title="Boolean">ok</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#531078" title="Types.this.TypeVar">tvar2</a>.<a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470266" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#531030" title="Boolean">cyclic</a> = <span title="Boolean(true)" class="keyword">true</span>
            <a href="#531019" title="(tvar: Types.this.TypeVar, tparam: Types.this.Symbol, variance: Int)Unit">solveOne</a><span class="delimiter">(</span><a href="#531078" title="Types.this.TypeVar">tvar2</a>, <a href="#531079" title="Types.this.Symbol">tparam2</a>, <a href="#531080" title="Int">variance2</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#531030" title="Boolean">cyclic</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#531028" title="Boolean">up</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#531029" title="Types.this.Type">bound</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a><span class="delimiter">)</span>
              <a href="#531020" title="Types.this.TypeVar">tvar</a> <a href="#470178" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a> <a href="#531029" title="Types.this.Type">bound</a>.<a href="#442014" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#494015" title="List[Types.this.Symbol]">tparams</a>, <a href="#494014" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
            <span class="keyword">for</span> <span class="delimiter">(</span>tparam2 &lt;- <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span>
              <a href="#531116" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448327" title="=&gt; Types.this.Type">lo</a>.<a href="#442018" title="=&gt; Types.this.Type">dealias</a> <span class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> TypeRef<a href="#531118" title="Unit" id="531123" class="delimiter">(</a>_, <a href="#531021" title="Unit" id="531126">`tparam`</a>, _<span class="delimiter">)</span> =&gt;
                  <a href="#531020" title="Types.this.TypeVar">tvar</a> <a href="#531127" title="(x: Unit)Unit">addHiBound</a> <a href="#531116" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a>.<a href="#442014" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#494015" title="List[Types.this.Symbol]">tparams</a>, <a href="#494014" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
                <span class="keyword">case</span> _ =&gt;
              <span class="delimiter">}</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#531029" title="Types.this.Type">bound</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#531029" title="Types.this.Type">bound</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#531021" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#531020" title="Types.this.TypeVar">tvar</a> <a href="#470177" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a> <a href="#531029" title="Types.this.Type">bound</a>.<a href="#442014" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#494015" title="List[Types.this.Symbol]">tparams</a>, <a href="#494014" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            <span class="keyword">for</span> <span class="delimiter">(</span>tparam2 &lt;- <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span>
              <a href="#531169" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a>.<a href="#442018" title="=&gt; Types.this.Type">dealias</a> <span class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> TypeRef<a href="#531171" title="Unit" id="531176" class="delimiter">(</a>_, <a href="#531021" title="Unit" id="531179">`tparam`</a>, _<span class="delimiter">)</span> =&gt;
                  <a href="#531020" title="Types.this.TypeVar">tvar</a> <a href="#531180" title="(x: Unit)Unit">addLoBound</a> <a href="#531169" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a>.<a href="#442014" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#494015" title="List[Types.this.Symbol]">tparams</a>, <a href="#494014" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
                <span class="keyword">case</span> _ =&gt;
              <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <a href="#531020" title="Types.this.TypeVar">tvar</a>.<a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470266" title="(x$1: Types.this.Type)Unit">inst</a> = <a href="#516490" title="Types.this.NoType.type">NoType</a> // necessary because hibounds/lobounds may contain tvar

        //println(&quot;solving &quot;+tvar+&quot; &quot;+up+&quot; &quot;+(if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds)+((if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds) map (_.widen)))

        <a href="#531020" title="Types.this.TypeVar">tvar</a> <a href="#470176" title="(tp: Types.this.Type)Unit">setInst</a> <span class="delimiter">(</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#531028" title="Boolean">up</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#494018" title="Int">depth</a> <a href="../../Int.scala.html#57898" title="(x: Int)Boolean">!=</a> <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span> <a href="#441569" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#531020" title="Types.this.TypeVar">tvar</a>.<a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470259" title="=&gt; List[Types.this.Type]">hiBounds</a>, <a href="#494018" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#441568" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#531020" title="Types.this.TypeVar">tvar</a>.<a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470259" title="=&gt; List[Types.this.Type]">hiBounds</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#494018" title="Int">depth</a> <a href="../../Int.scala.html#57898" title="(x: Int)Boolean">!=</a> <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span> <a href="#441560" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#531020" title="Types.this.TypeVar">tvar</a>.<a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470258" title="=&gt; List[Types.this.Type]">loBounds</a>, <a href="#494018" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#441559" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#531020" title="Types.this.TypeVar">tvar</a>.<a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470258" title="=&gt; List[Types.this.Type]">loBounds</a><span class="delimiter">)</span>
          <span class="delimiter">}</span><span class="delimiter">)</span>

        //Console.println(&quot;solving &quot;+tvar+&quot; &quot;+up+&quot; &quot;+(if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds)+((if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds) map (_.widen))+&quot; = &quot;+tvar.constr.inst)//@MDEBUG
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    // println(&quot;solving &quot;+tvars+&quot;/&quot;+tparams+&quot;/&quot;+(tparams map (_.info)))
    <a href="util/Collections.scala.html#440731" title="(xs1: List[Types.this.TypeVar], xs2: List[Types.this.Symbol], xs3: List[Int])(f: (Types.this.TypeVar, Types.this.Symbol, Int) =&gt; Unit)Unit">foreach3</a><span class="delimiter">(</span><a href="#494014" title="List[Types.this.TypeVar]">tvars</a>, <a href="#494015" title="List[Types.this.Symbol]">tparams</a>, <a href="#494016" title="List[Int]">variances</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#531019" title="(tvar: Types.this.TypeVar, tparam: Types.this.Symbol, variance: Int)Unit">solveOne</a><span class="delimiter">)</span>
    <a href="#494014" title="List[Types.this.TypeVar]">tvars</a> <a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.TypeVar =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a title="Types.this.TypeVar" id="531273">tvar</a> =&gt; <a href="#531273" title="Types.this.TypeVar">tvar</a>.<a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470264" title="(tp: Types.this.Type)Boolean">isWithinBounds</a><span class="delimiter">(</span><a href="#531273" title="Types.this.TypeVar">tvar</a>.<a href="#470165" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#470266" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Do type arguments `targs` conform to formal parameters `tparams`?
   */
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])Boolean" id="441537">isWithinBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="521424">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="521425">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="521426">tparams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="521427">targs</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="List[Types.this.TypeBounds]" id="531274">bounds</a> = <a href="#441538" title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]">instantiatedBounds</a><span class="delimiter">(</span><a href="#521424" title="Types.this.Type">pre</a>, <a href="#521425" title="Types.this.Symbol">owner</a>, <a href="#521426" title="List[Types.this.Symbol]">tparams</a>, <a href="#521427" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#521427" title="List[Types.this.Type]">targs</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#531286" title="Types.this.Type">_</a>.<a href="#442085" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#531274" title="List[Types.this.TypeBounds]">bounds</a> = <a href="AnnotationCheckers.scala.html#440541" title="(bounds: List[Types.this.TypeBounds], tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]">adaptBoundsToAnnotations</a><span class="delimiter">(</span><a href="#531274" title="List[Types.this.TypeBounds]">bounds</a>, <a href="#521426" title="List[Types.this.Symbol]">tparams</a>, <a href="#521427" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>
    <span class="delimiter">(</span><a href="#531274" title="List[Types.this.TypeBounds]">bounds</a> <a href="../../collection/LinearSeqLike.scala.html#76110" title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.TypeBounds, Types.this.Type) =&gt; Boolean)Boolean">corresponds</a> <a href="#521427" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#531313" title="Types.this.TypeBounds">_</a> <a href="#448306" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#531314" title="Types.this.Type">_</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]" id="441538">instantiatedBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="531275">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="531276">owner</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="531277">tparams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="531278">targs</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.TypeBounds]">List</a><span class="delimiter">[</span>TypeBounds<span class="delimiter">]</span> =
    <a href="#531277" title="List[Types.this.Symbol]">tparams</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.TypeBounds)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.TypeBounds,List[Types.this.TypeBounds]])List[Types.this.TypeBounds]">map</a> <span class="delimiter">(</span><a href="#531331" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442037" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#531275" title="Types.this.Type">pre</a>, <a href="#531276" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>.<a href="#442014" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#531277" title="List[Types.this.Symbol]">tparams</a>, <a href="#531278" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>

// Lubs and Glbs ---------------------------------------------------------

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(btsMap: Map[Types.this.Type,List[Types.this.Type]], depth: Int)Unit" id="441539">printLubMatrix</a><span class="delimiter">(</span><a title="Map[Types.this.Type,List[Types.this.Type]]" id="531367">btsMap</a>: <a href="../../collection/immutable/Map.scala.html#11605" title="Map[Types.this.Type,List[Types.this.Type]]">Map</a><span class="delimiter">[</span>Type, List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Int" id="531368">depth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">import</span> scala.tools.nsc.util.TableDef
    <span class="keyword">import</span> <a href="../../tools/nsc/util/TableDef.scala.html#51877" title="scala.tools.nsc.util.TableDef.type">TableDef</a>.Column
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)String" id="531372">str</a><span class="delimiter">(</span><a title="Types.this.Type" id="531388">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#531388" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="String" id="531393">s</a> = <span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#531388" title="Types.this.Type">tp</a><span class="delimiter">)</span>.<span title="(x$1: String, x$2: String)String">replaceAll</span><span class="delimiter">(</span><span title="String(&quot;[\\w.]+\\.(\\w+)&quot;)" class="string">&quot;&quot;&quot;[\w.]+\.(\w+)&quot;&quot;&quot;</span>, <span title="String(&quot;$1&quot;)" class="string">&quot;$1&quot;</span><span class="delimiter">)</span>
        <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#531393" title="String">s</a>.<span title="()Int">length</span> <a href="../../Int.scala.html#57905" title="(x: Int)Boolean">&lt;</a> <span title="Int(60)" class="int">60</span><span class="delimiter">)</span> <a href="#531393" title="String">s</a>
        <span class="keyword">else</span> <span class="delimiter">(</span><a href="../../Predef.scala.html#8578" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">s</a> <a href="../../collection/IndexedSeqOptimized.scala.html#60120" title="(n: Int)String">take</a> <span title="Int(57)" class="int">57</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;...&quot;)" class="string">&quot;...&quot;</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="List[(Types.this.Type, List[Types.this.Type])]" id="531373">sorted</a>       = <a href="#531367" title="Map[Types.this.Type,List[Types.this.Type]]">btsMap</a>.<a href="../../collection/TraversableOnce.scala.html#59174" title="=&gt; List[(Types.this.Type, List[Types.this.Type])]">toList</a>.<a href="../../collection/SeqLike.scala.html#59826" title="(lt: ((Types.this.Type, List[Types.this.Type]), (Types.this.Type, List[Types.this.Type])) =&gt; Boolean)List[(Types.this.Type, List[Types.this.Type])]">sortWith</a><span class="delimiter">(</span><span class="delimiter">(</span><a title="(Types.this.Type, List[Types.this.Type])" id="531463">x</a>, <a title="(Types.this.Type, List[Types.this.Type])" id="531464">y</a><span class="delimiter">)</span> =&gt; <a href="#531463" title="(Types.this.Type, List[Types.this.Type])">x</a>.<a href="../../Tuple2.scala.html#61506" title="=&gt; Types.this.Type">_1</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#443466" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#531464" title="(Types.this.Type, List[Types.this.Type])">y</a>.<a href="../../Tuple2.scala.html#61506" title="=&gt; Types.this.Type">_1</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Int" id="531374">maxSeqLength</a> = <a href="#531373" title="List[(Types.this.Type, List[Types.this.Type])]">sorted</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: ((Types.this.Type, List[Types.this.Type])) =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Type, List[Types.this.Type])],Int,List[Int]])List[Int]">map</a> <span class="delimiter">(</span><a href="#531482" title="(Types.this.Type, List[Types.this.Type])">_</a>.<a href="../../Tuple2.scala.html#61508" title="=&gt; List[Types.this.Type]">_2</a>.<a href="../../collection/SeqLike.scala.html#59711" title="=&gt; Int">size</a><span class="delimiter">)</span> <a href="../../collection/TraversableOnce.scala.html#59152" title="(implicit cmp: Ordering[Int])Int">max</a>
    <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="531375">padded</a>       = <a href="#531373" title="List[(Types.this.Type, List[Types.this.Type])]">sorted</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: ((Types.this.Type, List[Types.this.Type])) =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Type, List[Types.this.Type])],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</a> <span class="delimiter">(</span><a href="#531585" title="(Types.this.Type, List[Types.this.Type])">_</a>.<a href="../../Tuple2.scala.html#61508" title="=&gt; List[Types.this.Type]">_2</a>.<a href="../../collection/SeqLike.scala.html#59815" title="(len: Int, elem: Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">padTo</a><a href="../../collection/immutable/List.scala.html#63282" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.Type,List[Types.this.Type]]" class="delimiter">(</a><a href="#531374" title="Int">maxSeqLength</a>, <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="531376">transposed</a>   = <a href="#531375" title="List[List[Types.this.Type]]">padded</a>.<a href="../../collection/generic/GenericTraversableTemplate.scala.html#59389" title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.GenTraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</a>

    <span class="keyword">val</span> <a title="List[scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]]" id="531377">columns</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]]">List</a><span class="delimiter">[</span>Column<span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="util/Collections.scala.html#440714" title="(xs: List[(Types.this.Type, List[Types.this.Type])])(f: ((Types.this.Type, List[Types.this.Type]), Int) =&gt; scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]])List[scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]]">mapWithIndex</a><span class="delimiter">(</span><a href="#531373" title="List[(Types.this.Type, List[Types.this.Type])]">sorted</a><span class="delimiter">)</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractFunction2[(Types.this.Type, List[Types.this.Type]),Int,scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]] with Serializable" id="531706" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><span class="delimiter">(</span>k, v<span class="delimiter">)</span>, idx<span class="delimiter">)</span> =&gt;
        <a href="../../tools/nsc/util/TableDef.scala.html#531724" title="(name: String, f: List[Types.this.Type] =&gt; Any, left: Boolean)scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]">Column</a><a href="#531771" title="(x: scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]])scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]" class="delimiter">(</a><a href="#531372" title="(tp: Types.this.Type)String">str</a><span class="delimiter">(</span>k<span class="delimiter">)</span>, <span class="delimiter">(</span>xs: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="#531372" title="(tp: Types.this.Type)String">str</a><span class="delimiter">(</span><a href="../../collection/LinearSeqOptimized.scala.html#76165" title="(n: Int)Types.this.Type">xs</a><span class="delimiter">(</span>idx<span class="delimiter">)</span><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="scala.tools.nsc.util.TableDef[List[Types.this.Type]]" id="531378">tableDef</a> = <a href="../../tools/nsc/util/TableDef.scala.html#531385" title="(cols: tools.nsc.util.TableDef.Column[List[Types.this.Type]]*)scala.tools.nsc.util.TableDef[List[Types.this.Type]]">TableDef</a><span class="delimiter">(</span><a href="#531377" title="List[scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]]">columns</a>: _*<span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="tableDef.Table" id="531379">formatted</a> = <a href="#531378" title="scala.tools.nsc.util.TableDef[List[Types.this.Type]]">tableDef</a>.<a href="../../tools/nsc/util/TableDef.scala.html#531814" title="(rows: Seq[List[Types.this.Type]])tableDef.Table">table</a><span class="delimiter">(</span><a href="#531376" title="List[List[Types.this.Type]]">transposed</a><span class="delimiter">)</span>
    <a href="../../Predef.scala.html#8489" title="(x: Any)Unit">println</a><span class="delimiter">(</span><span title="String(&quot;** Depth is &quot;)" class="string">&quot;** Depth is &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#531368" title="Int">depth</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#531379" title="tableDef.Table">formatted</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** From a list of types, find any which take type parameters
   *  where the type parameter bounds contain references to other
   *  any types in the list (including itself.)
   *
   *  @return List of symbol pairs holding the recursive type
   *    parameter and the parameter which references it.
   */
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[(Types.this.Symbol, Types.this.Symbol)]" id="441540">findRecursiveBounds</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="531854">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[(Types.this.Symbol, Types.this.Symbol)]">List</a><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="List[(Types.this.Symbol, Types.this.Symbol)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#531854" title="List[Types.this.Type]">ts</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="531856">sym</a> = <a href="#531854" title="List[Types.this.Type]">ts</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>
      <a href="../../Predef.scala.html#8464" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#531854" title="List[Types.this.Type]">ts</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Type]">tail</a> <a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a href="#531868" title="Types.this.Type">_</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#531856" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>, <a href="#531854" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="531893">p</a> &lt;- <a href="#531856" title="Types.this.Symbol">sym</a>.<a href="../../collection/TraversableLike.scala.html#58976" title="(f: Types.this.Symbol =&gt; scala.collection.GenTraversableOnce[(Types.this.Symbol, Types.this.Symbol)])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],(Types.this.Symbol, Types.this.Symbol),List[(Types.this.Symbol, Types.this.Symbol)]])List[(Types.this.Symbol, Types.this.Symbol)]">typeParams</a> ; <a title="Types.this.Symbol" id="531910">in</a> &lt;- <a href="#531856" title="Types.this.Symbol">sym</a>.<a href="../../collection/generic/FilterMonadic.scala.html#59072" title="(f: Types.this.Symbol =&gt; (Types.this.Symbol, Types.this.Symbol))(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],(Types.this.Symbol, Types.this.Symbol),List[(Types.this.Symbol, Types.this.Symbol)]])List[(Types.this.Symbol, Types.this.Symbol)]">typeParams</a> ; <span class="keyword">if</span> <a href="#531910" title="Types.this.Symbol">in</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a> <a href="#442056" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#531893" title="Types.this.Symbol">p</a><span class="delimiter">)</span> <span class="keyword">yield</span>
        <a href="../../Predef.scala.html#8484" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">p</a> <a href="../../Predef.scala.html#63591" title="(y: Types.this.Symbol)(Types.this.Symbol, Types.this.Symbol)">-&gt;</a> <a href="#531910" title="Types.this.Symbol">in</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Given a matrix `tsBts` whose columns are basetype sequences (and the symbols `tsParams` that should be interpreted as type parameters in this matrix),
   * compute its least sorted upwards closed upper bound relative to the following ordering &lt;= between lists of types:
   *
   *    xs &lt;= ys   iff   forall y in ys exists x in xs such that x &lt;: y
   *
   *  @arg tsParams for each type in the original list of types `ts0`, its list of type parameters (if that type is a type constructor)
   *                (these type parameters may be referred to by type arguments in the BTS column of those types,
   *                and must be interpreted as bound variables; i.e., under a type lambda that wraps the types that refer to these type params)
   *  @arg tsBts    a matrix whose columns are basetype sequences
   *                the first row is the original list of types for which we're computing the lub
   *                  (except that type constructors have been applied to their dummyArgs)
   *  @See baseTypeSeq  for a definition of sorted and upwards closed.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]" id="441541">lubList</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="531986">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="531987">depth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    // Matching the type params of one of the initial types means dummies.
    <span class="keyword">val</span> <a title="List[List[Types.this.Symbol]]" id="531989">initialTypeParams</a> = <a href="#531986" title="List[Types.this.Type]">ts</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; List[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Symbol],List[List[Types.this.Symbol]]])List[List[Types.this.Symbol]]">map</a> <span class="delimiter">(</span><a href="#532011" title="Types.this.Type">_</a>.<a href="#442011" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(xs: List[Types.this.Type])Boolean" id="531990">isHotForTs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="532039">xs</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#531989" title="List[List[Types.this.Symbol]]">initialTypeParams</a> <a href="../../collection/SeqLike.scala.html#59768" title="(elem: Any)Boolean">contains</a> <a href="#532039" title="List[Types.this.Type]">xs</a>.<a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,Any])Any">map</a><a href="../../collection/immutable/List.scala.html#63282" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.Symbol,List[Types.this.Symbol]]" class="delimiter">(</a><a href="#532056" title="Types.this.Type">_</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="531991">elimHigherOrderTypeParam</a><span class="delimiter">(</span><a title="Types.this.Type" id="532084">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#532084" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> TypeRef<a href="#532089" title="Types.this.Type" id="532091" class="delimiter">(</a>pre, sym, args<span class="delimiter">)</span> <span class="keyword">if</span> args.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#531990" title="(xs: List[Types.this.Type])Boolean">isHotForTs</a><span class="delimiter">(</span>args<span class="delimiter">)</span> =&gt; <a href="#532084" title="Types.this.Type">tp</a>.<a href="#532092" title="(x: Types.this.Type)Types.this.Type">typeConstructor</a>
      <span class="keyword">case</span> _                                                            =&gt; <a href="#532092" title="(x: Types.this.Type)Types.this.Type">tp</a>
    <span class="delimiter">}</span>
    <span class="keyword">var</span> <a title="Int" id="531992">lubListDepth</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">def</span> <a title="(tsBts: List[List[Types.this.Type]])List[Types.this.Type]" id="531993">loop</a><span class="delimiter">(</span><a title="List[List[Types.this.Type]]" id="532097">tsBts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[List[Types.this.Type]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="#531992" title="Int">lubListDepth</a> <a href="../../Int.scala.html#57948" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>

      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#532097" title="List[List[Types.this.Type]]">tsBts</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#532097" title="List[List[Types.this.Type]]">tsBts</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: List[Types.this.Type] =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#532110" title="List[Types.this.Type]">_</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a>
      <span class="keyword">else</span> <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#532097" title="List[List[Types.this.Type]]">tsBts</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[List[Types.this.Type]]">tail</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#532097" title="List[List[Types.this.Type]]">tsBts</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; List[Types.this.Type]">head</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        // ts0 is the 1-dimensional frontier of symbols cutting through 2-dimensional tsBts.
        // Invariant: all symbols &quot;under&quot; (closer to the first row) the frontier
        // are smaller (according to _.isLess) than the ones &quot;on and beyond&quot; the frontier
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="532112">ts0</a>  = <a href="#532097" title="List[List[Types.this.Type]]">tsBts</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: List[Types.this.Type] =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#532130" title="List[Types.this.Type]">_</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a><span class="delimiter">)</span>

        // Is the frontier made up of types with the same symbol?
        <span class="keyword">val</span> <a title="Boolean" id="532113">isUniformFrontier</a> = <span class="delimiter">(</span><a href="#532112" title="List[Types.this.Type]">ts0</a>: @<a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type] @unchecked">unchecked</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> t <a href="#532177" title="Boolean" id="532178">::</a> ts  =&gt; ts <a href="#532179" title="(x: Boolean)Boolean">forall</a> <span class="delimiter">(</span><a href="#532170" title="Types.this.Type">_</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> t.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        // Produce a single type for this frontier by merging the prefixes and arguments of those
        // typerefs that share the same symbol: that symbol is the current maximal symbol for which
        // the invariant holds, i.e., the one that conveys most information wrt subtyping. Before
        // merging, strip targs that refer to bound tparams (when we're computing the lub of type
        // constructors.) Also filter out all types that are a subtype of some other type.
        <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#532113" title="Boolean">isUniformFrontier</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456420" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#441214" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[(Types.this.Symbol, Types.this.Symbol)]" id="532187">fbounds</a> = <a href="#441540" title="(ts: List[Types.this.Type])List[(Types.this.Symbol, Types.this.Symbol)]">findRecursiveBounds</a><span class="delimiter">(</span><a href="#532112" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#532187" title="List[(Types.this.Symbol, Types.this.Symbol)]">fbounds</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="../../Predef.scala.html#8489" title="(x: Any)Unit">println</a><span class="delimiter">(</span><span title="String(&quot;Encountered &quot;)" class="string">&quot;Encountered &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#532187" title="List[(Types.this.Symbol, Types.this.Symbol)]">fbounds</a>.<a href="../../collection/SeqLike.scala.html#59711" title="=&gt; Int">size</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; recursive bounds while lubbing &quot;)" class="string">&quot; recursive bounds while lubbing &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#532112" title="List[Types.this.Type]">ts0</a>.<a href="../../collection/SeqLike.scala.html#59711" title="=&gt; Int">size</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; types.&quot;)" class="string">&quot; types.&quot;</span><span class="delimiter">)</span>
              <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span>p0, p1<span class="delimiter">)</span> &lt;- <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: ((Types.this.Symbol, Types.this.Symbol)) =&gt; Unit)Unit">fbounds</a><span class="delimiter">)</span> <a href="#532227" title="(x: Unit)Unit" class="delimiter">{</a>
                <span class="keyword">val</span> <a title="String" id="532216">desc</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span>p0 <span title="(x$1: AnyRef)Boolean">==</span> p1<span class="delimiter">)</span> <span title="String(&quot;its own bounds&quot;)" class="string">&quot;its own bounds&quot;</span> <span class="keyword">else</span> <span title="String(&quot;the bounds of &quot;)" class="string">&quot;the bounds of &quot;</span> <span title="(x$1: Any)String">+</span> p1

                <a href="../../Predef.scala.html#8489" title="(x: Any)Unit">println</a><span class="delimiter">(</span><span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span> <span title="(x$1: Any)String">+</span> p0.<a href="Symbols.scala.html#443562" title="=&gt; String">fullLocationString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; appears in &quot;)" class="string">&quot; appears in &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#532216" title="String">desc</a><span class="delimiter">)</span>
                <a href="../../Predef.scala.html#8489" title="(x: Any)Unit">println</a><span class="delimiter">(</span><span title="String(&quot;    &quot;)" class="string">&quot;    &quot;</span> <span title="(x$1: Any)String">+</span> p1 <span title="(x$1: Any)String">+</span> <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)String">+</span> p1.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
              <a href="../../Predef.scala.html#8489" title="(x: Any)Unit">println</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="532183">tails</a> = <a href="#532097" title="List[List[Types.this.Type]]">tsBts</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: List[Types.this.Type] =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</a> <span class="delimiter">(</span><a href="#532254" title="List[Types.this.Type]">_</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Type]">tail</a><span class="delimiter">)</span>
          <a href="#441573" title="(tps: List[Types.this.Type], variance: Int, depth: Int)Option[Types.this.Type]">mergePrefixAndArgs</a><a href="../../Option.scala.html#64115" title="=&gt; Types.this.Type" class="delimiter">(</a><a href="#441547" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">elimSub</a><span class="delimiter">(</span><a href="#532112" title="List[Types.this.Type]">ts0</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#531991" title="(tp: Types.this.Type)Types.this.Type">elimHigherOrderTypeParam</a>, <a href="#531987" title="Int">depth</a><span class="delimiter">)</span>, <span title="Int(1)" class="int">1</span>, <a href="#531987" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> Some<a href="#532338" title="List[Types.this.Type]" id="532339" class="delimiter">(</a>tp<span class="delimiter">)</span> =&gt; tp <a href="#532340" title="(x: List[Types.this.Type])List[Types.this.Type]">::</a> <a href="#531993" title="(tsBts: List[List[Types.this.Type]])List[Types.this.Type]">loop</a><span class="delimiter">(</span><a href="#532183" title="List[List[Types.this.Type]]">tails</a><span class="delimiter">)</span>
            <span class="keyword">case</span> _        =&gt; <a href="#531993" title="(tsBts: List[List[Types.this.Type]])List[Types.this.Type]">loop</a><a href="#532340" title="(x: List[Types.this.Type])List[Types.this.Type]" class="delimiter">(</a><a href="#532183" title="List[List[Types.this.Type]]">tails</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          // frontier is not uniform yet, move it beyond the current minimal symbol;
          // lather, rinSe, repeat
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="532345">sym</a>    = <a href="#441542" title="(tps: List[Types.this.Type])Types.this.Symbol">minSym</a><span class="delimiter">(</span><a href="#532112" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="532346">newtps</a> = <a href="#532097" title="List[List[Types.this.Type]]">tsBts</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: List[Types.this.Type] =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</a> <span class="delimiter">(</span><a title="List[Types.this.Type]" id="532365">ts</a> =&gt; <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#532365" title="List[Types.this.Type]">ts</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#532345" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#532365" title="List[Types.this.Type]">ts</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Type]">tail</a> <span class="keyword">else</span> <a href="#532365" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#441214" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="String" id="532399">str</a> = <span class="delimiter">(</span><a href="#532346" title="List[List[Types.this.Type]]">newtps</a>.<a href="../../collection/IterableLike.scala.html#59514" title="(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],(List[Types.this.Type], Int),List[(List[Types.this.Type], Int)]])List[(List[Types.this.Type], Int)]">zipWithIndex</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: ((List[Types.this.Type], Int)) =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[(List[Types.this.Type], Int)],String,List[String]])List[String]">map</a> <a title="anonymous class $anonfun extends scala.runtime.AbstractFunction1[(List[Types.this.Type], Int),String] with Serializable" id="532459" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span>tps, idx<span class="delimiter">)</span> =&gt;
              tps.<a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],String,List[String]])List[String]">map</a><a href="../../collection/immutable/List.scala.html#63282" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,String,List[String]]" class="delimiter">(</a><span title="String(&quot;        &quot;)" class="string">&quot;        &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#532481" title="Types.this.Type">_</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a><a href="#532514" title="(x: String)String" class="delimiter">(</a><span title="String(&quot;   (&quot;)" class="string">&quot;   (&quot;</span> <span title="(x$1: Any)String">+</span> idx <span title="(x$1: Any)String">+</span> <span title="String(&quot;)\n&quot;)" class="string">&quot;)\n&quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span>
            <span class="delimiter">}</span><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#59190" title="(sep: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>

            <a href="../../Predef.scala.html#8489" title="(x: Any)Unit">println</a><span class="delimiter">(</span><span title="String(&quot;Frontier(\n&quot;)" class="string">&quot;Frontier(\n&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#532399" title="String">str</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
            <a href="#441539" title="(btsMap: Map[Types.this.Type,List[Types.this.Type]], depth: Int)Unit">printLubMatrix</a><span class="delimiter">(</span><a href="#531986" title="List[Types.this.Type]">ts</a> <a href="../../collection/IterableLike.scala.html#59486" title="(that: scala.collection.GenIterable[List[Types.this.Type]])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],(Types.this.Type, List[Types.this.Type]),List[(Types.this.Type, List[Types.this.Type])]])List[(Types.this.Type, List[Types.this.Type])]">zip</a> <a href="#532097" title="List[List[Types.this.Type]]">tsBts</a> <a href="../../collection/TraversableOnce.scala.html#59184" title="(implicit ev: &lt;:&lt;[(Types.this.Type, List[Types.this.Type]),(Types.this.Type, List[Types.this.Type])])scala.collection.immutable.Map[Types.this.Type,List[Types.this.Type]]">toMap</a>, <a href="#531992" title="Int">lubListDepth</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>

          <a href="#531993" title="(tsBts: List[List[Types.this.Type]])List[Types.this.Type]">loop</a><span class="delimiter">(</span><a href="#532346" title="List[List[Types.this.Type]]">newtps</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="531994">initialBTSes</a> = <a href="#531986" title="List[Types.this.Type]">ts</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</a> <span class="delimiter">(</span><a href="#532647" title="Types.this.Type">_</a>.<a href="#442066" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#447204" title="=&gt; List[Types.this.Type]">toList</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#441214" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span>
      <a href="#441539" title="(btsMap: Map[Types.this.Type,List[Types.this.Type]], depth: Int)Unit">printLubMatrix</a><span class="delimiter">(</span><a href="#531986" title="List[Types.this.Type]">ts</a> <a href="../../collection/IterableLike.scala.html#59486" title="(that: scala.collection.GenIterable[List[Types.this.Type]])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],(Types.this.Type, List[Types.this.Type]),List[(Types.this.Type, List[Types.this.Type])]])List[(Types.this.Type, List[Types.this.Type])]">zip</a> <a href="#531994" title="List[List[Types.this.Type]]">initialBTSes</a> <a href="../../collection/TraversableOnce.scala.html#59184" title="(implicit ev: &lt;:&lt;[(Types.this.Type, List[Types.this.Type]),(Types.this.Type, List[Types.this.Type])])scala.collection.immutable.Map[Types.this.Type,List[Types.this.Type]]">toMap</a>, <a href="#531987" title="Int">depth</a><span class="delimiter">)</span>

    <a href="#531993" title="(tsBts: List[List[Types.this.Type]])List[Types.this.Type]">loop</a><span class="delimiter">(</span><a href="#531994" title="List[List[Types.this.Type]]">initialBTSes</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** The minimal symbol (wrt Symbol.isLess) of a list of types */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type])Types.this.Symbol" id="441542">minSym</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="532347">tps</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> =
    <span class="delimiter">(</span><a href="#532347" title="List[Types.this.Type]">tps</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="../../collection/TraversableOnce.scala.html#59107" title="(z: Types.this.Symbol)(op: (Types.this.Symbol, Types.this.Type) =&gt; Types.this.Symbol)Types.this.Symbol">/:</a> <a href="#532347" title="List[Types.this.Type]">tps</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Type]">tail</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="delimiter">(</span><a title="Types.this.Symbol" id="532740">sym1</a>, <a title="Types.this.Type" id="532741">tp2</a><span class="delimiter">)</span> =&gt; <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#532741" title="Types.this.Type">tp2</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#443466" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#532740" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> <a href="#532741" title="Types.this.Type">tp2</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span class="keyword">else</span> <a href="#532740" title="Types.this.Symbol">sym1</a>
    <span class="delimiter">}</span>

  /** A minimal type list which has a given list of types as its base type sequence */
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="441543">spanningTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="532742">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#532742" title="List[Types.this.Type]">ts</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="532787">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; List<a href="#532783" title="(x: List[Types.this.Type])List[Types.this.Type]" class="delimiter">(</a><span class="delimiter">)</span>
    <span class="keyword">case</span> first <a href="#532778" title="List[Types.this.Type]" id="532782">::</a> rest =&gt;
      first <a href="#532783" title="(x: List[Types.this.Type])List[Types.this.Type]">::</a> <a href="#441543" title="(ts: List[Types.this.Type])List[Types.this.Type]">spanningTypes</a><span class="delimiter">(</span>
        rest <a href="../../collection/TraversableLike.scala.html#58981" title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</a> <span class="delimiter">(</span><a title="Types.this.Type" id="532773">t</a> =&gt; <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a>first.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443469" title="(that: Types.this.Symbol)Boolean">isSubClass</a><span class="delimiter">(</span><a href="#532773" title="Types.this.Type">t</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Eliminate from list of types all elements which are a supertype
   *  of some other element of the list. */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="441544">elimSuper</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="532792">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#532792" title="List[Types.this.Type]">ts</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="532849">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; List<a href="#532845" title="(x: List[Types.this.Type])List[Types.this.Type]" class="delimiter">(</a><span class="delimiter">)</span>
    <span class="keyword">case</span> t <a href="#532840" title="List[Types.this.Type]" id="532844">::</a> ts1 =&gt;
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="532819">rest</a> = <a href="#441544" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSuper</a><span class="delimiter">(</span>ts1 <a href="../../collection/TraversableLike.scala.html#58981" title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</a> <span class="delimiter">(</span><a title="Types.this.Type" id="532823">t1</a> =&gt; <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span>t <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#532823" title="Types.this.Type">t1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#532819" title="List[Types.this.Type]">rest</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a title="Types.this.Type" id="532831">t1</a> =&gt; <a href="#532831" title="Types.this.Type">t1</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> t<span class="delimiter">)</span><span class="delimiter">)</span> <a href="#532819" title="List[Types.this.Type]">rest</a> <span class="keyword">else</span> t <a href="../../collection/immutable/List.scala.html#63643" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#532819" title="List[Types.this.Type]">rest</a>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(t: Types.this.Type)Types.this.Type" id="441545">elimAnonymousClass</a><span class="delimiter">(</span><a title="Types.this.Type" id="532854">t</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#532854" title="Types.this.Type">t</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> TypeRef<a href="#532863" title="Types.this.Type" id="532866" class="delimiter">(</a>pre, clazz, <a href="../../collection/immutable/List.scala.html#11552" title="Types.this.Type" id="532868">Nil</a><span class="delimiter">)</span> <span class="keyword">if</span> clazz.<a href="Symbols.scala.html#443240" title="=&gt; Boolean">isAnonymousClass</a> =&gt;
      clazz.<a href="Symbols.scala.html#443450" title="=&gt; Types.this.Type">classBound</a>.<a href="#442037" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><a href="#532869" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>pre, clazz.<a href="Symbols.scala.html#443379" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="keyword">case</span> _ =&gt;
      <a href="#532869" title="(x: Types.this.Type)Types.this.Type">t</a>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(t: Types.this.Type)Types.this.Type" id="441546">elimRefinement</a><span class="delimiter">(</span><a title="Types.this.Type" id="532877">t</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#532877" title="Types.this.Type">t</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> RefinedType<a href="#532887" title="Types.this.Type" id="532889" class="delimiter">(</a>parents, decls<span class="delimiter">)</span> <span class="keyword">if</span> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a>decls.<a href="Scopes.scala.html#447327" title="=&gt; Boolean">isEmpty</a> =&gt; <a href="#441376" title="(tps: List[Types.this.Type])Types.this.Type">intersectionType</a><a href="#532890" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>parents<span class="delimiter">)</span>
    <span class="keyword">case</span> _                                             =&gt; <a href="#532890" title="(x: Types.this.Type)Types.this.Type">t</a>
  <span class="delimiter">}</span>

  /** Eliminate from list of types all elements which are a subtype
   *  of some other element of the list. */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]" id="441547">elimSub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="532282">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="532283">depth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="532895">elimSub0</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="532897">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#532897" title="List[Types.this.Type]">ts</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="532959">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; List<a href="#532955" title="(x: List[Types.this.Type])List[Types.this.Type]" class="delimiter">(</a><span class="delimiter">)</span>
      <span class="keyword">case</span> t <a href="#532950" title="List[Types.this.Type]" id="532954">::</a> ts1 =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="532923">rest</a> = <a href="#532895" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSub0</a><span class="delimiter">(</span>ts1 <a href="../../collection/TraversableLike.scala.html#58981" title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</a> <span class="delimiter">(</span><a title="Types.this.Type" id="532927">t1</a> =&gt; <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#441513" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#532927" title="Types.this.Type">t1</a>, t, <a href="#441213" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#532283" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#532923" title="List[Types.this.Type]">rest</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a title="Types.this.Type" id="532938">t1</a> =&gt; <a href="#441513" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span>t, <a href="#532938" title="Types.this.Type">t1</a>, <a href="#441213" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#532283" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#532923" title="List[Types.this.Type]">rest</a> <span class="keyword">else</span> t <a href="../../collection/immutable/List.scala.html#63643" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#532923" title="List[Types.this.Type]">rest</a>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="List[Types.this.Type]" id="532896">ts0</a> = <a href="#532895" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSub0</a><span class="delimiter">(</span><a href="#532282" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
    <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#532896" title="List[Types.this.Type]">ts0</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#532896" title="List[Types.this.Type]">ts0</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Type]">tail</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#532896" title="List[Types.this.Type]">ts0</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="532965">ts1</a> = <a href="#532896" title="List[Types.this.Type]">ts0</a> <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</a> <span class="delimiter">(</span><a title="Types.this.Type" id="532972">t</a> =&gt; <a href="#441545" title="(t: Types.this.Type)Types.this.Type">elimAnonymousClass</a><span class="delimiter">(</span><a href="#532972" title="Types.this.Type">t</a>.<a href="#441989" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#532965" title="List[Types.this.Type]">ts1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#532896" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span> <a href="#532896" title="List[Types.this.Type]">ts0</a>
      <span class="keyword">else</span> <a href="#441547" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">elimSub</a><span class="delimiter">(</span><a href="#532965" title="List[Types.this.Type]">ts1</a>, <a href="#532283" title="Int">depth</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])(List[Types.this.Type], List[Types.this.Symbol])" id="441548">stripExistentialsAndTypeVars</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="532974">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Tuple2.scala.html#1222" title="(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</a>List<span class="delimiter">[</span>Type<span class="delimiter">]</span>, List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="532976">quantified</a> = <a href="#532974" title="List[Types.this.Type]">ts</a> <a href="../../collection/TraversableLike.scala.html#58976" title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">flatMap</a> <a title="anonymous class $anonfun extends scala.runtime.AbstractFunction1[Types.this.Type,List[Types.this.Symbol]] with Serializable" id="532995" class="delimiter">{</a>
      <span class="keyword">case</span> ExistentialType<a href="#533007" title="List[Types.this.Symbol]" id="533010" class="delimiter">(</a>qs, _<span class="delimiter">)</span> =&gt; <a href="#533011" title="(x: List[Types.this.Symbol])List[Types.this.Symbol]">qs</a>
      <span class="keyword">case</span> t =&gt; List<a href="#533011" title="(x: List[Types.this.Symbol])List[Types.this.Symbol]" class="delimiter">(</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="532977">stripType</a><span class="delimiter">(</span><a title="Types.this.Type" id="533053">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#533053" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> ExistentialType<a href="#533064" title="Types.this.Type" id="533067" class="delimiter">(</a>_, res<span class="delimiter">)</span> =&gt;
        <a href="#533072" title="(x: Types.this.Type)Types.this.Type">res</a>
      <span class="keyword">case</span> tv@<a href="#470205" title="Option[(Types.this.Type, Types.this.TypeConstraint)]" id="533078">TypeVar</a><a href="#533064" title="Types.this.Type" id="533070" class="delimiter">(</a>_, constr<span class="delimiter">)</span> =&gt;
        <a href="#533072" title="(x: Types.this.Type)Types.this.Type" class="keyword">if</a> <span class="delimiter">(</span>tv.<a href="#470167" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> constr.<a href="#470266" title="=&gt; Types.this.Type">inst</a>
        <span class="keyword">else</span> <span title="Types.this.TypeVar" class="keyword">if</span> <span class="delimiter">(</span>tv.<a href="#470160" title="=&gt; Boolean">untouchable</a><span class="delimiter">)</span> tv
        <span class="keyword">else</span> <a href="SymbolTable.scala.html#440549" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><span title="String(&quot;trying to do lub/glb of typevar &quot;)" class="string">&quot;trying to do lub/glb of typevar &quot;</span><span title="(x$1: Any)String">+</span><a href="#533053" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> t =&gt; <a href="#533072" title="(x: Types.this.Type)Types.this.Type">t</a>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="List[Types.this.Type]" id="532978">strippedTypes</a> = <a href="#532974" title="List[Types.this.Type]">ts</a> <a href="../../collection/immutable/List.scala.html#63652" title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</a> <a href="#532977" title="(tp: Types.this.Type)Types.this.Type">stripType</a>
    <a href="../../Tuple2.scala.html#63804" title="(_1: List[Types.this.Type], _2: List[Types.this.Symbol])(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</a><a href="#532978" title="List[Types.this.Type]">strippedTypes</a>, <a href="#532976" title="List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])(Types.this.Type, Boolean)" id="441549">weakLub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="533094">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#533094" title="List[Types.this.Type]">ts</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#533094" title="List[Types.this.Type]">ts</a> <a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a> <a href="Definitions.scala.html#442791" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Tuple2.scala.html#63804" title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</a><a href="#441551" title="(ts: List[Types.this.Type])Types.this.Type">numericLub</a><span class="delimiter">(</span><a href="#533094" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#533094" title="List[Types.this.Type]">ts</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#533094" title="List[Types.this.Type]">ts</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#533133" title="Types.this.Type">_</a>.<a href="#442085" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="../../Tuple2.scala.html#63804" title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</a><a href="AnnotationCheckers.scala.html#440539" title="(tpe: Types.this.Type, ts: List[Types.this.Type])Types.this.Type">annotationsLub</a><span class="delimiter">(</span><a href="#441559" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#533094" title="List[Types.this.Type]">ts</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#533161" title="Types.this.Type">_</a>.<a href="#442086" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#533094" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <a href="../../Tuple2.scala.html#63804" title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</a><a href="#441559" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#533094" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])(Types.this.Type, Boolean)" id="441550">weakGlb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="533201">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#533201" title="List[Types.this.Type]">ts</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#533201" title="List[Types.this.Type]">ts</a> <a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a> <a href="Definitions.scala.html#442791" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="533211">nglb</a> = <a href="#441552" title="(ts: List[Types.this.Type])Types.this.Type">numericGlb</a><span class="delimiter">(</span><a href="#533201" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
      <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#533211" title="Types.this.Type">nglb</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="../../Tuple2.scala.html#63804" title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</a><a href="#533211" title="Types.this.Type">nglb</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="../../Tuple2.scala.html#63804" title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</a><a href="#441568" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#533201" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#533201" title="List[Types.this.Type]">ts</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#533201" title="List[Types.this.Type]">ts</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#533255" title="Types.this.Type">_</a>.<a href="#442085" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<a href="../../collection/TraversableOnce.scala.html#59102" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../../Tuple2.scala.html#63804" title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</a><a href="AnnotationCheckers.scala.html#440540" title="(tpe: Types.this.Type, ts: List[Types.this.Type])Types.this.Type">annotationsGlb</a><span class="delimiter">(</span><a href="#441568" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#533201" title="List[Types.this.Type]">ts</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#533283" title="Types.this.Type">_</a>.<a href="#442086" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#533201" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <a href="../../Tuple2.scala.html#63804" title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</a><a href="#441568" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#533201" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="441551">numericLub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="533108">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#533108" title="List[Types.this.Type]">ts</a> <a href="../../collection/LinearSeqOptimized.scala.html#76179" title="(f: (Types.this.Type, Types.this.Type) =&gt; Types.this.Type)Types.this.Type">reduceLeft</a> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="533123">t1</a>, <a title="Types.this.Type" id="533124">t2</a><span class="delimiter">)</span> =&gt;
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#441554" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#533123" title="Types.this.Type">t1</a>, <a href="#533124" title="Types.this.Type">t2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#533124" title="Types.this.Type">t2</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#441554" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#533124" title="Types.this.Type">t2</a>, <a href="#533123" title="Types.this.Type">t1</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#533123" title="Types.this.Type">t1</a>
      <span class="keyword">else</span> <a href="Definitions.scala.html#442849" title="=&gt; Types.this.ClassSymbol">IntClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="441552">numericGlb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="533212">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#533212" title="List[Types.this.Type]">ts</a> <a href="../../collection/LinearSeqOptimized.scala.html#76179" title="(f: (Types.this.Type, Types.this.Type) =&gt; Types.this.Type)Types.this.Type">reduceLeft</a> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="533227">t1</a>, <a title="Types.this.Type" id="533228">t2</a><span class="delimiter">)</span> =&gt;
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#441554" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#533227" title="Types.this.Type">t1</a>, <a href="#533228" title="Types.this.Type">t2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#533227" title="Types.this.Type">t1</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#441554" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#533228" title="Types.this.Type">t2</a>, <a href="#533227" title="Types.this.Type">t1</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#533228" title="Types.this.Type">t2</a>
      <span class="keyword">else</span> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="441553">isWeakSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="515704">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="515705">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
    <a href="#515704" title="Types.this.Type">tp1</a>.<a href="#441991" title="=&gt; Types.this.Type">deconst</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> TypeRef<a href="#515768" title="Boolean" id="515772" class="delimiter">(</a>_, sym1, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="Definitions.scala.html#442839" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span>sym1<span class="delimiter">)</span> =&gt;
        <a href="#515705" title="Types.this.Type">tp2</a>.<a href="#441991" title="=&gt; Types.this.Type">deconst</a>.<a href="#515778" title="(x: Boolean)Boolean">normalize</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> TypeRef<a href="#515727" title="Boolean" id="515731" class="delimiter">(</a>_, sym2, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="Definitions.scala.html#442839" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span>sym2<span class="delimiter">)</span> =&gt;
            <a href="Definitions.scala.html#442838" title="(sub: Types.this.Symbol, sup: Types.this.Symbol)Boolean">isNumericSubClass</a><a href="#515737" title="(x: Boolean)Boolean" class="delimiter">(</a>sym1, sym2<span class="delimiter">)</span>
          <span class="keyword">case</span> tv2 @ <a href="#470205" title="Option[(Types.this.Type, Types.this.TypeConstraint)]" id="515742">TypeVar</a><a href="#515727" title="Boolean" id="515735" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt;
            tv2.<a href="#470182" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><a href="#515737" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#515704" title="Types.this.Type">tp1</a>, isLowerBound = <span title="Boolean(true)" class="keyword">true</span>, isNumericBound = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
            <a href="#441512" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a><a href="#515737" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#515704" title="Types.this.Type">tp1</a>, <a href="#515705" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> tv1 @ <a href="#470205" title="Option[(Types.this.Type, Types.this.TypeConstraint)]" id="515783">TypeVar</a><a href="#515768" title="Boolean" id="515776" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt;
        <a href="#515705" title="Types.this.Type">tp2</a>.<a href="#441991" title="=&gt; Types.this.Type">deconst</a>.<a href="#515778" title="(x: Boolean)Boolean">normalize</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> TypeRef<a href="#515753" title="Boolean" id="515757" class="delimiter">(</a>_, sym2, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="Definitions.scala.html#442839" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span>sym2<span class="delimiter">)</span> =&gt;
            tv1.<a href="#470182" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><a href="#515758" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#515705" title="Types.this.Type">tp2</a>, isLowerBound = <span title="Boolean(false)" class="keyword">false</span>, isNumericBound = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
            <a href="#441512" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a><a href="#515758" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#515704" title="Types.this.Type">tp1</a>, <a href="#515705" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> _ =&gt;
        <a href="#441512" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a><a href="#515778" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#515704" title="Types.this.Type">tp1</a>, <a href="#515705" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  /** The isNumericValueType tests appear redundant, but without them
   *  test/continuations-neg/function3.scala goes into an infinite loop.
   *  (Even if the calls are to typeSymbolDirect.)
   */
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="441554">isNumericSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="525701">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="525702">tp2</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
       <a href="Definitions.scala.html#442791" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#525701" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
    <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="Definitions.scala.html#442791" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#525702" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
    <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="Definitions.scala.html#442838" title="(sub: Types.this.Symbol, sup: Types.this.Symbol)Boolean">isNumericSubClass</a><span class="delimiter">(</span><a href="#525701" title="Types.this.Type">tp1</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#525702" title="Types.this.Type">tp2</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
  <span class="delimiter">)</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" id="441555">lubResults</a> = <a href="../../collection/mutable/HashMap.scala.html#79203" title="()scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" class="keyword">new</a> mutable.<a href="../../collection/mutable/HashMap.scala.html#12880" title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">HashMap</a><span class="delimiter">[</span><span class="delimiter">(</span>Int, List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>, Type<span class="delimiter">]</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" id="441557">glbResults</a> = <a href="../../collection/mutable/HashMap.scala.html#79203" title="()scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" class="keyword">new</a> mutable.<a href="../../collection/mutable/HashMap.scala.html#12880" title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">HashMap</a><span class="delimiter">[</span><span class="delimiter">(</span>Int, List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>, Type<span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="441559">lub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="531222">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#531222" title="List[Types.this.Type]">ts</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="533365">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a>.<a href="#533361" title="(x: Types.this.Type)Types.this.Type">tpe</a>
    <span class="keyword">case</span> <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="533374">List</a><span class="delimiter">(</span>t<span class="delimiter">)</span> =&gt; <a href="#533361" title="(x: Types.this.Type)Types.this.Type">t</a>
    <span class="keyword">case</span> _ =&gt;
      <a href="#533361" title="(x: Types.this.Type)Types.this.Type" class="keyword">try</a> <span class="delimiter">{</span>
        <a href="#441560" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#531222" title="List[Types.this.Type]">ts</a>, <a href="#441486" title="(ts: List[Types.this.Type])Int">lubDepth</a><span class="delimiter">(</span><a href="#531222" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
        <a href="#441555" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">lubResults</a>.<a href="../../collection/mutable/HashMap.scala.html#79201" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#441557" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">glbResults</a>.<a href="../../collection/mutable/HashMap.scala.html#79201" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** The least upper bound wrt &lt;:&lt; of a list of types */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)Types.this.Type" id="441560">lub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="531228">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="531229">depth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="533382">lub0</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="533385">ts0</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441547" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">elimSub</a><a href="#533743" title="List[Types.this.Type]" class="delimiter">(</a><a href="#533385" title="List[Types.this.Type]">ts0</a>, <a href="#531229" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="533777">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a>.<a href="#533773" title="(x: Types.this.Type)Types.this.Type">tpe</a>
      <span class="keyword">case</span> <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="533786">List</a><span class="delimiter">(</span>t<span class="delimiter">)</span> =&gt; <a href="#533773" title="(x: Types.this.Type)Types.this.Type">t</a>
      <span class="keyword">case</span> ts @ PolyType<a title="Types.this.Type" id="533755" class="delimiter">(</a>tparams, _<span class="delimiter">)</span> <a href="#533743" title="Boolean" id="533752">::</a> _ =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol#TypeOfClonedSymbol]" id="533417">tparams1</a> = <a href="util/Collections.scala.html#440665" title="(xs1: List[Types.this.Symbol], xs2: List[List[Types.this.Type]])(f: (Types.this.Symbol, List[Types.this.Type]) =&gt; Types.this.Symbol#TypeOfClonedSymbol)List[Types.this.Symbol#TypeOfClonedSymbol]">map2</a><span class="delimiter">(</span>tparams, <a href="#441575" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[List[Types.this.Type]]">matchingBounds</a><span class="delimiter">(</span>ts, tparams<span class="delimiter">)</span>.<a href="../../collection/generic/GenericTraversableTemplate.scala.html#59389" title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.GenTraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="533489">tparam</a>, <a title="List[Types.this.Type]" id="533490">bounds</a><span class="delimiter">)</span> =&gt;
          <a href="#533489" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443475" title="=&gt; tparam.TypeOfClonedSymbol">cloneSymbol</a>.<a href="Symbols.scala.html#443429" title="(info: Types.this.Type)tparam.TypeOfClonedSymbol">setInfo</a><span class="delimiter">(</span><a href="#441569" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#533490" title="List[Types.this.Type]">bounds</a>, <a href="#531229" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#448476" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#533417" title="List[Types.this.Symbol#TypeOfClonedSymbol]">tparams1</a>, <a href="#533382" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#441576" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">matchingInstTypes</a><span class="delimiter">(</span>ts, <a href="#533417" title="List[Types.this.Symbol#TypeOfClonedSymbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> ts @ MethodType<a title="Types.this.Type" id="533760" class="delimiter">(</a>params, _<span class="delimiter">)</span> :: rest =&gt;
        <a href="#448374" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><a href="#533773" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>params, <a href="#533382" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#441577" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span>ts, params <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#533565" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> ts @ NullaryMethodType<a title="Types.this.Type" id="533765" class="delimiter">(</a>_<span class="delimiter">)</span> :: rest =&gt;
        <a href="#448427" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><a href="#533773" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#533382" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#441577" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span>ts, <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> ts @ TypeBounds<a title="Types.this.Type" id="533771" class="delimiter">(</a>_, _<span class="delimiter">)</span> :: rest =&gt;
        <a href="#448285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><a href="#533773" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#441569" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span>ts <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#533625" title="Types.this.Type">_</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448327" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#531229" title="Int">depth</a><span class="delimiter">)</span>, <a href="#441560" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span>ts <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#533667" title="Types.this.Type">_</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#531229" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> ts =&gt;
        <a href="#441555" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">lubResults</a> <a href="#533773" title="(x: Types.this.Type)Types.this.Type">get</a> <span class="delimiter">(</span><a href="#531229" title="Int">depth</a>, ts<span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> Some<a href="#533730" title="Types.this.Type" id="533731" class="delimiter">(</a>lubType<span class="delimiter">)</span> =&gt;
            <a href="#533734" title="(x: Types.this.Type)Types.this.Type">lubType</a>
          <span class="keyword">case</span> <a href="../../Option.scala.html#2498" title="Types.this.Type" id="533733">None</a> =&gt;
            <a href="../../collection/mutable/HashMap.scala.html#79209" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">lubResults</a><span class="delimiter">(</span><a href="../../Tuple2.scala.html#63804" title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</a><a href="#531229" title="Int">depth</a>, ts<span class="delimiter">)</span><span class="delimiter">)</span> = <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="533707">res</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#531229" title="Int">depth</a> <a href="../../Int.scala.html#57905" title="(x: Int)Boolean">&lt;</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#533383" title="(ts0: List[Types.this.Type])Types.this.Type">lub1</a><span class="delimiter">(</span>ts<span class="delimiter">)</span>
            <a href="../../collection/mutable/HashMap.scala.html#79209" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">lubResults</a><span class="delimiter">(</span><a href="../../Tuple2.scala.html#63804" title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</a><a href="#531229" title="Int">depth</a>, ts<span class="delimiter">)</span><span class="delimiter">)</span> = <a href="#533707" title="Types.this.Type">res</a>
            <a href="#533707" title="Types.this.Type">res</a>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="533383">lub1</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="533722">ts0</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#533818" title="(x: (List[Types.this.Type], List[Types.this.Symbol]))(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</a><a href="../../Tuple2.scala.html#61506" title="List[Types.this.Type]" id="533799">ts</a>, <a href="../../Tuple2.scala.html#61508" title="List[Types.this.Symbol]" id="533800">tparams</a><span class="delimiter">)</span> = <a href="#441548" title="(ts: List[Types.this.Type])(List[Types.this.Type], List[Types.this.Symbol])">stripExistentialsAndTypeVars</a><a href="../../Tuple2.scala.html#1222" title="(List[Types.this.Type], List[Types.this.Symbol]) @unchecked" class="delimiter">(</a><a href="#533722" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="533801">lubBaseTypes</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#441541" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">lubList</a><span class="delimiter">(</span><a href="#533799" title="List[Types.this.Type]">ts</a>, <a href="#531229" title="Int">depth</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="533802">lubParents</a> = <a href="#441543" title="(ts: List[Types.this.Type])List[Types.this.Type]">spanningTypes</a><span class="delimiter">(</span><a href="#533801" title="List[Types.this.Type]">lubBaseTypes</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="533803">lubOwner</a> = <a href="#441472" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#533799" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="533804">lubBase</a> = <a href="#441375" title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="#533802" title="List[Types.this.Type]">lubParents</a>, <a href="#533803" title="Types.this.Symbol">lubOwner</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="533805">lubType</a> =
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#531229" title="Int">depth</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#533804" title="Types.this.Type">lubBase</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="533836">lubRefined</a>  = <a href="#441369" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#533802" title="List[Types.this.Type]">lubParents</a>, <a href="#533803" title="Types.this.Symbol">lubOwner</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="533837">lubThisType</a> = <a href="#533836" title="Types.this.Type">lubRefined</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443485" title="=&gt; Types.this.Type">thisType</a>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="533838">narrowts</a>    = <a href="#533799" title="List[Types.this.Type]">ts</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#533862" title="Types.this.Type">_</a>.<a href="#441993" title="=&gt; Types.this.Type">narrow</a><span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="533839">excludeFromLub</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="533890">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
               <a href="#533890" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443231" title="=&gt; Boolean">isClass</a>
            <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#533890" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443265" title="=&gt; Boolean">isConstructor</a>
            <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#533890" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#443606" title="=&gt; Boolean">isPublic</a>
            <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="Definitions.scala.html#442840" title="(sym: Types.this.Symbol)Boolean">isGetClass</a><span class="delimiter">(</span><a href="#533890" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#533838" title="List[Types.this.Type]">narrowts</a>.<a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a title="Types.this.Type" id="533898">t</a> =&gt; <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#533841" title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean">refines</a><span class="delimiter">(</span><a href="#533898" title="Types.this.Type">t</a>, <a href="#533890" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(proto: Types.this.Symbol)Types.this.Symbol" id="533840">lubsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="533901">proto</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="533902">prototp</a> = <a href="#533837" title="Types.this.Type">lubThisType</a>.<a href="#442038" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#533901" title="Types.this.Symbol">proto</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="533903">syms</a> = <a href="#533838" title="List[Types.this.Type]">narrowts</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</a> <span class="delimiter">(</span><a title="Types.this.Type" id="533920">t</a> =&gt;
              <a href="#533920" title="Types.this.Type">t</a>.<a href="#442029" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#533901" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#443152" title="=&gt; proto.NameType">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#443474" title="(cond: Types.this.Symbol =&gt; Boolean)Types.this.Symbol">suchThat</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="533927">sym</a> =&gt;
                <a href="#533927" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a> <a href="#442064" title="(that: Types.this.Type)Boolean">matches</a> <a href="#533902" title="Types.this.Type">prototp</a>.<a href="#442043" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#533837" title="Types.this.Type">lubThisType</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#533920" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#533903" title="List[Types.this.Symbol]">syms</a> <a href="../../collection/SeqLike.scala.html#59768" title="(elem: Any)Boolean">contains</a> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a>
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="List[Types.this.Type]" id="533959">symtypes</a> =
                <a href="util/Collections.scala.html#440665" title="(xs1: List[Types.this.Type], xs2: List[Types.this.Symbol])(f: (Types.this.Type, Types.this.Symbol) =&gt; Types.this.Type)List[Types.this.Type]">map2</a><span class="delimiter">(</span><a href="#533838" title="List[Types.this.Type]">narrowts</a>, <a href="#533903" title="List[Types.this.Symbol]">syms</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="533982">t</a>, <a title="Types.this.Symbol" id="533983">sym</a><span class="delimiter">)</span> =&gt; <a href="#533982" title="Types.this.Type">t</a>.<a href="#442038" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#533983" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#442043" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#533982" title="Types.this.Type">t</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#533837" title="Types.this.Type">lubThisType</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#533901" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#443229" title="=&gt; Boolean">isTerm</a><span class="delimiter">)</span> // possible problem: owner of info is still the old one, instead of new refinement class
                <a href="#533901" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#443476" title="(newOwner: Types.this.Symbol)proto.TypeOfClonedSymbol">cloneSymbol</a><span class="delimiter">(</span><a href="#533836" title="Types.this.Type">lubRefined</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#443432" title="(info: Types.this.Type)proto.TypeOfClonedSymbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span><a href="#441560" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#533959" title="List[Types.this.Type]">symtypes</a>, <a href="#441213" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#531229" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#533959" title="List[Types.this.Type]">symtypes</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Type]">tail</a> <a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a href="#533959" title="List[Types.this.Type]">symtypes</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#533901" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#443476" title="(newOwner: Types.this.Symbol)proto.TypeOfClonedSymbol">cloneSymbol</a><span class="delimiter">(</span><a href="#533836" title="Types.this.Type">lubRefined</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#443432" title="(info: Types.this.Type)proto.TypeOfClonedSymbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span><a href="#533959" title="List[Types.this.Type]">symtypes</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a><span class="delimiter">)</span>
              <span class="keyword">else</span> <span class="delimiter">{</span>
                <span class="keyword">def</span> <a title="(bnds: List[Types.this.TypeBounds])Types.this.TypeBounds" id="534035">lubBounds</a><span class="delimiter">(</span><a title="List[Types.this.TypeBounds]" id="534036">bnds</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.TypeBounds]">List</a><span class="delimiter">[</span>TypeBounds<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#448315" title="Types.this.TypeBounds">TypeBounds</a> =
                  <a href="#448285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#441569" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#534036" title="List[Types.this.TypeBounds]">bnds</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.TypeBounds =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeBounds],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#534057" title="Types.this.TypeBounds">_</a>.<a href="#448327" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#441213" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#531229" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#441560" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#534036" title="List[Types.this.TypeBounds]">bnds</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.TypeBounds =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeBounds],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#534099" title="Types.this.TypeBounds">_</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#441213" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#531229" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#533836" title="Types.this.Type">lubRefined</a>.<a href="#441986" title="Types.this.Symbol" id="534137">typeSymbol</a>.<a href="Symbols.scala.html#457602" title="Long" id="534140">newAbstractType</a><span class="delimiter">(</span><a href="#533901" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#443152" title="=&gt; proto.NameType">name</a>.<a href="Names.scala.html#444127" title="Types.this.TypeName" id="534138">toTypeName</a>, <a href="#533901" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#443167" title="Types.this.Position" id="534139">pos</a><span class="delimiter">)</span>
                  .<a href="Symbols.scala.html#443432" title="(info: Types.this.Type)Types.this.AbstractTypeSymbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span><a href="#534035" title="(bnds: List[Types.this.TypeBounds])Types.this.TypeBounds">lubBounds</a><span class="delimiter">(</span><a href="#533959" title="List[Types.this.Type]">symtypes</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.TypeBounds)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.TypeBounds,List[Types.this.TypeBounds]])List[Types.this.TypeBounds]">map</a> <span class="delimiter">(</span><a href="#534160" title="Types.this.Type">_</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean" id="533841">refines</a><span class="delimiter">(</span><a title="Types.this.Type" id="533899">tp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="533900">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="534188">syms</a> = <a href="#533899" title="Types.this.Type">tp</a>.<a href="#442029" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#533900" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym.NameType">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#443472" title="=&gt; List[Types.this.Symbol]">alternatives</a>;
            <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#534188" title="List[Types.this.Symbol]">syms</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#534188" title="List[Types.this.Symbol]">syms</a> <a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="534197">alt</a> =&gt;
              // todo alt != sym is strictly speaking not correct, but without it we lose
              // efficiency.
              <a href="#534197" title="Types.this.Symbol">alt</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#533900" title="Types.this.Symbol">sym</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#441527" title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#533837" title="Types.this.Type">lubThisType</a>, <a href="#533900" title="Types.this.Symbol">sym</a>, <a href="#533899" title="Types.this.Type">tp</a>, <a href="#534197" title="Types.this.Symbol">alt</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          // add a refinement symbol for all non-class members of lubBase
          // which are refined by every type in ts.
          <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="534216">sym</a> &lt;- <a href="#533804" title="Types.this.Type">lubBase</a>.<a href="../../collection/generic/FilterMonadic.scala.html#59082" title="(f: Types.this.Symbol =&gt; Unit)Unit">nonPrivateMembers</a> ; <span class="keyword">if</span> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#533839" title="(sym: Types.this.Symbol)Boolean">excludeFromLub</a><span class="delimiter">(</span><a href="#534216" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">try</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Symbol" id="534217">lsym</a> = <a href="#533840" title="(proto: Types.this.Symbol)Types.this.Symbol">lubsym</a><span class="delimiter">(</span><a href="#534216" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
              <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#534217" title="Types.this.Symbol">lsym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#441574" title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol)Unit">addMember</a><span class="delimiter">(</span><a href="#533837" title="Types.this.Type">lubThisType</a>, <a href="#533836" title="Types.this.Type">lubRefined</a>, <a href="#534217" title="Types.this.Symbol">lsym</a><span class="delimiter">)</span>
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <a title="Unit" id="534222">ex</a>: <a href="#441582" title="Types.this.NoCommonType">NoCommonType</a> =&gt;
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#533836" title="Types.this.Type">lubRefined</a>.<a href="#442019" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#447327" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#533804" title="Types.this.Type">lubBase</a>
          <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span title="Boolean(true)">verifyLubs</span><span class="delimiter">)</span> <a href="#533836" title="Types.this.Type">lubRefined</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            // Verify that every given type conforms to the calculated lub.
            // In theory this should not be necessary, but higher-order type
            // parameters are not handled correctly.
            <span class="keyword">val</span> <a title="Boolean" id="534229">ok</a> = <a href="#533799" title="List[Types.this.Type]">ts</a> <a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a> <span class="delimiter">{</span> <a title="Types.this.Type" id="534236">t</a> =&gt;
              <span class="delimiter">(</span><a href="#534236" title="Types.this.Type">t</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#533836" title="Types.this.Type">lubRefined</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <span class="delimiter">{</span>
                <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456420" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#441214" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <a href="../../Console.scala.html#227" title="Console.type">Console</a>.<a href="../../Console.scala.html#64301" title="(x: Any)Unit">println</a><span class="delimiter">(</span>
                    <span title="String(&quot;Malformed lub: &quot;)" class="string">&quot;Malformed lub: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#533836" title="Types.this.Type">lubRefined</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span> <span title="(x$1: Any)String">+</span>
                    <span title="String(&quot;Argument &quot;)" class="string">&quot;Argument &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#534236" title="Types.this.Type">t</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; does not conform.  Falling back to &quot;)" class="string">&quot; does not conform.  Falling back to &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#533804" title="Types.this.Type">lubBase</a>
                  <span class="delimiter">)</span>
                <span class="delimiter">}</span>
                <span title="Boolean(false)" class="keyword">false</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            // If not, fall back on the more conservative calculation.
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#534229" title="Boolean">ok</a><span class="delimiter">)</span> <a href="#533836" title="Types.this.Type">lubRefined</a>
            <span class="keyword">else</span> <a href="#533804" title="Types.this.Type">lubBase</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <a href="#441386" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#533800" title="List[Types.this.Symbol]">tparams</a>, <a href="#533805" title="Types.this.Type">lubType</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#441214" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../../Predef.scala.html#8489" title="(x: Any)Unit">println</a><span class="delimiter">(</span><a href="#441585" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;lub of &quot;)" class="string">&quot;lub of &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#531228" title="List[Types.this.Type]">ts</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; at depth &quot;)" class="string">&quot; at depth &quot;</span><span title="(x$1: Any)String">+</span><a href="#531229" title="Int">depth</a><span class="delimiter">)</span>//debug
      <a href="#441585" title="(x$1: String)Unit">indent</a> = <a href="#441585" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
      <a href="../../Predef.scala.html#8459" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span><a href="#441585" title="=&gt; String">indent</a>.<span title="()Int">length</span> <a href="../../Int.scala.html#57912" title="(x: Int)Boolean">&lt;=</a> <span title="Int(100)" class="int">100</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="Types.this.Type" id="533384">res</a> = <a href="#533382" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#531228" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#441214" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#441585" title="(x$1: String)Unit">indent</a> = <a href="../../Predef.scala.html#8578" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">indent</a> <a href="../../collection/immutable/StringLike.scala.html#60709" title="(suffix: String)String">stripSuffix</a> <span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
      <a href="../../Predef.scala.html#8489" title="(x: Any)Unit">println</a><span class="delimiter">(</span><a href="#441585" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;lub of &quot;)" class="string">&quot;lub of &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#531228" title="List[Types.this.Type]">ts</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; is &quot;)" class="string">&quot; is &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#533384" title="Types.this.Type">res</a><span class="delimiter">)</span>//debug
    <span class="delimiter">}</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#531228" title="List[Types.this.Type]">ts</a> <a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a href="#534264" title="Types.this.Type">_</a>.<a href="#441975" title="=&gt; Boolean">isNotNull</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#533384" title="Types.this.Type">res</a>.<a href="#442013" title="=&gt; Types.this.Type">notNull</a> <span class="keyword">else</span> <a href="#533384" title="Types.this.Type">res</a>
  <span class="delimiter">}</span>

  <span class="keyword">val</span> <a title="Throwable" id="441561">GlbFailure</a> = <span title="Throwable" class="keyword">new</span> <a href="../../package.scala.html#56957" title="Throwable">Throwable</a>

  /** A global counter for glb calls in the `specializes` query connected to the `addMembers`
   *  call in `glb`. There's a possible infinite recursion when `specializes` calls
   *  memberType, which calls baseTypeSeq, which calls mergePrefixAndArgs, which calls glb.
   *  The counter breaks this recursion after two calls.
   *  If the recursion is broken, no member is added to the glb.
   */
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="441564">globalGlbDepth</a> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(2)" id="441566">globalGlbLimit</a> = <span title="Int(2)" class="int">2</span>

  /** The greatest lower bound wrt &lt;:&lt; of a list of types */
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="441568">glb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="531204">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441544" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSuper</a><a href="#534296" title="List[Types.this.Type]" class="delimiter">(</a><a href="#531204" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="534307">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a>.<a href="#534303" title="(x: Types.this.Type)Types.this.Type">tpe</a>
    <span class="keyword">case</span> <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="534316">List</a><span class="delimiter">(</span>t<span class="delimiter">)</span> =&gt; <a href="#534303" title="(x: Types.this.Type)Types.this.Type">t</a>
    <span class="keyword">case</span> ts0 =&gt;
      <a href="#534303" title="(x: Types.this.Type)Types.this.Type" class="keyword">try</a> <span class="delimiter">{</span>
        <a href="#441570" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glbNorm</a><span class="delimiter">(</span>ts0, <a href="#441486" title="(ts: List[Types.this.Type])Int">lubDepth</a><span class="delimiter">(</span>ts0<span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
        <a href="#441555" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">lubResults</a>.<a href="../../collection/mutable/HashMap.scala.html#79201" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#441557" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">glbResults</a>.<a href="../../collection/mutable/HashMap.scala.html#79201" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)Types.this.Type" id="441569">glb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="531210">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="531211">depth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#441544" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSuper</a><a href="#534351" title="List[Types.this.Type]" class="delimiter">(</a><a href="#531210" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="534362">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a>.<a href="#534358" title="(x: Types.this.Type)Types.this.Type">tpe</a>
    <span class="keyword">case</span> <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="534371">List</a><span class="delimiter">(</span>t<span class="delimiter">)</span> =&gt; <a href="#534358" title="(x: Types.this.Type)Types.this.Type">t</a>
    <span class="keyword">case</span> ts0 =&gt; <a href="#441570" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glbNorm</a><a href="#534358" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>ts0, <a href="#531211" title="Int">depth</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** The greatest lower bound wrt &lt;:&lt; of a list of types, which have been normalized
   *  wrt elimSuper */
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)Types.this.Type" id="441570">glbNorm</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="534291">ts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="534292">depth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="534379">glb0</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="534382">ts0</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#534382" title="List[Types.this.Type]">ts0</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="534751">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a>.<a href="#534747" title="(x: Types.this.Type)Types.this.Type">tpe</a>
      <span class="keyword">case</span> <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="534760">List</a><span class="delimiter">(</span>t<span class="delimiter">)</span> =&gt; <a href="#534747" title="(x: Types.this.Type)Types.this.Type">t</a>
      <span class="keyword">case</span> ts @ PolyType<a title="Types.this.Type" id="534729" class="delimiter">(</a>tparams, _<span class="delimiter">)</span> <a href="#534717" title="Boolean" id="534726">::</a> _ =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol#TypeOfClonedSymbol]" id="534414">tparams1</a> = <a href="util/Collections.scala.html#440665" title="(xs1: List[Types.this.Symbol], xs2: List[List[Types.this.Type]])(f: (Types.this.Symbol, List[Types.this.Type]) =&gt; Types.this.Symbol#TypeOfClonedSymbol)List[Types.this.Symbol#TypeOfClonedSymbol]">map2</a><span class="delimiter">(</span>tparams, <a href="#441575" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[List[Types.this.Type]]">matchingBounds</a><span class="delimiter">(</span>ts, tparams<span class="delimiter">)</span>.<a href="../../collection/generic/GenericTraversableTemplate.scala.html#59389" title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.GenTraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="534474">tparam</a>, <a title="List[Types.this.Type]" id="534475">bounds</a><span class="delimiter">)</span> =&gt;
          <a href="#534474" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443475" title="=&gt; tparam.TypeOfClonedSymbol">cloneSymbol</a>.<a href="Symbols.scala.html#443429" title="(info: Types.this.Type)tparam.TypeOfClonedSymbol">setInfo</a><span class="delimiter">(</span><a href="#441560" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#534475" title="List[Types.this.Type]">bounds</a>, <a href="#534292" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#448476" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#534414" title="List[Types.this.Symbol#TypeOfClonedSymbol]">tparams1</a>, <a href="#441570" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glbNorm</a><span class="delimiter">(</span><a href="#441576" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">matchingInstTypes</a><span class="delimiter">(</span>ts, <a href="#534414" title="List[Types.this.Symbol#TypeOfClonedSymbol]">tparams1</a><span class="delimiter">)</span>, <a href="#534292" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> ts @ MethodType<a title="Types.this.Type" id="534734" class="delimiter">(</a>params, _<span class="delimiter">)</span> :: rest =&gt;
        <a href="#448374" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><a href="#534747" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>params, <a href="#441570" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glbNorm</a><span class="delimiter">(</span><a href="#441577" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span>ts, params <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#534544" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#534292" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> ts @ NullaryMethodType<a title="Types.this.Type" id="534739" class="delimiter">(</a>_<span class="delimiter">)</span> :: rest =&gt;
        <a href="#448427" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><a href="#534747" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#441570" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glbNorm</a><span class="delimiter">(</span><a href="#441577" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span>ts, <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>, <a href="#534292" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> ts @ TypeBounds<a title="Types.this.Type" id="534745" class="delimiter">(</a>_, _<span class="delimiter">)</span> :: rest =&gt;
        <a href="#448285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><a href="#534747" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#441560" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span>ts <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#534604" title="Types.this.Type">_</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448327" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#534292" title="Int">depth</a><span class="delimiter">)</span>, <a href="#441569" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span>ts <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#534646" title="Types.this.Type">_</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#534292" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> ts =&gt;
        <a href="#441557" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">glbResults</a> <a href="#534747" title="(x: Types.this.Type)Types.this.Type">get</a> <span class="delimiter">(</span><a href="#534292" title="Int">depth</a>, ts<span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> Some<a href="#534709" title="Types.this.Type" id="534710" class="delimiter">(</a>glbType<span class="delimiter">)</span> =&gt;
            <a href="#534711" title="(x: Types.this.Type)Types.this.Type">glbType</a>
          <span class="keyword">case</span> _ =&gt;
            <a href="../../collection/mutable/HashMap.scala.html#79209" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">glbResults</a><span class="delimiter">(</span><a href="../../Tuple2.scala.html#63804" title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</a><a href="#534292" title="Int">depth</a>, ts<span class="delimiter">)</span><span class="delimiter">)</span> = <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="534686">res</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#534292" title="Int">depth</a> <a href="../../Int.scala.html#57905" title="(x: Int)Boolean">&lt;</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#534380" title="(ts0: List[Types.this.Type])Types.this.Type">glb1</a><span class="delimiter">(</span>ts<span class="delimiter">)</span>
            <a href="../../collection/mutable/HashMap.scala.html#79209" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">glbResults</a><span class="delimiter">(</span><a href="../../Tuple2.scala.html#63804" title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</a><a href="#534292" title="Int">depth</a>, ts<span class="delimiter">)</span><span class="delimiter">)</span> = <a href="#534686" title="Types.this.Type">res</a>
            <a href="#534686" title="Types.this.Type">res</a>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="534380">glb1</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="534701">ts0</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#535396" title="Types.this.Type" id="535391" class="keyword">try</a> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a href="#534793" title="(x: (List[Types.this.Type], List[Types.this.Symbol]))(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</a><a href="../../Tuple2.scala.html#61506" title="List[Types.this.Type]" id="534773">ts</a>, <a href="../../Tuple2.scala.html#61508" title="List[Types.this.Symbol]" id="534774">tparams</a><span class="delimiter">)</span> = <a href="#441548" title="(ts: List[Types.this.Type])(List[Types.this.Type], List[Types.this.Symbol])">stripExistentialsAndTypeVars</a><a href="../../Tuple2.scala.html#1222" title="(List[Types.this.Type], List[Types.this.Symbol]) @unchecked" class="delimiter">(</a><a href="#534701" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="534775">glbOwner</a> = <a href="#441472" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#534773" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="(t: Types.this.Type)List[Types.this.Type]" id="534776">refinedToParents</a><span class="delimiter">(</span><a title="Types.this.Type" id="534803">t</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#534803" title="Types.this.Type">t</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> RefinedType<a href="#534857" title="List[Types.this.Type]" id="534860" class="delimiter">(</a>ps, _<span class="delimiter">)</span> =&gt; ps <a href="#534861" title="(x: List[Types.this.Type])List[Types.this.Type]">flatMap</a> <a href="#534776" title="(t: Types.this.Type)List[Types.this.Type]">refinedToParents</a>
          <span class="keyword">case</span> _ =&gt; <a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><a href="#534861" title="(x: List[Types.this.Type])List[Types.this.Type]" class="delimiter">(</a><a href="#534803" title="Types.this.Type">t</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(t: Types.this.Type)List[Types.this.Scope]" id="534777">refinedToDecls</a><span class="delimiter">(</span><a title="Types.this.Type" id="534866">t</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Scope]">List</a><span class="delimiter">[</span>Scope<span class="delimiter">]</span> = <a href="#534866" title="Types.this.Type">t</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> RefinedType<a href="#534928" title="List[Types.this.Scope]" id="534930" class="delimiter">(</a>ps, decls<span class="delimiter">)</span> =&gt;
            <span class="keyword">val</span> <a title="List[Types.this.Scope]" id="534869">dss</a> = ps <a href="../../collection/TraversableLike.scala.html#58976" title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Scope])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Scope,List[Types.this.Scope]])List[Types.this.Scope]">flatMap</a> <a href="#534777" title="(t: Types.this.Type)List[Types.this.Scope]">refinedToDecls</a>
            <span title="List[Types.this.Scope]" class="keyword">if</span> <span class="delimiter">(</span>decls.<a href="Scopes.scala.html#447327" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#534869" title="List[Types.this.Scope]">dss</a> <span class="keyword">else</span> decls <a href="../../collection/immutable/List.scala.html#63643" title="(x: Types.this.Scope)List[Types.this.Scope]">::</a> <a href="#534869" title="List[Types.this.Scope]">dss</a>
          <span class="keyword">case</span> _ =&gt; List<a href="#534931" title="(x: List[Types.this.Scope])List[Types.this.Scope]" class="delimiter">(</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="534778">ts1</a> = <a href="#534773" title="List[Types.this.Type]">ts</a> <a href="../../collection/TraversableLike.scala.html#58976" title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">flatMap</a> <a href="#534776" title="(t: Types.this.Type)List[Types.this.Type]">refinedToParents</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="534779">glbBase</a> = <a href="#441375" title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="#534778" title="List[Types.this.Type]">ts1</a>, <a href="#534775" title="Types.this.Symbol">glbOwner</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="534780">glbType</a> =
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a> <a href="../../Boolean.scala.html#58724" title="(x: Boolean)Boolean">||</a> <a href="#534292" title="Int">depth</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#534779" title="Types.this.Type">glbBase</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="534988">glbRefined</a> = <a href="#441369" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#534778" title="List[Types.this.Type]">ts1</a>, <a href="#534775" title="Types.this.Symbol">glbOwner</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="534989">glbThisType</a> = <a href="#534988" title="Types.this.Type">glbRefined</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#443485" title="=&gt; Types.this.Type">thisType</a>
            <span class="keyword">def</span> <a title="(proto: Types.this.Symbol)Types.this.Symbol" id="534990">glbsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="534995">proto</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="534996">prototp</a> = <a href="#534989" title="Types.this.Type">glbThisType</a>.<a href="#442038" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#534995" title="Types.this.Symbol">proto</a><span class="delimiter">)</span>
              <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="534997">syms</a> = <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="535009">t</a> &lt;- <a href="../../collection/TraversableLike.scala.html#58976" title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">ts</a>;
                    <a title="Types.this.Symbol" id="535026">alt</a> &lt;- <span class="delimiter">(</span><a href="#535009" title="Types.this.Type">t</a>.<a href="#442029" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#534995" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#443152" title="=&gt; proto.NameType">name</a><span class="delimiter">)</span>.<a href="../../collection/generic/FilterMonadic.scala.html#59072" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">alternatives</a><span class="delimiter">)</span>;
                <span class="keyword">if</span> <a href="#534989" title="Types.this.Type">glbThisType</a>.<a href="#442038" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#535026" title="Types.this.Symbol">alt</a><span class="delimiter">)</span> <a href="#442064" title="(that: Types.this.Type)Boolean">matches</a> <a href="#534996" title="Types.this.Type">prototp</a>
              <span class="delimiter">)</span> <span class="keyword">yield</span> <a href="#535026" title="Types.this.Symbol">alt</a>
              <span class="keyword">val</span> <a title="List[Types.this.Type]" id="534998">symtypes</a> = <a href="#534997" title="List[Types.this.Symbol]">syms</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#534989" title="Types.this.Type">glbThisType</a>.<a href="#442038" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a>
              <a href="../../Predef.scala.html#8459" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#534998" title="List[Types.this.Type]">symtypes</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span>
              <a href="#534995" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#443476" title="(newOwner: Types.this.Symbol)proto.TypeOfClonedSymbol">cloneSymbol</a><span class="delimiter">(</span><a href="#534988" title="Types.this.Type">glbRefined</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#443432" title="(info: Types.this.Type)proto.TypeOfClonedSymbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span>
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#534995" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#443229" title="=&gt; Boolean">isTerm</a><span class="delimiter">)</span> <a href="#441569" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#534998" title="List[Types.this.Type]">symtypes</a>, <a href="#441213" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#534292" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span class="delimiter">{</span>
                  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="535151">isTypeBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="535155">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#535155" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
                    <span class="keyword">case</span> TypeBounds<a href="#535157" title="Boolean" id="535161" class="delimiter">(</a>_, _<span class="delimiter">)</span> =&gt; <a href="#535162" title="(x: Boolean)Boolean" class="keyword">true</a>
                    <span class="keyword">case</span> _ =&gt; <a href="#535162" title="(x: Boolean)Boolean" class="keyword">false</a>
                  <span class="delimiter">}</span>
                  <span class="keyword">def</span> <a title="(bnds: List[Types.this.Type])Types.this.TypeBounds" id="535152">glbBounds</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="535167">bnds</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#448315" title="Types.this.TypeBounds">TypeBounds</a> = <span class="delimiter">{</span>
                    <span class="keyword">val</span> <a title="Types.this.Type" id="535168">lo</a> = <a href="#441560" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#535167" title="List[Types.this.Type]">bnds</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#535190" title="Types.this.Type">_</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448327" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#441213" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#534292" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="keyword">val</span> <a title="Types.this.Type" id="535169">hi</a> = <a href="#441569" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#535167" title="List[Types.this.Type]">bnds</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#535232" title="Types.this.Type">_</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#441213" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#534292" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span title="Types.this.TypeBounds" class="keyword">if</span> <span class="delimiter">(</span><a href="#535168" title="Types.this.Type">lo</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#535169" title="Types.this.Type">hi</a><span class="delimiter">)</span> <a href="#448285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#535168" title="Types.this.Type">lo</a>, <a href="#535169" title="Types.this.Type">hi</a><span class="delimiter">)</span>
                    <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <a href="#441561" title="=&gt; Throwable">GlbFailure</a>
                  <span class="delimiter">}</span>
                  <span class="keyword">val</span> <a title="List[Types.this.Type]" id="535153">symbounds</a> = <a href="#534998" title="List[Types.this.Type]">symtypes</a> <a href="../../collection/TraversableLike.scala.html#58981" title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</a> <a href="#535151" title="(tp: Types.this.Type)Boolean">isTypeBound</a>
                  <span class="keyword">var</span> <a title="Types.this.Type" id="535154">result</a>: <a href="#441242" title="Types.this.Type">Type</a> =
                    <span title="Types.this.TypeBounds" class="keyword">if</span> <span class="delimiter">(</span><a href="#535153" title="List[Types.this.Type]">symbounds</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span>
                      <a href="#516870" title="Types.this.TypeBounds.type">TypeBounds</a>.<a href="#448282" title="=&gt; Types.this.TypeBounds">empty</a>
                    <span class="keyword">else</span> <a href="#535152" title="(bnds: List[Types.this.Type])Types.this.TypeBounds">glbBounds</a><span class="delimiter">(</span><a href="#535153" title="List[Types.this.Type]">symbounds</a><span class="delimiter">)</span>
                  <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="535273">t</a> &lt;- <a href="../../collection/generic/FilterMonadic.scala.html#59082" title="(f: Types.this.Type =&gt; Unit)Unit">symtypes</a> <span class="keyword">if</span> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#535151" title="(tp: Types.this.Type)Boolean">isTypeBound</a><span class="delimiter">(</span><a href="#535273" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#535154" title="Types.this.Type">result</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a> <a href="#448306" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#535273" title="Types.this.Type">t</a><span class="delimiter">)</span> <a href="#535154" title="Types.this.Type">result</a> = <a href="#535273" title="Types.this.Type">t</a>
                    <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <a href="#441561" title="=&gt; Throwable">GlbFailure</a>
                  <a href="#535154" title="Types.this.Type">result</a>
                <span class="delimiter">}</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#441564" title="=&gt; Int">globalGlbDepth</a> <a href="../../Int.scala.html#57905" title="(x: Int)Boolean">&lt;</a> <span title="Int(2)">globalGlbLimit</span><span class="delimiter">)</span>
              <span class="keyword">try</span> <span class="delimiter">{</span>
                <a href="#441564" title="(x$1: Int)Unit">globalGlbDepth</a> <a href="../../Int.scala.html#57948" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
                <span class="keyword">val</span> <a title="List[Types.this.Scope]" id="535285">dss</a> = <a href="#534773" title="List[Types.this.Type]">ts</a> <a href="../../collection/TraversableLike.scala.html#58976" title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Scope])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Scope,List[Types.this.Scope]])List[Types.this.Scope]">flatMap</a> <a href="#534777" title="(t: Types.this.Type)List[Types.this.Scope]">refinedToDecls</a>
                <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Scope" id="535349">ds</a> &lt;- <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.Scope =&gt; Unit)Unit">dss</a>; <a title="Types.this.Symbol" id="535360">sym</a> &lt;- <a href="#535349" title="Types.this.Scope">ds</a>.<a href="../../collection/Iterator.scala.html#65240" title="(f: Types.this.Symbol =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span>
                  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#441564" title="=&gt; Int">globalGlbDepth</a> <a href="../../Int.scala.html#57905" title="(x: Int)Boolean">&lt;</a> <span title="Int(2)">globalGlbLimit</span> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#534989" title="Types.this.Type">glbThisType</a> <a href="#442063" title="(sym: Types.this.Symbol)Boolean">specializes</a> <a href="#535360" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="keyword">try</span> <span class="delimiter">{</span>
                      <a href="#441574" title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol)Unit">addMember</a><span class="delimiter">(</span><a href="#534989" title="Types.this.Type">glbThisType</a>, <a href="#534988" title="Types.this.Type">glbRefined</a>, <a href="#534990" title="(proto: Types.this.Symbol)Types.this.Symbol">glbsym</a><span class="delimiter">(</span><a href="#535360" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
                      <span class="keyword">case</span> <a title="Unit" id="535365">ex</a>: <a href="#441582" title="Types.this.NoCommonType">NoCommonType</a> =&gt;
                    <span class="delimiter">}</span>
              <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                <a href="#441564" title="(x$1: Int)Unit">globalGlbDepth</a> <a href="../../Int.scala.html#57955" title="(x: Int)Int">-=</a> <span title="Int(1)" class="int">1</span>
              <span class="delimiter">}</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#534988" title="Types.this.Type">glbRefined</a>.<a href="#442019" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#447327" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#534779" title="Types.this.Type">glbBase</a> <span class="keyword">else</span> <a href="#534988" title="Types.this.Type">glbRefined</a>
          <span class="delimiter">}</span>
        <a href="#441386" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#534774" title="List[Types.this.Symbol]">tparams</a>, <a href="#534780" title="Types.this.Type">glbType</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="#441561" title="Types.this.Type" id="535394">GlbFailure</a> =&gt;
          <a href="#535396" title="(x: Types.this.Type)Types.this.Type" class="keyword">if</a> <span class="delimiter">(</span><a href="#534291" title="List[Types.this.Type]">ts</a> <a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a title="Types.this.Type" id="535383">t</a> =&gt; <a href="Definitions.scala.html#442195" title="Types.this.definitions.NullClass.type">NullClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#535383" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Definitions.scala.html#442195" title="Types.this.definitions.NullClass.type">NullClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a>
          <span class="keyword">else</span> <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    // if (settings.debug.value) { println(indent + &quot;glb of &quot; + ts + &quot; at depth &quot;+depth); indent = indent + &quot;  &quot; } //DEBUG

    <span class="keyword">val</span> <a title="Types.this.Type" id="534381">res</a> = <a href="#534379" title="(ts0: List[Types.this.Type])Types.this.Type">glb0</a><span class="delimiter">(</span><a href="#534291" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>

    // if (settings.debug.value) { indent = indent.substring(0, indent.length() - 2); log(indent + &quot;glb of &quot; + ts + &quot; is &quot; + res) }//DEBUG

    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#534291" title="List[Types.this.Type]">ts</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#535409" title="Types.this.Type">_</a>.<a href="#441975" title="=&gt; Boolean">isNotNull</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#534381" title="Types.this.Type">res</a>.<a href="#442013" title="=&gt; Types.this.Type">notNull</a> <span class="keyword">else</span> <a href="#534381" title="Types.this.Type">res</a>
  <span class="delimiter">}</span>

  /** A list of the typevars in a type. */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)List[Types.this.TypeVar]" id="441571">typeVarsInType</a><span class="delimiter">(</span><a title="Types.this.Type" id="535410">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.TypeVar]">List</a><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="List[Types.this.TypeVar]" id="535412">tvs</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.TypeVar]">List</a><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> = <a href="../../collection/immutable/List.scala.html#11552" title="scala.collection.immutable.Nil.type">Nil</a>
    <a href="#535410" title="Types.this.Type">tp</a> <a href="#442050" title="(f: Types.this.Type =&gt; Unit)Unit">foreach</a> <a title="anonymous class $anonfun extends scala.runtime.AbstractFunction1[Types.this.Type,Unit] with Serializable" id="535415" class="delimiter">{</a>
      <span class="keyword">case</span> <a href="#535428" title="Unit" id="535430">t</a>: TypeVar =&gt; <a href="#535412" title="List[Types.this.TypeVar]">tvs</a> <a href="#535431" title="(x: Unit)Unit">::=</a> t
      <span class="keyword">case</span> _          =&gt;
    <span class="delimiter">}</span>
    <a href="#535412" title="List[Types.this.TypeVar]">tvs</a>.<a href="../../collection/immutable/List.scala.html#63674" title="=&gt; List[Types.this.TypeVar]">reverse</a>
  <span class="delimiter">}</span>
  /** Make each type var in this type use its original type for comparisons instead
   * of collecting constraints.
   */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)List[Types.this.TypeVar]" id="441572">suspendTypeVarsInType</a><span class="delimiter">(</span><a title="Types.this.Type" id="515995">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.TypeVar]">List</a><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="List[Types.this.TypeVar]" id="535447">tvs</a> = <a href="#441571" title="(tp: Types.this.Type)List[Types.this.TypeVar]">typeVarsInType</a><span class="delimiter">(</span><a href="#515995" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    // !!! Is it somehow guaranteed that this will not break under nesting?
    // In general one has to save and restore the contents of the field...
    <a href="#535447" title="List[Types.this.TypeVar]">tvs</a> <a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.TypeVar =&gt; Unit)Unit">foreach</a> <span class="delimiter">(</span><a href="#535467" title="Types.this.TypeVar">_</a>.<a href="#470180" title="(x$1: Boolean)Unit">suspended</a> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <a href="#535447" title="List[Types.this.TypeVar]">tvs</a>
  <span class="delimiter">}</span>

  /** Compute lub (if `variance == 1`) or glb (if `variance == -1`) of given list
   *  of types `tps`. All types in `tps` are typerefs or singletypes
   *  with the same symbol.
   *  Return `Some(x)` if the computation succeeds with result `x`.
   *  Return `None` if the computation fails.
   */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], variance: Int, depth: Int)Option[Types.this.Type]" id="441573">mergePrefixAndArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="447386">tps</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="447387">variance</a>: <a href="../../Int.scala.html#508" title="Int">Int</a>, <a title="Int" id="447388">depth</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[Types.this.Type]">Option</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#447386" title="List[Types.this.Type]">tps</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="../../collection/generic/SeqFactory.scala.html#60838" title="Option[List[Types.this.Type]]" id="536061">List</a><span class="delimiter">(</span>tp<span class="delimiter">)</span> =&gt;
      <a href="../../Option.scala.html#64111" title="(x: Types.this.Type)Some[Types.this.Type]">Some</a><a href="#536050" title="(x: Option[Types.this.Type])Option[Types.this.Type]" class="delimiter">(</a>tp<span class="delimiter">)</span>
    <span class="keyword">case</span> TypeRef<a title="Option[Types.this.Type]" id="536039" class="delimiter">(</a>_, sym, _<span class="delimiter">)</span> <a href="#536030" title="Boolean" id="536035">::</a> rest =&gt;
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="535491">pres</a> = <a href="#447386" title="List[Types.this.Type]">tps</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#535511" title="Types.this.Type">_</a>.<a href="#441997" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span> // prefix normalizes automatically
      <span class="keyword">val</span> <a title="Types.this.Type" id="535492">pre</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#447387" title="Int">variance</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#441560" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#535491" title="List[Types.this.Type]">pres</a>, <a href="#447388" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#441569" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#535491" title="List[Types.this.Type]">pres</a>, <a href="#447388" title="Int">depth</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="535493">argss</a> = <a href="#447386" title="List[Types.this.Type]">tps</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</a> <span class="delimiter">(</span><a href="#535561" title="Types.this.Type">_</a>.<a href="#442017" title="=&gt; Types.this.Type">normalize</a>.<a href="#442000" title="=&gt; List[Types.this.Type]">typeArgs</a><span class="delimiter">)</span> // symbol equality (of the tp in tps) was checked using typeSymbol, which normalizes, so should normalize before retrieving arguments
      <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[Types.this.Symbol]" id="535494">capturedParams</a> = <span title="scala.collection.mutable.ListBuffer[Types.this.Symbol]" class="keyword">new</span> <a href="../../collection/mutable/ListBuffer.scala.html#13747" title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">ListBuffer</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span>sym <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#442352" title="=&gt; Types.this.ClassSymbol">ArrayClass</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          // special treatment for lubs of array types after erasure:
          // if argss contain one value type and some other type, the lub is Object
          // if argss contain several reference types, the lub is an array over lub of argtypes
          <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#535493" title="List[List[Types.this.Type]]">argss</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: List[Types.this.Type] =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#535599" title="List[Types.this.Type]">_</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="../../Option.scala.html#2498" title="None.type">None</a>  // something is wrong: an array without a type arg.
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[Types.this.Type]" id="535600">args</a> = <a href="#535493" title="List[List[Types.this.Type]]">argss</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: List[Types.this.Type] =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#535617" title="List[Types.this.Type]">_</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a><span class="delimiter">)</span>
            <span title="Some[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#535600" title="List[Types.this.Type]">args</a>.<a href="../../collection/TraversableLike.scala.html#59012" title="=&gt; List[Types.this.Type]">tail</a> <a href="../../collection/LinearSeqOptimized.scala.html#76169" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a href="#535653" title="Types.this.Type">_</a> <a href="#442062" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#535600" title="List[Types.this.Type]">args</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Option.scala.html#64111" title="(x: Types.this.Type)Some[Types.this.Type]">Some</a><span class="delimiter">(</span><a href="#441371" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#535492" title="Types.this.Type">pre</a>, sym, <a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><a href="#535600" title="List[Types.this.Type]">args</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword">else</span> <span title="Some[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#535600" title="List[Types.this.Type]">args</a> <a href="../../collection/LinearSeqOptimized.scala.html#76170" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a title="Types.this.Type" id="535671">arg</a> =&gt; <a href="Definitions.scala.html#442785" title="(sym: Types.this.Symbol)Boolean">isPrimitiveValueClass</a><span class="delimiter">(</span><a href="#535671" title="Types.this.Type">arg</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Option.scala.html#64111" title="(x: Types.this.Type)Some[Types.this.Type]">Some</a><span class="delimiter">(</span><a href="Definitions.scala.html#442179" title="=&gt; Types.this.ClassSymbol">ObjectClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="../../Option.scala.html#64111" title="(x: Types.this.Type)Some[Types.this.Type]">Some</a><span class="delimiter">(</span><a href="#441371" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#535492" title="Types.this.Type">pre</a>, sym, <a href="../../collection/immutable/List.scala.html#63291" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><a href="#441559" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#535600" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="535691">args</a> = <a href="util/Collections.scala.html#440665" title="(xs1: List[Types.this.Symbol], xs2: List[List[Types.this.Type]])(f: (Types.this.Symbol, List[Types.this.Type]) =&gt; Types.this.Type)List[Types.this.Type]">map2</a><span class="delimiter">(</span>sym.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#535493" title="List[List[Types.this.Type]]">argss</a>.<a href="../../collection/generic/GenericTraversableTemplate.scala.html#59389" title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.GenTraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="535752">tparam</a>, <a title="List[Types.this.Type]" id="535753">as</a><span class="delimiter">)</span> =&gt;
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#447388" title="Int">depth</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#535752" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443377" title="=&gt; Int">variance</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <a href="#447387" title="Int">variance</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                // Take the intersection of the upper bounds of the type parameters
                // rather than falling all the way back to &quot;Any&quot;, otherwise we end up not
                // conforming to bounds.
                <span class="keyword">val</span> <a title="List[Types.this.Type]" id="535763">bounds0</a> = sym.<a href="Symbols.scala.html#443447" title="=&gt; List[Types.this.Symbol]">typeParams</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#535783" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#441994" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#448328" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span> <a href="../../collection/TraversableLike.scala.html#58982" title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</a> <span class="delimiter">(</span><a href="#535816" title="Types.this.Type">_</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a><span class="delimiter">)</span>
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#535763" title="List[Types.this.Type]">bounds0</a>.<a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a>
                <span class="keyword">else</span> <a href="#441376" title="(tps: List[Types.this.Type])Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="#535763" title="List[Types.this.Type]">bounds0</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a title="Types.this.Type" id="535842">b</a> =&gt; <a href="#535842" title="Types.this.Type">b</a>.<a href="#442037" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#447386" title="List[Types.this.Type]">tps</a>.<a href="../../collection/IterableLike.scala.html#59473" title="=&gt; Types.this.Type">head</a>, sym<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="delimiter">}</span>
              <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#535752" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443377" title="=&gt; Int">variance</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <a href="../../Int.scala.html#57880" title="=&gt; Int">-</a><a href="#447387" title="Int">variance</a><span class="delimiter">)</span> <a href="Definitions.scala.html#442193" title="Types.this.definitions.NothingClass.type">NothingClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a>
              <span class="keyword">else</span> <a href="#516490" title="Types.this.NoType.type">NoType</a>
            <span class="delimiter">}</span>
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#535752" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443377" title="=&gt; Int">variance</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <a href="#447387" title="Int">variance</a><span class="delimiter">)</span> <a href="#441560" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#535753" title="List[Types.this.Type]">as</a>, <a href="#441213" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#447388" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#535752" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443377" title="=&gt; Int">variance</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <a href="../../Int.scala.html#57880" title="=&gt; Int">-</a><a href="#447387" title="Int">variance</a><span class="delimiter">)</span> <a href="#441569" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#535753" title="List[Types.this.Type]">as</a>, <a href="#441213" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#447388" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span class="delimiter">{</span>
                <span class="keyword">val</span> <a title="Types.this.Type" id="535895">l</a> = <a href="#441560" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#535753" title="List[Types.this.Type]">as</a>, <a href="#441213" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#447388" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">val</span> <a title="Types.this.Type" id="535896">g</a> = <a href="#441569" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#535753" title="List[Types.this.Type]">as</a>, <a href="#441213" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#447388" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#535895" title="Types.this.Type">l</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#535896" title="Types.this.Type">g</a><span class="delimiter">)</span> <a href="#535895" title="Types.this.Type">l</a>
                <span class="keyword">else</span> <span class="delimiter">{</span> // Martin: I removed this, because incomplete. Not sure there is a good way to fix it. For the moment we
                       // just err on the conservative side, i.e. with a bound that is too high.
                       // if(!(tparam.info.bounds contains tparam))   //@M can't deal with f-bounds, see #2251

                  <span class="keyword">val</span> <a title="Types.this.TypeSymbol" id="535906">qvar</a> = <a href="#441472" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#535753" title="List[Types.this.Type]">as</a><span class="delimiter">)</span> <a href="Symbols.scala.html#443202" title="(suffix: String)Types.this.TypeSymbol">freshExistential</a> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <a href="Symbols.scala.html#443429" title="(info: Types.this.Type)Types.this.TypeSymbol">setInfo</a> <a href="#448285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#535896" title="Types.this.Type">g</a>, <a href="#535895" title="Types.this.Type">l</a><span class="delimiter">)</span>
                  <a href="#535494" title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">capturedParams</a> <a href="../../collection/mutable/ListBuffer.scala.html#67856" title="(x: Types.this.Symbol)capturedParams.type">+=</a> <a href="#535906" title="Types.this.TypeSymbol">qvar</a>
                  <a href="#535906" title="Types.this.TypeSymbol">qvar</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#535691" title="List[Types.this.Type]">args</a> <a href="../../collection/SeqLike.scala.html#59768" title="(elem: Any)Boolean">contains</a> <a href="#516490" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="../../Option.scala.html#2498" title="None.type">None</a>
          <span class="keyword">else</span> <a href="../../Option.scala.html#64111" title="(x: Types.this.Type)Some[Types.this.Type]">Some</a><span class="delimiter">(</span><a href="#441386" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#535494" title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">capturedParams</a>.<a href="../../collection/mutable/ListBuffer.scala.html#67864" title="=&gt; List[Types.this.Symbol]">toList</a>, <a href="#441371" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#535492" title="Types.this.Type">pre</a>, sym, <a href="#535691" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="None.type" id="535930">ex</a>: <a href="#441583" title="Types.this.MalformedType">MalformedType</a> =&gt; <a href="../../Option.scala.html#2498" title="None.type">None</a>
        <span class="keyword">case</span> <a title="None.type" id="535931">ex</a>: <span title="IndexOutOfBoundsException">IndexOutOfBoundsException</span> =&gt;  // transpose freaked out because of irregular argss
        // catching just in case (shouldn't happen, but also doesn't cost us)
        <a href="SymbolTable.scala.html#440551" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><span title="String(&quot;transposed irregular matrix!?&quot;)" class="string">&quot;transposed irregular matrix!?&quot;</span><a href="../../Tuple2.scala.html#63804" title="(x$1: Any)String">+</a> <span class="delimiter">(</span><a href="#447386" title="List[Types.this.Type]">tps</a>, <a href="#535493" title="List[List[Types.this.Type]]">argss</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="../../Option.scala.html#2498" title="None.type">None</a>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> SingleType<a title="Option[Types.this.Type]" id="536044" class="delimiter">(</a>_, sym<span class="delimiter">)</span> :: rest =&gt;
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="535945">pres</a> = <a href="#447386" title="List[Types.this.Type]">tps</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#535963" title="Types.this.Type">_</a>.<a href="#441997" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="535946">pre</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#447387" title="Int">variance</a> <a href="../../Int.scala.html#57891" title="(x: Int)Boolean">==</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#441560" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#535945" title="List[Types.this.Type]">pres</a>, <a href="#447388" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#441569" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#535945" title="List[Types.this.Type]">pres</a>, <a href="#447388" title="Int">depth</a><span class="delimiter">)</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="../../Option.scala.html#64111" title="(x: Types.this.Type)Some[Types.this.Type]">Some</a><span class="delimiter">(</span><a href="#441367" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#535946" title="Types.this.Type">pre</a>, sym<span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="None.type" id="536006">ex</a>: <a href="#441583" title="Types.this.MalformedType">MalformedType</a> =&gt; <a href="../../Option.scala.html#2498" title="None.type">None</a>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> ExistentialType<a title="Option[Types.this.Type]" id="536048" class="delimiter">(</a>tparams, quantified<span class="delimiter">)</span> :: rest =&gt;
      <a href="#441573" title="(tps: List[Types.this.Type], variance: Int, depth: Int)Option[Types.this.Type]">mergePrefixAndArgs</a><span class="delimiter">(</span>quantified <a href="../../collection/immutable/List.scala.html#63643" title="(x: Types.this.Type)List[Types.this.Type]">::</a> rest, <a href="#447387" title="Int">variance</a>, <a href="#447388" title="Int">depth</a><span class="delimiter">)</span> <a href="#536050" title="(x: Option[Types.this.Type])Option[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#441386" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span>tparams, <a href="#536025" title="Types.this.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> _ =&gt;
      <a href="../../Predef.scala.html#8460" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span>, <a href="#447386" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>; <a href="../../Option.scala.html#2498" title="None.type">None</a>
  <span class="delimiter">}</span>

  /** Make symbol `sym` a member of scope `tp.decls`
   *  where `thistp` is the narrowed owner type of the scope.
   */
  <span class="keyword">def</span> <a title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol)Unit" id="441574">addMember</a><span class="delimiter">(</span><a title="Types.this.Type" id="496715">thistp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="496716">tp</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="496717">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#8459" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span><a href="#496717" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Symbols.scala.html#441152" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
    // debuglog(&quot;add member &quot; + sym+&quot;:&quot;+sym.info+&quot; to &quot;+thistp) //DEBUG
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#496715" title="Types.this.Type">thistp</a> <a href="#442063" title="(sym: Types.this.Symbol)Boolean">specializes</a> <a href="#496717" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#496717" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443229" title="=&gt; Boolean">isTerm</a><span class="delimiter">)</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="536097">alt</a> &lt;- <a href="#496716" title="Types.this.Type">tp</a>.<a href="#442022" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateDecl</a><span class="delimiter">(</span><a href="#496717" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#443152" title="=&gt; sym.NameType">name</a><span class="delimiter">)</span>.<a href="../../collection/LinearSeqOptimized.scala.html#76166" title="(f: Types.this.Symbol =&gt; Unit)Unit">alternatives</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#441527" title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#496715" title="Types.this.Type">thistp</a>, <a href="#496717" title="Types.this.Symbol">sym</a>, <a href="#496715" title="Types.this.Type">thistp</a>, <a href="#536097" title="Types.this.Symbol">alt</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#496716" title="Types.this.Type">tp</a>.<a href="#442019" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#447339" title="(sym: Types.this.Symbol)Unit">unlink</a> <a href="#536097" title="Types.this.Symbol">alt</a>;
      <a href="#496716" title="Types.this.Type">tp</a>.<a href="#442019" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#447331" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#496717" title="Types.this.Symbol">sym</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** All types in list must be polytypes with type parameter lists of
   *  same length as tparams.
   *  Returns list of list of bounds infos, where corresponding type
   *  parameters are renamed to tparams.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[List[Types.this.Type]]" id="441575">matchingBounds</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="533431">tps</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="533432">tparams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[List[Types.this.Type]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)List[Types.this.Type]" id="536113">getBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="536114">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#536114" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> PolyType<a href="#536165" title="List[Types.this.Type]" id="536168" class="delimiter">(</a>tparams1, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span>tparams1, <a href="#533432" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> =&gt;
        tparams1 <a href="#536169" title="(x: List[Types.this.Type])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="536134">tparam</a> =&gt; <a href="#536134" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#443427" title="=&gt; Types.this.Type">info</a>.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span>tparams1, <a href="#533432" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> tp =&gt;
        <a href="#536169" title="(x: List[Types.this.Type])List[Types.this.Type]" class="keyword">if</a> <span class="delimiter">(</span>tp <span title="(x$1: AnyRef)Boolean">ne</span> tp.<a href="#442017" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#536113" title="(tp: Types.this.Type)List[Types.this.Type]">getBounds</a><span class="delimiter">(</span>tp.<a href="#442017" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <span title="Types.this.NoCommonType" class="keyword">new</span> <a href="#441582" title="Types.this.NoCommonType">NoCommonType</a><span class="delimiter">(</span><a href="#533431" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#533431" title="List[Types.this.Type]">tps</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</a> <a href="#536113" title="(tp: Types.this.Type)List[Types.this.Type]">getBounds</a>
  <span class="delimiter">}</span>

  /** All types in list must be polytypes with type parameter lists of
   *  same length as tparams.
   *  Returns list of instance types, where corresponding type
   *  parameters are renamed to tparams.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]" id="441576">matchingInstTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="533531">tps</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="533532">tparams</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="536218">transformResultType</a><span class="delimiter">(</span><a title="Types.this.Type" id="536219">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> = <a href="#536219" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> PolyType<a href="#536226" title="Types.this.Type" id="536228" class="delimiter">(</a>tparams1, restpe<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#441502" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span>tparams1, <a href="#533532" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> =&gt;
        restpe.<a href="#442042" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><a href="#536229" title="(x: Types.this.Type)Types.this.Type" class="delimiter">(</a>tparams1, <a href="#533532" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
      <span class="keyword">case</span> tp =&gt;
        <a href="#536229" title="(x: Types.this.Type)Types.this.Type" class="keyword">if</a> <span class="delimiter">(</span>tp <span title="(x$1: AnyRef)Boolean">ne</span> tp.<a href="#442017" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#536218" title="(tp: Types.this.Type)Types.this.Type">transformResultType</a><span class="delimiter">(</span>tp.<a href="#442017" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <span title="Types.this.NoCommonType" class="keyword">new</span> <a href="#441582" title="Types.this.NoCommonType">NoCommonType</a><span class="delimiter">(</span><a href="#533531" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#533531" title="List[Types.this.Type]">tps</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#536218" title="(tp: Types.this.Type)Types.this.Type">transformResultType</a>
  <span class="delimiter">}</span>

  /** All types in list must be method types with equal parameter types.
   *  Returns list of their result types.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]" id="441577">matchingRestypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="533546">tps</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="533547">pts</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> =
    <a href="#533546" title="List[Types.this.Type]">tps</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a title="anonymous class $anonfun extends scala.runtime.AbstractFunction1[Types.this.Type,Types.this.Type] with Serializable" id="536294" class="delimiter">{</a>
      <span class="keyword">case</span> MethodType<a href="#536344" title="Types.this.Type" id="536346" class="delimiter">(</a>params1, res<span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#441501" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span>params1 <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#536314" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#443425" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>, <a href="#533547" title="List[Types.this.Type]">pts</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <a href="#536349" title="(x: Types.this.Type)Types.this.Type">res</a>
      <span class="keyword">case</span> NullaryMethodType<a href="#536344" title="Types.this.Type" id="536348" class="delimiter">(</a>res<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#533547" title="List[Types.this.Type]">pts</a> <a href="../../collection/IterableLike.scala.html#59464" title="=&gt; Boolean">isEmpty</a> =&gt;
        <a href="#536349" title="(x: Types.this.Type)Types.this.Type">res</a>
      <span class="keyword">case</span> _ =&gt;
        <a href="#536349" title="(x: Types.this.Type)Types.this.Type" class="keyword">throw</a> <span title="Types.this.NoCommonType" class="keyword">new</span> <a href="#441582" title="Types.this.NoCommonType">NoCommonType</a><span class="delimiter">(</span><a href="#533546" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

// Errors and Diagnostics -----------------------------------------------------

  /** A throwable signalling a type error */
  <span class="keyword">class</span> <a title="class TypeError extends Throwable" id="441578">TypeError</a><a href="#441578" title="Types.this.TypeError" class="delimiter">(</a><span class="keyword">var</span> <a title="Types.this.Position" id="448888">pos</a>: <a href="../../tools/nsc/util/Position.scala.html#52230" title="Types.this.Position">Position</a>, <span class="keyword">val</span> <a title="String" id="448889">msg</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="../../package.scala.html#56957" title="Throwable">Throwable</a><span class="delimiter">(</span><a href="#448889" title="String">msg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(msg: String)Types.this.TypeError" id="448884" class="keyword">this</a><span class="delimiter">(</span><a title="String" id="448887">msg</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#441578" title="TypeError.this.type" class="keyword">this</a><span class="delimiter">(</span><a href="Positions.scala.html#441880" title="=&gt; tools.nsc.util.NoPosition.type">NoPosition</a>, <a href="#448887" title="String">msg</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  // TODO: RecoverableCyclicReference should be separated from TypeError,
  // but that would be a big change. Left for further refactoring.
  /** An exception for cyclic references from which we can recover */
  case <span class="keyword">class</span> <a title="class RecoverableCyclicReference extends Types.this.TypeError with Product with Serializable" id="536666">RecoverableCyclicReference</a><a href="../../Product.scala.html#304" title="Product" class="delimiter">(</a><a title="Types.this.Symbol" id="536649">sym</a>: <a href="Symbols.scala.html#441132" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>
    <span class="keyword">extends</span> <a href="#441578" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic reference involving &quot;)" class="string">&quot;illegal cyclic reference involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#536649" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456420" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#536666" title="()Unit">printStackTrace</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class NoCommonType extends Throwable with scala.util.control.ControlThrowable" id="441582">NoCommonType</a><a href="#441582" title="Types.this.NoCommonType" class="delimiter">(</a><a title="List[Types.this.Type]" id="536163">tps</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="../../package.scala.html#56957" title="Throwable">Throwable</a><span class="delimiter">(</span>
    <span title="String(&quot;lub/glb of incompatible types: &quot;)" class="string">&quot;lub/glb of incompatible types: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#536163" title="List[Types.this.Type]">tps</a>.<a href="../../collection/TraversableOnce.scala.html#59189" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="String(&quot; and &quot;)" class="string">&quot; and &quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">with</span> <a href="../../util/control/ControlThrowable.scala.html#53835" title="scala.util.control.ControlThrowable">ControlThrowable</a>

  /** A throwable signalling a malformed type */
  <span class="keyword">class</span> <a title="class MalformedType extends Types.this.TypeError" id="441583">MalformedType</a><a href="#441583" title="Types.this.MalformedType" class="delimiter">(</a><a title="String" id="528940">msg</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#441578" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><a href="#528940" title="String">msg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, tp: String)Types.this.MalformedType" id="527968" class="keyword">this</a><span class="delimiter">(</span><a title="Types.this.Type" id="528938">pre</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="String" id="528939">tp</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#441583" title="MalformedType.this.type" class="keyword">this</a><span class="delimiter">(</span><span title="String(&quot;malformed type: &quot;)" class="string">&quot;malformed type: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#528938" title="Types.this.Type">pre</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#528939" title="String">tp</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** The current indentation string for traces */
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="String" id="441585">indent</a>: <span title="String">String</span> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>

  /** Perform operation `p` on arguments `tp1`, `arg2` and print trace of computation. */
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="[T](op: String, p: (Types.this.Type, T) =&gt; Boolean, tp1: Types.this.Type, arg2: T)Boolean" id="441587">explain</a><span class="delimiter">[</span><a title="" id="441589">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="515483">op</a>: <span title="String">String</span>, <a title="(Types.this.Type, T) =&gt; Boolean" id="515484">p</a>: <span class="delimiter">(</span>Type, T<span class="delimiter">)</span> =&gt; Boolean, <a title="Types.this.Type" id="515485">tp1</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="T" id="515486">arg2</a>: <a href="#441589" title="T">T</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
    <a href="../../Console.scala.html#227" title="Console.type">Console</a>.<a href="../../Console.scala.html#64301" title="(x: Any)Unit">println</a><span class="delimiter">(</span><a href="#441585" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <a href="#515485" title="Types.this.Type">tp1</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#515483" title="String">op</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#515486" title="T">arg2</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span> /* + &quot;(&quot;+tp1.getClass+&quot;,&quot;+arg2.getClass+&quot;)&quot;*/<span class="delimiter">)</span>
    <a href="#441585" title="(x$1: String)Unit">indent</a> = <a href="#441585" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
    <span class="keyword">val</span> <a title="Boolean" id="536486">result</a> = <a href="../../Function2.scala.html#65847" title="(v1: Types.this.Type, v2: T)Boolean">p</a><span class="delimiter">(</span><a href="#515485" title="Types.this.Type">tp1</a>, <a href="#515486" title="T">arg2</a><span class="delimiter">)</span>
    <a href="#441585" title="(x$1: String)Unit">indent</a> = <a href="../../Predef.scala.html#8578" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">indent</a> <a href="../../collection/immutable/StringLike.scala.html#60709" title="(suffix: String)String">stripSuffix</a> <span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
    <a href="../../Console.scala.html#227" title="Console.type">Console</a>.<a href="../../Console.scala.html#64301" title="(x: Any)Unit">println</a><span class="delimiter">(</span><a href="#441585" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <a href="#536486" title="Boolean">result</a><span class="delimiter">)</span>
    <a href="#536486" title="Boolean">result</a>
  <span class="delimiter">}</span>

  /** If option `explaintypes` is set, print a subtype trace for `found &lt;:&lt; required`. */
  <span class="keyword">def</span> <a title="(found: Types.this.Type, required: Types.this.Type)Unit" id="441590">explainTypes</a><span class="delimiter">(</span><a title="Types.this.Type" id="536496">found</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="536497">required</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456422" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">explaintypes</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#441592" title="(op: =&gt; Boolean)Boolean">withTypesExplained</a><span title="Unit" class="delimiter">(</span><a href="#536496" title="Types.this.Type">found</a> <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#536497" title="Types.this.Type">required</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** If option `explaintypes` is set, print a subtype trace for `op(found, required)`. */
  <span class="keyword">def</span> <a title="(op: (Types.this.Type, Types.this.Type) =&gt; Any, found: Types.this.Type, required: Types.this.Type)Unit" id="441591">explainTypes</a><span class="delimiter">(</span><a title="(Types.this.Type, Types.this.Type) =&gt; Any" id="536509">op</a>: <span class="delimiter">(</span>Type, Type<span class="delimiter">)</span> =&gt; Any, <a title="Types.this.Type" id="536510">found</a>: <a href="#441242" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="536511">required</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#441908" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#456422" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">explaintypes</a>.<a href="settings/MutableSettings.scala.html#456449" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#441592" title="(op: =&gt; Any)Any">withTypesExplained</a><span title="Unit" class="delimiter">(</span><a href="../../Function2.scala.html#65847" title="(v1: Types.this.Type, v2: Types.this.Type)Any">op</a><span class="delimiter">(</span><a href="#536510" title="Types.this.Type">found</a>, <a href="#536511" title="Types.this.Type">required</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Execute `op` while printing a trace of the operations on types executed. */
  <span class="keyword">def</span> <a title="[A](op: =&gt; A)A" id="441592">withTypesExplained</a><span class="delimiter">[</span><a title="" id="441594">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="536502">op</a>: =&gt; A<span class="delimiter">)</span>: <a href="#441594" title="A">A</a> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Boolean" id="536521">s</a> = <a href="#441201" title="=&gt; Boolean">explainSwitch</a>
    <span class="keyword">try</span> <span class="delimiter">{</span> <a href="#441201" title="(x$1: Boolean)Unit">explainSwitch</a> = <span title="Boolean(true)" class="keyword">true</span>; <a href="#536502" title="=&gt; A">op</a> <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span> <a href="#441201" title="(x$1: Boolean)Unit">explainSwitch</a> = <a href="#536521" title="Boolean">s</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="441595">isUnboundedGeneric</a><span class="delimiter">(</span><a title="Types.this.Type" id="536523">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#536523" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> t @ TypeRef<a href="#536530" title="Boolean" id="536534" class="delimiter">(</a>_, sym, _<span class="delimiter">)</span> =&gt; sym.<a href="Symbols.scala.html#443233" title="=&gt; Boolean">isAbstractType</a> <a href="#536535" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><span class="delimiter">(</span>t <a href="#442058" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="Definitions.scala.html#442177" title="=&gt; Types.this.AliasTypeSymbol">AnyRefClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="keyword">case</span> _                      =&gt; <a href="#536535" title="(x: Boolean)Boolean" class="keyword">false</a>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="441596">isBoundedGeneric</a><span class="delimiter">(</span><a title="Types.this.Type" id="536540">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#536540" title="Types.this.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> TypeRef<a href="#536547" title="Boolean" id="536551" class="delimiter">(</a>_, sym, _<span class="delimiter">)</span> <span class="keyword">if</span> sym.<a href="Symbols.scala.html#443233" title="=&gt; Boolean">isAbstractType</a> =&gt; <span class="delimiter">(</span><a href="#536540" title="Types.this.Type">tp</a> <a href="#536557" title="(x: Boolean)Boolean">&lt;:&lt;</a> <a href="Definitions.scala.html#442177" title="=&gt; Types.this.AliasTypeSymbol">AnyRefClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="keyword">case</span> TypeRef<span class="delimiter">(</span>_, sym, _<span class="delimiter">)</span>                       =&gt; <a href="#536557" title="(x: Boolean)Boolean">!</a><a href="Definitions.scala.html#442785" title="(sym: Types.this.Symbol)Boolean">isPrimitiveValueClass</a><span class="delimiter">(</span>sym<span class="delimiter">)</span>
    <span class="keyword">case</span> _                                        =&gt; <a href="#536557" title="(x: Boolean)Boolean" class="keyword">false</a>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="441597">objToAny</a><span class="delimiter">(</span><a title="Types.this.Type" id="536563">tp</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#441242" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#440593" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#452455" title="=&gt; Boolean">erasedTypes</a> <a href="../../Boolean.scala.html#58725" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#536563" title="Types.this.Type">tp</a>.<a href="#441986" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#442179" title="=&gt; Types.this.ClassSymbol">ObjectClass</a><span class="delimiter">)</span> <a href="Definitions.scala.html#442175" title="=&gt; Types.this.ClassSymbol">AnyClass</a>.<a href="Symbols.scala.html#443721" title="=&gt; Types.this.Type">tpe</a>
    <span class="keyword">else</span> <a href="#536563" title="Types.this.Type">tp</a>

  <span class="keyword">val</span> <a title="scala.collection.immutable.Set[String]" id="441598">shorthands</a> = <a href="../../collection/generic/GenericCompanion.scala.html#60782" title="(elems: String*)scala.collection.immutable.Set[String]">Set</a><span class="delimiter">(</span>
    <span title="String(&quot;scala.collection.immutable.List&quot;)" class="string">&quot;scala.collection.immutable.List&quot;</span>,
    <span title="String(&quot;scala.collection.immutable.Nil&quot;)" class="string">&quot;scala.collection.immutable.Nil&quot;</span>,
    <span title="String(&quot;scala.collection.Seq&quot;)" class="string">&quot;scala.collection.Seq&quot;</span>,
    <span title="String(&quot;scala.collection.Traversable&quot;)" class="string">&quot;scala.collection.Traversable&quot;</span>,
    <span title="String(&quot;scala.collection.Iterable&quot;)" class="string">&quot;scala.collection.Iterable&quot;</span>,
    <span title="String(&quot;scala.collection.mutable.StringBuilder&quot;)" class="string">&quot;scala.collection.mutable.StringBuilder&quot;</span>,
    <span title="String(&quot;scala.collection.IndexedSeq&quot;)" class="string">&quot;scala.collection.IndexedSeq&quot;</span>,
    <span title="String(&quot;scala.collection.Iterator&quot;)" class="string">&quot;scala.collection.Iterator&quot;</span><span class="delimiter">)</span>


  /** The maximum number of recursions allowed in toString
   */
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="441600">maxTostringRecursions</a> = <span title="Int(50)" class="int">50</span>

  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="441603">tostringRecursions</a> = <span title="Int(0)" class="int">0</span>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tpe: Types.this.Type)String" id="441605">typeToString</a><span class="delimiter">(</span><a title="Types.this.Type" id="515893">tpe</a>: <a href="#441242" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="String">String</span> =
    <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#441603" title="=&gt; Int">tostringRecursions</a> <a href="../../Int.scala.html#57926" title="(x: Int)Boolean">&gt;=</a> <span title="Int(50)">maxTostringRecursions</span><span class="delimiter">)</span>
      <span title="String(&quot;...&quot;)" class="string">&quot;...&quot;</span>
    <span class="keyword">else</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#441603" title="(x$1: Int)Unit">tostringRecursions</a> <a href="../../Int.scala.html#57948" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
        <a href="#515893" title="Types.this.Type">tpe</a>.<a href="#442077" title="=&gt; String">safeToString</a>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
        <a href="#441603" title="(x$1: Int)Unit">tostringRecursions</a> <a href="../../Int.scala.html#57955" title="(x: Int)Int">-=</a> <span title="Int(1)" class="int">1</span>
      <span class="delimiter">}</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>