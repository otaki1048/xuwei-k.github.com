<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/util/matching/Regex.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2007-2011, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */


/**
 * This package is concerned with regular expression (regex) matching against strings,
 * with the main goal of pulling out information from those matches, or replacing
 * them with something else.
 *
 * There are four classes and three objects, with most of them being members of
 * Regex companion object. [[scala.util.matching.Regex]] is the class users instantiate
 * to do regular expression matching.
 *
 * The remaining classes and objects in the package are used in the following way:
 *
 * * The companion object to [[scala.util.matching.Regex]] just contains the other members.
 * * [[scala.util.matching.Regex.Match]] makes more information about a match available.
 * * [[scala.util.matching.Regex.MatchIterator]] is used to iterate over multiple matches.
 * * [[scala.util.matching.Regex.MatchData]] is just a base trait for the above classes.
 * * [[scala.util.matching.Regex.Groups]] extracts group from a [[scala.util.matching.Regex.Match]]
 *   without recomputing the match.
 * * [[scala.util.matching.Regex.Match]] converts a [[scala.util.matching.Regex.Match]]
 *   into a [[java.lang.String]].
 *
 */
<span class="keyword">package</span> scala.util.matching

<span class="keyword">import</span> scala.collection.AbstractIterator
<span class="keyword">import</span> java.util.regex.<span class="delimiter">{</span> Pattern, Matcher <span class="delimiter">}</span>

/** This class provides methods for creating and using regular expressions.
 *  It is based on the regular expressions of the JDK since 1.4.
 *
 *  Its main goal is to extract strings that match a pattern, or the subgroups
 *  that make it up. For that reason, it is usually used with for comprehensions
 *  and matching (see methods for examples).
 *
 *  A Regex is created from a [[java.lang.String]] representation of the
 *  regular expression pattern^1^. That pattern is compiled
 *  during construction, so frequently used patterns should be declared outside
 *  loops if performance is of concern. Possibly, they might be declared on a
 *  companion object, so that they need only to be initialized once.
 *
 *  The canonical way of creating regex patterns is by using the method `r`, provided
 *  on [[java.lang.String]] through an implicit conversion into
 *  [[scala.collection.immutable.WrappedString]]. Using triple quotes to write these
 *  strings avoids having to quote the backslash character (`\`).
 *
 *  Using the constructor directly, on the other hand, makes
 *  it possible to declare names for subgroups in the pattern.
 *
 *  For example, both declarations below generate the same regex, but the second
 *  one associate names with the subgroups.
 *
 *  {{{
 *  val dateP1 = &quot;&quot;&quot;(\d\d\d\d)-(\d\d)-(\d\d)&quot;&quot;&quot;.r
 *  val dateP2 = new scala.util.matching.Regex(&quot;&quot;&quot;(\d\d\d\d)-(\d\d)-(\d\d)&quot;&quot;&quot;, &quot;year&quot;, &quot;month&quot;, &quot;day&quot;)
 *  }}}
 *
 *  There are two ways of using a `Regex` to find a pattern: calling methods on
 *  Regex, such as `findFirstIn` or `findAllIn`, or using it as an extractor in a
 *  pattern match.
 *
 *  Note, however, that when Regex is used as an extractor in a pattern match, it
 *  only succeeds if the whole text can be matched. For this reason, one usually
 *  calls a method to find the matching substrings, and then use it as an extractor
 *  to break match into subgroups.
 *
 *  As an example, the above patterns can be used like this:
 *
 *  {{{
 *  val dateP1(year, month, day) = &quot;2011-07-15&quot;
 *
 *  // val dateP1(year, month, day) = &quot;Date 2011-07-15&quot; // throws an exception at runtime
 *
 *  val copyright: String = dateP1 findFirstIn &quot;Date of this document: 2011-07-15&quot; match {
 *    case Some(dateP1(year, month, day)) =&gt; &quot;Copyright &quot;+year
 *    case None                           =&gt; &quot;No copyright&quot;
 *  }
 *
 *  val copyright: Option[String] = for {
 *    dateP1(year, month, day) &lt;- dateP1 findFirstIn &quot;Last modified 2011-07-15&quot;
 *  } yield year

 *  def getYears(text: String): Iterator[String] = for (dateP1(year, _, _) &lt;- dateP1 findAllIn text) yield year
 *  def getFirstDay(text: String): Option[String] = for (m &lt;- dateP2 findFirstMatchIn text) yield m group &quot;day&quot;
 *  }}}
 *
 *  Regex does not provide a method that returns a [[scala.Boolean]]. One can
 *  use [[java.lang.String]] `matches` method, or, if `Regex` is preferred,
 *  either ignore the return value or test the `Option` for emptyness. For example:
 *
 *  {{{
 *  def hasDate(text: String): Boolean = (dateP1 findFirstIn text).nonEmpty
 *  def printLinesWithDates(lines: Traversable[String]) {
 *    lines foreach { line =&gt;
 *      dateP1 findFirstIn line foreach { _ =&gt; println(line) }
 *    }
 *  }
 *  }}}
 *
 *  There are also methods that can be used to replace the patterns
 *  on a text. The substitutions can be simple replacements, or more
 *  complex functions. For example:
 *
 *  {{{
 *  val months = Map( 1 -&gt; &quot;Jan&quot;, 2 -&gt; &quot;Feb&quot;, 3 -&gt; &quot;Mar&quot;,
 *                    4 -&gt; &quot;Apr&quot;, 5 -&gt; &quot;May&quot;, 6 -&gt; &quot;Jun&quot;,
 *                    7 -&gt; &quot;Jul&quot;, 8 -&gt; &quot;Aug&quot;, 9 -&gt; &quot;Sep&quot;,
 *                    10 -&gt; &quot;Oct&quot;, 11 -&gt; &quot;Nov&quot;, 12 -&gt; &quot;Dec&quot;)
 *
 *  import scala.util.matching.Regex.Match
 *  def reformatDate(text: String) = dateP2 replaceAllIn ( text, (m: Match) =&gt;
 *    &quot;%s %s, %s&quot; format (months(m group &quot;month&quot; toInt), m group &quot;day&quot;, m group &quot;year&quot;)
 *  )
 *  }}}
 *
 *  You can use special pattern syntax constructs like `(?idmsux-idmsux)`ยน to switch
 *  various regex compilation options like `CASE_INSENSITIVE` or `UNICODE_CASE`.
 *
 *  @note ยน A detailed description is available in [[java.util.regex.Pattern]].
 *  @see [[java.util.regex.Pattern]]
 *
 *  @author  Thibaud Hottelier
 *  @author  Philipp Haller
 *  @author  Martin Odersky
 *  @version 1.1, 29/01/2008
 *
 *  @param regex      A string representing a regular expression
 *  @param groupNames A mapping from names to indices in capture groups
 *
 *  @define replacementString
 *  In the replacement String, a dollar sign (`$`) followed by a number will be
 *  interpreted as a reference to a group in the matched pattern, with numbers
 *  1 through 9 corresponding to the first nine groups, and 0 standing for the
 *  whole match. Any other character is an error. The backslash (`\`) character
 *  will be interpreted as an escape character, and can be used to escape the
 *  dollar sign. One can use [[scala.util.matching.Regex]]'s `quoteReplacement`
 *  to automatically escape these characters.
 */
@SerialVersionUID<span class="delimiter">(</span>-<span class="long">2094783597747625537L</span><span class="delimiter">)</span>
<span class="keyword">class</span> <a title="class Regex extends AnyRef with Serializable" id="53971">Regex</a><a href="#53971" title="scala.util.matching.Regex" class="delimiter">(</a><a title="String" id="243873">regex</a>: <span title="String">String</span>, <a title="String*" id="243874">groupNames</a>: <span title="String*">String</span>*<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="../../Serializable.scala.html#1369" title="Serializable">Serializable</a> <span class="delimiter">{</span>

  <span class="keyword">import</span> <a href="#1251295" title="scala.util.matching.Regex.type">Regex</a>._

  /** The compiled pattern */
  <span class="keyword">val</span> <a title="java.util.regex.Pattern" id="243852">pattern</a> = <span title="java.util.regex.Pattern.type">Pattern</span>.<span title="(x$1: String)java.util.regex.Pattern">compile</span><span class="delimiter">(</span><a href="#243873" title="String">regex</a><span class="delimiter">)</span>

  /** Tries to match target (whole match) and returns the matching subgroups.
   *  if the pattern has no subgroups, then it returns an empty list on a
   *  successful match.
   *
   *  Note, however, that if some subgroup has not been matched, a `null` will
   *  be returned for that subgroup.
   *
   *  For example:
   *
   *  {{{
   *  val p1 = &quot;ab*c&quot;.r
   *  val p2 = &quot;a(b*)c&quot;.r
   *
   *  val p1Matches = &quot;abbbc&quot; match {
   *    case p1() =&gt; true
   *    case _    =&gt; false
   *  }
   *
   *  val numberOfB = &quot;abbbc&quot; match {
   *    case p2(b) =&gt; Some(b.length)
   *    case _     =&gt; None
   *  }
   *  }}}
   *
   *  @param target The string to match
   *  @return       The matches
   */
  <span class="keyword">def</span> <a title="(target: Any)Option[List[String]]" id="243854">unapplySeq</a><span class="delimiter">(</span><a title="Any" id="409543">target</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[List[String]]">Option</a><span class="delimiter">[</span>List<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#409543" title="Any">target</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#1249889" title="Option[List[String]]" id="1249892">s</a>: java.lang.CharSequence =&gt;
      <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="1249711">m</a> = <a href="#243852" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span>s<span class="delimiter">)</span>
      <span title="Option[List[String]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1249711" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">matches</span><span class="delimiter">)</span> <a href="../../Option.scala.html#64111" title="(x: List[String])Some[List[String]]">Some</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="../../LowPriorityImplicits.scala.html#8333" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">1</a> <a href="../../runtime/RichInt.scala.html#57856" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#1249711" title="java.util.regex.Matcher">m</a>.<span title="()Int">groupCount</span><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#59174" title="=&gt; List[Int]">toList</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Int =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Int],String,List[String]])List[String]">map</a> <a href="#1249711" title="java.util.regex.Matcher">m</a>.<a href="#1249850" title="(x$1: Int)String">group</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="../../Option.scala.html#2498" title="None.type">None</a>
    <span class="keyword">case</span> <a href="#1249882" title="Option[String]" id="1249898">Match</a><a href="#1249889" title="Option[List[String]]" id="1249890" class="delimiter">(</a>s<span class="delimiter">)</span> =&gt;
      <a href="#243854" title="(target: Any)Option[List[String]]">unapplySeq</a><a href="#1249893" title="(x: Option[List[String]])Option[List[String]]" class="delimiter">(</a>s<span class="delimiter">)</span>
    <span class="keyword">case</span> _ =&gt;
      <a href="#1249893" title="(x: Option[List[String]])Option[List[String]]">None</a>
  <span class="delimiter">}</span>

  /** Return all matches of this regexp in given character sequence as a [[scala.util.matching.Regex.MatchIterator]],
   *  which is a special [[scala.collection.Iterator]] that returns the
   *  matched strings, but can also be converted into a normal iterator
   *  that returns objects of type [[scala.util.matching.Regex.Match]]
   *  that can be queried for data such as the text that precedes the
   *  match, subgroups, etc.
   *
   *  @param source The text to match against.
   *  @return       A [[scala.util.matching.Regex.MatchIterator]] of all matches.
   *  @example      {{{for (words &lt;- &quot;&quot;&quot;\w+&quot;&quot;&quot;.r findAllIn &quot;A simple example.&quot;) yield words}}}
   */
  <span class="keyword">def</span> <a title="(source: CharSequence)scala.util.matching.Regex.MatchIterator" id="243855">findAllIn</a><span class="delimiter">(</span><a title="CharSequence" id="941094">source</a>: java.lang.<span title="CharSequence">CharSequence</span><span class="delimiter">)</span> = <span title="scala.util.matching.Regex.MatchIterator" class="keyword">new</span> <a href="#1251295" title="scala.util.matching.Regex.type">Regex</a>.<a href="#409551" title="scala.util.matching.Regex.MatchIterator">MatchIterator</a><span class="delimiter">(</span><a href="#941094" title="CharSequence">source</a>, <a href="#53971" title="scala.util.matching.Regex" class="keyword">this</a>, <a href="#243874" title="String*">groupNames</a><span class="delimiter">)</span>


  /** Return all matches of this regexp in given character sequence as a
   *  [[scala.collection.Iterator]] of [[scala.util.matching.Regex.Match]].
   *
   *  @param source The text to match against.
   *  @return       A [[scala.collection.Iterator]] of [[scala.util.matching.Regex.Match]] for all matches.
   *  @example      {{{for (words &lt;- &quot;&quot;&quot;\w+&quot;&quot;&quot;.r findAllMatchIn &quot;A simple example.&quot;) yield words.start}}}
   */
  <span class="keyword">def</span> <a title="(source: CharSequence)Iterator[scala.util.matching.Regex.Match]" id="243856">findAllMatchIn</a><span class="delimiter">(</span><a title="CharSequence" id="1249900">source</a>: java.lang.<span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../collection/Iterator.scala.html#5383" title="Iterator[scala.util.matching.Regex.Match]">Iterator</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="scala.util.matching.Regex.MatchIterator" id="1249902">matchIterator</a> = <a href="#243855" title="(source: CharSequence)scala.util.matching.Regex.MatchIterator">findAllIn</a><span class="delimiter">(</span><a href="#1249900" title="CharSequence">source</a><span class="delimiter">)</span>
    <a href="#1249903" title="Iterator[scala.util.matching.Regex.Match]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Iterator[scala.util.matching.Regex.Match]" id="1249903">Iterator</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1249905">hasNext</a> = <a href="#1249902" title="scala.util.matching.Regex.MatchIterator">matchIterator</a>.<a href="#941113" title="=&gt; Boolean">hasNext</a>
      <span class="keyword">def</span> <a title="()scala.util.matching.Regex.Match" id="1249906">next</a>: <a href="#409546" title="scala.util.matching.Regex.Match">Match</a> = <span class="delimiter">{</span>
        <a href="#1249902" title="scala.util.matching.Regex.MatchIterator">matchIterator</a>.<a href="#941114" title="()String">next</a>;
        <span title="scala.util.matching.Regex.Match" class="keyword">new</span> <a href="#409546" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">(</span><a href="#1249902" title="scala.util.matching.Regex.MatchIterator">matchIterator</a>.<a href="#941123" title="=&gt; CharSequence">source</a>, <a href="#1249902" title="scala.util.matching.Regex.MatchIterator">matchIterator</a>.<a href="#941108" title="=&gt; java.util.regex.Matcher">matcher</a>, <a href="#1249902" title="scala.util.matching.Regex.MatchIterator">matchIterator</a>.<a href="#941125" title="=&gt; Seq[String]">groupNames</a><span class="delimiter">)</span>.<a href="#563869" title="=&gt; scala.util.matching.Regex.Match">force</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Return optionally first matching string of this regexp in given character sequence,
   *  or None if it does not exist.
   *
   *  @param source The text to match against.
   *  @return       An [[scala.Option]] of the first matching string in the text.
   *  @example      {{{&quot;&quot;&quot;\w+&quot;&quot;&quot;.r findFirstIn &quot;A simple example.&quot; foreach println // prints &quot;A&quot;}}}
   */
  <span class="keyword">def</span> <a title="(source: CharSequence)Option[String]" id="243857">findFirstIn</a><span class="delimiter">(</span><a title="CharSequence" id="1185172">source</a>: java.lang.<span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[String]">Option</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="1250091">m</a> = <a href="#243852" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#1185172" title="CharSequence">source</a><span class="delimiter">)</span>
    <span title="Option[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1250091" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">find</span><span class="delimiter">)</span> <a href="../../Option.scala.html#64111" title="(x: String)Some[String]">Some</a><span class="delimiter">(</span><a href="#1250091" title="java.util.regex.Matcher">m</a>.<span title="()String">group</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="../../Option.scala.html#2498" title="None.type">None</a>
  <span class="delimiter">}</span>

  /** Return optionally first match of this regexp in given character sequence,
   *  or None if it does not exist.
   *
   *  The main difference between this method and `findFirstIn` is that the (optional) return
   *  type for this is [[scala.util.matching.Regex.Match]], through which more
   *  data can be obtained about the match, such as the strings that precede and follow it,
   *  or subgroups.
   *
   *  @param source The text to match against.
   *  @return       A [[scala.Option]] of [[scala.util.matching.Regex.Match]] of the first matching string in the text.
   *  @example      {{{(&quot;&quot;&quot;[a-z]&quot;&quot;&quot;.r findFirstMatchIn &quot;A simple example.&quot;) map (_.start) // returns Some(2), the index of the first match in the text}}}
   */
  <span class="keyword">def</span> <a title="(source: CharSequence)Option[scala.util.matching.Regex.Match]" id="243858">findFirstMatchIn</a><span class="delimiter">(</span><a title="CharSequence" id="1250099">source</a>: java.lang.<span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[scala.util.matching.Regex.Match]">Option</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="1250101">m</a> = <a href="#243852" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#1250099" title="CharSequence">source</a><span class="delimiter">)</span>
    <span title="Option[scala.util.matching.Regex.Match]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1250101" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">find</span><span class="delimiter">)</span> <a href="../../Option.scala.html#64111" title="(x: scala.util.matching.Regex.Match)Some[scala.util.matching.Regex.Match]">Some</a><span class="delimiter">(</span><span title="scala.util.matching.Regex.Match" class="keyword">new</span> <a href="#409546" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">(</span><a href="#1250099" title="CharSequence">source</a>, <a href="#1250101" title="java.util.regex.Matcher">m</a>, <a href="#243874" title="String*">groupNames</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="../../Option.scala.html#2498" title="None.type">None</a>
  <span class="delimiter">}</span>

  /** Return optionally match of this regexp at the beginning of the
   *  given character sequence, or None if regexp matches no prefix
   *  of the character sequence.
   *
   *  The main difference from this method to `findFirstIn` is that this
   *  method will not return any matches that do not begin at the start
   *  of the text being matched against.
   *
   *  @param source The text to match against.
   *  @return       A [[scala.Option]] of the matched prefix.
   *  @example      {{{&quot;&quot;&quot;[a-z]&quot;&quot;&quot;.r findPrefixOf &quot;A simple example.&quot; // returns None, since the text does not begin with a lowercase letter}}}
   */
  <span class="keyword">def</span> <a title="(source: CharSequence)Option[String]" id="243859">findPrefixOf</a><span class="delimiter">(</span><a title="CharSequence" id="1250107">source</a>: java.lang.<span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[String]">Option</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="1250109">m</a> = <a href="#243852" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#1250107" title="CharSequence">source</a><span class="delimiter">)</span>
    <span title="Option[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1250109" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">lookingAt</span><span class="delimiter">)</span> <a href="../../Option.scala.html#64111" title="(x: String)Some[String]">Some</a><span class="delimiter">(</span><a href="#1250109" title="java.util.regex.Matcher">m</a>.<span title="()String">group</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="../../Option.scala.html#2498" title="None.type">None</a>
  <span class="delimiter">}</span>

  /** Return optionally match of this regexp at the beginning of the
   *  given character sequence, or None if regexp matches no prefix
   *  of the character sequence.
   *
   *  The main difference from this method to `findFirstMatchIn` is that
   *  this method will not return any matches that do not begin at the
   *  start of the text being matched against.
   *
   *  @param source The text to match against.
   *  @return       A [[scala.Option]] of the [[scala.util.matching.Regex.Match]] of the matched string.
   *  @example      {{{&quot;&quot;&quot;\w+&quot;&quot;&quot;.r findPrefixMatchOf &quot;A simple example.&quot; map (_.after) // returns Some(&quot; simple example.&quot;)}}}
   */
  <span class="keyword">def</span> <a title="(source: CharSequence)Option[scala.util.matching.Regex.Match]" id="243860">findPrefixMatchOf</a><span class="delimiter">(</span><a title="CharSequence" id="1250115">source</a>: java.lang.<span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[scala.util.matching.Regex.Match]">Option</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="1250117">m</a> = <a href="#243852" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#1250115" title="CharSequence">source</a><span class="delimiter">)</span>
    <span title="Option[scala.util.matching.Regex.Match]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1250117" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">lookingAt</span><span class="delimiter">)</span> <a href="../../Option.scala.html#64111" title="(x: scala.util.matching.Regex.Match)Some[scala.util.matching.Regex.Match]">Some</a><span class="delimiter">(</span><span title="scala.util.matching.Regex.Match" class="keyword">new</span> <a href="#409546" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">(</span><a href="#1250115" title="CharSequence">source</a>, <a href="#1250117" title="java.util.regex.Matcher">m</a>, <a href="#243874" title="String*">groupNames</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="../../Option.scala.html#2498" title="None.type">None</a>
  <span class="delimiter">}</span>

  /** Replaces all matches by a string.
   *
   *  $replacementString
   *
   *  @param target      The string to match
   *  @param replacement The string that will replace each match
   *  @return            The resulting string
   *  @example           {{{&quot;&quot;&quot;\d+&quot;&quot;&quot;.r replaceAllIn (&quot;July 15&quot;, &quot;&lt;NUMBER&gt;&quot;) // returns &quot;July &lt;NUMBER&gt;&quot;}}}
   */
  <span class="keyword">def</span> <a title="(target: CharSequence, replacement: String)String" id="243861">replaceAllIn</a><span class="delimiter">(</span><a title="CharSequence" id="563787">target</a>: java.lang.<span title="CharSequence">CharSequence</span>, <a title="String" id="563788">replacement</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="1250121">m</a> = <a href="#243852" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#563787" title="CharSequence">target</a><span class="delimiter">)</span>
    <a href="#1250121" title="java.util.regex.Matcher">m</a>.<span title="(x$1: String)String">replaceAll</span><span class="delimiter">(</span><a href="#563788" title="String">replacement</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /**
   * Replaces all matches using a replacer function. The replacer function takes a
   * [[scala.util.matching.Regex.Match]] so that extra information can be obtained
   * from the match. For example:
   *
   * {{{
   * import scala.util.matching.Regex
   * val datePattern = new Regex(&quot;&quot;&quot;(\d\d\d\d)-(\d\d)-(\d\d)&quot;&quot;&quot;, &quot;year&quot;, &quot;month&quot;, &quot;day&quot;)
   * val text = &quot;From 2011-07-15 to 2011-07-17&quot;
   * val repl = datePattern replaceAllIn (text, m =&gt; m.group(&quot;month&quot;)+&quot;/&quot;+m.group(&quot;day&quot;))
   * }}}
   *
   * $replacementString
   *
   * @param target      The string to match.
   * @param replacer    The function which maps a match to another string.
   * @return            The target string after replacements.
   */
  <span class="keyword">def</span> <a title="(target: CharSequence, replacer: scala.util.matching.Regex.Match =&gt; String)String" id="243862">replaceAllIn</a><span class="delimiter">(</span><a title="CharSequence" id="563784">target</a>: java.lang.<span title="CharSequence">CharSequence</span>, <a title="scala.util.matching.Regex.Match =&gt; String" id="563785">replacer</a>: Match =&gt; String<span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="replacementData extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement" id="1250122">it</a> = <span title="scala.util.matching.Regex.MatchIterator" class="keyword">new</span> <a href="#1251295" title="scala.util.matching.Regex.type">Regex</a>.<a href="#409551" title="scala.util.matching.Regex.MatchIterator">MatchIterator</a><span class="delimiter">(</span><a href="#563784" title="CharSequence">target</a>, <a href="#53971" title="scala.util.matching.Regex" class="keyword">this</a>, <a href="#243874" title="String*">groupNames</a><span class="delimiter">)</span>.<a href="#941122" title="=&gt; scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">replacementData</a>
    <a href="#1250122" title="replacementData extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">it</a> <a href="../../collection/Iterator.scala.html#65240" title="(f: scala.util.matching.Regex.Match =&gt; java.util.regex.Matcher)Unit">foreach</a> <span class="delimiter">(</span><a title="scala.util.matching.Regex.Match" id="1250174">md</a> =&gt; <a href="#1250122" title="replacementData extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">it</a> <a href="#1250137" title="(rs: String)java.util.regex.Matcher">replace</a> <a href="../../Function1.scala.html#59555" title="(v1: scala.util.matching.Regex.Match)String">replacer</a><span class="delimiter">(</span><a href="#1250174" title="scala.util.matching.Regex.Match">md</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#1250122" title="replacementData extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">it</a>.<a href="#1250136" title="=&gt; String">replaced</a>
  <span class="delimiter">}</span>

  /**
   * Replaces some of the matches using a replacer function that returns an [[scala.Option]].
   * The replacer function takes a [[scala.util.matching.Regex.Match]] so that extra
   * information can be btained from the match. For example:
   *
   * {{{
   * import scala.util.matching.Regex._
   *
   * val map = Map(&quot;x&quot; -&gt; &quot;a var&quot;, &quot;y&quot; -&gt; &quot;&quot;&quot;some $ and \ signs&quot;&quot;&quot;)
   * val text = &quot;A text with variables %x, %y and %z.&quot;
   * val varPattern = &quot;&quot;&quot;%(\w+)&quot;&quot;&quot;.r
   * val mapper = (m: Match) =&gt; map get (m group 1) map (quoteReplacement(_))
   * val repl = varPattern replaceSomeIn (text, mapper)
   * }}}
   *
   * $replacementString
   *
   * @param target      The string to match.
   * @param replacer    The function which optionally maps a match to another string.
   * @return            The target string after replacements.
   */
  <span class="keyword">def</span> <a title="(target: CharSequence, replacer: scala.util.matching.Regex.Match =&gt; Option[String])String" id="243863">replaceSomeIn</a><span class="delimiter">(</span><a title="CharSequence" id="1250186">target</a>: java.lang.<span title="CharSequence">CharSequence</span>, <a title="scala.util.matching.Regex.Match =&gt; Option[String]" id="1250187">replacer</a>: Match =&gt; Option<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="replacementData extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement" id="1250189">it</a> = <span title="scala.util.matching.Regex.MatchIterator" class="keyword">new</span> <a href="#1251295" title="scala.util.matching.Regex.type">Regex</a>.<a href="#409551" title="scala.util.matching.Regex.MatchIterator">MatchIterator</a><span class="delimiter">(</span><a href="#1250186" title="CharSequence">target</a>, <a href="#53971" title="scala.util.matching.Regex" class="keyword">this</a>, <a href="#243874" title="String*">groupNames</a><span class="delimiter">)</span>.<a href="#941122" title="=&gt; scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">replacementData</a>
    <span class="keyword">for</span> <span class="delimiter">(</span><a title="scala.util.matching.Regex.Match" id="1250198">matchdata</a> &lt;- <a href="../../collection/Iterator.scala.html#65240" title="(f: scala.util.matching.Regex.Match =&gt; Unit)Unit">it</a> ; <a title="String" id="1250204">replacement</a> &lt;- <a href="../../Function1.scala.html#59555" title="(v1: scala.util.matching.Regex.Match)Option[String]">replacer</a><a href="../../Option.scala.html#63839" title="(f: String =&gt; java.util.regex.Matcher)Unit" class="delimiter">(</a><a href="#1250198" title="scala.util.matching.Regex.Match">matchdata</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#1250189" title="replacementData extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">it</a> <a href="#1250137" title="(rs: String)java.util.regex.Matcher">replace</a> <a href="#1250204" title="String">replacement</a>

    <a href="#1250189" title="replacementData extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">it</a>.<a href="#1250136" title="=&gt; String">replaced</a>
  <span class="delimiter">}</span>

  /** Replaces the first match by a string.
   *
   *  $replacementString
   *
   *  @param target      The string to match
   *  @param replacement The string that will replace the match
   *  @return            The resulting string
   */
  <span class="keyword">def</span> <a title="(target: CharSequence, replacement: String)String" id="243864">replaceFirstIn</a><span class="delimiter">(</span><a title="CharSequence" id="1250207">target</a>: java.lang.<span title="CharSequence">CharSequence</span>, <a title="String" id="1250208">replacement</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="1250210">m</a> = <a href="#243852" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#1250207" title="CharSequence">target</a><span class="delimiter">)</span>
    <a href="#1250210" title="java.util.regex.Matcher">m</a>.<span title="(x$1: String)String">replaceFirst</span><span class="delimiter">(</span><a href="#1250208" title="String">replacement</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Splits the provided character sequence around matches of this regexp.
   *
   *  @param toSplit The character sequence to split
   *  @return        The array of strings computed by splitting the
   *                 input around matches of this regexp
   */
  <span class="keyword">def</span> <a title="(toSplit: CharSequence)Array[String]" id="243865">split</a><span class="delimiter">(</span><a title="CharSequence" id="1250211">toSplit</a>: java.lang.<span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../Array.scala.html#292" title="Array[String]">Array</a><span class="delimiter">[</span>String<span class="delimiter">]</span> =
    <a href="#243852" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)Array[String]">split</span><span class="delimiter">(</span><a href="#1250211" title="CharSequence">toSplit</a><span class="delimiter">)</span>

  /** The string defining the regular expression */
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="243866">toString</a> = <a href="#243873" title="String">regex</a>
<span class="delimiter">}</span>

/** This object defines inner classes that describe
 *  regex matches and helper objects. The class hierarchy
 *  is as follows:
 *
 *  {{{
 *            MatchData
 *            /      \
 *   MatchIterator  Match
 *  }}}
 *
 */
<span class="keyword">object</span> <a title="scala.util.matching.Regex.type" id="1251295">Regex</a> <a href="#53973" title="scala.util.matching.Regex.type" class="delimiter">{</a>

  /** This class provides methods to access
   *  the details of a match.
   */
  <span class="keyword">trait</span> <a title="trait MatchData extends Object" id="409545">MatchData</a> <a href="../../Unit.scala.html#2389" title="Unit" class="delimiter">{</a>

    /** The source from where the match originated */
    <span class="keyword">val</span> <a title="=&gt; CharSequence" id="563831">source</a>: java.lang.<span title="CharSequence">CharSequence</span>

    /** The names of the groups, or some empty sequence if one defined */
    <span class="keyword">val</span> <a title="=&gt; Seq[String]" id="563832">groupNames</a>: <a href="../../collection/Seq.scala.html#5620" title="Seq[String]">Seq</a><span class="delimiter">[</span>String<span class="delimiter">]</span>

    /** The number of subgroups in the pattern (not all of these need to match!) */
    <span class="keyword">def</span> <a title="=&gt; Int" id="563833">groupCount</a>: <a href="../../Int.scala.html#508" title="Int">Int</a>

    /** The index of the first matched character, or -1 if nothing was matched */
    <span class="keyword">def</span> <a title="=&gt; Int" id="563834">start</a>: <a href="../../Int.scala.html#508" title="Int">Int</a>

    /** The index of the first matched character in group `i`,
     *  or -1 if nothing was matched for that group */
    <span class="keyword">def</span> <a title="(i: Int)Int" id="563835">start</a><span class="delimiter">(</span><a title="Int" id="1250217">i</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Int.scala.html#508" title="Int">Int</a>

    /** The index of the last matched character, or -1 if nothing was matched */
    <span class="keyword">def</span> <a title="=&gt; Int" id="563836">end</a>: <a href="../../Int.scala.html#508" title="Int">Int</a>

    /** The index following the last matched character in group `i`,
     *  or -1 if nothing was matched for that group */
    <span class="keyword">def</span> <a title="(i: Int)Int" id="563837">end</a><span class="delimiter">(</span><a title="Int" id="1250218">i</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Int.scala.html#508" title="Int">Int</a>

    /** The matched string, or `null` if nothing was matched */
    <span class="keyword">def</span> <a title="=&gt; String" id="563838">matched</a>: <span title="String">String</span> =
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#563834" title="=&gt; Int">start</a> <a href="../../Int.scala.html#57926" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#563831" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><a href="#563834" title="=&gt; Int">start</a>, <a href="#563836" title="=&gt; Int">end</a><span class="delimiter">)</span>.<span title="()String">toString</span>
      <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>

    /** The matched string in group `i`,
     *  or `null` if nothing was matched */
    <span class="keyword">def</span> <a title="(i: Int)String" id="563839">group</a><span class="delimiter">(</span><a title="Int" id="563880">i</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <span title="String">String</span> =
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#563835" title="(i: Int)Int">start</a><span class="delimiter">(</span><a href="#563880" title="Int">i</a><span class="delimiter">)</span> <a href="../../Int.scala.html#57926" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#563831" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><a href="#563835" title="(i: Int)Int">start</a><span class="delimiter">(</span><a href="#563880" title="Int">i</a><span class="delimiter">)</span>, <a href="#563837" title="(i: Int)Int">end</a><span class="delimiter">(</span><a href="#563880" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="()String">toString</span>
      <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>

    /** All matched subgroups, i.e. not including group(0) */
    <span class="keyword">def</span> <a title="=&gt; List[String]" id="563840">subgroups</a>: <a href="../../collection/immutable/List.scala.html#12322" title="List[String]">List</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">(</span><a href="../../LowPriorityImplicits.scala.html#8333" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">1</a> <a href="../../runtime/RichInt.scala.html#57856" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#563833" title="=&gt; Int">groupCount</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#59174" title="=&gt; List[Int]">toList</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Int =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Int],String,List[String]])List[String]">map</a> <a href="#563839" title="(i: Int)String">group</a>

    /** The char sequence before first character of match,
     *  or `null` if nothing was matched */
    <span class="keyword">def</span> <a title="=&gt; CharSequence" id="563841">before</a>: java.lang.<span title="CharSequence">CharSequence</span> =
      <span title="CharSequence" class="keyword">if</span> <span class="delimiter">(</span><a href="#563834" title="=&gt; Int">start</a> <a href="../../Int.scala.html#57926" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#563831" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#563834" title="=&gt; Int">start</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>

    /** The char sequence before first character of match in group `i`,
     *  or `null` if nothing was matched for that group  */
    <span class="keyword">def</span> <a title="(i: Int)CharSequence" id="563842">before</a><span class="delimiter">(</span><a title="Int" id="1250401">i</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: java.lang.<span title="CharSequence">CharSequence</span> =
      <span title="CharSequence" class="keyword">if</span> <span class="delimiter">(</span><a href="#563835" title="(i: Int)Int">start</a><span class="delimiter">(</span><a href="#1250401" title="Int">i</a><span class="delimiter">)</span> <a href="../../Int.scala.html#57926" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#563831" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#563835" title="(i: Int)Int">start</a><span class="delimiter">(</span><a href="#1250401" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>

    /** Returns char sequence after last character of match,
     *  or `null` if nothing was matched */
    <span class="keyword">def</span> <a title="=&gt; CharSequence" id="563843">after</a>: java.lang.<span title="CharSequence">CharSequence</span> =
      <span title="CharSequence" class="keyword">if</span> <span class="delimiter">(</span><a href="#563836" title="=&gt; Int">end</a> <a href="../../Int.scala.html#57926" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#563831" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><a href="#563836" title="=&gt; Int">end</a>, <a href="#563831" title="=&gt; CharSequence">source</a>.<span title="()Int">length</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>

    /** The char sequence after last character of match in group `i`,
     *  or `null` if nothing was matched for that group  */
    <span class="keyword">def</span> <a title="(i: Int)CharSequence" id="563844">after</a><span class="delimiter">(</span><a title="Int" id="1250426">i</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: java.lang.<span title="CharSequence">CharSequence</span> =
      <span title="CharSequence" class="keyword">if</span> <span class="delimiter">(</span><a href="#563837" title="(i: Int)Int">end</a><span class="delimiter">(</span><a href="#1250426" title="Int">i</a><span class="delimiter">)</span> <a href="../../Int.scala.html#57926" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#563831" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><a href="#563837" title="(i: Int)Int">end</a><span class="delimiter">(</span><a href="#1250426" title="Int">i</a><span class="delimiter">)</span>, <a href="#563831" title="=&gt; CharSequence">source</a>.<span title="()Int">length</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>

    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Map[String,Int]" id="563846">nameToIndex</a>: <a href="../../collection/immutable/Map.scala.html#11605" title="Map[String,Int]">Map</a><span class="delimiter">[</span>String, Int<span class="delimiter">]</span> = <a href="../../collection/generic/GenMapFactory.scala.html#61654" title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</a><span title="(elems: (String, Int)*)scala.collection.immutable.Map[String,Int]" class="delimiter">[</span><span title="String">String</span>, <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span> <a href="../../collection/immutable/MapLike.scala.html#112064" title="(xs: scala.collection.GenTraversableOnce[(String, Int)])scala.collection.immutable.Map[String,Int]">++</a> <span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <a href="../../collection/immutable/List.scala.html#63643" title="(x: String)List[String]">::</a> <a href="#563832" title="=&gt; Seq[String]">groupNames</a>.<a href="../../collection/TraversableOnce.scala.html#59174" title="=&gt; List[String]">toList</a><span class="delimiter">)</span>.<a href="../../collection/IterableLike.scala.html#59514" title="(implicit bf: scala.collection.generic.CanBuildFrom[List[String],(String, Int),List[(String, Int)]])List[(String, Int)]">zipWithIndex</a>

    /** Returns the group with given name
     *
     *  @param id The group name
     *  @return   The requested group
     *  @throws   NoSuchElementException if the requested group name is not defined
     */
    <span class="keyword">def</span> <a title="(id: String)String" id="563847">group</a><span class="delimiter">(</span><a title="String" id="563879">id</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <a href="#563845" title="=&gt; Map[String,Int]">nameToIndex</a>.<a href="../../collection/MapLike.scala.html#78410" title="(key: String)Option[Int]">get</a><a href="../../Option.scala.html#64115" title="=&gt; Int" class="delimiter">(</a><a href="#563879" title="String">id</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="../../Option.scala.html#2498" title="String" id="1250588">None</a> =&gt; <a href="#1250589" title="(x: String)String" class="keyword">throw</a> <span title="(x$1: String)java.util.NoSuchElementException" class="keyword">new</span> <a href="../../package.scala.html#56968" title="java.util.NoSuchElementException">NoSuchElementException</a><span class="delimiter">(</span><span title="String(&quot;group name &quot;)" class="string">&quot;group name &quot;</span><span title="(x$1: Any)String">+</span><a href="#563879" title="String">id</a><span title="(x$1: Any)String">+</span><span title="String(&quot; not defined&quot;)" class="string">&quot; not defined&quot;</span><span class="delimiter">)</span>
      <span class="keyword">case</span> Some<a href="#1250585" title="String" id="1250587" class="delimiter">(</a>index<span class="delimiter">)</span> =&gt; <a href="#563839" title="(i: Int)String">group</a><a href="#1250589" title="(x: String)String" class="delimiter">(</a>index<span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** The matched string; equivalent to `matched.toString` */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="563848">toString</a> = <a href="#563838" title="=&gt; String">matched</a>

  <span class="delimiter">}</span>

  /** Provides information about a succesful match.
   */
  <span class="keyword">class</span> <a title="class Match extends Object with scala.util.matching.Regex.MatchData" id="409546">Match</a><a href="#409546" title="scala.util.matching.Regex.Match" class="delimiter">(</a><span class="keyword">val</span> <a title="CharSequence" id="1250084">source</a>: java.lang.<span title="CharSequence">CharSequence</span>,
              <a title="java.util.regex.Matcher" id="1250085">matcher</a>: <span title="java.util.regex.Matcher">Matcher</span>,
              <span class="keyword">val</span> <a title="Seq[String]" id="1250086">groupNames</a>: <a href="../../collection/Seq.scala.html#5620" title="Seq[String]">Seq</a><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#409545" title="scala.util.matching.Regex.MatchData">MatchData</a> <span class="delimiter">{</span>

    /** The index of the first matched character */
    <span class="keyword">val</span> <a title="Int" id="563858">start</a> = <a href="#1250085" title="java.util.regex.Matcher">matcher</a>.<span title="()Int">start</span>

    /** The index following the last matched character */
    <span class="keyword">val</span> <a title="Int" id="563860">end</a> = <a href="#1250085" title="java.util.regex.Matcher">matcher</a>.<span title="()Int">end</span>

    /** The number of subgroups */
    <span class="keyword">def</span> <a title="=&gt; Int" id="563862">groupCount</a> = <a href="#1250085" title="java.util.regex.Matcher">matcher</a>.<span title="()Int">groupCount</span>

    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Array[Int]" id="563864">starts</a>: <a href="../../Array.scala.html#292" title="Array[Int]">Array</a><span class="delimiter">[</span>Int<span class="delimiter">]</span> =
      <span class="delimiter">(</span><span class="delimiter">(</span><a href="../../LowPriorityImplicits.scala.html#8333" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">0</a> <a href="../../runtime/RichInt.scala.html#57856" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#563862" title="=&gt; Int">groupCount</a><span class="delimiter">)</span> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Int =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[Int],Int,scala.collection.immutable.IndexedSeq[Int]])scala.collection.immutable.IndexedSeq[Int]">map</a> <a href="#1250085" title="java.util.regex.Matcher">matcher</a>.<a href="#1250732" title="(x$1: Int)Int">start</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#59170" title="(implicit evidence$1: ArrayTag[Int])Array[Int]">toArray</a>
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Array[Int]" id="563866">ends</a>: <a href="../../Array.scala.html#292" title="Array[Int]">Array</a><span class="delimiter">[</span>Int<span class="delimiter">]</span> =
      <span class="delimiter">(</span><span class="delimiter">(</span><a href="../../LowPriorityImplicits.scala.html#8333" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">0</a> <a href="../../runtime/RichInt.scala.html#57856" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#563862" title="=&gt; Int">groupCount</a><span class="delimiter">)</span> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Int =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[Int],Int,scala.collection.immutable.IndexedSeq[Int]])scala.collection.immutable.IndexedSeq[Int]">map</a> <a href="#1250085" title="java.util.regex.Matcher">matcher</a>.<a href="#1250878" title="(x$1: Int)Int">end</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#59170" title="(implicit evidence$1: ArrayTag[Int])Array[Int]">toArray</a>

    /** The index of the first matched character in group `i` */
    <span class="keyword">def</span> <a title="(i: Int)Int" id="563867">start</a><span class="delimiter">(</span><a title="Int" id="1250923">i</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span> = <a href="../../Array.scala.html#57450" title="(i: Int)Int">starts</a><span class="delimiter">(</span><a href="#1250923" title="Int">i</a><span class="delimiter">)</span>

    /** The index following the last matched character in group `i` */
    <span class="keyword">def</span> <a title="(i: Int)Int" id="563868">end</a><span class="delimiter">(</span><a title="Int" id="1250928">i</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span> = <a href="../../Array.scala.html#57450" title="(i: Int)Int">ends</a><span class="delimiter">(</span><a href="#1250928" title="Int">i</a><span class="delimiter">)</span>

    /** The match itself with matcher-dependent lazy vals forced,
     *  so that match is valid even once matcher is advanced
     */
    <span class="keyword">def</span> <a title="=&gt; Match.this.type" id="563869">force</a>: <span class="keyword">this</span>.<span class="keyword">type</span> = <span class="delimiter">{</span> <a href="#563863" title="=&gt; Array[Int]">starts</a>; <a href="#563865" title="=&gt; Array[Int]">ends</a>; <a href="#409546" title="Match.this.type" class="keyword">this</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** An extractor object for Matches, yielding the matched string
   *
   *  This can be used to help writing replacer functions when you
   *  are not interested in match data. For example:
   *
   *  {{{
   *  import scala.util.matching.Regex.Match
   *  &quot;&quot;&quot;\w+&quot;&quot;&quot;.r replaceAllIn (&quot;A simple example.&quot;, _ match { case Match(s) =&gt; s.toUpperCase })
   *  }}}
   *
   */
  <span class="keyword">object</span> <a title="scala.util.matching.Regex.Match.type" id="409547">Match</a> <a href="#409548" title="scala.util.matching.Regex.Match.type" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(m: scala.util.matching.Regex.Match)Some[String]" id="1249882">unapply</a><span class="delimiter">(</span><a title="scala.util.matching.Regex.Match" id="1249883">m</a>: <a href="#409546" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#910" title="Some[String]">Some</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="../../Option.scala.html#64111" title="(x: String)Some[String]">Some</a><span class="delimiter">(</span><a href="#1249883" title="scala.util.matching.Regex.Match">m</a>.<a href="#563838" title="=&gt; String">matched</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** An extractor object that yields the groups in the match. Using an extractor
   *  rather than the original regex avoids recomputing the match.
   *
   *  {{{
   *  import scala.util.matching.Regex.Groups
   *
   *  val datePattern = &quot;&quot;&quot;(\d\d\d\d)-(\d\d)-(\d\d)&quot;&quot;&quot;.r
   *  val text = &quot;The doc spree happened on 2011-07-15.&quot;
   *  val day = datePattern replaceAllIn(text, _ match { case Groups(year, month, day) =&gt; month+&quot;/&quot;+day })
   *  }}}
   */
  <span class="keyword">object</span> <a title="scala.util.matching.Regex.Groups.type" id="409549">Groups</a> <a href="#409550" title="scala.util.matching.Regex.Groups.type" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(m: scala.util.matching.Regex.Match)Option[Seq[String]]" id="1100801">unapplySeq</a><span class="delimiter">(</span><a title="scala.util.matching.Regex.Match" id="1100802">m</a>: <a href="#409546" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#1510" title="Option[Seq[String]]">Option</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="Option[Seq[String]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1100802" title="scala.util.matching.Regex.Match">m</a>.<a href="#563862" title="=&gt; Int">groupCount</a> <a href="../../Int.scala.html#57919" title="(x: Int)Boolean">&gt;</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="../../Option.scala.html#64111" title="(x: Seq[String])Some[Seq[String]]">Some</a><span class="delimiter">(</span><a href="../../LowPriorityImplicits.scala.html#8333" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">1</a> <a href="../../runtime/RichInt.scala.html#57856" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#1100802" title="scala.util.matching.Regex.Match">m</a>.<a href="#563862" title="=&gt; Int">groupCount</a> <a href="../../collection/TraversableLike.scala.html#58971" title="(f: Int =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[Int],String,Seq[String]])Seq[String]">map</a> <a href="#1100802" title="scala.util.matching.Regex.Match">m</a>.<a href="#563839" title="(i: Int)String">group</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="../../Option.scala.html#2498" title="None.type">None</a>
  <span class="delimiter">}</span>

  /** A class to step through a sequence of regex matches
   */
  <span class="keyword">class</span> <a title="class MatchIterator extends scala.collection.AbstractIterator[String] with Iterator[String] with scala.util.matching.Regex.MatchData" id="409551">MatchIterator</a><a href="#409551" title="scala.util.matching.Regex.MatchIterator" class="delimiter">(</a><span class="keyword">val</span> <a title="CharSequence" id="941123">source</a>: java.lang.<span title="CharSequence">CharSequence</span>, <span class="keyword">val</span> <a title="scala.util.matching.Regex" id="941124">regex</a>: <a href="#53971" title="scala.util.matching.Regex">Regex</a>, <span class="keyword">val</span> <a title="Seq[String]" id="941125">groupNames</a>: <a href="../../collection/Seq.scala.html#5620" title="Seq[String]">Seq</a><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="../../collection/Iterator.scala.html#4801" title="scala.collection.AbstractIterator[String]">AbstractIterator</a><span class="delimiter">[</span>String<span class="delimiter">]</span> <span class="keyword">with</span> <a href="../../collection/Iterator.scala.html#5383" title="Iterator[String]">Iterator</a><span class="delimiter">[</span>String<span class="delimiter">]</span> <span class="keyword">with</span> <a href="#409545" title="scala.util.matching.Regex.MatchData">MatchData</a> <span class="delimiter">{</span> self =&gt;

    <span class="keyword">protected</span><span class="delimiter">[</span>Regex<span class="delimiter">]</span> <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="941108">matcher</a> = <a href="#941124" title="=&gt; scala.util.matching.Regex">regex</a>.<a href="#243852" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#941123" title="=&gt; CharSequence">source</a><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Boolean" id="941111">nextSeen</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is there another match? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="941113">hasNext</a>: <a href="../../Boolean.scala.html#2218" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#941111" title="=&gt; Boolean">nextSeen</a><span class="delimiter">)</span> <a href="#941111" title="(x$1: Boolean)Unit">nextSeen</a> = <a href="#941108" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()Boolean">find</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#941111" title="=&gt; Boolean">nextSeen</a>
    <span class="delimiter">}</span>

    /** The next matched substring of `source` */
    <span class="keyword">def</span> <a title="()String" id="941114">next</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../Boolean.scala.html#58721" title="=&gt; Boolean">!</a><a href="#941113" title="=&gt; Boolean">hasNext</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <span title="java.util.NoSuchElementException" class="keyword">new</span> <a href="../../package.scala.html#56968" title="java.util.NoSuchElementException">NoSuchElementException</a>
      <a href="#941111" title="(x$1: Boolean)Unit">nextSeen</a> = <span title="Boolean(false)" class="keyword">false</span>
      <a href="#941108" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()String">group</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="941115">toString</a> = <a href="#409551" title="scala.util.matching.Regex.MatchIterator" class="keyword">super</a><span class="delimiter">[</span>AbstractIterator<span class="delimiter">]</span>.<a href="../../collection/Iterator.scala.html#65272" title="()String">toString</a>

    /** The index of the first matched character */
    <span class="keyword">def</span> <a title="=&gt; Int" id="941116">start</a>: <a href="../../Int.scala.html#508" title="Int">Int</a> = <a href="#941108" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()Int">start</span>

    /** The index of the first matched character in group `i` */
    <span class="keyword">def</span> <a title="(i: Int)Int" id="941117">start</a><span class="delimiter">(</span><a title="Int" id="1251101">i</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Int.scala.html#508" title="Int">Int</a> = <a href="#941108" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="(x$1: Int)Int">start</span><span class="delimiter">(</span><a href="#1251101" title="Int">i</a><span class="delimiter">)</span>

    /** The index of the last matched character */
    <span class="keyword">def</span> <a title="=&gt; Int" id="941118">end</a>: <a href="../../Int.scala.html#508" title="Int">Int</a> = <a href="#941108" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()Int">end</span>

    /** The index following the last matched character in group `i` */
    <span class="keyword">def</span> <a title="(i: Int)Int" id="941119">end</a><span class="delimiter">(</span><a title="Int" id="1251112">i</a>: <a href="../../Int.scala.html#508" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Int.scala.html#508" title="Int">Int</a> = <a href="#941108" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="(x$1: Int)Int">end</span><span class="delimiter">(</span><a href="#1251112" title="Int">i</a><span class="delimiter">)</span>

    /** The number of subgroups */
    <span class="keyword">def</span> <a title="=&gt; Int" id="941120">groupCount</a> = <a href="#941108" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()Int">groupCount</span>

    /** Convert to an iterator that yields MatchData elements instead of Strings */
    <span class="keyword">def</span> <a title="=&gt; Iterator[scala.util.matching.Regex.Match]" id="941121">matchData</a>: <a href="../../collection/Iterator.scala.html#5383" title="Iterator[scala.util.matching.Regex.Match]">Iterator</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> = <a href="#1251120" title="scala.collection.AbstractIterator[scala.util.matching.Regex.Match]" class="keyword">new</a> <a title="anonymous class $anon extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match]" id="1251120">AbstractIterator</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1251122">hasNext</a> = <a href="#409551" title="MatchIterator.this.type">self</a>.<a href="#941113" title="=&gt; Boolean">hasNext</a>
      <span class="keyword">def</span> <a title="()scala.util.matching.Regex.Match" id="1251123">next</a> = <span class="delimiter">{</span> <a href="#409551" title="MatchIterator.this.type">self</a>.<a href="#941114" title="()String">next</a>; <span title="scala.util.matching.Regex.Match" class="keyword">new</span> <a href="#409546" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">(</span><a href="#941123" title="=&gt; CharSequence">source</a>, <a href="#941108" title="=&gt; java.util.regex.Matcher">matcher</a>, <a href="#941125" title="=&gt; Seq[String]">groupNames</a><span class="delimiter">)</span>.<a href="#563869" title="=&gt; scala.util.matching.Regex.Match">force</a> <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** Convert to an iterator that yields MatchData elements instead of Strings and has replacement support */
    <span class="keyword">private</span><span class="delimiter">[</span>matching<span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement" id="941122">replacementData</a> = <a href="#1250126" title="scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement" class="keyword">new</a> <a title="anonymous class $anon extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement" id="1250126">AbstractIterator</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> <span class="keyword">with</span> <a href="#409552" title="scala.util.matching.Regex.Replacement">Replacement</a> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="=&gt; java.util.regex.Matcher" id="1250128">matcher</a> = <a href="#409551" title="MatchIterator.this.type">self</a>.<a href="#941108" title="=&gt; java.util.regex.Matcher">matcher</a>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1250129">hasNext</a> = <a href="#409551" title="MatchIterator.this.type">self</a>.<a href="#941113" title="=&gt; Boolean">hasNext</a>
      <span class="keyword">def</span> <a title="()scala.util.matching.Regex.Match" id="1250130">next</a> = <span class="delimiter">{</span> <a href="#409551" title="MatchIterator.this.type">self</a>.<a href="#941114" title="()String">next</a>; <span title="scala.util.matching.Regex.Match" class="keyword">new</span> <a href="#409546" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">(</span><a href="#941123" title="=&gt; CharSequence">source</a>, <a href="#1250128" title="=&gt; java.util.regex.Matcher">matcher</a>, <a href="#941125" title="=&gt; Seq[String]">groupNames</a><span class="delimiter">)</span>.<a href="#563869" title="=&gt; scala.util.matching.Regex.Match">force</a> <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /**
   * A trait able to build a string with replacements assuming it has a matcher.
   * Meant to be mixed in with iterators.
   */
  <span class="keyword">private</span><span class="delimiter">[</span>matching<span class="delimiter">]</span> <span class="keyword">trait</span> <a title="trait Replacement extends Object" id="409552">Replacement</a> <a href="../../Unit.scala.html#2389" title="Unit" class="delimiter">{</a>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; java.util.regex.Matcher" id="1250132">matcher</a>: <span title="java.util.regex.Matcher">Matcher</span>

    <span class="keyword">private</span> <span class="keyword">var</span> <a title="StringBuffer" id="1250134">sb</a> = <span title="StringBuffer" class="keyword">new</span> java.lang.<span title="StringBuffer">StringBuffer</span>

    <span class="keyword">def</span> <a title="=&gt; String" id="1250136">replaced</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="StringBuffer" id="1250181">newsb</a> = <span title="(x$1: CharSequence)StringBuffer" class="keyword">new</span> java.lang.<span title="StringBuffer">StringBuffer</span><span class="delimiter">(</span><a href="#1250134" title="=&gt; StringBuffer">sb</a><span class="delimiter">)</span>
      <a href="#1250132" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="(x$1: StringBuffer)StringBuffer">appendTail</span><span class="delimiter">(</span><a href="#1250181" title="StringBuffer">newsb</a><span class="delimiter">)</span>
      <a href="#1250181" title="StringBuffer">newsb</a>.<span title="()String">toString</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(rs: String)java.util.regex.Matcher" id="1250137">replace</a><span class="delimiter">(</span><a title="String" id="1250175">rs</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#1250132" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="(x$1: StringBuffer, x$2: String)java.util.regex.Matcher">appendReplacement</span><span class="delimiter">(</span><a href="#1250134" title="=&gt; StringBuffer">sb</a>, <a href="#1250175" title="String">rs</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Quotes replacement strings to be used in replacement methods.
   *
   *  Replacement methods give special meaning to backslashes (`\`) and
   *  dollar signs (`$`) in replacement strings, so they are not treated
   *  as literals. This method escapes these characters so the resulting
   *  string can be used as a literal replacement representing the input
   *  string.
   *
   *  @param text The string one wishes to use as literal replacement.
   *  @return A string that can be used to replace matches with `text`.
   *  @example {{{&quot;CURRENCY&quot;.r.replaceAllIn(input, Regex quoteReplacement &quot;US$&quot;)}}}
   */
  <span class="keyword">def</span> <a title="(text: String)String" id="409553">quoteReplacement</a><span class="delimiter">(</span><a title="String" id="1251294">text</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <span title="java.util.regex.Matcher.type">Matcher</span> <span title="(x$1: String)String">quoteReplacement</span> <a href="#1251294" title="String">text</a>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>