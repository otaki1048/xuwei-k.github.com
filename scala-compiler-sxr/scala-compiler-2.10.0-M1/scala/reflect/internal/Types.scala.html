<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/reflect/internal/Types.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
/* NSC -- new Scala compiler
 * Copyright 2005-2011 LAMP/EPFL
 * @author  Martin Odersky
 */

<span class="keyword">package</span> scala.reflect
<span class="keyword">package</span> internal

<span class="keyword">import</span> scala.collection.<span class="delimiter">{</span> mutable, immutable <span class="delimiter">}</span>
<span class="keyword">import</span> scala.ref.WeakReference
<span class="keyword">import</span> mutable.ListBuffer
<span class="keyword">import</span> <a href="Flags.scala.html#8666" title="object scala.reflect.internal.Flags">Flags</a>._
<span class="keyword">import</span> scala.util.control.ControlThrowable
<span class="keyword">import</span> scala.annotation.tailrec
<span class="keyword">import</span> util.<a href="util/Statistics.scala.html#10702" title="object scala.reflect.internal.util.Statistics">Statistics</a>._

/* A standard type pattern match:
  case ErrorType =&gt;
    // internal: error
  case WildcardType =&gt;
    // internal: unknown
  case NoType =&gt;
  case NoPrefix =&gt;
  case ThisType(sym) =&gt;
    // sym.this.type
  case SuperType(thistpe, supertpe) =&gt;
    // super references
  case SingleType(pre, sym) =&gt;
    // pre.sym.type
  case ConstantType(value) =&gt;
    // Int(2)
  case TypeRef(pre, sym, args) =&gt;
    // pre.sym[targs]
    // Outer.this.C would be represented as TypeRef(ThisType(Outer), C, List())
  case RefinedType(parents, defs) =&gt;
    // parent1 with ... with parentn { defs }
  case ExistentialType(tparams, result) =&gt;
    // result forSome { tparams }
  case AnnotatedType(annots, tp, selfsym) =&gt;
    // tp @annots

  // the following are non-value types; you cannot write them down in Scala source.

  case TypeBounds(lo, hi) =&gt;
    // &gt;: lo &lt;: hi
  case ClassInfoType(parents, defs, clazz) =&gt;
    // same as RefinedType except as body of class
  case MethodType(paramtypes, result) =&gt;
    // (paramtypes)result
    // For instance def m(): T is represented as MethodType(List(), T)
  case NullaryMethodType(result) =&gt; // eliminated by uncurry
    // an eval-by-name type
    // For instance def m: T is represented as NullaryMethodType(T)
  case PolyType(tparams, result) =&gt;
    // [tparams]result where result is a (Nullary)MethodType or ClassInfoType

  // The remaining types are not used after phase `typer`.
  case OverloadedType(pre, tparams, alts) =&gt;
    // all alternatives of an overloaded ident
  case AntiPolyType(pre, targs) =&gt;
    // rarely used, disappears when combined with a PolyType
  case TypeVar(inst, constr) =&gt;
    // a type variable
    // Replace occurrences of type parameters with type vars, where
    // inst is the instantiation and constr is a list of bounds.
  case DeBruijnIndex(level, index)
    // for dependent method types: a type referring to a method parameter.
*/

<span class="keyword">trait</span> <a title="trait Types extends Object with scala.reflect.api.Types with ScalaObject" id="8614">Types</a> <span title="ScalaObject" class="keyword">extends</span> api.<span title="scala.reflect.api.Types">Types</span> <span class="delimiter">{</span> self: SymbolTable =&gt;
  <span class="keyword">import</span> <a href="Definitions.scala.html#40473" title="object Types.this.definitions">definitions</a>._

  //statistics
  <span class="keyword">def</span> <a title="=&gt; Int" id="40042">uniqueTypeCount</a> = <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#40224" title="=&gt; scala.reflect.internal.util.HashSet[Types.this.Type]">uniques</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> <span class="keyword">else</span> <a href="#40224" title="=&gt; scala.reflect.internal.util.HashSet[Types.this.Type]">uniques</a>.<a href="util/HashSet.scala.html#128854" title="=&gt; Int">size</a>

  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Boolean" id="40044">explainSwitch</a> = <span title="Boolean(false)" class="keyword">false</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="40046">emptySymbolSet</a> = immutable.<span title="object scala.collection.immutable.Set">Set</span>.<span title="[A]=&gt; scala.collection.immutable.Set[A]">empty</span><span title="scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span>

  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="40048">LogPendingSubTypesThreshold</a> = <span title="Int(50)" class="int">50</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="40050">LogPendingBaseTypesThreshold</a> = <span title="Int(50)" class="int">50</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="40052">LogVolatileThreshold</a> = <span title="Int(50)" class="int">50</span>

  /** A don't care value for the depth parameter in lubs/glbs and related operations. */
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(-3)" id="40054">AnyDepth</a> = -<span title="Int(-3)" class="int">3</span>

  /** Decrement depth unless it is a don't care. */
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="(depth: Int)Int" id="40056">decr</a><span class="delimiter">(</span><a title="Int" id="128899">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#128899" title="Int">depth</a> <span title="(x: Int)Boolean">==</span> <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span> <span title="Int(-3)">AnyDepth</span> <span class="keyword">else</span> <a href="#128899" title="Int">depth</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>

  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean" id="40057">printLubs</a> = sys.<span title="=&gt; scala.sys.SystemProperties">props</span> <span title="(key: String)Boolean">contains</span> <span title="String(&quot;scalac.debug.lub&quot;)" class="string">&quot;scalac.debug.lub&quot;</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean" id="40059">traceTypeVars</a> = sys.<span title="=&gt; scala.sys.SystemProperties">props</span> <span title="(key: String)Boolean">contains</span> <span title="String(&quot;scalac.debug.tvar&quot;)" class="string">&quot;scalac.debug.tvar&quot;</span>
  /** In case anyone wants to turn off lub verification without reverting anything. */
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean(true)" id="40061">verifyLubs</a> = <span title="Boolean(true)" class="keyword">true</span>
  /** In case anyone wants to turn off type parameter bounds being used
   *  to seed type constraints.
   */
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean" id="40063">propagateParameterBoundsToTypeVars</a> = sys.<span title="=&gt; scala.sys.SystemProperties">props</span> <span title="(key: String)Boolean">contains</span> <span title="String(&quot;scalac.debug.prop-constraints&quot;)" class="string">&quot;scalac.debug.prop-constraints&quot;</span>

  <span class="keyword">protected</span> <span class="keyword">val</span> <a title="Boolean" id="40065">enableTypeVarExperimentals</a> = <a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75546" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">Xexperimental</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a>

  /** Empty immutable maps to avoid allocations. */
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]" id="40067">emptySymMap</a>   = immutable.<span title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</span><span title="(elems: (Types.this.Symbol, Types.this.Symbol)*)scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Int]" id="40069">emptySymCount</a> = immutable.<span title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</span><span title="(elems: (Types.this.Symbol, Int)*)scala.collection.immutable.Map[Types.this.Symbol,Int]" class="delimiter">[</span><a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <span title="Int">Int</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>

  /** The current skolemization level, needed for the algorithms
   *  in isSameType, isSubType that do constraint solving under a prefix.
   */
  <span class="keyword">var</span> <a title="Int" id="40072">skolemizationLevel</a> = <span title="Int(0)" class="int">0</span>

  /** A log of type variable with their original constraints. Used in order
   *  to undo constraints in the case of isSubType/isSameType failure.
   */
  <span class="keyword">object</span> <a title="object Types.this.undoLog" id="40074">undoLog</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">type</span> <a title="List[(Types.this.TypeVar, Types.this.TypeConstraint)]" id="128911">UndoLog</a> = <span title="List[(Types.this.TypeVar, Types.this.TypeConstraint)]">List</span><span class="delimiter">[</span><span class="delimiter">(</span>TypeVar, TypeConstraint<span class="delimiter">)</span><span class="delimiter">]</span>
    <span class="keyword">private</span><span class="delimiter">[</span>scala<span class="delimiter">]</span> <span class="keyword">var</span> <a title="scala.reflect.internal.Types.undoLog.UndoLog" id="128913">log</a>: <span title="scala.reflect.internal.Types.undoLog.UndoLog">UndoLog</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    // register with the auto-clearing cache manager
    <a href="SymbolTable.scala.html#36987" title="object Types.this.perRunCaches">perRunCaches</a>.<a href="SymbolTable.scala.html#110468" title="(cache: Types.this.undoLog.type)Types.this.undoLog.type">recordCache</a><span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>

    /** Undo all changes to constraints to type variables upto `limit`. */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(limit: scala.reflect.internal.Types.undoLog.UndoLog)Unit" id="128915">undoTo</a><span class="delimiter">(</span><a title="scala.reflect.internal.Types.undoLog.UndoLog" id="128942">limit</a>: <span title="scala.reflect.internal.Types.undoLog.UndoLog">UndoLog</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#128913" title="=&gt; scala.reflect.internal.Types.undoLog.UndoLog">log</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#128942" title="scala.reflect.internal.Types.undoLog.UndoLog">limit</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#128913" title="=&gt; scala.reflect.internal.Types.undoLog.UndoLog">log</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#128944" title="()Unit" class="delimiter">{</a>
        <span class="keyword">val</span> <a href="#128947" title="(Types.this.TypeVar, Types.this.TypeConstraint)" class="delimiter">(</a><a href="#128946" title="Types.this.TypeVar" id="128947">tv</a>, <a href="#128946" title="Types.this.TypeConstraint" id="128948">constr</a><span class="delimiter">)</span> = <a href="#128913" title="=&gt; scala.reflect.internal.Types.undoLog.UndoLog">log</a>.<span title="=&gt; (Types.this.TypeVar, Types.this.TypeConstraint)">head</span>
        <a href="#128947" title="Types.this.TypeVar">tv</a>.<a href="#84202" title="(x$1: Types.this.TypeConstraint)Unit">constr</a> = <a href="#128948" title="Types.this.TypeConstraint">constr</a>
        <a href="#128913" title="(x$1: scala.reflect.internal.Types.undoLog.UndoLog)Unit">log</a> = <a href="#128913" title="=&gt; scala.reflect.internal.Types.undoLog.UndoLog">log</a>.<span title="=&gt; List[(Types.this.TypeVar, Types.this.TypeConstraint)]">tail</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">private</span><span class="delimiter">[</span>Types<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(tv: Types.this.TypeVar)Unit" id="128916">record</a><span class="delimiter">(</span><a title="Types.this.TypeVar" id="128966">tv</a>: <a href="#40176" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#128913" title="(x$1: scala.reflect.internal.Types.undoLog.UndoLog)Unit">log</a> <span title="(x: (Types.this.TypeVar, Types.this.TypeConstraint))List[(Types.this.TypeVar, Types.this.TypeConstraint)]">::=</span> <span class="delimiter">(</span><span title="(_1: Types.this.TypeVar, _2: Types.this.TypeConstraint)(Types.this.TypeVar, Types.this.TypeConstraint)" class="delimiter">(</span><a href="#128966" title="Types.this.TypeVar">tv</a>, <a href="#128966" title="Types.this.TypeVar">tv</a>.<a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84305" title="=&gt; Types.this.TypeConstraint">cloneInternal</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">private</span><span class="delimiter">[</span>scala<span class="delimiter">]</span> <span class="keyword">def</span> <a title="()Unit" id="128917">clear</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75538" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a><span class="delimiter">)</span>
        <a href="#8614" title="Types.this.type">self</a>.<a href="SymbolTable.scala.html#36938" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="String(&quot;Clearing &quot;)" class="string">&quot;Clearing &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#128913" title="=&gt; scala.reflect.internal.Types.undoLog.UndoLog">log</a>.<span title="=&gt; Int">size</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; entries from the undoLog.&quot;)" class="string">&quot; entries from the undoLog.&quot;</span><span class="delimiter">)</span>

      <a href="#128913" title="(x$1: scala.reflect.internal.Types.undoLog.UndoLog)Unit">log</a> = <span title="object Nil">Nil</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="=&gt; Int" id="128918">size</a> = <a href="#128913" title="=&gt; scala.reflect.internal.Types.undoLog.UndoLog">log</a>.<span title="=&gt; Int">size</span>

    // `block` should not affect constraints on typevars
    <span class="keyword">def</span> <a title="[T](block: =&gt; T)T" id="128919">undo</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="128921">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; T" id="129029">block</a>: =&gt; T<span class="delimiter">)</span>: <a href="#128921" title="T">T</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.reflect.internal.Types.undoLog.UndoLog" id="129032">before</a> = <a href="#128913" title="=&gt; scala.reflect.internal.Types.undoLog.UndoLog">log</a>

      <span class="keyword">try</span> <a href="#129029" title="=&gt; T">block</a>
      <span class="keyword">finally</span> <a href="#128915" title="(limit: scala.reflect.internal.Types.undoLog.UndoLog)Unit">undoTo</a><span class="delimiter">(</span><a href="#129032" title="scala.reflect.internal.Types.undoLog.UndoLog">before</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    // if `block` evaluates to false, it should not affect constraints on typevars
    <span class="keyword">def</span> <a title="(block: =&gt; Boolean)Boolean" id="128922">undoUnless</a><span class="delimiter">(</span><a title="=&gt; Boolean" id="129033">block</a>: =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.reflect.internal.Types.undoLog.UndoLog" id="129035">before</a> = <a href="#128913" title="=&gt; scala.reflect.internal.Types.undoLog.UndoLog">log</a>
      <span class="keyword">var</span> <a title="Boolean" id="129036">result</a> = <span title="Boolean(false)" class="keyword">false</span>

      <span class="keyword">try</span> <a href="#129036" title="Boolean">result</a> = <a href="#129033" title="=&gt; Boolean">block</a>
      <span class="keyword">finally</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#129036" title="Boolean">result</a><span class="delimiter">)</span> <a href="#128915" title="(limit: scala.reflect.internal.Types.undoLog.UndoLog)Unit">undoTo</a><span class="delimiter">(</span><a href="#129035" title="scala.reflect.internal.Types.undoLog.UndoLog">before</a><span class="delimiter">)</span>

      <a href="#129036" title="Boolean">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map from lists to compound types that have the given list as parents.
   *  This is used to avoid duplication in the computation of base type sequences and baseClasses.
   *  It makes use of the fact that these two operations depend only on the parents,
   *  not on the refinement.
   */
  <span class="keyword">val</span> <a title="scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]" id="40076">intersectionWitness</a> = <a href="SymbolTable.scala.html#36987" title="object Types.this.perRunCaches">perRunCaches</a>.<a href="SymbolTable.scala.html#110472" title="[K, V]()scala.collection.mutable.WeakHashMap[K,V]">newWeakMap</a><span title="()scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]" class="delimiter">[</span><span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <span title="scala.ref.WeakReference[Types.this.Type]">WeakReference</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>

  /** A proxy for a type (identified by field `underlying`) that forwards most
   *  operations to it (for exceptions, see WrappingProxy, which forwards even more operations).
   *  every operation that is overridden for some kind of types should be forwarded.
   */
  <span class="keyword">trait</span> <a title="trait SimpleTypeProxy extends Types.this.Type with ScalaObject" id="40078">SimpleTypeProxy</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="59506">underlying</a>: <a href="#40083" title="Types.this.Type">Type</a>

    // the following operations + those in RewrappingTypeProxy are all operations
    // in class Type that are overridden in some subclass
    // Important to keep this up-to-date when new operations are added!
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="59507">isTrivial</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42713" title="=&gt; Boolean">isTrivial</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="59508">isHigherKinded</a>: <span title="Boolean">Boolean</span> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42714" title="=&gt; Boolean">isHigherKinded</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="59509">typeConstructor</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42740" title="=&gt; Types.this.Type">typeConstructor</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="59510">isNotNull</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42717" title="=&gt; Boolean">isNotNull</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="59511">isError</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42722" title="=&gt; Boolean">isError</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="59512">isErroneous</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42723" title="=&gt; Boolean">isErroneous</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="59513">isStable</a>: <span title="Boolean">Boolean</span> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42715" title="=&gt; Boolean">isStable</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="59514">isVolatile</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42716" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="59515">finalResultType</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42747" title="=&gt; Types.this.Type">finalResultType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="59516">paramSectionCount</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42748" title="=&gt; Int">paramSectionCount</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="59517">paramss</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42749" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="59518">params</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42750" title="=&gt; List[Types.this.Symbol]">params</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="59519">paramTypes</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42751" title="=&gt; List[Types.this.Type]">paramTypes</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="59520">termSymbol</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42727" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="59521">termSymbolDirect</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42729" title="=&gt; Types.this.Symbol">termSymbolDirect</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="59522">typeParams</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42752" title="=&gt; List[Types.this.Symbol]">typeParams</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="59523">boundSyms</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42753" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="59524">typeSymbol</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="59525">typeSymbolDirect</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42730" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="59526">widen</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42732" title="=&gt; Types.this.Type">widen</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="59527">typeOfThis</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42734" title="=&gt; Types.this.Type">typeOfThis</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="59528">bounds</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="59529">parents</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42737" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="59530">prefix</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42738" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="59531">decls</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42760" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="59532">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="129125">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42777" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#129125" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="59533">baseTypeSeq</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42803" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="59534">baseTypeSeqDepth</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42804" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="59535">baseClasses</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42805" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
  <span class="delimiter">}</span>

  /** A proxy for a type (identified by field `underlying`) that forwards most
   *  operations to it. Every operation that is overridden for some kind of types is
   *  forwarded here. Some operations are rewrapped again.
   */
  <span class="keyword">trait</span> <a title="trait RewrappingTypeProxy extends Types.this.Type with Types.this.SimpleTypeProxy with ScalaObject" id="40079">RewrappingTypeProxy</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40078" title="Types.this.SimpleTypeProxy">SimpleTypeProxy</a> <span class="delimiter">{</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="59537">maybeRewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="129144">newtp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#129144" title="Types.this.Type">newtp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#42731" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span> <a href="#40079" title="Types.this.RewrappingTypeProxy" class="keyword">this</a> <span class="keyword">else</span> <a href="#59538" title="(newtp: Types.this.Type)Types.this.Type">rewrap</a><span class="delimiter">(</span><a href="#129144" title="Types.this.Type">newtp</a><span class="delimiter">)</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="59538">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="129147">newtp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a>

    // the following are all operations in class Type that are overridden in some subclass
    // Important to keep this up-to-date when new operations are added!
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="59539">widen</a> = <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42732" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="59540">narrow</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42735" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="59541">deconst</a> = <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42733" title="=&gt; Types.this.Type">deconst</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="59542">resultType</a> = <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42743" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(actuals: List[Types.this.Type])Types.this.Type" id="59543">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="129168">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42744" title="(actuals: List[Types.this.Type])Types.this.Type">resultType</a><span class="delimiter">(</span><a href="#129168" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="59544">finalResultType</a> = <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42747" title="=&gt; Types.this.Type">finalResultType</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="59545">paramSectionCount</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="59546">paramss</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="59547">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="59548">paramTypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="59549">typeArgs</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42741" title="=&gt; List[Types.this.Type]">typeArgs</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="59550">notNull</a> = <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42754" title="=&gt; Types.this.Type">notNull</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="59551">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="129216">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="129217">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42755" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#129216" title="List[Types.this.Symbol]">formals</a>, <a href="#129217" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="59552">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="129220">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="129221">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42756" title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type">skolemizeExistential</a><span class="delimiter">(</span><a href="#129220" title="Types.this.Symbol">owner</a>, <a href="#129221" title="AnyRef">origin</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="59553">normalize</a> = <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="59554">dealias</a> = <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42759" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="59555">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="129243">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42807" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#129243" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="59556">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="129246">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42808" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#129246" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="59557">prefixString</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42812" title="=&gt; String">prefixString</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="59558">isComplete</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42725" title="=&gt; Boolean">isComplete</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="59559">complete</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="129275">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42726" title="(sym: Types.this.Symbol)Unit">complete</a><span class="delimiter">(</span><a href="#129275" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="59560">load</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="129278">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42817" title="(sym: Types.this.Symbol)Unit">load</a><span class="delimiter">(</span><a href="#129278" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="59561">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="129280">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42825" title="(annots: List[Types.this.AnnotationInfo])Types.this.Type">withAnnotations</a><span class="delimiter">(</span><a href="#129280" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="59562">withoutAnnotations</a> = <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42822" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  case <span class="keyword">object</span> <a href="#129315" title="object Types.this.UnmappableTree" id="129321">UnmappableTree</a> <span title="ScalaObject" class="keyword">extends</span> <span title="Types.this.TermTree">TermTree</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="129292">toString</a> = <span title="String(&quot;&lt;unmappable&gt;&quot;)" class="string">&quot;&lt;unmappable&gt;&quot;</span>
    <span class="keyword">super</span>.<span title="(t: Types.this.Type)Unit">tpe_=</span><span class="delimiter">(</span><a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(t: Types.this.Type)Unit" id="129293">tpe_=</a><span class="delimiter">(</span><a title="Types.this.Type" id="129300">t</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#129300" title="Types.this.Type">t</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <span title="(x$1: String)UnsupportedOperationException" class="keyword">new</span> <span title="UnsupportedOperationException">UnsupportedOperationException</span><span class="delimiter">(</span><span title="String(&quot;tpe_=(&quot;)" class="string">&quot;tpe_=(&quot;</span><span title="(x$1: Any)String">+</span><a href="#129300" title="Types.this.Type">t</a><span title="(x$1: Any)String">+</span><span title="String(&quot;) inapplicable for &lt;empty&gt;&quot;)" class="string">&quot;) inapplicable for &lt;empty&gt;&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class AbsTypeImpl extends Types.this.AbsType with ScalaObject" id="40082">AbsTypeImpl</a> <a href="#40082" title="ScalaObject" class="keyword">extends</a> <a href="#8614" title="Types.this.AbsType">AbsType</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Type =&gt;
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="42706">declaration</a><span class="delimiter">(</span><a title="Types.this.Name" id="82825">name</a>: <a href="Names.scala.html#39679" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="#42761" title="(name: Types.this.Name)Types.this.Symbol">decl</a><span class="delimiter">(</span><a href="#82825" title="Types.this.Name">name</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="42707">nonPrivateDeclaration</a><span class="delimiter">(</span><a title="Types.this.Name" id="129323">name</a>: <a href="Names.scala.html#39679" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="#42763" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateDecl</a><span class="delimiter">(</span><a href="#129323" title="Types.this.Name">name</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="42708">allDeclarations</a> = <a href="#42760" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="42709">allMembers</a> = <a href="#42764" title="=&gt; List[Types.this.Symbol]">members</a>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="42710">typeArguments</a> = <a href="#42741" title="=&gt; List[Types.this.Type]">typeArgs</a>
    <span class="keyword">def</span> <a title="=&gt; _49.global.Type forSome { val _49: Object with scala.reflect.internal.transform.Erasure{val global: Types.this.type} }" id="42711">erasedType</a> = <a href="transform/Transforms.scala.html#40536" title="(tpe: Types.this.Type)_49.global.Type forSome { val _49: Object with scala.reflect.internal.transform.Erasure{val global: Types.this.type} }">transformedType</a><span class="delimiter">(</span><a href="#40082" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** The base class for all types */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Type extends Types.this.AbsTypeImpl with Types.this.Annotatable[Types.this.Type] with ScalaObject" id="40083">Type</a> <a href="#40083" title="ScalaObject" class="keyword">extends</a> <a href="#40082" title="Types.this.AbsTypeImpl">AbsTypeImpl</a> <span class="keyword">with</span> <a href="AnnotationInfos.scala.html#40572" title="Types.this.Annotatable[Types.this.Type]">Annotatable</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> <span class="delimiter">{</span>
    /** Types for which asSeenFrom always is the identity, no matter what
     *  prefix or owner.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="42713">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is this type higher-kinded, i.e., is it a type constructor @M */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="42714">isHigherKinded</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    /** Does this type denote a stable reference (i.e. singleton type)? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="42715">isStable</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is this type dangerous (i.e. it might contain conflicting
     *  type information when empty, so that it can be constructed
     *  so that type unsoundness results.) A dangerous type has an underlying
     *  type of the form T_1 with T_n { decls }, where one of the
     *  T_i (i &gt; 1) is an abstract type.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="42716">isVolatile</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is this type guaranteed not to have `null` as a value? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="42717">isNotNull</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is this type a structural refinement type (it ''refines'' members that have not been inherited) */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="42718">isStructuralRefinement</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    /** Does this type depend immediately on an enclosing method parameter?
      * I.e., is it a singleton type whose termSymbol refers to an argument of the symbol's owner (which is a method)?
      */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="42719">isImmediatelyDependent</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    /** Does this depend on an enclosing method parameter? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="42720">isDependent</a>: <span title="Boolean">Boolean</span> = <a href="#40262" title="object Types.this.IsDependentCollector">IsDependentCollector</a>.<a href="#129341" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** True for WildcardType or BoundedWildcardType. */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="42721">isWildcard</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is this type produced as a repair for an error? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="42722">isError</a>: <span title="Boolean">Boolean</span> = <a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47807" title="=&gt; Boolean">isError</a> <span title="(x: Boolean)Boolean">||</span> <a href="#42727" title="=&gt; Types.this.Symbol">termSymbol</a>.<a href="Symbols.scala.html#47807" title="=&gt; Boolean">isError</a>

    /** Is this type produced as a repair for an error? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="42723">isErroneous</a>: <span title="Boolean">Boolean</span> = <a href="#40278" title="object Types.this.ErroneousCollector">ErroneousCollector</a>.<a href="#129341" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Does this type denote a reference type which can be null? */
    // def isNullable: Boolean = false

    /** Can this type only be subtyped by bottom types?
     *  This is assessed to be the case if the class is final,
     *  and all type parameters (if any) are invariant.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="42724">isFinalType</a> =
      <a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="HasFlags.scala.html#48079" title="=&gt; Boolean">isFinal</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#129377" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47874" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span>

    /** Is this type completed (i.e. not a lazy type)? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="42725">isComplete</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>

    /** If this is a lazy type, assign a new type to `sym`. */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="42726">complete</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="82832">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>

    /** The term symbol associated with the type
      * Note that the symbol of the normalized type is returned (@see normalize)
      */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="42727">termSymbol</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a>

    /** The type symbol associated with the type
      * Note that the symbol of the normalized type is returned (@see normalize)
      * A type's typeSymbol should if possible not be inspected directly, due to
      * the likelihood that what is true for tp.typeSymbol is not true for
      * tp.sym, due to normalization.
      */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="42728">typeSymbol</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a>

    /** The term symbol ''directly'' associated with the type.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="42729">termSymbolDirect</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="#42727" title="=&gt; Types.this.Symbol">termSymbol</a>

    /** The type symbol ''directly'' associated with the type.
     *  In other words, no normalization is performed: if this is an alias type,
     *  the symbol returned is that of the alias, not the underlying type.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="42730">typeSymbolDirect</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>

    /** The base type underlying a type proxy, identity on all other types */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="42731">underlying</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40083" title="Types.this.Type" class="keyword">this</a>

    /** Widen from singleton type to its underlying non-singleton
     *  base type by applying one or more `underlying` dereferences,
     *  identity for all other types.
     *
     *  class Outer { class C ; val x: C }
     *  val o: Outer
     *  &lt;o.x.type&gt;.widen = o.C
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="42732">widen</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40083" title="Types.this.Type" class="keyword">this</a>

    /** Map a constant type or not-null-type to its underlying base type,
     *  identity for all other types.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="42733">deconst</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40083" title="Types.this.Type" class="keyword">this</a>

    /** The type of `this` of a class type or reference type. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="42734">typeOfThis</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47979" title="=&gt; Types.this.Type">typeOfThis</a>

    /** Map to a singleton type which is a subtype of this type.
     *  The fallback implemented here gives
     *    T.narrow  = T' forSome { type T' &lt;: T with Singleton }
     *  Overridden where we know more about where types come from.
     */
    /*
    Note: this implementation of narrow is theoretically superior to the one
    in use below, but imposed a significant performance penalty.  It was in trunk
    from svn r24960 through r25080.
    */
    /*
    def narrow: Type =
      if (phase.erasedTypes) this
      else commonOwner(this) freshExistential &quot;.type&quot; setInfo singletonBounds(this) tpe
    */

    /** Map to a singleton type which is a subtype of this type.
     *  The fallback implemented here gives:
     *  {{{
     *    T.narrow  =  (T {}).this.type
     *  }}}
     *  Overridden where we know more about where types come from.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="42735">narrow</a>: <a href="#40083" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#40083" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="129384">cowner</a> = <a href="#40280" title="(t: Types.this.Type)Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#40195" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>, <a href="#129384" title="Types.this.Symbol">cowner</a>, <a href="Scopes.scala.html#40430" title="object Types.this.EmptyScope">EmptyScope</a>, <a href="#129384" title="Types.this.Symbol">cowner</a>.<a href="Symbols.scala.html#47694" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>.<a href="#42735" title="=&gt; Types.this.Type">narrow</a>
      <span class="delimiter">}</span>

    /** For a TypeBounds type, itself;
     *  for a reference denoting an abstract type, its bounds,
     *  for all other types, a TypeBounds type all of whose bounds are this type.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="42736">bounds</a>: <a href="#66864" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#66838" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** For a class or intersection type, its parents.
     *  For a TypeBounds type, the parents of its hi bound.
     *  inherited by typerefs, singleton types, and refinement types,
     *  The empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="42737">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    /** For a typeref or single-type, the prefix of the normalized type (@see normalize).
     *  NoType for all other types. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="42738">prefix</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#130794" title="object Types.this.NoType">NoType</a>

    /** A chain of all typeref or singletype prefixes of this type, longest first.
     *  (Only used from safeToString.)
     */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="42739">prefixChain</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#40083" title="Types.this.Type" class="keyword">this</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="List[Types.this.Type]">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="129415">pre</a>, _, _<span class="delimiter">)</span> =&gt; <a href="#129415" title="Types.this.Type">pre</a> <a href="#129416" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#129415" title="Types.this.Type">pre</a>.<a href="#42739" title="=&gt; List[Types.this.Type]">prefixChain</a>
      <span class="keyword">case</span> <span title="List[Types.this.Type]">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="129422">pre</a>, _<span class="delimiter">)</span> =&gt; <a href="#129422" title="Types.this.Type">pre</a> <a href="#129423" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#129422" title="Types.this.Type">pre</a>.<a href="#42739" title="=&gt; List[Types.this.Type]">prefixChain</a>
      <span class="keyword">case</span> <span title="List[Nothing]">_</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** This type, without its type arguments @M */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="42740">typeConstructor</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40083" title="Types.this.Type" class="keyword">this</a>

    /** For a typeref, its arguments. The empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="42741">typeArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    
    /** A list of placeholder types derived from the type parameters.
     *  Used by RefinedType and TypeRef.
     */
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="42742">dummyArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#42752" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#129462" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47937" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>

    /** For a (nullary) method or poly type, its direct result type,
     *  the type itself for all other types. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="42743">resultType</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40083" title="Types.this.Type" class="keyword">this</a>

    <span class="keyword">def</span> <a title="(actuals: List[Types.this.Type])Types.this.Type" id="42744">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="76664">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#40083" title="Types.this.Type" class="keyword">this</a>

    /** Only used for dependent method types. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="42745">resultApprox</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#129498" title="(tp: Types.this.Type)Types.this.Type">ApproximateDependentMap</a><span class="delimiter">(</span><a href="#42743" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span> // if (!settings.YdepMethTpes.value) resultType else

    /** If this is a TypeRef `clazz`[`T`], return the argument `T`
     *  otherwise return this type
     */
    <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="42746">remove</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="129507">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40083" title="Types.this.Type" class="keyword">this</a>

    /** For a curried/nullary method or poly type its non-method result type,
     *  the type itself for all other types */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="42747">finalResultType</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40083" title="Types.this.Type" class="keyword">this</a>

    /** For a method type, the number of its value parameter sections,
     *  0 for all other types */
    <span class="keyword">def</span> <a title="=&gt; Int" id="42748">paramSectionCount</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>

    /** For a method or poly type, a list of its value parameter sections,
     *  the empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="42749">paramss</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    /** For a method or poly type, its first value parameter section,
     *  the empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="42750">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    /** For a method or poly type, the types of its first value parameter section,
     *  the empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="42751">paramTypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    /** For a (potentially wrapped) poly type, its type parameters,
     *  the empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="42752">typeParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    /** For a (potentially wrapped) poly or existential type, its bound symbols,
     *  the empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="42753">boundSyms</a>: immutable.<span title="scala.collection.immutable.Set[Types.this.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#40046" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">emptySymbolSet</a>

    /** Mixin a NotNull trait unless type already has one
     *  ...if the option is given, since it is causing typing bugs.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="42754">notNull</a>: <a href="#40083" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75539" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">Ynotnull</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">||</span> <a href="#42717" title="=&gt; Boolean">isNotNull</a> <span title="(x: Boolean)Boolean">||</span> <a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#40083" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#146963" title="(underlying: Types.this.Type)Types.this.NotNullType">NotNullType</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Replace formal type parameter symbols with actual type arguments.
     *
     * Amounts to substitution except for higher-kinded types. (See overridden method in TypeRef) -- @M
     */
    <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="42755">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="88094">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="88095">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#88094" title="List[Types.this.Symbol]">formals</a>, <a href="#88095" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#40083" title="Type.this.type" class="keyword">this</a>.<a href="#42782" title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#88094" title="List[Types.this.Symbol]">formals</a>, <a href="#88095" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#130719" title="object Types.this.ErrorType">ErrorType</a>

    /** If this type is an existential, turn all existentially bound variables to type skolems.
     *  @param  owner    The owner of the created type skolems
     *  @param  origin   The tree whose type was an existential for which the skolem was created.
     */
    <span class="keyword">def</span> <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="42756">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="129226">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="129227">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40083" title="Types.this.Type" class="keyword">this</a>

    /** A simple version of skolemizeExistential for situations where
     *  owner or unpack location do not matter (typically used in subtype tests)
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="42757">skolemizeExistential</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#42756" title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type">skolemizeExistential</a><span class="delimiter">(</span><a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a>, <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>

    /** Reduce to beta eta-long normal form.
     *  Expands type aliases and converts higher-kinded TypeRefs to PolyTypes.
     *  Functions on types are also implemented as PolyTypes.
     *
     *  Example: (in the below, &lt;List&gt; is the type constructor of List)
     *    TypeRef(pre, &lt;List&gt;, List()) is replaced by
     *    PolyType(X, TypeRef(pre, &lt;List&gt;, List(X)))
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="42758">normalize</a> = <a href="#40083" title="Types.this.Type" class="keyword">this</a> // @MAT

    /** Expands type aliases. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="42759">dealias</a> = <a href="#40083" title="Types.this.Type" class="keyword">this</a>

    /** For a classtype or refined type, its defined or declared members;
     *  inherited by subtypes and typerefs.
     *  The empty scope for all other types.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="42760">decls</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a> = <a href="Scopes.scala.html#40430" title="object Types.this.EmptyScope">EmptyScope</a>

    /** The defined or declared members with name `name` in this type;
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Alternatives of overloaded symbol appear in the order they are declared.
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="42761">decl</a><span class="delimiter">(</span><a title="Types.this.Name" id="59892">name</a>: <a href="Names.scala.html#39679" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="#42818" title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol">findDecl</a><span class="delimiter">(</span><a href="#59892" title="Types.this.Name">name</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
    
    /** A list of all non-private members defined or declared in this type. */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="42762">nonPrivateDecls</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#42760" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#61769" title="(p: Types.this.Symbol =&gt; Boolean)Types.this.Scope">filter</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="129568">x</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#129568" title="Types.this.Symbol">x</a>.<a href="HasFlags.scala.html#48084" title="=&gt; Boolean">isPrivate</a><span class="delimiter">)</span> <a href="Scopes.scala.html#61763" title="=&gt; List[Types.this.Symbol]">toList</a>

    /** The non-private defined or declared members with name `name` in this type;
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Alternatives of overloaded symbol appear in the order they are declared.
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="42763">nonPrivateDecl</a><span class="delimiter">(</span><a title="Types.this.Name" id="115595">name</a>: <a href="Names.scala.html#39679" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="#42818" title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol">findDecl</a><span class="delimiter">(</span><a href="#115595" title="Types.this.Name">name</a>, <span title="Int(4)">PRIVATE</span><span class="delimiter">)</span>

    /** A list of all members of this type (defined or inherited)
     *  Members appear in linearization order of their owners.
     *  Members with the same owner appear in reverse order of their declarations.
     */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="42764">members</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#42775" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(0L)" class="int">0</span>, <span title="Long(0L)" class="int">0</span><span class="delimiter">)</span>

    /** A list of all non-private members of this type (defined or inherited) */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="42765">nonPrivateMembers</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#42775" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619972L)">BridgeAndPrivateFlags</span>, <span title="Long(0L)" class="int">0</span><span class="delimiter">)</span>

    /** A list of all non-private members of this type  (defined or inherited),
     *  admitting members with given flags `admit`
     */
    <span class="keyword">def</span> <a title="(admit: Long)List[Types.this.Symbol]" id="42766">nonPrivateMembersAdmitting</a><span class="delimiter">(</span><a title="Long" id="129573">admit</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#42775" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619972L)">BridgeAndPrivateFlags</span> <span title="(x: Long)Long">&amp;</span> <span title="=&gt; Long">~</span><a href="#129573" title="Long">admit</a>, <span title="Long(0L)" class="int">0</span><span class="delimiter">)</span>

    /** A list of all implicit symbols of this type  (defined or inherited) */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="42767">implicitMembers</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#42775" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619968L)">BridgeFlags</span>, <span title="Long(512L)">IMPLICIT</span><span class="delimiter">)</span>

    /** A list of all deferred symbols of this type  (defined or inherited) */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="42768">deferredMembers</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#42775" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619968L)">BridgeFlags</span>, <span title="Long(16L)">DEFERRED</span><span class="delimiter">)</span>

    /** The member with given name,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="42769">member</a><span class="delimiter">(</span><a title="Types.this.Name" id="70213">name</a>: <a href="Names.scala.html#39679" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> =
      <a href="#42776" title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol">memberBasedOnName</a><span class="delimiter">(</span><a href="#70213" title="Types.this.Name">name</a>, <span title="Long(4398113619968L)">BridgeFlags</span><span class="delimiter">)</span>

    /** The non-private member with given name,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Bridges are excluded from the result
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="42770">nonPrivateMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="75448">name</a>: <a href="Names.scala.html#39679" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> =
      <a href="#42776" title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol">memberBasedOnName</a><span class="delimiter">(</span><a href="#75448" title="Types.this.Name">name</a>, <span title="Long(4398113619972L)">BridgeAndPrivateFlags</span><span class="delimiter">)</span>
      
    /** All members with the given flags, excluding bridges.
     */
    <span class="keyword">def</span> <a title="(requiredFlags: Long)List[Types.this.Symbol]" id="42771">membersWithFlags</a><span class="delimiter">(</span><a title="Long" id="129584">requiredFlags</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#42775" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619968L)">BridgeFlags</span>, <a href="#129584" title="Long">requiredFlags</a><span class="delimiter">)</span>

    /** All non-private members with the given flags, excluding bridges.
     */
    <span class="keyword">def</span> <a title="(requiredFlags: Long)List[Types.this.Symbol]" id="42772">nonPrivateMembersWithFlags</a><span class="delimiter">(</span><a title="Long" id="129586">requiredFlags</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#42775" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619972L)">BridgeAndPrivateFlags</span>, <a href="#129586" title="Long">requiredFlags</a><span class="delimiter">)</span>

    /** The non-private member with given name, admitting members with given flags `admit`.
     *  &quot;Admitting&quot; refers to the fact that members with a PRIVATE, BRIDGE, or VBRIDGE
     *  flag are usually excluded from findMember results, but supplying any of those flags
     *  to this method disables that exclusion.
     *
     *  An OverloadedSymbol if several exist, NoSymbol if none exists.
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name, admit: Long)Types.this.Symbol" id="42773">nonPrivateMemberAdmitting</a><span class="delimiter">(</span><a title="Types.this.Name" id="115602">name</a>: <a href="Names.scala.html#39679" title="Types.this.Name">Name</a>, <a title="Long" id="115603">admit</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> =
      <a href="#42776" title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol">memberBasedOnName</a><span class="delimiter">(</span><a href="#115602" title="Types.this.Name">name</a>, <span title="Long(4398113619972L)">BridgeAndPrivateFlags</span> <span title="(x: Long)Long">&amp;</span> <span title="=&gt; Long">~</span><a href="#115603" title="Long">admit</a><span class="delimiter">)</span>

    /** The non-local member with given name,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="42774">nonLocalMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="129592">name</a>: <a href="Names.scala.html#39679" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> =
      <a href="#42776" title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol">memberBasedOnName</a><span class="delimiter">(</span><a href="#129592" title="Types.this.Name">name</a>, BridgeFlags <span title="Long(4398114144256L)">|</span> LOCAL<span class="delimiter">)</span>
    
    /** Members excluding and requiring the given flags.
     *  Note: unfortunately it doesn't work to exclude DEFERRED this way.
     */
    <span class="keyword">def</span> <a title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]" id="42775">membersBasedOnFlags</a><span class="delimiter">(</span><a title="Long" id="129570">excludedFlags</a>: <span title="Long">Long</span>, <a title="Long" id="129571">requiredFlags</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#42819" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="StdNames.scala.html#40560" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#60007" title="=&gt; Types.this.nme.NameType">ANYNAME</a>, <a href="#129570" title="Long">excludedFlags</a>, <a href="#129571" title="Long">requiredFlags</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#47967" title="=&gt; List[Types.this.Symbol]">alternatives</a>

    <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol" id="42776">memberBasedOnName</a><span class="delimiter">(</span><a title="Types.this.Name" id="129581">name</a>: <a href="Names.scala.html#39679" title="Types.this.Name">Name</a>, <a title="Long" id="129582">excludedFlags</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> =
      <a href="#42819" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#129581" title="Types.this.Name">name</a>, <a href="#129582" title="Long">excludedFlags</a>, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

    /** The least type instance of given class which is a supertype
     *  of this type.  Example:
     *    class D[T]
     *    class C extends p.D[Int]
     *    ThisType(C).baseType(D) = p.D[Int]
     */
    <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="42777">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="74582">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#130794" title="object Types.this.NoType">NoType</a>

    /** This type as seen from prefix `pre` and class `clazz`. This means:
     *  Replace all thistypes of `clazz` or one of its subclasses
     *  by `pre` and instantiate all parameters by arguments of `pre`.
     *  Proceed analogously for thistypes referring to outer classes.
     *
     *  Example:
     *    class D[T] { def m: T }
     *    class C extends p.D[Int]
     *    T.asSeenFrom(ThisType(C), D)  (where D is owner of m)
     *      = Int
     */
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="42778">asSeenFrom</a><span class="delimiter">(</span><a title="Types.this.Type" id="82787">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="82788">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#42713" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">||</span> <a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#82787" title="Types.this.Type">pre</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#46442" title="=&gt; Types.this.Symbol">ArrayClass</a><span class="delimiter">)</span> <a href="#40083" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
//        scala.tools.nsc.util.trace.when(pre.isInstanceOf[ExistentialType])(&quot;X &quot;+this+&quot;.asSeenfrom(&quot;+pre+&quot;,&quot;+clazz+&quot; = &quot;) {
        <a href="util/StatBase.scala.html#39915" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39947" title="=&gt; scala.reflect.internal.util.Statistics.Counter">asSeenFromCount</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.LongPair" id="129608">start</a> = <a href="util/StatBase.scala.html#39919" title="(tm: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39949" title="=&gt; scala.reflect.internal.util.Statistics.Timer">asSeenFromNanos</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.AsSeenFromMap" id="129609">m</a> = <span title="Types.this.AsSeenFromMap" class="keyword">new</span> <a href="#40254" title="Types.this.AsSeenFromMap">AsSeenFromMap</a><span class="delimiter">(</span><a href="#82787" title="Types.this.Type">pre</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a>, <a href="#82788" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="129610">tp</a> = <a href="#129609" title="Types.this.AsSeenFromMap">m</a> <a href="#129653" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#40083" title="Types.this.Type" class="keyword">this</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="129611">tp1</a> = <a href="#40208" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#129609" title="Types.this.AsSeenFromMap">m</a>.<a href="#129645" title="=&gt; List[Types.this.Symbol]">capturedParams</a>, <a href="#129610" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="129612">result</a>: <a href="#40083" title="Types.this.Type">Type</a> =
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#129609" title="Types.this.AsSeenFromMap">m</a>.<a href="#129642" title="=&gt; List[Types.this.Symbol]">capturedSkolems</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#129611" title="Types.this.Type">tp1</a>
          <span class="keyword">else</span> <a href="Symbols.scala.html#40016" title="(syms: List[Types.this.Symbol], symFn: Types.this.Symbol =&gt; Types.this.Symbol)(tpe: Types.this.Type)Types.this.Type">deriveType</a><span class="delimiter">(</span><a href="#129609" title="Types.this.AsSeenFromMap">m</a>.<a href="#129642" title="=&gt; List[Types.this.Symbol]">capturedSkolems</a>, <a href="#129673" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47970" title="=&gt; Types.this.Symbol">cloneSymbol</a> <a href="Symbols.scala.html#47901" title="(mask: Long)Types.this.Symbol">setFlag</a> <span title="Long(65536L)">CAPTURED</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#129611" title="Types.this.Type">tp1</a><span class="delimiter">)</span>

        <a href="util/StatBase.scala.html#39920" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: scala.reflect.internal.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39949" title="=&gt; scala.reflect.internal.util.Statistics.Timer">asSeenFromNanos</a>, <a href="#129608" title="scala.reflect.internal.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
        <a href="#129612" title="Types.this.Type">result</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** The info of `sym`, seen as a member of this type.
     *
     *  Example:
     *  {{{
     *    class D[T] { def m: T }
     *    class C extends p.D[Int]
     *    ThisType(C).memberType(m) = Int
     *  }}}
     */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="42779">memberInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="112412">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#112412" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42778" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#112412" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** The type of `sym`, seen as a member of this type. */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="42780">memberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="112420">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#112420" title="Types.this.Symbol">sym</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="129689">meth</a>: <a href="Symbols.scala.html#40004" title="Types.this.MethodSymbol">MethodSymbol</a> =&gt;
        <a href="#129689" title="Types.this.MethodSymbol">meth</a>.<a href="Symbols.scala.html#71275" title="(pre: Types.this.Type)Types.this.Type">typeAsMemberOf</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#42781" title="(sym: Types.this.Symbol)Types.this.Type">computeMemberType</a><span class="delimiter">(</span><a href="#112420" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="42781">computeMemberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="116590">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#116590" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47919" title="=&gt; Types.this.Type">tpeHK</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span> //@M don't prematurely instantiate higher-kinded types, they will be instantiated by transform, typedTypeApply, etc. when really necessary
      <span class="keyword">case</span> <span title="Types.this.OverloadedType">OverloadedType</span><span class="delimiter">(</span>_, <a title="List[Types.this.Symbol]" id="129691">alts</a><span class="delimiter">)</span> =&gt;
        <a href="#146955" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.OverloadedType">OverloadedType</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#129691" title="List[Types.this.Symbol]">alts</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="129694">tp</a> =&gt;
        <a href="#129694" title="Types.this.Type">tp</a>.<a href="#42778" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#116590" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Substitute types `to` for occurrences of references to
     *  symbols `from` in this type.
     */
    <span class="keyword">def</span> <a title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type" id="42782">subst</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="82805">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="82806">to</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#82805" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#40083" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.SubstTypeMap" class="keyword">new</span> <a href="#40258" title="Types.this.SubstTypeMap">SubstTypeMap</a><span class="delimiter">(</span><a href="#82805" title="List[Types.this.Symbol]">from</a>, <a href="#82806" title="List[Types.this.Type]">to</a><span class="delimiter">)</span> <a href="#127621" title="(tp0: Types.this.Type)Types.this.Type">apply</a> <a href="#40083" title="Types.this.Type" class="keyword">this</a>

    /** Substitute symbols `to` for occurrences of symbols `from` in this type.
     *
     * !!! NOTE !!!: If you need to do a substThis and a substSym, the substThis has to come
     * first, as otherwise symbols will immediately get rebound in typeRef to the old
     * symbol.
     */
    <span class="keyword">def</span> <a title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type" id="42783">substSym</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="87957">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="87958">to</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#87957" title="List[Types.this.Symbol]">from</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#87958" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <a href="#40083" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.SubstSymMap" class="keyword">new</span> <a href="#40257" title="Types.this.SubstSymMap">SubstSymMap</a><span class="delimiter">(</span><a href="#87957" title="List[Types.this.Symbol]">from</a>, <a href="#87958" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <a href="#127705" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#40083" title="Types.this.Type" class="keyword">this</a>

    /** Substitute all occurrences of `ThisType(from)` in this type by `to`.
     *
     * !!! NOTE !!!: If you need to do a substThis and a substSym, the substThis has to come
     * first, as otherwise symbols will immediately get rebound in typeRef to the old
     * symbol.
     */
    <span class="keyword">def</span> <a title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type" id="42784">substThis</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="129701">from</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="129702">to</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
      <span title="Types.this.SubstThisMap" class="keyword">new</span> <a href="#40259" title="Types.this.SubstThisMap">SubstThisMap</a><span class="delimiter">(</span><a href="#129701" title="Types.this.Symbol">from</a>, <a href="#129702" title="Types.this.Type">to</a><span class="delimiter">)</span> <a href="#129709" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#40083" title="Types.this.Type" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(from: Types.this.Symbol, to: Types.this.Symbol)Types.this.Type" id="42785">substThis</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="129717">from</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="129718">to</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
      <a href="#42784" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#129717" title="Types.this.Symbol">from</a>, <a href="#129718" title="Types.this.Symbol">to</a>.<a href="Symbols.scala.html#47980" title="=&gt; Types.this.Type">thisType</a><span class="delimiter">)</span>

    /** Performs both substThis and substSym in one traversal.
     */
    <span class="keyword">def</span> <a title="(from: Types.this.Symbol, to: Types.this.Type, symsFrom: List[Types.this.Symbol], symsTo: List[Types.this.Symbol])Types.this.Type" id="42786">substThisAndSym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="115069">from</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="115070">to</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="115071">symsFrom</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="115072">symsTo</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#115071" title="List[Types.this.Symbol]">symsFrom</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#115072" title="List[Types.this.Symbol]">symsTo</a><span class="delimiter">)</span> <a href="#42784" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#115069" title="Types.this.Symbol">from</a>, <a href="#115070" title="Types.this.Type">to</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Types.this.SubstThisAndSymMap" class="keyword">new</span> <a href="#40260" title="Types.this.SubstThisAndSymMap">SubstThisAndSymMap</a><span class="delimiter">(</span><a href="#115069" title="Types.this.Symbol">from</a>, <a href="#115070" title="Types.this.Type">to</a>, <a href="#115071" title="List[Types.this.Symbol]">symsFrom</a>, <a href="#115072" title="List[Types.this.Symbol]">symsTo</a><span class="delimiter">)</span> <a href="#129741" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#40083" title="Types.this.Type" class="keyword">this</a>
    <span class="delimiter">}</span>

    /** Returns all parts of this type which satisfy predicate `p` */
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]" id="42787">filter</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="129751">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="Types.this.FilterTypeCollector" class="keyword">new</span> <a href="#40275" title="Types.this.FilterTypeCollector">FilterTypeCollector</a><span class="delimiter">(</span><a href="#129751" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span> <a href="#129757" title="(tp: Types.this.Type)List[Types.this.Type]">collect</a> <a href="#40083" title="Types.this.Type" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Types.this.FilterTypeCollector{def foreach[U](f: Types.this.Type =&gt; U): Unit; def map[T](f: Types.this.Type =&gt; T): List[T]}" id="42788">withFilter</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="129770">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> = <a href="#129773" title="Types.this.FilterTypeCollector {def foreach[U](f: Types.this.Type =&gt; U): Unit; def map[T](f: Types.this.Type =&gt; T): List[T]}" class="keyword">new</a> <a href="#40275" title="anonymous class $anon extends Types.this.FilterTypeCollector" id="129773">FilterTypeCollector</a><span class="delimiter">(</span><a href="#129770" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="[U](f: Types.this.Type =&gt; U)Unit" id="129775">foreach</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="129777">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; U" id="129781">f</a>: Type =&gt; U<span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#129757" title="(tp: Types.this.Type)List[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type">Type</a>.<span class="keyword">this</span><span class="delimiter">)</span> <span title="(f: Types.this.Type =&gt; U)Unit">foreach</span> <a href="#129781" title="Types.this.Type =&gt; U">f</a>
      <span class="keyword">def</span> <a title="[T](f: Types.this.Type =&gt; T)List[T]" id="129778">map</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="129780">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; T" id="129783">f</a>: Type =&gt; T<span class="delimiter">)</span>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span>  = <a href="#129757" title="(tp: Types.this.Type)List[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type">Type</a>.<span class="keyword">this</span><span class="delimiter">)</span> <span title="(f: Types.this.Type =&gt; T)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],T,List[T]])List[T]">map</span> <a href="#129783" title="Types.this.Type =&gt; T">f</a>
    <span class="delimiter">}</span>

    /** Returns optionally first type (in a preorder traversal) which satisfies predicate `p`,
     *  or None if none exists.
     */
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Option[Types.this.Type]" id="42789">find</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="82274">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <span title="Option[Types.this.Type]">Option</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="Types.this.FindTypeCollector" class="keyword">new</span> <a href="#40277" title="Types.this.FindTypeCollector">FindTypeCollector</a><span class="delimiter">(</span><a href="#82274" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span>.<a href="#129341" title="(tp: Types.this.Type)Option[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Apply `f` to each part of this type */
    <span class="keyword">def</span> <a title="(f: Types.this.Type =&gt; Unit)Unit" id="42790">foreach</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Unit" id="82279">f</a>: Type =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Types.this.ForEachTypeTraverser" class="keyword">new</span> <a href="#40276" title="Types.this.ForEachTypeTraverser">ForEachTypeTraverser</a><span class="delimiter">(</span><a href="#82279" title="Types.this.Type =&gt; Unit">f</a><span class="delimiter">)</span>.<a href="#129918" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span> <span class="delimiter">}</span>

    /** Apply `f` to each part of this type; children get mapped before their parents */
    <span class="keyword">def</span> <a title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.Type" id="42791">map</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Types.this.Type" id="82284">f</a>: Type =&gt; Type<span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#129923" title="Types.this.TypeMap" class="keyword">new</a> <a href="#40242" title="anonymous class $anon extends Types.this.TypeMap" id="129923">TypeMap</a> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(x: Types.this.Type)Types.this.Type" id="129925">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="129926">x</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#82284" title="(v1: Types.this.Type)Types.this.Type">f</a><span class="delimiter">(</span><a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#129926" title="Types.this.Type">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <a href="#129925" title="(x: Types.this.Type)Types.this.Type">apply</a> <a href="#40083" title="Types.this.Type" class="keyword">this</a>

    /** Is there part of this type which satisfies predicate `p`? */
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Boolean" id="42792">exists</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="82269">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="=&gt; Boolean">!</span><a href="#42789" title="(p: Types.this.Type =&gt; Boolean)Option[Types.this.Type]">find</a><span class="delimiter">(</span><a href="#82269" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span>.<span title="=&gt; Boolean">isEmpty</span>

    /** Does this type contain a reference to this symbol? */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="42793">contains</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="82264">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="Types.this.ContainsCollector" class="keyword">new</span> <a href="#40273" title="Types.this.ContainsCollector">ContainsCollector</a><span class="delimiter">(</span><a href="#82264" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#129341" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Does this type contain a reference to this type */
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="42794">containsTp</a><span class="delimiter">(</span><a title="Types.this.Type" id="129971">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="Types.this.ContainsTypeCollector" class="keyword">new</span> <a href="#40274" title="Types.this.ContainsTypeCollector">ContainsTypeCollector</a><span class="delimiter">(</span><a href="#129971" title="Types.this.Type">tp</a><span class="delimiter">)</span>.<a href="#129341" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Is this type a subtype of that type? */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="42795">&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="74451">that</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span>util.<a href="util/Statistics.scala.html#10702" title="object scala.reflect.internal.util.Statistics">Statistics</a>.<a href="util/StatBase.scala.html#39911" title="=&gt; Boolean">enabled</a><span class="delimiter">)</span> <a href="#42797" title="(that: Types.this.Type)Boolean">stat_&lt;:&lt;</a><span class="delimiter">(</span><a href="#74451" title="Types.this.Type">that</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="delimiter">(</span><a href="#40083" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#74451" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
        <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#40044" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#40391" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;&lt;:&quot;)" class="string">&quot;&lt;:&quot;</span>, <a href="#40319" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a>, <a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#74451" title="Types.this.Type">that</a><span class="delimiter">)</span>
         <span class="keyword">else</span> <a href="#40320" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#74451" title="Types.this.Type">that</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** Is this type a subtype of that type in a pattern context?
     *  Any type arguments on the right hand side are replaced with
     *  fresh existentials, except for Arrays.
     *
     *  See bug1434.scala for an example of code which would fail
     *  if only a &lt;:&lt; test were applied.
     */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="42796">matchesPattern</a><span class="delimiter">(</span><a title="Types.this.Type" id="130018">that</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="delimiter">(</span><a href="#40083" title="Type.this.type" class="keyword">this</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#130018" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#130018" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>TypeRef<span class="delimiter">(</span>_, <a href="Definitions.scala.html#46442" title="=&gt; Types.this.Symbol">ArrayClass</a>, <a href="#130030" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="130041">arg1</a><span class="delimiter">)</span><span class="delimiter">)</span>, TypeRef<span class="delimiter">(</span>_, <a href="Definitions.scala.html#46442" title="=&gt; Types.this.Symbol">ArrayClass</a>, <a href="#130043" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="130054">arg2</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#130054" title="Types.this.Type">arg2</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">nonEmpty</span> =&gt;
          <a href="#130041" title="Types.this.Type">arg1</a> <a href="#42796" title="(that: Types.this.Type)Boolean">matchesPattern</a> <a href="#130054" title="Types.this.Type">arg2</a>
        <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>_, TypeRef<span class="delimiter">(</span>_, _, <a title="List[Types.this.Type]" id="130058">args</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="130059">newtp</a> = <a href="#40208" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#130058" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <span class="delimiter">(</span><a href="#130076" title="Types.this.Type">_</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>, <a href="#130018" title="Types.this.Type">that</a><span class="delimiter">)</span>
          <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#130018" title="Types.this.Type">that</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#130059" title="Types.this.Type">newtp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#40083" title="Type.this.type" class="keyword">this</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#130059" title="Types.this.Type">newtp</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
          <span title="Boolean(false)" class="keyword">false</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="42797">stat_&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="129985">that</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="util/StatBase.scala.html#39915" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39951" title="=&gt; scala.reflect.internal.util.Statistics.Counter">subtypeCount</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.LongPair" id="130105">start</a> = <a href="util/StatBase.scala.html#39919" title="(tm: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39953" title="=&gt; scala.reflect.internal.util.Statistics.Timer">subtypeNanos</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Boolean" id="130106">result</a> =
        <span class="delimiter">(</span><a href="#40083" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#129985" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
        <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#40044" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#40391" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;&lt;:&quot;)" class="string">&quot;&lt;:&quot;</span>, <a href="#40319" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a>, <a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#129985" title="Types.this.Type">that</a><span class="delimiter">)</span>
         <span class="keyword">else</span> <a href="#40320" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#129985" title="Types.this.Type">that</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="util/StatBase.scala.html#39920" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: scala.reflect.internal.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39953" title="=&gt; scala.reflect.internal.util.Statistics.Timer">subtypeNanos</a>, <a href="#130105" title="scala.reflect.internal.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
      <a href="#130106" title="Boolean">result</a>
    <span class="delimiter">}</span>

    /** Is this type a weak subtype of that type? True also for numeric types, i.e. Int weak_&lt;:&lt; Long.
     */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="42798">weak_&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="130131">that</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="util/StatBase.scala.html#39915" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39951" title="=&gt; scala.reflect.internal.util.Statistics.Counter">subtypeCount</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.LongPair" id="130133">start</a> = <a href="util/StatBase.scala.html#39919" title="(tm: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39953" title="=&gt; scala.reflect.internal.util.Statistics.Timer">subtypeNanos</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Boolean" id="130134">result</a> =
        <span class="delimiter">(</span><span class="delimiter">(</span><a href="#40083" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130131" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
         <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#40044" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#40391" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;weak_&lt;:&quot;)" class="string">&quot;weak_&lt;:&quot;</span>, <a href="#40359" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isWeakSubType</a>, <a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#130131" title="Types.this.Type">that</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#40359" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isWeakSubType</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#130131" title="Types.this.Type">that</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="util/StatBase.scala.html#39920" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: scala.reflect.internal.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39953" title="=&gt; scala.reflect.internal.util.Statistics.Timer">subtypeNanos</a>, <a href="#130133" title="scala.reflect.internal.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
      <a href="#130134" title="Boolean">result</a>
    <span class="delimiter">}</span>

    /** Is this type equivalent to that type? */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="42799">=:=</a><span class="delimiter">(</span><a title="Types.this.Type" id="68114">that</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span>
      <span class="delimiter">(</span><a href="#40083" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#68114" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
      <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#40044" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#40391" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;=&quot;)" class="string">&quot;=&quot;</span>, <a href="#40302" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a>, <a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#68114" title="Types.this.Type">that</a><span class="delimiter">)</span>
       <span class="keyword">else</span> <a href="#40302" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#68114" title="Types.this.Type">that</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>;

    /** Does this type implement symbol `sym` with same or stronger type? */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="42800">specializes</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="130199">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#40044" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#40391" title="(op: String, p: (Types.this.Type, Types.this.Symbol) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Symbol)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;specializes&quot;)" class="string">&quot;specializes&quot;</span>, <a href="#40332" title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean">specializesSym</a>, <a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#130199" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#40332" title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#130199" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>

    /** Is this type close enough to that type so that members
     *  with the two type would override each other?
     *  This means:
     *    - Either both types are polytypes with the same number of
     *      type parameters and their result types match after renaming
     *      corresponding type parameters
     *    - Or both types are (nullary) method types with equivalent type parameter types
     *      and matching result types
     *    - Or both types are equivalent
     *    - Or phase.erasedTypes is false and both types are neither method nor
     *      poly types.
     */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="42801">matches</a><span class="delimiter">(</span><a title="Types.this.Type" id="83043">that</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#40334" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#83043" title="Types.this.Type">that</a>, <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>

    /** Same as matches, except that non-method types are always assumed to match. */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="42802">looselyMatches</a><span class="delimiter">(</span><a title="Types.this.Type" id="130235">that</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#40334" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#130235" title="Types.this.Type">that</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

    /** The shortest sorted upwards closed array of types that contains
     *  this type as first element.
     *
     *  A list or array of types ts is upwards closed if
     *
     *    for all t in ts:
     *      for all typerefs p.s[args] such that t &lt;: p.s[args]
     *      there exists a typeref p'.s[args'] in ts such that
     *      t &lt;: p'.s['args] &lt;: p.s[args],
     *
     *      and
     *
     *      for all singleton types p.s such that t &lt;: p.s
     *      there exists a singleton type p'.s in ts such that
     *      t &lt;: p'.s &lt;: p.s
     *
     *  Sorting is with respect to Symbol.isLess() on type symbols.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="42803">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#40512" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="BaseTypeSeqs.scala.html#40515" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">baseTypeSingletonSeq</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** The maximum depth (@see maxDepth)
     *  of each type in the BaseTypeSeq of this type.
     */
    <span class="keyword">def</span> <a title="=&gt; Int" id="42804">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <span title="Int(1)" class="int">1</span>

    /** The list of all baseclasses of this type (including its own typeSymbol)
     *  in reverse linearization order, starting with the class itself and ending
     *  in class Any.
     */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="42805">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    /**
     *  @param sym the class symbol
     *  @return    the index of given class symbol in the BaseTypeSeq of this type,
     *             or -1 if no base type with given class symbol exists.
     */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Int" id="42806">baseTypeIndex</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="116946">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="130245">bts</a> = <a href="#42803" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
      <span class="keyword">var</span> <a title="Int" id="130246">lo</a> = <span title="Int(0)" class="int">0</span>
      <span class="keyword">var</span> <a title="Int" id="130247">hi</a> = <a href="#130245" title="Types.this.BaseTypeSeq">bts</a>.<a href="BaseTypeSeqs.scala.html#60843" title="=&gt; Int">length</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#130246" title="Int">lo</a> <span title="(x: Int)Boolean">&lt;=</span> <a href="#130247" title="Int">hi</a><span class="delimiter">)</span> <a href="#130248" title="()Unit" class="delimiter">{</a>
        <span class="keyword">val</span> <a title="Int" id="130257">mid</a> = <span class="delimiter">(</span><a href="#130246" title="Int">lo</a> <span title="(x: Int)Int">+</span> <a href="#130247" title="Int">hi</a><span class="delimiter">)</span> <span title="(x: Int)Int">/</span> <span title="Int(2)" class="int">2</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="130258">btssym</a> = <a href="#130245" title="Types.this.BaseTypeSeq">bts</a>.<a href="BaseTypeSeqs.scala.html#60848" title="(i: Int)Types.this.Symbol">typeSymbol</a><span class="delimiter">(</span><a href="#130257" title="Int">mid</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#116946" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#130258" title="Types.this.Symbol">btssym</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#130257" title="Int">mid</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#116946" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#47961" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#130258" title="Types.this.Symbol">btssym</a><span class="delimiter">)</span> <a href="#130247" title="Int">hi</a> = <a href="#130257" title="Int">mid</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130258" title="Types.this.Symbol">btssym</a> <a href="Symbols.scala.html#47961" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#116946" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#130246" title="Int">lo</a> = <a href="#130257" title="Int">mid</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>
        <span class="keyword">else</span> <a href="SymbolTable.scala.html#36940" title="()Nothing">abort</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      -<span title="Int(-1)" class="int">1</span>
    <span class="delimiter">}</span>

    /** If this is a poly- or methodtype, a copy with cloned type / value parameters
     *  owned by `owner`. Identity for all other types.
     */
    <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="42807">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="112856">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#40083" title="Types.this.Type" class="keyword">this</a>

    /** Make sure this type is correct as the info of given owner; clone it if not. */
    <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="42808">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="114659">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#40083" title="Types.this.Type" class="keyword">this</a>

    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; String" id="42809">objectPrefix</a> = <span title="String(&quot;object &quot;)" class="string">&quot;object &quot;</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; String" id="42810">packagePrefix</a> = <span title="String(&quot;package &quot;)" class="string">&quot;package &quot;</span>
    <span class="keyword">def</span> <a title="(str: String)String" id="42811">trimPrefix</a><span class="delimiter">(</span><a title="String" id="129253">str</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#129253" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">str</a> <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">stripPrefix</span> <a href="#42809" title="=&gt; String">objectPrefix</a> <span title="(prefix: String)String">stripPrefix</span> <a href="#42810" title="=&gt; String">packagePrefix</a>

    /** The string representation of this type used as a prefix */
    <span class="keyword">def</span> <a title="=&gt; String" id="42812">prefixString</a> = <a href="#42811" title="(str: String)String">trimPrefix</a><span class="delimiter">(</span><a href="#42813" title="()String">toString</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span>

   /** Convert toString avoiding infinite recursions by cutting off
     *  after `maxTostringRecursions` recursion levels. Uses `safeToString`
     *  to produce a string on each level.
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="42813">toString</a>: <span title="String">String</span> =
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#40405" title="=&gt; Int">tostringRecursions</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(50)">maxTostringRecursions</span><span class="delimiter">)</span>
        <span title="String(&quot;...&quot;)" class="string">&quot;...&quot;</span>
      <span class="keyword">else</span>
        <span class="keyword">try</span> <span class="delimiter">{</span>
          <a href="#40405" title="(x$1: Int)Unit">tostringRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
          <a href="#42814" title="=&gt; String">safeToString</a>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
          <a href="#40405" title="(x$1: Int)Unit">tostringRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
        <span class="delimiter">}</span>

    /** Method to be implemented in subclasses.
     *  Converts this type to a string in calling toString for its parts.
     */
    <span class="keyword">def</span> <a title="=&gt; String" id="42814">safeToString</a>: <span title="String">String</span> = <a href="#40083" title="Types.this.Type" class="keyword">super</a>.<span title="()String">toString</span>

    /** The string representation of this type, with singletypes explained. */
    <span class="keyword">def</span> <a title="=&gt; String" id="42815">toLongString</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="128345">str</a> = <a href="#42813" title="()String">toString</a>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#128345" title="String">str</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="String(&quot;type&quot;)" class="string">&quot;type&quot;</span><span class="delimiter">)</span> <a href="#42732" title="=&gt; Types.this.Type">widen</a>.<a href="#42813" title="()String">toString</a>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#128345" title="String">str</a> <span title="(x$1: String)Boolean">endsWith</span> <span title="String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span><span class="delimiter">)</span> <a href="#128345" title="String">str</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; (with underlying type &quot;)" class="string">&quot; (with underlying type &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#42732" title="=&gt; Types.this.Type">widen</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
      <span class="keyword">else</span> <a href="#128345" title="String">str</a>
    <span class="delimiter">}</span>

    /** A test whether a type contains any unification type variables. */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="42816">isGround</a>: <span title="Boolean">Boolean</span> = <a href="#40083" title="Types.this.Type" class="keyword">this</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#84241" title="Boolean">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="130301">constr</a><span class="delimiter">)</span> =&gt;
        <a href="#130301" title="Types.this.TypeConstraint">constr</a>.<a href="#84304" title="=&gt; Boolean">instValid</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#130301" title="Types.this.TypeConstraint">constr</a>.<a href="#84302" title="=&gt; Types.this.Type">inst</a>.<a href="#42816" title="=&gt; Boolean">isGround</a>
      <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="130305">pre</a>, <a title="Types.this.Symbol" id="130306">sym</a>, <a title="List[Types.this.Type]" id="130307">args</a><span class="delimiter">)</span> =&gt;
        <a href="#130306" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="#130305" title="Types.this.Type">pre</a>.<a href="#42816" title="=&gt; Boolean">isGround</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#130307" title="List[Types.this.Type]">args</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#130314" title="Types.this.Type">_</a>.<a href="#42816" title="=&gt; Boolean">isGround</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="130315">pre</a>, <a title="Types.this.Symbol" id="130316">sym</a><span class="delimiter">)</span> =&gt;
        <a href="#130316" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="#130315" title="Types.this.Type">pre</a>.<a href="#42816" title="=&gt; Boolean">isGround</a>
      <span class="keyword">case</span> <span title="Boolean(true)">ThisType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> | <a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a> | <a href="#130739" title="object Types.this.WildcardType">WildcardType</a> | <a href="#130794" title="object Types.this.NoType">NoType</a> | <a href="#130719" title="object Types.this.ErrorType">ErrorType</a> | ConstantType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
        <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#130318" title="(tp: Types.this.Type)Types.this.Type">typeVarToOriginMap</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#40083" title="Types.this.Type" class="keyword">this</a>
    <span class="delimiter">}</span>

    /** If this is a symbol loader type, load and assign a new type to `sym`. */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="42817">load</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="113996">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol" id="42818">findDecl</a><span class="delimiter">(</span><a title="Types.this.Name" id="129551">name</a>: <a href="Names.scala.html#39679" title="Types.this.Name">Name</a>, <a title="Int" id="129552">excludedFlags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="130323">alts</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="130324">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a>
      <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="130325">e</a>: <a href="Scopes.scala.html#40421" title="Types.this.ScopeEntry">ScopeEntry</a> = <a href="#42760" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61761" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#129551" title="Types.this.Name">name</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#130325" title="Types.this.ScopeEntry">e</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#130326" title="()Unit" class="delimiter">{</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#130325" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#71190" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47905" title="(mask: Long)Boolean">hasFlag</a><span class="delimiter">(</span><a href="#129552" title="=&gt; Long">excludedFlags</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130324" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#130324" title="Types.this.Symbol">sym</a> = <a href="#130325" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#71190" title="=&gt; Types.this.Symbol">sym</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130323" title="List[Types.this.Symbol]">alts</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#130323" title="List[Types.this.Symbol]">alts</a> = <span title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</span><span class="delimiter">(</span><a href="#130324" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <a href="#130323" title="List[Types.this.Symbol]">alts</a> = <a href="#130325" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#71190" title="=&gt; Types.this.Symbol">sym</a> <a href="#130349" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#130323" title="List[Types.this.Symbol]">alts</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <a href="#130325" title="Types.this.ScopeEntry">e</a> = <a href="#42760" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61762" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a><span class="delimiter">(</span><a href="#130325" title="Types.this.ScopeEntry">e</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#130323" title="List[Types.this.Symbol]">alts</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#130324" title="Types.this.Symbol">sym</a>
      <span class="keyword">else</span> <span class="delimiter">(</span><a href="#42805" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#47722" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.Symbol">newOverloaded</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#130323" title="List[Types.this.Symbol]">alts</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /**
     *  Find member(s) in this type. If several members matching criteria are found, they are
     *  returned in an OverloadedSymbol
     *
     *  @param name           The member's name, where nme.ANYNAME means `unspecified`
     *  @param excludedFlags  Returned members do not have these flags
     *  @param requiredFlags  Returned members do have these flags
     *  @param stableOnly     If set, return only members that are types or stable values
     */
    //TODO: use narrow only for modules? (correct? efficiency gain?)
    <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol" id="42819">findMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="129598">name</a>: <a href="Names.scala.html#39679" title="Types.this.Name">Name</a>, <a title="Long" id="129599">excludedFlags</a>: <span title="Long">Long</span>, <a title="Long" id="129600">requiredFlags</a>: <span title="Long">Long</span>, <a title="Boolean" id="129601">stableOnly</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      // if this type contains type variables, put them to sleep for a while -- don't just wipe them out by
      // replacing them by the corresponding type parameter, as that messes up (e.g.) type variables in type refinements
      // without this, the matchesType call would lead to type variables on both sides
      // of a subtyping/equality judgement, which can lead to recursive types being constructed.
      // See (t0851) for a situation where this happens.
      <span class="keyword">val</span> <a title="List[Types.this.TypeVar]" id="130360">suspension</a>: <span title="List[Types.this.TypeVar]">List</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> = <span title="List[Types.this.TypeVar]" class="keyword">if</span> <span class="delimiter">(</span><a href="#40083" title="Type.this.type" class="keyword">this</a>.<a href="#42816" title="=&gt; Boolean">isGround</a><span class="delimiter">)</span> <span title="Null(null)" class="keyword">null</span> <span class="keyword">else</span> <a href="#40378" title="(tp: Types.this.Type)List[Types.this.TypeVar]">suspendTypeVarsInType</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

      <a href="util/StatBase.scala.html#39915" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39939" title="=&gt; scala.reflect.internal.util.Statistics.Counter">findMemberCount</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.LongPair" id="130361">start</a> = <a href="util/StatBase.scala.html#39919" title="(tm: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39945" title="=&gt; scala.reflect.internal.util.Statistics.Timer">findMemberNanos</a><span class="delimiter">)</span>

      //Console.println(&quot;find member &quot; + name.decode + &quot; in &quot; + this + &quot;:&quot; + this.baseClasses)//DEBUG
      <span class="keyword">var</span> <a title="Types.this.Scope" id="130362">members</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a> = <span title="Null(null)" class="keyword">null</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="130363">member</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a>
      <span class="keyword">var</span> <a title="Long" id="130364">excluded</a> = <a href="#129599" title="Long">excludedFlags</a> <span title="(x: Int)Long">|</span> <span title="Int(16)">DEFERRED</span>
      <span class="keyword">var</span> <a title="Boolean" id="130365">continue</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">var</span> <a title="Types.this.Type" id="130366">self</a>: <a href="#40083" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
      <span class="keyword">var</span> <a title="Types.this.Type" id="130367">membertpe</a>: <a href="#40083" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#130365" title="Boolean">continue</a><span class="delimiter">)</span> <a href="#130368" title="()Unit" class="delimiter">{</a>
        <a href="#130365" title="Boolean">continue</a> = <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="130377">bcs0</a> = <a href="#42805" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
        <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="130378">bcs</a> = <a href="#130377" title="List[Types.this.Symbol]">bcs0</a>
        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#130378" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#130379" title="()Unit" class="delimiter">{</a>
          <span class="keyword">val</span> <a title="Types.this.Scope" id="130381">decls</a> = <a href="#130378" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42760" title="=&gt; Types.this.Scope">decls</a>
          <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="130382">entry</a> =
            <span title="Types.this.ScopeEntry" class="keyword">if</span> <span class="delimiter">(</span><a href="#129598" title="Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#40560" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#60007" title="=&gt; Types.this.nme.NameType">ANYNAME</a><span class="delimiter">)</span> <a href="#130381" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61726" title="=&gt; Types.this.ScopeEntry">elems</a> <span class="keyword">else</span> <a href="#130381" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61761" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#129598" title="Types.this.Name">name</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#130382" title="Types.this.ScopeEntry">entry</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#130383" title="()Unit" class="delimiter">{</a>
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="130391">sym</a> = <a href="#130382" title="Types.this.ScopeEntry">entry</a>.<a href="Scopes.scala.html#71190" title="=&gt; Types.this.Symbol">sym</a>
            <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#130391" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#47906" title="(mask: Long)Boolean">hasAllFlags</a> <a href="#129600" title="Long">requiredFlags</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Long" id="130392">excl</a> = <a href="#130391" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47903" title="(mask: Long)Long">getFlag</a><span class="delimiter">(</span><a href="#130364" title="Long">excluded</a><span class="delimiter">)</span>
              <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#130392" title="Long">excl</a> <span title="(x: Long)Boolean">==</span> <span title="Long(0L)" class="long">0L</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                  <span class="delimiter">(</span>// omit PRIVATE LOCALS unless selector class is contained in class owning the def.
                   <span class="delimiter">(</span><a href="#130378" title="List[Types.this.Symbol]">bcs</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130377" title="List[Types.this.Symbol]">bcs0</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
                   <span title="=&gt; Boolean">!</span><a href="#130391" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#48088" title="=&gt; Boolean">isPrivateLocal</a> <span title="(x: Boolean)Boolean">||</span>
                   <span class="delimiter">(</span><a href="#130377" title="List[Types.this.Symbol]">bcs0</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#47882" title="(sym: Types.this.Symbol)Boolean">hasTransOwner</a><span class="delimiter">(</span><a href="#130378" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Types.this.Symbol">head</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#129598" title="Types.this.Name">name</a>.<a href="Names.scala.html#53411" title="=&gt; Boolean">isTypeName</a> <span title="(x: Boolean)Boolean">||</span> <a href="#129601" title="Boolean">stableOnly</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#130391" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47846" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <a href="util/StatBase.scala.html#39920" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: scala.reflect.internal.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39945" title="=&gt; scala.reflect.internal.util.Statistics.Timer">findMemberNanos</a>, <a href="#130361" title="scala.reflect.internal.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
                  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130360" title="List[Types.this.TypeVar]">suspension</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#130360" title="List[Types.this.TypeVar]">suspension</a> <span title="(f: Types.this.TypeVar =&gt; Unit)Unit">foreach</span> <span class="delimiter">(</span><a href="#130418" title="Types.this.TypeVar">_</a>.<a href="#84216" title="(x$1: Boolean)Unit">suspended</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
                  <span title="Nothing" class="keyword">return</span> <a href="#130391" title="Types.this.Symbol">sym</a>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#130363" title="Types.this.Symbol">member</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <a href="#130363" title="Types.this.Symbol">member</a> = <a href="#130391" title="Types.this.Symbol">sym</a>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#130362" title="Types.this.Scope">members</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130363" title="Types.this.Symbol">member</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#130391" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a> <span title="(x: Boolean)Boolean">||</span>
                      <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#130363" title="Types.this.Symbol">member</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#130391" title="Types.this.Symbol">sym</a> <span title="(x: Boolean)Boolean">||</span>
                        <a href="#130363" title="Types.this.Symbol">member</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#130391" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                        <span title="=&gt; Boolean">!</span><a href="#130391" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#48084" title="=&gt; Boolean">isPrivate</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
                          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130366" title="Types.this.Type">self</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#130366" title="Types.this.Type">self</a> = <a href="#40083" title="Type.this.type" class="keyword">this</a>.<a href="#42735" title="=&gt; Types.this.Type">narrow</a>
                          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130367" title="Types.this.Type">membertpe</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#130367" title="Types.this.Type">membertpe</a> = <a href="#130366" title="Types.this.Type">self</a>.<a href="#42780" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#130363" title="Types.this.Symbol">member</a><span class="delimiter">)</span>
                          <span class="delimiter">(</span><a href="#130367" title="Types.this.Type">membertpe</a> <a href="#42801" title="(that: Types.this.Type)Boolean">matches</a> <a href="#130366" title="Types.this.Type">self</a>.<a href="#42780" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#130391" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                        <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#130362" title="Types.this.Scope">members</a> = <a href="Scopes.scala.html#61746" title="(decls: List[Types.this.Symbol])Types.this.Scope" class="keyword">new</a> <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a><span class="delimiter">(</span><span title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</span><span class="delimiter">(</span><a href="#130363" title="Types.this.Symbol">member</a>, <a href="#130391" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  <span class="delimiter">}</span>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                  <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="130457">prevEntry</a> = <a href="#130362" title="Types.this.Scope">members</a>.<a href="Scopes.scala.html#61761" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#130391" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
                  <span class="keyword">var</span> <a title="Types.this.Type" id="130458">symtpe</a>: <a href="#40083" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
                  <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#130457" title="Types.this.ScopeEntry">prevEntry</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                         <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#130457" title="Types.this.ScopeEntry">prevEntry</a>.<a href="Scopes.scala.html#71190" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#130391" title="Types.this.Symbol">sym</a> <span title="(x: Boolean)Boolean">||</span>
                           <a href="#130457" title="Types.this.ScopeEntry">prevEntry</a>.<a href="Scopes.scala.html#71190" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#130391" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                           <span title="=&gt; Boolean">!</span><a href="#130391" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47905" title="(mask: Long)Boolean">hasFlag</a><span class="delimiter">(</span><span title="Long(4L)">PRIVATE</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
                             <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130366" title="Types.this.Type">self</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#130366" title="Types.this.Type">self</a> = <a href="#40083" title="Type.this.type" class="keyword">this</a>.<a href="#42735" title="=&gt; Types.this.Type">narrow</a>
                             <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130458" title="Types.this.Type">symtpe</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#130458" title="Types.this.Type">symtpe</a> = <a href="#130366" title="Types.this.Type">self</a>.<a href="#42780" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#130391" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
                             <a href="#130366" title="Types.this.Type">self</a>.<a href="#42780" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#130457" title="Types.this.ScopeEntry">prevEntry</a>.<a href="Scopes.scala.html#71190" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#42801" title="(that: Types.this.Type)Boolean">matches</a> <a href="#130458" title="Types.this.Type">symtpe</a>
                           <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#130457" title="Types.this.ScopeEntry">prevEntry</a> = <a href="#130362" title="Types.this.Scope">members</a> <a href="Scopes.scala.html#61762" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a> <a href="#130457" title="Types.this.ScopeEntry">prevEntry</a>
                  <span class="delimiter">}</span>
                  <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#130457" title="Types.this.ScopeEntry">prevEntry</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#130362" title="Types.this.Scope">members</a> <a href="Scopes.scala.html#61752" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#130391" title="Types.this.Symbol">sym</a>
                  <span class="delimiter">}</span>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130392" title="Long">excl</a> <span title="(x: Long)Boolean">==</span> <span title="Int(16)">DEFERRED</span>.<span title="=&gt; Long">toLong</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="#130365" title="Boolean">continue</a> = <span title="Boolean(true)" class="keyword">true</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <a href="#130382" title="Types.this.ScopeEntry">entry</a> = <span title="Types.this.ScopeEntry" class="keyword">if</span> <span class="delimiter">(</span><a href="#129598" title="Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#40560" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#60007" title="=&gt; Types.this.nme.NameType">ANYNAME</a><span class="delimiter">)</span> <a href="#130382" title="Types.this.ScopeEntry">entry</a>.<a href="Scopes.scala.html#71198" title="=&gt; Types.this.ScopeEntry">next</a> <span class="keyword">else</span> <a href="#130381" title="Types.this.Scope">decls</a> <a href="Scopes.scala.html#61762" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a> <a href="#130382" title="Types.this.ScopeEntry">entry</a>
          <span class="delimiter">}</span> // while (entry ne null)
          // excluded = excluded | LOCAL
          <a href="#130378" title="List[Types.this.Symbol]">bcs</a> = <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#129598" title="Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#40560" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#60009" title="=&gt; Types.this.nme.NameType">CONSTRUCTOR</a><span class="delimiter">)</span> <span title="object Nil">Nil</span> <span class="keyword">else</span> <a href="#130378" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>
        <span class="delimiter">}</span> // while (!bcs.isEmpty)
        <a href="#130364" title="Long">excluded</a> = <a href="#129599" title="Long">excludedFlags</a>
      <span class="delimiter">}</span> // while (continue)
      <a href="util/StatBase.scala.html#39920" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: scala.reflect.internal.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39945" title="=&gt; scala.reflect.internal.util.Statistics.Timer">findMemberNanos</a>, <a href="#130361" title="scala.reflect.internal.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130360" title="List[Types.this.TypeVar]">suspension</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#130360" title="List[Types.this.TypeVar]">suspension</a> <span title="(f: Types.this.TypeVar =&gt; Unit)Unit">foreach</span> <span class="delimiter">(</span><a href="#130505" title="Types.this.TypeVar">_</a>.<a href="#84216" title="(x$1: Boolean)Unit">suspended</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#130362" title="Types.this.Scope">members</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130363" title="Types.this.Symbol">member</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="util/StatBase.scala.html#39915" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39941" title="=&gt; scala.reflect.internal.util.Statistics.Counter">noMemberCount</a><span class="delimiter">)</span>
        <a href="#130363" title="Types.this.Symbol">member</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="util/StatBase.scala.html#39915" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39943" title="=&gt; scala.reflect.internal.util.Statistics.Counter">multMemberCount</a><span class="delimiter">)</span>
        <a href="#42805" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#47722" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.Symbol">newOverloaded</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a>, <a href="#130362" title="Types.this.Scope">members</a>.<a href="Scopes.scala.html#61763" title="=&gt; List[Types.this.Symbol]">toList</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    /** The existential skolems and existentially quantified variables which are free in this type */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="42820">existentialSkolems</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="130520">boundSyms</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="130521">skolems</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="130537">t</a> &lt;- <a href="#42790" title="(f: Types.this.Type =&gt; Unit)Unit" class="keyword">this</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#130537" title="Types.this.Type">t</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Unit">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="130538">quantified</a>, <a title="Types.this.Type" id="130539">qtpe</a><span class="delimiter">)</span> =&gt;
            <a href="#130520" title="List[Types.this.Symbol]">boundSyms</a> = <a href="#130520" title="List[Types.this.Symbol]">boundSyms</a> <a href="#130540" title="(prefix: List[Types.this.Symbol])List[Types.this.Symbol]">:::</a> <a href="#130538" title="List[Types.this.Symbol]">quantified</a>
          <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="130548">sym</a>, _<span class="delimiter">)</span> =&gt;
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#130548" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#47905" title="(mask: Long)Boolean">hasFlag</a> <span title="Long(34359738368L)">EXISTENTIAL</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#130520" title="List[Types.this.Symbol]">boundSyms</a> <span title="(elem: Any)Boolean">contains</span> <a href="#130548" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#130521" title="List[Types.this.Symbol]">skolems</a> <span title="(elem: Any)Boolean">contains</span> <a href="#130548" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#130521" title="List[Types.this.Symbol]">skolems</a> = <a href="#130548" title="Types.this.Symbol">sym</a> <a href="#130549" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#130521" title="List[Types.this.Symbol]">skolems</a>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#130521" title="List[Types.this.Symbol]">skolems</a>
    <span class="delimiter">}</span>

    // Implementation of Annotatable for all types but AnnotatedType, which
    // overrides these.
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.AnnotationInfo]" id="42821">annotations</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span> = <span title="object Nil">Nil</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="42822">withoutAnnotations</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40083" title="Types.this.Type" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(p: Types.this.AnnotationInfo =&gt; Boolean)Types.this.Type" id="42823">filterAnnotations</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo =&gt; Boolean" id="74894">p</a>: AnnotationInfo =&gt; Boolean<span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40083" title="Types.this.Type" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="42824">setAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="74934">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a>  = <a href="#40180" title="(annots: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.Type">annotatedType</a><span class="delimiter">(</span><a href="#74934" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="42825">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="74914">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40180" title="(annots: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.Type">annotatedType</a><span class="delimiter">(</span><a href="#74914" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Remove any annotations from this type and from any
     *  types embedded in this type. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="42826">stripAnnotations</a> = <a href="#130564" title="(tp: Types.this.Type)Types.this.Type">StripAnnotationsMap</a><span class="delimiter">(</span><a href="#40083" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Set the self symbol of an annotated type, or do nothing
     *  otherwise.  */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="42827">withSelfsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="130569">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#40083" title="Types.this.Type" class="keyword">this</a>

    /** The selfsym of an annotated type, or NoSymbol of anything else */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="42828">selfsym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a>

    /** The kind of this type; used for debugging */
    <span class="keyword">def</span> <a title="=&gt; String" id="42829">kind</a>: <span title="String">String</span> = <span title="String(&quot;unknown type of class &quot;)" class="string">&quot;unknown type of class &quot;</span><span title="(x$1: Any)String">+</span><a href="#40083" title="()Class[_]">getClass</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

// Subclasses ------------------------------------------------------------

  <span class="keyword">trait</span> <a title="trait UniqueType extends Object with Product with ScalaObject" id="40084">UniqueType</a> <span title="ScalaObject" class="keyword">extends</span> <span title="Product">Product</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">val</span> <a title="Int" id="130578">hashCode</a> = scala.runtime.<span title="object scala.runtime.ScalaRunTime">ScalaRunTime</span>.<span title="(x: Product)Int">_hashCode</span><span class="delimiter">(</span><a href="#40084" title="Types.this.UniqueType" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

 /** A base class for types that defer some operations
   *  to their immediate supertype.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SubType extends Types.this.Type with ScalaObject" id="40085">SubType</a> <a href="#40085" title="ScalaObject" class="keyword">extends</a> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="66840">supertype</a>: <a href="#40083" title="Types.this.Type">Type</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="66841">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#66840" title="=&gt; Types.this.Type">supertype</a>.<a href="#42737" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="66842">decls</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a> = <a href="#66840" title="=&gt; Types.this.Type">supertype</a>.<a href="#42760" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="66843">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="130587">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#66840" title="=&gt; Types.this.Type">supertype</a>.<a href="#42777" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#130587" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="66844">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#40512" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#66840" title="=&gt; Types.this.Type">supertype</a>.<a href="#42803" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="66845">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#66840" title="=&gt; Types.this.Type">supertype</a>.<a href="#42804" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="66846">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#66840" title="=&gt; Types.this.Type">supertype</a>.<a href="#42805" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="66847">isNotNull</a> = <a href="#66840" title="=&gt; Types.this.Type">supertype</a>.<a href="#42717" title="=&gt; Boolean">isNotNull</a>
  <span class="delimiter">}</span>

  case <span class="keyword">class</span> <a title="class NotNullType extends Types.this.SubType with Types.this.RewrappingTypeProxy with ScalaObject with Product with Serializable" id="146963">NotNullType</a><a href="#146963" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="84452">underlying</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40085" title="Types.this.SubType">SubType</a> <span class="keyword">with</span> <a href="#40079" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="84423">supertype</a> = <a href="#84452" title="=&gt; Types.this.Type">underlying</a>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="84424">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="130607">newtp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#146963" title="(underlying: Types.this.Type)Types.this.NotNullType">NotNullType</a><span class="delimiter">(</span><a href="#130607" title="Types.this.Type">newtp</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="84425">isNotNull</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.NotNullType" id="84426">notNull</a> = <a href="#146963" title="Types.this.NotNullType" class="keyword">this</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="84427">deconst</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#84452" title="=&gt; Types.this.Type">underlying</a> //todo: needed?
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84428">safeToString</a>: <span title="String">String</span> = <a href="#84452" title="=&gt; Types.this.Type">underlying</a>.<a href="#42813" title="()String">toString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; with NotNull&quot;)" class="string">&quot; with NotNull&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84429">kind</a> = <span title="String(&quot;NotNullType&quot;)" class="string">&quot;NotNullType&quot;</span>
  <span class="delimiter">}</span>

  /** A base class for types that represent a single value
   *  (single-types and this-types).
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SingletonType extends Types.this.SubType with Types.this.SimpleTypeProxy with Types.this.AbsSingletonType with ScalaObject" id="40089">SingletonType</a> <a href="#40089" title="ScalaObject" class="keyword">extends</a> <a href="#40085" title="Types.this.SubType">SubType</a> <span class="keyword">with</span> <a href="#40078" title="Types.this.SimpleTypeProxy">SimpleTypeProxy</a> <span class="keyword">with</span> <span title="Types.this.AbsSingletonType">AbsSingletonType</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83397">supertype</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83398">isTrivial</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83399">isStable</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83400">isVolatile</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42716" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83401">widen</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42732" title="=&gt; Types.this.Type">widen</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="83402">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#40512" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      <a href="util/StatBase.scala.html#39915" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39933" title="=&gt; scala.reflect.internal.util.Statistics.Counter">singletonBaseTypeSeqCount</a><span class="delimiter">)</span>
      <a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42803" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#60851" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">prepend</a> <a href="#40089" title="Types.this.SingletonType" class="keyword">this</a>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83403">isHigherKinded</a> = <span title="Boolean(false)" class="keyword">false</span> // singleton type classifies objects, thus must be kind *
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83404">safeToString</a>: <span title="String">String</span> = <a href="#42812" title="=&gt; String">prefixString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;type&quot;)" class="string">&quot;type&quot;</span>
/*
    override def typeOfThis: Type = typeSymbol.typeOfThis
    override def bounds: TypeBounds = TypeBounds(this, this)
    override def prefix: Type = NoType
    override def typeArgs: List[Type] = List()
    override def typeParams: List[Symbol] = List()
*/
  <span class="delimiter">}</span>

  /** An object representing an erroneous type */
  case <span class="keyword">object</span> <a href="#130712" title="object Types.this.ErrorType" id="130719">ErrorType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    // todo see whether we can do without
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="84532">isError</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="84533">decls</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a> = <span title="Types.this.ErrorScope" class="keyword">new</span> <a href="Scopes.scala.html#40432" title="Types.this.ErrorScope">ErrorScope</a><span class="delimiter">(</span><a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol" id="84534">findMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="130679">name</a>: <a href="Names.scala.html#39679" title="Types.this.Name">Name</a>, <a title="Long" id="130680">excludedFlags</a>: <span title="Long">Long</span>, <a title="Long" id="130681">requiredFlags</a>: <span title="Long">Long</span>, <a title="Boolean" id="130682">stableOnly</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="130684">sym</a> = <a href="#84533" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#61759" title="(name: Types.this.Name)Types.this.Symbol">lookup</a> <a href="#130679" title="Types.this.Name">name</a>
      <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#130684" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#130684" title="Types.this.Symbol">sym</a> = <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a>.<a href="Symbols.scala.html#47743" title="(name: Types.this.Name)Types.this.Symbol">newErrorSymbol</a><span class="delimiter">(</span><a href="#130679" title="Types.this.Name">name</a><span class="delimiter">)</span>
        <a href="#84533" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#61752" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#130684" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span>
      <a href="#130684" title="Types.this.Symbol">sym</a>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="84535">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="130699">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="keyword">this</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84536">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;&lt;error&gt;&quot;)" class="string">&quot;&lt;error&gt;&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="84537">narrow</a>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="keyword">this</span>
    // override def isNullable: Boolean = true
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84538">kind</a> = <span title="String(&quot;ErrorType&quot;)" class="string">&quot;ErrorType&quot;</span>
  <span class="delimiter">}</span>

  /** An object representing an unknown type, used during type inference.
   *  If you see WildcardType outside of inference it is almost certainly a bug.
   */
  case <span class="keyword">object</span> <a href="#130732" title="object Types.this.WildcardType" id="130739">WildcardType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="84540">isWildcard</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84541">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span>
    // override def isNullable: Boolean = true
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84542">kind</a> = <span title="String(&quot;WildcardType&quot;)" class="string">&quot;WildcardType&quot;</span>
  <span class="delimiter">}</span>
  /** BoundedWildcardTypes, used only during type inference, are created in
   *  two places that I can find:
   *
   *    1. If the expected type of an expression is an existential type,
   *       its hidden symbols are replaced with bounded wildcards.
   *    2. When an implicit conversion is being sought based in part on
   *       the name of a method in the converted type, a HasMethodMatching
   *       type is created: a MethodType with parameters typed as
   *       BoundedWildcardTypes.
   */
  case <span class="keyword">class</span> <a title="class BoundedWildcardType extends Types.this.Type with ScalaObject with Product with Serializable" id="146959">BoundedWildcardType</a><a href="#146959" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.TypeBounds" id="83727">bounds</a>: <a href="#66864" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83702">isWildcard</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83703">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#83727" title="=&gt; Types.this.TypeBounds">bounds</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83704">kind</a> = <span title="String(&quot;BoundedWildcardType&quot;)" class="string">&quot;BoundedWildcardType&quot;</span>
  <span class="delimiter">}</span>

  /** An object representing a non-existing type */
  case <span class="keyword">object</span> <a href="#130787" title="object Types.this.NoType" id="130794">NoType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="60791">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="60792">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;&lt;notype&gt;&quot;)" class="string">&quot;&lt;notype&gt;&quot;</span>
    // override def isNullable: Boolean = true
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="60793">kind</a> = <span title="String(&quot;NoType&quot;)" class="string">&quot;NoType&quot;</span>
  <span class="delimiter">}</span>

  /** An object representing a non-existing prefix */
  case <span class="keyword">object</span> <a href="#130811" title="object Types.this.NoPrefix" id="130818">NoPrefix</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="73854">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="73855">isStable</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="73856">prefixString</a> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="73857">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;&lt;noprefix&gt;&quot;)" class="string">&quot;&lt;noprefix&gt;&quot;</span>
    // override def isNullable: Boolean = true
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="73858">kind</a> = <span title="String(&quot;NoPrefixType&quot;)" class="string">&quot;NoPrefixType&quot;</span>
  <span class="delimiter">}</span>

  /** A class for this-types of the form &lt;sym&gt;.this.type
   */
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#130859" title="class ThisType extends Types.this.SingletonType with ScalaObject with Product with Serializable" id="83420">ThisType</a><a href="#83420" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="83428">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40089" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#83428" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47757" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span>
    //assert(sym.isClass &amp;&amp; !sym.isModuleClass || sym.isRoot, sym)
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83409">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#83428" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83410">isNotNull</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="83411">typeSymbol</a> = <a href="#83428" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83412">underlying</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#83428" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47979" title="=&gt; Types.this.Type">typeOfThis</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83413">isVolatile</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83414">isHigherKinded</a> = <a href="#83428" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47779" title="=&gt; Boolean">isRefinementClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#83412" title="=&gt; Types.this.Type">underlying</a>.<a href="#42714" title="=&gt; Boolean">isHigherKinded</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83415">prefixString</a> =
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75538" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#83428" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#48044" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.this.&quot;)" class="string">&quot;.this.&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#83428" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47817" title="=&gt; Boolean">isAnonOrRefinementClass</a><span class="delimiter">)</span> <span title="String(&quot;this.&quot;)" class="string">&quot;this.&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#83428" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47828" title="=&gt; Boolean">isOmittablePrefix</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#83428" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47775" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <a href="#83428" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47897" title="=&gt; String">fullName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      <span class="keyword">else</span> <a href="#83428" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#48044" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.this.&quot;)" class="string">&quot;.this.&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83416">safeToString</a>: <span title="String">String</span> =
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#83428" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47788" title="=&gt; Boolean">isRoot</a><span class="delimiter">)</span> <span title="String(&quot;&lt;root&gt;&quot;)" class="string">&quot;&lt;root&gt;&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#83428" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47785" title="=&gt; Boolean">isEmptyPackageClass</a><span class="delimiter">)</span> <span title="String(&quot;&lt;empty&gt;&quot;)" class="string">&quot;&lt;empty&gt;&quot;</span>
      <span class="keyword">else</span> <a href="#83420" title="Types.this.ThisType" class="keyword">super</a>.<a href="#83404" title="=&gt; String">safeToString</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83417">narrow</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#83420" title="Types.this.ThisType" class="keyword">this</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83418">kind</a> = <span title="String(&quot;ThisType&quot;)" class="string">&quot;ThisType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueThisType extends Types.this.ThisType with Types.this.UniqueType with ScalaObject" id="40104">UniqueThisType</a><a href="#40104" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="130881">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#83420" title="Types.this.ThisType">ThisType</a><span class="delimiter">(</span><a href="#130881" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#40084" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.ThisType" id="130889">ThisType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#8614" title="Types.this.ThisTypeExtractor">ThisTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="83395">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="83431">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#40229" title="(tp: Types.this.UniqueThisType)Types.this.UniqueThisType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueThisType" class="keyword">new</span> <a href="#40104" title="Types.this.UniqueThisType">UniqueThisType</a><span class="delimiter">(</span><a href="#83431" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83431" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47771" title="=&gt; Boolean">isImplClass</a><span class="delimiter">)</span> <a href="#83431" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47979" title="=&gt; Types.this.Type">typeOfThis</a>
      <span class="keyword">else</span> <a href="#83431" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A class for singleton types of the form `&lt;prefix&gt;.&lt;sym.name&gt;.type`.
   *  Cannot be created directly; one should always use `singleType` for creation.
   */
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#130931" title="class SingleType extends Types.this.SingletonType with ScalaObject with Product with Serializable" id="83463">SingleType</a><a href="#83463" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="83477">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="83478">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40089" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="83445">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#83477" title="=&gt; Types.this.Type">pre</a>.<a href="#42713" title="=&gt; Boolean">isTrivial</a>
    // override def isNullable = underlying.isNullable
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83447">isNotNull</a> = <a href="#83454" title="=&gt; Types.this.Type">underlying</a>.<a href="#42717" title="=&gt; Boolean">isNotNull</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="83449">underlyingCache</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#130794" title="object Types.this.NoType">NoType</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="83452">underlyingPeriod</a> = <span title="Int(0)">NoPeriod</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83454">underlying</a>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="130900">period</a> = <a href="#83452" title="=&gt; Int">underlyingPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130900" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#36969" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#83452" title="(x$1: Int)Unit">underlyingPeriod</a> = <a href="SymbolTable.scala.html#36969" title="=&gt; Types.this.Period">currentPeriod</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#36981" title="(period: Types.this.Period)Boolean">isValid</a><span class="delimiter">(</span><a href="#130900" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#83449" title="(x$1: Types.this.Type)Unit">underlyingCache</a> = <a href="#83477" title="=&gt; Types.this.Type">pre</a>.<a href="#42780" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#83478" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#42743" title="=&gt; Types.this.Type">resultType</a>;
          <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#83449" title="=&gt; Types.this.Type">underlyingCache</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#83463" title="Types.this.SingleType" class="keyword">this</a>, <a href="#83463" title="Types.this.SingleType" class="keyword">this</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#83449" title="=&gt; Types.this.Type">underlyingCache</a>
    <span class="delimiter">}</span>

    // more precise conceptually, but causes cyclic errors:    (paramss exists (_ contains sym))
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83455">isImmediatelyDependent</a> = <span class="delimiter">(</span><a href="#83478" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#83478" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#47773" title="=&gt; Boolean">isMethod</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#83478" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47799" title="=&gt; Boolean">isValueParameter</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83456">isVolatile</a> : <span title="Boolean">Boolean</span> = <a href="#83454" title="=&gt; Types.this.Type">underlying</a>.<a href="#42716" title="=&gt; Boolean">isVolatile</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#83478" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47846" title="=&gt; Boolean">isStable</a>
/*
    override def narrow: Type = {
      if (phase.erasedTypes) this
      else {
        val thissym = refinedType(List(this), sym.owner, EmptyScope).typeSymbol
        if (sym.owner != NoSymbol) {
          //Console.println(&quot;narrowing module &quot; + sym + thissym.owner);
          thissym.typeOfThis = this
        }
        thissym.thisType
      }
    }
*/
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83457">narrow</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#83463" title="Types.this.SingleType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="83458">termSymbol</a> = <a href="#83478" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83459">prefix</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#83477" title="=&gt; Types.this.Type">pre</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83460">prefixString</a> = <span class="delimiter">(</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#83478" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47826" title="=&gt; Types.this.Symbol">skipPackageObject</a>.<a href="Symbols.scala.html#47828" title="=&gt; Boolean">isOmittablePrefix</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#83478" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47818" title="=&gt; Boolean">isPackageObjectOrClass</a><span class="delimiter">)</span> <a href="#83477" title="=&gt; Types.this.Type">pre</a>.<a href="#42812" title="=&gt; String">prefixString</a>
      <span class="keyword">else</span> <a href="#83477" title="=&gt; Types.this.Type">pre</a>.<a href="#42812" title="=&gt; String">prefixString</a> <span title="(x$1: Any)String">+</span> <a href="#83478" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#48044" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
    <span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83461">kind</a> = <span title="String(&quot;SingleType&quot;)" class="string">&quot;SingleType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueSingleType extends Types.this.SingleType with Types.this.UniqueType with ScalaObject" id="40108">UniqueSingleType</a><a href="#40108" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="130962">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="130963">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#83463" title="Types.this.SingleType">SingleType</a><span class="delimiter">(</span><a href="#130962" title="Types.this.Type">pre</a>, <a href="#130963" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#40084" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.SingleType" id="130968">SingleType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#8614" title="Types.this.SingleTypeExtractor">SingleTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="83437">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="83483">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="83484">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#40229" title="(tp: Types.this.UniqueSingleType)Types.this.UniqueSingleType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueSingleType" class="keyword">new</span> <a href="#40108" title="Types.this.UniqueSingleType">UniqueSingleType</a><span class="delimiter">(</span><a href="#83483" title="Types.this.Type">pre</a>, <a href="#83484" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#130994" title="class SuperType extends Types.this.SingletonType with ScalaObject with Product with Serializable" id="83653">SuperType</a><a href="#83653" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="83667">thistpe</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="83668">supertpe</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40089" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="83643">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#83667" title="=&gt; Types.this.Type">thistpe</a>.<a href="#42713" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#83668" title="=&gt; Types.this.Type">supertpe</a>.<a href="#42713" title="=&gt; Boolean">isTrivial</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83645">isNotNull</a> = <span title="Boolean(true)" class="keyword">true</span>;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="83646">typeSymbol</a> = <a href="#83667" title="=&gt; Types.this.Type">thistpe</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83647">underlying</a> = <a href="#83668" title="=&gt; Types.this.Type">supertpe</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83648">prefix</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#83668" title="=&gt; Types.this.Type">supertpe</a>.<a href="#42738" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83649">prefixString</a> = <a href="#83667" title="=&gt; Types.this.Type">thistpe</a>.<a href="#42812" title="=&gt; String">prefixString</a>.<span title="(x$1: String, x$2: String)String">replaceAll</span><span class="delimiter">(</span><span title="String(&quot;\\bthis\\.$&quot;)" class="string">&quot;&quot;&quot;\bthis\.$&quot;&quot;&quot;</span>, <span title="String(&quot;super.&quot;)" class="string">&quot;super.&quot;</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83650">narrow</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#83667" title="=&gt; Types.this.Type">thistpe</a>.<a href="#42735" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83651">kind</a> = <span title="String(&quot;SuperType&quot;)" class="string">&quot;SuperType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueSuperType extends Types.this.SuperType with Types.this.UniqueType with ScalaObject" id="40112">UniqueSuperType</a><a href="#40112" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="131025">thistp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="131026">supertp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#83653" title="Types.this.SuperType">SuperType</a><span class="delimiter">(</span><a href="#131025" title="Types.this.Type">thistp</a>, <a href="#131026" title="Types.this.Type">supertp</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#40084" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.SuperType" id="131031">SuperType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#8614" title="Types.this.SuperTypeExtractor">SuperTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(thistp: Types.this.Type, supertp: Types.this.Type)Types.this.Type" id="83635">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="83673">thistp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="83674">supertp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#83674" title="Types.this.Type">supertp</a>
      <span class="keyword">else</span> <a href="#40229" title="(tp: Types.this.UniqueSuperType)Types.this.UniqueSuperType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueSuperType" class="keyword">new</span> <a href="#40112" title="Types.this.UniqueSuperType">UniqueSuperType</a><span class="delimiter">(</span><a href="#83673" title="Types.this.Type">thistp</a>, <a href="#83674" title="Types.this.Type">supertp</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A class for the bounds of abstract types and type parameters
   */
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#131058" title="class TypeBounds extends Types.this.SubType with ScalaObject with Product with Serializable" id="66864">TypeBounds</a><a href="#66864" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="66878">lo</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="66879">hi</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40085" title="Types.this.SubType">SubType</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="66855">supertype</a> = <a href="#66879" title="=&gt; Types.this.Type">hi</a>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="66856">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#66878" title="=&gt; Types.this.Type">lo</a>.<a href="#42713" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#66879" title="=&gt; Types.this.Type">hi</a>.<a href="#42713" title="=&gt; Boolean">isTrivial</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="66858">bounds</a>: <a href="#66864" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#66864" title="Types.this.TypeBounds" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="66859">containsType</a><span class="delimiter">(</span><a title="Types.this.Type" id="131040">that</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#131040" title="Types.this.Type">that</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">TypeBounds</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#131040" title="Types.this.Type">that</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#66864" title="Types.this.TypeBounds" class="keyword">this</a>
      <span class="keyword">case</span> <span title="Boolean">_</span>                =&gt; <a href="#66878" title="=&gt; Types.this.Type">lo</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#131040" title="Types.this.Type">that</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#131040" title="Types.this.Type">that</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#66879" title="=&gt; Types.this.Type">hi</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="66860">isEmptyBounds</a> = <span class="delimiter">(</span><a href="#66878" title="=&gt; Types.this.Type">lo</a>.<a href="#42730" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#66879" title="=&gt; Types.this.Type">hi</a>.<a href="#42730" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span>
    // override def isNullable: Boolean = NullClass.tpe &lt;:&lt; lo;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="66861">safeToString</a> = <span title="String(&quot;&gt;: &quot;)" class="string">&quot;&gt;: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#66878" title="=&gt; Types.this.Type">lo</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; &lt;: &quot;)" class="string">&quot; &lt;: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#66879" title="=&gt; Types.this.Type">hi</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="66862">kind</a> = <span title="String(&quot;TypeBoundsType&quot;)" class="string">&quot;TypeBoundsType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueTypeBounds extends Types.this.TypeBounds with Types.this.UniqueType with ScalaObject" id="40116">UniqueTypeBounds</a><a href="#40116" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="131089">lo</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="131090">hi</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#66864" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#131089" title="Types.this.Type">lo</a>, <a href="#131090" title="Types.this.Type">hi</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#40084" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.TypeBounds" id="131099">TypeBounds</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#8614" title="Types.this.TypeBoundsExtractor">TypeBoundsExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="66835">empty</a>: <a href="#66864" title="Types.this.TypeBounds">TypeBounds</a>           = <a href="#66838" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a>.<a href="Symbols.scala.html#70289" title="=&gt; Types.this.Type">tpe</a>, <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(hi: Types.this.Type)Types.this.TypeBounds" id="66836">upper</a><span class="delimiter">(</span><a title="Types.this.Type" id="116426">hi</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#66864" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#66838" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a>.<a href="Symbols.scala.html#70289" title="=&gt; Types.this.Type">tpe</a>, <a href="#116426" title="Types.this.Type">hi</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(lo: Types.this.Type)Types.this.TypeBounds" id="66837">lower</a><span class="delimiter">(</span><a title="Types.this.Type" id="131094">lo</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#66864" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#66838" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="#131094" title="Types.this.Type">lo</a>, <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds" id="66838">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="83686">lo</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="83687">hi</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#66864" title="Types.this.TypeBounds">TypeBounds</a> = <span class="delimiter">{</span>
      <a href="#40229" title="(tp: Types.this.UniqueTypeBounds)Types.this.UniqueTypeBounds">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueTypeBounds" class="keyword">new</span> <a href="#40116" title="Types.this.UniqueTypeBounds">UniqueTypeBounds</a><span class="delimiter">(</span><a href="#83686" title="Types.this.Type">lo</a>, <a href="#83687" title="Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.TypeBounds" class="delimiter">[</span><a href="#66864" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">]</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A common base class for intersection types and class types
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class CompoundType extends Types.this.Type with ScalaObject" id="40117">CompoundType</a> <a href="#40117" title="ScalaObject" class="keyword">extends</a> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>

    <span class="keyword">var</span> <a title="Types.this.BaseTypeSeq" id="61663">baseTypeSeqCache</a>: <a href="BaseTypeSeqs.scala.html#40512" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="61666">baseTypeSeqPeriod</a> = <span title="Int(0)">NoPeriod</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="61669">baseClassesCache</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="61672">baseClassesPeriod</a> = <span title="Int(0)">NoPeriod</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="61674">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#40512" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="131107">period</a> = <a href="#61666" title="=&gt; Int">baseTypeSeqPeriod</a>;
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#131107" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#36969" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span> // no caching in IDE
        <a href="#61666" title="(x$1: Int)Unit">baseTypeSeqPeriod</a> = <a href="SymbolTable.scala.html#36969" title="=&gt; Types.this.Period">currentPeriod</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#36982" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#131107" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#42737" title="=&gt; List[Types.this.Type]">parents</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#131121" title="Types.this.Type">_</a>.<a href="#42792" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#131124" title="Types.this.Type">_</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#40176" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            // rename type vars to fresh type params, take base type sequence of
            // resulting type, and rename back all the entries in that sequence
            <span class="keyword">var</span> <a title="scala.collection.immutable.Set[Types.this.TypeVar]" id="131125">tvs</a> = <span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.TypeVar*)scala.collection.immutable.Set[Types.this.TypeVar]" class="delimiter">[</span><a href="#40176" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
            <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="131153">p</a> &lt;- <a href="#42737" title="(f: Types.this.Type =&gt; Unit)Unit">parents</a><span class="delimiter">)</span>
              <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="131156">t</a> &lt;- <a href="#42790" title="(f: Types.this.Type =&gt; Unit)Unit">p</a><span class="delimiter">)</span> <a href="#131156" title="Types.this.Type">t</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <a title="Unit" id="131157">tv</a>: <a href="#40176" title="Types.this.TypeVar">TypeVar</a> =&gt; <a href="#131125" title="scala.collection.immutable.Set[Types.this.TypeVar]">tvs</a> <span title="(elem: Types.this.TypeVar)scala.collection.immutable.Set[Types.this.TypeVar]">+=</span> <a href="#131157" title="Types.this.TypeVar">tv</a>
                <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
              <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="Map[Types.this.Type,Types.this.Symbol]" id="131126">varToParamMap</a>: <span title="Map[Types.this.Type,Types.this.Symbol]">Map</span><span class="delimiter">[</span>Type, Symbol<span class="delimiter">]</span> = <a href="#131125" title="scala.collection.immutable.Set[Types.this.TypeVar]">tvs</a> <span title="(f: Types.this.TypeVar =&gt; (Types.this.TypeVar, Types.this.Symbol))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[Types.this.TypeVar],(Types.this.TypeVar, Types.this.Symbol),scala.collection.immutable.Set[(Types.this.TypeVar, Types.this.Symbol)]])scala.collection.immutable.Set[(Types.this.TypeVar, Types.this.Symbol)]">map</span> <span class="delimiter">(</span><a title="Types.this.TypeVar" id="131207">tv</a> =&gt; <a href="#131207" title="(x: Types.this.TypeVar)ArrowAssoc[Types.this.TypeVar]">tv</a> <span title="(y: Types.this.Symbol)(Types.this.TypeVar, Types.this.Symbol)">-&gt;</span> <a href="#131207" title="Types.this.TypeVar">tv</a>.<a href="#135385" title="=&gt; Types.this.Type">origin</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47970" title="=&gt; Types.this.Symbol">cloneSymbol</a><span class="delimiter">)</span> <span title="(implicit ev: &lt;:&lt;[(Types.this.TypeVar, Types.this.Symbol),(Types.this.Type, Types.this.Symbol)])scala.collection.immutable.Map[Types.this.Type,Types.this.Symbol]">toMap</span>
            <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]" id="131127">paramToVarMap</a> = <a href="#131126" title="Map[Types.this.Type,Types.this.Symbol]">varToParamMap</a> <span title="(f: ((Types.this.Type, Types.this.Symbol)) =&gt; (Types.this.Symbol, Types.this.Type))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[Types.this.Type,Types.this.Symbol],(Types.this.Symbol, Types.this.Type),scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]])scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#131303" title="(Types.this.Type, Types.this.Symbol)">_</a>.<span title="=&gt; (Types.this.Symbol, Types.this.Type)">swap</span><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.TypeMap" id="131128">varToParam</a> = <a href="#131338" title="Types.this.TypeMap" class="keyword">new</a> <a href="#40242" title="anonymous class $anon extends Types.this.TypeMap" id="131338">TypeMap</a> <span class="delimiter">{</span>
              <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="131340">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="131341">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#131126" title="Map[Types.this.Type,Types.this.Symbol]">varToParamMap</a> <span title="(key: Types.this.Type)Option[Types.this.Symbol]">get</span> <a href="#131341" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Types.this.Type">Some</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="131349">sym</a><span class="delimiter">)</span> =&gt; <a href="#131349" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>
                <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#131341" title="Types.this.Type">tp</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="Types.this.TypeMap" id="131129">paramToVar</a> = <a href="#131368" title="Types.this.TypeMap" class="keyword">new</a> <a href="#40242" title="anonymous class $anon extends Types.this.TypeMap" id="131368">TypeMap</a> <span class="delimiter">{</span>
              <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="131370">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="131371">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#131371" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="131376">tsym</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#131127" title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]">paramToVarMap</a>.<span title="(key: Types.this.Symbol)Boolean">isDefinedAt</span><span class="delimiter">(</span><a href="#131376" title="Types.this.Symbol">tsym</a><span class="delimiter">)</span> =&gt; <a href="#131127" title="(key: Types.this.Symbol)Types.this.Type">paramToVarMap</a><span class="delimiter">(</span><a href="#131376" title="Types.this.Symbol">tsym</a><span class="delimiter">)</span>
                <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#131371" title="Types.this.Type">tp</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="131130">bts</a> = <a href="#40197" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#40117" title="CompoundType.this.type" class="keyword">this</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.RefinedType" class="delimiter">[</span><a href="#61660" title="Types.this.RefinedType">RefinedType</a><span class="delimiter">]</span>, <a href="#42737" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#131128" title="Types.this.TypeMap">varToParam</a>, <a href="#131128" title="Types.this.TypeMap">varToParam</a> <a href="#82356" title="(scope: Types.this.Scope)Types.this.Scope">mapOver</a> <a href="#42760" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span>.<a href="#42803" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
            <a href="#61663" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="#131130" title="Types.this.BaseTypeSeq">bts</a> <a href="BaseTypeSeqs.scala.html#60854" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">lateMap</a> <a href="#131129" title="Types.this.TypeMap">paramToVar</a>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <a href="util/StatBase.scala.html#39915" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39935" title="=&gt; scala.reflect.internal.util.Statistics.Counter">compoundBaseTypeSeqCount</a><span class="delimiter">)</span>
            <a href="#61663" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="BaseTypeSeqs.scala.html#40513" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a>
            <a href="#61663" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <span title="Types.this.BaseTypeSeq" class="keyword">if</span> <span class="delimiter">(</span><a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47779" title="=&gt; Boolean">isRefinementClass</a><span class="delimiter">)</span>
              <a href="#61677" title="(op1: =&gt; Types.this.BaseTypeSeq)(op2: Types.this.Type =&gt; Types.this.BaseTypeSeq)Types.this.BaseTypeSeq">memo</a><span class="delimiter">(</span><a href="BaseTypeSeqs.scala.html#40516" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">compoundBaseTypeSeq</a><span class="delimiter">(</span><a href="#40117" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#131565" title="Types.this.Type">_</a>.<a href="#42803" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#60852" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">updateHead</a> <a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
            <span class="keyword">else</span>
              <a href="BaseTypeSeqs.scala.html#40516" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">compoundBaseTypeSeq</a><span class="delimiter">(</span><a href="#40117" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span>
            // [Martin] suppressing memo-ization solves the problem with &quot;same type after erasure&quot; errors
            // when compiling with
            // scalac scala.collection.IterableViewLike.scala scala.collection.IterableLike.scala
            // I have not yet figured out precisely why this is the case.
            // My current assumption is that taking memos forces baseTypeSeqs to be computed
            // at stale types (i.e. the underlying typeSymbol has already another type).
            // I do not yet see precisely why this would cause a problem, but it looks
            // fishy in any case.
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        //Console.println(&quot;baseTypeSeq(&quot; + typeSymbol + &quot;) = &quot; + baseTypeSeqCache.toList);//DEBUG
      <span class="delimiter">}</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#61663" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="BaseTypeSeqs.scala.html#40513" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">throw</span> <a href="#67275" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#40384" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic inheritance involving &quot;)" class="string">&quot;illegal cyclic inheritance involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
      <a href="#61663" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="61675">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#61674" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#60856" title="=&gt; Int">maxDepth</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="61676">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="131574">computeBaseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
        <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#42737" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</span><span class="delimiter">(</span><a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          //Console.println(&quot;computing base classes of &quot; + typeSymbol + &quot; at phase &quot; + phase);//DEBUG
          // optimized, since this seems to be performance critical
          <span class="keyword">val</span> <a title="Types.this.Type" id="131584">superclazz</a> = <a href="#42737" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Types.this.Type">head</span>
          <span class="keyword">var</span> <a title="List[Types.this.Type]" id="131585">mixins</a> = <a href="#42737" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; List[Types.this.Type]">tail</span>
          <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="131586">sbcs</a> = <a href="#131584" title="Types.this.Type">superclazz</a>.<a href="#42805" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
          <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="131587">bcs</a> = <a href="#131586" title="List[Types.this.Symbol]">sbcs</a>
          <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Boolean" id="131588">isNew</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="131592">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span>
            <a href="#131584" title="Types.this.Type">superclazz</a>.<a href="#42806" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#131592" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <span class="delimiter">{</span> <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="131597">p</a> = <a href="#131587" title="List[Types.this.Symbol]">bcs</a>;
              <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#131597" title="List[Types.this.Symbol]">p</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#131586" title="List[Types.this.Symbol]">sbcs</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#131597" title="List[Types.this.Symbol]">p</a>.<span title="=&gt; Types.this.Symbol">head</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#131592" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#131597" title="List[Types.this.Symbol]">p</a> = <a href="#131597" title="List[Types.this.Symbol]">p</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>;
              <a href="#131597" title="List[Types.this.Symbol]">p</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131586" title="List[Types.this.Symbol]">sbcs</a>
            <span class="delimiter">}</span>
          <span class="delimiter">)</span>;
          <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#131585" title="List[Types.this.Type]">mixins</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#131589" title="()Unit" class="delimiter">{</a>
            <span class="keyword">def</span> <a title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]" id="131607">addMixinBaseClasses</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="131608">mbcs</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
              <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#131608" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#131587" title="List[Types.this.Symbol]">bcs</a>
              <span class="keyword">else</span> <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#131588" title="(clazz: Types.this.Symbol)Boolean">isNew</a><span class="delimiter">(</span><a href="#131608" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; Types.this.Symbol">head</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#131608" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; Types.this.Symbol">head</span> <a href="#131609" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#131607" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#131608" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <a href="#131607" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#131608" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span><span class="delimiter">)</span>;
            <a href="#131587" title="List[Types.this.Symbol]">bcs</a> = <a href="#131607" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#131585" title="List[Types.this.Type]">mixins</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#42805" title="=&gt; List[Types.this.Symbol]">baseClasses</a><span class="delimiter">)</span>
            <a href="#131585" title="List[Types.this.Type]">mixins</a> = <a href="#131585" title="List[Types.this.Type]">mixins</a>.<span title="=&gt; List[Types.this.Type]">tail</span>
          <span class="delimiter">}</span>
          <a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="#131616" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#131587" title="List[Types.this.Symbol]">bcs</a>
         <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="Int" id="131575">period</a> = <a href="#61672" title="=&gt; Int">baseClassesPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#131575" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#36969" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#61672" title="(x$1: Int)Unit">baseClassesPeriod</a> = <a href="SymbolTable.scala.html#36969" title="=&gt; Types.this.Period">currentPeriod</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#36982" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#131575" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#61669" title="(x$1: List[Types.this.Symbol])Unit">baseClassesCache</a> = <span title="Null(null)" class="keyword">null</span>
          <a href="#61669" title="(x$1: List[Types.this.Symbol])Unit">baseClassesCache</a> = <a href="#61677" title="(op1: =&gt; List[Types.this.Symbol])(op2: Types.this.Type =&gt; List[Types.this.Symbol])List[Types.this.Symbol]">memo</a><span class="delimiter">(</span><a href="#131574" title="=&gt; List[Types.this.Symbol]">computeBaseClasses</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="#131633" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#131632" title="Types.this.Type">_</a>.<a href="#42805" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#61669" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">throw</span> <a href="#67275" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#40384" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic reference involving &quot;)" class="string">&quot;illegal cyclic reference involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
      <a href="#61669" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a>
    <span class="delimiter">}</span>

    /** The slightly less idiomatic use of Options is due to
     *  performance considerations. A version using for comprehensions
     *  might be too slow (this is deemed a hotspot of the type checker).
     *
     *  See with Martin before changing this method.
     */
    <span class="keyword">def</span> <a title="[A](op1: =&gt; A)(op2: Types.this.Type =&gt; A)A" id="61677">memo</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="61679">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="131551">op1</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; A" id="131552">op2</a>: Type =&gt; A<span class="delimiter">)</span>: <a href="#61679" title="A">A</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="()A" id="131642">updateCache</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#61679" title="A">A</a> = <span class="delimiter">{</span>
        <a href="#40076" title="(k: List[Types.this.Type], v: scala.ref.WeakReference[Types.this.Type])Unit">intersectionWitness</a><span class="delimiter">(</span><a href="#42737" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> = <span title="(value: Types.this.CompoundType)scala.ref.WeakReference[Types.this.CompoundType]" class="keyword">new</span> <span title="scala.ref.WeakReference[Types.this.CompoundType]">WeakReference</span><span class="delimiter">(</span><a href="#40117" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#131551" title="=&gt; A">op1</a>
      <span class="delimiter">}</span>

      <a href="#40076" title="=&gt; scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]">intersectionWitness</a> <span title="(k: List[Types.this.Type])Option[scala.ref.WeakReference[Types.this.Type]]">get</span> <a href="#42737" title="=&gt; List[Types.this.Type]">parents</a> <span title="A" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="A">Some</span><span class="delimiter">(</span><a title="scala.ref.WeakReference[Types.this.Type]" id="131681">ref</a><span class="delimiter">)</span> =&gt;
          <a href="#131681" title="scala.ref.WeakReference[Types.this.Type]">ref</a>.<span title="=&gt; Option[Types.this.Type]">get</span> <span title="A" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="A">Some</span><span class="delimiter">(</span><a title="Types.this.Type" id="131683">w</a><span class="delimiter">)</span> =&gt; <span title="A" class="keyword">if</span> <span class="delimiter">(</span><a href="#131683" title="Types.this.Type">w</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#40117" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span> <a href="#131551" title="=&gt; A">op1</a> <span class="keyword">else</span> <a href="#131552" title="(v1: Types.this.Type)A">op2</a><span class="delimiter">(</span><a href="#131683" title="Types.this.Type">w</a><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="A">None</span> =&gt; <a href="#131642" title="()A">updateCache</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="keyword">case</span> <span title="A">None</span> =&gt; <a href="#131642" title="()A">updateCache</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="61680">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="131685">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="131688">index</a> = <a href="#42806" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#131685" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#131688" title="Int">index</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="BaseTypeSeqs.scala.html#60846" title="(i: Int)Types.this.Type">baseTypeSeq</a><span class="delimiter">(</span><a href="#131688" title="Int">index</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#130794" title="object Types.this.NoType">NoType</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="61681">narrow</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47980" title="=&gt; Types.this.Type">thisType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="61682">isNotNull</a>: <span title="Boolean">Boolean</span> = <a href="#42737" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#131706" title="Types.this.Type">_</a>.<a href="#42717" title="=&gt; Boolean">isNotNull</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="61683">isStructuralRefinement</a>: <span title="Boolean">Boolean</span> =
      <a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47817" title="=&gt; Boolean">isAnonOrRefinementClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#42760" title="=&gt; Types.this.Scope">decls</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#131716" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47868" title="=&gt; Boolean">isPossibleInRefinement</a><span class="delimiter">)</span>

    // override def isNullable: Boolean =
    // parents forall (p =&gt; p.isNullable &amp;&amp; !p.typeSymbol.isAbstractType);

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="61684">safeToString</a>: <span title="String">String</span> =
      <a href="#42737" title="=&gt; List[Types.this.Type]">parents</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot; with &quot;)" class="string">&quot; with &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span>
      <span class="delimiter">(</span><span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75538" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">||</span> <a href="#42737" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#42760" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61726" title="=&gt; Types.this.ScopeEntry">elems</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#42760" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61770" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;{&quot;)" class="string">&quot;{&quot;</span>, <span title="String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="String(&quot;}&quot;)" class="string">&quot;}&quot;</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** A class representing intersection types with refinements of the form
   *    `&lt;parents_0&gt; with ... with &lt;parents_n&gt; { decls }`
   *  Cannot be created directly;
   *  one should always use `refinedType` for creation.
   */
  case <span class="keyword">class</span> <a title="class RefinedType extends Types.this.CompoundType with ScalaObject with Product with Serializable" id="61660">RefinedType</a><a href="#61660" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Type]" id="83878">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>,
                         <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Scope" id="83879">decls</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40117" title="Types.this.CompoundType">CompoundType</a> <span class="delimiter">{</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="61692">isHigherKinded</a> = <span class="delimiter">(</span>
      <a href="#83878" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span class="delimiter">(</span><a href="#83878" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#131741" title="Types.this.Type">_</a>.<a href="#42714" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a>
    <span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="61693">typeParams</a> =
      <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#61692" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#83878" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#42752" title="=&gt; List[Types.this.Symbol]">typeParams</a>
      <span class="keyword">else</span> <a href="#61660" title="Types.this.RefinedType" class="keyword">super</a>.<a href="#42752" title="=&gt; List[Types.this.Symbol]">typeParams</a>

    //@M may result in an invalid type (references to higher-order args become dangling )
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="61694">typeConstructor</a> =
      <a href="#40197" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#61660" title="Types.this.RefinedType" class="keyword">this</a>, <a href="#83878" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#131765" title="Types.this.Type">_</a>.<a href="#42740" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>, <a href="#83879" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span>

    /* MO to AM: This is probably not correct
     * If they are several higher-kinded parents with different bounds we need
     * to take the intersection of their bounds
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="61695">normalize</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#61692" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#40207" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span>
          <a href="#61693" title="=&gt; List[Types.this.Symbol]">typeParams</a>,
          <a href="#61659" title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span>
            <a href="#83878" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#131820" title="Types.this.Type" class="delimiter">{</a>
              <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="131821">pre</a>, <a title="Types.this.Symbol" id="131822">sym</a>, <a href="#131824" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#66645" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#131821" title="Types.this.Type">pre</a>, <a href="#131822" title="Types.this.Symbol">sym</a>, <a href="#42742" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>
              <span class="keyword">case</span> <a title="Types.this.Type" id="131838">p</a> =&gt; <a href="#131838" title="Types.this.Type">p</a>
            <span class="delimiter">}</span>,
            <a href="#83879" title="=&gt; Types.this.Scope">decls</a>,
            <a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#61660" title="Types.this.RefinedType" class="keyword">super</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a>
    <span class="delimiter">}</span>

    /** A refined type P1 with ... with Pn { decls } is volatile if
     *  one of the parent types Pi is an abstract type, and
     *  either i &gt; 1, or decls or a following parent Pj, j &gt; 1, contributes
     *  an abstract member.
     *  A type contributes an abstract member if it has an abstract member which
     *  is also a member of the whole refined type. A scope `decls` contributes
     *  an abstract member if it has an abstract definition which is also
     *  a member of the whole type.
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="61696">isVolatile</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(m: Types.this.Symbol)Boolean" id="131870">isVisible</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="131872">m</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
        <a href="#61660" title="RefinedType.this.type" class="keyword">this</a>.<a href="#42770" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#131872" title="Types.this.Symbol">m</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#47967" title="=&gt; List[Types.this.Symbol]">alternatives</a> <span title="(elem: Any)Boolean">contains</span> <a href="#131872" title="Types.this.Symbol">m</a>
      <span class="keyword">def</span> <a title="(p: Types.this.Type)Boolean" id="131871">contributesAbstractMembers</a><span class="delimiter">(</span><a title="Types.this.Type" id="131874">p</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
        <a href="#131874" title="Types.this.Type">p</a>.<a href="#42768" title="=&gt; List[Types.this.Symbol]">deferredMembers</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <a href="#131870" title="(m: Types.this.Symbol)Boolean">isVisible</a>

      <span class="delimiter">(</span><span class="delimiter">(</span><a href="#83878" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#131890" title="Types.this.Type">_</a>.<a href="#42716" title="=&gt; Boolean">isVolatile</a><span class="delimiter">)</span><span class="delimiter">)</span>
       <span title="(x: Boolean)Boolean">||</span>
       <span class="delimiter">(</span><a href="#83878" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">dropWhile</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span> <a href="#131895" title="Types.this.Type">_</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47760" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
         <span class="keyword">case</span> <a title="Boolean" id="131897">ps</a> @ <span class="delimiter">(</span>_ :: <a title="List[Types.this.Type]" id="131902">ps1</a><span class="delimiter">)</span> =&gt;
           <span class="delimiter">(</span><a href="#131897" title="collection.immutable.::[Types.this.Type]">ps</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#83878" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
           <span class="delimiter">(</span><a href="#131902" title="List[Types.this.Type]">ps1</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <a href="#131871" title="(p: Types.this.Type)Boolean">contributesAbstractMembers</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
           <span class="delimiter">(</span><a href="#83879" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61765" title="=&gt; Iterator[Types.this.Symbol]">iterator</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="131916">m</a> =&gt; <a href="#131916" title="Types.this.Symbol">m</a>.<a href="HasFlags.scala.html#48097" title="=&gt; Boolean">isDeferred</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#131870" title="(m: Types.this.Symbol)Boolean">isVisible</a><span class="delimiter">(</span><a href="#131916" title="Types.this.Symbol">m</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
         <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
           <span title="Boolean(false)" class="keyword">false</span>
       <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="61697">kind</a> = <span title="String(&quot;RefinedType&quot;)" class="string">&quot;RefinedType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class RefinedType0 extends Types.this.RefinedType with ScalaObject" id="40121">RefinedType0</a><a href="#40121" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Type]" id="131969">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="131970">decls</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="131971">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#61660" title="Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#131969" title="List[Types.this.Type]">parents</a>, <a href="#131970" title="Types.this.Scope">decls</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="131964">typeSymbol</a> = <a href="#131971" title="Types.this.Symbol">clazz</a>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.RefinedType" id="131976">RefinedType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#8614" title="Types.this.RefinedTypeExtractor">RefinedTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType" id="61659">apply</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="83863">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="83864">decls</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="83865">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#61660" title="Types.this.RefinedType">RefinedType</a> =
      <span title="Types.this.RefinedType0" class="keyword">new</span> <a href="#40121" title="Types.this.RefinedType0">RefinedType0</a><span class="delimiter">(</span><a href="#83863" title="List[Types.this.Type]">parents</a>, <a href="#83864" title="Types.this.Scope">decls</a>, <a href="#83865" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Overridden in reflection compiler */
  <span class="keyword">def</span> <a title="(tp: Types.this.ClassInfoType)Unit" id="40122">validateClassInfo</a><span class="delimiter">(</span><a title="Types.this.ClassInfoType" id="131977">tp</a>: <a href="#71108" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>

  /** A class representing a class info
   */
  case <span class="keyword">class</span> <a title="class ClassInfoType extends Types.this.CompoundType with ScalaObject with Product with Serializable" id="71108">ClassInfoType</a><a href="#71108" title="ScalaObject" class="delimiter">(</a>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Type]" id="71148">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>,
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Scope" id="71149">decls</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a>,
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Symbol" id="71150">typeSymbol</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40117" title="Types.this.CompoundType">CompoundType</a>
  <span class="delimiter">{</span>
    <a href="#40122" title="(tp: Types.this.ClassInfoType)Unit">validateClassInfo</a><span class="delimiter">(</span><a href="#71108" title="Types.this.ClassInfoType" class="keyword">this</a><span class="delimiter">)</span>

    /** refs indices */
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(0)" id="71119">NonExpansive</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(1)" id="71121">Expansive</a> = <span title="Int(1)" class="int">1</span>

    /** initialization states */
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(0)" id="71123">UnInitialized</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(1)" id="71125">Initializing</a> = <span title="Int(1)" class="int">1</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(2)" id="71127">Initialized</a> = <span title="Int(2)" class="int">2</span>

    <span class="keyword">private</span> <span class="keyword">type</span> <a title="Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]" id="71129">RefMap</a> = <span title="Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">Map</span><span class="delimiter">[</span>Symbol, immutable.Set<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span>

    /** All type parameters reachable from given type parameter
     *  by a path which contains at least one expansive reference.
     *  @See Kennedy, Pierce: On Decidability of Nominal Subtyping with Variance
     */
    <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Set[Types.this.Symbol]" id="71130">expansiveRefs</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="131985">tparam</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#71135" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)">UnInitialized</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#71143" title="()Unit">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#71135" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(2)">Initialized</span><span class="delimiter">)</span> <a href="#71144" title="()Boolean">propagate</a><a href="#131994" title="()Unit" class="delimiter">(</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#71137" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#131985" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /* The rest of this class is auxiliary code for `expansiveRefs`
     */

    /** The type parameters which are referenced type parameters of this class.
     *  Two entries: refs(0): Non-expansive references
     *               refs(1): Expansive references
     */
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Array[ClassInfoType.this.RefMap]" id="71132">refs</a>: <span title="Array[ClassInfoType.this.RefMap]">Array</span><span class="delimiter">[</span>RefMap<span class="delimiter">]</span> = _

    /** The initialization state of the class: UnInialized --&gt; Initializing --&gt; Initialized
     */
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="71135">state</a> = <span title="Int(0)">UnInitialized</span>

    /** Get references for given type parameter
     *  @param  which in {NonExpansive, Expansive}
     *  @param  from  The type parameter from which references originate.
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]" id="71137">getRefs</a><span class="delimiter">(</span><a title="Int" id="132001">which</a>: <span title="Int">Int</span>, <a title="Types.this.Symbol" id="132002">from</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Set[Types.this.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#71132" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#132001" title="Int">which</a><span class="delimiter">)</span> <span title="(key: Types.this.Symbol)Option[scala.collection.immutable.Set[Types.this.Symbol]]">get</span> <a href="#132002" title="Types.this.Symbol">from</a> <span title="Set[Types.this.Symbol]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="scala.collection.immutable.Set[Types.this.Symbol]">Some</span><span class="delimiter">(</span><a title="scala.collection.immutable.Set[Types.this.Symbol]" id="132019">set</a><span class="delimiter">)</span> =&gt; <a href="#132019" title="scala.collection.immutable.Set[Types.this.Symbol]">set</a>
      <span class="keyword">case</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="132020">none</a> =&gt; <span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]">Set</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Augment existing refs map with reference &lt;pre&gt;from -&gt; to&lt;/pre&gt;
     *  @param  which &lt;- {NonExpansive, Expansive}
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit" id="71138">addRef</a><span class="delimiter">(</span><a title="Int" id="132024">which</a>: <span title="Int">Int</span>, <a title="Types.this.Symbol" id="132025">from</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="132026">to</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#71132" title="(i: Int, x: ClassInfoType.this.RefMap)Unit">refs</a><span class="delimiter">(</span><a href="#132024" title="Int">which</a><span class="delimiter">)</span> = <a href="#71132" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#132024" title="Int">which</a><span class="delimiter">)</span> <span title="(kv: (Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol]))scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">+</span> <span class="delimiter">(</span><a href="#132025" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">from</a> <span title="(y: scala.collection.immutable.Set[Types.this.Symbol])(Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])">-&gt;</span> <span class="delimiter">(</span><a href="#71137" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><a href="#132024" title="Int">which</a>, <a href="#132025" title="Types.this.Symbol">from</a><span class="delimiter">)</span> <span title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">+</span> <a href="#132026" title="Types.this.Symbol">to</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Augment existing refs map with references &lt;pre&gt;from -&gt; sym&lt;/pre&gt;, for
     *  all elements &lt;pre&gt;sym&lt;/pre&gt; of set `to`.
     *  @param  which &lt;- {NonExpansive, Expansive}
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit" id="71139">addRefs</a><span class="delimiter">(</span><a title="Int" id="132142">which</a>: <span title="Int">Int</span>, <a title="Types.this.Symbol" id="132143">from</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Set[Types.this.Symbol]" id="132144">to</a>: <span title="Set[Types.this.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#71132" title="(i: Int, x: ClassInfoType.this.RefMap)Unit">refs</a><span class="delimiter">(</span><a href="#132142" title="Int">which</a><span class="delimiter">)</span> = <a href="#71132" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#132142" title="Int">which</a><span class="delimiter">)</span> <span title="(kv: (Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol]))scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">+</span> <span class="delimiter">(</span><a href="#132143" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">from</a> <span title="(y: scala.collection.immutable.Set[Types.this.Symbol])(Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])">-&gt;</span> <span class="delimiter">(</span><a href="#71137" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><a href="#132142" title="Int">which</a>, <a href="#132143" title="Types.this.Symbol">from</a><span class="delimiter">)</span> <span title="(elems: scala.collection.GenTraversableOnce[Types.this.Symbol])scala.collection.immutable.Set[Types.this.Symbol]">++</span> <a href="#132144" title="Set[Types.this.Symbol]">to</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** The ClassInfoType which belongs to the class containing given type parameter
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Types.this.ClassInfoType" id="71140">classInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="132286">tparam</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#71108" title="Types.this.ClassInfoType">ClassInfoType</a> =
      <a href="#132286" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42743" title="=&gt; Types.this.Type">resultType</a> <span title="Types.this.ClassInfoType" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="Types.this.ClassInfoType" id="132291">ci</a>: <a href="#71108" title="Types.this.ClassInfoType">ClassInfoType</a> =&gt; <a href="#132291" title="Types.this.ClassInfoType">ci</a>
        <span class="keyword">case</span> <span title="Types.this.ClassInfoType">_</span> =&gt; <a href="#71140" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><a href="Definitions.scala.html#46278" title="=&gt; Types.this.Symbol">ObjectClass</a><span class="delimiter">)</span> // something's wrong; fall back to safe value
                                         // (this can happen only for erroneous programs).
      <span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">object</span> <a title="object ClassInfoType.this.enterRefs" id="71141">enterRefs</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
      <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Symbol" id="132294">tparam</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = _

      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="132296">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="132300">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
        <a href="#132300" title="Types.this.Type">tp</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Unit" id="132303">tr</a> @ TypeRef<span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="132304">sym</a>, <a title="List[Types.this.Type]" id="132305">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#132305" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">nonEmpty</span> =&gt;
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="132306">tparams</a> = <a href="#132303" title="Types.this.TypeRef">tr</a>.<a href="#66678" title="=&gt; List[Types.this.Symbol]">initializedTypeParams</a>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75538" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#132306" title="List[Types.this.Symbol]">tparams</a>, <a href="#132305" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="SymbolTable.scala.html#36942" title="(msg: =&gt; String)Unit">debugwarn</a><span class="delimiter">(</span><span title="String(&quot;Mismatched zip in computeRefs(): &quot;)" class="string">&quot;Mismatched zip in computeRefs(): &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#132304" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42752" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#132305" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>

            <a href="util/Collections.scala.html#39613" title="(xs1: List[Types.this.Symbol], xs2: List[Types.this.Type])(f: (Types.this.Symbol, Types.this.Type) =&gt; Unit)Unit">foreach2</a><span class="delimiter">(</span><a href="#132306" title="List[Types.this.Symbol]">tparams</a>, <a href="#132305" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="132348">tparam1</a>, <a title="Types.this.Type" id="132349">arg</a><span class="delimiter">)</span> =&gt;
              <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#132349" title="Types.this.Type">arg</a> <a href="#42793" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#132294" title="=&gt; Types.this.Symbol">tparam</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="#71138" title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit">addRef</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#132294" title="=&gt; Types.this.Symbol">tparam</a>, <a href="#132348" title="Types.this.Symbol">tparam1</a><span class="delimiter">)</span>
                <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#132349" title="Types.this.Type">arg</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#132294" title="=&gt; Types.this.Symbol">tparam</a><span class="delimiter">)</span>
                  <a href="#71138" title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit">addRef</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#132294" title="=&gt; Types.this.Symbol">tparam</a>, <a href="#132348" title="Types.this.Symbol">tparam1</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
        <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#132300" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="(tparam0: Types.this.Symbol, parent: Types.this.Type)Unit" id="132297">enter</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="132364">tparam0</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="132365">parent</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">this</span>.<a href="#132294" title="(x$1: Types.this.Symbol)Unit">tparam</a> = <a href="#132364" title="Types.this.Symbol">tparam0</a>
        <a href="#132296" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span title="Unit" class="delimiter">(</span><a href="#132365" title="Types.this.Type">parent</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** Compute initial (one-step) references and set state to `Initializing`.
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="()Unit" id="71143">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#71132" title="(x$1: Array[ClassInfoType.this.RefMap])Unit">refs</a> = <span title="(xs: ClassInfoType.this.RefMap*)(implicit evidence$2: scala.reflect.ClassManifest[ClassInfoType.this.RefMap])Array[ClassInfoType.this.RefMap]">Array</span><a href="#8614" title="(clazz: Class[_], arg1: scala.reflect.OptManifest[_], args: scala.reflect.OptManifest[_]*)scala.reflect.ClassManifest[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" class="delimiter">(</a><span title="(elems: (Types.this.Symbol, Nothing)*)scala.collection.immutable.Map[Types.this.Symbol,Nothing]">Map</span><span class="delimiter">(</span><span class="delimiter">)</span>, <span title="(elems: (Types.this.Symbol, Nothing)*)scala.collection.immutable.Map[Types.this.Symbol,Nothing]">Map</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#71150" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(f: Types.this.Symbol =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="132463">tparam</a> =&gt;
        <a href="#71148" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="Types.this.Type" id="132483">p</a> =&gt;
          <a href="#71141" title="object ClassInfoType.this.enterRefs">enterRefs</a>.<a href="#132297" title="(tparam0: Types.this.Symbol, parent: Types.this.Type)Unit">enter</a><span class="delimiter">(</span><a href="#132463" title="Types.this.Symbol">tparam</a>, <a href="#132483" title="Types.this.Type">p</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#71135" title="(x$1: Int)Unit">state</a> = <span title="Int(1)">Initializing</span>
    <span class="delimiter">}</span>

    /** Propagate to form transitive closure.
     *  Set state to Initialized if no change resulted from propagation.
     *  @return   true iff there as a change in last iteration
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="()Boolean" id="71144">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#71135" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)">UnInitialized</span><span class="delimiter">)</span> <a href="#71143" title="()Unit">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span>
      //Console.println(&quot;Propagate &quot;+symbol+&quot;, initial expansive = &quot;+refs(Expansive)+&quot;, nonexpansive = &quot;+refs(NonExpansive))//DEBUG
      <span class="keyword">val</span> <a title="Array[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" id="132486">lastRefs</a> = <span title="(xs: ClassInfoType.this.RefMap*)(implicit evidence$2: scala.reflect.ClassManifest[ClassInfoType.this.RefMap])Array[ClassInfoType.this.RefMap]">Array</span><a href="#8614" title="(clazz: Class[_], arg1: scala.reflect.OptManifest[_], args: scala.reflect.OptManifest[_]*)scala.reflect.ClassManifest[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" class="delimiter">(</a><a href="#71132" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>, <a href="#71132" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#71135" title="(x$1: Int)Unit">state</a> = <span title="Int(2)">Initialized</span>
      <span class="keyword">var</span> <a title="Boolean" id="132487">change</a> = <span title="Boolean(false)" class="keyword">false</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="132582">from</a>, <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="132583">targets</a><span class="delimiter">)</span> &lt;- <a href="#71132" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span><span class="delimiter">)</span>.<a href="#132564" title="(f: ((Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])) =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="132608">target</a> &lt;- <a href="#132583" title="(f: Types.this.Symbol =&gt; Unit)Unit">targets</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">var</span> <a title="Types.this.ClassInfoType" id="132609">thatInfo</a> = <a href="#71140" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><a href="#132608" title="Types.this.Symbol">target</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#132609" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#71135" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(2)">Initialized</span><span class="delimiter">)</span>
            <a href="#132487" title="Boolean">change</a> = <a href="#132487" title="Boolean">change</a> <span title="(x: Boolean)Boolean">|</span> <a href="#132609" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#71144" title="()Boolean">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#71139" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#132582" title="Types.this.Symbol">from</a>, <a href="#132609" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#71137" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#132608" title="Types.this.Symbol">target</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#71139" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#132582" title="Types.this.Symbol">from</a>, <a href="#132609" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#71137" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#132608" title="Types.this.Symbol">target</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="132637">from</a>, <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="132638">targets</a><span class="delimiter">)</span> &lt;- <a href="#71132" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span><span class="delimiter">)</span>.<a href="#132619" title="(f: ((Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])) =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="132655">target</a> &lt;- <a href="#132638" title="(f: Types.this.Symbol =&gt; Unit)Unit">targets</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">var</span> <a title="Types.this.ClassInfoType" id="132656">thatInfo</a> = <a href="#71140" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><a href="#132655" title="Types.this.Symbol">target</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#132656" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#71135" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(2)">Initialized</span><span class="delimiter">)</span>
            <a href="#132487" title="Boolean">change</a> = <a href="#132487" title="Boolean">change</a> <span title="(x: Boolean)Boolean">|</span> <a href="#132656" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#71144" title="()Boolean">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#71139" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#132637" title="Types.this.Symbol">from</a>, <a href="#132656" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#71137" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#132655" title="Types.this.Symbol">target</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <a href="#132487" title="Boolean">change</a> = <a href="#132487" title="Boolean">change</a> <span title="(x: Boolean)Boolean">||</span> <a href="#71132" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#132486" title="(i: Int)scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">lastRefs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#71132" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#132486" title="(i: Int)scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">lastRefs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#132487" title="Boolean">change</a><span class="delimiter">)</span> <a href="#71135" title="(x$1: Int)Unit">state</a> = <span title="Int(1)">Initializing</span>
      //else Console.println(&quot;Propagate &quot;+symbol+&quot;, final expansive = &quot;+refs(Expansive)+&quot;, nonexpansive = &quot;+refs(NonExpansive))//DEBUG
      <a href="#132487" title="Boolean">change</a>
    <span class="delimiter">}</span>

    // override def isNullable: Boolean =
    // symbol == AnyClass ||
    // symbol != NothingClass &amp;&amp; (symbol isSubClass ObjectClass) &amp;&amp; !(symbol isSubClass NonNullClass);

    // override def isNonNull: Boolean = symbol == NonNullClass || super.isNonNull;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="71145">kind</a> = <span title="String(&quot;ClassInfoType&quot;)" class="string">&quot;ClassInfoType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.ClassInfoType" id="132713">ClassInfoType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#8614" title="Types.this.ClassInfoTypeExtractor">ClassInfoTypeExtractor</a>

  <span class="keyword">class</span> <a title="class PackageClassInfoType extends Types.this.ClassInfoType with ScalaObject" id="40126">PackageClassInfoType</a><a href="#40126" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Scope" id="132722">decls</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="132723">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="#71108" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">(</span>List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#132722" title="Types.this.Scope">decls</a>, <a href="#132723" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>

  /** A class representing a constant type.
   *
   *  @param value ...
   */
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#132759" title="class ConstantType extends Types.this.SingletonType with ScalaObject with Product with Serializable" id="83618">ConstantType</a><a href="#83618" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Constant" id="83626">value</a>: <a href="Constants.scala.html#40506" title="Types.this.Constant">Constant</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40089" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83611">underlying</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#83626" title="=&gt; Types.this.Constant">value</a>.<a href="Constants.scala.html#47591" title="=&gt; Types.this.Type">tpe</a>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#83611" title="=&gt; Types.this.Type">underlying</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#46834" title="=&gt; Types.this.Symbol">UnitClass</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83612">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83613">isNotNull</a> = <a href="#83626" title="=&gt; Types.this.Constant">value</a>.<a href="Constants.scala.html#47577" title="=&gt; Any">value</a> <span title="(x$1: Any)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83614">deconst</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#83611" title="=&gt; Types.this.Type">underlying</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83615">safeToString</a>: <span title="String">String</span> =
      <a href="#83611" title="=&gt; Types.this.Type">underlying</a>.<a href="#42813" title="()String">toString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#83626" title="=&gt; Types.this.Constant">value</a>.<a href="Constants.scala.html#47605" title="=&gt; String">escapedStringValue</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
    // override def isNullable: Boolean = value.value eq null
    // override def isNonNull: Boolean = value.value ne null
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83616">kind</a> = <span title="String(&quot;ConstantType&quot;)" class="string">&quot;ConstantType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueConstantType extends Types.this.ConstantType with Types.this.UniqueType with ScalaObject" id="40130">UniqueConstantType</a><a href="#40130" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Constant" id="132784">value</a>: <a href="Constants.scala.html#40506" title="Types.this.Constant">Constant</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#83618" title="Types.this.ConstantType">ConstantType</a><span class="delimiter">(</span><a href="#132784" title="Types.this.Constant">value</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#40084" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span>
    /** Save the type of `value`. For Java enums, it depends on finding the linked class,
     *  which might not be found after `flatten`. */
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.Type" id="132780">_tpe</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#132784" title="Types.this.Constant">value</a>.<a href="Constants.scala.html#47591" title="=&gt; Types.this.Type">tpe</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="132781">underlying</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#132779" title="=&gt; Types.this.Type">_tpe</a>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.ConstantType" id="132791">ConstantType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#8614" title="Types.this.ConstantTypeExtractor">ConstantTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(value: Types.this.Constant)Types.this.ConstantType" id="83606">apply</a><span class="delimiter">(</span><a title="Types.this.Constant" id="83629">value</a>: <a href="Constants.scala.html#40506" title="Types.this.Constant">Constant</a><span class="delimiter">)</span>: <a href="#83618" title="Types.this.ConstantType">ConstantType</a> = <span class="delimiter">{</span>
      <a href="#40229" title="(tp: Types.this.UniqueConstantType)Types.this.UniqueConstantType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueConstantType" class="keyword">new</span> <a href="#40130" title="Types.this.UniqueConstantType">UniqueConstantType</a><span class="delimiter">(</span><a href="#83629" title="Types.this.Constant">value</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.ConstantType" class="delimiter">[</span><a href="#83618" title="Types.this.ConstantType">ConstantType</a><span class="delimiter">]</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="40132">volatileRecursions</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.Symbol]" id="40134">pendingVolatiles</a> = <span title="()scala.collection.mutable.HashSet[Types.this.Symbol]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Types.this.Symbol]">HashSet</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
  
  <span class="keyword">class</span> <a title="class ArgsTypeRef extends Types.this.TypeRef with Types.this.UniqueType with ScalaObject" id="40136">ArgsTypeRef</a><a href="#40136" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="132807">pre0</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="132808">sym0</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="132809">args0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#66707" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">(</span><a href="#132807" title="Types.this.Type">pre0</a>, <a href="#132808" title="Types.this.Symbol">sym0</a>, <a href="#132809" title="List[Types.this.Type]">args0</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#40084" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#132809" title="List[Types.this.Type]">args0</a>.<span title="=&gt; Boolean">nonEmpty</span>, <a href="#40136" title="Types.this.ArgsTypeRef" class="keyword">this</a><span class="delimiter">)</span>

    /** No unapplied type params size it has (should have) equally as many args. */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="132799">isHigherKinded</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Nil.type" id="132800">typeParams</a> = <span title="object Nil">Nil</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="132801">transform</a><span class="delimiter">(</span><a title="Types.this.Type" id="132818">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      // This situation arises when a typevar is encountered for which
      // too little information is known to determine its kind, and
      // it later turns out not to have kind *. See SI-4070.  Only
      // logging it for now.
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">!=</span> <a href="#66726" title="=&gt; List[Types.this.Type]">args</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>
        <a href="SymbolTable.scala.html#36938" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;!!! %s.transform(%s), but tparams.isEmpty and args=&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#40136" title="Types.this.ArgsTypeRef" class="keyword">this</a>, <a href="#132818" title="Types.this.Type">tp</a>, <a href="#66726" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <a href="#66680" title="(tp: Types.this.Type)Types.this.Type">asSeenFromOwner</a><span class="delimiter">(</span><a href="#132818" title="Types.this.Type">tp</a><span class="delimiter">)</span>.<a href="#42755" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#66726" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    
    // note: does not go through typeRef. There's no need to because
    // neither `pre` nor `sym` changes.  And there's a performance
    // advantage to call TypeRef directly.
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="132802">typeConstructor</a> = <a href="#66645" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#66724" title="=&gt; Types.this.Type">pre</a>, <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">class</span> <a title="class NoArgsTypeRef extends Types.this.TypeRef with Types.this.UniqueType with ScalaObject" id="40137">NoArgsTypeRef</a><a href="#40137" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="132856">pre0</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="132857">sym0</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#66707" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">(</span><a href="#132856" title="Types.this.Type">pre0</a>, <a href="#132857" title="Types.this.Symbol">sym0</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#40084" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span>
    // A reference (in a Scala program) to a type that has type parameters, but where the reference
    // does not include type arguments. Note that it doesn't matter whether the symbol refers
    // to a java or scala symbol, but it does matter whether it occurs in java or scala code.
    // TypeRefs w/o type params that occur in java signatures/code are considered raw types, and are
    // represented as existential types.
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="132844">isHigherKinded</a> = <a href="#132845" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">nonEmpty</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="132845">typeParams</a>     = <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#46236" title="=&gt; Boolean">isDefinitionsInitialized</a><span class="delimiter">)</span> <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span class="keyword">else</span> <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47939" title="=&gt; List[Types.this.Symbol]">unsafeTypeParams</a>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="132846">isRaw</a>           = <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#40247" title="(sym: Types.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
    
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="132847">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="132872">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="132873">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#132844" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#132872" title="List[Types.this.Symbol]">formals</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])List[Types.this.Symbol]">intersect</span> <a href="#132845" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#132845" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#40199" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#40137" title="Types.this.NoArgsTypeRef" class="keyword">this</a>, <a href="#66724" title="=&gt; Types.this.Type">pre</a>, <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>, <a href="#132873" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
        // partial application (needed in infer when bunching type arguments from classes and methods together)
        <span class="keyword">else</span>
          <a href="#40199" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#40137" title="Types.this.NoArgsTypeRef" class="keyword">this</a>, <a href="#66724" title="=&gt; Types.this.Type">pre</a>, <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>, <a href="#42742" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>.<a href="#42755" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#132872" title="List[Types.this.Symbol]">formals</a>, <a href="#132873" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span>
        <a href="#40137" title="Types.this.NoArgsTypeRef" class="keyword">super</a>.<a href="#42755" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#132872" title="List[Types.this.Symbol]">formals</a>, <a href="#132873" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="132848">transform</a><span class="delimiter">(</span><a title="Types.this.Type" id="132893">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="132895">res</a> = <a href="#66680" title="(tp: Types.this.Type)Types.this.Type">asSeenFromOwner</a><span class="delimiter">(</span><a href="#132893" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#132844" title="=&gt; Boolean">isHigherKinded</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#132846" title="=&gt; Boolean">isRaw</a><span class="delimiter">)</span>
        <a href="#132895" title="Types.this.Type">res</a>.<a href="#42755" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#132845" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#42742" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <a href="#132895" title="Types.this.Type">res</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="132849">transformInfo</a><span class="delimiter">(</span><a title="Types.this.Type" id="132896">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = 
      <a href="#40204" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#66680" title="(tp: Types.this.Type)Types.this.Type">asSeenFromOwner</a><span class="delimiter">(</span><a href="#132896" title="Types.this.Type">tp</a><span class="delimiter">)</span>, <a href="#42742" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>
      
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="132850">narrow</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47775" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <a href="#40194" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#66724" title="=&gt; Types.this.Type">pre</a>, <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47985" title="=&gt; Types.this.Symbol">sourceModule</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#40137" title="Types.this.NoArgsTypeRef" class="keyword">super</a>.<a href="#42735" title="=&gt; Types.this.Type">narrow</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.NoArgsTypeRef" id="132851">typeConstructor</a> = <a href="#40137" title="Types.this.NoArgsTypeRef" class="keyword">this</a>
    // eta-expand, subtyping relies on eta-expansion of higher-kinded types

    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="132852">normalizeImpl</a>: <a href="#40083" title="Types.this.Type">Type</a> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#132844" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#66674" title="=&gt; Types.this.Type">etaExpand</a> <span class="keyword">else</span> <a href="#40137" title="Types.this.NoArgsTypeRef" class="keyword">super</a>.<a href="#66672" title="=&gt; Types.this.Type">normalizeImpl</a>
  <span class="delimiter">}</span>
  
  <span class="keyword">trait</span> <a title="trait ClassTypeRef extends Types.this.TypeRef with ScalaObject" id="40138">ClassTypeRef</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#66707" title="Types.this.TypeRef">TypeRef</a> <span class="delimiter">{</span>
    // !!! There are scaladoc-created symbols arriving which violate this require.
    // require(sym.isClass, sym)
    
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="132915">normalizeImpl</a>: <a href="#40083" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47779" title="=&gt; Boolean">isRefinementClass</a><span class="delimiter">)</span> <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a> // I think this is okay, but see #1241 (r12414), #2208, and typedTypeConstructor in Typers
      <span class="keyword">else</span> <a href="#40138" title="Types.this.ClassTypeRef" class="keyword">super</a>.<a href="#66672" title="=&gt; Types.this.Type">normalizeImpl</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="132916">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="132923">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#132923" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <a href="#40138" title="Types.this.ClassTypeRef" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#66671" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42777" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#132923" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">trait</span> <a title="trait NonClassTypeRef extends Types.this.TypeRef with ScalaObject" id="40139">NonClassTypeRef</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#66707" title="Types.this.TypeRef">TypeRef</a> <span class="delimiter">{</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47762" title="=&gt; Boolean">isNonClassType</a>, <a href="#66725" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="132934">relativeInfoCache</a>: <a href="#40083" title="Types.this.Type">Type</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="132937">memberInfoCache</a>: <a href="#40083" title="Types.this.Type">Type</a> = _

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="132939">relativeInfo</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="132950">memberInfo</a> = <a href="#66724" title="=&gt; Types.this.Type">pre</a>.<a href="#42779" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#132934" title="=&gt; Types.this.Type">relativeInfoCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#132950" title="Types.this.Type">memberInfo</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#132937" title="=&gt; Types.this.Type">memberInfoCache</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#132937" title="(x$1: Types.this.Type)Unit">memberInfoCache</a> = <a href="#132950" title="Types.this.Type">memberInfo</a>
        <a href="#132934" title="(x$1: Types.this.Type)Unit">relativeInfoCache</a> = <a href="#66676" title="(tp: Types.this.Type)Types.this.Type">transformInfo</a><span class="delimiter">(</span><a href="#132950" title="Types.this.Type">memberInfo</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#132934" title="=&gt; Types.this.Type">relativeInfoCache</a>
    <span class="delimiter">}</span>
    
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="132940">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="132956">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">(</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#132956" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <a href="#40139" title="Types.this.NonClassTypeRef" class="keyword">this</a> <span class="keyword">else</span> <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#40315" title="(x$1: Int)Unit">basetypeRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#40315" title="=&gt; Int">basetypeRecursions</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(50)">LogPendingBaseTypesThreshold</span><span class="delimiter">)</span>
          <a href="#132939" title="=&gt; Types.this.Type">relativeInfo</a>.<a href="#42777" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#132956" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#40317" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <span title="(elem: Types.this.Type)Boolean">contains</span> <a href="#40139" title="Types.this.NonClassTypeRef" class="keyword">this</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#132956" title="Types.this.Symbol">clazz</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span> <a href="#132956" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#130794" title="object Types.this.NoType">NoType</a>
        <span class="keyword">else</span>
          <span class="keyword">try</span> <span class="delimiter">{</span>
            <a href="#40317" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <span title="(elem: Types.this.Type)Types.this.pendingBaseTypes.type">+=</span> <a href="#40139" title="Types.this.NonClassTypeRef" class="keyword">this</a>
            <a href="#132939" title="=&gt; Types.this.Type">relativeInfo</a>.<a href="#42777" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#132956" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            <a href="#40317" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <span title="(elem: Types.this.Type)Types.this.pendingBaseTypes.type">-=</span> <a href="#40139" title="Types.this.NonClassTypeRef" class="keyword">this</a>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
        <a href="#40315" title="(x$1: Int)Unit">basetypeRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
      <span class="delimiter">}</span>
    <span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">trait</span> <a title="trait AliasTypeRef extends Types.this.TypeRef with Types.this.NonClassTypeRef with ScalaObject" id="40140">AliasTypeRef</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40139" title="Types.this.NonClassTypeRef">NonClassTypeRef</a> <span class="delimiter">{</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47759" title="=&gt; Boolean">isAliasType</a>, <a href="#66725" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133004">dealias</a>    = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#66679" title="=&gt; Boolean">typeParamsMatchArgs</a><span class="delimiter">)</span> <a href="#133013" title="=&gt; Types.this.Type">betaReduce</a>.<a href="#42759" title="=&gt; Types.this.Type">dealias</a> <span class="keyword">else</span> <a href="#40140" title="Types.this.AliasTypeRef" class="keyword">super</a>.<a href="#42759" title="=&gt; Types.this.Type">dealias</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133005">isStable</a>   = <a href="#66673" title="=&gt; Types.this.Type">normalize</a>.<a href="#42715" title="=&gt; Boolean">isStable</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133006">isVolatile</a> = <a href="#66673" title="=&gt; Types.this.Type">normalize</a>.<a href="#42716" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133007">narrow</a>     = <a href="#66673" title="=&gt; Types.this.Type">normalize</a>.<a href="#42735" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133008">thisInfo</a>   = <a href="#66673" title="=&gt; Types.this.Type">normalize</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133009">prefix</a>     = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#40140" title="AliasTypeRef.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#66673" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#66673" title="=&gt; Types.this.Type">normalize</a>.<a href="#42738" title="=&gt; Types.this.Type">prefix</a> <span class="keyword">else</span> <a href="#66724" title="=&gt; Types.this.Type">pre</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="133010">termSymbol</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#40140" title="AliasTypeRef.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#66673" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#66673" title="=&gt; Types.this.Type">normalize</a>.<a href="#42727" title="=&gt; Types.this.Symbol">termSymbol</a> <span class="keyword">else</span> <a href="#40140" title="Types.this.AliasTypeRef" class="keyword">super</a>.<a href="#66685" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="133011">typeSymbol</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#40140" title="AliasTypeRef.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#66673" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#66673" title="=&gt; Types.this.Type">normalize</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span class="keyword">else</span> <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>

    // beta-reduce, but don't do partial application -- cycles have been checked in typeRef
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133012">normalizeImpl</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#66679" title="=&gt; Boolean">typeParamsMatchArgs</a><span class="delimiter">)</span> <a href="#133013" title="=&gt; Types.this.Type">betaReduce</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#42714" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#40140" title="Types.this.AliasTypeRef" class="keyword">super</a>.<a href="#66672" title="=&gt; Types.this.Type">normalizeImpl</a>
      <span class="keyword">else</span> <a href="#130719" title="object Types.this.ErrorType">ErrorType</a>
    
    // isHKSubType0 introduces synthetic type params so that
    // betaReduce can first apply sym.info to typeArgs before calling
    // asSeenFrom.  asSeenFrom then skips synthetic type params, which
    // are used to reduce HO subtyping to first-order subtyping, but
    // which can't be instantiated from the given prefix and class.
    //
    // this crashes pos/depmet_implicit_tpbetareduce.scala
    // appliedType(sym.info, typeArgs).asSeenFrom(pre, sym.owner)
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133013">betaReduce</a> = <a href="#66671" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42743" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
    
    // #3731: return sym1 for which holds: pre bound sym.name to sym and
    // pre1 now binds sym.name to sym1, conceptually exactly the same
    // symbol as sym.  The selection of sym on pre must be updated to the
    // selection of sym1 on pre1, since sym's info was probably updated
    // by the TypeMap to yield a new symbol, sym1 with transformed info.
    // @returns sym1
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(pre1: Types.this.Type)Types.this.Symbol" id="133014">coevolveSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="133079">pre1</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> =
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#66724" title="=&gt; Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#133079" title="Types.this.Type">pre1</a><span class="delimiter">)</span> <a href="#66725" title="=&gt; Types.this.Symbol">sym</a> <span class="keyword">else</span> <span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#66724" title="=&gt; Types.this.Type">pre</a>, <a href="#133079" title="Types.this.Type">pre1</a><span class="delimiter">)</span> <span title="Types.this.Symbol" class="keyword">match</span> <span class="delimiter">{</span>
        // don't look at parents -- it would be an error to override alias types anyway
        <span class="keyword">case</span> <span title="Types.this.Symbol" class="delimiter">(</span>RefinedType<span class="delimiter">(</span>_, _<span class="delimiter">)</span>, RefinedType<span class="delimiter">(</span>_, <a title="Types.this.Scope" id="133091">decls1</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#133091" title="Types.this.Scope">decls1</a> <a href="Scopes.scala.html#61759" title="(name: Types.this.Name)Types.this.Symbol">lookup</a> <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a>
        // TODO: is there another way a typeref's symbol can refer to a symbol defined in its pre?
        <span class="keyword">case</span> <span title="Types.this.Symbol">_</span>                                           =&gt; <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>
      <span class="delimiter">}</span>
    
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait AbstractTypeRef extends Types.this.TypeRef with Types.this.NonClassTypeRef with ScalaObject" id="40141">AbstractTypeRef</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40139" title="Types.this.NonClassTypeRef">NonClassTypeRef</a> <span class="delimiter">{</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47760" title="=&gt; Boolean">isAbstractType</a>, <a href="#66725" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
    
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="133095">symInfoCache</a>: <a href="#40083" title="Types.this.Type">Type</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="133098">thisInfoCache</a>: <a href="#40083" title="Types.this.Type">Type</a> = _

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133100">isVolatile</a> = <span class="delimiter">{</span>
      // need to be careful not to fall into an infinite recursion here
      // because volatile checking is done before all cycles are detected.
      // the case to avoid is an abstract type directly or
      // indirectly upper-bounded by itself. See #2918
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#40132" title="(x$1: Int)Unit">volatileRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#40132" title="=&gt; Int">volatileRecursions</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(50)">LogVolatileThreshold</span><span class="delimiter">)</span>
          <a href="#133103" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a>.<a href="#42716" title="=&gt; Boolean">isVolatile</a>
        <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#40134" title="(elem: Types.this.Symbol)Boolean">pendingVolatiles</a><span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="Boolean(true)" class="keyword">true</span> // we can return true here, because a cycle will be detected
               // here afterwards and an error will result anyway.
        <span class="keyword">else</span>
          <span class="keyword">try</span> <span class="delimiter">{</span>
            <a href="#40134" title="=&gt; scala.collection.mutable.HashSet[Types.this.Symbol]">pendingVolatiles</a> <span title="(elem: Types.this.Symbol)Types.this.pendingVolatiles.type">+=</span> <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>
            <a href="#133103" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a>.<a href="#42716" title="=&gt; Boolean">isVolatile</a>
          <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            <a href="#40134" title="=&gt; scala.collection.mutable.HashSet[Types.this.Symbol]">pendingVolatiles</a> <span title="(elem: Types.this.Symbol)Types.this.pendingVolatiles.type">-=</span> <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
        <a href="#40132" title="(x$1: Int)Unit">volatileRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133101">thisInfo</a>   = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="133128">symInfo</a> = <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133098" title="=&gt; Types.this.Type">thisInfoCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#133128" title="Types.this.Type">symInfo</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#133095" title="=&gt; Types.this.Type">symInfoCache</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#133095" title="(x$1: Types.this.Type)Unit">symInfoCache</a> = <a href="#133128" title="Types.this.Type">symInfo</a>
        <a href="#133098" title="(x$1: Types.this.Type)Unit">thisInfoCache</a> = <a href="#66676" title="(tp: Types.this.Type)Types.this.Type">transformInfo</a><span class="delimiter">(</span><a href="#133128" title="Types.this.Type">symInfo</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
          // If a subtyping cycle is not detected here, we'll likely enter an infinite
          // loop before a sensible error can be issued.  SI-5093 is one example.
          <span class="keyword">case</span> <a title="Nothing" id="133134">x</a>: <a href="#40085" title="Types.this.SubType">SubType</a> <span class="keyword">if</span> <a href="#133134" title="Types.this.SubType">x</a>.<a href="#66840" title="=&gt; Types.this.Type">supertype</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#40141" title="Types.this.AbstractTypeRef" class="keyword">this</a> =&gt;
            <span title="Nothing" class="keyword">throw</span> <a href="#67275" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#40384" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic reference involving &quot;)" class="string">&quot;illegal cyclic reference involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#66725" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <a title="Types.this.Type" id="133137">tp</a> =&gt; <a href="#133137" title="Types.this.Type">tp</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#133098" title="=&gt; Types.this.Type">thisInfoCache</a>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133102">isStable</a> = <a href="#133103" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#47964" title="(that: Types.this.Symbol)Boolean">isSubClass</a> <a href="Definitions.scala.html#46375" title="=&gt; Types.this.Symbol">SingletonClass</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="133103">bounds</a>   = <a href="#133101" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>
    // def transformInfo(tp: Type): Type = appliedType(tp.asSeenFrom(pre, sym.owner), typeArgsOrDummies)
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="133104">baseTypeSeqImpl</a>: <a href="BaseTypeSeqs.scala.html#40512" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#66671" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#133103" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>.<a href="#42803" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#60851" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">prepend</a> <a href="#40141" title="Types.this.AbstractTypeRef" class="keyword">this</a>
  <span class="delimiter">}</span>

  /** A class for named types of the form
   *    `&lt;prefix&gt;.&lt;sym.name&gt;[args]`
   *  Cannot be created directly; one should always use `typeRef`
   *  for creation. (@M: Otherwise hashing breaks)
   *
   * @M: a higher-kinded type is represented as a TypeRef with sym.typeParams.nonEmpty, but args.isEmpty
   */
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#133592" title="class TypeRef extends Types.this.Type with ScalaObject with Product with Serializable" id="66707">TypeRef</a><a href="#66707" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="66724">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="66725">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="66726">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[Types.this.Type]" id="66657">parentsCache</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>      = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="66660">parentsPeriod</a>                 = <span title="Int(0)">NoPeriod</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.BaseTypeSeq" id="66663">baseTypeSeqCache</a>: <a href="BaseTypeSeqs.scala.html#40512" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="66666">baseTypeSeqPeriod</a>             = <span title="Int(0)">NoPeriod</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="66669">normalized</a>: <a href="#40083" title="Types.this.Type">Type</a>              = _

    // @M: propagate actual type params (args) to `tp`, by replacing
    // formal type parameters with actual ones. If tp is higher kinded,
    // the &quot;actual&quot; type arguments are types that simply reference the
    // corresponding type parameters (unbound type variables)
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="66671">transform</a><span class="delimiter">(</span><a title="Types.this.Type" id="132820">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a>

    // eta-expand, subtyping relies on eta-expansion of higher-kinded types
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="66672">normalizeImpl</a>: <a href="#40083" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#42714" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#66674" title="=&gt; Types.this.Type">etaExpand</a> <span class="keyword">else</span> <a href="#66707" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a>

    // TODO: test case that is compiled in a specific order and in different runs
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="66673">normalize</a>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      // arises when argument-dependent types are approximated (see def depoly in implicits)
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#66724" title="=&gt; Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130739" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span> <a href="#130739" title="object Types.this.WildcardType">WildcardType</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#66672" title="=&gt; Types.this.Type">normalizeImpl</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#66669" title="=&gt; Types.this.Type">normalized</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
          <a href="#66669" title="(x$1: Types.this.Type)Unit">normalized</a> = <a href="#66672" title="=&gt; Types.this.Type">normalizeImpl</a>
        <a href="#66669" title="=&gt; Types.this.Type">normalized</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="66674">etaExpand</a>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      // must initialise symbol, see test/files/pos/ticket0137.scala
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="133197">tpars</a> = <a href="#66678" title="=&gt; List[Types.this.Symbol]">initializedTypeParams</a>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133197" title="List[Types.this.Symbol]">tpars</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#66707" title="Types.this.TypeRef" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#40206" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFunAnon</a><span class="delimiter">(</span><a href="#133197" title="List[Types.this.Symbol]">tpars</a>, <a href="#40199" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#66707" title="Types.this.TypeRef" class="keyword">this</a>, <a href="#66724" title="=&gt; Types.this.Type">pre</a>, <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>, <a href="#133197" title="List[Types.this.Symbol]">tpars</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#133217" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47919" title="=&gt; Types.this.Type">tpeHK</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> // todo: also beta-reduce?
    <span class="delimiter">}</span>

    // only need to rebind type aliases, as typeRef already handles abstract types
    // (they are allowed to be rebound more liberally)
    <span class="keyword">def</span> <a title="(pre1: Types.this.Type)Types.this.Symbol" id="66675">coevolveSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="133081">pre1</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>

    //@M! use appliedType on the polytype that represents the bounds (or if aliastype, the rhs)
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="66676">transformInfo</a><span class="delimiter">(</span><a title="Types.this.Type" id="132898">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40204" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#66680" title="(tp: Types.this.Type)Types.this.Type">asSeenFromOwner</a><span class="delimiter">(</span><a href="#132898" title="Types.this.Type">tp</a><span class="delimiter">)</span>, <a href="#66726" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="66677">thisInfo</a>                  = <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="66678">initializedTypeParams</a>     = <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42752" title="=&gt; List[Types.this.Symbol]">typeParams</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="66679">typeParamsMatchArgs</a>       = <a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#66678" title="=&gt; List[Types.this.Symbol]">initializedTypeParams</a>, <a href="#66726" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="66680">asSeenFromOwner</a><span class="delimiter">(</span><a title="Types.this.Type" id="132831">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#132831" title="Types.this.Type">tp</a>.<a href="#42778" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#66724" title="=&gt; Types.this.Type">pre</a>, <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="66681">baseClasses</a>      = <a href="#66677" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#42805" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="66682">baseTypeSeqDepth</a> = <a href="#66697" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#60856" title="=&gt; Int">maxDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="66683">isStable</a>         = <span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#46375" title="=&gt; Types.this.Symbol">SingletonClass</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="66684">prefix</a>           = <a href="#66724" title="=&gt; Types.this.Type">pre</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="66685">termSymbol</a>       = <a href="#66707" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#42727" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="66686">termSymbolDirect</a> = <a href="#66707" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#42727" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="66687">typeArgs</a>         = <a href="#66726" title="=&gt; List[Types.this.Type]">args</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="66688">typeOfThis</a>       = <a href="#66671" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47979" title="=&gt; Types.this.Type">typeOfThis</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="66689">typeSymbol</a>       = <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="66690">typeSymbolDirect</a> = <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>

    <span class="keyword">override</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="66692">isTrivial</a>: <span title="Boolean">Boolean</span> =
      <span title="=&gt; Boolean">!</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47781" title="=&gt; Boolean">isTypeParameter</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#66724" title="=&gt; Types.this.Type">pre</a>.<a href="#42713" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#66726" title="=&gt; List[Types.this.Type]">args</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#133273" title="Types.this.Type">_</a>.<a href="#42713" title="=&gt; Boolean">isTrivial</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="66693">isNotNull</a> =
      <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47775" title="=&gt; Boolean">isModuleClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="#66725" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="Definitions.scala.html#46780" title="(sym: Types.this.Symbol)Boolean">isValueClass</a><span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#66707" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#42717" title="=&gt; Boolean">isNotNull</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="66694">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="133286">period</a> = <a href="#66660" title="=&gt; Int">parentsPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133286" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#36969" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#66660" title="(x$1: Int)Unit">parentsPeriod</a> = <a href="SymbolTable.scala.html#36969" title="=&gt; Types.this.Period">currentPeriod</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#36982" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#133286" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#66657" title="(x$1: List[Types.this.Type])Unit">parentsCache</a> = <a href="#66677" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#42737" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#66671" title="(tp: Types.this.Type)Types.this.Type">transform</a>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#66657" title="=&gt; List[Types.this.Type]">parentsCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span> // seems this can happen if things are corrupted enough, see #2641
          <a href="#66657" title="(x$1: List[Types.this.Type])Unit">parentsCache</a> = <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#66657" title="=&gt; List[Types.this.Type]">parentsCache</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="66695">decls</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a> = <span class="delimiter">{</span>
      <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="133352">sym1</a>, _<span class="delimiter">)</span> =&gt;
          <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#133352" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>, <a href="#66707" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span> // @MAT was != typeSymbol
        <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
      <span class="delimiter">}</span>
      <a href="#66677" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#42760" title="=&gt; Types.this.Scope">decls</a>
    <span class="delimiter">}</span>
  
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="66696">baseTypeSeqImpl</a>: <a href="BaseTypeSeqs.scala.html#40512" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42803" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#60853" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">map</a> <a href="#66671" title="(tp: Types.this.Type)Types.this.Type">transform</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="66697">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#40512" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="133362">period</a> = <a href="#66666" title="=&gt; Int">baseTypeSeqPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133362" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#36969" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#66666" title="(x$1: Int)Unit">baseTypeSeqPeriod</a> = <a href="SymbolTable.scala.html#36969" title="=&gt; Types.this.Period">currentPeriod</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#36982" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#133362" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="util/StatBase.scala.html#39915" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39937" title="=&gt; scala.reflect.internal.util.Statistics.Counter">typerefBaseTypeSeqCount</a><span class="delimiter">)</span>
          <a href="#66663" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="BaseTypeSeqs.scala.html#40513" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a>
          <a href="#66663" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="#66696" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqImpl</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#66663" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="BaseTypeSeqs.scala.html#40513" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">throw</span> <a href="#67275" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#40384" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic inheritance involving &quot;)" class="string">&quot;illegal cyclic inheritance involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#66725" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <a href="#66663" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
    <span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; String" id="66698">preString</a> = <span class="delimiter">(</span>
      // ensure that symbol is not a local copy with a name coincidence
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75538" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#40400" title="(elem: String)Boolean">shorthands</a><span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47897" title="=&gt; String">fullName</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47878" title="=&gt; List[Types.this.Symbol]">ownerChain</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#133413" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47757" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <a href="#66724" title="=&gt; Types.this.Type">pre</a>.<a href="#42812" title="=&gt; String">prefixString</a>
    <span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; String" id="66699">argsString</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#66726" title="=&gt; List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="#66726" title="=&gt; List[Types.this.Type]">args</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; String" id="66700">refinementString</a> = <span class="delimiter">(</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47866" title="=&gt; Boolean">isStructuralRefinement</a><span class="delimiter">)</span> <span class="delimiter">(</span>
        <a href="#66695" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#61769" title="(p: Types.this.Symbol =&gt; Boolean)Types.this.Scope">filter</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="133428">sym</a> =&gt; <a href="#133428" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47868" title="=&gt; Boolean">isPossibleInRefinement</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#133428" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#48094" title="=&gt; Boolean">isPublic</a><span class="delimiter">)</span>
          <span title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[Types.this.Symbol],String,Iterable[String]])Iterable[String]">map</span> <span class="delimiter">(</span><a href="#133448" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#48059" title="=&gt; String">defString</a><span class="delimiter">)</span>
          <span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot; {&quot;)" class="string">&quot; {&quot;</span>, <span title="String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="String(&quot;}&quot;)" class="string">&quot;}&quot;</span><span class="delimiter">)</span>
      <span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(rest: String)String" id="66701">finishPrefix</a><span class="delimiter">(</span><a title="String" id="133493">rest</a>: <span title="String">String</span><span class="delimiter">)</span> = <span class="delimiter">(</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#42810" title="=&gt; String">packagePrefix</a> <span title="(x$1: Any)String">+</span> <a href="#133493" title="String">rest</a>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47775" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <a href="#42809" title="=&gt; String">objectPrefix</a> <span title="(x$1: Any)String">+</span> <a href="#133493" title="String">rest</a>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47872" title="=&gt; Boolean">isInitialized</a><span class="delimiter">)</span> <a href="#133493" title="String">rest</a>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47815" title="=&gt; Boolean">isAnonymousClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
        <a href="#66677" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#42737" title="=&gt; List[Types.this.Type]">parents</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="String(&quot; with &quot;)" class="string">&quot; with &quot;</span>, <a href="#66700" title="=&gt; String">refinementString</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47779" title="=&gt; Boolean">isRefinementClass</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#66677" title="=&gt; Types.this.Type">thisInfo</a>
      <span class="keyword">else</span> <a href="#133493" title="String">rest</a>
    <span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; String" id="66702">customToString</a> = <a href="#66707" title="Types.this.TypeRef" class="keyword">this</a> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="String">TypeRef</span><span class="delimiter">(</span>_, <a href="Definitions.scala.html#46389" title="=&gt; Types.this.Symbol">RepeatedParamClass</a>, <a title="Types.this.Type" id="133506">arg</a> :: _<span class="delimiter">)</span> =&gt; <a href="#133506" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">arg</a> <span title="(other: String)String">+</span> <span title="String(&quot;*&quot;)" class="string">&quot;*&quot;</span>
      <span class="keyword">case</span> <span title="String">TypeRef</span><span class="delimiter">(</span>_, <a href="Definitions.scala.html#46406" title="=&gt; Types.this.Symbol">ByNameParamClass</a>, <a title="Types.this.Type" id="133513">arg</a> :: _<span class="delimiter">)</span>   =&gt; <span title="String(&quot;=&gt; &quot;)" class="string">&quot;=&gt; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#133513" title="Types.this.Type">arg</a>
      <span class="keyword">case</span> <span title="String">_</span> =&gt;
        <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#46557" title="(tp: Types.this.Type)Boolean">isFunctionType</a><span class="delimiter">(</span><a href="#66707" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="133515">targs</a> = <a href="#66673" title="=&gt; Types.this.Type">normalize</a>.<a href="#42741" title="=&gt; List[Types.this.Type]">typeArgs</a>
          // Aesthetics: printing Function1 as T =&gt; R rather than (T) =&gt; R
          // ...but only if it's not a tuple, so ((T1, T2)) =&gt; R is distinguishable
          // from (T1, T2) =&gt; R.
          <a href="#133515" title="List[Types.this.Type]">targs</a> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a title="String" id="133520">in</a> :: <a title="Types.this.Type" id="133528">out</a> :: <span title="object Nil">Nil</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="Definitions.scala.html#46538" title="(tp: Types.this.Type)Boolean">isTupleTypeOrSubtype</a><span class="delimiter">(</span><a href="#133520" title="Types.this.Type">in</a><span class="delimiter">)</span> =&gt;
              // A =&gt; B =&gt; C should be (A =&gt; B) =&gt; C or A =&gt; (B =&gt; C)
              <span class="keyword">val</span> <a title="String" id="133530">in_s</a>  = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#46557" title="(tp: Types.this.Type)Boolean">isFunctionType</a><span class="delimiter">(</span><a href="#133520" title="Types.this.Type">in</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#133520" title="Types.this.Type">in</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#133520" title="Types.this.Type">in</a>
              <span class="keyword">val</span> <a title="String" id="133531">out_s</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#46557" title="(tp: Types.this.Type)Boolean">isFunctionType</a><span class="delimiter">(</span><a href="#133528" title="Types.this.Type">out</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#133528" title="Types.this.Type">out</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#133528" title="Types.this.Type">out</a>
              <a href="#133530" title="String">in_s</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; =&gt; &quot;)" class="string">&quot; =&gt; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#133531" title="String">out_s</a>
            <span class="keyword">case</span> <a title="String" id="133532">xs</a> =&gt;
              <a href="#133532" title="List[Types.this.Type]">xs</a>.<span title="=&gt; List[Types.this.Type]">init</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; =&gt; &quot;)" class="string">&quot; =&gt; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#133532" title="List[Types.this.Type]">xs</a>.<span title="=&gt; Types.this.Type">last</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#46538" title="(tp: Types.this.Type)Boolean">isTupleTypeOrSubtype</a><span class="delimiter">(</span><a href="#66707" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#66673" title="=&gt; Types.this.Type">normalize</a>.<a href="#42741" title="=&gt; List[Types.this.Type]">typeArgs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#40311" title="(xs: List[_], len: Int)Boolean">hasLength</a><span class="delimiter">(</span><a href="#66673" title="=&gt; Types.this.Type">normalize</a>.<a href="#42741" title="=&gt; List[Types.this.Type]">typeArgs</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;,)&quot;)" class="string">&quot;,)&quot;</span> <span class="keyword">else</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47759" title="=&gt; Boolean">isAliasType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#42739" title="=&gt; List[Types.this.Type]">prefixChain</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#133559" title="Types.this.Type">_</a>.<a href="#42727" title="=&gt; Types.this.Symbol">termSymbol</a>.<a href="HasFlags.scala.html#48086" title="=&gt; Boolean">isSynthetic</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#66673" title="=&gt; Types.this.Type">normalize</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#66707" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#66673" title="=&gt; Types.this.Type">normalize</a>
        <span class="keyword">else</span>
          <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="66703">safeToString</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="133563">custom</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75538" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="#66702" title="=&gt; String">customToString</a>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#133563" title="String">custom</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span> <a href="#133563" title="String">custom</a>
      <span class="keyword">else</span> <a href="#66701" title="(rest: String)String">finishPrefix</a><span class="delimiter">(</span><a href="#66698" title="=&gt; String">preString</a> <span title="(x$1: Any)String">+</span> <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#48044" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <a href="#66699" title="=&gt; String">argsString</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="66704">prefixString</a> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span>
      <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75538" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a><span class="delimiter">)</span>
        <a href="#66707" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#42812" title="=&gt; String">prefixString</a>
      <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47828" title="=&gt; Boolean">isOmittablePrefix</a><span class="delimiter">)</span>
        <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47818" title="=&gt; Boolean">isPackageObjectOrClass</a><span class="delimiter">)</span>
        <a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47826" title="=&gt; Types.this.Symbol">skipPackageObject</a>.<a href="Symbols.scala.html#47897" title="=&gt; String">fullName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#66683" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="StdNames.scala.html#40560" title="object Types.this.nme">nme</a>.<a href="NameManglers.scala.html#60680" title="(name: Types.this.Name)Boolean">isSingletonName</a><span class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="StdNames.scala.html#40560" title="object Types.this.nme">nme</a>.<a href="NameManglers.scala.html#60698" title="(name: Types.this.Name)Types.this.TypeName">dropSingletonName</a><span title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd" class="delimiter">(</span><a href="#66725" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span> <span title="(other: String)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      <span class="keyword">else</span>
        <a href="#66707" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#42812" title="=&gt; String">prefixString</a>
    <span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="66705">kind</a> = <span title="String(&quot;TypeRef&quot;)" class="string">&quot;TypeRef&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.TypeRef" id="133769">TypeRef</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#8614" title="Types.this.TypeRefExtractor">TypeRefExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="66645">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="83326">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="83327">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="83328">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40229" title="(tp: Types.this.Type)Types.this.Type">unique</a><span class="delimiter">(</span><span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83328" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83327" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47759" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span>              <a href="#133624" title="Types.this.ArgsTypeRef with Types.this.AliasTypeRef" class="keyword">new</a> <a href="#40136" title="anonymous class $anon extends Types.this.ArgsTypeRef with Types.this.AliasTypeRef" id="133624">ArgsTypeRef</a><span class="delimiter">(</span><a href="#83326" title="Types.this.Type">pre</a>, <a href="#83327" title="Types.this.Symbol">sym</a>, <a href="#83328" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#40140" title="Types.this.AliasTypeRef">AliasTypeRef</a>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83327" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47760" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span>      <a href="#133648" title="Types.this.ArgsTypeRef with Types.this.AbstractTypeRef" class="keyword">new</a> <a href="#40136" title="anonymous class $anon extends Types.this.ArgsTypeRef with Types.this.AbstractTypeRef" id="133648">ArgsTypeRef</a><span class="delimiter">(</span><a href="#83326" title="Types.this.Type">pre</a>, <a href="#83327" title="Types.this.Symbol">sym</a>, <a href="#83328" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#40141" title="Types.this.AbstractTypeRef">AbstractTypeRef</a>
        <span class="keyword">else</span>                              <a href="#133672" title="Types.this.ArgsTypeRef with Types.this.ClassTypeRef" class="keyword">new</a> <a href="#40136" title="anonymous class $anon extends Types.this.ArgsTypeRef with Types.this.ClassTypeRef" id="133672">ArgsTypeRef</a><span class="delimiter">(</span><a href="#83326" title="Types.this.Type">pre</a>, <a href="#83327" title="Types.this.Symbol">sym</a>, <a href="#83328" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#40138" title="Types.this.ClassTypeRef">ClassTypeRef</a>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83327" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47759" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span>              <a href="#133696" title="Types.this.NoArgsTypeRef with Types.this.AliasTypeRef" class="keyword">new</a> <a href="#40137" title="anonymous class $anon extends Types.this.NoArgsTypeRef with Types.this.AliasTypeRef" id="133696">NoArgsTypeRef</a><span class="delimiter">(</span><a href="#83326" title="Types.this.Type">pre</a>, <a href="#83327" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#40140" title="Types.this.AliasTypeRef">AliasTypeRef</a>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83327" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47760" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span>      <a href="#133720" title="Types.this.NoArgsTypeRef with Types.this.AbstractTypeRef" class="keyword">new</a> <a href="#40137" title="anonymous class $anon extends Types.this.NoArgsTypeRef with Types.this.AbstractTypeRef" id="133720">NoArgsTypeRef</a><span class="delimiter">(</span><a href="#83326" title="Types.this.Type">pre</a>, <a href="#83327" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#40141" title="Types.this.AbstractTypeRef">AbstractTypeRef</a>
        <span class="keyword">else</span>                              <a href="#133744" title="Types.this.NoArgsTypeRef with Types.this.ClassTypeRef" class="keyword">new</a> <a href="#40137" title="anonymous class $anon extends Types.this.NoArgsTypeRef with Types.this.ClassTypeRef" id="133744">NoArgsTypeRef</a><span class="delimiter">(</span><a href="#83326" title="Types.this.Type">pre</a>, <a href="#83327" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#40138" title="Types.this.ClassTypeRef">ClassTypeRef</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** A class representing a method type with parameters.
   *  Note that a parameterless method is represented by a NullaryMethodType:
   *
   *    def m(): Int        MethodType(Nil, Int)
   *    def m: Int          NullaryMethodType(Int)
   */
  case <span class="keyword">class</span> <a title="class MethodType extends Types.this.Type with ScalaObject with Product with Serializable" id="66899">MethodType</a><a href="#66899" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="71280">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
                        <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="71281">resultType</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="66907">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#66908" title="=&gt; Boolean">isTrivial0</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#71281" title="=&gt; Types.this.Type">resultType</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#71281" title="=&gt; Types.this.Type">resultType</a>.<a href="#42822" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="66909">isTrivial0</a> =
      <a href="#71281" title="=&gt; Types.this.Type">resultType</a>.<a href="#42713" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span><span class="delimiter">{</span><a title="Types.this.Symbol" id="133840">p</a> =&gt; <a href="#133840" title="Types.this.Symbol">p</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>.<a href="#42713" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>  <span class="delimiter">(</span>
        /*!settings.YdepMethTpes.value ||*/ <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#133847" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>.<a href="#42793" title="(sym: Types.this.Symbol)Boolean">contains</a><span class="delimiter">(</span><a href="#133840" title="Types.this.Symbol">p</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#71281" title="=&gt; Types.this.Type">resultType</a>.<a href="#42793" title="(sym: Types.this.Symbol)Boolean">contains</a><span class="delimiter">(</span><a href="#133840" title="Types.this.Symbol">p</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="=&gt; Boolean" id="66910">isImplicit</a> = <a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="HasFlags.scala.html#48080" title="=&gt; Boolean">isImplicit</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="66911">isJava</a> = <span title="Boolean(false)" class="keyword">false</span> // can we do something like for implicits? I.e. do Java methods without parameters need to be recognized?

    //assert(paramTypes forall (pt =&gt; !pt.typeSymbol.isImplClass))//DEBUG
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="66912">paramSectionCount</a>: <span title="Int">Int</span> = <a href="#71281" title="=&gt; Types.this.Type">resultType</a>.<a href="#42748" title="=&gt; Int">paramSectionCount</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="66913">paramss</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a> <a href="#133878" title="(x: List[Types.this.Symbol])List[List[Types.this.Symbol]]">::</a> <a href="#71281" title="=&gt; Types.this.Type">resultType</a>.<a href="#42749" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="66914">paramTypes</a> = <a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#133907" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="66915">boundSyms</a> = <a href="#71281" title="=&gt; Types.this.Type">resultType</a>.<a href="#42753" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a> <span title="(elems: scala.collection.GenTraversableOnce[Types.this.Symbol])scala.collection.immutable.Set[Types.this.Symbol]">++</span> <a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(actuals: List[Types.this.Type])Types.this.Type" id="66916">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="133779">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#66907" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">||</span> <a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#71281" title="=&gt; Types.this.Type">resultType</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#133779" title="List[Types.this.Type]">actuals</a>, <a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.InstantiateDependentMap" id="133790">idm</a> = <span title="Types.this.InstantiateDependentMap" class="keyword">new</span> <a href="#40266" title="Types.this.InstantiateDependentMap">InstantiateDependentMap</a><span class="delimiter">(</span><a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#133779" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="133791">res</a> = <a href="#133801" title="(tp: Types.this.Type)Types.this.Type">idm</a><span class="delimiter">(</span><a href="#71281" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
        <a href="#40208" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#133790" title="Types.this.InstantiateDependentMap">idm</a>.<a href="#133802" title="=&gt; List[Types.this.Symbol]">existentialsNeeded</a>, <a href="#133791" title="Types.this.Type">res</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#40208" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#71281" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>

    // implicit args can only be depended on in result type: TODO this may be generalised so that the only constraint is dependencies are acyclic
    <span class="keyword">def</span> <a title="=&gt; Types.this.MethodType" id="66917">approximate</a>: <a href="#66899" title="Types.this.MethodType">MethodType</a> = <a href="#66899" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#42745" title="=&gt; Types.this.Type">resultApprox</a><span class="delimiter">)</span> // if (!settings.YdepMethTpes.value) this else

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="66918">finalResultType</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#71281" title="=&gt; Types.this.Type">resultType</a>.<a href="#42747" title="=&gt; Types.this.Type">finalResultType</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="66919">safeToString</a> = <a href="TypeDebugging.scala.html#40676" title="(tp: Types.this.Type)String">paramString</a><span class="delimiter">(</span><a href="#66899" title="Types.this.MethodType" class="keyword">this</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#71281" title="=&gt; Types.this.Type">resultType</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="66920">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="134012">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="134015">vparams</a> = <a href="Symbols.scala.html#40019" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)List[Types.this.Symbol]">cloneSymbolsAtOwner</a><span class="delimiter">(</span><a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#134012" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#40201" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#66899" title="Types.this.MethodType" class="keyword">this</a>, <a href="#134015" title="List[Types.this.Symbol]">vparams</a>, <a href="#71281" title="=&gt; Types.this.Type">resultType</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#134015" title="List[Types.this.Symbol]">vparams</a><span class="delimiter">)</span>.<a href="#42807" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#134012" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="66921">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="134026">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#134030" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#134026" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#71281" title="=&gt; Types.this.Type">resultType</a>.<a href="#42808" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#134026" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#71281" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#66920" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#134026" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <a href="#66899" title="Types.this.MethodType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="66922">kind</a> = <span title="String(&quot;MethodType&quot;)" class="string">&quot;MethodType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.MethodType" id="134089">MethodType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#8614" title="Types.this.MethodTypeExtractor">MethodTypeExtractor</a>

  <span class="keyword">class</span> <a title="class JavaMethodType extends Types.this.MethodType with ScalaObject" id="40148">JavaMethodType</a><a href="#40148" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="134099">ps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="134100">rt</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#66899" title="Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#134099" title="List[Types.this.Symbol]">ps</a>, <a href="#134100" title="Types.this.Type">rt</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="134095">isJava</a> = <span title="Boolean(true)" class="keyword">true</span>
  <span class="delimiter">}</span>

  case <span class="keyword">class</span> <a title="class NullaryMethodType extends Types.this.Type with ScalaObject with Product with Serializable" id="66963">NullaryMethodType</a><a href="#66963" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="72680">resultType</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="66968">isTrivial</a> = <a href="#72680" title="=&gt; Types.this.Type">resultType</a>.<a href="#42713" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#72680" title="=&gt; Types.this.Type">resultType</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#72680" title="=&gt; Types.this.Type">resultType</a>.<a href="#42822" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="66969">prefix</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#72680" title="=&gt; Types.this.Type">resultType</a>.<a href="#42738" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="66970">narrow</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#72680" title="=&gt; Types.this.Type">resultType</a>.<a href="#42735" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="66971">finalResultType</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#72680" title="=&gt; Types.this.Type">resultType</a>.<a href="#42747" title="=&gt; Types.this.Type">finalResultType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="66972">termSymbol</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="#72680" title="=&gt; Types.this.Type">resultType</a>.<a href="#42727" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="66973">typeSymbol</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="#72680" title="=&gt; Types.this.Type">resultType</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="66974">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#72680" title="=&gt; Types.this.Type">resultType</a>.<a href="#42737" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="66975">decls</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a> = <a href="#72680" title="=&gt; Types.this.Type">resultType</a>.<a href="#42760" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="66976">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#40512" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#72680" title="=&gt; Types.this.Type">resultType</a>.<a href="#42803" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="66977">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#72680" title="=&gt; Types.this.Type">resultType</a>.<a href="#42804" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="66978">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#72680" title="=&gt; Types.this.Type">resultType</a>.<a href="#42805" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="66979">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="134183">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#72680" title="=&gt; Types.this.Type">resultType</a>.<a href="#42777" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#134183" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="66980">boundSyms</a> = <a href="#72680" title="=&gt; Types.this.Type">resultType</a>.<a href="#42753" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="66981">isVolatile</a> = <a href="#72680" title="=&gt; Types.this.Type">resultType</a>.<a href="#42716" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="66982">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;=&gt; &quot;)" class="string">&quot;=&gt; &quot;</span><span title="(x$1: Any)String">+</span> <a href="#72680" title="=&gt; Types.this.Type">resultType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="66983">kind</a> = <span title="String(&quot;NullaryMethodType&quot;)" class="string">&quot;NullaryMethodType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.NullaryMethodType" id="134245">NullaryMethodType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#8614" title="Types.this.NullaryMethodTypeExtractor">NullaryMethodTypeExtractor</a>

  /** A type function or the type of a polymorphic value (and thus of kind *).
   *
   * Before the introduction of NullaryMethodType, a polymorphic nullary method (e.g, def isInstanceOf[T]: Boolean)
   * used to be typed as PolyType(tps, restpe), and a monomorphic one as PolyType(Nil, restpe)
   * This is now: PolyType(tps, NullaryMethodType(restpe)) and NullaryMethodType(restpe)
   * by symmetry to MethodTypes: PolyType(tps, MethodType(params, restpe)) and MethodType(params, restpe)
   *
   * Thus, a PolyType(tps, TypeRef(...)) unambiguously indicates a type function (which results from eta-expanding a type constructor alias).
   * Similarly, PolyType(tps, ClassInfoType(...)) is a type constructor.
   *
   * A polytype is of kind * iff its resultType is a (nullary) method type.
   */
  case <span class="keyword">class</span> <a title="class PolyType extends Types.this.Type with ScalaObject with Product with Serializable" id="67004">PolyType</a><a href="#67004" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="83548">typeParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="83549">resultType</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>
       <span class="keyword">extends</span> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    //assert(!(typeParams contains NoSymbol), this)
    <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#83548" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="=&gt; Boolean">nonEmpty</span>, <a href="#67004" title="Types.this.PolyType" class="keyword">this</a><span class="delimiter">)</span> // used to be a marker for nullary method type, illegal now (see @NullaryMethodType)

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="67012">paramSectionCount</a>: <span title="Int">Int</span> = <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42748" title="=&gt; Int">paramSectionCount</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="67013">paramss</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42749" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="67014">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42750" title="=&gt; List[Types.this.Symbol]">params</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="67015">paramTypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42751" title="=&gt; List[Types.this.Type]">paramTypes</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="67016">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42737" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="67017">decls</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a> = <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42760" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="67018">termSymbol</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42727" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="67019">typeSymbol</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="67020">boundSyms</a> = immutable.<span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#83548" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(that: scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">++</span> <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42753" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>: _*<span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="67021">prefix</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42738" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="67022">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#40512" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42803" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="67023">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42804" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="67024">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42805" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="67025">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="134384">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42777" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#134384" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="67026">narrow</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42735" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="67027">isVolatile</a> = <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42716" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="67028">finalResultType</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42747" title="=&gt; Types.this.Type">finalResultType</a>

    /** @M: typeDefSig wraps a TypeBounds in a PolyType
     *  to represent a higher-kinded type parameter
     *  wrap lo&amp;hi in polytypes to bind variables
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="67029">bounds</a>: <a href="#66864" title="Types.this.TypeBounds">TypeBounds</a> =
      <a href="#66838" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#40207" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#83548" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66878" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>,
                 <a href="#40207" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#83548" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="67030">isHigherKinded</a> = <span title="=&gt; Boolean">!</span><a href="#83548" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">isEmpty</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="67031">safeToString</a> = <a href="TypeDebugging.scala.html#40677" title="(tp: Types.this.Type)String">typeParamsString</a><span class="delimiter">(</span><a href="#67004" title="Types.this.PolyType" class="keyword">this</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#83549" title="=&gt; Types.this.Type">resultType</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.PolyType" id="67032">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="134434">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="134437">tparams</a> = <a href="Symbols.scala.html#40019" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)List[Types.this.Symbol]">cloneSymbolsAtOwner</a><span class="delimiter">(</span><a href="#83548" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#134434" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#67004" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#134437" title="List[Types.this.Symbol]">tparams</a>, <a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#83548" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#134437" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>.<a href="#42807" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#134434" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="67033">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="134444">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#83548" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#134453" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#134444" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#83549" title="=&gt; Types.this.Type">resultType</a>.<a href="#42808" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#134444" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#83549" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#67032" title="(owner: Types.this.Symbol)Types.this.PolyType">cloneInfo</a><span class="delimiter">(</span><a href="#134444" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <a href="#67004" title="Types.this.PolyType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="67034">kind</a> = <span title="String(&quot;PolyType&quot;)" class="string">&quot;PolyType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.PolyType" id="134512">PolyType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#8614" title="Types.this.PolyTypeExtractor">PolyTypeExtractor</a>
  
  /** A creator for existential types which flattens nested existentials.
   */
  <span class="keyword">def</span> <a title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type" id="40155">newExistentialType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="83947">quantified</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="83948">underlying</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83947" title="List[Types.this.Symbol]">quantified</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#83948" title="Types.this.Type">underlying</a>
    <span class="keyword">else</span> <a href="#83948" title="Types.this.Type">underlying</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="134513">qs</a>, <a title="Types.this.Type" id="134514">restpe</a><span class="delimiter">)</span> =&gt; <a href="#40155" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">(</span><a href="#83947" title="List[Types.this.Symbol]">quantified</a> <a href="#134515" title="(prefix: List[Types.this.Symbol])List[Types.this.Symbol]">:::</a> <a href="#134513" title="List[Types.this.Symbol]">qs</a>, <a href="#134514" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.ExistentialType">_</span>                           =&gt; <a href="#67120" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">ExistentialType</a><span class="delimiter">(</span><a href="#83947" title="List[Types.this.Symbol]">quantified</a>, <a href="#83948" title="Types.this.Type">underlying</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  case <span class="keyword">class</span> <a title="class ExistentialType extends Types.this.Type with Types.this.RewrappingTypeProxy with ScalaObject with Product with Serializable" id="67120">ExistentialType</a><a href="#67120" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="134523">quantified</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
                             <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="134524">underlying</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40079" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a>
  <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="67128">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="134533">newtp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#40208" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#134523" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#134533" title="Types.this.Type">newtp</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="67129">isTrivial</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="67130">isStable</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="67131">bounds</a> = <a href="#66838" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#134524" title="=&gt; Types.this.Type">underlying</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66878" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#134524" title="=&gt; Types.this.Type">underlying</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="67132">parents</a> = <a href="#134524" title="=&gt; Types.this.Type">underlying</a>.<a href="#42737" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="67133">boundSyms</a> = <a href="#134523" title="=&gt; List[Types.this.Symbol]">quantified</a>.<span title="scala.collection.immutable.Set[Types.this.Symbol]">toSet</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="67134">prefix</a> = <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#134524" title="=&gt; Types.this.Type">underlying</a>.<a href="#42738" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="67135">typeArgs</a> = <a href="#134524" title="=&gt; Types.this.Type">underlying</a>.<a href="#42741" title="=&gt; List[Types.this.Type]">typeArgs</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="67136">params</a> = <a href="#134524" title="=&gt; Types.this.Type">underlying</a>.<a href="#42750" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Symbol)List[Types.this.Symbol]">mapConserve</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="134667">param</a> =&gt;
      <span class="keyword">val</span> <a title="Types.this.Type" id="134668">tpe1</a> = <a href="#67128" title="(newtp: Types.this.Type)Types.this.Type">rewrap</a><span class="delimiter">(</span><a href="#134667" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#134668" title="Types.this.Type">tpe1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#134667" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span> <a href="#134667" title="Types.this.Symbol">param</a> <span class="keyword">else</span> <a href="#134667" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#47970" title="=&gt; Types.this.Symbol">cloneSymbol</a>.<a href="Symbols.scala.html#47922" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a><span class="delimiter">(</span><a href="#134668" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="67137">paramTypes</a> = <a href="#134524" title="=&gt; Types.this.Type">underlying</a>.<a href="#42751" title="=&gt; List[Types.this.Type]">paramTypes</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="67138">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="134728">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="134729">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
//      maybeRewrap(underlying.instantiateTypeParams(formals, actuals))

      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="134732">quantified1</a> = <span title="Types.this.SubstTypeMap" class="keyword">new</span> <a href="#40258" title="Types.this.SubstTypeMap">SubstTypeMap</a><span class="delimiter">(</span><a href="#134728" title="List[Types.this.Symbol]">formals</a>, <a href="#134729" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span> <a href="#82357" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a> <a href="#134523" title="=&gt; List[Types.this.Symbol]">quantified</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="134733">underlying1</a> = <a href="#134524" title="=&gt; Types.this.Type">underlying</a>.<a href="#42755" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#134728" title="List[Types.this.Symbol]">formals</a>, <a href="#134729" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#134732" title="List[Types.this.Symbol]">quantified1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#134523" title="=&gt; List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#134733" title="Types.this.Type">underlying1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#134524" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#67120" title="Types.this.ExistentialType" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#40208" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#134732" title="List[Types.this.Symbol]">quantified1</a>, <a href="#134733" title="Types.this.Type">underlying1</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#134523" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#134732" title="List[Types.this.Symbol]">quantified1</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="67139">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="134743">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#134524" title="=&gt; Types.this.Type">underlying</a>.<a href="#42777" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#134743" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="67140">baseTypeSeq</a> = <a href="#134524" title="=&gt; Types.this.Type">underlying</a>.<a href="#42803" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#60853" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">map</a> <a href="#59537" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="67141">isHigherKinded</a> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="67142">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="134757">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="134758">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span> =
      <a href="Symbols.scala.html#40016" title="(syms: List[Types.this.Symbol], symFn: Types.this.Symbol =&gt; Types.this.Symbol)(tpe: Types.this.Type)Types.this.Type">deriveType</a><span class="delimiter">(</span><a href="#134523" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a title="Types.this.Symbol" id="134764">tparam</a> =&gt; <span class="delimiter">(</span><a href="#134757" title="Types.this.Symbol">owner</a> <a href="Symbols.scala.html#48033" title="(alt: =&gt; Types.this.Symbol)Types.this.Symbol">orElse</a> <a href="#134764" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#47728" title="(basis: Types.this.Symbol, origin: AnyRef)Types.this.TypeSkolem">newExistentialSkolem</a><span class="delimiter">(</span><a href="#134764" title="Types.this.Symbol">tparam</a>, <a href="#134758" title="AnyRef">origin</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#134524" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(available: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]" id="67143">wildcardArgsString</a><span class="delimiter">(</span><a title="Set[Types.this.Symbol]" id="134769">available</a>: <span title="Set[Types.this.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="134770">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[String]">List</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="#134770" title="List[Types.this.Type]">args</a> <span title="List[String]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="List[String]">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="134776">sym</a>, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="134777">args1</a> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#134769" title="Set[Types.this.Symbol]">available</a> <span title="(elem: Types.this.Symbol)Boolean">contains</span> <a href="#134776" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> =&gt;
        <span class="delimiter">(</span><span title="String(&quot;_&quot;)" class="string">&quot;_&quot;</span><span title="(x$1: Any)String">+</span><a href="#134776" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#48051" title="(tp: Types.this.Type)String">infoString</a><span class="delimiter">(</span><a href="#134776" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#134780" title="(x: String)List[String]">::</a> <a href="#67143" title="(available: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]">wildcardArgsString</a><span class="delimiter">(</span><a href="#134769" title="Set[Types.this.Symbol]">available</a> <span title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">-</span> <a href="#134776" title="Types.this.Symbol">sym</a>, <a href="#134777" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="List[String]" id="134799">arg</a> :: <a title="List[Types.this.Type]" id="134800">args1</a> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#134523" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#134799" title="Types.this.Type">arg</a> <a href="#42793" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#134807" title="Types.this.Symbol">_</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <a href="#134799" title="Types.this.Type">arg</a>.<a href="#42813" title="()String">toString</a> <a href="#134809" title="(x: String)List[String]">::</a> <a href="#67143" title="(available: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]">wildcardArgsString</a><span class="delimiter">(</span><a href="#134769" title="Set[Types.this.Symbol]">available</a>, <a href="#134800" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="List[Nothing]">_</span> =&gt;
        List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="67144">safeToString</a>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#134523" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#134825" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#48062" title="=&gt; Boolean">isSingletonExistential</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75538" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a><span class="delimiter">)</span>
        // try to represent with wildcards first
        <a href="#134524" title="=&gt; Types.this.Type">underlying</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="134829">pre</a>, <a title="Types.this.Symbol" id="134830">sym</a>, <a title="List[Types.this.Type]" id="134831">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#134831" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">nonEmpty</span> =&gt;
            <span class="keyword">val</span> <a title="List[String]" id="134832">wargs</a> = <a href="#67143" title="(available: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]">wildcardArgsString</a><span class="delimiter">(</span><a href="#134523" title="=&gt; List[Types.this.Symbol]">quantified</a>.<span title="scala.collection.immutable.Set[Types.this.Symbol]">toSet</span>, <a href="#134831" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#134832" title="List[String]">wargs</a>, <a href="#134831" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span title="Nothing" class="keyword">return</span> <a href="#66645" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd" class="delimiter">(</span><a href="#134829" title="Types.this.Type">pre</a>, <a href="#134830" title="Types.this.Symbol">sym</a>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(other: String)String">+</span> <a href="#134832" title="List[String]">wargs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">var</span> <a title="String" id="134822">ustr</a> = <a href="#134524" title="=&gt; Types.this.Type">underlying</a>.<a href="#42813" title="()String">toString</a>
      <a href="#134524" title="=&gt; Types.this.Type">underlying</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Unit">MethodType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> | NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> | PolyType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#134822" title="String">ustr</a> = <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span><span title="(x$1: Any)String">+</span><a href="#134822" title="String">ustr</a><span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
        <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
      <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="String" id="134823">str</a> =
        <a href="#134822" title="String">ustr</a><span title="(x$1: Any)String">+</span><span class="delimiter">(</span><a href="#134523" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],String,List[String]])List[String]">map</span> <span class="delimiter">(</span><a href="#134867" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#48063" title="=&gt; String">existentialToString</a><span class="delimiter">)</span> <span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot; forSome { &quot;)" class="string">&quot; forSome { &quot;</span>, <span title="String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="String(&quot; }&quot;)" class="string">&quot; }&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75540" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">explaintypes</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span><span title="(x$1: Any)String">+</span><a href="#134823" title="String">str</a><span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <span class="keyword">else</span> <a href="#134823" title="String">str</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="67145">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="134905">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      <a href="Symbols.scala.html#40024" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol, tpe: Types.this.Type)(creator: (List[Types.this.Symbol], Types.this.Type) =&gt; Types.this.Type)Types.this.Type">createFromClonedSymbolsAtOwner</a><span class="delimiter">(</span><a href="#134523" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#134905" title="Types.this.Symbol">owner</a>, <a href="#134524" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#40155" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="67146">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="134921">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#134523" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#134925" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#134921" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#67145" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#134921" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#67120" title="Types.this.ExistentialType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="67147">kind</a> = <span title="String(&quot;ExistentialType&quot;)" class="string">&quot;ExistentialType&quot;</span>

    <span class="keyword">def</span> <a title="(op: Types.this.Type =&gt; Boolean)Boolean" id="67148">withTypeVars</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="134934">op</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#67149" title="(op: Types.this.Type =&gt; Boolean, depth: Int)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#134934" title="Types.this.Type =&gt; Boolean">op</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="(op: Types.this.Type =&gt; Boolean, depth: Int)Boolean" id="67149">withTypeVars</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="134940">op</a>: Type =&gt; Boolean, <a title="Int" id="134941">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="134943">quantifiedFresh</a> = <a href="Symbols.scala.html#40018" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#134523" title="=&gt; List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.TypeVar]" id="134944">tvars</a> = <a href="#134943" title="List[Types.this.Symbol]">quantifiedFresh</a> <span title="(f: Types.this.Symbol =&gt; Types.this.TypeVar)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.TypeVar,List[Types.this.TypeVar]])List[Types.this.TypeVar]">map</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="134963">tparam</a> =&gt; <a href="#84243" title="(tparam: Types.this.Symbol)Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#134963" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="134945">underlying1</a> = <a href="#134524" title="=&gt; Types.this.Type">underlying</a>.<a href="#42755" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#134523" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#134944" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span> // fuse subst quantified -&gt; quantifiedFresh -&gt; tvars
      <a href="#134940" title="(v1: Types.this.Type)Boolean">op</a><span class="delimiter">(</span><a href="#134945" title="Types.this.Type">underlying1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
        <a href="#40342" title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean, depth: Int)Boolean">solve</a><span class="delimiter">(</span><a href="#134944" title="List[Types.this.TypeVar]">tvars</a>, <a href="#134943" title="List[Types.this.Symbol]">quantifiedFresh</a>, <a href="#134943" title="List[Types.this.Symbol]">quantifiedFresh</a> <span title="(f: Types.this.Symbol =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Int,List[Int]])List[Int]">map</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="135023">x</a> =&gt; <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span>, <a href="#134941" title="Int">depth</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <a href="#40343" title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])Boolean">isWithinBounds</a><span class="delimiter">(</span><a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a>, <a href="#134943" title="List[Types.this.Symbol]">quantifiedFresh</a>, <a href="#134944" title="List[Types.this.TypeVar]">tvars</a> <span title="(f: Types.this.TypeVar =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeVar],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#135083" title="Types.this.TypeVar">_</a>.<a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84302" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.ExistentialType" id="135149">ExistentialType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#8614" title="Types.this.ExistentialTypeExtractor">ExistentialTypeExtractor</a>

  /** A class containing the alternatives and type prefix of an overloaded symbol.
   *  Not used after phase `typer`.
   */
  case <span class="keyword">class</span> <a title="class OverloadedType extends Types.this.Type with ScalaObject with Product with Serializable" id="146955">OverloadedType</a><a href="#146955" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="84040">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="84041">alternatives</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="84006">prefix</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#84040" title="=&gt; Types.this.Type">pre</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84007">safeToString</a> =
      <span class="delimiter">(</span><a href="#84041" title="=&gt; List[Types.this.Symbol]">alternatives</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#84040" title="=&gt; Types.this.Type">pre</a>.<a href="#42780" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="String(&quot; &lt;and&gt; &quot;)" class="string">&quot; &lt;and&gt; &quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84008">kind</a> = <span title="String(&quot;OverloadedType&quot;)" class="string">&quot;OverloadedType&quot;</span>
  <span class="delimiter">}</span>

  /** A class remembering a type instantiation for some a set of overloaded
   *  polymorphic symbols.
   *  Not used after phase `typer`.
   */
  case <span class="keyword">class</span> <a title="class AntiPolyType extends Types.this.Type with ScalaObject with Product with Serializable" id="146951">AntiPolyType</a><a href="#146951" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="84137">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="List[Types.this.Type]" id="84138">targs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84103">safeToString</a> =
      <a href="#84137" title="=&gt; Types.this.Type">pre</a>.<a href="#42813" title="()String">toString</a> <span title="(x$1: Any)String">+</span> <a href="#84138" title="=&gt; List[Types.this.Type]">targs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;(with type arguments &quot;)" class="string">&quot;(with type arguments &quot;</span>, <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="84104">memberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="135253">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#40204" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#84137" title="=&gt; Types.this.Type">pre</a>.<a href="#42780" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#135253" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>, <a href="#84138" title="=&gt; List[Types.this.Type]">targs</a><span class="delimiter">)</span>
//     override def memberType(sym: Symbol) = pre.memberType(sym) match {
//       case PolyType(tparams, restp) =&gt;
//         restp.subst(tparams, targs)
// /* I don't think this is needed, as existential types close only over value types
//       case ExistentialType(tparams, qtpe) =&gt;
//         existentialAbstraction(tparams, qtpe.memberType(sym))
// */
//       case ErrorType =&gt;
//         ErrorType
//     }
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84105">kind</a> = <span title="String(&quot;AntiPolyType&quot;)" class="string">&quot;AntiPolyType&quot;</span>
  <span class="delimiter">}</span>

  //private var tidCount = 0  //DEBUG

  <span class="keyword">object</span> <a title="object Types.this.HasTypeMember" id="40165">HasTypeMember</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(name: Types.this.TypeName, tp: Types.this.Type)Types.this.Type" id="135297">apply</a><span class="delimiter">(</span><a title="Types.this.TypeName" id="135300">name</a>: <a href="Names.scala.html#39686" title="Types.this.TypeName">TypeName</a>, <a title="Types.this.Type" id="135301">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="135303">bound</a> = <a href="#40196" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><span title="(xs: Types.this.WildcardType.type*)List[Types.this.WildcardType.type]">List</span><span class="delimiter">(</span><a href="#130739" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span>, <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="135304">bsym</a> = <a href="#135303" title="Types.this.Type">bound</a>.<a href="#42728" title="Types.this.Symbol" id="135323">typeSymbol</a>.<a href="Symbols.scala.html#75650" title="Types.this.Position" id="135326">newAliasType</a><span class="delimiter">(</span><a href="#135300" title="Types.this.TypeName" id="135324">name</a><span class="delimiter">)</span>
      <a href="#135304" title="Types.this.Symbol">bsym</a> <a href="Symbols.scala.html#47922" title="(info: Types.this.Type)bsym.type">setInfo</a> <a href="#135301" title="Types.this.Type">tp</a>
      <a href="#135303" title="Types.this.Type">bound</a>.<a href="#42760" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#61752" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#135304" title="Types.this.Symbol">bsym</a>
      <a href="#135303" title="Types.this.Type">bound</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Option[(Types.this.TypeName, Types.this.Type)]" id="135298">unapply</a><span class="delimiter">(</span><a title="Types.this.Type" id="135329">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Option[(Types.this.TypeName, Types.this.Type)]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>TypeName, Type<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#135329" title="Types.this.Type">tp</a> <span title="Option[(Types.this.TypeName, Types.this.Type)]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Some[(Types.this.TypeName, Types.this.Type)]">RefinedType</span><span class="delimiter">(</span><a href="#135332" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><a href="#130739" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span>, <a href="Scopes.scala.html#71173" title="(decls: Types.this.Scope)Some[Seq[Types.this.Symbol]]">Scope</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="135346">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span title="(x: (Types.this.TypeName, Types.this.Type))Some[(Types.this.TypeName, Types.this.Type)]">Some</span><span class="delimiter">(</span><span title="(_1: Types.this.TypeName, _2: Types.this.Type)(Types.this.TypeName, Types.this.Type)" class="delimiter">(</span><a href="#135346" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#53413" title="=&gt; Types.this.TypeName">toTypeName</a>, <a href="#135346" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="None.type">_</span> =&gt; <span title="object None">None</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  // Not used yet.
  <span class="keyword">object</span> <a title="object Types.this.HasTypeParams" id="40167">HasTypeParams</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Option[(List[Types.this.Symbol], Types.this.Type)]" id="135358">unapply</a><span class="delimiter">(</span><a title="Types.this.Type" id="135360">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Option[(List[Types.this.Symbol], Types.this.Type)]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, Type<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#135360" title="Types.this.Type">tp</a> <span title="Option[(List[Types.this.Symbol], Types.this.Type)]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Option[(List[Types.this.Symbol], Types.this.Type)]">AnnotatedType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="135362">tp</a>, _<span class="delimiter">)</span>        =&gt; <a href="#135358" title="(tp: Types.this.Type)Option[(List[Types.this.Symbol], Types.this.Type)]">unapply</a><span class="delimiter">(</span><a href="#135362" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Some[(List[Types.this.Symbol], Types.this.Type)]">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="135363">tparams</a>, <a title="Types.this.Type" id="135364">qtpe</a><span class="delimiter">)</span> =&gt; <span title="(x: (List[Types.this.Symbol], Types.this.Type))Some[(List[Types.this.Symbol], Types.this.Type)]">Some</span><span class="delimiter">(</span><span title="(_1: List[Types.this.Symbol], _2: Types.this.Type)(List[Types.this.Symbol], Types.this.Type)" class="delimiter">(</span><a href="#135363" title="List[Types.this.Symbol]">tparams</a>, <a href="#135364" title="Types.this.Type">qtpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Some[(List[Types.this.Symbol], Types.this.Type)]">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="135374">tparams</a>, <a title="Types.this.Type" id="135375">restpe</a><span class="delimiter">)</span>      =&gt; <span title="(x: (List[Types.this.Symbol], Types.this.Type))Some[(List[Types.this.Symbol], Types.this.Type)]">Some</span><span class="delimiter">(</span><span title="(_1: List[Types.this.Symbol], _2: Types.this.Type)(List[Types.this.Symbol], Types.this.Type)" class="delimiter">(</span><a href="#135374" title="List[Types.this.Symbol]">tparams</a>, <a href="#135375" title="Types.this.Type">restpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="None.type">_</span>                              =&gt; <span title="object None">None</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  //@M
  // a TypeVar used to be a case class with only an origin and a constr
  // then, constr became mutable (to support UndoLog, I guess),
  // but pattern-matching returned the original constr0 (a bug)
  // now, pattern-matching returns the most recent constr
  <span class="keyword">object</span> <a title="object Types.this.TypeVar" id="40169">TypeVar</a> <span title="ScalaObject" class="delimiter">{</span>
    @inline <span class="keyword">final</span> <span class="keyword">def</span> <a title="[T](action: String, msg: =&gt; String)(value: T)T" id="84237">trace</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="84239">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="135388">action</a>: <span title="String">String</span>, <a title="=&gt; String" id="135389">msg</a>: =&gt; String<span class="delimiter">)</span><span class="delimiter">(</span><a title="T" id="135390">value</a>: <a href="#84239" title="T">T</a><span class="delimiter">)</span>: <a href="#84239" title="T">T</a> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#40059" title="=&gt; Boolean">traceTypeVars</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="String" id="135393">s</a> = <a href="#135389" title="=&gt; String">msg</a> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>   =&gt; <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
          <span class="keyword">case</span> <a title="String" id="135394">str</a>  =&gt; <span title="String(&quot;( &quot;)" class="string">&quot;( &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#135394" title="String">str</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; )&quot;)" class="string">&quot; )&quot;</span>
        <span class="delimiter">}</span>
        <span title="object Console">Console</span>.<span title="=&gt; java.io.PrintStream">err</span>.<span title="(x$1: String)Unit">println</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;[%10s] %-25s%s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#135388" title="String">action</a>, <a href="#135390" title="T">value</a>, <a href="#135393" title="String">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#135390" title="T">value</a>
    <span class="delimiter">}</span>

    /** Create a new TypeConstraint based on the given symbol.
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Types.this.TypeConstraint" id="84240">deriveConstraint</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="135402">tparam</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40237" title="Types.this.TypeConstraint">TypeConstraint</a> = <span class="delimiter">{</span>
      /** Must force the type parameter's info at this point
       *  or things don't end well for higher-order type params.
       *  See SI-5359.
       */
      <span class="keyword">val</span> <a title="Types.this.TypeBounds" id="135404">bounds</a>  = <a href="#135402" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>
      /** We can seed the type constraint with the type parameter
       *  bounds as long as the types are concrete.  This should lower
       *  the complexity of the search even if it doesn't improve
       *  any results.
       */
      <span title="Types.this.TypeConstraint" class="keyword">if</span> <span class="delimiter">(</span><a href="#40063" title="=&gt; Boolean">propagateParameterBoundsToTypeVars</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Boolean" id="135405">exclude</a> = <a href="#135404" title="Types.this.TypeBounds">bounds</a>.<a href="#66860" title="=&gt; Boolean">isEmptyBounds</a> <span title="(x: Boolean)Boolean">||</span> <a href="#135404" title="Types.this.TypeBounds">bounds</a>.<a href="#42792" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#135408" title="Types.this.Type">_</a>.<a href="#42730" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>.<a href="Symbols.scala.html#47762" title="=&gt; Boolean">isNonClassType</a><span class="delimiter">)</span>

        <span title="Types.this.TypeConstraint" class="keyword">if</span> <span class="delimiter">(</span><a href="#135405" title="Boolean">exclude</a><span class="delimiter">)</span> <a href="#84278" title="()Types.this.TypeConstraint" class="keyword">new</a> <a href="#40237" title="Types.this.TypeConstraint">TypeConstraint</a>
        <span class="keyword">else</span> <a href="#40169" title="object Types.this.TypeVar">TypeVar</a>.<a href="#84237" title="(action: String, msg: =&gt; String)(value: Types.this.TypeConstraint)Types.this.TypeConstraint">trace</a><span class="delimiter">(</span><span title="String(&quot;constraint&quot;)" class="string">&quot;constraint&quot;</span>, <span title="String(&quot;For &quot;)" class="string">&quot;For &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#135402" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#48049" title="=&gt; String">fullLocationString</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#84277" title="(bounds: Types.this.TypeBounds)Types.this.TypeConstraint" class="keyword">new</a> <a href="#40237" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">(</span><a href="#135404" title="Types.this.TypeBounds">bounds</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#84278" title="()Types.this.TypeConstraint" class="keyword">new</a> <a href="#40237" title="Types.this.TypeConstraint">TypeConstraint</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]" id="84241">unapply</a><span class="delimiter">(</span><a title="Types.this.TypeVar" id="128383">tv</a>: <a href="#40176" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">)</span>: <span title="Some[(Types.this.Type, Types.this.TypeConstraint)]">Some</span><span class="delimiter">[</span><span class="delimiter">(</span>Type, TypeConstraint<span class="delimiter">)</span><span class="delimiter">]</span>   = <span title="(x: (Types.this.Type, Types.this.TypeConstraint))Some[(Types.this.Type, Types.this.TypeConstraint)]">Some</span><span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.TypeConstraint)(Types.this.Type, Types.this.TypeConstraint)" class="delimiter">(</span><a href="#128383" title="Types.this.TypeVar">tv</a>.<a href="#135385" title="=&gt; Types.this.Type">origin</a>, <a href="#128383" title="Types.this.TypeVar">tv</a>.<a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(origin: Types.this.Type, constr: Types.this.TypeConstraint)Types.this.TypeVar" id="84242">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="84254">origin</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.TypeConstraint" id="84255">constr</a>: <a href="#40237" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">)</span>: <a href="#40176" title="Types.this.TypeVar">TypeVar</a> = <a href="#84244" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">apply</a><span class="delimiter">(</span><a href="#84254" title="Types.this.Type">origin</a>, <a href="#84255" title="Types.this.TypeConstraint">constr</a>, <span title="object Nil">Nil</span>, <span title="object Nil">Nil</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Types.this.TypeVar" id="84243">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="84252">tparam</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40176" title="Types.this.TypeVar">TypeVar</a>                       = <a href="#84244" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">apply</a><span class="delimiter">(</span><a href="#84252" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47919" title="=&gt; Types.this.Type">tpeHK</a>, <a href="#84240" title="(tparam: Types.this.Symbol)Types.this.TypeConstraint">deriveConstraint</a><span class="delimiter">(</span><a href="#84252" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span>, <span title="object Nil">Nil</span>, <a href="#84252" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span>

    /** This is the only place TypeVars should be instantiated.
     */
    <span class="keyword">def</span> <a title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar" id="84244">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="84247">origin</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.TypeConstraint" id="84248">constr</a>: <a href="#40237" title="Types.this.TypeConstraint">TypeConstraint</a>, <a title="List[Types.this.Type]" id="84249">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="84250">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40176" title="Types.this.TypeVar">TypeVar</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.TypeVar" id="135438">tv</a> = <span class="delimiter">(</span>
        <span title="Types.this.TypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#84249" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#84250" title="List[Types.this.Symbol]">params</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>   <span title="Types.this.TypeVar" class="keyword">new</span> <a href="#40176" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#84247" title="Types.this.Type">origin</a>, <a href="#84248" title="Types.this.TypeConstraint">constr</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Types.this.TypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#84249" title="List[Types.this.Type]">args</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">==</span> <a href="#84250" title="List[Types.this.Symbol]">params</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>    <span title="Types.this.AppliedTypeVar" class="keyword">new</span> <a href="#40175" title="Types.this.AppliedTypeVar">AppliedTypeVar</a><span class="delimiter">(</span><a href="#84247" title="Types.this.Type">origin</a>, <a href="#84248" title="Types.this.TypeConstraint">constr</a>, <a href="#84250" title="List[Types.this.Symbol]">params</a> <span title="(that: scala.collection.GenIterable[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],(Types.this.Symbol, Types.this.Type),List[(Types.this.Symbol, Types.this.Type)]])List[(Types.this.Symbol, Types.this.Type)]">zip</span> <a href="#84249" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Types.this.HKTypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#84249" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>                <span title="Types.this.HKTypeVar" class="keyword">new</span> <a href="#40174" title="Types.this.HKTypeVar">HKTypeVar</a><span class="delimiter">(</span><a href="#84247" title="Types.this.Type">origin</a>, <a href="#84248" title="Types.this.TypeConstraint">constr</a>, <a href="#84250" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <a href="#67275" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#40384" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;Invalid TypeVar construction: &quot;)" class="string">&quot;Invalid TypeVar construction: &quot;</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.TypeConstraint, _3: List[Types.this.Type], _4: List[Types.this.Symbol])(Types.this.Type, Types.this.TypeConstraint, List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</span><a href="#84247" title="Types.this.Type">origin</a>, <a href="#84248" title="Types.this.TypeConstraint">constr</a>, <a href="#84249" title="List[Types.this.Type]">args</a>, <a href="#84250" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">)</span>
      
      <a href="#84237" title="(action: String, msg: =&gt; String)(value: Types.this.TypeVar)Types.this.TypeVar">trace</a><span class="delimiter">(</span><span title="String(&quot;create&quot;)" class="string">&quot;create&quot;</span>, <span title="String(&quot;In &quot;)" class="string">&quot;In &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#135438" title="Types.this.TypeVar">tv</a>.<a href="#84230" title="=&gt; String">originLocation</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#135438" title="Types.this.TypeVar">tv</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  // TODO: I don't really know why this happens -- maybe because
  // the owner hierarchy changes? the other workaround (besides
  // repackExistential) is to explicitly pass expectedTp as the type
  // argument for the call to guard, but repacking the existential
  // somehow feels more robust
  //
  // TODO: check if optimization makes a difference, try something else
  // if necessary (cache?)

  /** Repack existential types, otherwise they sometimes get unpacked in the
   *  wrong location (type inference comes up with an unexpected skolem)
   */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="40171">repackExistential</a><span class="delimiter">(</span><a title="Types.this.Type" id="135833">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">(</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#135833" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <a href="#135833" title="Types.this.Type">tp</a>
    <span class="keyword">else</span> <a href="#40208" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#40173" title="(tpe: Types.this.Type)List[Types.this.Symbol]">existentialsInType</a><span class="delimiter">(</span><a href="#135833" title="Types.this.Type">tp</a><span class="delimiter">)</span>, <a href="#135833" title="Types.this.Type">tp</a><span class="delimiter">)</span>
  <span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(tpe: Types.this.Type)Boolean" id="40172">containsExistential</a><span class="delimiter">(</span><a title="Types.this.Type" id="135849">tpe</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
    <a href="#135849" title="Types.this.Type">tpe</a> <a href="#42792" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#135854" title="Types.this.Type">_</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47770" title="=&gt; Boolean">isExistentiallyBound</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tpe: Types.this.Type)List[Types.this.Symbol]" id="40173">existentialsInType</a><span class="delimiter">(</span><a title="Types.this.Type" id="135839">tpe</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
    <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="135847">tp</a> &lt;- <a href="#129906" title="(f: Types.this.Type =&gt; Types.this.Symbol)List[Types.this.Symbol]">tpe</a> ; <span class="keyword">if</span> <a href="#135847" title="Types.this.Type">tp</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47770" title="=&gt; Boolean">isExistentiallyBound</a><span class="delimiter">)</span> <span class="keyword">yield</span>
      <a href="#135847" title="Types.this.Type">tp</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>
  <span class="delimiter">)</span>

  /** Precondition: params.nonEmpty.  (args.nonEmpty enforced structurally.)
   */
  <span class="keyword">class</span> <a title="class HKTypeVar extends Types.this.TypeVar with ScalaObject" id="40174">HKTypeVar</a><a href="#40174" title="ScalaObject" class="delimiter">(</a>
    <a title="Types.this.Type" id="135528">_origin</a>: <a href="#40083" title="Types.this.Type">Type</a>,
    <a title="Types.this.TypeConstraint" id="135529">_constr</a>: <a href="#40237" title="Types.this.TypeConstraint">TypeConstraint</a>,
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="135530">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
  <span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40176" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#135528" title="Types.this.Type">_origin</a>, <a href="#135529" title="Types.this.TypeConstraint">_constr</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#135530" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Boolean">nonEmpty</span>, <a href="#40174" title="Types.this.HKTypeVar" class="keyword">this</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="135526">isHigherKinded</a>          = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; String" id="135527">typeVarString</a> = <a href="#135530" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="(f: Types.this.Symbol =&gt; Types.this.Name)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Name,List[Types.this.Name]])List[Types.this.Name]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.Name,List[Types.this.Name]]" class="delimiter">(</span><a href="#135886" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;]=&gt;&quot;)" class="string">&quot;]=&gt;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#84229" title="=&gt; String">originName</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  /** Precondition: zipped params/args nonEmpty.  (Size equivalence enforced structurally.)
   */
  <span class="keyword">class</span> <a title="class AppliedTypeVar extends Types.this.TypeVar with ScalaObject" id="40175">AppliedTypeVar</a><a href="#40175" title="ScalaObject" class="delimiter">(</a>
    <a title="Types.this.Type" id="135454">_origin</a>: <a href="#40083" title="Types.this.Type">Type</a>,
    <a title="Types.this.TypeConstraint" id="135455">_constr</a>: <a href="#40237" title="Types.this.TypeConstraint">TypeConstraint</a>,
    <a title="List[(Types.this.Symbol, Types.this.Type)]" id="135456">zippedArgs</a>: <span title="List[(Types.this.Symbol, Types.this.Type)]">List</span><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Type<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40176" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#135454" title="Types.this.Type">_origin</a>, <a href="#135455" title="Types.this.TypeConstraint">_constr</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#135456" title="List[(Types.this.Symbol, Types.this.Type)]">zippedArgs</a>.<span title="=&gt; Boolean">nonEmpty</span>, <a href="#40175" title="Types.this.AppliedTypeVar" class="keyword">this</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="135451">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#135456" title="List[(Types.this.Symbol, Types.this.Type)]">zippedArgs</a> <span title="(f: ((Types.this.Symbol, Types.this.Type)) =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Symbol, Types.this.Type)],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <span class="delimiter">(</span><a href="#135939" title="(Types.this.Symbol, Types.this.Type)">_</a>.<span title="=&gt; Types.this.Symbol">_1</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="135452">typeArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#135456" title="List[(Types.this.Symbol, Types.this.Type)]">zippedArgs</a> <span title="(f: ((Types.this.Symbol, Types.this.Type)) =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Symbol, Types.this.Type)],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#135977" title="(Types.this.Symbol, Types.this.Type)">_</a>.<span title="=&gt; Types.this.Type">_2</span><span class="delimiter">)</span>
    
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; String" id="135453">typeVarString</a> = <span class="delimiter">(</span>
      <a href="#135456" title="List[(Types.this.Symbol, Types.this.Type)]">zippedArgs</a> <span title="(f: ((Types.this.Symbol, Types.this.Type)) =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Symbol, Types.this.Type)],String,List[String]])List[String]">map</span> <a href="#136018" title="String" class="delimiter">{</a> <span class="keyword">case</span> <span title="String" class="delimiter">(</span><a title="Types.this.Symbol" id="136021">p</a>, <a title="Types.this.Type" id="136022">a</a><span class="delimiter">)</span> =&gt; <a href="#136021" title="Types.this.Symbol">p</a>.<a href="Symbols.scala.html#47883" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">name</a> <span title="(other: String)String">+</span> <span title="String(&quot;=&quot;)" class="string">&quot;=&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#136022" title="Types.this.Type">a</a> <span class="delimiter">}</span> <span title="(start: String, sep: String, end: String)String">mkString</span> <span class="delimiter">(</span><a href="#135385" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">origin</a> <span title="(other: String)String">+</span> <span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  /** A class representing a type variable: not used after phase `typer`.
   *
   *  A higher-kinded TypeVar has params (Symbols) and typeArgs (Types).
   *  A TypeVar with nonEmpty typeArgs can only be instantiated by a higher-kinded
   *  type that can be applied to those args.  A TypeVar is much like a TypeRef,
   *  except it has special logic for equality and subtyping.
   *
   *  Precondition for this class, enforced structurally: args.isEmpty &amp;&amp; params.isEmpty.
   */
  <span class="keyword">class</span> <a title="class TypeVar extends Types.this.Type with ScalaObject" id="40176">TypeVar</a><a href="#40176" title="ScalaObject" class="delimiter">(</a>
    <span class="keyword">val</span> <a title="Types.this.Type" id="135385">origin</a>: <a href="#40083" title="Types.this.Type">Type</a>,
    <span class="keyword">val</span> <a title="Types.this.TypeConstraint" id="135386">constr0</a>: <a href="#40237" title="Types.this.TypeConstraint">TypeConstraint</a>
  <span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="84198">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span title="object Nil">Nil</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="84199">typeArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="object Nil">Nil</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="84200">isHigherKinded</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** The constraint associated with the variable */
    <span class="keyword">var</span> <a title="Types.this.TypeConstraint" id="84202">constr</a> = <a href="#135386" title="=&gt; Types.this.TypeConstraint">constr0</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="84204">instValid</a> = <a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84304" title="=&gt; Boolean">instValid</a>

    /** The variable's skolemization level */
    <span class="keyword">val</span> <a title="Int" id="84205">level</a> = <a href="#40072" title="=&gt; Int">skolemizationLevel</a>
    
    /** Two occurrences of a higher-kinded typevar, e.g. `?CC[Int]` and `?CC[String]`, correspond to
     *  ''two instances'' of `TypeVar` that share the ''same'' `TypeConstraint`.
     *
     *  `constr` for `?CC` only tracks type constructors anyway,
     *   so when `?CC[Int] &lt;:&lt; List[Int]` and `?CC[String] &lt;:&lt; Iterable[String]`
     *  `?CC's` hibounds contains List and Iterable.
     */
    <span class="keyword">def</span> <a title="(newArgs: List[Types.this.Type])Types.this.TypeVar" id="84207">applyArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="136064">newArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40176" title="Types.this.TypeVar">TypeVar</a> = <span class="delimiter">(</span>
      <span title="Types.this.TypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#136064" title="List[Types.this.Type]">newArgs</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#84199" title="=&gt; List[Types.this.Type]">typeArgs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
        <a href="#40176" title="Types.this.TypeVar" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.TypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#136064" title="List[Types.this.Type]">newArgs</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">==</span> <a href="#84198" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.TypeVar" id="136073">tv</a> = <a href="#84244" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#135385" title="=&gt; Types.this.Type">origin</a>, <a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>, <a href="#136064" title="List[Types.this.Type]">newArgs</a>, <a href="#84198" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
        <a href="#40169" title="object Types.this.TypeVar">TypeVar</a>.<a href="#84237" title="(action: String, msg: =&gt; String)(value: Types.this.TypeVar)Types.this.TypeVar">trace</a><span class="delimiter">(</span><span title="String(&quot;applyArgs&quot;)" class="string">&quot;applyArgs&quot;</span>, <span title="String(&quot;In &quot;)" class="string">&quot;In &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#84230" title="=&gt; String">originLocation</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, apply args &quot;)" class="string">&quot;, apply args &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#136064" title="List[Types.this.Type]">newArgs</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; to &quot;)" class="string">&quot; to &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#84229" title="=&gt; String">originName</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#136073" title="Types.this.TypeVar">tv</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span>
        <span title="Nothing" class="keyword">throw</span> <a href="#67275" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#40384" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;Invalid type application in TypeVar: &quot;)" class="string">&quot;Invalid type application in TypeVar: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#84198" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#136064" title="List[Types.this.Type]">newArgs</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    // newArgs.length may differ from args.length (could've been empty before)
    //
    // !!! @PP - I need an example of this, since this exception never triggers
    // even though I am requiring the size match.
    //
    // example: when making new typevars, you start out with C[A], then you replace C by ?C, which should yield ?C[A], then A by ?A, ?C[?A]
    // we need to track a TypeVar's arguments, and map over them (see TypeMap::mapOver)
    // TypeVars get applied to different arguments over time (in asSeenFrom)
     // -- see pos/tcpoly_infer_implicit_tuplewrapper.scala
    // thus: make new TypeVar's for every application of a TV to args,
    // inference may generate several TypeVar's for a single type parameter that must be inferred,
    // only one of them is in the set of tvars that need to be solved, but
    // they share the same TypeConstraint instance
    
    // When comparing to types containing skolems, remember the highest level
    // of skolemization. If that highest level is higher than our initial
    // skolemizationLevel, we can't re-use those skolems as the solution of this
    // typevar, which means we'll need to repack our constr.inst into a fresh
    // existential.
    // were we compared to skolems at a higher skolemizationLevel?
    // EXPERIMENTAL: value will not be considered unless enableTypeVarExperimentals is true
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Boolean" id="84209">encounteredHigherLevel</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="84211">shouldRepackType</a> = <a href="#40065" title="=&gt; Boolean">enableTypeVarExperimentals</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#84209" title="=&gt; Boolean">encounteredHigherLevel</a>

    // &lt;region name=&quot;constraint mutators + undoLog&quot;&gt;
    // invariant: before mutating constr, save old state in undoLog
    // (undoLog is used to reset constraints to avoid piling up unrelated ones)
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="84212">setInst</a><span class="delimiter">(</span><a title="Types.this.Type" id="136093">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
//      assert(!(tp containsTp this), this)
      <a href="#40074" title="object Types.this.undoLog">undoLog</a> <a href="#128916" title="(tv: Types.this.TypeVar)Unit">record</a> <a href="#40176" title="Types.this.TypeVar" class="keyword">this</a>
      // if we were compared against later typeskolems, repack the existential,
      // because skolems are only compatible if they were created at the same level
      <span class="keyword">val</span> <a title="Types.this.Type" id="136095">res</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#84211" title="=&gt; Boolean">shouldRepackType</a><span class="delimiter">)</span> <a href="#40171" title="(tp: Types.this.Type)Types.this.Type">repackExistential</a><span class="delimiter">(</span><a href="#136093" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#136093" title="Types.this.Type">tp</a>
      <a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84302" title="(x$1: Types.this.Type)Unit">inst</a> = <a href="#40169" title="object Types.this.TypeVar">TypeVar</a>.<a href="#84237" title="(action: String, msg: =&gt; String)(value: Types.this.Type)Types.this.Type">trace</a><span class="delimiter">(</span><span title="String(&quot;setInst&quot;)" class="string">&quot;setInst&quot;</span>, <span title="String(&quot;In &quot;)" class="string">&quot;In &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#84230" title="=&gt; String">originLocation</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#84229" title="=&gt; String">originName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;=&quot;)" class="string">&quot;=&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#136095" title="Types.this.Type">res</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#136095" title="Types.this.Type">res</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="84213">addLoBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="136102">tp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Boolean" id="136105">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#136102" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#40176" title="Types.this.TypeVar" class="keyword">this</a>, <a href="#136102" title="Types.this.Type">tp</a><span class="delimiter">)</span> // implies there is a cycle somewhere (?)
      //println(&quot;addLoBound: &quot;+(safeToString, debugString(tp))) //DEBUG
      <a href="#40074" title="object Types.this.undoLog">undoLog</a> <a href="#128916" title="(tv: Types.this.TypeVar)Unit">record</a> <a href="#40176" title="Types.this.TypeVar" class="keyword">this</a>
      <a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84297" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a><span class="delimiter">(</span><a href="#136102" title="Types.this.Type">tp</a>, <a href="#136105" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="84214">addHiBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="136116">tp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Boolean" id="136119">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      // assert(tp != this)
      //println(&quot;addHiBound: &quot;+(safeToString, debugString(tp))) //DEBUG
      <a href="#40074" title="object Types.this.undoLog">undoLog</a> <a href="#128916" title="(tv: Types.this.TypeVar)Unit">record</a> <a href="#40176" title="Types.this.TypeVar" class="keyword">this</a>
      <a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84299" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a><span class="delimiter">(</span><a href="#136116" title="Types.this.Type">tp</a>, <a href="#136119" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    // &lt;/region&gt;

    // ignore subtyping&amp;equality checks while true -- see findMember
    <span class="keyword">private</span><span class="delimiter">[</span>Types<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Boolean" id="84216">suspended</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Called when a TypeVar is involved in a subtyping check.  Result is whether
     *  this TypeVar could plausibly be a [super/sub]type of argument `tp` and if so,
     *  tracks tp as a [lower/upper] bound of this TypeVar.
     *
     *  if (isLowerBound)   this typevar could be a subtype, track tp as a lower bound
     *  if (!isLowerBound)  this typevar could be a supertype, track tp as an upper bound
     *
     *  If isNumericBound is true, the subtype check is performed with weak_&lt;:&lt; instead of &lt;:&lt;.
     */
    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean" id="84218">registerBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="130156">tp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Boolean" id="130157">isLowerBound</a>: <span title="Boolean">Boolean</span>, <a title="Boolean" id="130160">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      // println(&quot;regBound: &quot;+(safeToString, debugString(tp), isLowerBound)) //@MDEBUG
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130157" title="Boolean">isLowerBound</a><span class="delimiter">)</span>
        <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#130156" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#40176" title="Types.this.TypeVar" class="keyword">this</a><span class="delimiter">)</span>

      // side effect: adds the type to upper or lower bounds
      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="136124">addBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="136134">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130157" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#84213" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a><span class="delimiter">(</span><a href="#136134" title="Types.this.Type">tp</a>, <a href="#130160" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#84214" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a><span class="delimiter">(</span><a href="#136134" title="Types.this.Type">tp</a>, <a href="#130160" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      // swaps the arguments if it's an upper bound
      <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="136125">checkSubtype</a><span class="delimiter">(</span><a title="Types.this.Type" id="136135">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="136136">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="136137">lhs</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#130157" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#136135" title="Types.this.Type">tp1</a> <span class="keyword">else</span> <a href="#136136" title="Types.this.Type">tp2</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="136138">rhs</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#130157" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#136136" title="Types.this.Type">tp2</a> <span class="keyword">else</span> <a href="#136135" title="Types.this.Type">tp1</a>

        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#130160" title="Boolean">isNumericBound</a><span class="delimiter">)</span> <a href="#136137" title="Types.this.Type">lhs</a> <a href="#42798" title="(that: Types.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#136138" title="Types.this.Type">rhs</a>
        <span class="keyword">else</span> <a href="#136137" title="Types.this.Type">lhs</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#136138" title="Types.this.Type">rhs</a>
      <span class="delimiter">}</span>

      /** Simple case: type arguments can be ignored, because either this typevar has
       *  no type parameters, or we are comparing to Any/Nothing.
       *
       *  The latter condition is needed because HK unification is limited to constraints of the shape
       *  {{{
       *    TC1[T1,..., TN] &lt;: TC2[T'1,...,T'N]
       *  }}}
       *  which would preclude the following important constraints:
       *  {{{
       *    Nothing &lt;: ?TC[?T]
       *    ?TC[?T] &lt;: Any
       *  }}}
       */
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="136126">unifySimple</a> = <span class="delimiter">(</span>
        <span class="delimiter">(</span><a href="#84198" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#130156" title="Types.this.Type">tp</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="#130156" title="Types.this.Type">tp</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
          <a href="#136124" title="(tp: Types.this.Type)Unit">addBound</a><span class="delimiter">(</span><a href="#130156" title="Types.this.Type">tp</a><span class="delimiter">)</span>
          <span title="Boolean(true)" class="keyword">true</span>
        <span class="delimiter">}</span>
      <span class="delimiter">)</span>

      /** Full case: involving a check of the form
       *  {{{
       *    TC1[T1,..., TN] &lt;: TC2[T'1,...,T'N]
       *  }}}
       *  Checks subtyping of higher-order type vars, and uses variances as defined in the
       *  type parameter we're trying to infer (the result will be sanity-checked later).
       */
      <span class="keyword">def</span> <a title="(tpe: Types.this.Type)Boolean" id="136127">unifyFull</a><span class="delimiter">(</span><a title="Types.this.Type" id="136151">tpe</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        // The alias/widen variations are often no-ops.
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="136152">tpes</a> = <span class="delimiter">(</span>
          <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#130157" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#136151" title="Types.this.Type">tpe</a>, <a href="#136151" title="Types.this.Type">tpe</a>.<a href="#42732" title="=&gt; Types.this.Type">widen</a>, <a href="#136151" title="Types.this.Type">tpe</a>.<a href="#42759" title="=&gt; Types.this.Type">dealias</a>, <a href="#136151" title="Types.this.Type">tpe</a>.<a href="#42732" title="=&gt; Types.this.Type">widen</a>.<a href="#42759" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span>.<span title="=&gt; List[Types.this.Type]">distinct</span>
          <span class="keyword">else</span> <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#136151" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
        <span class="delimiter">)</span>
        <a href="#136152" title="List[Types.this.Type]">tpes</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <a title="Types.this.Type" id="136174">tp</a> =&gt;
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="136175">lhs</a> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#130157" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#136174" title="Types.this.Type">tp</a>.<a href="#42741" title="=&gt; List[Types.this.Type]">typeArgs</a> <span class="keyword">else</span> <a href="#84199" title="=&gt; List[Types.this.Type]">typeArgs</a>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="136176">rhs</a> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#130157" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#84199" title="=&gt; List[Types.this.Type]">typeArgs</a> <span class="keyword">else</span> <a href="#136174" title="Types.this.Type">tp</a>.<a href="#42741" title="=&gt; List[Types.this.Type]">typeArgs</a>

          <a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#136175" title="List[Types.this.Type]">lhs</a>, <a href="#136176" title="List[Types.this.Type]">rhs</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
            // this is a higher-kinded type var with same arity as tp.
            // side effect: adds the type constructor itself as a bound
            <a href="#136124" title="(tp: Types.this.Type)Unit">addBound</a><span class="delimiter">(</span><a href="#136174" title="Types.this.Type">tp</a>.<a href="#42740" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>
            <a href="#40328" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean">isSubArgs</a><span class="delimiter">(</span><a href="#136175" title="List[Types.this.Type]">lhs</a>, <a href="#136176" title="List[Types.this.Type]">rhs</a>, <a href="#84198" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      // There's a &lt;: test taking place right now, where tp is a concrete type and this is a typevar
      // attempting to satisfy that test. Either the test will be unsatisfiable, in which case
      // registerBound will return false; or the upper or lower bounds of this type var will be
      // supplemented with the type being tested against.
      //
      // Eventually the types which have accumulated in the upper and lower bounds will be lubbed
      // (resp. glbbed) to instantiate the typevar.
      //
      // The only types which are eligible for unification are those with the same number of
      // typeArgs as this typevar, or Any/Nothing, which are kind-polymorphic. For the upper bound,
      // any parent or base type of `tp` may be tested here (leading to a corresponding relaxation
      // in the upper bound.) The universe of possible glbs, being somewhat more infinite, is not
      // addressed here: all lower bounds are retained and their intersection calculated when the
      // bounds are solved.
      //
      // In a side-effect free universe, checking tp and tp.parents beofre checking tp.baseTypeSeq
      // would be pointless. In this case, each check we perform causes us to lose specificity: in
      // the end the best we'll do is the least specific type we tested against, since the typevar
      // does not see these checks as &quot;probes&quot; but as requirements to fulfill.
      // TODO: the `suspended` flag can be used to poke around with leaving a trace
      //
      // So the strategy used here is to test first the type, then the direct parents, and finally
      // to fall back on the individual base types. This warrants eventual re-examination.

      // AM: I think we could use the `suspended` flag to avoid side-effecting during unification

      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#84216" title="=&gt; Boolean">suspended</a><span class="delimiter">)</span>              // constraint accumulation is disabled
        <a href="#136125" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">checkSubtype</a><span class="delimiter">(</span><a href="#130156" title="Types.this.Type">tp</a>, <a href="#135385" title="=&gt; Types.this.Type">origin</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84304" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span>  // type var is already set
        <a href="#136125" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">checkSubtype</a><span class="delimiter">(</span><a href="#130156" title="Types.this.Type">tp</a>, <a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84302" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#84223" title="(tp: Types.this.Type)Boolean">isRelatable</a><span class="delimiter">(</span><a href="#130156" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
        <a href="#136126" title="=&gt; Boolean">unifySimple</a> <span title="(x: Boolean)Boolean">||</span> <a href="#136127" title="(tpe: Types.this.Type)Boolean">unifyFull</a><span class="delimiter">(</span><a href="#130156" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span>
          // only look harder if our gaze is oriented toward Any
          <a href="#130157" title="Boolean">isLowerBound</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span>
            <span class="delimiter">(</span><a href="#130156" title="Types.this.Type">tp</a>.<a href="#42737" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <a href="#136127" title="(tpe: Types.this.Type)Boolean">unifyFull</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span>
              // @PP: Is it going to be faster to filter out the parents we just checked?
              // That's what's done here but I'm not sure it matters.
              <a href="#130156" title="Types.this.Type">tp</a>.<a href="#42803" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#60849" title="=&gt; List[Types.this.Type]">toList</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</span> <span class="delimiter">(</span><a href="#130156" title="Types.this.Type">tp</a>.<a href="#42737" title="=&gt; List[Types.this.Type]">parents</a> <span title="(elem: Any)Boolean">contains</span> <a href="#136215" title="Types.this.Type">_</a><span class="delimiter">)</span> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <a href="#136127" title="(tpe: Types.this.Type)Boolean">unifyFull</a>
            <span class="delimiter">)</span>
          <span class="delimiter">)</span>
        <span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean" id="84219">registerTypeEquality</a><span class="delimiter">(</span><a title="Types.this.Type" id="136225">tp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Boolean" id="136226">typeVarLHS</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      //println(&quot;regTypeEq: &quot;+(safeToString, debugString(tp), typeVarLHS)) //@MDEBUG
      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="136228">checkIsSameType</a><span class="delimiter">(</span><a title="Types.this.Type" id="136229">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
        <span title="Boolean" class="keyword">if</span><span class="delimiter">(</span><a href="#136226" title="Boolean">typeVarLHS</a><span class="delimiter">)</span> <a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84302" title="=&gt; Types.this.Type">inst</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#136229" title="Types.this.Type">tp</a>
        <span class="keyword">else</span>           <a href="#136229" title="Types.this.Type">tp</a>          <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84302" title="=&gt; Types.this.Type">inst</a>

      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#84216" title="=&gt; Boolean">suspended</a><span class="delimiter">)</span> <a href="#136225" title="Types.this.Type">tp</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#135385" title="=&gt; Types.this.Type">origin</a>
      <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84304" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#136228" title="(tp: Types.this.Type)Boolean">checkIsSameType</a><span class="delimiter">(</span><a href="#136225" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#84223" title="(tp: Types.this.Type)Boolean">isRelatable</a><span class="delimiter">(</span><a href="#136225" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="136234">newInst</a> = <a href="#136236" title="(tp: Types.this.Type)Types.this.Type">wildcardToTypeVarMap</a><span class="delimiter">(</span><a href="#136225" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a> <a href="#84300" title="(tp: Types.this.Type)Boolean">isWithinBounds</a> <a href="#136234" title="Types.this.Type">newInst</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span> <a href="#84212" title="(tp: Types.this.Type)Unit">setInst</a><span class="delimiter">(</span><a href="#136225" title="Types.this.Type">tp</a><span class="delimiter">)</span>; <span title="Boolean(true)" class="keyword">true</span> <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /**
     * `?A.T =:= tp` is rewritten as the constraint `?A &lt;: {type T = tp}`
     *
     * TODO: make these constraints count (incorporate them into implicit search in `applyImplicitArgs`)
     * (`T` corresponds to @param sym)
     */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, tp: Types.this.Type)Boolean" id="84220">registerTypeSelection</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="136243">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="136244">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="#84218" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#135297" title="(name: Types.this.TypeName, tp: Types.this.Type)Types.this.Type">HasTypeMember</a><span class="delimiter">(</span><a href="#136243" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#53413" title="=&gt; Types.this.TypeName">toTypeName</a>, <a href="#136244" title="Types.this.Type">tp</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="84221">isSkolemAboveLevel</a><span class="delimiter">(</span><a title="Types.this.Type" id="136190">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#136190" title="Types.this.Type">tp</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="136193">ts</a>: <a href="Symbols.scala.html#40009" title="Types.this.TypeSkolem">TypeSkolem</a> =&gt; <a href="#136193" title="Types.this.TypeSkolem">ts</a>.<a href="Symbols.scala.html#82102" title="=&gt; Int">level</a> <span title="(x: Int)Boolean">&gt;</span> <a href="#84205" title="=&gt; Int">level</a>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span>              =&gt; <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>
    // side-effects encounteredHigherLevel
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="84222">containsSkolemAboveLevel</a><span class="delimiter">(</span><a title="Types.this.Type" id="136186">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
      <span class="delimiter">(</span><a href="#136186" title="Types.this.Type">tp</a> <a href="#42792" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#84221" title="(tp: Types.this.Type)Boolean">isSkolemAboveLevel</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span> <a href="#84209" title="(x$1: Boolean)Unit">encounteredHigherLevel</a> = <span title="Boolean(true)" class="keyword">true</span> ; <span title="Boolean(true)" class="keyword">true</span> <span class="delimiter">}</span>

     /** Can this variable be related in a constraint to type `tp`?
      *  This is not the case if `tp` contains type skolems whose
      *  skolemization level is higher than the level of this variable.
      */
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="84223">isRelatable</a><span class="delimiter">(</span><a title="Types.this.Type" id="136183">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
         <a href="#84211" title="=&gt; Boolean">shouldRepackType</a>               // short circuit if we already know we've seen higher levels
      <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#84222" title="(tp: Types.this.Type)Boolean">containsSkolemAboveLevel</a><span class="delimiter">(</span><a href="#136183" title="Types.this.Type">tp</a><span class="delimiter">)</span>  // side-effects tracking boolean
      <span title="(x: Boolean)Boolean">||</span> <a href="#40065" title="=&gt; Boolean">enableTypeVarExperimentals</a>     // -Xexperimental: always say we're relatable, track consequences
    <span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="84224">normalize</a>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">(</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84304" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84302" title="=&gt; Types.this.Type">inst</a>
      // get here when checking higher-order subtyping of the typevar by itself
      // TODO: check whether this ever happens?
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#84200" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#40207" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#84198" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#84207" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#84198" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#136268" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47937" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#40176" title="Types.this.TypeVar" class="keyword">super</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a>
    <span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="84225">typeSymbol</a> = <a href="#135385" title="=&gt; Types.this.Type">origin</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="84226">isStable</a> = <a href="#135385" title="=&gt; Types.this.Type">origin</a>.<a href="#42715" title="=&gt; Boolean">isStable</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="84227">isVolatile</a> = <a href="#135385" title="=&gt; Types.this.Type">origin</a>.<a href="#42716" title="=&gt; Boolean">isVolatile</a>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)String" id="84228">tparamsOfSym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="135749">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#135749" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="String">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="135752">tparams</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#135752" title="List[Types.this.Symbol]">tparams</a>.<span title="=&gt; Boolean">nonEmpty</span> =&gt;
        <a href="#135752" title="List[Types.this.Symbol]">tparams</a> <span title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],String,List[String]])List[String]">map</span> <span class="delimiter">(</span><a href="#135769" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#48059" title="=&gt; String">defString</a><span class="delimiter">)</span> <span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="String(&quot;&quot;)">_</span> =&gt; <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="=&gt; String" id="84229">originName</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="135558">name</a> = <a href="#135385" title="=&gt; Types.this.Type">origin</a>.<a href="#42730" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>.<a href="Symbols.scala.html#47887" title="=&gt; String">decodedName</a>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#135558" title="String">name</a> <span title="(x$1: CharSequence)Boolean">contains</span> <span title="String(&quot;_$&quot;)" class="string">&quot;_$&quot;</span><span class="delimiter">)</span> <a href="#135385" title="=&gt; Types.this.Type">origin</a>.<a href="#42730" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>.<a href="Symbols.scala.html#47887" title="=&gt; String">decodedName</a> <span class="keyword">else</span> <a href="#135558" title="String">name</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="=&gt; String" id="84230">originLocation</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="135647">sym</a>  = <a href="#135385" title="=&gt; Types.this.Type">origin</a>.<a href="#42730" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="135648">encl</a> = <a href="#135647" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#48000" title="=&gt; Types.this.Symbol">logicallyEnclosingMember</a>
      
      // This should display somewhere between one and three
      // things which enclose the origin: at most, a class, a
      // a method, and a term.  At least, a class.
      <span title="(xs: Option[Types.this.Symbol]*)List[Option[Types.this.Symbol]]">List</span><span class="delimiter">(</span>
        <span title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</span><span class="delimiter">(</span><a href="#135648" title="Types.this.Symbol">encl</a>.<a href="Symbols.scala.html#47975" title="=&gt; Types.this.Symbol">enclClass</a><span class="delimiter">)</span>,
        <span title="Option[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#135648" title="Types.this.Symbol">encl</a>.<a href="Symbols.scala.html#47773" title="=&gt; Boolean">isMethod</a><span class="delimiter">)</span> <span title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</span><span class="delimiter">(</span><a href="#135648" title="Types.this.Symbol">encl</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="object None">None</span>,
        <span title="Option[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#135647" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#47755" title="=&gt; Boolean">isTerm</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#135647" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#135648" title="Types.this.Symbol">encl</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</span><span class="delimiter">(</span><a href="#135647" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="object None">None</span>
      <span class="delimiter">)</span>.<a href="#135726" title="(implicit asTraversable: Option[Types.this.Symbol] =&gt; scala.collection.GenTraversableOnce[Types.this.Symbol])List[Types.this.Symbol]">flatten</a> <span title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],String,List[String]])List[String]">map</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="135748">s</a> =&gt; <a href="#135748" title="Types.this.Symbol">s</a>.<a href="Symbols.scala.html#47887" title="=&gt; String">decodedName</a> <span title="(x$1: Any)String">+</span> <a href="#84228" title="(sym: Types.this.Symbol)String">tparamsOfSym</a><span class="delimiter">(</span><a href="#135748" title="Types.this.Symbol">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(sep: String)String">mkString</span> <span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span>
    <span class="delimiter">}</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Any" id="84231">levelString</a> = <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75540" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">explaintypes</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#84205" title="=&gt; Int">level</a> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; String" id="84232">typeVarString</a> = <a href="#84229" title="=&gt; String">originName</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84233">safeToString</a> = <span class="delimiter">(</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84302" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;TVar&lt;&quot;)" class="string">&quot;TVar&lt;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#84229" title="=&gt; String">originName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;=null&gt;&quot;)" class="string">&quot;=null&gt;&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84302" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84302" title="=&gt; Types.this.Type">inst</a>
      <span class="keyword">else</span> <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#84231" title="=&gt; Any">levelString</a> <span title="(x$1: Any)String">+</span> <a href="#84229" title="=&gt; String">originName</a>
    <span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84234">kind</a> = <span title="String(&quot;TypeVar&quot;)" class="string">&quot;TypeVar&quot;</span>

    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeVar" id="84235">cloneInternal</a> = <span class="delimiter">{</span>
      // cloning a suspended type variable when it's suspended will cause the clone
      // to never be resumed with the current implementation
      <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#84216" title="=&gt; Boolean">suspended</a>, <a href="#40176" title="Types.this.TypeVar" class="keyword">this</a><span class="delimiter">)</span>
      <a href="#40169" title="object Types.this.TypeVar">TypeVar</a>.<a href="#84237" title="(action: String, msg: =&gt; String)(value: Types.this.TypeVar)Types.this.TypeVar">trace</a><span class="delimiter">(</span><span title="String(&quot;clone&quot;)" class="string">&quot;clone&quot;</span>, <a href="#84230" title="=&gt; String">originLocation</a><span class="delimiter">)</span><span class="delimiter">(</span>
        <a href="#84244" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#135385" title="=&gt; Types.this.Type">origin</a>, <a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a> <a href="#84305" title="=&gt; Types.this.TypeConstraint">cloneInternal</a>, <a href="#84199" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#84198" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span> // @M TODO: clone args/params?
      <span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A type carrying some annotations. Created by the typechecker
   *  when eliminating ''Annotated'' trees (see typedAnnotated).
   *
   *  @param annotations the list of annotations on the type
   *  @param underlying the type without the annotation
   *  @param selfsym a &quot;self&quot; symbol with type `underlying`;
   *    only available if -Yself-in-annots is turned on. Can be `NoSymbol`
   *    if it is not used.
   */
  case <span class="keyword">class</span> <a title="class AnnotatedType extends Types.this.Type with Types.this.RewrappingTypeProxy with ScalaObject with Product with Serializable" id="59504">AnnotatedType</a><a href="#59504" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="84463">annotations</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span>,
                           <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="84464">underlying</a>: <a href="#40083" title="Types.this.Type">Type</a>,
                           <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Symbol" id="84465">selfsym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="#40079" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a> <span class="delimiter">{</span>

    <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#84463" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">isEmpty</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#84464" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.AnnotatedType" id="59573">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="136324">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#84463" title="List[Types.this.AnnotationInfo]" id="136342">copy</a><span class="delimiter">(</span>underlying = <a href="#136324" title="Types.this.Type" id="136340">tp</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="59574">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#59575" title="=&gt; Boolean">isTrivial0</a>
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="59576">isTrivial0</a> = <a href="#84464" title="=&gt; Types.this.Type">underlying</a>.<a href="#42713" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#84463" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="(p: Types.this.AnnotationInfo =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#136351" title="Types.this.AnnotationInfo">_</a>.<a href="AnnotationInfos.scala.html#47247" title="=&gt; Boolean">isTrivial</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="59577">safeToString</a> = <a href="#84463" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><a href="#84464" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">underlying</a> <span title="(other: String)String">+</span> <span title="String(&quot; @&quot;)" class="string">&quot; @&quot;</span>, <span title="String(&quot; @&quot;)" class="string">&quot; @&quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(p: Types.this.AnnotationInfo =&gt; Boolean)Types.this.Type" id="59578">filterAnnotations</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo =&gt; Boolean" id="136359">p</a>: AnnotationInfo =&gt; Boolean<span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#136363" title="(List[Types.this.AnnotationInfo], List[Types.this.AnnotationInfo])" class="delimiter">(</a><a href="#136362" title="List[Types.this.AnnotationInfo]" id="136363">yes</a>, <a href="#136362" title="List[Types.this.AnnotationInfo]" id="136364">no</a><span class="delimiter">)</span> = <a href="#84463" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a> <span title="(p: Types.this.AnnotationInfo =&gt; Boolean)(List[Types.this.AnnotationInfo], List[Types.this.AnnotationInfo])">partition</span> <a href="#136359" title="Types.this.AnnotationInfo =&gt; Boolean">p</a>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#136363" title="List[Types.this.AnnotationInfo]">yes</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#84464" title="=&gt; Types.this.Type">underlying</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#136364" title="List[Types.this.AnnotationInfo]">no</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#59504" title="Types.this.AnnotatedType" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#59504" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">copy</a><span class="delimiter">(</span>annotations = <a href="#136363" title="List[Types.this.AnnotationInfo]">yes</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="59579">setAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="136382">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#136382" title="List[Types.this.AnnotationInfo]">annots</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#84464" title="=&gt; Types.this.Type">underlying</a>
      <span class="keyword">else</span> <a href="#59504" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">copy</a><span class="delimiter">(</span>annotations = <a href="#136382" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span>

    /** Add a number of annotations to this type */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="59580">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="136385">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#136385" title="List[Types.this.AnnotationInfo]">annots</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#59504" title="Types.this.AnnotatedType" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#59504" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">copy</a><span class="delimiter">(</span><a href="#136385" title="List[Types.this.AnnotationInfo]">annots</a> <a href="#136388" title="(prefix: List[Types.this.AnnotationInfo])List[Types.this.AnnotationInfo]">:::</a> <a href="#59504" title="AnnotatedType.this.type" class="keyword">this</a>.<a href="#84463" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a><span class="delimiter">)</span>

    /** Remove any annotations from this type.
     *  TODO - is it allowed to nest AnnotatedTypes? If not then let's enforce
     *  that at creation.  At the moment if they do ever turn up nested this
     *  recursively calls withoutAnnotations.
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="59581">withoutAnnotations</a> = <a href="#84464" title="=&gt; Types.this.Type">underlying</a>.<a href="#42822" title="=&gt; Types.this.Type">withoutAnnotations</a>

    /** Set the self symbol */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.AnnotatedType" id="59582">withSelfsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="136399">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#84463" title="List[Types.this.AnnotationInfo]" id="136404">copy</a><span class="delimiter">(</span>selfsym = <a href="#136399" title="Types.this.Symbol" id="136402">sym</a><span class="delimiter">)</span>

    /** Drop the annotations on the bounds, unless the low and high
     *  bounds are exactly tp.
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="59583">bounds</a>: <a href="#66864" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#84464" title="=&gt; Types.this.Type">underlying</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a> <span title="Types.this.TypeBounds" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.TypeBounds">TypeBounds</span><span class="delimiter">(</span>_: <span class="keyword">this</span>.<span class="keyword">type</span>, _: <span class="keyword">this</span>.<span class="keyword">type</span><span class="delimiter">)</span> =&gt; <a href="#66838" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#59504" title="Types.this.AnnotatedType" class="keyword">this</a>, <a href="#59504" title="Types.this.AnnotatedType" class="keyword">this</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.TypeBounds" id="136407">oftp</a>                                   =&gt; <a href="#136407" title="Types.this.TypeBounds">oftp</a>
    <span class="delimiter">}</span>

    // ** Replace formal type parameter symbols with actual type arguments. * /
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="59584">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="136408">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="136409">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="136412">annotations1</a> = <a href="#84463" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="(f: Types.this.AnnotationInfo =&gt; Types.this.AnnotationInfo)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.AnnotationInfo],Types.this.AnnotationInfo,List[Types.this.AnnotationInfo]])List[Types.this.AnnotationInfo]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.AnnotationInfo,List[Types.this.AnnotationInfo]]" class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="136430">info</a> =&gt; <a href="AnnotationInfos.scala.html#47273" title="(atp: Types.this.Type, args: List[Types.this.Tree], assocs: List[(Types.this.Name, Types.this.ClassfileAnnotArg)])Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">(</span><a href="#136430" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#47239" title="=&gt; Types.this.Type">atp</a>.<a href="#42755" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span>
          <a href="#136408" title="List[Types.this.Symbol]">formals</a>, <a href="#136409" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>, <a href="#136430" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#47240" title="=&gt; List[Types.this.Tree]">args</a>, <a href="#136430" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#47241" title="=&gt; List[(Types.this.Name, Types.this.ClassfileAnnotArg)]">assocs</a><span class="delimiter">)</span>.<a href="AnnotationInfos.scala.html#47253" title="(pos: Types.this.Position)Types.this.AnnotationInfo">setPos</a><span class="delimiter">(</span><a href="#136430" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#47252" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="136413">underlying1</a> = <a href="#84464" title="=&gt; Types.this.Type">underlying</a>.<a href="#42755" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#136408" title="List[Types.this.Symbol]">formals</a>, <a href="#136409" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#136412" title="List[Types.this.AnnotationInfo]">annotations1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#84463" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#136413" title="Types.this.Type">underlying1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#84464" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#59504" title="Types.this.AnnotatedType" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#59504" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#136412" title="List[Types.this.AnnotationInfo]">annotations1</a>, <a href="#136413" title="Types.this.Type">underlying1</a>, <a href="#84465" title="=&gt; Types.this.Symbol">selfsym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Return the base type sequence of tp, dropping the annotations, unless the base type sequence of tp
      * is precisely tp itself. */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="59585">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#40512" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
       <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="136472">oftp</a> = <a href="#84464" title="=&gt; Types.this.Type">underlying</a>.<a href="#42803" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
       <span title="Types.this.BaseTypeSeq" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#136472" title="Types.this.BaseTypeSeq">oftp</a>.<a href="BaseTypeSeqs.scala.html#60843" title="=&gt; Int">length</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="BaseTypeSeqs.scala.html#60846" title="(i: Int)Types.this.Type">oftp</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#84464" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span>
         <a href="BaseTypeSeqs.scala.html#40515" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">baseTypeSingletonSeq</a><span class="delimiter">(</span><a href="#59504" title="Types.this.AnnotatedType" class="keyword">this</a><span class="delimiter">)</span>
       <span class="keyword">else</span>
         <a href="#136472" title="Types.this.BaseTypeSeq">oftp</a>
     <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="59586">kind</a> = <span title="String(&quot;AnnotatedType&quot;)" class="string">&quot;AnnotatedType&quot;</span>
  <span class="delimiter">}</span>

  /** Creator for AnnotatedTypes.  It returns the underlying type if annotations.isEmpty
   *  rather than walking into the assertion.
   */
  <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.Type" id="40180">annotatedType</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="130553">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span>, <a title="Types.this.Type" id="130554">underlying</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="130557">selfsym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#130553" title="List[Types.this.AnnotationInfo]">annots</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#130554" title="Types.this.Type">underlying</a>
    <span class="keyword">else</span> <a href="#59504" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#130553" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#130554" title="Types.this.Type">underlying</a>, <a href="#130557" title="Types.this.Symbol">selfsym</a><span class="delimiter">)</span>

  <span class="keyword">object</span> <a title="object Types.this.AnnotatedType" id="136514">AnnotatedType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#8614" title="Types.this.AnnotatedTypeExtractor">AnnotatedTypeExtractor</a> <span class="delimiter">{</span> <span class="delimiter">}</span>

  /** A class representing types with a name. When an application uses
   *  named arguments, the named argument types for calling isApplicable
   *  are represented as NamedType.
   */
  case <span class="keyword">class</span> <a title="class NamedType extends Types.this.Type with ScalaObject with Product with Serializable" id="146947">NamedType</a><a href="#146947" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Name" id="146942">name</a>: <a href="Names.scala.html#39679" title="Types.this.Name">Name</a>, <a title="Types.this.Type" id="146943">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="136522">safeToString</a>: <span title="String">String</span> = <a href="#146942" title="=&gt; Types.this.Name">name</a>.<span title="()String">toString</span> <span title="(x$1: Any)String">+</span><span title="String(&quot;: &quot;)" class="string">&quot;: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#146943" title="=&gt; Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  /** A De Bruijn index referring to a previous type argument. Only used
   *  as a serialization format.
   */
  case <span class="keyword">class</span> <a title="class DeBruijnIndex extends Types.this.Type with ScalaObject with Product with Serializable" id="146911">DeBruijnIndex</a><a href="#146911" title="ScalaObject" class="delimiter">(</a><a title="Int" id="137288">level</a>: <span title="Int">Int</span>, <a title="Int" id="137289">idx</a>: <span title="Int">Int</span>, <a title="List[Types.this.Type]" id="137290">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="136578">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;De Bruijn index(&quot;)" class="string">&quot;De Bruijn index(&quot;</span><span title="(x$1: Any)String">+</span><a href="#137288" title="=&gt; Int">level</a><span title="(x$1: Any)String">+</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span title="(x$1: Any)String">+</span><a href="#137289" title="=&gt; Int">idx</a><span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
  <span class="delimiter">}</span>

  /** A binder defining data associated with De Bruijn indices. Only used
   *  as a serialization format.
   */
  case <span class="keyword">class</span> <a title="class DeBruijnBinder extends Types.this.Type with ScalaObject with Product with Serializable" id="146907">DeBruijnBinder</a><a href="#146907" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Name]" id="137138">pnames</a>: <span title="List[Types.this.Name]">List</span><span class="delimiter">[</span>Name<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="137139">ptypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Type" id="137140">restpe</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="136647">safeToString</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="136659">kind</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#137138" title="=&gt; List[Types.this.Name]">pnames</a>.<span title="=&gt; Types.this.Name">head</span>.<a href="Names.scala.html#53411" title="=&gt; Boolean">isTypeName</a><span class="delimiter">)</span> <span title="String(&quot;poly&quot;)" class="string">&quot;poly&quot;</span> <span class="keyword">else</span> <span title="String(&quot;method&quot;)" class="string">&quot;method&quot;</span>
      <span title="String(&quot;De Bruijn &quot;)" class="string">&quot;De Bruijn &quot;</span><span title="(x$1: Any)String">+</span><a href="#136659" title="String">kind</a><span title="(x$1: Any)String">+</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span><span title="(x$1: Any)String">+</span><span class="delimiter">(</span><a href="#137138" title="=&gt; List[Types.this.Name]">pnames</a> <span title="(sep: String)String">mkString</span> <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span title="(x$1: Any)String">+</span><span title="String(&quot;;&quot;)" class="string">&quot;;&quot;</span><span title="(x$1: Any)String">+</span><span class="delimiter">(</span><a href="#137139" title="=&gt; List[Types.this.Type]">ptypes</a> <span title="(sep: String)String">mkString</span> <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span title="(x$1: Any)String">+</span><span title="String(&quot;;&quot;)" class="string">&quot;;&quot;</span><span title="(x$1: Any)String">+</span><a href="#137140" title="=&gt; Types.this.Type">restpe</a><span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A class representing an as-yet unevaluated type.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class LazyType extends Types.this.Type with ScalaObject" id="40190">LazyType</a> <a href="#40190" title="ScalaObject" class="keyword">extends</a> <a href="#40083" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="72756">isComplete</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="72757">complete</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="82835">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="72758">safeToString</a> = <span title="String(&quot;&lt;?&gt;&quot;)" class="string">&quot;&lt;?&gt;&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="72759">kind</a> = <span title="String(&quot;LazyType&quot;)" class="string">&quot;LazyType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class LazyPolyType extends Types.this.LazyType with ScalaObject" id="40191">LazyPolyType</a><a href="#40191" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="82841">typeParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40190" title="Types.this.LazyType">LazyType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="82253">safeToString</a> =
      <span class="delimiter">(</span><span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#82841" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="TypeDebugging.scala.html#40677" title="(tp: Types.this.Type)String">typeParamsString</a><span class="delimiter">(</span><a href="#40191" title="Types.this.LazyPolyType" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#40191" title="Types.this.LazyPolyType" class="keyword">super</a>.<a href="#72758" title="=&gt; String">safeToString</a>
  <span class="delimiter">}</span>

  // def mkLazyType(tparams: Symbol*)(f: Symbol =&gt; Unit): LazyType = (
  //   if (tparams.isEmpty) new LazyType { override def complete(sym: Symbol) = f(sym) }
  //   else new LazyPolyType(tparams.toList) { override def complete(sym: Symbol) = f(sym) }
  // )

// Creators ---------------------------------------------------------------

  /** Rebind symbol `sym` to an overriding member in type `pre`. */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol" id="40192">rebind</a><span class="delimiter">(</span><a title="Types.this.Type" id="136728">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="136729">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
    <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#136729" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47778" title="=&gt; Boolean">isOverridableMember</a> <span title="(x: Boolean)Boolean">||</span> <a href="#136729" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#136728" title="Types.this.Type">pre</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span> <a href="#136729" title="Types.this.Symbol">sym</a>
    <span class="keyword">else</span> <a href="#136728" title="Types.this.Type">pre</a>.<a href="#42770" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#136729" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#47969" title="(cond: Types.this.Symbol =&gt; Boolean)Types.this.Symbol">suchThat</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="136739">sym</a> =&gt; <a href="#136739" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47756" title="=&gt; Boolean">isType</a> <span title="(x: Boolean)Boolean">||</span> <a href="#136739" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47846" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="Symbols.scala.html#48033" title="(alt: =&gt; Types.this.Symbol)Types.this.Symbol">orElse</a> <a href="#136729" title="Types.this.Symbol">sym</a>
  <span class="delimiter">}</span>

  /** Convert a `super` prefix to a this-type if `sym` is abstract or final. */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="40193">removeSuper</a><span class="delimiter">(</span><a title="Types.this.Type" id="136742">tp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="136743">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#136742" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">SuperType</span><span class="delimiter">(</span><a title="Types.this.Type" id="136745">thistp</a>, _<span class="delimiter">)</span> =&gt;
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#136743" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47861" title="=&gt; Boolean">isEffectivelyFinal</a> <span title="(x: Boolean)Boolean">||</span> <a href="#136743" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#48097" title="=&gt; Boolean">isDeferred</a><span class="delimiter">)</span> <a href="#136745" title="Types.this.Type">thistp</a>
      <span class="keyword">else</span> <a href="#136742" title="Types.this.Type">tp</a>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <a href="#136742" title="Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  /** The canonical creator for single-types */
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="40194">singleType</a><span class="delimiter">(</span><a title="Types.this.Type" id="117061">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="117062">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
      <a href="#117062" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>.<a href="#42743" title="=&gt; Types.this.Type">resultType</a>
    <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#117062" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47789" title="=&gt; Boolean">isRootPackage</a><span class="delimiter">)</span>
      <a href="#83395" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="Definitions.scala.html#46242" title="=&gt; Types.this.ModuleClassSymbol">RootClass</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="136748">sym1</a> = <a href="#40192" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#117061" title="Types.this.Type">pre</a>, <a href="#117062" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="136749">pre1</a> = <a href="#40193" title="(tp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">removeSuper</a><span class="delimiter">(</span><a href="#117061" title="Types.this.Type">pre</a>, <a href="#136748" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#136749" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#117061" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#136748" title="Types.this.Symbol">sym1</a> = <a href="#40192" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#136749" title="Types.this.Type">pre1</a>, <a href="#136748" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      <a href="#83437" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">SingleType</a><span class="delimiter">(</span><a href="#136749" title="Types.this.Type">pre1</a>, <a href="#136748" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** the canonical creator for a refined type with a given scope */
  <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type" id="40195">refinedType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="114900">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="114901">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Scope" id="114902">decls</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a>, <a title="Types.this.Position" id="114903">pos</a>: <span title="Types.this.Position">Position</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#114900" title="List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="Definitions.scala.html#46278" title="=&gt; Types.this.Symbol">ObjectClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#114900" title="List[Types.this.Type]">parents</a>.<span title="=&gt; Types.this.Type">head</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.ClassSymbol" id="136752">clazz</a> = <a href="#114901" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#47741" title="(pos: Types.this.Position)Types.this.ClassSymbol">newRefinementClass</a><span class="delimiter">(</span><a href="#8614" title="=&gt; Types.this.Position">NoPosition</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.RefinedType" id="136753">result</a> = <a href="#61659" title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#114900" title="List[Types.this.Type]">parents</a>, <a href="#114902" title="Types.this.Scope">decls</a>, <a href="#136752" title="Types.this.ClassSymbol">clazz</a><span class="delimiter">)</span>
      <a href="#136752" title="Types.this.ClassSymbol">clazz</a>.<a href="Symbols.scala.html#47922" title="(info: Types.this.Type)clazz.type">setInfo</a><span class="delimiter">(</span><a href="#136753" title="Types.this.RefinedType">result</a><span class="delimiter">)</span>
      <a href="#136753" title="Types.this.RefinedType">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** The canonical creator for a refined type with an initially empty scope.
   *
   *  @param parents ...
   *  @param owner   ...
   *  @return        ...
   */
  <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type" id="40196">refinedType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="114895">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="114896">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
    <a href="#40195" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#114895" title="List[Types.this.Type]">parents</a>, <a href="#114896" title="Types.this.Symbol">owner</a>, <a href="Scopes.scala.html#61744" title="()Types.this.Scope" class="keyword">new</a> <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a>, <a href="#114896" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#47694" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type" id="40197">copyRefinedType</a><span class="delimiter">(</span><a title="Types.this.RefinedType" id="131423">original</a>: <a href="#61660" title="Types.this.RefinedType">RefinedType</a>, <a title="List[Types.this.Type]" id="131424">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="131425">decls</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a><span class="delimiter">)</span> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#131424" title="List[Types.this.Type]">parents</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131423" title="Types.this.RefinedType">original</a>.<a href="#83878" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#131425" title="Types.this.Scope">decls</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131423" title="Types.this.RefinedType">original</a>.<a href="#83879" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#131423" title="Types.this.RefinedType">original</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="131428">owner</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#131423" title="Types.this.RefinedType">original</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a> <span class="keyword">else</span> <a href="#131423" title="Types.this.RefinedType">original</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="131429">result</a> = <a href="#40196" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#131424" title="List[Types.this.Type]">parents</a>, <a href="#131428" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="131430">syms1</a> = <a href="#131425" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61763" title="=&gt; List[Types.this.Symbol]">toList</a>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="131462">sym</a> &lt;- <a href="#131430" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)Unit">syms1</a><span class="delimiter">)</span>
        <a href="#131429" title="Types.this.Type">result</a>.<a href="#42760" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61752" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a><span class="delimiter">(</span><a href="#131462" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47971" title="(owner: Types.this.Symbol)Types.this.Symbol">cloneSymbol</a><span class="delimiter">(</span><a href="#131429" title="Types.this.Type">result</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="131431">syms2</a> = <a href="#131429" title="Types.this.Type">result</a>.<a href="#42760" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61763" title="=&gt; List[Types.this.Symbol]">toList</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="131432">resultThis</a> = <a href="#131429" title="Types.this.Type">result</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47980" title="=&gt; Types.this.Type">thisType</a>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="131491">sym</a> &lt;- <a href="#131431" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)Unit">syms2</a><span class="delimiter">)</span>
        <a href="#131491" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#47923" title="(f: Types.this.Type =&gt; Types.this.Type)sym.type">modifyInfo</a> <span class="delimiter">(</span><a href="#131494" title="Types.this.Type">_</a> <a href="#42786" title="(from: Types.this.Symbol, to: Types.this.Type, symsFrom: List[Types.this.Symbol], symsTo: List[Types.this.Symbol])Types.this.Type">substThisAndSym</a><span class="delimiter">(</span><a href="#131423" title="Types.this.RefinedType">original</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#131432" title="Types.this.Type">resultThis</a>, <a href="#131430" title="List[Types.this.Symbol]">syms1</a>, <a href="#131431" title="List[Types.this.Symbol]">syms2</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <a href="#131429" title="Types.this.Type">result</a>
    <span class="delimiter">}</span>

  /** The canonical creator for typerefs
   *  todo: see how we can clean this up a bit
   */
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="40198">typeRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="73846">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="73847">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="73848">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    // type alias selections are rebound in TypeMap (&quot;coevolved&quot;,
    // actually -- see #3731) e.g., when type parameters that are
    // referenced by the alias are instantiated in the prefix. See
    // pos/depmet_rebind_typealias.

    <span class="keyword">val</span> <a title="Types.this.Symbol" id="136768">sym1</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#73847" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47760" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span> <a href="#40192" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#73846" title="Types.this.Type">pre</a>, <a href="#73847" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#73847" title="Types.this.Symbol">sym</a>
    // don't expand cyclical type alias
    // we require that object is initialized, thus info.typeParams instead of typeParams.
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#136768" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47759" title="=&gt; Boolean">isAliasType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#136768" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42752" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#73848" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#136768" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47752" title="=&gt; Boolean">lockOK</a><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <a href="#67275" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#40384" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic reference involving &quot;)" class="string">&quot;illegal cyclic reference involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#136768" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="Types.this.Type" id="136769">pre1</a> = <a href="#73846" title="Types.this.Type">pre</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="136774">x</a>: <a href="#83653" title="Types.this.SuperType">SuperType</a> <span class="keyword">if</span> <a href="#136768" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47861" title="=&gt; Boolean">isEffectivelyFinal</a> <span title="(x: Boolean)Boolean">||</span> <a href="#136768" title="Types.this.Symbol">sym1</a>.<a href="HasFlags.scala.html#48097" title="=&gt; Boolean">isDeferred</a> =&gt;
        <a href="#136774" title="Types.this.SuperType">x</a>.<a href="#83667" title="=&gt; Types.this.Type">thistpe</a>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span>: <a href="#40117" title="Types.this.CompoundType">CompoundType</a> <span class="keyword">if</span> <a href="#136768" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47757" title="=&gt; Boolean">isClass</a> =&gt;
        // sharpen prefix so that it is maximal and still contains the class.
        <a href="#73846" title="Types.this.Type">pre</a>.<a href="#42737" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; List[Types.this.Type]">reverse</span> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">dropWhile</span> <span class="delimiter">(</span><a href="#136782" title="Types.this.Type">_</a>.<a href="#42769" title="(name: Types.this.Name)Types.this.Symbol">member</a><span class="delimiter">(</span><a href="#136768" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#136768" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Types.this.Type">Nil</span>         =&gt; <a href="#73846" title="Types.this.Type">pre</a>
          <span class="keyword">case</span> <a title="Types.this.Type" id="136793">parent</a> :: _ =&gt; <a href="#136793" title="Types.this.Type">parent</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#73846" title="Types.this.Type">pre</a>
    <span class="delimiter">}</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#73846" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#136769" title="Types.this.Type">pre1</a><span class="delimiter">)</span>                                <a href="#66645" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#73846" title="Types.this.Type">pre</a>, <a href="#136768" title="Types.this.Symbol">sym1</a>, <a href="#73848" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#136768" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47760" title="=&gt; Boolean">isAbstractType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#136768" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47757" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span>  <a href="#40198" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#136769" title="Types.this.Type">pre1</a>, <a href="#40192" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#136769" title="Types.this.Type">pre1</a>, <a href="#136768" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>, <a href="#73848" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">else</span>                                            <a href="#40198" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#136769" title="Types.this.Type">pre1</a>, <a href="#136768" title="Types.this.Symbol">sym1</a>, <a href="#73848" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  // Optimization to avoid creating unnecessary new typerefs.
  <span class="keyword">def</span> <a title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="40199">copyTypeRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="125088">tp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="125089">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="125090">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="125091">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#125088" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="136794">pre0</a>, <a title="Types.this.Symbol" id="136795">sym0</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#125089" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#136794" title="Types.this.Type">pre0</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#136795" title="Types.this.Symbol">sym0</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#125090" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a> =&gt;
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#125090" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47759" title="=&gt; Boolean">isAliasType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#125090" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42752" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#125091" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#125090" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47752" title="=&gt; Boolean">lockOK</a><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">throw</span> <a href="#67275" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#40384" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic reference involving &quot;)" class="string">&quot;illegal cyclic reference involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#125090" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>

      <a href="#66645" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#125089" title="Types.this.Type">pre</a>, <a href="#125090" title="Types.this.Symbol">sym</a>, <a href="#125091" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <a href="#40198" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#125089" title="Types.this.Type">pre</a>, <a href="#125090" title="Types.this.Symbol">sym</a>, <a href="#125091" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** The canonical creator for implicit method types */
  <span class="keyword">def</span> <a title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.JavaMethodType" id="40200">JavaMethodType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="136809">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="136810">resultType</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40148" title="Types.this.JavaMethodType">JavaMethodType</a> =
    <span title="Types.this.JavaMethodType" class="keyword">new</span> <a href="#40148" title="Types.this.JavaMethodType">JavaMethodType</a><span class="delimiter">(</span><a href="#136809" title="List[Types.this.Symbol]">params</a>, <a href="#136810" title="Types.this.Type">resultType</a><span class="delimiter">)</span> // don't unique this!

  /** Create a new MethodType of the same class as tp, i.e. keep JavaMethodType */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type" id="40201">copyMethodType</a><span class="delimiter">(</span><a title="Types.this.Type" id="134018">tp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="134019">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="134020">restpe</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#134018" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.JavaMethodType">_</span>: <a href="#40148" title="Types.this.JavaMethodType">JavaMethodType</a> =&gt; <a href="#40200" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.JavaMethodType">JavaMethodType</a><span class="delimiter">(</span><a href="#134019" title="List[Types.this.Symbol]">params</a>, <a href="#134020" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.MethodType">_</span>                 =&gt; <a href="#66899" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#134019" title="List[Types.this.Symbol]">params</a>, <a href="#134020" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** A creator for intersection type where intersections of a single type are
   *  replaced by the type itself, and repeated parent classes are merged.
   *
   *  !!! Repeated parent classes are not merged - is this a bug in the
   *  comment or in the code?
   */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type" id="40202">intersectionType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="68161">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="68162">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#68161" title="List[Types.this.Type]">tps</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#136813" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="136824">tp</a><span class="delimiter">)</span> =&gt;
      <a href="#136824" title="Types.this.Type">tp</a>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
       <a href="#40196" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#68161" title="List[Types.this.Type]">tps</a>, <a href="#68162" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
/*
      def merge(tps: List[Type]): List[Type] = tps match {
        case tp :: tps1 =&gt;
          val tps1a = tps1 filter (_.typeSymbol.==(tp.typeSymbol))
          val tps1b = tps1 filter (_.typeSymbol.!=(tp.typeSymbol))
          mergePrefixAndArgs(tps1a, -1) match {
            case Some(tp1) =&gt; tp1 :: merge(tps1b)
            case None =&gt; throw new MalformedType(
              &quot;malformed type: &quot;+refinedType(tps, owner)+&quot; has repeated parent class &quot;+
              tp.typeSymbol+&quot; with incompatible prefixes or type arguments&quot;)
          }
        case _ =&gt; tps
      }
      refinedType(merge(tps), owner)
*/
  <span class="delimiter">}</span>

  /** A creator for intersection type where intersections of a single type are
   *  replaced by the type itself. */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type])Types.this.Type" id="40203">intersectionType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="68158">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#68158" title="List[Types.this.Type]">tps</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#136830" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="136841">tp</a><span class="delimiter">)</span> =&gt; <a href="#136841" title="Types.this.Type">tp</a>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#40196" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#68158" title="List[Types.this.Type]">tps</a>, <a href="#40281" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#68158" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** A creator for type applications */
  <span class="keyword">def</span> <a title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type" id="40204">appliedType</a><span class="delimiter">(</span><a title="Types.this.Type" id="70399">tycon</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="List[Types.this.Type]" id="70400">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#70400" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#70399" title="Types.this.Type">tycon</a> //@M! `if (args.isEmpty) tycon' is crucial (otherwise we create new types in phases after typer and then they don't get adapted (??))
    <span class="keyword">else</span> <a href="#70399" title="Types.this.Type">tycon</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="136852">pre</a>, <a title="Types.this.Symbol" id="136853">sym</a> @ <span class="delimiter">(</span><a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a>|<a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#40199" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#70399" title="Types.this.Type">tycon</a>, <a href="#136852" title="Types.this.Type">pre</a>, <a href="#136853" title="Types.this.Symbol">sym</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span>   //@M drop type args to Any/Nothing
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="136854">pre</a>, <a title="Types.this.Symbol" id="136855">sym</a>, _<span class="delimiter">)</span>                           =&gt; <a href="#40199" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#70399" title="Types.this.Type">tycon</a>, <a href="#136854" title="Types.this.Type">pre</a>, <a href="#136855" title="Types.this.Symbol">sym</a>, <a href="#70400" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="136856">tparams</a>, <a title="Types.this.Type" id="136857">restpe</a><span class="delimiter">)</span>                      =&gt; <a href="#136857" title="Types.this.Type">restpe</a>.<a href="#42755" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#136856" title="List[Types.this.Symbol]">tparams</a>, <a href="#70400" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="136858">tparams</a>, <a title="Types.this.Type" id="136859">restpe</a><span class="delimiter">)</span>               =&gt; <a href="#40155" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">(</span><a href="#136858" title="List[Types.this.Symbol]">tparams</a>, <a href="#40204" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#136859" title="Types.this.Type">restpe</a>, <a href="#70400" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="136860">st</a>: <a href="#40089" title="Types.this.SingletonType">SingletonType</a>                              =&gt; <a href="#40204" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#136860" title="Types.this.SingletonType">st</a>.<a href="#83401" title="=&gt; Types.this.Type">widen</a>, <a href="#70400" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> // @M TODO: what to do? see bug1
      <span class="keyword">case</span> <span title="Types.this.RefinedType">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="136861">parents</a>, <a title="Types.this.Scope" id="136862">decls</a><span class="delimiter">)</span>                    =&gt; <a href="#61660" title="(parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#136861" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#40204" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#136885" title="Types.this.Type">_</a>, <a href="#70400" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#136862" title="Types.this.Scope">decls</a><span class="delimiter">)</span> // MO to AM: please check
      <span class="keyword">case</span> <span title="Types.this.TypeBounds">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="136913">lo</a>, <a title="Types.this.Type" id="136914">hi</a><span class="delimiter">)</span>                             =&gt; <a href="#66838" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#40204" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#136913" title="Types.this.Type">lo</a>, <a href="#70400" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, <a href="#40204" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#136914" title="Types.this.Type">hi</a>, <a href="#70400" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.TypeVar" id="136915">tv</a>@<a href="#84241" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span>                               =&gt; <a href="#136915" title="Types.this.TypeVar">tv</a>.<a href="#84207" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#70400" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.AnnotatedType">AnnotatedType</span><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="136917">annots</a>, <a title="Types.this.Type" id="136918">underlying</a>, <a title="Types.this.Symbol" id="136919">self</a><span class="delimiter">)</span>        =&gt; <a href="#59504" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#136917" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#40204" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#136918" title="Types.this.Type">underlying</a>, <a href="#70400" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, <a href="#136919" title="Types.this.Symbol">self</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="#130719" title="Types.this.Type">ErrorType</a>                                      =&gt; <a href="#70399" title="Types.this.Type">tycon</a>
      <span class="keyword">case</span> <a href="#130739" title="Types.this.Type">WildcardType</a>                                   =&gt; <a href="#70399" title="Types.this.Type">tycon</a> // needed for neg/t0226
      <span class="keyword">case</span> <span title="Nothing">_</span>                                              =&gt; <a href="SymbolTable.scala.html#36939" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><a href="TypeDebugging.scala.html#40679" title="(tp: Types.this.Type)String">debugString</a><span class="delimiter">(</span><a href="#70399" title="Types.this.Type">tycon</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  /** A creator for type parameterizations that strips empty type parameter lists.
   *  Use this factory method to indicate the type has kind * (it's a polymorphic value)
   *  until we start tracking explicit kinds equivalent to typeFun (except that the latter requires tparams nonEmpty).
   *
   *  PP to AM: I've co-opted this for where I know tparams may well be empty, and
   *  expecting to get back `tpe` in such cases.  Re being &quot;forgiving&quot; below,
   *  can we instead say this is the canonical creator for polyTypes which
   *  may or may not be poly? (It filched the standard &quot;canonical creator&quot; name.)
   */
  <span class="keyword">def</span> <a title="(tparams: List[Types.this.Symbol], tpe: Types.this.Type)Types.this.Type" id="40205">polyType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="73449">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="73450">tpe</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#73449" title="List[Types.this.Symbol]">tparams</a> <span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#40207" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#73449" title="List[Types.this.Symbol]">tparams</a>, <a href="#73450" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <a href="#73450" title="Types.this.Type">tpe</a> // it's okay to be forgiving here

  /** A creator for anonymous type functions, where the symbol for the type function still needs to be created.
   *
   * TODO:
   * type params of anonymous type functions, which currently can only arise from normalising type aliases, are owned by the type alias of which they are the eta-expansion
   * higher-order subtyping expects eta-expansion of type constructors that arise from a class; here, the type params are owned by that class, but is that the right thing to do?
   */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type" id="40206">typeFunAnon</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="133198">tps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="133199">body</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40207" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#133198" title="List[Types.this.Symbol]">tps</a>, <a href="#133199" title="Types.this.Type">body</a><span class="delimiter">)</span>

  /** A creator for a type functions, assuming the type parameters tps already have the right owner. */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type" id="40207">typeFun</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="131796">tps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="131797">body</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#67004" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#131796" title="List[Types.this.Symbol]">tps</a>, <a href="#131797" title="Types.this.Type">body</a><span class="delimiter">)</span>

  /** A creator for existential types. This generates:
   *
   *  tpe1 where { tparams }
   *
   *  where `tpe1` is the result of extrapolating `tpe` wrt to `tparams`.
   *  Extrapolating means that type variables in `tparams` occurring
   *  in covariant positions are replaced by upper bounds, (minus any
   *  SingletonClass markers), type variables in `tparams` occurring in
   *  contravariant positions are replaced by upper bounds, provided the
   *  resulting type is legal wrt to stability, and does not contain any type
   *  variable in `tparams`.
   *
   *  The abstraction drops all type parameters that are not directly or
   *  indirectly referenced by type `tpe1`. If there are no remaining type
   *  parameters, simply returns result type `tpe`.
   */
  <span class="keyword">def</span> <a title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type" id="40208">existentialAbstraction</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="129665">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="129666">tpe0</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#129665" title="List[Types.this.Symbol]">tparams</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#129666" title="Types.this.Type">tpe0</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="136925">tpe</a>      = <a href="#136931" title="(tp: Types.this.Type)Types.this.Type">deAlias</a><span class="delimiter">(</span><a href="#129666" title="Types.this.Type">tpe0</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="136926">tpe1</a>     = <span title="Types.this.ExistentialExtrapolation" class="keyword">new</span> <a href="#40252" title="Types.this.ExistentialExtrapolation">ExistentialExtrapolation</a><span class="delimiter">(</span><a href="#129665" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <a href="#136949" title="(tpe: Types.this.Type)Types.this.Type">extrapolate</a> <a href="#136925" title="Types.this.Type">tpe</a>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="136927">tparams0</a> = <a href="#129665" title="List[Types.this.Symbol]">tparams</a>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="136928">tparams1</a> = <a href="#136927" title="List[Types.this.Symbol]">tparams0</a> <span title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">filter</span> <a href="#136926" title="Types.this.Type">tpe1</a>.<a href="#42793" title="(sym: Types.this.Symbol)Boolean">contains</a>

      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#136928" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#136927" title="List[Types.this.Symbol]">tparams0</a><span class="delimiter">)</span> <a href="#136929" title="()Unit" class="delimiter">{</a>
        <a href="#136927" title="List[Types.this.Symbol]">tparams0</a> = <a href="#136928" title="List[Types.this.Symbol]">tparams1</a>
        <a href="#136928" title="List[Types.this.Symbol]">tparams1</a> = <a href="#129665" title="List[Types.this.Symbol]">tparams</a> <span title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">filter</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="136971">p</a> =&gt;
          <a href="#136928" title="List[Types.this.Symbol]">tparams1</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="136980">p1</a> =&gt; <a href="#136980" title="Types.this.Symbol">p1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#136971" title="Types.this.Symbol">p</a> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#136980" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a> <a href="#42793" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#136971" title="Types.this.Symbol">p</a><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#40155" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">(</span><a href="#136928" title="List[Types.this.Symbol]">tparams1</a>, <a href="#136926" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  /** Remove any occurrences of type aliases from this type */
  <span class="keyword">object</span> <a title="object Types.this.deAlias" id="40209">deAlias</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="136931">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="136932">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a> <span class="delimiter">{</span>
      <a href="#136932" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="136996">pre</a>, <a title="Types.this.Symbol" id="136997">sym</a>, <a title="List[Types.this.Type]" id="136998">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#136997" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47759" title="=&gt; Boolean">isAliasType</a> =&gt; <a href="#136932" title="Types.this.Type">tp</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#136932" title="Types.this.Type">tp</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Remove any occurrence of type &lt;singleton&gt; from this type and its parents */
  <span class="keyword">object</span> <a title="object Types.this.dropSingletonType" id="40211">dropSingletonType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="116321">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="116322">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#116322" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span>_, <a href="Definitions.scala.html#46375" title="=&gt; Types.this.Symbol">SingletonClass</a>, _<span class="delimiter">)</span> =&gt;
          <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>
        <span class="keyword">case</span> <a title="Types.this.Type" id="137000">tp1</a> @ RefinedType<span class="delimiter">(</span><a title="List[Types.this.Type]" id="137001">parents</a>, <a title="Types.this.Scope" id="137002">decls</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">var</span> <a title="List[Types.this.Type]" id="137003">parents1</a> = <a href="#137001" title="List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a href="#137007" title="Types.this.Type">_</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#46375" title="=&gt; Types.this.Symbol">SingletonClass</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#137003" title="List[Types.this.Type]">parents1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#137003" title="List[Types.this.Type]">parents1</a> = <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#137003" title="List[Types.this.Type]">parents1</a>.<span title="=&gt; List[Types.this.Type]">tail</span>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#137002" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61748" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#137003" title="List[Types.this.Type]">parents1</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#40197" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#137000" title="Types.this.RefinedType">tp1</a>, <a href="#137003" title="List[Types.this.Type]">parents1</a>, <a href="#137002" title="Types.this.Scope">decls</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <a title="Types.this.Type" id="137040">tp1</a> =&gt;
          <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#137040" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Substitutes the empty scope for any non-empty decls in the type. */
  <span class="keyword">object</span> <a title="object Types.this.dropAllRefinements" id="40213">dropAllRefinements</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="137050">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="137052">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#137052" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="137055">rt</a> @ RefinedType<span class="delimiter">(</span><a title="List[Types.this.Type]" id="137056">parents</a>, <a title="Types.this.Scope" id="137057">decls</a><span class="delimiter">)</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#137057" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61748" title="=&gt; Boolean">isEmpty</a> =&gt;
        <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#40197" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#137055" title="Types.this.RefinedType">rt</a>, <a href="#137056" title="List[Types.this.Type]">parents</a>, <a href="Scopes.scala.html#40430" title="object Types.this.EmptyScope">EmptyScope</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ClassInfoType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="137066">parents</a>, <a title="Types.this.Scope" id="137067">decls</a>, <a title="Types.this.Symbol" id="137068">clazz</a><span class="delimiter">)</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#137067" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61748" title="=&gt; Boolean">isEmpty</a> =&gt;
        <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#71108" title="(parents: List[Types.this.Type], decls: Types.this.Scope, typeSymbol: Types.this.Symbol)Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">(</span><a href="#137066" title="List[Types.this.Type]">parents</a>, <a href="Scopes.scala.html#40430" title="object Types.this.EmptyScope">EmptyScope</a>, <a href="#137068" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#137052" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  // Set to true for A* =&gt; Seq[A]
  //   (And it will only rewrite A* in method result types.)
  //   This is the pre-existing behavior.
  // Or false for Seq[A] =&gt; Seq[A]
  //   (It will rewrite A* everywhere but method parameters.)
  //   This is the specified behavior.
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="40215">etaExpandKeepsStar</a> = <span title="Boolean(false)" class="keyword">false</span>

  <span class="keyword">object</span> <a title="object Types.this.dropRepeatedParamType" id="40216">dropRepeatedParamType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="137092">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="137094">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#137094" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.MethodType">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="137097">params</a>, <a title="Types.this.Type" id="137098">restpe</a><span class="delimiter">)</span> =&gt;
        <a href="#66899" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#137097" title="List[Types.this.Symbol]">params</a>, <a href="#137092" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#137098" title="Types.this.Type">restpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.PolyType">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="137100">tparams</a>, <a title="Types.this.Type" id="137101">restpe</a><span class="delimiter">)</span> =&gt;
        <a href="#67004" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#137100" title="List[Types.this.Symbol]">tparams</a>, <a href="#137092" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#137101" title="Types.this.Type">restpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span>_, <a href="Definitions.scala.html#46389" title="=&gt; Types.this.Symbol">RepeatedParamClass</a>, <a title="Types.this.Type" id="137106">arg</a> :: <span title="object Nil">Nil</span><span class="delimiter">)</span> =&gt;
        <a href="Definitions.scala.html#46560" title="(arg: Types.this.Type)Types.this.Type">seqType</a><span class="delimiter">(</span><a href="#137106" title="Types.this.Type">arg</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#40215" title="=&gt; Boolean">etaExpandKeepsStar</a><span class="delimiter">)</span> <a href="#137094" title="Types.this.Type">tp</a> <span class="keyword">else</span> <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#137094" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.toDeBruijn" id="40218">toDeBruijn</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[List[Types.this.Symbol]]" id="137118">paramStack</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="object Nil">Nil</span>
    <span class="keyword">def</span> <a title="(params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.DeBruijnBinder" id="137120">mkDebruijnBinder</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="137124">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="137125">restpe</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#137118" title="(x$1: List[List[Types.this.Symbol]])Unit">paramStack</a> = <a href="#137124" title="List[Types.this.Symbol]">params</a> <a href="#137128" title="(x: List[Types.this.Symbol])List[List[Types.this.Symbol]]">::</a> <a href="#137118" title="=&gt; List[List[Types.this.Symbol]]">paramStack</a>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#146907" title="(pnames: List[Types.this.Name], ptypes: List[Types.this.Type], restpe: Types.this.Type)Types.this.DeBruijnBinder">DeBruijnBinder</a><span class="delimiter">(</span><a href="#137124" title="List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Name)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Name,List[Types.this.Name]])List[Types.this.Name]">map</span> <span class="delimiter">(</span><a href="#137164" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>, <a href="#137124" title="List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="137213">p</a> =&gt; <a href="#137121" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#137213" title="Types.this.Symbol">p</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#137121" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#137125" title="Types.this.Type">restpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <a href="#137118" title="(x$1: List[List[Types.this.Symbol]])Unit">paramStack</a> = <a href="#137118" title="=&gt; List[List[Types.this.Symbol]]">paramStack</a>.<span title="=&gt; List[List[Types.this.Symbol]]">tail</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="137121">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="137214">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#137214" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.DeBruijnBinder">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="137250">tparams</a>, <a title="Types.this.Type" id="137251">restpe</a><span class="delimiter">)</span> =&gt;
        <a href="#137120" title="(params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.DeBruijnBinder">mkDebruijnBinder</a><span class="delimiter">(</span><a href="#137250" title="List[Types.this.Symbol]">tparams</a>, <a href="#137251" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.DeBruijnBinder">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="137252">params</a>, <a title="Types.this.Type" id="137253">restpe</a><span class="delimiter">)</span> =&gt;
        <a href="#137120" title="(params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.DeBruijnBinder">mkDebruijnBinder</a><span class="delimiter">(</span><a href="#137252" title="List[Types.this.Symbol]">params</a>, <a href="#137253" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="137254">sym</a>, <a title="List[Types.this.Type]" id="137255">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Int" id="137256">level</a> = <a href="#137118" title="=&gt; List[List[Types.this.Symbol]]">paramStack</a> <span title="(p: List[Types.this.Symbol] =&gt; Boolean)Int">indexWhere</span> <span class="delimiter">(</span><a href="#137271" title="List[Types.this.Symbol]">_</a> <span title="(elem: Any)Boolean">contains</span> <a href="#137254" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#137256" title="Int">level</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#137214" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#146911" title="(level: Int, idx: Int, args: List[Types.this.Type])Types.this.DeBruijnIndex">DeBruijnIndex</a><span class="delimiter">(</span><a href="#137256" title="Int">level</a>, <a href="#137118" title="(n: Int)List[Types.this.Symbol]">paramStack</a><span class="delimiter">(</span><a href="#137256" title="Int">level</a><span class="delimiter">)</span> <span title="(elem: Types.this.Symbol)Int">indexOf</span> <a href="#137254" title="Types.this.Symbol">sym</a>, <a href="#137255" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="keyword">this</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#137214" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.TypeMap" id="40220">fromDeBruijn</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="137335">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#137338" title="Types.this.TypeMap {}" class="keyword">new</a> <a href="#40242" title="anonymous class $anon extends Types.this.TypeMap" id="137338">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[List[Types.this.Symbol]]" id="137341">paramStack</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="object Nil">Nil</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="137343">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="137344">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#137344" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">DeBruijnBinder</span><span class="delimiter">(</span><a title="List[Types.this.Name]" id="137375">pnames</a>, <a title="List[Types.this.Type]" id="137376">ptypes</a>, <a title="Types.this.Type" id="137377">restpe</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Boolean" id="137378">isType</a> = <a href="#137375" title="List[Types.this.Name]">pnames</a>.<span title="=&gt; Types.this.Name">head</span>.<a href="Names.scala.html#53411" title="=&gt; Boolean">isTypeName</a>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="137379">newParams</a> = <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Name" id="137397">name</a> &lt;- <a href="#137375" title="(f: Types.this.Name =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Name],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">pnames</a><span class="delimiter">)</span> <span class="keyword">yield</span>
          <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#137378" title="Boolean">isType</a><span class="delimiter">)</span> <a href="#137335" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#47726" title="(name: Types.this.TypeName, pos: Types.this.Position, newFlags: Long)Types.this.Symbol">newTypeParameter</a><span class="delimiter">(</span><a href="#137397" title="Types.this.Name">name</a>.<a href="Names.scala.html#53413" title="=&gt; Types.this.TypeName">toTypeName</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#137335" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#47700" title="(name: Types.this.TermName, pos: Types.this.Position, newFlags: Long)Types.this.TermSymbol">newValueParameter</a><span class="delimiter">(</span><a href="#137397" title="Types.this.Name">name</a>.<a href="Names.scala.html#53412" title="=&gt; Types.this.TermName">toTermName</a><span class="delimiter">)</span>
        <a href="#137341" title="(x$1: List[List[Types.this.Symbol]])Unit">paramStack</a> = <a href="#137379" title="List[Types.this.Symbol]">newParams</a> <a href="#137431" title="(x: List[Types.this.Symbol])List[List[Types.this.Symbol]]">::</a> <a href="#137341" title="=&gt; List[List[Types.this.Symbol]]">paramStack</a>
        <span class="keyword">try</span> <span class="delimiter">{</span>
          <span title="(_1: List[Types.this.Symbol], _2: List[Types.this.Type])(List[Types.this.Symbol], List[Types.this.Type])" class="delimiter">(</span><a href="#137379" title="List[Types.this.Symbol]">newParams</a>, <a href="#137376" title="List[Types.this.Type]">ptypes</a><span class="delimiter">)</span>.<span title="(implicit w1: List[Types.this.Symbol] =&gt; scala.collection.TraversableLike[Types.this.Symbol,List[Types.this.Symbol]], implicit w2: List[Types.this.Type] =&gt; scala.collection.IterableLike[Types.this.Type,List[Types.this.Type]])(List[Types.this.Symbol], List[Types.this.Type])#Zipped[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Type],Types.this.Type]">zipped</span> <span title="(f: (Types.this.Symbol, Types.this.Type) =&gt; Types.this.Symbol)Unit">foreach</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="137488">p</a>, <a title="Types.this.Type" id="137489">t</a><span class="delimiter">)</span> =&gt; <a href="#137488" title="Types.this.Symbol">p</a> <a href="Symbols.scala.html#47922" title="(info: Types.this.Type)p.type">setInfo</a> <a href="#137343" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#137489" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="137435">restpe1</a> = <a href="#137343" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#137377" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#137378" title="Boolean">isType</a><span class="delimiter">)</span> <a href="#67004" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#137379" title="List[Types.this.Symbol]">newParams</a>, <a href="#137435" title="Types.this.Type">restpe1</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#66899" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#137379" title="List[Types.this.Symbol]">newParams</a>, <a href="#137435" title="Types.this.Type">restpe1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <a href="#137341" title="(x$1: List[List[Types.this.Symbol]])Unit">paramStack</a> = <a href="#137341" title="=&gt; List[List[Types.this.Symbol]]">paramStack</a>.<span title="=&gt; List[List[Types.this.Symbol]]">tail</span>
      <span class="keyword">case</span> <span title="Types.this.Type">DeBruijnIndex</span><span class="delimiter">(</span><a title="Int" id="137538">level</a>, <a title="Int" id="137539">idx</a>, <a title="List[Types.this.Type]" id="137540">args</a><span class="delimiter">)</span> =&gt;
        <a href="#66645" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="#137341" title="(n: Int)List[Types.this.Symbol]">paramStack</a><span title="(n: Int)Types.this.Symbol" class="delimiter">(</span><a href="#137538" title="Int">level</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#137539" title="Int">idx</a><span class="delimiter">)</span>, <a href="#137540" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#137338" title="Types.this.TypeMap {}" class="keyword">this</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#137344" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

// Hash consing --------------------------------------------------------------

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="Int" id="40221">initialUniquesCapacity</a> = <span title="Int(4096)" class="int">4096</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="scala.reflect.internal.util.HashSet[Types.this.Type]" id="40224">uniques</a>: util.<a href="util/HashSet.scala.html#10629" title="scala.reflect.internal.util.HashSet[Types.this.Type]">HashSet</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = _
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="40227">uniqueRunId</a> = <span title="Int(0)">NoRunId</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T &lt;: Types.this.Type](tp: T)T" id="40229">unique</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Types.this.Type" id="40231">T</a> &lt;: Type<span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="130883">tp</a>: <a href="#40231" title="T">T</a><span class="delimiter">)</span>: <a href="#40231" title="T">T</a> = <span class="delimiter">{</span>
    <a href="util/StatBase.scala.html#39915" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39957" title="=&gt; scala.reflect.internal.util.Statistics.Counter">rawTypeCount</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#40227" title="=&gt; Int">uniqueRunId</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#36965" title="=&gt; Types.this.RunId">currentRunId</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#40224" title="(x$1: scala.reflect.internal.util.HashSet[Types.this.Type])Unit">uniques</a> = util.<a href="util/HashSet.scala.html#137637" title="[T &gt;: Null &lt;: AnyRef](label: String, initialCapacity: Int)scala.reflect.internal.util.HashSet[T]">HashSet</a><span title="(label: String, initialCapacity: Int)scala.reflect.internal.util.HashSet[Types.this.Type]" class="delimiter">[</span><a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="String(&quot;uniques&quot;)" class="string">&quot;uniques&quot;</span>, <a href="#40221" title="=&gt; Int">initialUniquesCapacity</a><span class="delimiter">)</span>
      <a href="#40227" title="(x$1: Int)Unit">uniqueRunId</a> = <a href="SymbolTable.scala.html#36965" title="=&gt; Types.this.RunId">currentRunId</a>
    <span class="delimiter">}</span>
    <span class="delimiter">(</span><a href="#40224" title="=&gt; scala.reflect.internal.util.HashSet[Types.this.Type]">uniques</a> <a href="util/HashSet.scala.html#128856" title="(x: Types.this.Type)Types.this.Type">findEntryOrUpdate</a> <a href="#130883" title="T">tp</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#40231" title="T">T</a><span class="delimiter">]</span>
  <span class="delimiter">}</span>

// Helper Classes ---------------------------------------------------------

  /** @PP: Unable to see why these apparently constant types should need vals
   *  in every TypeConstraint, I lifted them out.
   */
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.Type" id="40233">numericLoBound</a> = <a href="Definitions.scala.html#46842" title="=&gt; Types.this.Symbol">IntClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.Type" id="40235">numericHiBound</a> = <a href="#40202" title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">intersectionType</a><span class="delimiter">(</span><span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="Definitions.scala.html#46836" title="=&gt; Types.this.Symbol">ByteClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>, <a href="Definitions.scala.html#46840" title="=&gt; Types.this.Symbol">CharClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>, <a href="Definitions.scala.html#46254" title="=&gt; Types.this.Symbol">ScalaPackageClass</a><span class="delimiter">)</span>

  /** A class expressing upper and lower bounds constraints of type variables,
   * as well as their instantiations.
   */
  <span class="keyword">class</span> <a title="class TypeConstraint extends Object with ScalaObject" id="40237">TypeConstraint</a><a href="#40237" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Type]" id="85211">lo0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="85212">hi0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Type" id="85213">numlo0</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="85214">numhi0</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Boolean" id="85217">avoidWidening0</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(lo0: List[Types.this.Type], hi0: List[Types.this.Type])Types.this.TypeConstraint" id="84276" class="keyword">this</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="85207">lo0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="85208">hi0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#40237" title="TypeConstraint.this.type" class="keyword">this</a><span class="delimiter">(</span><a href="#85207" title="List[Types.this.Type]">lo0</a>, <a href="#85208" title="List[Types.this.Type]">hi0</a>, <a href="#130794" title="object Types.this.NoType">NoType</a>, <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(bounds: Types.this.TypeBounds)Types.this.TypeConstraint" id="84277" class="keyword">this</a><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="85205">bounds</a>: <a href="#66864" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">)</span> = <a href="#84276" title="(lo0: List[Types.this.Type], hi0: List[Types.this.Type])Types.this.TypeConstraint" class="keyword">this</a><span class="delimiter">(</span><span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#85205" title="Types.this.TypeBounds">bounds</a>.<a href="#66878" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#85205" title="Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="()Types.this.TypeConstraint" id="84278" class="keyword">this</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="#84276" title="(lo0: List[Types.this.Type], hi0: List[Types.this.Type])Types.this.TypeConstraint" class="keyword">this</a><span class="delimiter">(</span>List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

    /** Guard these lists against AnyClass and NothingClass appearing,
     *  else loBounds.isEmpty will have different results for an empty
     *  constraint and one with Nothing as a lower bound.  [Actually
     *  guarding addLoBound/addHiBound somehow broke raw types so it
     *  only guards against being created with them.]
     */
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[Types.this.Type]" id="84280">lobounds</a> = <a href="#85211" title="List[Types.this.Type]">lo0</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</span> <span class="delimiter">(</span><a href="#129017" title="Types.this.Type">_</a>.<a href="#42730" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[Types.this.Type]" id="84283">hibounds</a> = <a href="#85212" title="List[Types.this.Type]">hi0</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</span> <span class="delimiter">(</span><a href="#129021" title="Types.this.Type">_</a>.<a href="#42730" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="84286">numlo</a> = <a href="#85213" title="Types.this.Type">numlo0</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="84289">numhi</a> = <a href="#85214" title="Types.this.Type">numhi0</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Boolean" id="84292">avoidWidening</a> = <a href="#85217" title="Boolean">avoidWidening0</a>

    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="84294">loBounds</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#84286" title="=&gt; Types.this.Type">numlo</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <a href="#84280" title="=&gt; List[Types.this.Type]">lobounds</a> <span class="keyword">else</span> <a href="#84286" title="=&gt; Types.this.Type">numlo</a> <a href="#137741" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#84280" title="=&gt; List[Types.this.Type]">lobounds</a>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="84295">hiBounds</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#84289" title="=&gt; Types.this.Type">numhi</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <a href="#84283" title="=&gt; List[Types.this.Type]">hibounds</a> <span class="keyword">else</span> <a href="#84289" title="=&gt; Types.this.Type">numhi</a> <a href="#137752" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#84283" title="=&gt; List[Types.this.Type]">hibounds</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="84296">avoidWiden</a>: <span title="Boolean">Boolean</span> = <a href="#84292" title="=&gt; Boolean">avoidWidening</a>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="84297">addLoBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="136112">tp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Boolean" id="136115">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#136115" title="Boolean">isNumericBound</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#46785" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#136112" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#84286" title="=&gt; Types.this.Type">numlo</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#130794" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">||</span> <a href="#40360" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#84286" title="=&gt; Types.this.Type">numlo</a>, <a href="#136112" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#84286" title="(x$1: Types.this.Type)Unit">numlo</a> = <a href="#136112" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#40360" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#136112" title="Types.this.Type">tp</a>, <a href="#84286" title="=&gt; Types.this.Type">numlo</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#84286" title="(x$1: Types.this.Type)Unit">numlo</a> = <a href="#40232" title="=&gt; Types.this.Type">numericLoBound</a>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#84280" title="(x$1: List[Types.this.Type])Unit">lobounds</a> <span title="(x: Types.this.Type)List[Types.this.Type]">::=</span> <a href="#136112" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="84298">checkWidening</a><span class="delimiter">(</span><a title="Types.this.Type" id="137773">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#137773" title="Types.this.Type">tp</a>.<a href="#42715" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#84292" title="(x$1: Boolean)Unit">avoidWidening</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">else</span> <a href="#137773" title="Types.this.Type">tp</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="#135298" title="Unit">HasTypeMember</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#84292" title="(x$1: Boolean)Unit">avoidWidening</a> = <span title="Boolean(true)" class="keyword">true</span>
        <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="84299">addHiBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="136120">tp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Boolean" id="136123">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#84298" title="(tp: Types.this.Type)Unit">checkWidening</a><span class="delimiter">(</span><a href="#136120" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#136123" title="Boolean">isNumericBound</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#46785" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#136120" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#84289" title="=&gt; Types.this.Type">numhi</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#130794" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">||</span> <a href="#40360" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#136120" title="Types.this.Type">tp</a>, <a href="#84289" title="=&gt; Types.this.Type">numhi</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#84289" title="(x$1: Types.this.Type)Unit">numhi</a> = <a href="#136120" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#40360" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#84289" title="=&gt; Types.this.Type">numhi</a>, <a href="#136120" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#84289" title="(x$1: Types.this.Type)Unit">numhi</a> = <a href="#40234" title="=&gt; Types.this.Type">numericHiBound</a>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#84283" title="(x$1: List[Types.this.Type])Unit">hibounds</a> <span title="(x: Types.this.Type)List[Types.this.Type]">::=</span> <a href="#136120" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="84300">isWithinBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="136241">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <a href="#84280" title="=&gt; List[Types.this.Type]">lobounds</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#137794" title="Types.this.Type">_</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#136241" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <a href="#84283" title="=&gt; List[Types.this.Type]">hibounds</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#136241" title="Types.this.Type">tp</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#137804" title="Types.this.Type">_</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span class="delimiter">(</span><a href="#84286" title="=&gt; Types.this.Type">numlo</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#130794" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#84286" title="=&gt; Types.this.Type">numlo</a> <a href="#42798" title="(that: Types.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#136241" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span class="delimiter">(</span><a href="#84289" title="=&gt; Types.this.Type">numhi</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#130794" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#136241" title="Types.this.Type">tp</a> <a href="#42798" title="(that: Types.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#84289" title="=&gt; Types.this.Type">numhi</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">var</span> <a title="Types.this.Type" id="84302">inst</a>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#130794" title="object Types.this.NoType">NoType</a> // @M reduce visibility?

    <span class="keyword">def</span> <a title="=&gt; Boolean" id="84304">instValid</a> = <span class="delimiter">(</span><a href="#84302" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#84302" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeConstraint" id="84305">cloneInternal</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.TypeConstraint" id="129011">tc</a> = <span title="Types.this.TypeConstraint" class="keyword">new</span> <a href="#40237" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">(</span><a href="#84280" title="=&gt; List[Types.this.Type]">lobounds</a>, <a href="#84283" title="=&gt; List[Types.this.Type]">hibounds</a>, <a href="#84286" title="=&gt; Types.this.Type">numlo</a>, <a href="#84289" title="=&gt; Types.this.Type">numhi</a>, <a href="#84292" title="=&gt; Boolean">avoidWidening</a><span class="delimiter">)</span>
      <a href="#129011" title="Types.this.TypeConstraint">tc</a>.<a href="#84302" title="(x$1: Types.this.Type)Unit">inst</a> = <a href="#84302" title="=&gt; Types.this.Type">inst</a>
      <a href="#129011" title="Types.this.TypeConstraint">tc</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="84306">toString</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="137819">boundsStr</a> = <span class="delimiter">(</span>
        <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#84294" title="=&gt; List[Types.this.Type]">loBounds</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#84295" title="=&gt; List[Types.this.Type]">hiBounds</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="String(&quot;[]&quot;)" class="string">&quot;[]&quot;</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="String" id="137822">lostr</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#84294" title="=&gt; List[Types.this.Type]">loBounds</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="#84294" title="=&gt; List[Types.this.Type]">loBounds</a> <span title="(f: Types.this.Type =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],String,List[String]])List[String]">map</span> <span class="delimiter">(</span><a href="#137844" title="Types.this.Type">_</a>.<a href="#42814" title="=&gt; String">safeToString</a><span class="delimiter">)</span> <span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;_&gt;:(&quot;)" class="string">&quot;_&gt;:(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="String" id="137823">histr</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#84295" title="=&gt; List[Types.this.Type]">hiBounds</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="#84295" title="=&gt; List[Types.this.Type]">hiBounds</a> <span title="(f: Types.this.Type =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],String,List[String]])List[String]">map</span> <span class="delimiter">(</span><a href="#137895" title="Types.this.Type">_</a>.<a href="#42814" title="=&gt; String">safeToString</a><span class="delimiter">)</span> <span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;_&lt;:(&quot;)" class="string">&quot;_&lt;:(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
          <span title="(xs: String*)List[String]">List</span><span class="delimiter">(</span><a href="#137822" title="String">lostr</a>, <a href="#137823" title="String">histr</a><span class="delimiter">)</span> <span title="(p: String =&gt; Boolean)List[String]">filterNot</span> <span class="delimiter">(</span><a href="#137938" title="String">_</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span> <span title="(start: String, sep: String, end: String)String">mkString</span> <span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot; | &quot;)" class="string">&quot; | &quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">)</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#84302" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <a href="#137819" title="String">boundsStr</a>
      <span class="keyword">else</span> <a href="#137819" title="String">boundsStr</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; _= &quot;)" class="string">&quot; _= &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#84302" title="=&gt; Types.this.Type">inst</a>.<a href="#42814" title="=&gt; String">safeToString</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait AnnotationFilter extends Types.this.TypeMap with ScalaObject" id="40239">AnnotationFilter</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(annot: Types.this.AnnotationInfo)Boolean" id="129655">keepAnnotation</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="137952">annot</a>: <a href="AnnotationInfos.scala.html#40591" title="Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(annot: Types.this.AnnotationInfo)Types.this.AnnotationInfo" id="129656">mapOver</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="137954">annot</a>: <a href="AnnotationInfos.scala.html#40591" title="Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span> =
      <span title="Types.this.AnnotationInfo" class="keyword">if</span> <span class="delimiter">(</span><a href="#129655" title="(annot: Types.this.AnnotationInfo)Boolean">keepAnnotation</a><span class="delimiter">(</span><a href="#137954" title="Types.this.AnnotationInfo">annot</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#40239" title="Types.this.AnnotationFilter" class="keyword">super</a>.<a href="#82358" title="(annot: Types.this.AnnotationInfo)Types.this.AnnotationInfo">mapOver</a><span class="delimiter">(</span><a href="#137954" title="Types.this.AnnotationInfo">annot</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="AnnotationInfos.scala.html#40594" title="object Types.this.UnmappableAnnotation">UnmappableAnnotation</a>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait KeepOnlyTypeConstraints extends Types.this.TypeMap with Types.this.AnnotationFilter with ScalaObject" id="40240">KeepOnlyTypeConstraints</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40239" title="Types.this.AnnotationFilter">AnnotationFilter</a> <span class="delimiter">{</span>
    // filter keeps only type constraint annotations
    <span class="keyword">def</span> <a title="(annot: Types.this.AnnotationInfo)Boolean" id="129658">keepAnnotation</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="137968">annot</a>: <a href="AnnotationInfos.scala.html#40591" title="Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span> = <a href="#137968" title="Types.this.AnnotationInfo">annot</a> <a href="AnnotationInfos.scala.html#47257" title="(clazz: Types.this.Symbol)Boolean">matches</a> <a href="Definitions.scala.html#46373" title="=&gt; Types.this.Symbol">TypeConstraintClass</a>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait VariantTypeMap extends Types.this.TypeMap with ScalaObject" id="40241">VariantTypeMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">var</span> <a title="Int" id="136937">_variance</a> = <span title="Int(1)" class="int">1</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="136938">variance</a> = <a href="#136937" title="Int">_variance</a>
    <span class="keyword">def</span> <a title="(x: Int)Unit" id="136939">variance_=</a><span class="delimiter">(</span><a title="Int" id="137980">x</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#136937" title="Int">_variance</a> = <a href="#137980" title="Int">x</a>
    
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(origSyms: List[Types.this.Symbol])Boolean" id="136940">noChangeToSymbols</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="137983">origSyms</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#137983" title="List[Types.this.Symbol]">origSyms</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="138010">sym</a> =&gt;
        <span class="keyword">val</span> <a title="Int" id="138011">v</a> = <a href="#136938" title="=&gt; Int">variance</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#138010" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47759" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span> <a href="#136939" title="(x: Int)Unit">variance</a> = <span title="Int(0)" class="int">0</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="138012">result</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138010" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span>
        <a href="#136939" title="(x: Int)Unit">variance</a> = <a href="#138011" title="Int">v</a>
        <a href="#138012" title="Types.this.Type">result</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138010" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]" id="136941">mapOverArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="138021">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="138022">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> =
      <a href="#40336" title="(xs: List[Types.this.Type], ys: List[Types.this.Symbol])(f: (Types.this.Type, Types.this.Symbol) =&gt; Types.this.Type)List[Types.this.Type]">map2Conserve</a><span class="delimiter">(</span><a href="#138021" title="List[Types.this.Type]">args</a>, <a href="#138022" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Type" id="138067">arg</a>, <a title="Types.this.Symbol" id="138068">tparam</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Int" id="138069">v</a> = <a href="#136938" title="=&gt; Int">variance</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#138068" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47766" title="=&gt; Boolean">isContravariant</a><span class="delimiter">)</span> <a href="#136939" title="(x: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#136938" title="=&gt; Int">variance</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#138068" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47768" title="=&gt; Boolean">isCovariant</a><span class="delimiter">)</span> <a href="#136939" title="(x: Int)Unit">variance</a> = <span title="Int(0)" class="int">0</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="138070">arg1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138067" title="Types.this.Type">arg</a><span class="delimiter">)</span>
        <a href="#136939" title="(x: Int)Unit">variance</a> = <a href="#138069" title="Int">v</a>
        <a href="#138070" title="Types.this.Type">arg1</a>
      <span class="delimiter">}</span>

    /** Map this function over given type */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="136942">mapOver</a><span class="delimiter">(</span><a title="Types.this.Type" id="138079">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#138079" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="138082">params</a>, <a title="Types.this.Type" id="138083">result</a><span class="delimiter">)</span> =&gt;
        <a href="#136939" title="(x: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#136938" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="138084">params1</a> = <a href="#82357" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#138082" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
        <a href="#136939" title="(x: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#136938" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="138085">result1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138083" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#138084" title="List[Types.this.Symbol]">params1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138082" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#138085" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138083" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#138079" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#40201" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#138079" title="Types.this.Type">tp</a>, <a href="#138084" title="List[Types.this.Symbol]">params1</a>, <a href="#138085" title="Types.this.Type">result1</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#138082" title="List[Types.this.Symbol]">params</a>, <a href="#138084" title="List[Types.this.Symbol]">params1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="138100">tparams</a>, <a title="Types.this.Type" id="138101">result</a><span class="delimiter">)</span> =&gt;
        <a href="#136939" title="(x: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#136938" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="138102">tparams1</a> = <a href="#82357" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#138100" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
        <a href="#136939" title="(x: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#136938" title="=&gt; Int">variance</a>
        <span class="keyword">var</span> <a title="Types.this.Type" id="138103">result1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138101" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#138102" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138100" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#138103" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138101" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#138079" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#67004" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#138102" title="List[Types.this.Symbol]">tparams1</a>, <a href="#138103" title="Types.this.Type">result1</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#138100" title="List[Types.this.Symbol]">tparams</a>, <a href="#138102" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="138118">lo</a>, <a title="Types.this.Type" id="138119">hi</a><span class="delimiter">)</span> =&gt;
        <a href="#136939" title="(x: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#136938" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="138120">lo1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138118" title="Types.this.Type">lo</a><span class="delimiter">)</span>
        <a href="#136939" title="(x: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#136938" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="138121">hi1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138119" title="Types.this.Type">hi</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#138120" title="Types.this.Type">lo1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138118" title="Types.this.Type">lo</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#138121" title="Types.this.Type">hi1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138119" title="Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#138079" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#66838" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#138120" title="Types.this.Type">lo1</a>, <a href="#138121" title="Types.this.Type">hi1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="138138">tr</a> @ TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="138139">pre</a>, <a title="Types.this.Symbol" id="138140">sym</a>, <a title="List[Types.this.Type]" id="138141">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="138142">pre1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138139" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="138143">args1</a> =
          <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#138141" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
            <a href="#138141" title="List[Types.this.Type]">args</a>
          <span class="keyword">else</span> <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#136938" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> // fast &amp; safe path: don't need to look at typeparams
            <a href="#138141" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <a href="#40241" title="Types.this.VariantTypeMap" class="keyword">this</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="138163">tparams</a> = <a href="#138140" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a>
            <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#138163" title="List[Types.this.Symbol]">tparams</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#138141" title="List[Types.this.Type]">args</a>
            <span class="keyword">else</span> <a href="#136941" title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">mapOverArgs</a><span class="delimiter">(</span><a href="#138141" title="List[Types.this.Type]">args</a>, <a href="#138163" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#138142" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138139" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#138143" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138141" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#138079" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#40199" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#138079" title="Types.this.Type">tp</a>, <a href="#138142" title="Types.this.Type">pre1</a>, <a href="#138138" title="Types.this.TypeRef">tr</a>.<a href="#66675" title="(pre1: Types.this.Type)Types.this.Symbol">coevolveSym</a><span class="delimiter">(</span><a href="#138142" title="Types.this.Type">pre1</a><span class="delimiter">)</span>, <a href="#138143" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#40241" title="Types.this.VariantTypeMap" class="keyword">super</a>.<a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#138079" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A prototype for mapping a function over all possible types
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeMap extends Object with Types.this.Type =&gt; Types.this.Type with ScalaObject" id="40242">TypeMap</a> <a href="#40242" title="ScalaObject" class="keyword">extends</a> <span class="delimiter">(</span>Type =&gt; Type<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="82351">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="82373">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a>

    /** Mix in VariantTypeMap if you want variances to be significant.
     */
    <span class="keyword">def</span> <a title="=&gt; Int" id="82352">variance</a> = <span title="Int(0)" class="int">0</span>

    /** Map this function over given type */
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="82353">mapOver</a><span class="delimiter">(</span><a title="Types.this.Type" id="129957">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#129957" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="138172">tr</a> @ TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="138173">pre</a>, <a title="Types.this.Symbol" id="138174">sym</a>, <a title="List[Types.this.Type]" id="138175">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="138176">pre1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138173" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="138177">args1</a> = <a href="#138175" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <a href="#40242" title="Types.this.TypeMap" class="keyword">this</a>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#138176" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138173" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#138177" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138175" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#129957" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#40199" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#129957" title="Types.this.Type">tp</a>, <a href="#138176" title="Types.this.Type">pre1</a>, <a href="#138172" title="Types.this.TypeRef">tr</a>.<a href="#66675" title="(pre1: Types.this.Type)Types.this.Symbol">coevolveSym</a><span class="delimiter">(</span><a href="#138176" title="Types.this.Type">pre1</a><span class="delimiter">)</span>, <a href="#138177" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#129957" title="Types.this.Type">tp</a>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="138192">pre</a>, <a title="Types.this.Symbol" id="138193">sym</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#138193" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#129957" title="Types.this.Type">tp</a> // short path
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="138194">pre1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138192" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#138194" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138192" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#129957" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#40194" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#138194" title="Types.this.Type">pre1</a>, <a href="#138193" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="138203">params</a>, <a title="Types.this.Type" id="138204">result</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="138205">params1</a> = <a href="#82357" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#138203" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="138206">result1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138204" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#138205" title="List[Types.this.Symbol]">params1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138203" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#138206" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138204" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#129957" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#40201" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#129957" title="Types.this.Type">tp</a>, <a href="#138205" title="List[Types.this.Symbol]">params1</a>, <a href="#138206" title="Types.this.Type">result1</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#138203" title="List[Types.this.Symbol]">params</a>, <a href="#138205" title="List[Types.this.Symbol]">params1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="138221">tparams</a>, <a title="Types.this.Type" id="138222">result</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="138223">tparams1</a> = <a href="#82357" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#138221" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
        <span class="keyword">var</span> <a title="Types.this.Type" id="138224">result1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138222" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#138223" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138221" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#138224" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138222" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#129957" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#67004" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#138223" title="List[Types.this.Symbol]">tparams1</a>, <a href="#138224" title="Types.this.Type">result1</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#138221" title="List[Types.this.Symbol]">tparams</a>, <a href="#138223" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="138239">result</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="138240">result1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138239" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#138240" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138239" title="Types.this.Type">result</a><span class="delimiter">)</span> <a href="#129957" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#66963" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#138240" title="Types.this.Type">result1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ConstantType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#129957" title="Types.this.Type">tp</a>
      <span class="keyword">case</span> <span title="Types.this.Type">SuperType</span><span class="delimiter">(</span><a title="Types.this.Type" id="138250">thistp</a>, <a title="Types.this.Type" id="138251">supertp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="138252">thistp1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138250" title="Types.this.Type">thistp</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="138253">supertp1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138251" title="Types.this.Type">supertp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#138252" title="Types.this.Type">thistp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138250" title="Types.this.Type">thistp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#138253" title="Types.this.Type">supertp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138251" title="Types.this.Type">supertp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#129957" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#83635" title="(thistp: Types.this.Type, supertp: Types.this.Type)Types.this.Type">SuperType</a><span class="delimiter">(</span><a href="#138252" title="Types.this.Type">thistp1</a>, <a href="#138253" title="Types.this.Type">supertp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="138272">lo</a>, <a title="Types.this.Type" id="138273">hi</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="138274">lo1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138272" title="Types.this.Type">lo</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="138275">hi1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138273" title="Types.this.Type">hi</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#138274" title="Types.this.Type">lo1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138272" title="Types.this.Type">lo</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#138275" title="Types.this.Type">hi1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138273" title="Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#129957" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#66838" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#138274" title="Types.this.Type">lo1</a>, <a href="#138275" title="Types.this.Type">hi1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="138292">bounds</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="138293">bounds1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138292" title="Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#138293" title="Types.this.Type">bounds1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138292" title="Types.this.TypeBounds">bounds</a><span class="delimiter">)</span> <a href="#129957" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#146959" title="(bounds: Types.this.TypeBounds)Types.this.BoundedWildcardType">BoundedWildcardType</a><span class="delimiter">(</span><a href="#138293" title="Types.this.Type">bounds1</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.TypeBounds" class="delimiter">[</span><a href="#66864" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">]</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="138303">rtp</a> @ RefinedType<span class="delimiter">(</span><a title="List[Types.this.Type]" id="138304">parents</a>, <a title="Types.this.Scope" id="138305">decls</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="138306">parents1</a> = <a href="#138304" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <a href="#40242" title="Types.this.TypeMap" class="keyword">this</a>
        <span class="keyword">val</span> <a title="Types.this.Scope" id="138307">decls1</a> = <a href="#82356" title="(scope: Types.this.Scope)Types.this.Scope">mapOver</a><span class="delimiter">(</span><a href="#138305" title="Types.this.Scope">decls</a><span class="delimiter">)</span>
        //if ((parents1 eq parents) &amp;&amp; (decls1 eq decls)) tp
        //else refinementOfClass(tp.typeSymbol, parents1, decls1)
        <a href="#40197" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#138303" title="Types.this.RefinedType">rtp</a>, <a href="#138306" title="List[Types.this.Type]">parents1</a>, <a href="#138307" title="Types.this.Scope">decls1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="138320">tparams</a>, <a title="Types.this.Type" id="138321">result</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="138322">tparams1</a> = <a href="#82357" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#138320" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
        <span class="keyword">var</span> <a title="Types.this.Type" id="138323">result1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138321" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#138322" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138320" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#138323" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138321" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#129957" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#40155" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">(</span><a href="#138322" title="List[Types.this.Symbol]">tparams1</a>, <a href="#138323" title="Types.this.Type">result1</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#138320" title="List[Types.this.Symbol]">tparams</a>, <a href="#138322" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">OverloadedType</span><span class="delimiter">(</span><a title="Types.this.Type" id="138338">pre</a>, <a title="List[Types.this.Symbol]" id="138339">alts</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="138340">pre1</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#138338" title="Types.this.Type">pre</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#71108" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#138338" title="Types.this.Type">pre</a> <span class="keyword">else</span> <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138338" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#138340" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138338" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#129957" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#146955" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.OverloadedType">OverloadedType</a><span class="delimiter">(</span><a href="#138340" title="Types.this.Type">pre1</a>, <a href="#138339" title="List[Types.this.Symbol]">alts</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">AntiPolyType</span><span class="delimiter">(</span><a title="Types.this.Type" id="138349">pre</a>, <a title="List[Types.this.Type]" id="138350">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="138351">pre1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138349" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="138352">args1</a> = <a href="#138350" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a href="#40242" title="Types.this.TypeMap" class="keyword">this</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#138351" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138349" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#138352" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138350" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#129957" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#146951" title="(pre: Types.this.Type, targs: List[Types.this.Type])Types.this.AntiPolyType">AntiPolyType</a><span class="delimiter">(</span><a href="#138351" title="Types.this.Type">pre1</a>, <a href="#138352" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="138369">tv</a>@<a href="#84241" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="138371">constr</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#138371" title="Types.this.TypeConstraint">constr</a>.<a href="#84304" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138371" title="Types.this.TypeConstraint">constr</a>.<a href="#84302" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#138369" title="Types.this.TypeVar">tv</a>.<a href="#84207" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#82354" title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">mapOverArgs</a><span class="delimiter">(</span><a href="#138369" title="Types.this.TypeVar">tv</a>.<a href="#84199" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#138369" title="Types.this.TypeVar">tv</a>.<a href="#84198" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span>  //@M !args.isEmpty implies !typeParams.isEmpty
      <span class="keyword">case</span> <span title="Types.this.Type">NotNullType</span><span class="delimiter">(</span><a title="Types.this.Type" id="138380">tp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="138381">tp1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138380" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#138381" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138380" title="Types.this.Type">tp</a><span class="delimiter">)</span> <a href="#138380" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#146963" title="(underlying: Types.this.Type)Types.this.NotNullType">NotNullType</a><span class="delimiter">(</span><a href="#138381" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">AnnotatedType</span><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="138391">annots</a>, <a title="Types.this.Type" id="138392">atp</a>, <a title="Types.this.Symbol" id="138393">selfsym</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="138394">annots1</a> = <a href="#82359" title="(annots: List[Types.this.AnnotationInfo])List[Types.this.AnnotationInfo]">mapOverAnnotations</a><span class="delimiter">(</span><a href="#138391" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="138395">atp1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138392" title="Types.this.Type">atp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#138394" title="List[Types.this.AnnotationInfo]">annots1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138391" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#138395" title="Types.this.Type">atp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138392" title="Types.this.Type">atp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#129957" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#138394" title="List[Types.this.AnnotationInfo]">annots1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#138395" title="Types.this.Type">atp1</a>
        <span class="keyword">else</span> <a href="#59504" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#138394" title="List[Types.this.AnnotationInfo]">annots1</a>, <a href="#138395" title="Types.this.Type">atp1</a>, <a href="#138393" title="Types.this.Symbol">selfsym</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">DeBruijnIndex</span><span class="delimiter">(</span><a title="Int" id="138406">shift</a>, <a title="Int" id="138407">idx</a>, <a title="List[Types.this.Type]" id="138408">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="138409">args1</a> = <a href="#138408" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <a href="#40242" title="Types.this.TypeMap" class="keyword">this</a>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#138409" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138408" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <a href="#129957" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#146911" title="(level: Int, idx: Int, args: List[Types.this.Type])Types.this.DeBruijnIndex">DeBruijnIndex</a><span class="delimiter">(</span><a href="#138406" title="Int">shift</a>, <a href="#138407" title="Int">idx</a>, <a href="#138409" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
/*
      case ErrorType =&gt; tp
      case WildcardType =&gt; tp
      case NoType =&gt; tp
      case NoPrefix =&gt; tp
*/
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#129957" title="Types.this.Type">tp</a>
        // throw new Error(&quot;mapOver inapplicable for &quot; + tp);
    <span class="delimiter">}</span>

    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]" id="82354">mapOverArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="138024">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="138025">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> =
      <a href="#138024" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <a href="#40242" title="Types.this.TypeMap" class="keyword">this</a>
    
    /** Called by mapOver to determine whether the original symbols can
     *  be returned, or whether they must be cloned.  Overridden in VariantTypeMap.
     */
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(origSyms: List[Types.this.Symbol])Boolean" id="82355">noChangeToSymbols</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="137985">origSyms</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#137985" title="List[Types.this.Symbol]">origSyms</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="137994">sym</a> =&gt; <a href="#137994" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#82351" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#137994" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span>

    /** Map this function over given scope */
    <span class="keyword">def</span> <a title="(scope: Types.this.Scope)Types.this.Scope" id="82356">mapOver</a><span class="delimiter">(</span><a title="Types.this.Scope" id="129947">scope</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a><span class="delimiter">)</span>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="138422">elems</a> = <a href="#129947" title="Types.this.Scope">scope</a>.<a href="Scopes.scala.html#61763" title="=&gt; List[Types.this.Symbol]">toList</a>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="138423">elems1</a> = <a href="#82357" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#138422" title="List[Types.this.Symbol]">elems</a><span class="delimiter">)</span>
      <span title="Types.this.Scope" class="keyword">if</span> <span class="delimiter">(</span><a href="#138423" title="List[Types.this.Symbol]">elems1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138422" title="List[Types.this.Symbol]">elems</a><span class="delimiter">)</span> <a href="#129947" title="Types.this.Scope">scope</a>
      <span class="keyword">else</span> <a href="Scopes.scala.html#61746" title="(decls: List[Types.this.Symbol])Types.this.Scope" class="keyword">new</a> <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a><span class="delimiter">(</span><a href="#138423" title="List[Types.this.Symbol]">elems1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    
    /** Map this function over given list of symbols */
    <span class="keyword">def</span> <a title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]" id="82357">mapOver</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="129943">origSyms</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      // fast path in case nothing changes due to map
      <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#82355" title="(origSyms: List[Types.this.Symbol])Boolean">noChangeToSymbols</a><span class="delimiter">(</span><a href="#129943" title="List[Types.this.Symbol]">origSyms</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#129943" title="List[Types.this.Symbol]">origSyms</a>
      // map is not the identity --&gt; do cloning properly
      <span class="keyword">else</span> <a href="Symbols.scala.html#40020" title="(syms: List[Types.this.Symbol], infoFn: Types.this.Type =&gt; Types.this.Type)List[Types.this.Symbol]">cloneSymbolsAndModify</a><span class="delimiter">(</span><a href="#129943" title="List[Types.this.Symbol]">origSyms</a>, <a href="#40242" title="Types.this.TypeMap">TypeMap</a>.<span class="keyword">this</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(annot: Types.this.AnnotationInfo)Types.this.AnnotationInfo" id="82358">mapOver</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="129941">annot</a>: <a href="AnnotationInfos.scala.html#40591" title="Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span>: <a href="AnnotationInfos.scala.html#40591" title="Types.this.AnnotationInfo">AnnotationInfo</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="AnnotationInfos.scala.html#47274" title="(info: Types.this.AnnotationInfo)Option[(Types.this.Type, List[Types.this.Tree], List[(Types.this.Name, Types.this.ClassfileAnnotArg)])]">AnnotationInfo</a><a href="#138437" title="(Types.this.Type, List[Types.this.Tree], List[(Types.this.Name, Types.this.ClassfileAnnotArg)])" class="delimiter">(</a><a href="#138436" title="Types.this.Type" id="138437">atp</a>, <a href="#138436" title="List[Types.this.Tree]" id="138438">args</a>, <a href="#138436" title="List[(Types.this.Name, Types.this.ClassfileAnnotArg)]" id="138439">assocs</a><span class="delimiter">)</span> = <a href="#129941" title="Types.this.AnnotationInfo">annot</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="138440">atp1</a>  = <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#138437" title="Types.this.Type">atp</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Tree]" id="138441">args1</a> = <a href="#82360" title="(args: List[Types.this.Tree])List[Types.this.Tree]">mapOverAnnotArgs</a><span class="delimiter">(</span><a href="#138438" title="List[Types.this.Tree]">args</a><span class="delimiter">)</span>
      // there is no need to rewrite assocs, as they are constants

      <span title="Types.this.AnnotationInfo" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#138438" title="List[Types.this.Tree]">args</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138441" title="List[Types.this.Tree]">args1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#138437" title="Types.this.Type">atp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138440" title="Types.this.Type">atp1</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#129941" title="Types.this.AnnotationInfo">annot</a>
      <span class="keyword">else</span> <span title="Types.this.AnnotationInfo" class="keyword">if</span> <span class="delimiter">(</span><a href="#138441" title="List[Types.this.Tree]">args1</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#138438" title="List[Types.this.Tree]">args</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="AnnotationInfos.scala.html#40594" title="object Types.this.UnmappableAnnotation">UnmappableAnnotation</a>  // some annotation arg was unmappable
      <span class="keyword">else</span> <a href="AnnotationInfos.scala.html#47273" title="(atp: Types.this.Type, args: List[Types.this.Tree], assocs: List[(Types.this.Name, Types.this.ClassfileAnnotArg)])Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">(</span><a href="#138440" title="Types.this.Type">atp1</a>, <a href="#138441" title="List[Types.this.Tree]">args1</a>, <a href="#138439" title="List[(Types.this.Name, Types.this.ClassfileAnnotArg)]">assocs</a><span class="delimiter">)</span> <a href="AnnotationInfos.scala.html#47253" title="(pos: Types.this.Position)Types.this.AnnotationInfo">setPos</a> <a href="#129941" title="Types.this.AnnotationInfo">annot</a>.<a href="AnnotationInfos.scala.html#47252" title="=&gt; Types.this.Position">pos</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])List[Types.this.AnnotationInfo]" id="82359">mapOverAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="138396">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="138489">annots1</a> = <a href="#138396" title="List[Types.this.AnnotationInfo]">annots</a> <span title="(f: Types.this.AnnotationInfo =&gt; Types.this.AnnotationInfo)List[Types.this.AnnotationInfo]">mapConserve</span> <a href="#82358" title="(annot: Types.this.AnnotationInfo)Types.this.AnnotationInfo">mapOver</a>
      <span title="List[Types.this.AnnotationInfo]" class="keyword">if</span> <span class="delimiter">(</span><a href="#138489" title="List[Types.this.AnnotationInfo]">annots1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138396" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span> <a href="#138396" title="List[Types.this.AnnotationInfo]">annots</a>
      <span class="keyword">else</span> <a href="#138489" title="List[Types.this.AnnotationInfo]">annots1</a> <span title="(p: Types.this.AnnotationInfo =&gt; Boolean)List[Types.this.AnnotationInfo]">filterNot</span> <span class="delimiter">(</span><a href="#138509" title="Types.this.AnnotationInfo">_</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="AnnotationInfos.scala.html#40594" title="object Types.this.UnmappableAnnotation">UnmappableAnnotation</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Map over a set of annotation arguments.  If any
     *  of the arguments cannot be mapped, then return Nil.  */
    <span class="keyword">def</span> <a title="(args: List[Types.this.Tree])List[Types.this.Tree]" id="82360">mapOverAnnotArgs</a><span class="delimiter">(</span><a title="List[Types.this.Tree]" id="138487">args</a>: <span title="List[Types.this.Tree]">List</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Tree]">List</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Tree]" id="138510">args1</a> = <a href="#138487" title="List[Types.this.Tree]">args</a> <span title="(f: Types.this.Tree =&gt; Types.this.Tree)List[Types.this.Tree]">mapConserve</span> <a href="#82361" title="(tree: Types.this.Tree)Types.this.Tree">mapOver</a>
      <span title="List[Types.this.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#138510" title="List[Types.this.Tree]">args1</a> <span title="(elem: Any)Boolean">contains</span> <a href="#129321" title="object Types.this.UnmappableTree">UnmappableTree</a><span class="delimiter">)</span> <span title="object Nil">Nil</span>
      <span class="keyword">else</span> <a href="#138510" title="List[Types.this.Tree]">args1</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="82361">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="129939">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> =
      <a href="#82362" title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree">mapOver</a><span class="delimiter">(</span><a href="#129939" title="Types.this.Tree">tree</a>, <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <span title="Nothing" class="keyword">return</span> <a href="#129321" title="object Types.this.UnmappableTree">UnmappableTree</a><span class="delimiter">)</span>

    /** Map a tree that is part of an annotation argument.
     *  If the tree cannot be mapped, then invoke giveup().
     *  The default is to transform the tree with
     *  TypeMapTransformer.
     */
    <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="82362">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="129936">tree</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="129937">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> =
      <span class="delimiter">(</span><span title="TypeMap.this.TypeMapTransformer" class="keyword">new</span> <a href="#82363" title="TypeMap.this.TypeMapTransformer">TypeMapTransformer</a><span class="delimiter">)</span>.<a href="#138533" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#129936" title="Types.this.Tree">tree</a><span class="delimiter">)</span>

    /** This transformer leaves the tree alone except to remap
     *  its types. */
    <span class="keyword">class</span> <a title="class TypeMapTransformer extends Types.this.Transformer with ScalaObject" id="82363">TypeMapTransformer</a> <a href="#82363" title="ScalaObject" class="keyword">extends</a> <a href="#8614" title="Types.this.Transformer">Transformer</a> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="138533">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="138535">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Tree" id="138539">tree1</a> = <a href="#82363" title="TypeMap.this.TypeMapTransformer" class="keyword">super</a>.<span title="(tree: Types.this.Tree)Types.this.Tree">transform</span><span class="delimiter">(</span><a href="#138535" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="138540">tpe1</a> = <a href="#82351" title="(tp: Types.this.Type)Types.this.Type">TypeMap</a>.<span class="keyword">this</span><span class="delimiter">(</span><a href="#138539" title="Types.this.Tree">tree1</a>.<span title="=&gt; Types.this.Type">tpe</span><span class="delimiter">)</span>
        <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#138535" title="Types.this.Tree">tree</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138539" title="Types.this.Tree">tree1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#138535" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Type">tpe</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138540" title="Types.this.Type">tpe1</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#138535" title="Types.this.Tree">tree</a>
        <span class="keyword">else</span>
          <a href="Trees.scala.html#40606" title="implicit scala.reflect.internal.Trees.treeOps : (tree: Types.this.Tree)Types.this.TreeOps">tree1</a>.<a href="Trees.scala.html#59729" title="=&gt; Types.this.Tree">shallowDuplicate</a>.<span title="(tp: Types.this.Type)Types.this.Tree">setType</span><span class="delimiter">(</span><a href="#138540" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeTraverser extends Types.this.TypeMap with ScalaObject" id="40243">TypeTraverser</a> <a href="#40243" title="ScalaObject" class="keyword">extends</a> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="129333">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="129352">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Unit">Unit</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="129334">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="138559">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span> <a href="#129333" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#138559" title="Types.this.Type">tp</a><span class="delimiter">)</span>; <a href="#138559" title="Types.this.Type">tp</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeCollector[T] extends Types.this.TypeTraverser with ScalaObject" id="40244">TypeCollector</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40245">T</a><span class="delimiter">]</span><a href="#40244" title="ScalaObject" class="delimiter">(</a><a title="T" id="129343">initial</a>: <a href="#40245" title="T">T</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40243" title="Types.this.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="T" id="129339">result</a>: <a href="#40245" title="T">T</a> = _
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)T" id="129341">collect</a><span class="delimiter">(</span><a title="Types.this.Type" id="129348">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#129339" title="(x$1: T)Unit">result</a> = <a href="#129343" title="T">initial</a>
      <a href="#129333" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#129348" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <a href="#129339" title="=&gt; T">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A collector that tests for existential types appearing at given variance in a type
   *  @PP: Commenting out due to not being used anywhere.
   */
  // class ContainsVariantExistentialCollector(v: Int) extends TypeCollector(false) with VariantTypeMap {
  //   variance = v
  // 
  //   def traverse(tp: Type) = tp match {
  //     case ExistentialType(_, _) if (variance == v) =&gt; result = true
  //     case _ =&gt; mapOver(tp)
  //   }
  // }
  // 
  // val containsCovariantExistentialCollector = new ContainsVariantExistentialCollector(1)
  // val containsContravariantExistentialCollector = new ContainsVariantExistentialCollector(-1)

  <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol, tparams: List[Types.this.Symbol])List[Types.this.Symbol]" id="40246">typeParamsToExistentials</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="138564">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="138565">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="138567">eparams</a> = <a href="util/Collections.scala.html#39601" title="(xs: List[Types.this.Symbol])(f: (Types.this.Symbol, Int) =&gt; Types.this.Symbol)List[Types.this.Symbol]">mapWithIndex</a><span class="delimiter">(</span><a href="#138565" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="138593">tparam</a>, <a title="Int" id="138594">i</a><span class="delimiter">)</span> =&gt;
      <a href="#138564" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#47729" title="(name: Types.this.TypeName, pos: Types.this.Position, newFlags: Long)Types.this.Symbol">newExistential</a><span class="delimiter">(</span><a href="Names.scala.html#39671" title="(s: String)Types.this.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span><span title="(x$1: Any)String">+</span><a href="#138594" title="Int">i</a><span class="delimiter">)</span>, <a href="#138564" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#47694" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span> <a href="Symbols.scala.html#47922" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a> <a href="#138593" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>

    <a href="#138567" title="List[Types.this.Symbol]">eparams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <span class="delimiter">(</span><a href="#138631" title="Types.this.Symbol">_</a> <a href="Symbols.scala.html#47924" title="(syms0: List[Types.this.Symbol], syms1: List[Types.this.Symbol])Types.this.Symbol">substInfo</a> <span class="delimiter">(</span><a href="#138565" title="List[Types.this.Symbol]">tparams</a>, <a href="#138567" title="List[Types.this.Symbol]">eparams</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  //  note: it's important to write the two tests in this order,
  //  as only typeParams forces the classfile to be read. See #400
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="40247">isRawIfWithoutArgs</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="132868">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
    <a href="#132868" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47757" title="=&gt; Boolean">isClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#132868" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#132868" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#48117" title="=&gt; Boolean">isJavaDefined</a>

  <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean" id="40248">isRaw</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="138661">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="138662">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#40247" title="(sym: Types.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span><a href="#138661" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#138662" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span>

  /** Is type tp a ''raw type''? */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="40249">isRawType</a><span class="delimiter">(</span><a title="Types.this.Type" id="138665">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#138665" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="138668">sym</a>, <a title="List[Types.this.Type]" id="138669">args</a><span class="delimiter">)</span> =&gt; <a href="#40248" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><span class="delimiter">(</span><a href="#138668" title="Types.this.Symbol">sym</a>, <a href="#138669" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>

  /** The raw to existential map converts a ''raw type'' to an existential type.
   *  It is necessary because we might have read a raw type of a
   *  parameterized Java class from a class file. At the time we read the type
   *  the corresponding class file might still not be read, so we do not
   *  know what the type parameters of the type are. Therefore
   *  the conversion of raw types to existential types might not have taken place
   *  in ClassFileparser.sigToType (where it is usually done).
   */
  <span class="keyword">object</span> <a title="object Types.this.rawToExistential" id="40250">rawToExistential</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="116512">expanded</a> = immutable.<span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="scala.collection.immutable.Set[Types.this.Type]" id="116515">generated</a> = immutable.<span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.Type*)scala.collection.immutable.Set[Types.this.Type]" class="delimiter">[</span><a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="116517">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="116518">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#116518" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="138675">pre</a>, <a title="Types.this.Symbol" id="138676">sym</a>, <a href="#138678" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#40247" title="(sym: Types.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span><a href="#138676" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#116512" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">expanded</a> <span title="(elem: Types.this.Symbol)Boolean">contains</span> <a href="#138676" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="Definitions.scala.html#46276" title="=&gt; Types.this.Symbol">AnyRefClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>
        <span class="keyword">else</span> <span class="keyword">try</span> <span class="delimiter">{</span>
          <a href="#116512" title="(x$1: scala.collection.immutable.Set[Types.this.Symbol])Unit">expanded</a> <span title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">+=</span> <a href="#138676" title="Types.this.Symbol">sym</a>
          <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="138693">eparams</a> = <a href="#82357" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#40246" title="(clazz: Types.this.Symbol, tparams: List[Types.this.Symbol])List[Types.this.Symbol]">typeParamsToExistentials</a><span class="delimiter">(</span><a href="#138676" title="Types.this.Symbol">sym</a>, <a href="#138676" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#40208" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#138693" title="List[Types.this.Symbol]">eparams</a>, <a href="#40198" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#116517" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#138675" title="Types.this.Type">pre</a><span class="delimiter">)</span>, <a href="#138676" title="Types.this.Symbol">sym</a>, <a href="#138693" title="List[Types.this.Symbol]">eparams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#138728" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
          <a href="#116512" title="(x$1: scala.collection.immutable.Set[Types.this.Symbol])Unit">expanded</a> <span title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">-=</span> <a href="#138676" title="Types.this.Symbol">sym</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#116515" title="=&gt; scala.collection.immutable.Set[Types.this.Type]">generated</a> <span title="(elem: Types.this.Type)Boolean">contains</span> <a href="#116518" title="Types.this.Type">tp</a><span class="delimiter">)</span> =&gt; // to avoid infinite expansions. todo: not sure whether this is needed
        <span class="keyword">val</span> <a title="Types.this.Type" id="138783">result</a> = <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#116518" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <a href="#116515" title="(x$1: scala.collection.immutable.Set[Types.this.Type])Unit">generated</a> <span title="(elem: Types.this.Type)scala.collection.immutable.Set[Types.this.Type]">+=</span> <a href="#138783" title="Types.this.Type">result</a>
        <a href="#138783" title="Types.this.Type">result</a>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#116518" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  /** Used by existentialAbstraction.
   */
  <span class="keyword">class</span> <a title="class ExistentialExtrapolation extends Types.this.TypeMap with Types.this.VariantTypeMap with ScalaObject" id="40252">ExistentialExtrapolation</a><a href="#40252" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="136953">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40241" title="Types.this.VariantTypeMap">VariantTypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[Types.this.Symbol,Int]" id="136946">occurCount</a> = mutable.<span title="[A, B](elems: (A, B)*)scala.collection.mutable.HashMap[A,B]">HashMap</span><span title="(elems: (Types.this.Symbol, Int)*)scala.collection.mutable.HashMap[Types.this.Symbol,Int]" class="delimiter">[</span><a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <span title="Int">Int</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="136948">countOccs</a><span class="delimiter">(</span><a title="Types.this.Type" id="138812">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#138812" title="Types.this.Type">tp</a> <a href="#42790" title="(f: Types.this.Type =&gt; Unit)Unit">foreach</a> <a href="#138817" title="Unit" class="delimiter">{</a>
        <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="138818">sym</a>, _<span class="delimiter">)</span> =&gt;
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#136953" title="List[Types.this.Symbol]">tparams</a> <span title="(elem: Any)Boolean">contains</span> <a href="#138818" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <a href="#136946" title="(key: Types.this.Symbol, value: Int)Unit">occurCount</a><span class="delimiter">(</span><a href="#138818" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
        <span class="keyword">case</span> <span title="Unit">_</span> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tpe: Types.this.Type)Types.this.Type" id="136949">extrapolate</a><span class="delimiter">(</span><a title="Types.this.Type" id="136954">tpe</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#136953" title="List[Types.this.Symbol]">tparams</a> <span title="(f: Types.this.Symbol =&gt; Unit)Unit">foreach</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="138904">t</a> =&gt; <a href="#136946" title="(key: Types.this.Symbol, value: Int)Unit">occurCount</a><span class="delimiter">(</span><a href="#138904" title="Types.this.Symbol">t</a><span class="delimiter">)</span> = <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      <a href="#136948" title="(tp: Types.this.Type)Unit">countOccs</a><span class="delimiter">(</span><a href="#136954" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="138917">tparam</a> &lt;- <a href="#136953" title="(f: Types.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span>
        <a href="#136948" title="(tp: Types.this.Type)Unit">countOccs</a><span class="delimiter">(</span><a href="#138917" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span>
      
      <a href="#136950" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#136954" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="136950">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="138919">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="138923">tp1</a> = <a href="#136951" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#138919" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#136938" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#138923" title="Types.this.Type">tp1</a>
      <span class="keyword">else</span> <a href="#138923" title="Types.this.Type">tp1</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="138952">pre</a>, <a title="Types.this.Symbol" id="138953">sym</a>, <a title="List[Types.this.Type]" id="138954">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#136953" title="List[Types.this.Symbol]">tparams</a> <span title="(elem: Any)Boolean">contains</span> <a href="#138953" title="Types.this.Symbol">sym</a> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="138955">repl</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#136938" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#116321" title="(tp: Types.this.Type)Types.this.Type">dropSingletonType</a><span class="delimiter">(</span><a href="#138923" title="Types.this.Type">tp1</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#138923" title="Types.this.Type">tp1</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66878" title="=&gt; Types.this.Type">lo</a>
          //println(&quot;eliminate &quot;+sym+&quot;/&quot;+repl+&quot;/&quot;+occurCount(sym)+&quot;/&quot;+(tparams exists (repl.contains)))//DEBUG
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#138955" title="Types.this.Type">repl</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47758" title="=&gt; Boolean">isBottomClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#136946" title="(key: Types.this.Symbol)Int">occurCount</a><span class="delimiter">(</span><a href="#138953" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#136953" title="List[Types.this.Symbol]">tparams</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#138955" title="Types.this.Type">repl</a>.<a href="#42793" title="(sym: Types.this.Symbol)Boolean">contains</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#138955" title="Types.this.Type">repl</a>
          <span class="keyword">else</span> <a href="#138923" title="Types.this.Type">tp1</a>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#138923" title="Types.this.Type">tp1</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="136951">mapOver</a><span class="delimiter">(</span><a title="Types.this.Type" id="138924">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#138924" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="138994">pre</a>, <a title="Types.this.Symbol" id="138995">sym</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#138995" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#138924" title="Types.this.Type">tp</a> // short path
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="138996">pre1</a> = <a href="#136950" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138994" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#138996" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138994" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#138996" title="Types.this.Type">pre1</a>.<a href="#42715" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#138924" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#40194" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#138996" title="Types.this.Type">pre1</a>, <a href="#138995" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#40252" title="Types.this.ExistentialExtrapolation" class="keyword">super</a>.<a href="#136942" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#138924" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    // Do not discard the types of existential ident's. The
    // symbol of the Ident itself cannot be listed in the
    // existential's parameters, so the resulting existential
    // type would be ill-formed.
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="136952">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="138927">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = <a href="#138927" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Tree">Ident</span><span class="delimiter">(</span>_<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#138927" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Type">tpe</span>.<a href="#42715" title="=&gt; Boolean">isStable</a> =&gt; <a href="#138927" title="Types.this.Tree">tree</a>
      <span class="keyword">case</span> <span title="Types.this.Tree">_</span>                             =&gt; <a href="#40252" title="Types.this.ExistentialExtrapolation" class="keyword">super</a>.<a href="#82361" title="(tree: Types.this.Tree)Types.this.Tree">mapOver</a><span class="delimiter">(</span><a href="#138927" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(hi: Types.this.Type)Types.this.TypeBounds" id="40253">singletonBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="116423">hi</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#131099" title="object Types.this.TypeBounds">TypeBounds</a>.<a href="#66836" title="(hi: Types.this.Type)Types.this.TypeBounds">upper</a><span class="delimiter">(</span><a href="#40203" title="(tps: List[Types.this.Type])Types.this.Type">intersectionType</a><span class="delimiter">(</span><span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#116423" title="Types.this.Type">hi</a>, <a href="Definitions.scala.html#46375" title="=&gt; Types.this.Symbol">SingletonClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  /** A map to compute the asSeenFrom method  */
  <span class="keyword">class</span> <a title="class AsSeenFromMap extends Types.this.TypeMap with Types.this.KeepOnlyTypeConstraints with ScalaObject" id="40254">AsSeenFromMap</a><a href="#40254" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="129659">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="129660">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="keyword">with</span> <a href="#40240" title="Types.this.KeepOnlyTypeConstraints">KeepOnlyTypeConstraints</a> <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="129642">capturedSkolems</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="129645">capturedParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">var</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]" id="129648">capturedPre</a> = <a href="#40067" title="=&gt; scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]">emptySymMap</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="129650">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="139032">tree</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="139033">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="object annotationArgRewriter" id="139036">annotationArgRewriter</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#82363" title="AsSeenFromMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>
        /** Rewrite `This` trees in annotation argument trees */
        <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="139039">rewriteThis</a><span class="delimiter">(</span><a title="Types.this.Tree" id="139042">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> =
          <a href="#139042" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Types.this.Tree">This</span><span class="delimiter">(</span>_<span class="delimiter">)</span>
            <span class="keyword">if</span> <span class="delimiter">(</span><a href="#139042" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span> <a href="Symbols.scala.html#47963" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#129660" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
               <span class="delimiter">(</span><a href="#129659" title="Types.this.Type">pre</a>.<a href="#42732" title="=&gt; Types.this.Type">widen</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#47963" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#139042" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span> =&gt;
              <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#129659" title="Types.this.Type">pre</a>.<a href="#42715" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <span class="delimiter">{</span> // XXX why is this in this method? pull it out and guard the call `annotationArgRewriter.transform(tree)`?
                <span class="keyword">val</span> <a title="Types.this.TermSymbol" id="139049">termSym</a> = <span class="delimiter">(</span>
                  <a href="#129659" title="Types.this.Type">pre</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47876" title="Types.this.Symbol" id="139057">owner</a>.<a href="Symbols.scala.html#72659" title="Long" id="139060">newValue</a><span class="delimiter">(</span><a href="#129659" title="Types.this.Type">pre</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#53412" title="Types.this.TermName" id="139058">toTermName</a>, <a href="#129659" title="Types.this.Type">pre</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47694" title="Types.this.Position" id="139059">pos</a><span class="delimiter">)</span> // what symbol should really be used?
                    <a href="Symbols.scala.html#47922" title="(info: Types.this.Type)Types.this.TermSymbol">setInfo</a> <a href="#129659" title="Types.this.Type">pre</a>
                <span class="delimiter">)</span>
                <a href="Required.scala.html#40686" title="=&gt; scala.reflect.internal.TreeGen{val global: Types.this.type}">gen</a>.<a href="TreeGen.scala.html#92626" title="(tpe: Types.this.gen.global.Type, termSym: Types.this.gen.global.Symbol)Types.this.gen.global.Tree">mkAttributedQualifier</a><span class="delimiter">(</span><a href="#129659" title="Types.this.Type">pre</a>, <a href="#139049" title="Types.this.TermSymbol">termSym</a><span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">else</span>
                <a href="#139033" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span>

            <span class="keyword">case</span> <a title="Types.this.Tree" id="139072">tree</a> =&gt; <a href="#139072" title="Types.this.Tree">tree</a>
          <span class="delimiter">}</span>

        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="139040">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="139073">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Tree" id="139076">tree1</a> = <a href="#139039" title="(tree: Types.this.Tree)Types.this.Tree">rewriteThis</a><span class="delimiter">(</span><span class="keyword">super</span>.<a href="#138533" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#139073" title="Types.this.Tree">tree</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#139076" title="Types.this.Tree">tree1</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#139036" title="object annotationArgRewriter">annotationArgRewriter</a>.<a href="#139040" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#139032" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="129651">stabilize</a><span class="delimiter">(</span><a title="Types.this.Type" id="139080">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="139081">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
      <a href="#129648" title="=&gt; scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]">capturedPre</a>.<span title="(key: Types.this.Symbol, default: =&gt; Types.this.Symbol)Types.this.Symbol">getOrElse</span><span class="delimiter">(</span><a href="#139081" title="Types.this.Symbol">clazz</a>, <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="139114">qvar</a> = <a href="#139081" title="Types.this.Symbol">clazz</a> <a href="Symbols.scala.html#47730" title="(suffix: String)Types.this.Symbol">freshExistential</a> <span title="String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span> <a href="Symbols.scala.html#47922" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a> <a href="#40253" title="(hi: Types.this.Type)Types.this.TypeBounds">singletonBounds</a><span class="delimiter">(</span><a href="#139080" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <a href="#129648" title="(x$1: scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol])Unit">capturedPre</a> <span title="(kv: (Types.this.Symbol, Types.this.Symbol))scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]">+=</span> <span class="delimiter">(</span><a href="#139081" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">clazz</a> <span title="(y: Types.this.Symbol)(Types.this.Symbol, Types.this.Symbol)">-&gt;</span> <a href="#139114" title="Types.this.Symbol">qvar</a><span class="delimiter">)</span>
          <a href="#129645" title="(x$1: List[Types.this.Symbol])Unit">capturedParams</a> = <a href="#139114" title="Types.this.Symbol">qvar</a> <a href="#139200" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#129645" title="=&gt; List[Types.this.Symbol]">capturedParams</a>
          <a href="#139114" title="Types.this.Symbol">qvar</a>
      <span class="delimiter">}</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>

    /** Return `pre.baseType(clazz)`, or if that's `NoType` and `clazz` is a refinement, `pre` itself.
     *  See bug397.scala for an example where the second alternative is needed.
     *  The problem is that when forming the base type sequence of an abstract type,
     *  any refinements in the base type list might be regenerated, and thus acquire
     *  new class symbols. However, since refinements always have non-interesting prefixes
     *  it looks OK to me to just take the prefix directly. */
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="129652">base</a><span class="delimiter">(</span><a title="Types.this.Type" id="139209">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="139210">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="139213">b</a> = <a href="#139209" title="Types.this.Type">pre</a>.<a href="#42777" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#139210" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139213" title="Types.this.Type">b</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#130794" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#139210" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#47779" title="=&gt; Boolean">isRefinementClass</a><span class="delimiter">)</span> <a href="#139209" title="Types.this.Type">pre</a>
      <span class="keyword">else</span> <a href="#139213" title="Types.this.Type">b</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="129653">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="129661">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#129659" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#129659" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#129660" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#47757" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span> <a href="#129661" title="Types.this.Type">tp</a>
      <span class="keyword">else</span> <a href="#129661" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="139219">sym</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="139220">toPrefix</a><span class="delimiter">(</span><a title="Types.this.Type" id="139221">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="139222">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139221" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#139221" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#139222" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#47757" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span> <a href="#129661" title="Types.this.Type">tp</a>
            <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139219" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#47963" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#139222" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                     <span class="delimiter">(</span><a href="#139221" title="Types.this.Type">pre</a>.<a href="#42732" title="=&gt; Types.this.Type">widen</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#47963" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#139219" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="139226">pre1</a> = <a href="#139221" title="Types.this.Type">pre</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Types.this.Type">SuperType</span><span class="delimiter">(</span><a title="Types.this.Type" id="139227">thistp</a>, _<span class="delimiter">)</span> =&gt; <a href="#139227" title="Types.this.Type">thistp</a>
                <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#139221" title="Types.this.Type">pre</a>
              <span class="delimiter">}</span>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#139226" title="Types.this.Type">pre1</a>.<a href="#42715" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">||</span>
                    <a href="#139226" title="Types.this.Type">pre1</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a> <span title="(x: Boolean)Boolean">||</span>
                    <a href="#139226" title="Types.this.Type">pre1</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47775" title="=&gt; Boolean">isModuleClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#139226" title="Types.this.Type">pre1</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47857" title="=&gt; Boolean">isStatic</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="#129651" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">stabilize</a><span class="delimiter">(</span><a href="#139226" title="Types.this.Type">pre1</a>, <a href="#139219" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                <a href="#139226" title="Types.this.Type">pre1</a>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <a href="#139220" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toPrefix</a><span class="delimiter">(</span><a href="#129652" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">base</a><span class="delimiter">(</span><a href="#139221" title="Types.this.Type">pre</a>, <a href="#139222" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>.<a href="#42738" title="=&gt; Types.this.Type">prefix</a>, <a href="#139222" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <a href="#139220" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toPrefix</a><span class="delimiter">(</span><a href="#129659" title="Types.this.Type">pre</a>, <a href="#129660" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="139228">pre</a>, <a title="Types.this.Symbol" id="139229">sym</a><span class="delimiter">)</span> =&gt;
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139229" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#129661" title="Types.this.Type">tp</a> // short path
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="139230">pre1</a> = <a href="#129653" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139228" title="Types.this.Type">pre</a><span class="delimiter">)</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139230" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139228" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#129661" title="Types.this.Type">tp</a>
            <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139230" title="Types.this.Type">pre1</a>.<a href="#42715" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#40194" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#139230" title="Types.this.Type">pre1</a>, <a href="#139229" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#139230" title="Types.this.Type">pre1</a>.<a href="#42780" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#139229" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#42743" title="=&gt; Types.this.Type">resultType</a> //todo: this should be rolled into existential abstraction
          <span class="delimiter">}</span>
        // AM: Martin, is this description accurate?
        // walk the owner chain of `clazz` (the original argument to asSeenFrom) until we find the type param's owner (while rewriting pre as we crawl up the owner chain)
        // once we're at the owner, extract the information that pre encodes about the type param,
        // by minimally subsuming pre to the type instance of the class that owns the type param,
        // the type we're looking for is the type instance's type argument at the position corresponding to the type parameter
        // optimisation: skip this type parameter if it's not owned by a class, as those params are not influenced by the prefix through which they are seen
        // (concretely: type params of anonymous type functions, which currently can only arise from normalising type aliases, are owned by the type alias of which they are the eta-expansion)
        // (skolems also aren't affected: they are ruled out by the isTypeParameter check)
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="139241">prefix</a>, <a title="Types.this.Symbol" id="139242">sym</a>, <a title="List[Types.this.Type]" id="139243">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#139242" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47781" title="=&gt; Boolean">isTypeParameter</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#139242" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#47757" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="139245">toInstance</a><span class="delimiter">(</span><a title="Types.this.Type" id="139246">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="139247">clazz</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139246" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#139246" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#139247" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#47757" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span> <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#129661" title="Types.this.Type">tp</a><span class="delimiter">)</span>
            //@M! see test pos/tcpoly_return_overriding.scala why mapOver is necessary
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span class="keyword">def</span> <a title="=&gt; Nothing" id="139256">throwError</a> = <a href="SymbolTable.scala.html#36939" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#129661" title="Types.this.Type">tp</a> <span title="(x$1: Any)String">+</span> <a href="#139242" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#48048" title="=&gt; String">locationString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; cannot be instantiated from &quot;)" class="string">&quot; cannot be instantiated from &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#139246" title="Types.this.Type">pre</a>.<a href="#42732" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>

              <span class="keyword">val</span> <a title="Types.this.Symbol" id="139257">symclazz</a> = <a href="#139242" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139257" title="Types.this.Symbol">symclazz</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#139247" title="Types.this.Symbol">clazz</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#139246" title="Types.this.Type">pre</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#40176" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#139246" title="Types.this.Type">pre</a>.<a href="#42732" title="=&gt; Types.this.Type">widen</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#47963" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#139257" title="Types.this.Symbol">symclazz</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                // have to deconst because it may be a Class[T].
                <a href="#139246" title="Types.this.Type">pre</a>.<a href="#42777" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#139257" title="Types.this.Symbol">symclazz</a><span class="delimiter">)</span>.<a href="#42733" title="=&gt; Types.this.Type">deconst</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
                  <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="139268">basesym</a>, <a title="List[Types.this.Type]" id="139269">baseargs</a><span class="delimiter">)</span> =&gt;

                   <span class="keyword">def</span> <a title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type" id="139270">instParam</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="139272">ps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="139273">as</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
                      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139272" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#40688" title="=&gt; Boolean">forInteractive</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                          <span class="keyword">val</span> <a title="Boolean" id="139274">saved</a> = <a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75542" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">uniqid</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a>
                          <span class="keyword">try</span> <span class="delimiter">{</span>
                            <a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75542" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">uniqid</a>.<a href="settings/MutableSettings.scala.html#75566" title="(arg: Boolean)Unit">value</a> = <span title="Boolean(true)" class="keyword">true</span>
                            <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;*** stale type parameter: &quot;)" class="string">&quot;*** stale type parameter: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#129661" title="Types.this.Type">tp</a> <span title="(x$1: Any)String">+</span> <a href="#139242" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#48048" title="=&gt; String">locationString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; cannot be instantiated from &quot;)" class="string">&quot; cannot be instantiated from &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#139246" title="Types.this.Type">pre</a>.<a href="#42732" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
                            <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;*** confused with params: &quot;)" class="string">&quot;*** confused with params: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#139242" title="Types.this.Symbol">sym</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; in &quot;)" class="string">&quot; in &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#139242" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; not in &quot;)" class="string">&quot; not in &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#139272" title="List[Types.this.Symbol]">ps</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; of &quot;)" class="string">&quot; of &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#139268" title="Types.this.Symbol">basesym</a><span class="delimiter">)</span>
                            <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;*** stacktrace = &quot;)" class="string">&quot;*** stacktrace = &quot;</span><span class="delimiter">)</span>
                            <span title="Error" class="keyword">new</span> <span title="Error">Error</span><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="()Unit">printStackTrace</span><span class="delimiter">(</span><span class="delimiter">)</span>
                          <span class="delimiter">}</span> <span class="keyword">finally</span> <a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75542" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">uniqid</a>.<a href="settings/MutableSettings.scala.html#75566" title="(arg: Boolean)Unit">value</a> = <a href="#139274" title="Boolean">saved</a>
                          <a href="#139271" title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type">instParamRelaxed</a><span class="delimiter">(</span><a href="#139268" title="Types.this.Symbol">basesym</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#139269" title="List[Types.this.Type]">baseargs</a><span class="delimiter">)</span>
                        <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#139256" title="=&gt; Nothing">throwError</a>
                      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139242" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139272" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; Types.this.Symbol">head</span><span class="delimiter">)</span>
                        // @M! don't just replace the whole thing, might be followed by type application
                        <a href="#40204" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#139273" title="List[Types.this.Type]">as</a>.<span title="=&gt; Types.this.Type">head</span>, <a href="#139243" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a href="#40254" title="Types.this.AsSeenFromMap" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> // @M: was as.head
                      <span class="keyword">else</span> <a href="#139270" title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type">instParam</a><span class="delimiter">(</span><a href="#139272" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>, <a href="#139273" title="List[Types.this.Type]">as</a>.<span title="=&gt; List[Types.this.Type]">tail</span><span class="delimiter">)</span>

                    /** Relaxed version of instParams which matches on names not symbols.
                     *  This is a last fallback in interactive mode because races in calls
                     *  from the IDE to the compiler may in rare cases lead to symbols referring
                     *  to type parameters that are no longer current.
                     */
                    <span class="keyword">def</span> <a title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type" id="139271">instParamRelaxed</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="139310">ps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="139311">as</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
                      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139310" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#139256" title="=&gt; Nothing">throwError</a>
                      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139242" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#139310" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
                        // @M! don't just replace the whole thing, might be followed by type application
                        <a href="#40204" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#139311" title="List[Types.this.Type]">as</a>.<span title="=&gt; Types.this.Type">head</span>, <a href="#139243" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a href="#40254" title="Types.this.AsSeenFromMap" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> // @M: was as.head
                      <span class="keyword">else</span> <a href="#139271" title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type">instParamRelaxed</a><span class="delimiter">(</span><a href="#139310" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>, <a href="#139311" title="List[Types.this.Type]">as</a>.<span title="=&gt; List[Types.this.Type]">tail</span><span class="delimiter">)</span>

                    //Console.println(&quot;instantiating &quot; + sym + &quot; from &quot; + basesym + &quot; with &quot; + basesym.typeParams + &quot; and &quot; + baseargs+&quot;, pre = &quot;+pre+&quot;, symclazz = &quot;+symclazz);//DEBUG
                    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#139268" title="Types.this.Symbol">basesym</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#139269" title="List[Types.this.Type]">baseargs</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                      <a href="#139270" title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type">instParam</a><span class="delimiter">(</span><a href="#139268" title="Types.this.Symbol">basesym</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#139269" title="List[Types.this.Type]">baseargs</a><span class="delimiter">)</span>
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                      <span title="Nothing" class="keyword">throw</span> <a href="#67275" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#40384" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span>
                        <span title="String(&quot;something is wrong (wrong class file?): &quot;)" class="string">&quot;something is wrong (wrong class file?): &quot;</span><span title="(x$1: Any)String">+</span><a href="#139268" title="Types.this.Symbol">basesym</a><span title="(x$1: Any)String">+</span>
                        <span title="String(&quot; with type parameters &quot;)" class="string">&quot; with type parameters &quot;</span><span title="(x$1: Any)String">+</span>
                        <a href="#139268" title="Types.this.Symbol">basesym</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="(f: Types.this.Symbol =&gt; Types.this.Name)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Name,List[Types.this.Name]])List[Types.this.Name]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.Name,List[Types.this.Name]]" class="delimiter">(</span><a href="#139350" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>,<span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>,<span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span><span title="(x$1: Any)String">+</span>
                        <span title="String(&quot; gets applied to arguments &quot;)" class="string">&quot; gets applied to arguments &quot;</span><span title="(x$1: Any)String">+</span><a href="#139269" title="List[Types.this.Type]">baseargs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>,<span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>,<span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span><span title="(x$1: Any)String">+</span><span title="String(&quot;, phase = &quot;)" class="string">&quot;, phase = &quot;</span><span title="(x$1: Any)String">+</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a><span class="delimiter">)</span>
                    <span class="delimiter">}</span>
                  <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="139383">tparams</a>, <a title="Types.this.Type" id="139384">qtpe</a><span class="delimiter">)</span> =&gt;
                    <a href="#129642" title="(x$1: List[Types.this.Symbol])Unit">capturedSkolems</a> = <a href="#129642" title="=&gt; List[Types.this.Symbol]">capturedSkolems</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">union</span> <a href="#139383" title="List[Types.this.Symbol]">tparams</a>
                    <a href="#139245" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toInstance</a><span class="delimiter">(</span><a href="#139384" title="Types.this.Type">qtpe</a>, <a href="#139247" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
                  <span class="keyword">case</span> <a title="Nothing" id="139440">t</a> =&gt;
                    <a href="#139256" title="=&gt; Nothing">throwError</a>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#139245" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toInstance</a><span class="delimiter">(</span><a href="#129652" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">base</a><span class="delimiter">(</span><a href="#139246" title="Types.this.Type">pre</a>, <a href="#139247" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>.<a href="#42738" title="=&gt; Types.this.Type">prefix</a>, <a href="#139247" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <a href="#139245" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toInstance</a><span class="delimiter">(</span><a href="#129659" title="Types.this.Type">pre</a>, <a href="#129660" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#129661" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A base class to compute all substitutions */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SubstMap[T] extends Types.this.TypeMap with ScalaObject" id="40255">SubstMap</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40256">T</a><span class="delimiter">]</span><a href="#40255" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="127625">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[T]" id="127626">to</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#127625" title="List[Types.this.Symbol]">from</a>, <a href="#127626" title="List[T]">to</a><span class="delimiter">)</span>, <span title="String(&quot;Unsound substitution from &quot;)" class="string">&quot;Unsound substitution from &quot;</span><span title="(x$1: Any)String">+</span> <a href="#127625" title="List[Types.this.Symbol]">from</a> <span title="(x$1: Any)String">+</span><span title="String(&quot; to &quot;)" class="string">&quot; to &quot;</span><span title="(x$1: Any)String">+</span> <a href="#127626" title="List[T]">to</a><span class="delimiter">)</span>

    /** Are `sym` and `sym1` the same? Can be tuned by subclasses. */
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, sym1: Types.this.Symbol)Boolean" id="127618">matches</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="139456">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="139457">sym1</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#139456" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139457" title="Types.this.Symbol">sym1</a>

    /** Map target to type, can be tuned by subclasses */
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(fromtp: Types.this.Type, tp: T)Types.this.Type" id="127619">toType</a><span class="delimiter">(</span><a title="Types.this.Type" id="139459">fromtp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="T" id="139460">tp</a>: <a href="#40256" title="T">T</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a>

    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="127620">renameBoundSyms</a><span class="delimiter">(</span><a title="Types.this.Type" id="139462">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#139462" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="139464">ps</a>, <a title="Types.this.Type" id="139465">restp</a><span class="delimiter">)</span> =&gt;
        <a href="Symbols.scala.html#40021" title="(syms: List[Types.this.Symbol], tpe: Types.this.Type)(creator: (List[Types.this.Symbol], Types.this.Type) =&gt; Types.this.Type)Types.this.Type">createFromClonedSymbols</a><span class="delimiter">(</span><a href="#139464" title="List[Types.this.Symbol]">ps</a>, <a href="#139465" title="Types.this.Type">restp</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="139474">ps1</a>, <a title="Types.this.Type" id="139475">tp1</a><span class="delimiter">)</span> =&gt; <a href="#40201" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#139462" title="Types.this.Type">tp</a>, <a href="#139474" title="List[Types.this.Symbol]">ps1</a>, <a href="#127620" title="(tp: Types.this.Type)Types.this.Type">renameBoundSyms</a><span class="delimiter">(</span><a href="#139475" title="Types.this.Type">tp1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.PolyType">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="139478">bs</a>, <a title="Types.this.Type" id="139479">restp</a><span class="delimiter">)</span> =&gt;
        <a href="Symbols.scala.html#40021" title="(syms: List[Types.this.Symbol], tpe: Types.this.Type)(creator: (List[Types.this.Symbol], Types.this.Type) =&gt; Types.this.PolyType)Types.this.PolyType">createFromClonedSymbols</a><span class="delimiter">(</span><a href="#139478" title="List[Types.this.Symbol]">bs</a>, <a href="#139479" title="Types.this.Type">restp</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="139485">ps1</a>, <a title="Types.this.Type" id="139486">tp1</a><span class="delimiter">)</span> =&gt; <a href="#67004" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#139485" title="List[Types.this.Symbol]">ps1</a>, <a href="#127620" title="(tp: Types.this.Type)Types.this.Type">renameBoundSyms</a><span class="delimiter">(</span><a href="#139486" title="Types.this.Type">tp1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="139489">bs</a>, <a title="Types.this.Type" id="139490">restp</a><span class="delimiter">)</span> =&gt;
        <a href="Symbols.scala.html#40021" title="(syms: List[Types.this.Symbol], tpe: Types.this.Type)(creator: (List[Types.this.Symbol], Types.this.Type) =&gt; Types.this.Type)Types.this.Type">createFromClonedSymbols</a><span class="delimiter">(</span><a href="#139489" title="List[Types.this.Symbol]">bs</a>, <a href="#139490" title="Types.this.Type">restp</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#40155" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#139462" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp0: Types.this.Type)Types.this.Type" id="127621">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="127732">tp0</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#127625" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#127732" title="Types.this.Type">tp0</a> <span class="keyword">else</span> <span class="delimiter">{</span>
      @tailrec <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type" id="139500">subst</a><span class="delimiter">(</span><a title="Types.this.Type" id="139504">tp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="139505">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="139506">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[T]" id="139507">to</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139506" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#139504" title="Types.this.Type">tp</a>
        // else if (to.isEmpty) error(&quot;Unexpected substitution on '%s': from = %s but to == Nil&quot;.format(tp, from))
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#127618" title="(sym: Types.this.Symbol, sym1: Types.this.Symbol)Boolean">matches</a><span class="delimiter">(</span><a href="#139506" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Types.this.Symbol">head</span>, <a href="#139505" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#127619" title="(fromtp: Types.this.Type, tp: T)Types.this.Type">toType</a><span class="delimiter">(</span><a href="#139504" title="Types.this.Type">tp</a>, <a href="#139507" title="List[T]">to</a>.<span title="=&gt; T">head</span><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#139500" title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#139504" title="Types.this.Type">tp</a>, <a href="#139505" title="Types.this.Symbol">sym</a>, <a href="#139506" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>, <a href="#139507" title="List[T]">to</a>.<span title="=&gt; List[T]">tail</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="139501">boundSyms</a> = <a href="#127732" title="Types.this.Type">tp0</a>.<a href="#42753" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="139502">tp1</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139501" title="scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <a href="#127625" title="List[Types.this.Symbol]">from</a>.<a href="#139513" title="(elem: Any)Boolean">contains</a><span class="delimiter">)</span> <a href="#127620" title="(tp: Types.this.Type)Types.this.Type">renameBoundSyms</a><span class="delimiter">(</span><a href="#127732" title="Types.this.Type">tp0</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#127732" title="Types.this.Type">tp0</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="139503">tp</a> = <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#139502" title="Types.this.Type">tp1</a><span class="delimiter">)</span>

      <a href="#139503" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        // @M
        // 1) arguments must also be substituted (even when the &quot;head&quot; of the
        // applied type has already been substituted)
        // example: (subst RBound[RT] from [type RT,type RBound] to
        // [type RT&amp;,type RBound&amp;]) = RBound&amp;[RT&amp;]
        // 2) avoid loops (which occur because alpha-conversion is
        // not performed properly imo)
        // e.g. if in class Iterable[a] there is a new Iterable[(a,b)],
        // we must replace the a in Iterable[a] by (a,b)
        // (must not recurse --&gt; loops)
        // 3) replacing m by List in m[Int] should yield List[Int], not just List
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="139520">sym</a>, <a title="List[Types.this.Type]" id="139521">args</a><span class="delimiter">)</span> =&gt;
          <a href="#40204" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#139500" title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#139503" title="Types.this.Type">tp</a>, <a href="#139520" title="Types.this.Symbol">sym</a>, <a href="#127625" title="List[Types.this.Symbol]">from</a>, <a href="#127626" title="List[T]">to</a><span class="delimiter">)</span>, <a href="#139521" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> // if args.isEmpty, appliedType is the identity
        <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="139522">sym</a><span class="delimiter">)</span> =&gt;
          <a href="#139500" title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#139503" title="Types.this.Type">tp</a>, <a href="#139522" title="Types.this.Symbol">sym</a>, <a href="#127625" title="List[Types.this.Symbol]">from</a>, <a href="#127626" title="List[T]">to</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#139503" title="Types.this.Type">tp</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `substSym` method. */
  <span class="keyword">class</span> <a title="class SubstSymMap extends Types.this.SubstMap[Types.this.Symbol] with ScalaObject" id="40257">SubstSymMap</a><a href="#40257" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="127707">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="127708">to</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40255" title="Types.this.SubstMap[Types.this.Symbol]">SubstMap</a><span class="delimiter">(</span><a href="#127707" title="List[Types.this.Symbol]">from</a>, <a href="#127708" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(fromtp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="127704">toType</a><span class="delimiter">(</span><a title="Types.this.Type" id="139544">fromtp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="139545">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#139544" title="Types.this.Type">fromtp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="139550">pre</a>, _, <a title="List[Types.this.Type]" id="139551">args</a><span class="delimiter">)</span> =&gt; <a href="#40199" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#139544" title="Types.this.Type">fromtp</a>, <a href="#139550" title="Types.this.Type">pre</a>, <a href="#139545" title="Types.this.Symbol">sym</a>, <a href="#139551" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="139552">pre</a>, _<span class="delimiter">)</span> =&gt; <a href="#40194" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#139552" title="Types.this.Type">pre</a>, <a href="#139545" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="127705">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="127730">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#127707" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#127730" title="Types.this.Type">tp</a> <span class="keyword">else</span> <span class="delimiter">{</span>
      @tailrec <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol" id="139553">subst</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="139554">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="139555">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="139556">to</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> =
        <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#139555" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#139554" title="Types.this.Symbol">sym</a>
        // else if (to.isEmpty) error(&quot;Unexpected substitution on '%s': from = %s but to == Nil&quot;.format(sym, from))
        <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#127618" title="(sym: Types.this.Symbol, sym1: Types.this.Symbol)Boolean">matches</a><span class="delimiter">(</span><a href="#139555" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Types.this.Symbol">head</span>, <a href="#139554" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#139556" title="List[Types.this.Symbol]">to</a>.<span title="=&gt; Types.this.Symbol">head</span>
        <span class="keyword">else</span> <a href="#139553" title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol">subst</a><span class="delimiter">(</span><a href="#139554" title="Types.this.Symbol">sym</a>, <a href="#139555" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>, <a href="#139556" title="List[Types.this.Symbol]">to</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span><span class="delimiter">)</span>
      <a href="#127730" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="139557">pre</a>, <a title="Types.this.Symbol" id="139558">sym</a>, <a title="List[Types.this.Type]" id="139559">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#139557" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="139560">newSym</a> = <a href="#139553" title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol">subst</a><span class="delimiter">(</span><a href="#139558" title="Types.this.Symbol">sym</a>, <a href="#127707" title="List[Types.this.Symbol]">from</a>, <a href="#127708" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span>
          // assert(newSym.typeParams.length == sym.typeParams.length, &quot;typars mismatch in SubstSymMap: &quot;+(sym, sym.typeParams, newSym, newSym.typeParams))
          <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#40199" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#127730" title="Types.this.Type">tp</a>, <a href="#139557" title="Types.this.Type">pre</a>, <a href="#139560" title="Types.this.Symbol">newSym</a>, <a href="#139559" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> // mapOver takes care of subst'ing in args
        <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="139573">pre</a>, <a title="Types.this.Symbol" id="139574">sym</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#139573" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a> =&gt;
          <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#40194" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#139573" title="Types.this.Type">pre</a>, <a href="#139553" title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol">subst</a><span class="delimiter">(</span><a href="#139574" title="Types.this.Symbol">sym</a>, <a href="#127707" title="List[Types.this.Symbol]">from</a>, <a href="#127708" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#40257" title="Types.this.SubstSymMap" class="keyword">super</a>.<a href="#127621" title="(tp0: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#127730" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="127706">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="139561">tree</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="139562">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="object trans" id="139585">trans</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#82363" title="SubstSymMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>

        <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Option[Types.this.Symbol]" id="139588">termMapsTo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="139591">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#127707" title="List[Types.this.Symbol]">from</a> <span title="(elem: Types.this.Symbol)Int">indexOf</span> <a href="#139591" title="Types.this.Symbol">sym</a> <span title="Option[Types.this.Symbol]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="None.type">-</span><span class="int">1</span>   =&gt; <span title="object None">None</span>
          <span class="keyword">case</span> <a title="Some[Types.this.Symbol]" id="139609">idx</a>  =&gt; <span title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</span><span class="delimiter">(</span><a href="#127708" title="(n: Int)Types.this.Symbol">to</a><span class="delimiter">(</span><a href="#139609" title="Int">idx</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="139589">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="139631">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> =
          <a href="#139631" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a title="Types.this.Tree" id="139636">tree</a>@Ident<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
              <a href="#139588" title="(sym: Types.this.Symbol)Option[Types.this.Symbol]">termMapsTo</a><span class="delimiter">(</span><a href="#139636" title="Types.this.Ident">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Types.this.Tree">Some</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="139640">tosym</a><span class="delimiter">)</span> =&gt;
                  <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#139640" title="Types.this.Symbol">tosym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#47964" title="(that: Types.this.Symbol)Boolean">isSubClass</a> <a href="Definitions.scala.html#46375" title="=&gt; Types.this.Symbol">SingletonClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#8614" title="(name: String)Types.this.Ident">Ident</a><span class="delimiter">(</span><a href="#139640" title="Types.this.Symbol">tosym</a>.<a href="Symbols.scala.html#48063" title="=&gt; String">existentialToString</a><span class="delimiter">)</span>
                      .<span title="(sym: Types.this.Symbol)Types.this.Ident">setSymbol</span><span class="delimiter">(</span><a href="#139640" title="Types.this.Symbol">tosym</a><span class="delimiter">)</span>
                      .<span title="(pos: Types.this.Position)Types.this.Ident">setPos</span><span class="delimiter">(</span><a href="#139640" title="Types.this.Symbol">tosym</a>.<a href="Symbols.scala.html#47694" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>
                      .<span title="(tp: Types.this.Type)Types.this.Ident">setType</span><span class="delimiter">(</span><a href="#116321" title="(tp: Types.this.Type)Types.this.Type">dropSingletonType</a><span class="delimiter">(</span><a href="#139640" title="Types.this.Symbol">tosym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                    <a href="#139562" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span>
                  <span class="delimiter">}</span>
                <span class="keyword">case</span> <a title="Types.this.Tree" id="139666">none</a> =&gt; <span class="keyword">super</span>.<a href="#138533" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#139636" title="Types.this.Ident">tree</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="keyword">case</span> <a title="Types.this.Tree" id="139669">tree</a> =&gt; <span class="keyword">super</span>.<a href="#138533" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#139669" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#139585" title="object trans">trans</a>.<a href="#139589" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#139561" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `subst` method. */
  <span class="keyword">class</span> <a title="class SubstTypeMap extends Types.this.SubstMap[Types.this.Type] with ScalaObject" id="40258">SubstTypeMap</a><a href="#40258" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="127647">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="127648">to</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="#40255" title="Types.this.SubstMap[Types.this.Type]">SubstMap</a><span class="delimiter">(</span><a href="#127647" title="List[Types.this.Symbol]">from</a>, <a href="#127648" title="List[Types.this.Type]">to</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(fromtp: Types.this.Type, tp: Types.this.Type)Types.this.Type" id="127645">toType</a><span class="delimiter">(</span><a title="Types.this.Type" id="139693">fromtp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="139694">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#139694" title="Types.this.Type">tp</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="127646">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="134735">tree</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="134736">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="object trans" id="139699">trans</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#82363" title="SubstTypeMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="139702">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="139704">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = <a href="#139704" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Types.this.Tree">Ident</span><span class="delimiter">(</span><a title="Types.this.Name" id="139711">name</a><span class="delimiter">)</span> =&gt;
            <a href="#127647" title="List[Types.this.Symbol]">from</a> <span title="(elem: Types.this.Symbol)Int">indexOf</span> <a href="#139704" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <span title="Types.this.Tree">-</span><span class="int">1</span>   =&gt; <span class="keyword">super</span>.<a href="#138533" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#139704" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
              <span class="keyword">case</span> <a title="Types.this.Tree" id="139729">idx</a>  =&gt;
                <span class="keyword">val</span> <a title="Types.this.Type" id="139730">totpe</a> = <a href="#127648" title="(n: Int)Types.this.Type">to</a><span class="delimiter">(</span><a href="#139729" title="Int">idx</a><span class="delimiter">)</span>
                <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#139730" title="Types.this.Type">totpe</a>.<a href="#42715" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#139704" title="Types.this.Tree">tree</a>.<span title="=&gt; tree.type">duplicate</span> <span title="(tp: Types.this.Type)tree.type">setType</span> <a href="#139730" title="Types.this.Type">totpe</a>
                <span class="keyword">else</span> <a href="#134736" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> <span title="Types.this.Tree">_</span> =&gt;
            <span class="keyword">super</span>.<a href="#138533" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#139704" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#139699" title="object trans">trans</a>.<a href="#139702" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#134735" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `substThis` method. */
  <span class="keyword">class</span> <a title="class SubstThisMap extends Types.this.TypeMap with ScalaObject" id="40259">SubstThisMap</a><a href="#40259" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="129710">from</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="129711">to</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="129709">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="129713">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#129713" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="139744">sym</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#139744" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#129710" title="Types.this.Symbol">from</a><span class="delimiter">)</span> =&gt; <a href="#129711" title="Types.this.Type">to</a>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#129713" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">class</span> <a title="class SubstThisAndSymMap extends Types.this.SubstSymMap with ScalaObject" id="40260">SubstThisAndSymMap</a><a href="#40260" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="129742">fromThis</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="129743">toThis</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="129744">fromSyms</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="129745">toSyms</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="#40257" title="Types.this.SubstSymMap">SubstSymMap</a><span class="delimiter">(</span><a href="#129744" title="List[Types.this.Symbol]">fromSyms</a>, <a href="#129745" title="List[Types.this.Symbol]">toSyms</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="129741">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="129747">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#129747" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="139762">sym</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#139762" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#129742" title="Types.this.Symbol">fromThis</a> =&gt; <a href="#129741" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#129743" title="Types.this.Type">toThis</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span>                                =&gt; <a href="#40260" title="Types.this.SubstThisAndSymMap" class="keyword">super</a>.<a href="#127705" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#129747" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class SubstWildcardMap extends Types.this.TypeMap with ScalaObject" id="40261">SubstWildcardMap</a><a href="#40261" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="139775">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="139772">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="139776">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
      <a href="#139776" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.BoundedWildcardType">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="139779">sym</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#139775" title="List[Types.this.Symbol]">from</a> <span title="(elem: Any)Boolean">contains</span> <a href="#139779" title="Types.this.Symbol">sym</a> =&gt;
          <a href="#146959" title="(bounds: Types.this.TypeBounds)Types.this.BoundedWildcardType">BoundedWildcardType</a><span class="delimiter">(</span><a href="#139779" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#139776" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Types.this.WildcardType.type" id="139789">ex</a>: <a href="#40386" title="Types.this.MalformedType">MalformedType</a> =&gt;
        <a href="#130739" title="object Types.this.WildcardType">WildcardType</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

// dependent method types
  <span class="keyword">object</span> <a title="object Types.this.IsDependentCollector" id="40262">IsDependentCollector</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40244" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="129347">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="139799">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#139799" title="Types.this.Type">tp</a> <a href="#42719" title="=&gt; Boolean">isImmediatelyDependent</a><span class="delimiter">)</span> <a href="#129339" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#129339" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#139799" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.ApproximateDependentMap" id="40264">ApproximateDependentMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="129498">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="129499">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span><span class="delimiter">(</span><a href="#129499" title="Types.this.Type">tp</a> <a href="#42719" title="=&gt; Boolean">isImmediatelyDependent</a><span class="delimiter">)</span> <a href="#130739" title="object Types.this.WildcardType">WildcardType</a>
      <span class="keyword">else</span> <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#129499" title="Types.this.Type">tp</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class InstantiateDependentMap extends Types.this.TypeMap with Types.this.KeepOnlyTypeConstraints with ScalaObject" id="40266">InstantiateDependentMap</a><a href="#40266" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="133808">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="133809">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="keyword">with</span> <a href="#40240" title="Types.this.KeepOnlyTypeConstraints">KeepOnlyTypeConstraints</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.IndexedSeq[Types.this.Type]" id="133797">actualsIndexed</a> = <a href="#133809" title="List[Types.this.Type]">actuals</a>.<span title="=&gt; scala.collection.immutable.IndexedSeq[Types.this.Type]">toIndexedSeq</span>

    <span class="keyword">object</span> <a title="object InstantiateDependentMap.this.ParamWithActual" id="133799">ParamWithActual</a> <span title="ScalaObject" class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Option[Types.this.Type]" id="139821">unapply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="139823">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Option[Types.this.Type]">Option</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Int" id="139825">pid</a> = <a href="#133808" title="List[Types.this.Symbol]">params</a> <span title="(elem: Types.this.Symbol)Int">indexOf</span> <a href="#139823" title="Types.this.Symbol">sym</a>
        <span title="Option[Types.this.Type]" class="keyword">if</span><span class="delimiter">(</span><a href="#139825" title="Int">pid</a> <span title="(x: Int)Boolean">!=</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#133797" title="(idx: Int)Types.this.Type">actualsIndexed</a><span class="delimiter">(</span><a href="#139825" title="Int">pid</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="object None">None</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="133801">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="133811">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
      <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#133811" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="#139821" title="(sym: Types.this.Symbol)Option[Types.this.Type]">ParamWithActual</a><span class="delimiter">(</span><a title="Types.this.Type" id="139880">arg</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#139880" title="Types.this.Type">arg</a>.<a href="#42715" title="=&gt; Boolean">isStable</a> =&gt; <a href="#139880" title="Types.this.Type">arg</a> // unsound to replace args by unstable actual #3873
        // (soundly) expand type alias selections on implicit arguments, see depmet_implicit_oopsla* test cases -- typically, `param.isImplicit`
        <span class="keyword">case</span> <a title="Types.this.Type" id="139881">tp1</a>@TypeRef<span class="delimiter">(</span>SingleType<span class="delimiter">(</span><a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="#139821" title="(sym: Types.this.Symbol)Option[Types.this.Type]">ParamWithActual</a><span class="delimiter">(</span><a title="Types.this.Type" id="139883">arg</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a title="Types.this.Symbol" id="139884">sym</a>, <a title="List[Types.this.Type]" id="139885">targs</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="139886">res</a> = <a href="#40198" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#139883" title="Types.this.Type">arg</a>, <a href="#139884" title="Types.this.Symbol">sym</a>, <a href="#139885" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span><span class="delimiter">(</span><a href="#139886" title="Types.this.Type">res</a>.<a href="#42730" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <a href="Symbols.scala.html#47759" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span> <a href="#139886" title="Types.this.Type">res</a>.<a href="#42759" title="=&gt; Types.this.Type">dealias</a>
          <span class="keyword">else</span> <a href="#139881" title="Types.this.TypeRef">tp1</a>
        <span class="keyword">case</span> <a title="Types.this.Type" id="139888">tp1</a> =&gt; <a href="#139888" title="Types.this.Type">tp1</a> // don't return the original `tp`, which may be different from `tp1`, due to dropping annotations
      <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="133802">existentialsNeeded</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#133803" title="(xs: Array[Types.this.Symbol])scala.collection.mutable.ArrayOps[Types.this.Symbol]">existSyms</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Array[Types.this.Symbol]">filter</span><span title="(xs: Array[Types.this.Symbol])scala.collection.mutable.ArrayOps[Types.this.Symbol]" class="delimiter">(</span><a href="#140089" title="Types.this.Symbol">_</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>.<span title="=&gt; List[Types.this.Symbol]">toList</span>

    <span class="keyword">private</span> <span class="keyword">val</span> <a title="Array[Types.this.Symbol]" id="133803">existSyms</a>: <span title="Array[Types.this.Symbol]">Array</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span title="Array[Types.this.Symbol]" class="keyword">new</span> <span title="Array[Types.this.Symbol]">Array</span><span class="delimiter">(</span><a href="#133797" title="=&gt; scala.collection.immutable.IndexedSeq[Types.this.Type]">actualsIndexed</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(i: Int)Boolean" id="133805">haveExistential</a><span class="delimiter">(</span><a title="Int" id="140194">i</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span class="delimiter">{</span><span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#140194" title="Int">i</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#140194" title="Int">i</a> <span title="(x: Int)Boolean">&lt;=</span> <a href="#133797" title="=&gt; scala.collection.immutable.IndexedSeq[Types.this.Type]">actualsIndexed</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span><span class="delimiter">)</span>; <a href="#133803" title="(i: Int)Types.this.Symbol">existSyms</a><span class="delimiter">(</span><a href="#140194" title="Int">i</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">}</span>

    /* Return the type symbol for referencing a parameter inside the existential quantifier.
     * (Only needed if the actual is unstable.)
     */
    <span class="keyword">def</span> <a title="(actualIdx: Int)Types.this.Symbol" id="133806">existSymFor</a><span class="delimiter">(</span><a title="Int" id="140207">actualIdx</a>: <span title="Int">Int</span><span class="delimiter">)</span> =
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#133805" title="(i: Int)Boolean">haveExistential</a><span class="delimiter">(</span><a href="#140207" title="Int">actualIdx</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133803" title="(i: Int)Types.this.Symbol">existSyms</a><span class="delimiter">(</span><a href="#140207" title="Int">actualIdx</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="140210">oldSym</a> = <a href="#133808" title="(n: Int)Types.this.Symbol">params</a><span class="delimiter">(</span><a href="#140207" title="Int">actualIdx</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="140211">symowner</a> = <a href="#140210" title="Types.this.Symbol">oldSym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>
        <span class="keyword">val</span> <a title="Types.this.TypeBounds" id="140212">bound</a> = <a href="#40253" title="(hi: Types.this.Type)Types.this.TypeBounds">singletonBounds</a><span class="delimiter">(</span><a href="#133797" title="(idx: Int)Types.this.Type">actualsIndexed</a><span class="delimiter">(</span><a href="#140207" title="Int">actualIdx</a><span class="delimiter">)</span><span class="delimiter">)</span>

        <span class="keyword">val</span> <a title="Types.this.Symbol" id="140213">sym</a> = <a href="#140211" title="Types.this.Symbol">symowner</a>.<a href="Symbols.scala.html#47729" title="(name: Types.this.TypeName, pos: Types.this.Position, newFlags: Long)Types.this.Symbol">newExistential</a><span class="delimiter">(</span><a href="Names.scala.html#39671" title="(s: String)Types.this.TypeName">newTypeName</a><span class="delimiter">(</span><a href="#140210" title="Types.this.Symbol">oldSym</a>.<a href="Symbols.scala.html#47883" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">name</a> <span title="(other: String)String">+</span> <span title="String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span><span class="delimiter">)</span>, <a href="#140210" title="Types.this.Symbol">oldSym</a>.<a href="Symbols.scala.html#47694" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>
        <a href="#140213" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47922" title="(info: Types.this.Type)sym.type">setInfo</a><span class="delimiter">(</span><a href="#140212" title="Types.this.TypeBounds">bound</a><span class="delimiter">)</span>
        <a href="#140213" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47901" title="(mask: Long)sym.type">setFlag</a><span class="delimiter">(</span><a href="#140210" title="Types.this.Symbol">oldSym</a>.<a href="Symbols.scala.html#47898" title="=&gt; Long">flags</a><span class="delimiter">)</span>

        <a href="#133803" title="(i: Int, x: Types.this.Symbol)Unit">existSyms</a><span class="delimiter">(</span><a href="#140207" title="Int">actualIdx</a><span class="delimiter">)</span> = <a href="#140213" title="Types.this.Symbol">sym</a>
        <a href="#140213" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span>

    //AM propagate more info to annotations -- this seems a bit ad-hoc... (based on code by spoon)
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(arg: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="133807">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="139869">arg</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="139870">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="object treeTrans" id="140248">treeTrans</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#8614" title="Types.this.Transformer">Transformer</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="140251">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="140255">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
          <a href="#140255" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a href="#140259" title="Types.this.Tree">RefParamAt</a><span class="delimiter">(</span><a title="Int" id="140263">pid</a><span class="delimiter">)</span> =&gt;
              // TODO: this should be simplified; in the stable case, one can probably
              // just use an Ident to the tree.symbol. Why an existential in the non-stable case?
              <span class="keyword">val</span> <a title="Types.this.Type" id="140264">actual</a> = <a href="#133797" title="(idx: Int)Types.this.Type">actualsIndexed</a><span class="delimiter">(</span><a href="#140263" title="Int">pid</a><span class="delimiter">)</span>
              <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#140264" title="Types.this.Type">actual</a>.<a href="#42715" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#140264" title="Types.this.Type">actual</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="Required.scala.html#40686" title="=&gt; scala.reflect.internal.TreeGen{val global: Types.this.type}">gen</a>.<a href="TreeGen.scala.html#92626" title="(tpe: Types.this.gen.global.Type, termSym: Types.this.gen.global.Symbol)Types.this.gen.global.Tree">mkAttributedQualifier</a><span class="delimiter">(</span><a href="#133797" title="(idx: Int)Types.this.Type">actualsIndexed</a><span class="delimiter">(</span><a href="#140263" title="Int">pid</a><span class="delimiter">)</span>, <a href="#140255" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                <span class="keyword">val</span> <a title="Types.this.Symbol" id="140286">sym</a> = <a href="#133806" title="(actualIdx: Int)Types.this.Symbol">existSymFor</a><span class="delimiter">(</span><a href="#140263" title="Int">pid</a><span class="delimiter">)</span>
                <span class="delimiter">(</span><a href="#8614" title="(name: Types.this.Name)Types.this.Ident">Ident</a><span class="delimiter">(</span><a href="#140286" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
                 <span title="(tree: Types.this.Tree)Types.this.Ident">copyAttrs</span> <a href="#140255" title="Types.this.Tree">tree</a>
                 <span title="(tp: Types.this.Type)Types.this.Ident">setType</span> <a href="#40198" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="#140286" title="Types.this.Symbol">sym</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="keyword">case</span> <span title="Types.this.Tree">_</span> =&gt; <span class="keyword">super</span>.<span title="(tree: Types.this.Tree)Types.this.Tree">transform</span><span class="delimiter">(</span><a href="#140255" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">object</span> <a title="object scala.reflect.internal.Types.InstantiateDependentMap.treeTrans.RefParamAt" id="140252">RefParamAt</a> <span title="ScalaObject" class="delimiter">{</span>
          <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Option[Int]" id="140259">unapply</a><span class="delimiter">(</span><a title="Types.this.Tree" id="140260">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Option[Int]">Option</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> = <a href="#140260" title="Types.this.Tree">tree</a> <span title="Option[Int]" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Option[Int]">Ident</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <span title="(x: Int)Some[Int]">Some</span><span class="delimiter">(</span><a href="#133808" title="List[Types.this.Symbol]">params</a> <span title="(elem: Types.this.Symbol)Int">indexOf</span> <a href="#140260" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span> <span title="(p: Int =&gt; Boolean)Option[Int]">filterNot</span> <span class="delimiter">(</span><a href="#140327" title="Int">_</a> <span title="(x: Int)Boolean">==</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="None.type">_</span>        =&gt; <span title="object None">None</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#140248" title="object treeTrans">treeTrans</a>.<a href="#140251" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#139869" title="Types.this.Tree">arg</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  <span class="keyword">object</span> <a title="object Types.this.StripAnnotationsMap" id="40267">StripAnnotationsMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="130564">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="130565">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#130565" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">AnnotatedType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="140334">atp</a>, _<span class="delimiter">)</span> =&gt;
        <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#140334" title="Types.this.Type">atp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="140343">tp</a> =&gt;
        <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#140343" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to convert every occurrence of a wildcard type to a fresh
   *  type variable */
  <span class="keyword">object</span> <a title="object Types.this.wildcardToTypeVarMap" id="40269">wildcardToTypeVarMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="136236">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="136237">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#136237" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#130739" title="Types.this.TypeVar">WildcardType</a> =&gt;
        <a href="#84242" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint)Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#136237" title="Types.this.Type">tp</a>, <a href="#84278" title="()Types.this.TypeConstraint" class="keyword">new</a> <a href="#40237" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.TypeVar">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="140361">bounds</a><span class="delimiter">)</span> =&gt;
        <a href="#84242" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint)Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#136237" title="Types.this.Type">tp</a>, <a href="#84277" title="(bounds: Types.this.TypeBounds)Types.this.TypeConstraint" class="keyword">new</a> <a href="#40237" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">(</span><a href="#140361" title="Types.this.TypeBounds">bounds</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#136237" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to convert every occurrence of a type variable to a wildcard type. */
  <span class="keyword">object</span> <a title="object Types.this.typeVarToOriginMap" id="40271">typeVarToOriginMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="130318">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="130319">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#130319" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#84241" title="Types.this.Type">TypeVar</a><span class="delimiter">(</span><a title="Types.this.Type" id="140380">origin</a>, _<span class="delimiter">)</span> =&gt; <a href="#140380" title="Types.this.Type">origin</a>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#130319" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `contains` method. */
  <span class="keyword">class</span> <a title="class ContainsCollector extends Types.this.TypeCollector[Boolean] with ScalaObject" id="40273">ContainsCollector</a><a href="#40273" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="129970">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40244" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="129968">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="140395">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#129339" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#140395" title="Types.this.Type">tp</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="140397">sym1</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#129970" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#140397" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> =&gt; <a href="#129339" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span title="Unit">SingleType</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="140403">sym1</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#129970" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#140403" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> =&gt; <a href="#129339" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt; <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#140395" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(arg: Types.this.Tree)Types.this.Tree" id="129969">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="140408">arg</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Tree" id="140415">t</a> &lt;- <a href="#140408" title="(f: Types.this.Tree =&gt; Unit)Unit">arg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#129968" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#140415" title="Types.this.Tree">t</a>.<span title="=&gt; Types.this.Type">tpe</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#140415" title="Types.this.Tree">t</a>.<span title="=&gt; Types.this.Symbol">symbol</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#129970" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <a href="#129339" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="delimiter">}</span>
      <a href="#140408" title="Types.this.Tree">arg</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `contains` method. */
  <span class="keyword">class</span> <a title="class ContainsTypeCollector extends Types.this.TypeCollector[Boolean] with ScalaObject" id="40274">ContainsTypeCollector</a><a href="#40274" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="129981">t</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40244" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="129979">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="140433">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#129339" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#140433" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#129981" title="Types.this.Type">t</a><span class="delimiter">)</span> <a href="#129339" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
        <span class="keyword">else</span> <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#140433" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(arg: Types.this.Tree)Types.this.Tree" id="129980">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="140436">arg</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Tree" id="140443">t</a> &lt;- <a href="#140436" title="(f: Types.this.Tree =&gt; Unit)Unit">arg</a><span class="delimiter">)</span>
        <a href="#129979" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#140443" title="Types.this.Tree">t</a>.<span title="=&gt; Types.this.Type">tpe</span><span class="delimiter">)</span>

      <a href="#140436" title="Types.this.Tree">arg</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `filter` method. */
  <span class="keyword">class</span> <a title="class FilterTypeCollector extends Types.this.TypeCollector[List[Types.this.Type]] with ScalaObject" id="40275">FilterTypeCollector</a><a href="#40275" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type =&gt; Boolean" id="129759">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40244" title="Types.this.TypeCollector[List[Types.this.Type]]">TypeCollector</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="object Nil">Nil</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(q: Types.this.Type =&gt; Boolean)Types.this.FilterTypeCollector" id="129756">withFilter</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="140453">q</a>: Type =&gt; Boolean<span class="delimiter">)</span> = <span title="Types.this.FilterTypeCollector" class="keyword">new</span> <a href="#40275" title="Types.this.FilterTypeCollector">FilterTypeCollector</a><span class="delimiter">(</span><a title="Types.this.Type" id="140457">tp</a> =&gt; <a href="#129759" title="(v1: Types.this.Type)Boolean">p</a><span class="delimiter">(</span><a href="#140457" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#140453" title="(v1: Types.this.Type)Boolean">q</a><span class="delimiter">(</span><a href="#140457" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)List[Types.this.Type]" id="129757">collect</a><span class="delimiter">(</span><a title="Types.this.Type" id="129761">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#40275" title="Types.this.FilterTypeCollector" class="keyword">super</a>.<a href="#129341" title="(tp: Types.this.Type)List[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#129761" title="Types.this.Type">tp</a><span class="delimiter">)</span>.<span title="=&gt; List[Types.this.Type]">reverse</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="129758">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="140460">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#129759" title="(v1: Types.this.Type)Boolean">p</a><span class="delimiter">(</span><a href="#140460" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#129339" title="(x$1: List[Types.this.Type])Unit">result</a> <span title="(x: Types.this.Type)List[Types.this.Type]">::=</span> <a href="#140460" title="Types.this.Type">tp</a>
      <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#140460" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class ForEachTypeTraverser extends Types.this.TypeTraverser with ScalaObject" id="40276">ForEachTypeTraverser</a><a href="#40276" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type =&gt; Unit" id="129919">f</a>: Type =&gt; Unit<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40243" title="Types.this.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="129918">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="129921">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#129919" title="(v1: Types.this.Type)Unit">f</a><span class="delimiter">(</span><a href="#129921" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#129921" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `filter` method. */
  <span class="keyword">class</span> <a title="class FindTypeCollector extends Types.this.TypeCollector[Option[Types.this.Type]] with ScalaObject" id="40277">FindTypeCollector</a><a href="#40277" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type =&gt; Boolean" id="129914">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40244" title="Types.this.TypeCollector[Option[Types.this.Type]]">TypeCollector</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="object None">None</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="129913">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="140489">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#129339" title="=&gt; Option[Types.this.Type]">result</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#129914" title="(v1: Types.this.Type)Boolean">p</a><span class="delimiter">(</span><a href="#140489" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#129339" title="(x$1: Option[Types.this.Type])Unit">result</a> = <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#140489" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#140489" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `contains` method. */
  <span class="keyword">object</span> <a title="object Types.this.ErroneousCollector" id="40278">ErroneousCollector</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40244" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="129361">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="140507">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#129339" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#129339" title="(x$1: Boolean)Unit">result</a> = <a href="#140507" title="Types.this.Type">tp</a>.<a href="#42722" title="=&gt; Boolean">isError</a>
        <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#140507" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** The most deeply nested owner that contains all the symbols
   *  of thistype or prefixless typerefs/singletype occurrences in given type.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(t: Types.this.Type)Types.this.Symbol" id="40280">commonOwner</a><span class="delimiter">(</span><a title="Types.this.Type" id="129391">t</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <a href="#40281" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#129391" title="Types.this.Type">t</a> <a href="#140522" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <span title="object Nil">Nil</span><span class="delimiter">)</span>

  /** The most deeply nested owner that contains all the symbols
   *  of thistype or prefixless typerefs/singletype occurrences in given list
   *  of types.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type])Types.this.Symbol" id="40281">commonOwner</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="129389">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
    <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#129389" title="List[Types.this.Type]">tps</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <a href="#40282" title="object Types.this.commonOwnerMap">commonOwnerMap</a>.<a href="#140532" title="(x$1: Types.this.Symbol)Unit">result</a> = <span title="Null(null)" class="keyword">null</span>
      <a href="#129389" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Unit)Unit">foreach</span> <span class="delimiter">(</span><a href="#40282" title="object Types.this.commonOwnerMap">commonOwnerMap</a> <a href="#140535" title="(tp: Types.this.Type)Unit">traverse</a> <a href="#140556" title="Types.this.Type">_</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="140529">result</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#40282" title="object Types.this.commonOwnerMap">commonOwnerMap</a>.<a href="#140532" title="=&gt; Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#40282" title="object Types.this.commonOwnerMap">commonOwnerMap</a>.<a href="#140532" title="=&gt; Types.this.Symbol">result</a> <span class="keyword">else</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a>
      <a href="SymbolTable.scala.html#36941" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="#129389" title="List[Types.this.Type]">tps</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;commonOwner(&quot;)" class="string">&quot;commonOwner(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;) == &quot;)" class="string">&quot;) == &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#140529" title="Types.this.Symbol">result</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#140529" title="Types.this.Symbol">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">private</span> <span class="keyword">object</span> <a title="object Types.this.commonOwnerMap" id="40282">commonOwnerMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40243" title="Types.this.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="Types.this.Symbol" id="140532">result</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = _

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="140534">register</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="140561">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      // First considered type is the trivial result.
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#140532" title="=&gt; Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#140561" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#140532" title="(x$1: Types.this.Symbol)Unit">result</a> = <a href="#140561" title="Types.this.Symbol">sym</a>
      <span class="keyword">else</span>
        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#140532" title="=&gt; Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#140532" title="=&gt; Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#140561" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#140561" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#47962" title="(that: Types.this.Symbol)Boolean">isNestedIn</a> <a href="#140532" title="=&gt; Types.this.Symbol">result</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#140532" title="(x$1: Types.this.Symbol)Unit">result</a> = <a href="#140532" title="=&gt; Types.this.Symbol">result</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="140535">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="140557">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#140557" title="Types.this.Type">tp</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Unit">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="140560">sym</a><span class="delimiter">)</span>                =&gt; <a href="#140534" title="(sym: Types.this.Symbol)Unit">register</a><span class="delimiter">(</span><a href="#140560" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span><a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="140563">sym</a>, <a title="List[Types.this.Type]" id="140564">args</a><span class="delimiter">)</span> =&gt; <a href="#140534" title="(sym: Types.this.Symbol)Unit">register</a><span class="delimiter">(</span><a href="#140563" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span> ; <a href="#140564" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Unit)Unit">foreach</span> <a href="#140535" title="(tp: Types.this.Type)Unit">traverse</a>
      <span class="keyword">case</span> <span title="Unit">SingleType</span><span class="delimiter">(</span><a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="140586">sym</a><span class="delimiter">)</span>    =&gt; <a href="#140534" title="(sym: Types.this.Symbol)Unit">register</a><span class="delimiter">(</span><a href="#140586" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Unit">_</span>                            =&gt; <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#140557" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class MissingAliasControl extends Throwable with scala.util.control.ControlThrowable with ScalaObject" id="40284">MissingAliasControl</a> <a href="#40284" title="ScalaObject" class="keyword">extends</a> <span title="scala.util.control.ControlThrowable">ControlThrowable</span>
  <span class="keyword">val</span> <a title="Types.this.MissingAliasControl" id="40285">missingAliasException</a> = <span title="Types.this.MissingAliasControl" class="keyword">new</span> <a href="#40284" title="Types.this.MissingAliasControl">MissingAliasControl</a>
  <span class="keyword">class</span> <a title="class MissingTypeControl extends Throwable with scala.util.control.ControlThrowable with ScalaObject" id="40287">MissingTypeControl</a> <a href="#40287" title="ScalaObject" class="keyword">extends</a> <span title="scala.util.control.ControlThrowable">ControlThrowable</span>

  <span class="keyword">object</span> <a title="object Types.this.adaptToNewRunMap" id="40288">adaptToNewRunMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#40242" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol" id="114765">adaptToNewRun</a><span class="delimiter">(</span><a title="Types.this.Type" id="140611">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="140612">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70384" title="=&gt; Boolean">flatClasses</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#140612" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#140612" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#40473" title="object Types.this.definitions">definitions</a>.<a href="Definitions.scala.html#46242" title="=&gt; Types.this.ModuleClassSymbol">RootClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="Definitions.scala.html#40473" title="object Types.this.definitions">definitions</a>.<a href="Definitions.scala.html#46242" title="=&gt; Types.this.ModuleClassSymbol">RootClass</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#140612" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#40473" title="object Types.this.definitions">definitions</a>.<a href="Definitions.scala.html#46240" title="=&gt; Types.this.Symbol">RootPackage</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="Definitions.scala.html#40473" title="object Types.this.definitions">definitions</a>.<a href="Definitions.scala.html#46240" title="=&gt; Types.this.Symbol">RootPackage</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#140612" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47775" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="140622">sourceModule1</a> = <a href="#114765" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#140611" title="Types.this.Type">pre</a>, <a href="#140612" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47985" title="=&gt; Types.this.Symbol">sourceModule</a><span class="delimiter">)</span>
        <span class="keyword">var</span> <a title="Types.this.Symbol" id="140623">result</a> = <a href="#140622" title="Types.this.Symbol">sourceModule1</a>.<a href="Symbols.scala.html#48010" title="=&gt; Types.this.Symbol">moduleClass</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#140623" title="Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#140623" title="Types.this.Symbol">result</a> = <a href="#140622" title="Types.this.Symbol">sourceModule1</a>.<a href="Symbols.scala.html#47932" title="=&gt; sourceModule1.type">initialize</a>.<a href="Symbols.scala.html#48010" title="=&gt; Types.this.Symbol">moduleClass</a>
        <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#140623" title="Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#140623" title="Types.this.Symbol">result</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="String" id="140634">msg</a> = <span title="String(&quot;Cannot adapt module class; sym = %s, sourceModule = %s, sourceModule.moduleClass = %s =&gt; sourceModule1 = %s, sourceModule1.moduleClass = %s&quot;)" class="string">&quot;Cannot adapt module class; sym = %s, sourceModule = %s, sourceModule.moduleClass = %s =&gt; sourceModule1 = %s, sourceModule1.moduleClass = %s&quot;</span>
          <a href="SymbolTable.scala.html#36941" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="#140634" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">msg</a>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#140612" title="Types.this.Symbol">sym</a>, <a href="#140612" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47985" title="=&gt; Types.this.Symbol">sourceModule</a>, <a href="#140612" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47985" title="=&gt; Types.this.Symbol">sourceModule</a>.<a href="Symbols.scala.html#48010" title="=&gt; Types.this.Symbol">moduleClass</a>, <a href="#140622" title="Types.this.Symbol">sourceModule1</a>, <a href="#140622" title="Types.this.Symbol">sourceModule1</a>.<a href="Symbols.scala.html#48010" title="=&gt; Types.this.Symbol">moduleClass</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#140612" title="Types.this.Symbol">sym</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#140611" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#140611" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#140612" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#140612" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">var</span> <a title="Types.this.Symbol" id="140639">rebind0</a> = <a href="#140611" title="Types.this.Type">pre</a>.<a href="#42819" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#140612" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a>, <span title="Long(67108864L)">BRIDGE</span>, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#140639" title="Types.this.Symbol">rebind0</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#140612" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47759" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <a href="#40285" title="=&gt; Types.this.MissingAliasControl">missingAliasException</a>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75538" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#140611" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">pre</a><span title="(other: String)String">+</span><span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span><span title="(x$1: Any)String">+</span><a href="#140612" title="Types.this.Symbol">sym</a><span title="(x$1: Any)String">+</span><span title="String(&quot; does no longer exist, phase = &quot;)" class="string">&quot; does no longer exist, phase = &quot;</span><span title="(x$1: Any)String">+</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <span title="Types.this.MissingTypeControl" class="keyword">new</span> <a href="#40287" title="Types.this.MissingTypeControl">MissingTypeControl</a> // For build manager and presentation compiler purposes
          //assert(false, pre+&quot;.&quot;+sym+&quot; does no longer exist, phase = &quot;+phase)
        <span class="delimiter">}</span>
        /** The two symbols have the same fully qualified name */
        <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean" id="140640">corresponds</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="140654">sym1</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="140655">sym2</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
          <a href="#140654" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#140655" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#140654" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="#140640" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#140654" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>, <a href="#140655" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#140640" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#140612" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>, <a href="#140639" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="SymbolTable.scala.html#36941" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><span title="String(&quot;ADAPT1 pre = &quot;)" class="string">&quot;ADAPT1 pre = &quot;</span><span title="(x$1: Any)String">+</span><a href="#140611" title="Types.this.Type">pre</a><span title="(x$1: Any)String">+</span><span title="String(&quot;, sym = &quot;)" class="string">&quot;, sym = &quot;</span><span title="(x$1: Any)String">+</span><a href="#140612" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#48049" title="=&gt; String">fullLocationString</a><span title="(x$1: Any)String">+</span><span title="String(&quot;, rebind = &quot;)" class="string">&quot;, rebind = &quot;</span><span title="(x$1: Any)String">+</span><a href="#140639" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#48049" title="=&gt; String">fullLocationString</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="140662">bcs</a> = <a href="#140611" title="Types.this.Type">pre</a>.<a href="#42805" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">dropWhile</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="140669">bc</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#140640" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#140669" title="Types.this.Symbol">bc</a>, <a href="#140612" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>;
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#140662" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
            <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#140611" title="Types.this.Type">pre</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47779" title="=&gt; Boolean">isRefinementClass</a>, <a href="#140611" title="Types.this.Type">pre</a><span class="delimiter">)</span> // if pre is a refinementclass it might be a structural type =&gt; OK to leave it in.
          <span class="keyword">else</span>
            <a href="#140639" title="Types.this.Symbol">rebind0</a> = <a href="#140611" title="Types.this.Type">pre</a>.<a href="#42777" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#140662" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Types.this.Symbol">head</span><span class="delimiter">)</span>.<a href="#42769" title="(name: Types.this.Name)Types.this.Symbol">member</a><span class="delimiter">(</span><a href="#140612" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
          <a href="SymbolTable.scala.html#36941" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span>
            <span title="String(&quot;ADAPT2 pre = &quot;)" class="string">&quot;ADAPT2 pre = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#140611" title="Types.this.Type">pre</a> <span title="(x$1: Any)String">+</span>
            <span title="String(&quot;, bcs.head = &quot;)" class="string">&quot;, bcs.head = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#140662" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Types.this.Symbol">head</span> <span title="(x$1: Any)String">+</span>
            <span title="String(&quot;, sym = &quot;)" class="string">&quot;, sym = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#140612" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#48049" title="=&gt; String">fullLocationString</a> <span title="(x$1: Any)String">+</span>
            <span title="String(&quot;, rebind = &quot;)" class="string">&quot;, rebind = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#140639" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#48049" title="=&gt; String">fullLocationString</a>
          <span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="140641">rebind</a> = <a href="#140639" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#47969" title="(cond: Types.this.Symbol =&gt; Boolean)Types.this.Symbol">suchThat</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="140676">sym</a> =&gt; <a href="#140676" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47756" title="=&gt; Boolean">isType</a> <span title="(x: Boolean)Boolean">||</span> <a href="#140676" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47846" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#140641" title="Types.this.Symbol">rebind</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="SymbolTable.scala.html#36941" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)String">+</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70384" title="=&gt; Boolean">flatClasses</a><span title="(x$1: Any)String">+</span><a href="#140612" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a><span title="(x$1: Any)String">+</span><a href="#140612" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span title="(x$1: Any)String">+</span><span title="String(&quot; &quot;)" class="string">&quot; &quot;</span><span title="(x$1: Any)String">+</span><a href="#140612" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47756" title="=&gt; Boolean">isType</a><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <a href="#139793" title="(pre: Types.this.Type, tp: String)Types.this.MalformedType" class="keyword">new</a> <a href="#40386" title="Types.this.MalformedType">MalformedType</a><span class="delimiter">(</span><a href="#140611" title="Types.this.Type">pre</a>, <a href="#140612" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#48044" title="=&gt; String">nameString</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#140641" title="Types.this.Symbol">rebind</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="114766">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="114767">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#114767" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="140686">sym</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">try</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="140687">sym1</a> = <a href="#114765" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#140686" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#47980" title="=&gt; Types.this.Type">thisType</a>, <a href="#140686" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140687" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#140686" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#114767" title="Types.this.Type">tp</a> <span class="keyword">else</span> <a href="#83395" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="#140687" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        	<span class="keyword">case</span> <a title="Types.this.Type" id="140693">ex</a>: <a href="#40287" title="Types.this.MissingTypeControl">MissingTypeControl</a> =&gt;
            <a href="#114767" title="Types.this.Type">tp</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="140694">pre</a>, <a title="Types.this.Symbol" id="140695">sym</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140695" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47786" title="=&gt; Boolean">isPackage</a><span class="delimiter">)</span> <a href="#114767" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="140696">pre1</a> = <a href="#114766" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#140694" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="140697">sym1</a> = <a href="#114765" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#140696" title="Types.this.Type">pre1</a>, <a href="#140695" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#140696" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#140694" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#140697" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#140695" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#114767" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#40194" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#140696" title="Types.this.Type">pre1</a>, <a href="#140697" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="140699">pre</a>, <a title="Types.this.Symbol" id="140700">sym</a>, <a title="List[Types.this.Type]" id="140701">args</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140700" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#114767" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="140702">pre1</a> = <a href="#114766" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#140699" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="140703">args1</a> = <a href="#140701" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>
          <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="140710">sym1</a> = <a href="#114765" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#140702" title="Types.this.Type">pre1</a>, <a href="#140700" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#140702" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#140699" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#140710" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#140700" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#140703" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#140701" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>/* &amp;&amp; sym.isExternal*/<span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#114767" title="Types.this.Type">tp</a>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140710" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75538" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;adapt fail: &quot;)" class="string">&quot;adapt fail: &quot;</span><span title="(x$1: Any)String">+</span><a href="#140699" title="Types.this.Type">pre</a><span title="(x$1: Any)String">+</span><span title="String(&quot; &quot;)" class="string">&quot; &quot;</span><span title="(x$1: Any)String">+</span><a href="#140702" title="Types.this.Type">pre1</a><span title="(x$1: Any)String">+</span><span title="String(&quot; &quot;)" class="string">&quot; &quot;</span><span title="(x$1: Any)String">+</span><a href="#140700" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
              <a href="#114767" title="Types.this.Type">tp</a>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <a href="#40199" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#114767" title="Types.this.Type">tp</a>, <a href="#140702" title="Types.this.Type">pre1</a>, <a href="#140710" title="Types.this.Symbol">sym1</a>, <a href="#140703" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a title="Types.this.Type" id="140720">ex</a>: <a href="#40284" title="Types.this.MissingAliasControl">MissingAliasControl</a> =&gt;
              <a href="#114766" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#114767" title="Types.this.Type">tp</a>.<a href="#42759" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="Types.this.Type">_</span>: <a href="#40287" title="Types.this.MissingTypeControl">MissingTypeControl</a> =&gt;
              <a href="#114767" title="Types.this.Type">tp</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="140722">params</a>, <a title="Types.this.Type" id="140723">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="140724">restp1</a> = <a href="#114766" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#140723" title="Types.this.Type">restp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140724" title="Types.this.Type">restp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#140723" title="Types.this.Type">restp</a><span class="delimiter">)</span> <a href="#114767" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#40201" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#114767" title="Types.this.Type">tp</a>, <a href="#140722" title="List[Types.this.Symbol]">params</a>, <a href="#140724" title="Types.this.Type">restp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="140726">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="140727">restp1</a> = <a href="#114766" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#140726" title="Types.this.Type">restp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140727" title="Types.this.Type">restp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#140726" title="Types.this.Type">restp</a><span class="delimiter">)</span> <a href="#114767" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#66963" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#140727" title="Types.this.Type">restp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="140728">tparams</a>, <a title="Types.this.Type" id="140729">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="140730">restp1</a> = <a href="#114766" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#140729" title="Types.this.Type">restp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140730" title="Types.this.Type">restp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#140729" title="Types.this.Type">restp</a><span class="delimiter">)</span> <a href="#114767" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#67004" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#140728" title="List[Types.this.Symbol]">tparams</a>, <a href="#140730" title="Types.this.Type">restp1</a><span class="delimiter">)</span>

      // Lukas: we need to check (together) whether we should also include parameter types
      // of PolyType and MethodType in adaptToNewRun

      <span class="keyword">case</span> <span title="Types.this.Type">ClassInfoType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="140731">parents</a>, <a title="Types.this.Scope" id="140732">decls</a>, <a title="Types.this.Symbol" id="140733">clazz</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140733" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#114767" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="140734">parents1</a> = <a href="#140731" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140734" title="List[Types.this.Type]">parents1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#140731" title="List[Types.this.Type]">parents</a><span class="delimiter">)</span> <a href="#114767" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#71108" title="(parents: List[Types.this.Type], decls: Types.this.Scope, typeSymbol: Types.this.Symbol)Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">(</span><a href="#140734" title="List[Types.this.Type]">parents1</a>, <a href="#140732" title="Types.this.Scope">decls</a>, <a href="#140733" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="140741">parents</a>, <a title="Types.this.Scope" id="140742">decls</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="140743">parents1</a> = <a href="#140741" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140743" title="List[Types.this.Type]">parents1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#140741" title="List[Types.this.Type]">parents</a><span class="delimiter">)</span> <a href="#114767" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#40195" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#140743" title="List[Types.this.Type]">parents1</a>, <a href="#114767" title="Types.this.Type">tp</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>, <a href="#140742" title="Types.this.Scope">decls</a>, <a href="#114767" title="Types.this.Type">tp</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#47694" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SuperType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#114767" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeBounds</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#114767" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="#84241" title="Types.this.Type">TypeVar</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#114767" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">AnnotatedType</span><span class="delimiter">(</span>_,_,_<span class="delimiter">)</span> =&gt; <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#114767" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">NotNullType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#114767" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#82353" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#114767" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#114767" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class SubTypePair extends Object with ScalaObject" id="40290">SubTypePair</a><a href="#40290" title="ScalaObject" class="delimiter">(</a><span class="keyword">val</span> <a title="Types.this.Type" id="140818">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <span class="keyword">val</span> <a title="Types.this.Type" id="140819">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()Int" id="140812">hashCode</a> = <a href="#140818" title="=&gt; Types.this.Type">tp1</a>.<span title="()Int">hashCode</span> <span title="(x: Int)Int">*</span> <span title="Int(41)" class="int">41</span> <span title="(x: Int)Int">+</span> <a href="#140819" title="=&gt; Types.this.Type">tp2</a>.<span title="()Int">hashCode</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(other: Any)Boolean" id="140813">equals</a><span class="delimiter">(</span><a title="Any" id="140831">other</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <a href="#140831" title="Any">other</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="140834">stp</a>: <a href="#40290" title="Types.this.SubTypePair">SubTypePair</a> =&gt;
        <span class="delimiter">(</span><a href="#140818" title="=&gt; Types.this.Type">tp1</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#140834" title="Types.this.SubTypePair">stp</a>.<a href="#140818" title="=&gt; Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#140819" title="=&gt; Types.this.Type">tp2</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#140834" title="Types.this.SubTypePair">stp</a>.<a href="#140819" title="=&gt; Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
        <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="140814">toString</a> = <a href="#140818" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">tp1</a><span title="(other: String)String">+</span><span title="String(&quot; &lt;:&lt;? &quot;)" class="string">&quot; &lt;:&lt;? &quot;</span><span title="(x$1: Any)String">+</span><a href="#140819" title="=&gt; Types.this.Type">tp2</a>
  <span class="delimiter">}</span>

// Helper Methods  -------------------------------------------------------------

  <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(0)" id="40291">LubGlbMargin</a> = <span title="Int(0)" class="int">0</span>

  /** The maximum allowable depth of lubs or glbs over types `ts`.
    * This is the maximum depth of all types in the base type sequences
    * of each of the types `ts`, plus LubGlbMargin.
    */
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Int" id="40293">lubDepth</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="61823">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="Int" id="61826">d</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="61857">tp</a> &lt;- <a href="#61823" title="(f: Types.this.Type =&gt; Unit)Unit">ts</a><span class="delimiter">)</span> <a href="#61826" title="Int">d</a> = math.<span title="(x: Int, y: Int)Int">max</span><span class="delimiter">(</span><a href="#61826" title="Int">d</a>, <a href="#61857" title="Types.this.Type">tp</a>.<a href="#42804" title="=&gt; Int">baseTypeSeqDepth</a><span class="delimiter">)</span>
    <a href="#61826" title="Int">d</a> <span title="(x: Int)Int">+</span> <span title="Int(0)">LubGlbMargin</span>
  <span class="delimiter">}</span>

  /** Is intersection of given types populated? That is,
   *  for all types tp1, tp2 in intersection
   *    for all common base classes bc of tp1 and tp2
   *      let bt1, bt2 be the base types of tp1, tp2 relative to class bc
   *      Then:
   *        bt1 and bt2 have the same prefix, and
   *        any corresponding non-variant type arguments of bt1 and bt2 are the same
   */
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="40294">isPopulated</a><span class="delimiter">(</span><a title="Types.this.Type" id="125085">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="125086">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="140842">isConsistent</a><span class="delimiter">(</span><a title="Types.this.Type" id="140844">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="140845">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#140844" title="Types.this.Type">tp1</a>, <a href="#140845" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="140854">pre1</a>, <a title="Types.this.Symbol" id="140855">sym1</a>, <a title="List[Types.this.Type]" id="140856">args1</a><span class="delimiter">)</span>, TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="140857">pre2</a>, <a title="Types.this.Symbol" id="140858">sym2</a>, <a title="List[Types.this.Type]" id="140859">args2</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#140855" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#140858" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>
        <a href="#140854" title="Types.this.Type">pre1</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#140857" title="Types.this.Type">pre2</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <a href="util/Collections.scala.html#39635" title="(xs1: List[Types.this.Type], xs2: List[Types.this.Type], xs3: List[Types.this.Symbol])(f: (Types.this.Type, Types.this.Type, Types.this.Symbol) =&gt; Boolean)Boolean">forall3</a><span class="delimiter">(</span><a href="#140856" title="List[Types.this.Type]">args1</a>, <a href="#140859" title="List[Types.this.Type]">args2</a>, <a href="#140855" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Type" id="140923">arg1</a>, <a title="Types.this.Type" id="140924">arg2</a>, <a title="Types.this.Symbol" id="140925">tparam</a><span class="delimiter">)</span> =&gt; 
            //if (tparam.variance == 0 &amp;&amp; !(arg1 =:= arg2)) Console.println(&quot;inconsistent: &quot;+arg1+&quot;!=&quot;+arg2)//DEBUG
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#140925" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47874" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#140923" title="Types.this.Type">arg1</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#140924" title="Types.this.Type">arg2</a>
          <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#140923" title="Types.this.Type">arg1</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#40176" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span><span class="delimiter">)</span>
            // if left-hand argument is a typevar, make it compatible with variance
            // this is for more precise pattern matching
            // todo: work this in the spec of this method
            // also: think what happens if there are embedded typevars?
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#140925" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47874" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#140923" title="Types.this.Type">arg1</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#140924" title="Types.this.Type">arg2</a> <span class="keyword">else</span> <a href="#140924" title="Types.this.Type">arg2</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#140923" title="Types.this.Type">arg1</a>
          <span class="keyword">else</span> <span title="Boolean(true)" class="keyword">true</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span><a title="Types.this.ExistentialType" id="140940">et</a>: <a href="#67120" title="Types.this.ExistentialType">ExistentialType</a>, _<span class="delimiter">)</span> =&gt;
        <a href="#140940" title="Types.this.ExistentialType">et</a>.<a href="#67148" title="(op: Types.this.Type =&gt; Boolean)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#140842" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#140944" title="Types.this.Type">_</a>, <a href="#140845" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>_, <a title="Types.this.ExistentialType" id="140947">et</a>: <a href="#67120" title="Types.this.ExistentialType">ExistentialType</a><span class="delimiter">)</span> =&gt;
        <a href="#140947" title="Types.this.ExistentialType">et</a>.<a href="#67148" title="(op: Types.this.Type =&gt; Boolean)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#140842" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#140844" title="Types.this.Type">tp1</a>, <a href="#140951" title="Types.this.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="140843">check</a><span class="delimiter">(</span><a title="Types.this.Type" id="140952">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="140953">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#140952" title="Types.this.Type">tp1</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47757" title="=&gt; Boolean">isClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#140952" title="Types.this.Type">tp1</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47905" title="(mask: Long)Boolean">hasFlag</a><span class="delimiter">(</span><span title="Long(32L)">FINAL</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#140952" title="Types.this.Type">tp1</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#140953" title="Types.this.Type">tp2</a> <span title="(x: Boolean)Boolean">||</span> <a href="Definitions.scala.html#46830" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#140952" title="Types.this.Type">tp1</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#46830" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#140953" title="Types.this.Type">tp2</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#140952" title="Types.this.Type">tp1</a>.<a href="#42805" title="=&gt; List[Types.this.Symbol]">baseClasses</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="140965">bc</a> =&gt;
        <a href="#140953" title="Types.this.Type">tp2</a>.<a href="#42806" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#140965" title="Types.this.Symbol">bc</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#140842" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#140952" title="Types.this.Type">tp1</a>.<a href="#42777" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#140965" title="Types.this.Symbol">bc</a><span class="delimiter">)</span>, <a href="#140953" title="Types.this.Type">tp2</a>.<a href="#42777" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#140965" title="Types.this.Symbol">bc</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <a href="#140843" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">check</a><span class="delimiter">(</span><a href="#125085" title="Types.this.Type">tp1</a>, <a href="#125086" title="Types.this.Type">tp2</a><span class="delimiter">)</span>/* &amp;&amp; check(tp2, tp1)*/ // need to investgate why this can't be made symmetric -- neg/gadts1 fails, and run/existials also.
  <span class="delimiter">}</span>

  /** Does a pattern of type `patType` need an outer test when executed against
   *  selector type `selType` in context defined by `currentOwner`?
   */
  <span class="keyword">def</span> <a title="(patType: Types.this.Type, selType: Types.this.Type, currentOwner: Types.this.Symbol)Boolean" id="40295">needsOuterTest</a><span class="delimiter">(</span><a title="Types.this.Type" id="125036">patType</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="125037">selType</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="125038">currentOwner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type)Types.this.Type" id="125041">createDummyClone</a><span class="delimiter">(</span><a title="Types.this.Type" id="125043">pre</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.TermSymbol" id="125044">dummy</a> = <a href="#125038" title="Types.this.Symbol">currentOwner</a>.<a href="Symbols.scala.html#47975" title="Types.this.Symbol" id="125052">enclClass</a>.<a href="Symbols.scala.html#72658" title="Types.this.Position" id="125055">newValue</a><span class="delimiter">(</span><a href="StdNames.scala.html#40560" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#60007" title="Types.this.nme.NameType" id="125053">ANYNAME</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#47922" title="(info: Types.this.Type)Types.this.TermSymbol">setInfo</a><span class="delimiter">(</span><a href="#125043" title="Types.this.Type">pre</a>.<a href="#42732" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
      <a href="#40194" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#83395" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="#125038" title="Types.this.Symbol">currentOwner</a>.<a href="Symbols.scala.html#47975" title="=&gt; Types.this.Symbol">enclClass</a><span class="delimiter">)</span>, <a href="#125044" title="Types.this.TermSymbol">dummy</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="125042">maybeCreateDummyClone</a><span class="delimiter">(</span><a title="Types.this.Type" id="125060">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="125061">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#125060" title="Types.this.Type">pre</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="125062">pre1</a>, <a title="Types.this.Symbol" id="125063">sym1</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#125063" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47774" title="=&gt; Boolean">isModule</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#125063" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47857" title="=&gt; Boolean">isStatic</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#130794" title="object Types.this.NoType">NoType</a>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#125063" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47774" title="=&gt; Boolean">isModule</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#125061" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#125063" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#48010" title="=&gt; Types.this.Symbol">moduleClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="125069">pre2</a> = <a href="#125042" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span><a href="#125062" title="Types.this.Type">pre1</a>, <a href="#125063" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#125069" title="Types.this.Type">pre2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <a href="#125069" title="Types.this.Type">pre2</a>
          <span class="keyword">else</span> <a href="#40194" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#125069" title="Types.this.Type">pre2</a>, <a href="#125063" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <a href="#125041" title="(pre: Types.this.Type)Types.this.Type">createDummyClone</a><span class="delimiter">(</span><a href="#125060" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="125070">clazz</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#125070" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#47775" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span>
          <a href="#125042" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span><a href="#125070" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#47979" title="=&gt; Types.this.Type">typeOfThis</a>, <a href="#125061" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#125061" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#125070" title="Types.this.Symbol">clazz</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#125061" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47905" title="(mask: Long)Boolean">hasFlag</a><span class="delimiter">(</span><span title="Long(4L)">PRIVATE</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#125061" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47911" title="=&gt; Types.this.Symbol">privateWithin</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#125070" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#130794" title="object Types.this.NoType">NoType</a>
        <span class="keyword">else</span>
          <a href="#125041" title="(pre: Types.this.Type)Types.this.Type">createDummyClone</a><span class="delimiter">(</span><a href="#125060" title="Types.this.Type">pre</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.NoType.type">_</span> =&gt;
        <a href="#130794" title="object Types.this.NoType">NoType</a>
    <span class="delimiter">}</span>
    <a href="#125036" title="Types.this.Type">patType</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="125081">pre</a>, <a title="Types.this.Symbol" id="125082">sym</a>, <a title="List[Types.this.Type]" id="125083">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="125084">pre1</a> = <a href="#125042" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span><a href="#125081" title="Types.this.Type">pre</a>, <a href="#125082" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="#125084" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#40294" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isPopulated</a><span class="delimiter">(</span><a href="#40199" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#125036" title="Types.this.Type">patType</a>, <a href="#125084" title="Types.this.Type">pre1</a>, <a href="#125082" title="Types.this.Symbol">sym</a>, <a href="#125083" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, <a href="#125037" title="Types.this.Type">selType</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
        <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="40297">subsametypeRecursions</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(pre1: Types.this.Type, pre2: Types.this.Type)Boolean" id="40299">isUnifiable</a><span class="delimiter">(</span><a title="Types.this.Type" id="140972">pre1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="140973">pre2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
    <span class="delimiter">(</span><a href="#40321" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#140972" title="Types.this.Type">pre1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#40321" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#140973" title="Types.this.Type">pre2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#140972" title="Types.this.Type">pre1</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#140973" title="Types.this.Type">pre2</a><span class="delimiter">)</span>

  /** Returns true iff we are past phase specialize,
   *  sym1 and sym2 are two existential skolems with equal names and bounds,
   *  and pre1 and pre2 are equal prefixes
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol, pre1: Types.this.Type, pre2: Types.this.Type)Boolean" id="40300">isSameSpecializedSkolem</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="140979">sym1</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="140980">sym2</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="140981">pre1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="140982">pre2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#140979" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47812" title="=&gt; Boolean">isExistentialSkolem</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#140980" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47812" title="=&gt; Boolean">isExistentialSkolem</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
    <a href="#140979" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#140980" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
    <a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70382" title="=&gt; Boolean">specialized</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
    <a href="#140979" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#140980" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
    <a href="#140981" title="Types.this.Type">pre1</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#140982" title="Types.this.Type">pre2</a>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean" id="40301">equalSymsAndPrefixes</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="140993">sym1</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="140994">pre1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="140995">sym2</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="140996">pre2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#140993" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#140995" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> <a href="#140993" title="Types.this.Symbol">sym1</a>.<a href="HasFlags.scala.html#48109" title="=&gt; Boolean">hasPackageFlag</a> <span title="(x: Boolean)Boolean">||</span> <a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#140994" title="Types.this.Type">pre1</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#140996" title="Types.this.Type">pre2</a>
    <span class="keyword">else</span> <span class="delimiter">(</span><a href="#140993" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#140995" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#40299" title="(pre1: Types.this.Type, pre2: Types.this.Type)Boolean">isUnifiable</a><span class="delimiter">(</span><a href="#140994" title="Types.this.Type">pre1</a>, <a href="#140996" title="Types.this.Type">pre2</a><span class="delimiter">)</span>

  /** Do `tp1` and `tp2` denote equivalent types? */
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="40302">isSameType</a><span class="delimiter">(</span><a title="Types.this.Type" id="130189">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="130190">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="util/StatBase.scala.html#39915" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#39955" title="=&gt; scala.reflect.internal.util.Statistics.Counter">sametypeCount</a><span class="delimiter">)</span>
    <a href="#40297" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <a href="#40074" title="object Types.this.undoLog">undoLog</a> <a href="#128922" title="(block: =&gt; Boolean)Boolean">undoUnless</a> <span class="delimiter">{</span>
      <a href="#40306" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType1</a><span class="delimiter">(</span><a href="#130189" title="Types.this.Type">tp1</a>, <a href="#130190" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#40297" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
    // XXX AM TODO: figure out when it is safe and needed to clear the log -- the commented approach below is too eager (it breaks #3281, #3866)
    // it doesn't help to keep separate recursion counts for the three methods that now share it
    // if (subsametypeRecursions == 0) undoLog.clear()
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="40303">isDifferentType</a><span class="delimiter">(</span><a title="Types.this.Type" id="141021">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141022">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="#40297" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <a href="#40074" title="object Types.this.undoLog">undoLog</a> <a href="#128919" title="(block: =&gt; Boolean)Boolean">undo</a> <span class="delimiter">{</span> // undo type constraints that arise from operations in this block
      <span title="=&gt; Boolean">!</span><a href="#40306" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType1</a><span class="delimiter">(</span><a href="#141021" title="Types.this.Type">tp1</a>, <a href="#141022" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#40297" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
    // XXX AM TODO: figure out when it is safe and needed to clear the log -- the commented approach below is too eager (it breaks #3281, #3866)
    // it doesn't help to keep separate recursion counts for the three methods that now share it
    // if (subsametypeRecursions == 0) undoLog.clear()
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="40304">isDifferentTypeConstructor</a><span class="delimiter">(</span><a title="Types.this.Type" id="141035">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141036">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#141035" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="141038">pre1</a>, <a title="Types.this.Symbol" id="141039">sym1</a>, _<span class="delimiter">)</span> =&gt;
      <a href="#141036" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="141040">pre2</a>, <a title="Types.this.Symbol" id="141041">sym2</a>, _<span class="delimiter">)</span> =&gt; <a href="#141039" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#141041" title="Types.this.Symbol">sym2</a> <span title="(x: Boolean)Boolean">||</span> <a href="#40303" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isDifferentType</a><span class="delimiter">(</span><a href="#141038" title="Types.this.Type">pre1</a>, <a href="#141040" title="Types.this.Type">pre2</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Boolean(true)">_</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> <span title="Boolean(true)">_</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="40305">normalizePlus</a><span class="delimiter">(</span><a title="Types.this.Type" id="141046">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#40249" title="(tp: Types.this.Type)Boolean">isRawType</a><span class="delimiter">(</span><a href="#141046" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#116517" title="(tp: Types.this.Type)Types.this.Type">rawToExistential</a><span class="delimiter">(</span><a href="#141046" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <a href="#141046" title="Types.this.Type">tp</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a>

  /*
  todo: change to:
  def normalizePlus(tp: Type) = tp match {
    case TypeRef(pre, sym, List()) =&gt;
      if (!sym.isInitialized) sym.rawInfo.load(sym)
      if (sym.isJavaDefined &amp;&amp; !sym.typeParams.isEmpty) rawToExistential(tp)
      else tp.normalize
    case _ =&gt; tp.normalize
  }
  */
/*
  private def isSameType0(tp1: Type, tp2: Type): Boolean = {
    if (tp1 eq tp2) return true
    ((tp1, tp2) match {
      case (ErrorType, _) =&gt; true
      case (WildcardType, _) =&gt; true
      case (_, ErrorType) =&gt; true
      case (_, WildcardType) =&gt; true

      case (NoType, _) =&gt; false
      case (NoPrefix, _) =&gt; tp2.typeSymbol.isPackageClass
      case (_, NoType) =&gt; false
      case (_, NoPrefix) =&gt; tp1.typeSymbol.isPackageClass

      case (ThisType(sym1), ThisType(sym2))
      if (sym1 == sym2) =&gt;
        true
      case (SingleType(pre1, sym1), SingleType(pre2, sym2))
      if (equalSymsAndPrefixes(sym1, pre1, sym2, pre2)) =&gt;
        true
/*
      case (SingleType(pre1, sym1), ThisType(sym2))
      if (sym1.isModule &amp;&amp;
          sym1.moduleClass == sym2 &amp;&amp;
          pre1 =:= sym2.owner.thisType) =&gt;
        true
      case (ThisType(sym1), SingleType(pre2, sym2))
      if (sym2.isModule &amp;&amp;
          sym2.moduleClass == sym1 &amp;&amp;
          pre2 =:= sym1.owner.thisType) =&gt;
        true
*/
      case (ConstantType(value1), ConstantType(value2)) =&gt;
        value1 == value2
      case (TypeRef(pre1, sym1, args1), TypeRef(pre2, sym2, args2)) =&gt;
        equalSymsAndPrefixes(sym1, pre1, sym2, pre2) &amp;&amp;
        ((tp1.isHigherKinded &amp;&amp; tp2.isHigherKinded &amp;&amp; tp1.normalize =:= tp2.normalize) ||
         isSameTypes(args1, args2))
         // @M! normalize reduces higher-kinded case to PolyType's
      case (RefinedType(parents1, ref1), RefinedType(parents2, ref2)) =&gt;
        def isSubScope(s1: Scope, s2: Scope): Boolean = s2.toList.forall {
          sym2 =&gt;
            var e1 = s1.lookupEntry(sym2.name)
            (e1 ne null) &amp;&amp; {
              val substSym = sym2.info.substThis(sym2.owner, e1.sym.owner.thisType)
              var isEqual = false
              while (!isEqual &amp;&amp; (e1 ne null)) {
                isEqual = e1.sym.info =:= substSym
                e1 = s1.lookupNextEntry(e1)
              }
              isEqual
            }
        }
        //Console.println(&quot;is same? &quot; + tp1 + &quot; &quot; + tp2 + &quot; &quot; + tp1.typeSymbol.owner + &quot; &quot; + tp2.typeSymbol.owner)//DEBUG
        isSameTypes(parents1, parents2) &amp;&amp; isSubScope(ref1, ref2) &amp;&amp; isSubScope(ref2, ref1)
      case (MethodType(params1, res1), MethodType(params2, res2)) =&gt;
        // new dependent types: probably fix this, use substSym as done for PolyType
        (isSameTypes(tp1.paramTypes, tp2.paramTypes) &amp;&amp;
         res1 =:= res2 &amp;&amp;
         tp1.isImplicit == tp2.isImplicit)
      case (PolyType(tparams1, res1), PolyType(tparams2, res2)) =&gt;
        // assert((tparams1 map (_.typeParams.length)) == (tparams2 map (_.typeParams.length)))
        (tparams1.length == tparams2.length) &amp;&amp; (tparams1 corresponds tparams2)(_.info =:= _.info.substSym(tparams2, tparams1)) &amp;&amp; // @M looks like it might suffer from same problem as #2210
          res1 =:= res2.substSym(tparams2, tparams1)
      case (ExistentialType(tparams1, res1), ExistentialType(tparams2, res2)) =&gt;
        (tparams1.length == tparams2.length) &amp;&amp; (tparams1 corresponds tparams2)(_.info =:= _.info.substSym(tparams2, tparams1)) &amp;&amp; // @M looks like it might suffer from same problem as #2210
          res1 =:= res2.substSym(tparams2, tparams1)
      case (TypeBounds(lo1, hi1), TypeBounds(lo2, hi2)) =&gt;
        lo1 =:= lo2 &amp;&amp; hi1 =:= hi2
      case (BoundedWildcardType(bounds), _) =&gt;
        bounds containsType tp2
      case (_, BoundedWildcardType(bounds)) =&gt;
        bounds containsType tp1
      case (tv @ TypeVar(_,_), tp) =&gt;
        tv.registerTypeEquality(tp, true)
      case (tp, tv @ TypeVar(_,_)) =&gt;
        tv.registerTypeEquality(tp, false)
      case (AnnotatedType(_,_,_), _) =&gt;
        annotationsConform(tp1, tp2) &amp;&amp; annotationsConform(tp2, tp1) &amp;&amp; tp1.withoutAnnotations =:= tp2.withoutAnnotations
      case (_, AnnotatedType(_,_,_)) =&gt;
        annotationsConform(tp1, tp2) &amp;&amp; annotationsConform(tp2, tp1) &amp;&amp; tp1.withoutAnnotations =:= tp2.withoutAnnotations
      case (_: SingletonType, _: SingletonType) =&gt;
        var origin1 = tp1
        while (origin1.underlying.isInstanceOf[SingletonType]) {
          assert(origin1 ne origin1.underlying, origin1)
          origin1 = origin1.underlying
        }
        var origin2 = tp2
        while (origin2.underlying.isInstanceOf[SingletonType]) {
          assert(origin2 ne origin2.underlying, origin2)
          origin2 = origin2.underlying
        }
        ((origin1 ne tp1) || (origin2 ne tp2)) &amp;&amp; (origin1 =:= origin2)
      case _ =&gt;
        false
    }) || {
      val tp1n = normalizePlus(tp1)
      val tp2n = normalizePlus(tp2)
      ((tp1n ne tp1) || (tp2n ne tp2)) &amp;&amp; isSameType(tp1n, tp2n)
    }
  }
*/
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="40306">isSameType1</a><span class="delimiter">(</span><a title="Types.this.Type" id="141014">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141015">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141014" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#141015" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
        <span class="delimiter">(</span><a href="#141014" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130719" title="object Types.this.ErrorType">ErrorType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#141014" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130739" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
        <span class="delimiter">(</span><a href="#141015" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130719" title="object Types.this.ErrorType">ErrorType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#141015" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130739" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141014" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#141015" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#141014" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span>
      <a href="#141015" title="Types.this.Type">tp2</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a>
    <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#141015" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span>
      <a href="#141014" title="Types.this.Type">tp1</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <a href="#40307" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType2</a><span class="delimiter">(</span><a href="#141014" title="Types.this.Type">tp1</a>, <a href="#141015" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="141053">tp1n</a> = <a href="#40305" title="(tp: Types.this.Type)Types.this.Type">normalizePlus</a><span class="delimiter">(</span><a href="#141014" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="141054">tp2n</a> = <a href="#40305" title="(tp: Types.this.Type)Types.this.Type">normalizePlus</a><span class="delimiter">(</span><a href="#141015" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141053" title="Types.this.Type">tp1n</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#141014" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#141054" title="Types.this.Type">tp2n</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#141015" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#40302" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a><span class="delimiter">(</span><a href="#141053" title="Types.this.Type">tp1n</a>, <a href="#141054" title="Types.this.Type">tp2n</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="40307">isSameType2</a><span class="delimiter">(</span><a title="Types.this.Type" id="141050">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141051">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <a href="#141050" title="Types.this.Type">tp1</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Unit" id="141055">tr1</a>: <a href="#66707" title="Types.this.TypeRef">TypeRef</a> =&gt;
        <a href="#141051" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Nothing" id="141056">tr2</a>: <a href="#66707" title="Types.this.TypeRef">TypeRef</a> =&gt;
            <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span><a href="#40301" title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean">equalSymsAndPrefixes</a><span class="delimiter">(</span><a href="#141055" title="Types.this.TypeRef">tr1</a>.<a href="#66725" title="=&gt; Types.this.Symbol">sym</a>, <a href="#141055" title="Types.this.TypeRef">tr1</a>.<a href="#66724" title="=&gt; Types.this.Type">pre</a>, <a href="#141056" title="Types.this.TypeRef">tr2</a>.<a href="#66725" title="=&gt; Types.this.Symbol">sym</a>, <a href="#141056" title="Types.this.TypeRef">tr2</a>.<a href="#66724" title="=&gt; Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141050" title="Types.this.Type">tp1</a>.<a href="#42714" title="=&gt; Boolean">isHigherKinded</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141051" title="Types.this.Type">tp2</a>.<a href="#42714" title="=&gt; Boolean">isHigherKinded</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141050" title="Types.this.Type">tp1</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141051" title="Types.this.Type">tp2</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
               <a href="#40308" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span><a href="#141055" title="Types.this.TypeRef">tr1</a>.<a href="#66726" title="=&gt; List[Types.this.Type]">args</a>, <a href="#141056" title="Types.this.TypeRef">tr2</a>.<a href="#66726" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
               <span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#141055" title="Types.this.TypeRef">tr1</a>.<a href="#66724" title="=&gt; Types.this.Type">pre</a>, <a href="#141056" title="Types.this.TypeRef">tr2</a>.<a href="#66724" title="=&gt; Types.this.Type">pre</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
                 <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span><a title="Types.this.TypeVar" id="141070">tv</a> @ <a href="#84241" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#141070" title="Types.this.TypeVar">tv</a>.<a href="#84220" title="(sym: Types.this.Symbol, tp: Types.this.Type)Boolean">registerTypeSelection</a><span class="delimiter">(</span><a href="#141055" title="Types.this.TypeRef">tr1</a>.<a href="#66725" title="=&gt; Types.this.Symbol">sym</a>, <a href="#141056" title="Types.this.TypeRef">tr2</a><span class="delimiter">)</span>
                 <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>_, <a title="Types.this.TypeVar" id="141074">tv</a> @ <a href="#84241" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#141074" title="Types.this.TypeVar">tv</a>.<a href="#84220" title="(sym: Types.this.Symbol, tp: Types.this.Type)Boolean">registerTypeSelection</a><span class="delimiter">(</span><a href="#141056" title="Types.this.TypeRef">tr2</a>.<a href="#66725" title="=&gt; Types.this.Symbol">sym</a>, <a href="#141055" title="Types.this.TypeRef">tr1</a><span class="delimiter">)</span>
                 <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
               <span class="delimiter">}</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="141076">tt1</a>: <a href="#83420" title="Types.this.ThisType">ThisType</a> =&gt;
        <a href="#141051" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Unit" id="141077">tt2</a>: <a href="#83420" title="Types.this.ThisType">ThisType</a> =&gt;
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#141076" title="Types.this.ThisType">tt1</a>.<a href="#83428" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#141077" title="Types.this.ThisType">tt2</a>.<a href="#83428" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="141082">st1</a>: <a href="#83463" title="Types.this.SingleType">SingleType</a> =&gt;
        <a href="#141051" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Unit" id="141083">st2</a>: <a href="#83463" title="Types.this.SingleType">SingleType</a> =&gt;
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#40301" title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean">equalSymsAndPrefixes</a><span class="delimiter">(</span><a href="#141082" title="Types.this.SingleType">st1</a>.<a href="#83478" title="=&gt; Types.this.Symbol">sym</a>, <a href="#141082" title="Types.this.SingleType">st1</a>.<a href="#83477" title="=&gt; Types.this.Type">pre</a>, <a href="#141083" title="Types.this.SingleType">st2</a>.<a href="#83478" title="=&gt; Types.this.Symbol">sym</a>, <a href="#141083" title="Types.this.SingleType">st2</a>.<a href="#83477" title="=&gt; Types.this.Type">pre</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="141084">ct1</a>: <a href="#83618" title="Types.this.ConstantType">ConstantType</a> =&gt;
        <a href="#141051" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Nothing" id="141085">ct2</a>: <a href="#83618" title="Types.this.ConstantType">ConstantType</a> =&gt;
            <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span><a href="#141084" title="Types.this.ConstantType">ct1</a>.<a href="#83626" title="=&gt; Types.this.Constant">value</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#141085" title="Types.this.ConstantType">ct2</a>.<a href="#83626" title="=&gt; Types.this.Constant">value</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="141090">rt1</a>: <a href="#61660" title="Types.this.RefinedType">RefinedType</a> =&gt;
        <a href="#141051" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Nothing" id="141091">rt2</a>: <a href="#61660" title="Types.this.RefinedType">RefinedType</a> =&gt; //
            <span class="keyword">def</span> <a title="(s1: Types.this.Scope, s2: Types.this.Scope)Boolean" id="141092">isSubScope</a><span class="delimiter">(</span><a title="Types.this.Scope" id="141093">s1</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a>, <a title="Types.this.Scope" id="141094">s2</a>: <a href="Scopes.scala.html#40425" title="Types.this.Scope">Scope</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#141094" title="Types.this.Scope">s2</a>.<a href="Scopes.scala.html#61763" title="=&gt; List[Types.this.Symbol]">toList</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">{</span>
              <a title="Types.this.Symbol" id="141103">sym2</a> =&gt;
                <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="141104">e1</a> = <a href="#141093" title="Types.this.Scope">s1</a>.<a href="Scopes.scala.html#61761" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#141103" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
                <span class="delimiter">(</span><a href="#141104" title="Types.this.ScopeEntry">e1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
                  <span class="keyword">val</span> <a title="Types.this.Type" id="141106">substSym</a> = <a href="#141103" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42785" title="(from: Types.this.Symbol, to: Types.this.Symbol)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#141103" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>, <a href="#141104" title="Types.this.ScopeEntry">e1</a>.<a href="Scopes.scala.html#71190" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
                  <span class="keyword">var</span> <a title="Boolean" id="141107">isEqual</a> = <span title="Boolean(false)" class="keyword">false</span>
                  <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#141107" title="Boolean">isEqual</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#141104" title="Types.this.ScopeEntry">e1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#141108" title="()Unit" class="delimiter">{</a>
                    <a href="#141107" title="Boolean">isEqual</a> = <a href="#141104" title="Types.this.ScopeEntry">e1</a>.<a href="Scopes.scala.html#71190" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141106" title="Types.this.Type">substSym</a>
                    <a href="#141104" title="Types.this.ScopeEntry">e1</a> = <a href="#141093" title="Types.this.Scope">s1</a>.<a href="Scopes.scala.html#61762" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a><span class="delimiter">(</span><a href="#141104" title="Types.this.ScopeEntry">e1</a><span class="delimiter">)</span>
                  <span class="delimiter">}</span>
                  <a href="#141107" title="Boolean">isEqual</a>
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            //Console.println(&quot;is same? &quot; + tp1 + &quot; &quot; + tp2 + &quot; &quot; + tp1.typeSymbol.owner + &quot; &quot; + tp2.typeSymbol.owner)//DEBUG
            <span title="Nothing" class="keyword">return</span> <a href="#40308" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span><a href="#141090" title="Types.this.RefinedType">rt1</a>.<a href="#83878" title="=&gt; List[Types.this.Type]">parents</a>, <a href="#141091" title="Types.this.RefinedType">rt2</a>.<a href="#83878" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Scope" id="141118">decls1</a> = <a href="#141090" title="Types.this.RefinedType">rt1</a>.<a href="#83879" title="=&gt; Types.this.Scope">decls</a>
              <span class="keyword">val</span> <a title="Types.this.Scope" id="141119">decls2</a> = <a href="#141091" title="Types.this.RefinedType">rt2</a>.<a href="#83879" title="=&gt; Types.this.Scope">decls</a>
              <a href="#141092" title="(s1: Types.this.Scope, s2: Types.this.Scope)Boolean">isSubScope</a><span class="delimiter">(</span><a href="#141118" title="Types.this.Scope">decls1</a>, <a href="#141119" title="Types.this.Scope">decls2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141092" title="(s1: Types.this.Scope, s2: Types.this.Scope)Boolean">isSubScope</a><span class="delimiter">(</span><a href="#141119" title="Types.this.Scope">decls2</a>, <a href="#141118" title="Types.this.Scope">decls1</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="141120">mt1</a>: <a href="#66899" title="Types.this.MethodType">MethodType</a> =&gt;
        <a href="#141051" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Nothing" id="141121">mt2</a>: <a href="#66899" title="Types.this.MethodType">MethodType</a> =&gt;
            <span title="Nothing" class="keyword">return</span> <a href="#40308" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span><a href="#141120" title="Types.this.MethodType">mt1</a>.<a href="#66914" title="=&gt; List[Types.this.Type]">paramTypes</a>, <a href="#141121" title="Types.this.MethodType">mt2</a>.<a href="#66914" title="=&gt; List[Types.this.Type]">paramTypes</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <a href="#141120" title="Types.this.MethodType">mt1</a>.<a href="#71281" title="=&gt; Types.this.Type">resultType</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141121" title="Types.this.MethodType">mt2</a>.<a href="#71281" title="=&gt; Types.this.Type">resultType</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#141121" title="Types.this.MethodType">mt2</a>.<a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#141120" title="Types.this.MethodType">mt1</a>.<a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <a href="#141120" title="Types.this.MethodType">mt1</a>.<a href="#66910" title="=&gt; Boolean">isImplicit</a> <span title="(x: Boolean)Boolean">==</span> <a href="#141121" title="Types.this.MethodType">mt2</a>.<a href="#66910" title="=&gt; Boolean">isImplicit</a>
          // note: no case NullaryMethodType(restpe) =&gt; return mt1.params.isEmpty &amp;&amp; mt1.resultType =:= restpe
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Unit">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="141132">restpe1</a><span class="delimiter">)</span> =&gt;
        <a href="#141051" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          // note: no case mt2: MethodType =&gt; return mt2.params.isEmpty &amp;&amp; restpe  =:= mt2.resultType
          <span class="keyword">case</span> <span title="Nothing">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="141133">restpe2</a><span class="delimiter">)</span> =&gt;
            <span title="Nothing" class="keyword">return</span> <a href="#141132" title="Types.this.Type">restpe1</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141133" title="Types.this.Type">restpe2</a>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Unit">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141135">tparams1</a>, <a title="Types.this.Type" id="141136">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#141051" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Nothing">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141137">tparams2</a>, <a title="Types.this.Type" id="141138">res2</a><span class="delimiter">)</span> =&gt;
//            assert((tparams1 map (_.typeParams.length)) == (tparams2 map (_.typeParams.length)))
              // @M looks like it might suffer from same problem as #2210
              <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span>
                <span class="delimiter">(</span><a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#141135" title="List[Types.this.Symbol]">tparams1</a>, <a href="#141137" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> // corresponds does not check length of two sequences before checking the predicate
                <span class="delimiter">(</span><a href="#141135" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#141137" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#141163" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141164" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#141137" title="List[Types.this.Symbol]">tparams2</a>, <a href="#141135" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                <a href="#141136" title="Types.this.Type">res1</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141138" title="Types.this.Type">res2</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#141137" title="List[Types.this.Symbol]">tparams2</a>, <a href="#141135" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>
              <span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Unit">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141168">tparams1</a>, <a title="Types.this.Type" id="141169">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#141051" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Nothing">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141170">tparams2</a>, <a title="Types.this.Type" id="141171">res2</a><span class="delimiter">)</span> =&gt;
            // @M looks like it might suffer from same problem as #2210
            <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span>
              // corresponds does not check length of two sequences before checking the predicate -- faster &amp; needed to avoid crasher in #2956
              <a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#141168" title="List[Types.this.Symbol]">tparams1</a>, <a href="#141170" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <span class="delimiter">(</span><a href="#141168" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#141170" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#141196" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141197" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#141170" title="List[Types.this.Symbol]">tparams2</a>, <a href="#141168" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <a href="#141169" title="Types.this.Type">res1</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141171" title="Types.this.Type">res2</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#141170" title="List[Types.this.Symbol]">tparams2</a>, <a href="#141168" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>
            <span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Unit">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="141201">lo1</a>, <a title="Types.this.Type" id="141202">hi1</a><span class="delimiter">)</span> =&gt;
        <a href="#141051" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Nothing">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="141203">lo2</a>, <a title="Types.this.Type" id="141204">hi2</a><span class="delimiter">)</span> =&gt;
            <span title="Nothing" class="keyword">return</span> <a href="#141201" title="Types.this.Type">lo1</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141203" title="Types.this.Type">lo2</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141202" title="Types.this.Type">hi1</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141204" title="Types.this.Type">hi2</a>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Nothing">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="141207">bounds</a><span class="delimiter">)</span> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="#141207" title="Types.this.TypeBounds">bounds</a> <a href="#66859" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#141051" title="Types.this.Type">tp2</a>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#141051" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Nothing">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="141208">bounds</a><span class="delimiter">)</span> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="#141208" title="Types.this.TypeBounds">bounds</a> <a href="#66859" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#141050" title="Types.this.Type">tp1</a>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#141050" title="Types.this.Type">tp1</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Nothing" id="141209">tv</a> @ <a href="#84241" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="#141209" title="Types.this.TypeVar">tv</a>.<a href="#84219" title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean">registerTypeEquality</a><span class="delimiter">(</span><a href="#141051" title="Types.this.Type">tp2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#141051" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Nothing" id="141211">tv</a> @ <a href="#84241" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="#141211" title="Types.this.TypeVar">tv</a>.<a href="#84219" title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean">registerTypeEquality</a><span class="delimiter">(</span><a href="#141050" title="Types.this.Type">tp1</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#141050" title="Types.this.Type">tp1</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Nothing">_</span>: <a href="#59504" title="Types.this.AnnotatedType">AnnotatedType</a> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="AnnotationCheckers.scala.html#36289" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#141050" title="Types.this.Type">tp1</a>, <a href="#141051" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#36289" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#141051" title="Types.this.Type">tp2</a>, <a href="#141050" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141050" title="Types.this.Type">tp1</a>.<a href="#42822" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141051" title="Types.this.Type">tp2</a>.<a href="#42822" title="=&gt; Types.this.Type">withoutAnnotations</a>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#141051" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Nothing">_</span>: <a href="#59504" title="Types.this.AnnotatedType">AnnotatedType</a> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="AnnotationCheckers.scala.html#36289" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#141050" title="Types.this.Type">tp1</a>, <a href="#141051" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#36289" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#141051" title="Types.this.Type">tp2</a>, <a href="#141050" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141050" title="Types.this.Type">tp1</a>.<a href="#42822" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141051" title="Types.this.Type">tp2</a>.<a href="#42822" title="=&gt; Types.this.Type">withoutAnnotations</a>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#141050" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="#40089" title="Types.this.SingletonType">SingletonType</a> =&gt;
        <a href="#141051" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="#40089" title="Types.this.SingletonType">SingletonType</a> =&gt;
            @inline <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="141219">chaseDealiasedUnderlying</a><span class="delimiter">(</span><a title="Types.this.Type" id="141222">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
              <span class="keyword">var</span> <a title="Types.this.Type" id="141223">origin</a> = <a href="#141222" title="Types.this.Type">tp</a>
              <span class="keyword">var</span> <a title="Types.this.Type" id="141224">next</a> = <a href="#141223" title="Types.this.Type">origin</a>.<a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42759" title="=&gt; Types.this.Type">dealias</a>
              <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#141224" title="Types.this.Type">next</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#40089" title="Types.this.SingletonType">SingletonType</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#141225" title="()Unit" class="delimiter">{</a>
                <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#141223" title="Types.this.Type">origin</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#141224" title="Types.this.Type">next</a>, <a href="#141223" title="Types.this.Type">origin</a><span class="delimiter">)</span>
                <a href="#141223" title="Types.this.Type">origin</a> = <a href="#141224" title="Types.this.Type">next</a>
                <a href="#141224" title="Types.this.Type">next</a> = <a href="#141223" title="Types.this.Type">origin</a>.<a href="#42731" title="=&gt; Types.this.Type">underlying</a>.<a href="#42759" title="=&gt; Types.this.Type">dealias</a>
              <span class="delimiter">}</span>
              <a href="#141223" title="Types.this.Type">origin</a>
            <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="141220">origin1</a> = <a href="#141219" title="(tp: Types.this.Type)Types.this.Type">chaseDealiasedUnderlying</a><span class="delimiter">(</span><a href="#141050" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="141221">origin2</a> = <a href="#141219" title="(tp: Types.this.Type)Types.this.Type">chaseDealiasedUnderlying</a><span class="delimiter">(</span><a href="#141051" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
            <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141220" title="Types.this.Type">origin1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#141050" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#141221" title="Types.this.Type">origin2</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#141051" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#141220" title="Types.this.Type">origin1</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141221" title="Types.this.Type">origin2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
        <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Are `tps1` and `tps2` lists of pairwise equivalent types? */
  <span class="keyword">def</span> <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean" id="40308">isSameTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="141059">tps1</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="141060">tps2</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#141059" title="List[Types.this.Type]">tps1</a> <span title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.Type, Types.this.Type) =&gt; Boolean)Boolean">corresponds</span> <a href="#141060" title="List[Types.this.Type]">tps2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#141251" title="Types.this.Type">_</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141252" title="Types.this.Type">_</a><span class="delimiter">)</span>

  /** True if two lists have the same length.  Since calling length on linear sequences
   *  is O(n), it is an inadvisable way to test length equality.
   */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(xs1: List[_], xs2: List[_])Boolean" id="40309">sameLength</a><span class="delimiter">(</span><a title="List[_]" id="87968">xs1</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="List[_]" id="87969">xs2</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#40310" title="(xs1: List[_], xs2: List[_])Int">compareLengths</a><span class="delimiter">(</span><a href="#87968" title="List[_]">xs1</a>, <a href="#87969" title="List[_]">xs2</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span>
  @tailrec <span class="keyword">final</span> <span class="keyword">def</span> <a title="(xs1: List[_], xs2: List[_])Int" id="40310">compareLengths</a><span class="delimiter">(</span><a title="List[_]" id="87972">xs1</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="List[_]" id="87973">xs2</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> =
    <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#87972" title="List[_]">xs1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#87973" title="List[_]">xs2</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> <span class="keyword">else</span> -<span title="Int(-1)" class="int">1</span> <span class="delimiter">}</span>
    <span class="keyword">else</span> <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#87973" title="List[_]">xs2</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="Int(1)" class="int">1</span>
    <span class="keyword">else</span> <a href="#40310" title="(xs1: List[_], xs2: List[_])Int">compareLengths</a><span class="delimiter">(</span><a href="#87972" title="List[_]">xs1</a>.<span title="=&gt; List[_$3]">tail</span>, <a href="#87973" title="List[_]">xs2</a>.<span title="=&gt; List[_$4]">tail</span><span class="delimiter">)</span>

  /** Again avoiding calling length, but the lengthCompare interface is clunky.
   */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(xs: List[_], len: Int)Boolean" id="40311">hasLength</a><span class="delimiter">(</span><a title="List[_]" id="133539">xs</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Int" id="133540">len</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#133539" title="List[_]">xs</a>.<span title="(len: Int)Int">lengthCompare</span><span class="delimiter">(</span><a href="#133540" title="Int">len</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.SubTypePair]" id="40312">pendingSubTypes</a> = <span title="()scala.collection.mutable.HashSet[Types.this.SubTypePair]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Types.this.SubTypePair]">HashSet</span><span class="delimiter">[</span>SubTypePair<span class="delimiter">]</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="40315">basetypeRecursions</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.Type]" id="40317">pendingBaseTypes</a> = <span title="()scala.collection.mutable.HashSet[Types.this.Type]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Types.this.Type]">HashSet</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="40319">isSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="74823">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="74824">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#40320" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#74823" title="Types.this.Type">tp1</a>, <a href="#74824" title="Types.this.Type">tp2</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean" id="40320">isSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="74816">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="74817">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Int" id="74818">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="#40297" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>

    <a href="#40074" title="object Types.this.undoLog">undoLog</a> <a href="#128922" title="(block: =&gt; Boolean)Boolean">undoUnless</a> <span class="delimiter">{</span> // if subtype test fails, it should not affect constraints on typevars
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#40297" title="=&gt; Int">subsametypeRecursions</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(50)">LogPendingSubTypesThreshold</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.SubTypePair" id="141279">p</a> = <span title="Types.this.SubTypePair" class="keyword">new</span> <a href="#40290" title="Types.this.SubTypePair">SubTypePair</a><span class="delimiter">(</span><a href="#74816" title="Types.this.Type">tp1</a>, <a href="#74817" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#40312" title="(elem: Types.this.SubTypePair)Boolean">pendingSubTypes</a><span class="delimiter">(</span><a href="#141279" title="Types.this.SubTypePair">p</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">else</span>
          <span class="keyword">try</span> <span class="delimiter">{</span>
            <a href="#40312" title="=&gt; scala.collection.mutable.HashSet[Types.this.SubTypePair]">pendingSubTypes</a> <span title="(elem: Types.this.SubTypePair)Types.this.pendingSubTypes.type">+=</span> <a href="#141279" title="Types.this.SubTypePair">p</a>
            <a href="#40330" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType2</a><span class="delimiter">(</span><a href="#74816" title="Types.this.Type">tp1</a>, <a href="#74817" title="Types.this.Type">tp2</a>, <a href="#74818" title="Int">depth</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            <a href="#40312" title="=&gt; scala.collection.mutable.HashSet[Types.this.SubTypePair]">pendingSubTypes</a> <span title="(elem: Types.this.SubTypePair)Types.this.pendingSubTypes.type">-=</span> <a href="#141279" title="Types.this.SubTypePair">p</a>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#40330" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType2</a><span class="delimiter">(</span><a href="#74816" title="Types.this.Type">tp1</a>, <a href="#74817" title="Types.this.Type">tp2</a>, <a href="#74818" title="Int">depth</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#40297" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
    // XXX AM TODO: figure out when it is safe and needed to clear the log -- the commented approach below is too eager (it breaks #3281, #3866)
    // it doesn't help to keep separate recursion counts for the three methods that now share it
    // if (subsametypeRecursions == 0) undoLog.clear()
  <span class="delimiter">}</span>

  /** Does this type have a prefix that begins with a type variable,
   *  or is it a refinement type? For type prefixes that fulfil this condition,
   *  type selections with the same name of equal (wrt) =:= prefixes are
   *  considered equal wrt =:=
   */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="40321">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a title="Types.this.Type" id="140976">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#140976" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="141324">pre</a>, <a title="Types.this.Symbol" id="141325">sym</a><span class="delimiter">)</span> =&gt;
      <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#141325" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#47905" title="(mask: Long)Boolean">hasFlag</a> <span title="Long(16384L)">PACKAGE</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#40321" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#141324" title="Types.this.Type">pre</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="Boolean" id="141326">tv</a>@<a href="#84241" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="141328">constr</a><span class="delimiter">)</span> =&gt;
      <span title="=&gt; Boolean">!</span><a href="#141326" title="Types.this.TypeVar">tv</a>.<a href="#84204" title="=&gt; Boolean">instValid</a> <span title="(x: Boolean)Boolean">||</span> <a href="#40321" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#141328" title="Types.this.TypeConstraint">constr</a>.<a href="#84302" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Boolean(true)">RefinedType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
      <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
      <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="40322">instTypeVar</a><span class="delimiter">(</span><a title="Types.this.Type" id="141329">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#141329" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="141331">pre</a>, <a title="Types.this.Symbol" id="141332">sym</a>, <a title="List[Types.this.Type]" id="141333">args</a><span class="delimiter">)</span> =&gt;
      <a href="#40199" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#141329" title="Types.this.Type">tp</a>, <a href="#40322" title="(tp: Types.this.Type)Types.this.Type">instTypeVar</a><span class="delimiter">(</span><a href="#141331" title="Types.this.Type">pre</a><span class="delimiter">)</span>, <a href="#141332" title="Types.this.Symbol">sym</a>, <a href="#141333" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="141334">pre</a>, <a title="Types.this.Symbol" id="141335">sym</a><span class="delimiter">)</span> =&gt;
      <a href="#40194" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#40322" title="(tp: Types.this.Type)Types.this.Type">instTypeVar</a><span class="delimiter">(</span><a href="#141334" title="Types.this.Type">pre</a><span class="delimiter">)</span>, <a href="#141335" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a href="#84241" title="Types.this.Type">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="141337">constr</a><span class="delimiter">)</span> =&gt;
      <a href="#40322" title="(tp: Types.this.Type)Types.this.Type">instTypeVar</a><span class="delimiter">(</span><a href="#141337" title="Types.this.TypeConstraint">constr</a>.<a href="#84302" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <a href="#141329" title="Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="40323">isErrorOrWildcard</a><span class="delimiter">(</span><a title="Types.this.Type" id="141338">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#141338" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130719" title="object Types.this.ErrorType">ErrorType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#141338" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130739" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="40324">isSingleType</a><span class="delimiter">(</span><a title="Types.this.Type" id="141341">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#141341" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean(true)">ThisType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> | SuperType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> | SingleType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="40325">isConstantType</a><span class="delimiter">(</span><a title="Types.this.Type" id="113920">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#113920" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean(true)">ConstantType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>

  // @assume tp1.isHigherKinded || tp2.isHigherKinded
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean" id="40326">isHKSubType0</a><span class="delimiter">(</span><a title="Types.this.Type" id="141344">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141345">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Int" id="141346">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span>
    <a href="#141344" title="Types.this.Type">tp1</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a>
    <span title="(x: Boolean)Boolean">||</span>
    <a href="#141345" title="Types.this.Type">tp2</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a> // @M Any and Nothing are super-type resp. subtype of every well-kinded type
    <span title="(x: Boolean)Boolean">||</span> // @M! normalize reduces higher-kinded case to PolyType's
    <span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#141344" title="Types.this.Type">tp1</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a>.<a href="#42822" title="=&gt; Types.this.Type">withoutAnnotations</a> , <a href="#141345" title="Types.this.Type">tp2</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a>.<a href="#42822" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141368">tparams1</a>, <a title="Types.this.Type" id="141369">res1</a><span class="delimiter">)</span>, PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141370">tparams2</a>, <a title="Types.this.Type" id="141371">res2</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; // @assume tp1.isHigherKinded &amp;&amp; tp2.isHigherKinded (as they were both normalized to PolyType)
        <a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#141368" title="List[Types.this.Symbol]">tparams1</a>, <a href="#141370" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#141368" title="List[Types.this.Symbol]">tparams1</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#47773" title="=&gt; Boolean">isMethod</a><span class="delimiter">)</span> <span class="delimiter">{</span>  // fast-path: polymorphic method type -- type params cannot be captured
            <span class="delimiter">(</span><a href="#141368" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#141370" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="141397">p1</a>, <a title="Types.this.Symbol" id="141398">p2</a><span class="delimiter">)</span> =&gt; <a href="#141398" title="Types.this.Symbol">p2</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#141370" title="List[Types.this.Symbol]">tparams2</a>, <a href="#141368" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141397" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#141369" title="Types.this.Type">res1</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141371" title="Types.this.Type">res2</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#141370" title="List[Types.this.Symbol]">tparams2</a>, <a href="#141368" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span> // normalized higher-kinded type
            //@M for an example of why we need to generate fresh symbols, see neg/tcpoly_ticket2101.scala
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="141402">tpsFresh</a> = <a href="Symbols.scala.html#40018" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#141368" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>

            <span class="delimiter">(</span><a href="#141368" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#141370" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="141422">p1</a>, <a title="Types.this.Symbol" id="141423">p2</a><span class="delimiter">)</span> =&gt;
              <a href="#141423" title="Types.this.Symbol">p2</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#141370" title="List[Types.this.Symbol]">tparams2</a>, <a href="#141402" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141422" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#141368" title="List[Types.this.Symbol]">tparams1</a>, <a href="#141402" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#141369" title="Types.this.Type">res1</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#141368" title="List[Types.this.Symbol]">tparams1</a>, <a href="#141402" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141371" title="Types.this.Type">res2</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#141370" title="List[Types.this.Symbol]">tparams2</a>, <a href="#141402" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span>

            //@M the forall in the previous test could be optimised to the following,
            // but not worth the extra complexity since it only shaves 1s from quick.comp
            //   (List.forall2(tpsFresh/*optimisation*/, tparams2)((p1, p2) =&gt;
            //   p2.info.substSym(tparams2, tpsFresh) &lt;:&lt; p1.info /*optimisation, == (p1 from tparams1).info.substSym(tparams1, tpsFresh)*/) &amp;&amp;
            // this optimisation holds because inlining cloneSymbols in `val tpsFresh = cloneSymbols(tparams1)` gives:
            // val tpsFresh = tparams1 map (_.cloneSymbol)
            // for (tpFresh &lt;- tpsFresh) tpFresh.setInfo(tpFresh.info.substSym(tparams1, tpsFresh))
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#36289" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#141344" title="Types.this.Type">tp1</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a>, <a href="#141345" title="Types.this.Type">tp2</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean(false)" class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <span title="Boolean(false)" class="keyword">false</span> // @assume !tp1.isHigherKinded || !tp2.isHigherKinded
      // --&gt; thus, cannot be subtypes (Any/Nothing has already been checked)
    <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(t1: Types.this.Type, t2: Types.this.Type, variance: Int)Boolean" id="40327">isSubArg</a><span class="delimiter">(</span><a title="Types.this.Type" id="141430">t1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141431">t2</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Int" id="141432">variance</a>: <span title="Int">Int</span><span class="delimiter">)</span> =
    <span class="delimiter">(</span><a href="#141432" title="Int">variance</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#141431" title="Types.this.Type">t2</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141430" title="Types.this.Type">t1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#141432" title="Int">variance</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#141430" title="Types.this.Type">t1</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141431" title="Types.this.Type">t2</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean" id="40328">isSubArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="136179">tps1</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="136180">tps2</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="136181">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="util/Collections.scala.html#39554" title="(xs1: List[Types.this.Type], xs2: List[Types.this.Type], xs3: List[Int])(f: (Types.this.Type, Types.this.Type, Int) =&gt; Boolean)Boolean">corresponds3</a><span class="delimiter">(</span><a href="#136179" title="List[Types.this.Type]">tps1</a>, <a href="#136180" title="List[Types.this.Type]">tps2</a>, <a href="#136181" title="List[Types.this.Symbol]">tparams</a> <span title="(f: Types.this.Symbol =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Int,List[Int]])List[Int]">map</span> <span class="delimiter">(</span><a href="#141478" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47874" title="=&gt; Int">variance</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#40327" title="(t1: Types.this.Type, t2: Types.this.Type, variance: Int)Boolean">isSubArg</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Types.this.Type" id="40329">differentOrNone</a><span class="delimiter">(</span><a title="Types.this.Type" id="141561">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141562">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#141561" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#141562" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <a href="#130794" title="object Types.this.NoType">NoType</a> <span class="keyword">else</span> <a href="#141561" title="Types.this.Type">tp1</a>

  /** Does type `tp1` conform to `tp2`? */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean" id="40330">isSubType2</a><span class="delimiter">(</span><a title="Types.this.Type" id="141308">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141309">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Int" id="141310">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#141309" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#40323" title="(tp: Types.this.Type)Boolean">isErrorOrWildcard</a><span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#40323" title="(tp: Types.this.Type)Boolean">isErrorOrWildcard</a><span class="delimiter">(</span><a href="#141309" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(true)" class="keyword">true</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#141309" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(false)" class="keyword">false</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span><a href="#141309" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#141309" title="Types.this.Type">tp2</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#141309" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130818" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#141308" title="Types.this.Type">tp1</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47787" title="=&gt; Boolean">isPackageClass</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#40324" title="(tp: Types.this.Type)Boolean">isSingleType</a><span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#40324" title="(tp: Types.this.Type)Boolean">isSingleType</a><span class="delimiter">(</span><a href="#141309" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#40325" title="(tp: Types.this.Type)Boolean">isConstantType</a><span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#40325" title="(tp: Types.this.Type)Boolean">isConstantType</a><span class="delimiter">(</span><a href="#141309" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#141308" title="Types.this.Type">tp1</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141309" title="Types.this.Type">tp2</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a>.<a href="#42714" title="=&gt; Boolean">isHigherKinded</a> <span title="(x: Boolean)Boolean">||</span> <a href="#141309" title="Types.this.Type">tp2</a>.<a href="#42714" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#40326" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isHKSubType0</a><span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a>, <a href="#141309" title="Types.this.Type">tp2</a>, <a href="#141310" title="Int">depth</a><span class="delimiter">)</span>

    /** First try, on the right:
     *   - unwrap Annotated types, BoundedWildcardTypes,
     *   - bind TypeVars  on the right, if lhs is not Annotated nor BoundedWildcard
     *   - handle common cases for first-kind TypeRefs on both sides as a fast path.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="141565">firstTry</a> = <a href="#141309" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      // fast path: two typerefs, none of them HK
      <span class="keyword">case</span> <a title="Boolean" id="141571">tr2</a>: <a href="#66707" title="Types.this.TypeRef">TypeRef</a> =&gt;
        <a href="#141308" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="141572">tr1</a>: <a href="#66707" title="Types.this.TypeRef">TypeRef</a> =&gt;
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="141573">sym1</a> = <a href="#141572" title="Types.this.TypeRef">tr1</a>.<a href="#66725" title="=&gt; Types.this.Symbol">sym</a>
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="141574">sym2</a> = <a href="#141571" title="Types.this.TypeRef">tr2</a>.<a href="#66725" title="=&gt; Types.this.Symbol">sym</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="141575">pre1</a> = <a href="#141572" title="Types.this.TypeRef">tr1</a>.<a href="#66724" title="=&gt; Types.this.Type">pre</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="141576">pre2</a> = <a href="#141571" title="Types.this.TypeRef">tr2</a>.<a href="#66724" title="=&gt; Types.this.Type">pre</a>
            <span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#141573" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#141574" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> <a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#141575" title="Types.this.Type">pre1</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141576" title="Types.this.Type">pre2</a>
               <span class="keyword">else</span> <span class="delimiter">(</span><a href="#141573" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#141574" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#141573" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47775" title="=&gt; Boolean">isModuleClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#141574" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47775" title="=&gt; Boolean">isModuleClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                     <span class="delimiter">(</span><a href="#40299" title="(pre1: Types.this.Type, pre2: Types.this.Type)Boolean">isUnifiable</a><span class="delimiter">(</span><a href="#141575" title="Types.this.Type">pre1</a>, <a href="#141576" title="Types.this.Type">pre2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#40300" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol, pre1: Types.this.Type, pre2: Types.this.Type)Boolean">isSameSpecializedSkolem</a><span class="delimiter">(</span><a href="#141573" title="Types.this.Symbol">sym1</a>, <a href="#141574" title="Types.this.Symbol">sym2</a>, <a href="#141575" title="Types.this.Type">pre1</a>, <a href="#141576" title="Types.this.Type">pre2</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                    <a href="#40328" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean">isSubArgs</a><span class="delimiter">(</span><a href="#141572" title="Types.this.TypeRef">tr1</a>.<a href="#66726" title="=&gt; List[Types.this.Type]">args</a>, <a href="#141571" title="Types.this.TypeRef">tr2</a>.<a href="#66726" title="=&gt; List[Types.this.Type]">args</a>, <a href="#141573" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span><span class="delimiter">)</span>
             <span title="(x: Boolean)Boolean">||</span>
             <a href="#141574" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47757" title="=&gt; Boolean">isClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
               <span class="keyword">val</span> <a title="Types.this.Type" id="141587">base</a> = <a href="#141572" title="Types.this.TypeRef">tr1</a> <a href="#42777" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a> <a href="#141574" title="Types.this.Symbol">sym2</a>
               <span class="delimiter">(</span><a href="#141587" title="Types.this.Type">base</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#141572" title="Types.this.TypeRef">tr1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141587" title="Types.this.Type">base</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141571" title="Types.this.TypeRef">tr2</a>
             <span class="delimiter">}</span>
             <span title="(x: Boolean)Boolean">||</span>
             <a href="#141567" title="(tp1: Types.this.Type, tp2: Types.this.TypeRef)Boolean">thirdTryRef</a><span class="delimiter">(</span><a href="#141572" title="Types.this.TypeRef">tr1</a>, <a href="#141571" title="Types.this.TypeRef">tr2</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#141566" title="=&gt; Boolean">secondTry</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">AnnotatedType</span><span class="delimiter">(</span>_, _, _<span class="delimiter">)</span> =&gt;
        <a href="#141308" title="Types.this.Type">tp1</a>.<a href="#42822" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141309" title="Types.this.Type">tp2</a>.<a href="#42822" title="=&gt; Types.this.Type">withoutAnnotations</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#36289" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a>, <a href="#141309" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="141707">bounds</a><span class="delimiter">)</span> =&gt;
        <a href="#141308" title="Types.this.Type">tp1</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141707" title="Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a>
      <span class="keyword">case</span> <a title="Boolean" id="141709">tv2</a> @ <a href="#84241" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="141711">constr2</a><span class="delimiter">)</span> =&gt;
        <a href="#141308" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">AnnotatedType</span><span class="delimiter">(</span>_, _, _<span class="delimiter">)</span> | BoundedWildcardType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
            <a href="#141566" title="=&gt; Boolean">secondTry</a>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#141709" title="Types.this.TypeVar">tv2</a>.<a href="#84218" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#141566" title="=&gt; Boolean">secondTry</a>
    <span class="delimiter">}</span>

    /** Second try, on the left:
     *   - unwrap AnnotatedTypes, BoundedWildcardTypes,
     *   - bind typevars,
     *   - handle existential types by skolemization.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="141566">secondTry</a> = <a href="#141308" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">AnnotatedType</span><span class="delimiter">(</span>_, _, _<span class="delimiter">)</span> =&gt;
        <a href="#141308" title="Types.this.Type">tp1</a>.<a href="#42822" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141309" title="Types.this.Type">tp2</a>.<a href="#42822" title="=&gt; Types.this.Type">withoutAnnotations</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#36289" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a>, <a href="#141309" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="141594">bounds</a><span class="delimiter">)</span> =&gt;
        <a href="#141308" title="Types.this.Type">tp1</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66878" title="=&gt; Types.this.Type">lo</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141309" title="Types.this.Type">tp2</a>
      <span class="keyword">case</span> <a title="Boolean" id="141597">tv</a> @ <a href="#84241" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt;
        <a href="#141597" title="Types.this.TypeVar">tv</a>.<a href="#84218" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#141309" title="Types.this.Type">tp2</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
        <span class="keyword">try</span> <span class="delimiter">{</span>
          <a href="#40072" title="(x$1: Int)Unit">skolemizationLevel</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
          <a href="#141308" title="Types.this.Type">tp1</a>.<a href="#42757" title="=&gt; Types.this.Type">skolemizeExistential</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141309" title="Types.this.Type">tp2</a>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
          <a href="#40072" title="(x$1: Int)Unit">skolemizationLevel</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#141568" title="=&gt; Boolean">thirdTry</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.TypeRef)Boolean" id="141567">thirdTryRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="141590">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.TypeRef" id="141591">tp2</a>: <a href="#66707" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="141712">sym2</a> = <a href="#141591" title="Types.this.TypeRef">tp2</a>.<a href="#66725" title="=&gt; Types.this.Symbol">sym</a>
      <a href="#141712" title="Types.this.Symbol">sym2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="Definitions.scala.html#46364" title="Boolean">NotNullClass</a> =&gt; <a href="#141590" title="Types.this.Type">tp1</a>.<a href="#42717" title="=&gt; Boolean">isNotNull</a>
        <span class="keyword">case</span> <a href="Definitions.scala.html#46375" title="Boolean">SingletonClass</a> =&gt; <a href="#141590" title="Types.this.Type">tp1</a>.<a href="#42715" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">||</span> <a href="#141569" title="=&gt; Boolean">fourthTry</a>
        <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="Symbols.scala.html#40010" title="Types.this.ClassSymbol">ClassSymbol</a> =&gt;
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#40248" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><span class="delimiter">(</span><a href="#141712" title="Types.this.Symbol">sym2</a>, <a href="#141591" title="Types.this.TypeRef">tp2</a>.<a href="#66726" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#40320" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#141590" title="Types.this.Type">tp1</a>, <a href="#116517" title="(tp: Types.this.Type)Types.this.Type">rawToExistential</a><span class="delimiter">(</span><a href="#141591" title="Types.this.TypeRef">tp2</a><span class="delimiter">)</span>, <a href="#141310" title="Int">depth</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#141712" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#40550" title="object Types.this.tpnme">tpnme</a>.<a href="StdNames.scala.html#67976" title="=&gt; Types.this.tpnme.NameType">REFINE_CLASS_NAME</a><span class="delimiter">)</span>
            <a href="#40320" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#141590" title="Types.this.Type">tp1</a>, <a href="#141712" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>, <a href="#141310" title="Int">depth</a><span class="delimiter">)</span>
          <span class="keyword">else</span>
            <a href="#141569" title="=&gt; Boolean">fourthTry</a>
        <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="Symbols.scala.html#40008" title="Types.this.TypeSymbol">TypeSymbol</a> =&gt;
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#141712" title="Types.this.Symbol">sym2</a> <a href="Symbols.scala.html#47905" title="(mask: Long)Boolean">hasFlag</a> <span title="Long(16L)">DEFERRED</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="141726">tp2a</a> = <a href="#141591" title="Types.this.TypeRef">tp2</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66878" title="=&gt; Types.this.Type">lo</a>
            <a href="#40304" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isDifferentTypeConstructor</a><span class="delimiter">(</span><a href="#141591" title="Types.this.TypeRef">tp2</a>, <a href="#141726" title="Types.this.Type">tp2a</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141590" title="Types.this.Type">tp1</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141726" title="Types.this.Type">tp2a</a> <span title="(x: Boolean)Boolean">||</span> <a href="#141569" title="=&gt; Boolean">fourthTry</a>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <a href="#40320" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#141590" title="Types.this.Type">tp1</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a>, <a href="#141591" title="Types.this.TypeRef">tp2</a>.<a href="#66673" title="=&gt; Types.this.Type">normalize</a>, <a href="#141310" title="Int">depth</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
          <a href="#141569" title="=&gt; Boolean">fourthTry</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** Third try, on the right:
     *   - decompose refined types.
     *   - handle typerefs, existentials, and notnull types.
     *   - handle left+right method types, polytypes, typebounds
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="141568">thirdTry</a> = <a href="#141309" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="141611">tr2</a>: <a href="#66707" title="Types.this.TypeRef">TypeRef</a> =&gt;
        <a href="#141567" title="(tp1: Types.this.Type, tp2: Types.this.TypeRef)Boolean">thirdTryRef</a><span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a>, <a href="#141611" title="Types.this.TypeRef">tr2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Boolean" id="141612">rt2</a>: <a href="#61660" title="Types.this.RefinedType">RefinedType</a> =&gt;
        <span class="delimiter">(</span><a href="#141612" title="Types.this.RefinedType">rt2</a>.<a href="#83878" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141619" title="Types.this.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <span class="delimiter">(</span><a href="#141612" title="Types.this.RefinedType">rt2</a>.<a href="#83879" title="=&gt; Types.this.Scope">decls</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <a href="#141308" title="Types.this.Type">tp1</a>.<a href="#42800" title="(sym: Types.this.Symbol)Boolean">specializes</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Boolean" id="141627">et2</a>: <a href="#67120" title="Types.this.ExistentialType">ExistentialType</a> =&gt;
        <a href="#141627" title="Types.this.ExistentialType">et2</a>.<a href="#67149" title="(op: Types.this.Type =&gt; Boolean, depth: Int)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141631" title="Types.this.Type">_</a>, <a href="#141310" title="Int">depth</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#141569" title="=&gt; Boolean">fourthTry</a>
      <span class="keyword">case</span> <a title="Boolean" id="141669">nn2</a>: <a href="#146963" title="Types.this.NotNullType">NotNullType</a> =&gt;
        <a href="#141308" title="Types.this.Type">tp1</a>.<a href="#42717" title="=&gt; Boolean">isNotNull</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141308" title="Types.this.Type">tp1</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141669" title="Types.this.NotNullType">nn2</a>.<a href="#84452" title="=&gt; Types.this.Type">underlying</a>
      <span class="keyword">case</span> <a title="Boolean" id="141671">mt2</a>: <a href="#66899" title="Types.this.MethodType">MethodType</a> =&gt;
        <a href="#141308" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="141672">mt1</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141673">params1</a>, <a title="Types.this.Type" id="141674">res1</a><span class="delimiter">)</span> =&gt;
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="141675">params2</a> = <a href="#141671" title="Types.this.MethodType">mt2</a>.<a href="#71280" title="=&gt; List[Types.this.Symbol]">params</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="141676">res2</a> = <a href="#141671" title="Types.this.MethodType">mt2</a>.<a href="#71281" title="=&gt; Types.this.Type">resultType</a>
            <span class="delimiter">(</span><a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#141673" title="List[Types.this.Symbol]">params1</a>, <a href="#141675" title="List[Types.this.Symbol]">params2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
             <a href="#40335" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span><a href="#141673" title="List[Types.this.Symbol]">params1</a>, <a href="#141675" title="List[Types.this.Symbol]">params2</a>, <a href="#141672" title="Types.this.MethodType">mt1</a>.<a href="#66911" title="=&gt; Boolean">isJava</a>, <a href="#141671" title="Types.this.MethodType">mt2</a>.<a href="#66911" title="=&gt; Boolean">isJava</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
             <span class="delimiter">(</span><a href="#141674" title="Types.this.Type">res1</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141676" title="Types.this.Type">res2</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#141675" title="List[Types.this.Symbol]">params2</a>, <a href="#141673" title="List[Types.this.Symbol]">params1</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
             <a href="#141672" title="Types.this.MethodType">mt1</a>.<a href="#66910" title="=&gt; Boolean">isImplicit</a> <span title="(x: Boolean)Boolean">==</span> <a href="#141671" title="Types.this.MethodType">mt2</a>.<a href="#66910" title="=&gt; Boolean">isImplicit</a><span class="delimiter">)</span>
          // TODO: if mt1.params.isEmpty, consider NullaryMethodType?
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Boolean" id="141692">pt2</a> @ NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
        <a href="#141308" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          // TODO: consider MethodType mt for which mt.params.isEmpty??
          <span class="keyword">case</span> <a title="Boolean" id="141693">pt1</a> @ NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
            <a href="#141693" title="Types.this.NullaryMethodType">pt1</a>.<a href="#72680" title="=&gt; Types.this.Type">resultType</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141692" title="Types.this.NullaryMethodType">pt2</a>.<a href="#72680" title="=&gt; Types.this.Type">resultType</a>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="141699">lo2</a>, <a title="Types.this.Type" id="141700">hi2</a><span class="delimiter">)</span> =&gt;
        <a href="#141308" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="141701">lo1</a>, <a title="Types.this.Type" id="141702">hi1</a><span class="delimiter">)</span> =&gt;
            <a href="#141699" title="Types.this.Type">lo2</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141701" title="Types.this.Type">lo1</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141702" title="Types.this.Type">hi1</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141700" title="Types.this.Type">hi2</a>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#141569" title="=&gt; Boolean">fourthTry</a>
    <span class="delimiter">}</span>

    /** Fourth try, on the left:
     *   - handle typerefs, refined types, notnull and singleton types.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="141569">fourthTry</a> = <a href="#141308" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="141632">tr1</a> @ TypeRef<span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="141633">sym1</a>, _<span class="delimiter">)</span> =&gt;
        <a href="#141633" title="Types.this.Symbol">sym1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="Definitions.scala.html#46289" title="Boolean(true)">NothingClass</a> =&gt; <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <a href="Definitions.scala.html#46291" title="Boolean">NullClass</a> =&gt;
            <a href="#141309" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="141634">sym2</a>, _<span class="delimiter">)</span> =&gt;
                <a href="#141634" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47757" title="=&gt; Boolean">isClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#141634" title="Types.this.Symbol">sym2</a> <a href="Symbols.scala.html#47963" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="Definitions.scala.html#46278" title="=&gt; Types.this.Symbol">ObjectClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#141309" title="Types.this.Type">tp2</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#47963" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="Definitions.scala.html#46364" title="=&gt; Types.this.Symbol">NotNullClass</a><span class="delimiter">)</span>
              <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
                <a href="#40324" title="(tp: Types.this.Type)Boolean">isSingleType</a><span class="delimiter">(</span><a href="#141309" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141308" title="Types.this.Type">tp1</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141309" title="Types.this.Type">tp2</a>.<a href="#42732" title="=&gt; Types.this.Type">widen</a>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="Symbols.scala.html#40010" title="Types.this.ClassSymbol">ClassSymbol</a> =&gt;
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#40248" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><span class="delimiter">(</span><a href="#141633" title="Types.this.Symbol">sym1</a>, <a href="#141632" title="Types.this.TypeRef">tr1</a>.<a href="#66726" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#40320" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#116517" title="(tp: Types.this.Type)Types.this.Type">rawToExistential</a><span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a><span class="delimiter">)</span>, <a href="#141309" title="Types.this.Type">tp2</a>, <a href="#141310" title="Int">depth</a><span class="delimiter">)</span>
            <span class="keyword">else</span>
              <a href="#141633" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#40550" title="object Types.this.tpnme">tpnme</a>.<a href="StdNames.scala.html#67976" title="=&gt; Types.this.tpnme.NameType">REFINE_CLASS_NAME</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <a href="#40320" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#141633" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>, <a href="#141309" title="Types.this.Type">tp2</a>, <a href="#141310" title="Int">depth</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="Symbols.scala.html#40008" title="Types.this.TypeSymbol">TypeSymbol</a> =&gt;
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#141633" title="Types.this.Symbol">sym1</a> <a href="Symbols.scala.html#47905" title="(mask: Long)Boolean">hasFlag</a> <span title="Long(16L)">DEFERRED</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="141652">tp1a</a> = <a href="#141308" title="Types.this.Type">tp1</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a>
              <a href="#40304" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isDifferentTypeConstructor</a><span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a>, <a href="#141652" title="Types.this.Type">tp1a</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141652" title="Types.this.Type">tp1a</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141309" title="Types.this.Type">tp2</a>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <a href="#40320" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#141308" title="Types.this.Type">tp1</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a>, <a href="#141309" title="Types.this.Type">tp2</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a>, <a href="#141310" title="Int">depth</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="141658">parents1</a>, _<span class="delimiter">)</span> =&gt;
        <a href="#141658" title="List[Types.this.Type]">parents1</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#141665" title="Types.this.Type">_</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141309" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="#40089" title="Types.this.SingletonType">SingletonType</a> | _: <a href="#146963" title="Types.this.NotNullType">NotNullType</a> =&gt;
        <a href="#141308" title="Types.this.Type">tp1</a>.<a href="#42731" title="=&gt; Types.this.Type">underlying</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141309" title="Types.this.Type">tp2</a>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
        <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>

    <a href="#141565" title="=&gt; Boolean">firstTry</a>
  <span class="delimiter">}</span>

  /** Are `tps1` and `tps2` lists of equal length such that all elements
   *  of `tps1` conform to corresponding elements of `tps2`?
   */
  <span class="keyword">def</span> <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean" id="40331">isSubTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="141732">tps1</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="141733">tps2</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#141732" title="List[Types.this.Type]">tps1</a> <span title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.Type, Types.this.Type) =&gt; Boolean)Boolean">corresponds</span> <a href="#141733" title="List[Types.this.Type]">tps2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#141757" title="Types.this.Type">_</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141758" title="Types.this.Type">_</a><span class="delimiter">)</span>

  /** Does type `tp` implement symbol `sym` with same or
   *  stronger type? Exact only if `sym` is a member of some
   *  refinement type, otherwise we might return false negatives.
   */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean" id="40332">specializesSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="130215">tp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="130216">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#130215" title="Types.this.Type">tp</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a> <span title="(x: Boolean)Boolean">||</span>
    <a href="#130215" title="Types.this.Type">tp</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#46291" title="object Types.this.definitions.NullClass">NullClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#130216" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a> <a href="Symbols.scala.html#47964" title="(that: Types.this.Symbol)Boolean">isSubClass</a> <a href="Definitions.scala.html#46278" title="=&gt; Types.this.Symbol">ObjectClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
    <span class="delimiter">(</span><a href="#130215" title="Types.this.Type">tp</a>.<a href="#42770" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#130216" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#47967" title="=&gt; List[Types.this.Symbol]">alternatives</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span>
      <span class="delimiter">(</span><a title="Types.this.Symbol" id="141779">alt</a> =&gt; <a href="#130216" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#141779" title="Types.this.Symbol">alt</a> <span title="(x: Boolean)Boolean">||</span> <a href="#40333" title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#130215" title="Types.this.Type">tp</a>.<a href="#42735" title="=&gt; Types.this.Type">narrow</a>, <a href="#141779" title="Types.this.Symbol">alt</a>, <a href="#130216" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#47980" title="=&gt; Types.this.Type">thisType</a>, <a href="#130216" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  /** Does member `sym1` of `tp1` have a stronger type
   *  than member `sym2` of `tp2`?
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean" id="40333">specializesSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="130210">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="130211">sym1</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="130212">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="130213">sym2</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Types.this.Type" id="141789">info1</a> = <a href="#130210" title="Types.this.Type">tp1</a>.<a href="#42779" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#130211" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Types.this.Type" id="141790">info2</a> = <a href="#130212" title="Types.this.Type">tp2</a>.<a href="#42779" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#130213" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>.<a href="#42784" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#130212" title="Types.this.Type">tp2</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#130210" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
    //System.out.println(&quot;specializes &quot;+tp1+&quot;.&quot;+sym1+&quot;:&quot;+info1+sym1.locationString+&quot; AND &quot;+tp2+&quot;.&quot;+sym2+&quot;:&quot;+info2)//DEBUG
    <a href="#130213" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47755" title="=&gt; Boolean">isTerm</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#141789" title="Types.this.Type">info1</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141790" title="Types.this.Type">info2</a><span class="delimiter">)</span> /*&amp;&amp; (!sym2.isStable || sym1.isStable) */ <span title="(x: Boolean)Boolean">||</span>
    <a href="#130213" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47760" title="=&gt; Boolean">isAbstractType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="141798">memberTp1</a> = <a href="#130210" title="Types.this.Type">tp1</a>.<a href="#42780" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#130211" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      // println(&quot;kinds conform? &quot;+(memberTp1, tp1, sym2, kindsConform(List(sym2), List(memberTp1), tp2, sym2.owner)))
      <a href="#141790" title="Types.this.Type">info2</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66859" title="(that: Types.this.Type)Boolean">containsType</a><span class="delimiter">(</span><a href="#141798" title="Types.this.Type">memberTp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <a href="Kinds.scala.html#40416" title="(tparams: List[Types.this.Symbol], targs: List[Types.this.Type], pre: Types.this.Type, owner: Types.this.Symbol)Boolean">kindsConform</a><span class="delimiter">(</span><span title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</span><span class="delimiter">(</span><a href="#130213" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>, <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#141798" title="Types.this.Type">memberTp1</a><span class="delimiter">)</span>, <a href="#130210" title="Types.this.Type">tp1</a>, <a href="#130211" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span title="(x: Boolean)Boolean">||</span>
    <a href="#130213" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47759" title="=&gt; Boolean">isAliasType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#130212" title="Types.this.Type">tp2</a>.<a href="#42780" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#130213" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>.<a href="#42784" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#130212" title="Types.this.Type">tp2</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#130210" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#130210" title="Types.this.Type">tp1</a>.<a href="#42780" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#130211" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> //@MAT ok
  <span class="delimiter">}</span>

  /** A function implementing `tp1` matches `tp2`. */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean" id="40334">matchesType</a><span class="delimiter">(</span><a title="Types.this.Type" id="130231">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="130232">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Boolean" id="130233">alwaysMatchSimple</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean" id="141824">matchesQuantified</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141826">tparams1</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="141827">tparams2</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="141828">res1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141829">res2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span>
      <a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#141826" title="List[Types.this.Symbol]">tparams1</a>, <a href="#141827" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <a href="#40334" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#141828" title="Types.this.Type">res1</a>, <a href="#141829" title="Types.this.Type">res2</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#141827" title="List[Types.this.Symbol]">tparams2</a>, <a href="#141826" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>, <a href="#130233" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="141825">lastTry</a> =
      <a href="#130232" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="141832">res2</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#130233" title="Boolean">alwaysMatchSimple</a> =&gt;
          <a href="#40334" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#130231" title="Types.this.Type">tp1</a>, <a href="#141832" title="Types.this.Type">res2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Boolean(false)">MethodType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
          <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">case</span> <span title="Boolean">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141833">tparams2</a>, <a title="Types.this.Type" id="141834">res2</a><span class="delimiter">)</span> =&gt;
          <a href="#141833" title="List[Types.this.Symbol]">tparams2</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#40334" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#130231" title="Types.this.Type">tp1</a>, <a href="#141834" title="Types.this.Type">res2</a>, <a href="#130233" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
          <a href="#130233" title="Boolean">alwaysMatchSimple</a> <span title="(x: Boolean)Boolean">||</span> <a href="#130231" title="Types.this.Type">tp1</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#130232" title="Types.this.Type">tp2</a>
      <span class="delimiter">}</span>
    <a href="#130231" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="141836">mt1</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141837">params1</a>, <a title="Types.this.Type" id="141838">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#130232" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="141839">mt2</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141840">params2</a>, <a title="Types.this.Type" id="141841">res2</a><span class="delimiter">)</span> =&gt;
            // sameLength(params1, params2) was used directly as pre-screening optimization (now done by matchesQuantified -- is that ok, performancewise?)
            <a href="#141824" title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean">matchesQuantified</a><span class="delimiter">(</span><a href="#141837" title="List[Types.this.Symbol]">params1</a>, <a href="#141840" title="List[Types.this.Symbol]">params2</a>, <a href="#141838" title="Types.this.Type">res1</a>, <a href="#141841" title="Types.this.Type">res2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#40335" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span><a href="#141837" title="List[Types.this.Symbol]">params1</a>, <a href="#141840" title="List[Types.this.Symbol]">params2</a>, <a href="#141836" title="Types.this.MethodType">mt1</a>.<a href="#66911" title="=&gt; Boolean">isJava</a>, <a href="#141839" title="Types.this.MethodType">mt2</a>.<a href="#66911" title="=&gt; Boolean">isJava</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#141836" title="Types.this.MethodType">mt1</a>.<a href="#66910" title="=&gt; Boolean">isImplicit</a> <span title="(x: Boolean)Boolean">==</span> <a href="#141839" title="Types.this.MethodType">mt2</a>.<a href="#66910" title="=&gt; Boolean">isImplicit</a>
          <span class="keyword">case</span> <span title="Boolean">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="141847">res2</a><span class="delimiter">)</span> =&gt;
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#141837" title="List[Types.this.Symbol]">params1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#40334" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#141838" title="Types.this.Type">res1</a>, <a href="#141847" title="Types.this.Type">res2</a>, <a href="#130233" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#40334" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#130231" title="Types.this.Type">tp1</a>, <a href="#141847" title="Types.this.Type">res2</a>, <a href="#130233" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="141848">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#130233" title="Boolean">alwaysMatchSimple</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#40334" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#130231" title="Types.this.Type">tp1</a>, <a href="#141848" title="Types.this.Type">res2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Boolean" id="141849">mt1</a> @ NullaryMethodType<span class="delimiter">(</span><a title="Types.this.Type" id="141850">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#130232" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="141851">mt2</a> @ MethodType<span class="delimiter">(</span><span title="object Nil">Nil</span>, <a title="Types.this.Type" id="141852">res2</a><span class="delimiter">)</span>  =&gt; // could never match if params nonEmpty, and !mt2.isImplicit is implied by empty param list
            <a href="#40334" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#141850" title="Types.this.Type">res1</a>, <a href="#141852" title="Types.this.Type">res2</a>, <a href="#130233" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="141853">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#40334" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#141850" title="Types.this.Type">res1</a>, <a href="#141853" title="Types.this.Type">res2</a>, <a href="#130233" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="141854">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#130233" title="Boolean">alwaysMatchSimple</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#40334" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#130231" title="Types.this.Type">tp1</a>, <a href="#141854" title="Types.this.Type">res2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#40334" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#141850" title="Types.this.Type">res1</a>, <a href="#130232" title="Types.this.Type">tp2</a>, <a href="#130233" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141855">tparams1</a>, <a title="Types.this.Type" id="141856">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#130232" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141857">tparams2</a>, <a title="Types.this.Type" id="141858">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#141824" title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean">matchesQuantified</a><span class="delimiter">(</span><a href="#141855" title="List[Types.this.Symbol]">tparams1</a>, <a href="#141857" title="List[Types.this.Symbol]">tparams2</a>, <a href="#141856" title="Types.this.Type">res1</a>, <a href="#141858" title="Types.this.Type">res2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="141859">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#130233" title="Boolean">alwaysMatchSimple</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#40334" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#130231" title="Types.this.Type">tp1</a>, <a href="#141859" title="Types.this.Type">res2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span> // remember that tparams1.nonEmpty is now an invariant of PolyType
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141860">tparams1</a>, <a title="Types.this.Type" id="141861">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#130232" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141862">tparams2</a>, <a title="Types.this.Type" id="141863">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#141824" title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean">matchesQuantified</a><span class="delimiter">(</span><a href="#141860" title="List[Types.this.Symbol]">tparams1</a>, <a href="#141862" title="List[Types.this.Symbol]">tparams2</a>, <a href="#141861" title="Types.this.Type">res1</a>, <a href="#141863" title="Types.this.Type">res2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#130233" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span> <a href="#40334" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#141861" title="Types.this.Type">res1</a>, <a href="#130232" title="Types.this.Type">tp2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#141825" title="=&gt; Boolean">lastTry</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#141825" title="=&gt; Boolean">lastTry</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

/** matchesType above is an optimized version of the following implementation:

  def matchesType2(tp1: Type, tp2: Type, alwaysMatchSimple: Boolean): Boolean = {
    def matchesQuantified(tparams1: List[Symbol], tparams2: List[Symbol], res1: Type, res2: Type): Boolean =
      tparams1.length == tparams2.length &amp;&amp;
      matchesType(res1, res2.substSym(tparams2, tparams1), alwaysMatchSimple)
    (tp1, tp2) match {
      case (MethodType(params1, res1), MethodType(params2, res2)) =&gt;
        params1.length == params2.length &amp;&amp; // useful pre-secreening optimization
        matchingParams(params1, params2, tp1.isInstanceOf[JavaMethodType], tp2.isInstanceOf[JavaMethodType]) &amp;&amp;
        matchesType(res1, res2, alwaysMatchSimple) &amp;&amp;
        tp1.isImplicit == tp2.isImplicit
      case (PolyType(tparams1, res1), PolyType(tparams2, res2)) =&gt;
        matchesQuantified(tparams1, tparams2, res1, res2)
      case (NullaryMethodType(rtp1), MethodType(List(), rtp2)) =&gt;
        matchesType(rtp1, rtp2, alwaysMatchSimple)
      case (MethodType(List(), rtp1), NullaryMethodType(rtp2)) =&gt;
        matchesType(rtp1, rtp2, alwaysMatchSimple)
      case (ExistentialType(tparams1, res1), ExistentialType(tparams2, res2)) =&gt;
        matchesQuantified(tparams1, tparams2, res1, res2)
      case (ExistentialType(_, res1), _) if alwaysMatchSimple =&gt;
        matchesType(res1, tp2, alwaysMatchSimple)
      case (_, ExistentialType(_, res2)) if alwaysMatchSimple =&gt;
        matchesType(tp1, res2, alwaysMatchSimple)
      case (NullaryMethodType(rtp1), _) =&gt;
        matchesType(rtp1, tp2, alwaysMatchSimple)
      case (_, NullaryMethodType(rtp2)) =&gt;
        matchesType(tp1, rtp2, alwaysMatchSimple)
      case (MethodType(_, _), _) =&gt; false
      case (PolyType(_, _), _)   =&gt; false
      case (_, MethodType(_, _)) =&gt; false
      case (_, PolyType(_, _))   =&gt; false
      case _ =&gt;
        alwaysMatchSimple || tp1 =:= tp2
    }
  }
*/

  /** Are `syms1` and `syms2` parameter lists with pairwise equivalent types? */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean" id="40335">matchingParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141681">syms1</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="141682">syms2</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Boolean" id="141683">syms1isJava</a>: <span title="Boolean">Boolean</span>, <a title="Boolean" id="141684">syms2isJava</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#141681" title="List[Types.this.Symbol]">syms1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean">Nil</span> =&gt;
      <a href="#141682" title="List[Types.this.Symbol]">syms2</a>.<span title="=&gt; Boolean">isEmpty</span>
    <span class="keyword">case</span> <a title="Boolean" id="141868">sym1</a> :: <a title="List[Types.this.Symbol]" id="141869">rest1</a> =&gt;
      <a href="#141682" title="List[Types.this.Symbol]">syms2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Boolean(false)">Nil</span> =&gt;
          <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">case</span> <a title="Boolean" id="141874">sym2</a> :: <a title="List[Types.this.Symbol]" id="141875">rest2</a> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="141876">tp1</a> = <a href="#141868" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>
          <span class="keyword">val</span> <a title="Types.this.Type" id="141877">tp2</a> = <a href="#141874" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>
          <span class="delimiter">(</span><a href="#141876" title="Types.this.Type">tp1</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141877" title="Types.this.Type">tp2</a> <span title="(x: Boolean)Boolean">||</span>
           <a href="#141683" title="Boolean">syms1isJava</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141877" title="Types.this.Type">tp2</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#46278" title="=&gt; Types.this.Symbol">ObjectClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141876" title="Types.this.Type">tp1</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a> <span title="(x: Boolean)Boolean">||</span>
           <a href="#141684" title="Boolean">syms2isJava</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141876" title="Types.this.Type">tp1</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#46278" title="=&gt; Types.this.Symbol">ObjectClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141877" title="Types.this.Type">tp2</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
          <a href="#40335" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span><a href="#141869" title="List[Types.this.Symbol]">rest1</a>, <a href="#141875" title="List[Types.this.Symbol]">rest2</a>, <a href="#141683" title="Boolean">syms1isJava</a>, <a href="#141684" title="Boolean">syms2isJava</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** like map2, but returns list `xs` itself - instead of a copy - if function
   *  `f` maps all elements to themselves.
   */
  <span class="keyword">def</span> <a title="[A &lt;: AnyRef, B](xs: List[A], ys: List[B])(f: (A, B) =&gt; A)List[A]" id="40336">map2Conserve</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef" id="40339">A</a> &lt;: AnyRef, <a title="&gt;: Nothing &lt;: Any" id="40340">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[A]" id="138027">xs</a>: <span title="List[A]">List</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="List[B]" id="138028">ys</a>: <span title="List[B]">List</span><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; A" id="138029">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span>: <span title="List[A]">List</span><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <span title="List[A]" class="keyword">if</span> <span class="delimiter">(</span><a href="#138027" title="List[A]">xs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#138027" title="List[A]">xs</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="A" id="141899">x1</a> = <a href="#138029" title="(v1: A, v2: B)A">f</a><span class="delimiter">(</span><a href="#138027" title="List[A]">xs</a>.<span title="=&gt; A">head</span>, <a href="#138028" title="List[B]">ys</a>.<span title="=&gt; B">head</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[A]" id="141900">xs1</a> = <a href="#40336" title="(xs: List[A], ys: List[B])(f: (A, B) =&gt; A)List[A]">map2Conserve</a><span class="delimiter">(</span><a href="#138027" title="List[A]">xs</a>.<span title="=&gt; List[A]">tail</span>, <a href="#138028" title="List[B]">ys</a>.<span title="=&gt; List[B]">tail</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#138029" title="(A, B) =&gt; A">f</a><span class="delimiter">)</span>
      <span title="List[A]" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141899" title="A">x1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138027" title="List[A]">xs</a>.<span title="=&gt; A">head</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#141900" title="List[A]">xs1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138027" title="List[A]">xs</a>.<span title="=&gt; List[A]">tail</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#138027" title="List[A]">xs</a>
      <span class="keyword">else</span> <a href="#141899" title="A">x1</a> <a href="#141939" title="(x: A)List[A]">::</a> <a href="#141900" title="List[A]">xs1</a>
    <span class="delimiter">}</span>

  /** Solve constraint collected in types `tvars`.
   *
   *  @param tvars      All type variables to be instantiated.
   *  @param tparams    The type parameters corresponding to `tvars`
   *  @param variances  The variances of type parameters; need to reverse
   *                    solution direction for all contravariant variables.
   *  @param upper      When `true` search for max solution else min.
   */
  <span class="keyword">def</span> <a title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean)Boolean" id="40341">solve</a><span class="delimiter">(</span><a title="List[Types.this.TypeVar]" id="135008">tvars</a>: <span title="List[Types.this.TypeVar]">List</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="135009">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
            <a title="List[Int]" id="135010">variances</a>: <span title="List[Int]">List</span><span class="delimiter">[</span>Int<span class="delimiter">]</span>, <a title="Boolean" id="135011">upper</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
     <a href="#40342" title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean, depth: Int)Boolean">solve</a><span class="delimiter">(</span><a href="#135008" title="List[Types.this.TypeVar]">tvars</a>, <a href="#135009" title="List[Types.this.Symbol]">tparams</a>, <a href="#135010" title="List[Int]">variances</a>, <a href="#135011" title="Boolean">upper</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean, depth: Int)Boolean" id="40342">solve</a><span class="delimiter">(</span><a title="List[Types.this.TypeVar]" id="135002">tvars</a>: <span title="List[Types.this.TypeVar]">List</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="135003">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
            <a title="List[Int]" id="135004">variances</a>: <span title="List[Int]">List</span><span class="delimiter">[</span>Int<span class="delimiter">]</span>, <a title="Boolean" id="135005">upper</a>: <span title="Boolean">Boolean</span>, <a title="Int" id="135006">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>

    <span class="keyword">def</span> <a title="(tvar: Types.this.TypeVar, tparam: Types.this.Symbol, variance: Int)Unit" id="141949">solveOne</a><span class="delimiter">(</span><a title="Types.this.TypeVar" id="141950">tvar</a>: <a href="#40176" title="Types.this.TypeVar">TypeVar</a>, <a title="Types.this.Symbol" id="141951">tparam</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="Int" id="141952">variance</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#141950" title="Types.this.TypeVar">tvar</a>.<a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84302" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Boolean" id="141958">up</a> = <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#141952" title="Int">variance</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(131072)">CONTRAVARIANT</span><span class="delimiter">)</span> <a href="#135005" title="Boolean">upper</a> <span class="keyword">else</span> <span title="=&gt; Boolean">!</span><a href="#135005" title="Boolean">upper</a>
        <a href="#141950" title="Types.this.TypeVar">tvar</a>.<a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84302" title="(x$1: Types.this.Type)Unit">inst</a> = <span title="Null(null)" class="keyword">null</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="141959">bound</a>: <a href="#40083" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#141958" title="Boolean">up</a><span class="delimiter">)</span> <a href="#141951" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a> <span class="keyword">else</span> <a href="#141951" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66878" title="=&gt; Types.this.Type">lo</a>
        //Console.println(&quot;solveOne0(tv, tp, v, b)=&quot;+(tvar, tparam, variance, bound))
        <span class="keyword">var</span> <a title="Boolean" id="141960">cyclic</a> = <a href="#141959" title="Types.this.Type">bound</a> <a href="#42793" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#141951" title="Types.this.Symbol">tparam</a>
        <a href="util/Collections.scala.html#39618" title="(xs1: List[Types.this.TypeVar], xs2: List[Types.this.Symbol], xs3: List[Int])(f: (Types.this.TypeVar, Types.this.Symbol, Int) =&gt; Unit)Unit">foreach3</a><span class="delimiter">(</span><a href="#135002" title="List[Types.this.TypeVar]">tvars</a>, <a href="#135003" title="List[Types.this.Symbol]">tparams</a>, <a href="#135004" title="List[Int]">variances</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.TypeVar" id="142033">tvar2</a>, <a title="Types.this.Symbol" id="142034">tparam2</a>, <a title="Int" id="142035">variance2</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Boolean" id="142036">ok</a> = <span class="delimiter">(</span><a href="#142034" title="Types.this.Symbol">tparam2</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#141951" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span>
               <span class="delimiter">(</span><a href="#141959" title="Types.this.Type">bound</a> <a href="#42793" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#142034" title="Types.this.Symbol">tparam2</a><span class="delimiter">)</span>
            <span title="(x: Boolean)Boolean">||</span>  <a href="#141958" title="Boolean">up</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#142034" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66878" title="=&gt; Types.this.Type">lo</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141951" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
            <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#141958" title="Boolean">up</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#142034" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141951" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
          <span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#142036" title="Boolean">ok</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#142033" title="Types.this.TypeVar">tvar2</a>.<a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84302" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#141960" title="Boolean">cyclic</a> = <span title="Boolean(true)" class="keyword">true</span>
            <a href="#141949" title="(tvar: Types.this.TypeVar, tparam: Types.this.Symbol, variance: Int)Unit">solveOne</a><span class="delimiter">(</span><a href="#142033" title="Types.this.TypeVar">tvar2</a>, <a href="#142034" title="Types.this.Symbol">tparam2</a>, <a href="#142035" title="Int">variance2</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#141960" title="Boolean">cyclic</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#141958" title="Boolean">up</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#141959" title="Types.this.Type">bound</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span>
              <a href="#141950" title="Types.this.TypeVar">tvar</a> <a href="#84214" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a> <a href="#141959" title="Types.this.Type">bound</a>.<a href="#42755" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#135003" title="List[Types.this.Symbol]">tparams</a>, <a href="#135002" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
            <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="142069">tparam2</a> &lt;- <a href="#135003" title="(f: Types.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span>
              <a href="#142069" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66878" title="=&gt; Types.this.Type">lo</a>.<a href="#42759" title="=&gt; Types.this.Type">dealias</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a href="#141951" title="Types.this.Symbol">`tparam`</a>, _<span class="delimiter">)</span> =&gt;
                  <a href="#141950" title="Types.this.TypeVar">tvar</a> <a href="#84214" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a> <a href="#142069" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>.<a href="#42755" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#135003" title="List[Types.this.Symbol]">tparams</a>, <a href="#135002" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
                <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
              <span class="delimiter">}</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#141959" title="Types.this.Type">bound</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141959" title="Types.this.Type">bound</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#141951" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#141950" title="Types.this.TypeVar">tvar</a> <a href="#84213" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a> <a href="#141959" title="Types.this.Type">bound</a>.<a href="#42755" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#135003" title="List[Types.this.Symbol]">tparams</a>, <a href="#135002" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="142092">tparam2</a> &lt;- <a href="#135003" title="(f: Types.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span>
              <a href="#142092" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a>.<a href="#42759" title="=&gt; Types.this.Type">dealias</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a href="#141951" title="Types.this.Symbol">`tparam`</a>, _<span class="delimiter">)</span> =&gt;
                  <a href="#141950" title="Types.this.TypeVar">tvar</a> <a href="#84213" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a> <a href="#142092" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>.<a href="#42755" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#135003" title="List[Types.this.Symbol]">tparams</a>, <a href="#135002" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
                <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
              <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <a href="#141950" title="Types.this.TypeVar">tvar</a>.<a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84302" title="(x$1: Types.this.Type)Unit">inst</a> = <a href="#130794" title="object Types.this.NoType">NoType</a> // necessary because hibounds/lobounds may contain tvar

        //println(&quot;solving &quot;+tvar+&quot; &quot;+up+&quot; &quot;+(if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds)+((if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds) map (_.widen)))

        <a href="#141950" title="Types.this.TypeVar">tvar</a> <a href="#84212" title="(tp: Types.this.Type)Unit">setInst</a> <span class="delimiter">(</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#141958" title="Boolean">up</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#135006" title="Int">depth</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span> <a href="#40375" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#141950" title="Types.this.TypeVar">tvar</a>.<a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84295" title="=&gt; List[Types.this.Type]">hiBounds</a>, <a href="#135006" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#40374" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#141950" title="Types.this.TypeVar">tvar</a>.<a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84295" title="=&gt; List[Types.this.Type]">hiBounds</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#135006" title="Int">depth</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span> <a href="#40366" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#141950" title="Types.this.TypeVar">tvar</a>.<a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84294" title="=&gt; List[Types.this.Type]">loBounds</a>, <a href="#135006" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#40365" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#141950" title="Types.this.TypeVar">tvar</a>.<a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84294" title="=&gt; List[Types.this.Type]">loBounds</a><span class="delimiter">)</span>
          <span class="delimiter">}</span><span class="delimiter">)</span>

        //Console.println(&quot;solving &quot;+tvar+&quot; &quot;+up+&quot; &quot;+(if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds)+((if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds) map (_.widen))+&quot; = &quot;+tvar.constr.inst)//@MDEBUG
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    // println(&quot;solving &quot;+tvars+&quot;/&quot;+tparams+&quot;/&quot;+(tparams map (_.info)))
    <a href="util/Collections.scala.html#39618" title="(xs1: List[Types.this.TypeVar], xs2: List[Types.this.Symbol], xs3: List[Int])(f: (Types.this.TypeVar, Types.this.Symbol, Int) =&gt; Unit)Unit">foreach3</a><span class="delimiter">(</span><a href="#135002" title="List[Types.this.TypeVar]">tvars</a>, <a href="#135003" title="List[Types.this.Symbol]">tparams</a>, <a href="#135004" title="List[Int]">variances</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#141949" title="(tvar: Types.this.TypeVar, tparam: Types.this.Symbol, variance: Int)Unit">solveOne</a><span class="delimiter">)</span>
    <a href="#135002" title="List[Types.this.TypeVar]">tvars</a> <span title="(p: Types.this.TypeVar =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.TypeVar" id="142186">tvar</a> =&gt; <a href="#142186" title="Types.this.TypeVar">tvar</a>.<a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84300" title="(tp: Types.this.Type)Boolean">isWithinBounds</a><span class="delimiter">(</span><a href="#142186" title="Types.this.TypeVar">tvar</a>.<a href="#84202" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84302" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Do type arguments `targs` conform to formal parameters `tparams`?
   */
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])Boolean" id="40343">isWithinBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="135062">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="135063">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="135064">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="135065">targs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="List[Types.this.TypeBounds]" id="142187">bounds</a> = <a href="#40344" title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]">instantiatedBounds</a><span class="delimiter">(</span><a href="#135062" title="Types.this.Type">pre</a>, <a href="#135063" title="Types.this.Symbol">owner</a>, <a href="#135064" title="List[Types.this.Symbol]">tparams</a>, <a href="#135065" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#135065" title="List[Types.this.Type]">targs</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#142199" title="Types.this.Type">_</a>.<a href="#42821" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#142187" title="List[Types.this.TypeBounds]">bounds</a> = <a href="AnnotationCheckers.scala.html#36292" title="(bounds: List[Types.this.TypeBounds], tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]">adaptBoundsToAnnotations</a><span class="delimiter">(</span><a href="#142187" title="List[Types.this.TypeBounds]">bounds</a>, <a href="#135064" title="List[Types.this.Symbol]">tparams</a>, <a href="#135065" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>
    <span class="delimiter">(</span><a href="#142187" title="List[Types.this.TypeBounds]">bounds</a> <span title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.TypeBounds, Types.this.Type) =&gt; Boolean)Boolean">corresponds</span> <a href="#135065" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#142232" title="Types.this.TypeBounds">_</a> <a href="#66859" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#142233" title="Types.this.Type">_</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]" id="40344">instantiatedBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="142188">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="142189">owner</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="142190">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="142191">targs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.TypeBounds]">List</span><span class="delimiter">[</span>TypeBounds<span class="delimiter">]</span> =
    <a href="#142190" title="List[Types.this.Symbol]">tparams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.TypeBounds)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.TypeBounds,List[Types.this.TypeBounds]])List[Types.this.TypeBounds]">map</span> <span class="delimiter">(</span><a href="#142250" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42778" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#142188" title="Types.this.Type">pre</a>, <a href="#142189" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>.<a href="#42755" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#142190" title="List[Types.this.Symbol]">tparams</a>, <a href="#142191" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>

// Lubs and Glbs ---------------------------------------------------------

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(btsMap: Map[Types.this.Type,List[Types.this.Type]], depth: Int)Unit" id="40345">printLubMatrix</a><span class="delimiter">(</span><a title="Map[Types.this.Type,List[Types.this.Type]]" id="142292">btsMap</a>: <span title="Map[Types.this.Type,List[Types.this.Type]]">Map</span><span class="delimiter">[</span>Type, List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Int" id="142293">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">import</span> scala.tools.nsc.util.TableDef
    <span class="keyword">import</span> <a href="../../tools/nsc/util/TableDef.scala.html#34365" title="object scala.tools.nsc.util.TableDef">TableDef</a>.Column
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)String" id="142297">str</a><span class="delimiter">(</span><a title="Types.this.Type" id="142313">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#142313" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="String" id="142318">s</a> = <span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#142313" title="Types.this.Type">tp</a><span class="delimiter">)</span>.<span title="(x$1: String, x$2: String)String">replaceAll</span><span class="delimiter">(</span><span title="String(&quot;[\\w.]+\\.(\\w+)&quot;)" class="string">&quot;&quot;&quot;[\w.]+\.(\w+)&quot;&quot;&quot;</span>, <span title="String(&quot;$1&quot;)" class="string">&quot;$1&quot;</span><span class="delimiter">)</span>
        <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#142318" title="String">s</a>.<span title="()Int">length</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(60)" class="int">60</span><span class="delimiter">)</span> <a href="#142318" title="String">s</a>
        <span class="keyword">else</span> <span class="delimiter">(</span><a href="#142318" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">s</a> <span title="(n: Int)String">take</span> <span title="Int(57)" class="int">57</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;...&quot;)" class="string">&quot;...&quot;</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="List[(Types.this.Type, List[Types.this.Type])]" id="142298">sorted</a>       = <a href="#142292" title="Map[Types.this.Type,List[Types.this.Type]]">btsMap</a>.<span title="=&gt; List[(Types.this.Type, List[Types.this.Type])]">toList</span>.<span title="(lt: ((Types.this.Type, List[Types.this.Type]), (Types.this.Type, List[Types.this.Type])) =&gt; Boolean)List[(Types.this.Type, List[Types.this.Type])]">sortWith</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="(Types.this.Type, List[Types.this.Type])" id="142388">x</a>, <a title="(Types.this.Type, List[Types.this.Type])" id="142389">y</a><span class="delimiter">)</span> =&gt; <a href="#142388" title="(Types.this.Type, List[Types.this.Type])">x</a>.<span title="=&gt; Types.this.Type">_1</span>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#47961" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#142389" title="(Types.this.Type, List[Types.this.Type])">y</a>.<span title="=&gt; Types.this.Type">_1</span>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Int" id="142299">maxSeqLength</a> = <a href="#142298" title="List[(Types.this.Type, List[Types.this.Type])]">sorted</a> <span title="(f: ((Types.this.Type, List[Types.this.Type])) =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Type, List[Types.this.Type])],Int,List[Int]])List[Int]">map</span> <span class="delimiter">(</span><a href="#142407" title="(Types.this.Type, List[Types.this.Type])">_</a>.<span title="=&gt; List[Types.this.Type]">_2</span>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> <span title="(implicit cmp: Ordering[Int])Int">max</span>
    <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="142300">padded</a>       = <a href="#142298" title="List[(Types.this.Type, List[Types.this.Type])]">sorted</a> <span title="(f: ((Types.this.Type, List[Types.this.Type])) =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Type, List[Types.this.Type])],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a href="#142511" title="(Types.this.Type, List[Types.this.Type])">_</a>.<span title="=&gt; List[Types.this.Type]">_2</span>.<span title="(len: Int, elem: Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">padTo</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.Type,List[Types.this.Type]]" class="delimiter">(</span><a href="#142299" title="Int">maxSeqLength</a>, <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="142301">transposed</a>   = <a href="#142300" title="List[List[Types.this.Type]]">padded</a>.<span title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.GenTraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</span>

    <span class="keyword">val</span> <a title="List[scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]]" id="142302">columns</a>: <span title="List[scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]]">List</span><span class="delimiter">[</span>Column<span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#142298" title="List[(Types.this.Type, List[Types.this.Type])]">sorted</a>.<span title="(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Type, List[Types.this.Type])],((Types.this.Type, List[Types.this.Type]), Int),List[((Types.this.Type, List[Types.this.Type]), Int)]])List[((Types.this.Type, List[Types.this.Type]), Int)]">zipWithIndex</span> <span title="(f: (((Types.this.Type, List[Types.this.Type]), Int)) =&gt; scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]])(implicit bf: scala.collection.generic.CanBuildFrom[List[((Types.this.Type, List[Types.this.Type]), Int)],scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]],List[scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]]])List[scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]]">map</span> <a href="#142675" title="scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]" class="delimiter">{</a>
      <span class="keyword">case</span> <span title="scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]" class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="142680">k</a>, <a title="List[Types.this.Type]" id="142681">v</a><span class="delimiter">)</span>, <a title="Int" id="142682">idx</a><span class="delimiter">)</span> =&gt;
        <a href="../../tools/nsc/util/TableDef.scala.html#142685" title="(name: String, f: List[Types.this.Type] =&gt; Any, left: Boolean)scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]">Column</a><span class="delimiter">(</span><a href="#142297" title="(tp: Types.this.Type)String">str</a><span class="delimiter">(</span><a href="#142680" title="Types.this.Type">k</a><span class="delimiter">)</span>, <span class="delimiter">(</span>xs: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="#142297" title="(tp: Types.this.Type)String">str</a><span class="delimiter">(</span><a href="#142719" title="(n: Int)Types.this.Type">xs</a><span class="delimiter">(</span><a href="#142682" title="Int">idx</a><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="scala.tools.nsc.util.TableDef[List[Types.this.Type]]" id="142303">tableDef</a> = <a href="../../tools/nsc/util/TableDef.scala.html#142310" title="(cols: tools.nsc.util.TableDef.Column[List[Types.this.Type]]*)scala.tools.nsc.util.TableDef[List[Types.this.Type]]">TableDef</a><span class="delimiter">(</span><a href="#142302" title="List[scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]]">columns</a>: _*<span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="tableDef.Table" id="142304">formatted</a> = <a href="#142303" title="scala.tools.nsc.util.TableDef[List[Types.this.Type]]">tableDef</a>.<a href="../../tools/nsc/util/TableDef.scala.html#142794" title="(rows: Seq[List[Types.this.Type]])tableDef.Table">table</a><span class="delimiter">(</span><a href="#142301" title="List[List[Types.this.Type]]">transposed</a><span class="delimiter">)</span>
    <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;** Depth is &quot;)" class="string">&quot;** Depth is &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#142293" title="Int">depth</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#142304" title="tableDef.Table">formatted</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  /** From a list of types, find any which take type parameters 
   *  where the type parameter bounds contain references to other
   *  any types in the list (including itself.)
   *
   *  @return List of symbol pairs holding the recursive type
   *    parameter and the parameter which references it.
   */
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[(Types.this.Symbol, Types.this.Symbol)]" id="40346">findRecursiveBounds</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="142852">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[(Types.this.Symbol, Types.this.Symbol)]">List</span><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="List[(Types.this.Symbol, Types.this.Symbol)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#142852" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="object Nil">Nil</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="142854">sym</a> = <a href="#142852" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>
      <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#142852" title="List[Types.this.Type]">ts</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#142866" title="Types.this.Type">_</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#142854" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>, <a href="#142852" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="142891">p</a> &lt;- <a href="#142854" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47940" title="(f: Types.this.Symbol =&gt; scala.collection.GenTraversableOnce[(Types.this.Symbol, Types.this.Symbol)])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],(Types.this.Symbol, Types.this.Symbol),List[(Types.this.Symbol, Types.this.Symbol)]])List[(Types.this.Symbol, Types.this.Symbol)]">typeParams</a> ; <a title="Types.this.Symbol" id="142908">in</a> &lt;- <a href="#142854" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47940" title="(f: Types.this.Symbol =&gt; (Types.this.Symbol, Types.this.Symbol))(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],(Types.this.Symbol, Types.this.Symbol),List[(Types.this.Symbol, Types.this.Symbol)]])List[(Types.this.Symbol, Types.this.Symbol)]">typeParams</a> ; <span class="keyword">if</span> <a href="#142908" title="Types.this.Symbol">in</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a> <a href="#42793" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#142891" title="Types.this.Symbol">p</a><span class="delimiter">)</span> <span class="keyword">yield</span>
        <a href="#142891" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">p</a> <span title="(y: Types.this.Symbol)(Types.this.Symbol, Types.this.Symbol)">-&gt;</span> <a href="#142908" title="Types.this.Symbol">in</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Given a matrix `tsBts` whose columns are basetype sequences (and the symbols `tsParams` that should be interpreted as type parameters in this matrix),
   * compute its least sorted upwards closed upper bound relative to the following ordering &lt;= between lists of types:
   *
   *    xs &lt;= ys   iff   forall y in ys exists x in xs such that x &lt;: y
   *
   *  @arg tsParams for each type in the original list of types `ts0`, its list of type parameters (if that type is a type constructor)
   *                (these type parameters may be referred to by type arguments in the BTS column of those types,
   *                and must be interpreted as bound variables; i.e., under a type lambda that wraps the types that refer to these type params)
   *  @arg tsBts    a matrix whose columns are basetype sequences
   *                the first row is the original list of types for which we're computing the lub
   *                  (except that type constructors have been applied to their dummyArgs)
   *  @See baseTypeSeq  for a definition of sorted and upwards closed.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]" id="40347">lubList</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="142990">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="142991">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    // Matching the type params of one of the initial types means dummies.
    <span class="keyword">val</span> <a title="List[List[Types.this.Symbol]]" id="142993">initialTypeParams</a> = <a href="#142990" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; List[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Symbol],List[List[Types.this.Symbol]]])List[List[Types.this.Symbol]]">map</span> <span class="delimiter">(</span><a href="#143015" title="Types.this.Type">_</a>.<a href="#42752" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(xs: List[Types.this.Type])Boolean" id="142994">isHotForTs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143043">xs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#142993" title="List[List[Types.this.Symbol]]">initialTypeParams</a> <span title="(elem: Any)Boolean">contains</span> <a href="#143043" title="List[Types.this.Type]">xs</a>.<span title="(f: Types.this.Type =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,Any])Any">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.Symbol,List[Types.this.Symbol]]" class="delimiter">(</span><a href="#143060" title="Types.this.Type">_</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="142995">elimHigherOrderTypeParam</a><span class="delimiter">(</span><a title="Types.this.Type" id="143088">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#143088" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="143089">pre</a>, <a title="Types.this.Symbol" id="143090">sym</a>, <a title="List[Types.this.Type]" id="143091">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#143091" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#142994" title="(xs: List[Types.this.Type])Boolean">isHotForTs</a><span class="delimiter">(</span><a href="#143091" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> =&gt; <a href="#143088" title="Types.this.Type">tp</a>.<a href="#42740" title="=&gt; Types.this.Type">typeConstructor</a>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span>                                                            =&gt; <a href="#143088" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>
    <span class="keyword">var</span> <a title="Int" id="142996">lubListDepth</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">def</span> <a title="(tsBts: List[List[Types.this.Type]])List[Types.this.Type]" id="142997">loop</a><span class="delimiter">(</span><a title="List[List[Types.this.Type]]" id="143092">tsBts</a>: <span title="List[List[Types.this.Type]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="#142996" title="Int">lubListDepth</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>

      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#143092" title="List[List[Types.this.Type]]">tsBts</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#143092" title="List[List[Types.this.Type]]">tsBts</a>.<span title="(p: List[Types.this.Type] =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#143103" title="List[Types.this.Type]">_</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="object Nil">Nil</span>
      <span class="keyword">else</span> <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#143092" title="List[List[Types.this.Type]]">tsBts</a>.<span title="=&gt; List[List[Types.this.Type]]">tail</span>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#143092" title="List[List[Types.this.Type]]">tsBts</a>.<span title="=&gt; List[Types.this.Type]">head</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        // ts0 is the 1-dimensional frontier of symbols cutting through 2-dimensional tsBts.
        // Invariant: all symbols &quot;under&quot; (closer to the first row) the frontier
        // are smaller (according to _.isLess) than the ones &quot;on and beyond&quot; the frontier
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="143105">ts0</a>  = <a href="#143092" title="List[List[Types.this.Type]]">tsBts</a> <span title="(f: List[Types.this.Type] =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#143123" title="List[Types.this.Type]">_</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span>

        // Is the frontier made up of types with the same symbol?
        <span class="keyword">val</span> <a title="Boolean" id="143106">isUniformFrontier</a> = <span class="delimiter">(</span><a href="#143105" title="List[Types.this.Type]">ts0</a>: @<span title="List[Types.this.Type] @unchecked">unchecked</span><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="143155">t</a> :: <a title="List[Types.this.Type]" id="143156">ts</a>  =&gt; <a href="#143156" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#143163" title="Types.this.Type">_</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#143155" title="Types.this.Type">t</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        // Produce a single type for this frontier by merging the prefixes and arguments of those
        // typerefs that share the same symbol: that symbol is the current maximal symbol for which
        // the invariant holds, i.e., the one that conveys most information wrt subtyping. Before
        // merging, strip targs that refer to bound tparams (when we're computing the lub of type
        // constructors.) Also filter out all types that are a subtype of some other type.
        <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#143106" title="Boolean">isUniformFrontier</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75538" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">||</span> <a href="#40057" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[(Types.this.Symbol, Types.this.Symbol)]" id="143173">fbounds</a> = <a href="#40346" title="(ts: List[Types.this.Type])List[(Types.this.Symbol, Types.this.Symbol)]">findRecursiveBounds</a><span class="delimiter">(</span><a href="#143105" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#143173" title="List[(Types.this.Symbol, Types.this.Symbol)]">fbounds</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;Encountered &quot;)" class="string">&quot;Encountered &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#143173" title="List[(Types.this.Symbol, Types.this.Symbol)]">fbounds</a>.<span title="=&gt; Int">size</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; recursive bounds while lubbing &quot;)" class="string">&quot; recursive bounds while lubbing &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#143105" title="List[Types.this.Type]">ts0</a>.<span title="=&gt; Int">size</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; types.&quot;)" class="string">&quot; types.&quot;</span><span class="delimiter">)</span>
              <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="143212">p0</a>, <a title="Types.this.Symbol" id="143213">p1</a><span class="delimiter">)</span> &lt;- <a href="#143173" title="(f: ((Types.this.Symbol, Types.this.Symbol)) =&gt; Unit)Unit">fbounds</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">val</span> <a title="String" id="143214">desc</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#143212" title="Types.this.Symbol">p0</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#143213" title="Types.this.Symbol">p1</a><span class="delimiter">)</span> <span title="String(&quot;its own bounds&quot;)" class="string">&quot;its own bounds&quot;</span> <span class="keyword">else</span> <span title="String(&quot;the bounds of &quot;)" class="string">&quot;the bounds of &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#143213" title="Types.this.Symbol">p1</a>

                <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#143212" title="Types.this.Symbol">p0</a>.<a href="Symbols.scala.html#48049" title="=&gt; String">fullLocationString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; appears in &quot;)" class="string">&quot; appears in &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#143214" title="String">desc</a><span class="delimiter">)</span>
                <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;    &quot;)" class="string">&quot;    &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#143213" title="Types.this.Symbol">p1</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#143213" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
              <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="143169">tails</a> = <a href="#143092" title="List[List[Types.this.Type]]">tsBts</a> <span title="(f: List[Types.this.Type] =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a href="#143236" title="List[Types.this.Type]">_</a>.<span title="=&gt; List[Types.this.Type]">tail</span><span class="delimiter">)</span>
          <a href="#40379" title="(tps: List[Types.this.Type], variance: Int, depth: Int)Option[Types.this.Type]">mergePrefixAndArgs</a><span class="delimiter">(</span><a href="#40353" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">elimSub</a><span class="delimiter">(</span><a href="#143105" title="List[Types.this.Type]">ts0</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#142995" title="(tp: Types.this.Type)Types.this.Type">elimHigherOrderTypeParam</a>, <a href="#142991" title="Int">depth</a><span class="delimiter">)</span>, <span title="Int(1)" class="int">1</span>, <a href="#142991" title="Int">depth</a><span class="delimiter">)</span> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="List[Types.this.Type]">Some</span><span class="delimiter">(</span><a title="Types.this.Type" id="143312">tp</a><span class="delimiter">)</span> =&gt; <a href="#143312" title="Types.this.Type">tp</a> <a href="#143313" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#142997" title="(tsBts: List[List[Types.this.Type]])List[Types.this.Type]">loop</a><span class="delimiter">(</span><a href="#143169" title="List[List[Types.this.Type]]">tails</a><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="List[Types.this.Type]">_</span>        =&gt; <a href="#142997" title="(tsBts: List[List[Types.this.Type]])List[Types.this.Type]">loop</a><span class="delimiter">(</span><a href="#143169" title="List[List[Types.this.Type]]">tails</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          // frontier is not uniform yet, move it beyond the current minimal symbol;
          // lather, rinSe, repeat
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="143319">sym</a>    = <a href="#40348" title="(tps: List[Types.this.Type])Types.this.Symbol">minSym</a><span class="delimiter">(</span><a href="#143105" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="143320">newtps</a> = <a href="#143092" title="List[List[Types.this.Type]]">tsBts</a> <span title="(f: List[Types.this.Type] =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a title="List[Types.this.Type]" id="143339">ts</a> =&gt; <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#143339" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#143319" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#143339" title="List[Types.this.Type]">ts</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span class="keyword">else</span> <a href="#143339" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#40057" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="String" id="143373">str</a> = <span class="delimiter">(</span><a href="#143320" title="List[List[Types.this.Type]]">newtps</a>.<span title="(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],(List[Types.this.Type], Int),List[(List[Types.this.Type], Int)]])List[(List[Types.this.Type], Int)]">zipWithIndex</span> <span title="(f: ((List[Types.this.Type], Int)) =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[(List[Types.this.Type], Int)],String,List[String]])List[String]">map</span> <a href="#143433" title="String" class="delimiter">{</a> <span class="keyword">case</span> <span title="String" class="delimiter">(</span><a title="List[Types.this.Type]" id="143436">tps</a>, <a title="Int" id="143437">idx</a><span class="delimiter">)</span> =&gt;
              <a href="#143436" title="List[Types.this.Type]">tps</a>.<span title="(f: Types.this.Type =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],String,List[String]])List[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,String,List[String]]" class="delimiter">(</span><span title="String(&quot;        &quot;)" class="string">&quot;        &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#143454" title="Types.this.Type">_</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;   (&quot;)" class="string">&quot;   (&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#143437" title="Int">idx</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)\n&quot;)" class="string">&quot;)\n&quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span>
            <span class="delimiter">}</span><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>

            <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;Frontier(\n&quot;)" class="string">&quot;Frontier(\n&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#143373" title="String">str</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
            <a href="#40345" title="(btsMap: Map[Types.this.Type,List[Types.this.Type]], depth: Int)Unit">printLubMatrix</a><span class="delimiter">(</span><a href="#142990" title="List[Types.this.Type]">ts</a> <span title="(that: scala.collection.GenIterable[List[Types.this.Type]])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],(Types.this.Type, List[Types.this.Type]),List[(Types.this.Type, List[Types.this.Type])]])List[(Types.this.Type, List[Types.this.Type])]">zip</span> <a href="#143092" title="List[List[Types.this.Type]]">tsBts</a> <span title="(implicit ev: &lt;:&lt;[(Types.this.Type, List[Types.this.Type]),(Types.this.Type, List[Types.this.Type])])scala.collection.immutable.Map[Types.this.Type,List[Types.this.Type]]">toMap</span>, <a href="#142996" title="Int">lubListDepth</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>

          <a href="#142997" title="(tsBts: List[List[Types.this.Type]])List[Types.this.Type]">loop</a><span class="delimiter">(</span><a href="#143320" title="List[List[Types.this.Type]]">newtps</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="142998">initialBTSes</a> = <a href="#142990" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a href="#143620" title="Types.this.Type">_</a>.<a href="#42803" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#60849" title="=&gt; List[Types.this.Type]">toList</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a href="#143626" title="Types.this.Type">_</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="HasFlags.scala.html#48094" title="=&gt; Boolean">isPublic</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#40057" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span>
      <a href="#40345" title="(btsMap: Map[Types.this.Type,List[Types.this.Type]], depth: Int)Unit">printLubMatrix</a><span class="delimiter">(</span><a href="#142990" title="List[Types.this.Type]">ts</a> <span title="(that: scala.collection.GenIterable[List[Types.this.Type]])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],(Types.this.Type, List[Types.this.Type]),List[(Types.this.Type, List[Types.this.Type])]])List[(Types.this.Type, List[Types.this.Type])]">zip</span> <a href="#142998" title="List[List[Types.this.Type]]">initialBTSes</a> <span title="(implicit ev: &lt;:&lt;[(Types.this.Type, List[Types.this.Type]),(Types.this.Type, List[Types.this.Type])])scala.collection.immutable.Map[Types.this.Type,List[Types.this.Type]]">toMap</span>, <a href="#142991" title="Int">depth</a><span class="delimiter">)</span>

    <a href="#142997" title="(tsBts: List[List[Types.this.Type]])List[Types.this.Type]">loop</a><span class="delimiter">(</span><a href="#142998" title="List[List[Types.this.Type]]">initialBTSes</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  // @AM the following problem is solved by elimHOTparams in lublist
  // @PP lubLists gone bad: lubList(List(
  //   List(scala.collection.generic.GenericCompanion[scala.collection.immutable.Seq], ScalaObject, java.lang.Object, Any)
  //   List(scala.collection.generic.GenericCompanion[scala.collection.mutable.Seq], ScalaObject, java.lang.Object, Any)
  // )) == (
  //   List(scala.collection.generic.GenericCompanion[Seq**[Any]**], ScalaObject, java.lang.Object, Any)
  // )

  /** The minimal symbol (wrt Symbol.isLess) of a list of types */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type])Types.this.Symbol" id="40348">minSym</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143321">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> =
    <span class="delimiter">(</span><a href="#143321" title="List[Types.this.Type]">tps</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="#143709" title="(z: Types.this.Symbol)(op: (Types.this.Symbol, Types.this.Type) =&gt; Types.this.Symbol)Types.this.Symbol">/:</a> <a href="#143321" title="List[Types.this.Type]">tps</a>.<span title="=&gt; List[Types.this.Type]">tail</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="delimiter">(</span><a title="Types.this.Symbol" id="143725">sym1</a>, <a title="Types.this.Type" id="143726">tp2</a><span class="delimiter">)</span> =&gt; <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#143726" title="Types.this.Type">tp2</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#47961" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#143725" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> <a href="#143726" title="Types.this.Type">tp2</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span class="keyword">else</span> <a href="#143725" title="Types.this.Symbol">sym1</a>
    <span class="delimiter">}</span>

  /** A minimal type list which has a given list of types as its base type sequence */
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="40349">spanningTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143727">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#143727" title="List[Types.this.Type]">ts</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#143730" title="List[Nothing]">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="List[Types.this.Type]" id="143752">first</a> :: <a title="List[Types.this.Type]" id="143753">rest</a> =&gt;
      <a href="#143752" title="Types.this.Type">first</a> <a href="#143754" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#40349" title="(ts: List[Types.this.Type])List[Types.this.Type]">spanningTypes</a><span class="delimiter">(</span>
        <a href="#143753" title="List[Types.this.Type]">rest</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a title="Types.this.Type" id="143758">t</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#143752" title="Types.this.Type">first</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47964" title="(that: Types.this.Symbol)Boolean">isSubClass</a><span class="delimiter">(</span><a href="#143758" title="Types.this.Type">t</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Eliminate from list of types all elements which are a supertype
   *  of some other element of the list. */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="40350">elimSuper</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143762">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#143762" title="List[Types.this.Type]">ts</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#143765" title="List[Nothing]">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="List[Types.this.Type]" id="143787">t</a> :: <a title="List[Types.this.Type]" id="143788">ts1</a> =&gt;
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="143789">rest</a> = <a href="#40350" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSuper</a><span class="delimiter">(</span><a href="#143788" title="List[Types.this.Type]">ts1</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a title="Types.this.Type" id="143793">t1</a> =&gt; <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#143787" title="Types.this.Type">t</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#143793" title="Types.this.Type">t1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#143789" title="List[Types.this.Type]">rest</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a title="Types.this.Type" id="143801">t1</a> =&gt; <a href="#143801" title="Types.this.Type">t1</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#143787" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#143789" title="List[Types.this.Type]">rest</a> <span class="keyword">else</span> <a href="#143787" title="Types.this.Type">t</a> <a href="#143803" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#143789" title="List[Types.this.Type]">rest</a>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(t: Types.this.Type)Types.this.Type" id="40351">elimAnonymousClass</a><span class="delimiter">(</span><a title="Types.this.Type" id="143809">t</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#143809" title="Types.this.Type">t</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="143812">pre</a>, <a title="Types.this.Symbol" id="143813">clazz</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#143813" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#47815" title="=&gt; Boolean">isAnonymousClass</a> =&gt;
      <a href="#143813" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#47943" title="=&gt; Types.this.Type">classBound</a>.<a href="#42778" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#143812" title="Types.this.Type">pre</a>, <a href="#143813" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#47876" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <a href="#143809" title="Types.this.Type">t</a>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(t: Types.this.Type)Types.this.Type" id="40352">elimRefinement</a><span class="delimiter">(</span><a title="Types.this.Type" id="143817">t</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#143817" title="Types.this.Type">t</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143820">parents</a>, <a title="Types.this.Scope" id="143821">decls</a><span class="delimiter">)</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#143821" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61748" title="=&gt; Boolean">isEmpty</a> =&gt; <a href="#40203" title="(tps: List[Types.this.Type])Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="#143820" title="List[Types.this.Type]">parents</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span>                                             =&gt; <a href="#143817" title="Types.this.Type">t</a>
  <span class="delimiter">}</span>

  /** Eliminate from list of types all elements which are a subtype
   *  of some other element of the list. */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]" id="40353">elimSub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143264">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="143265">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="143826">elimSub0</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143828">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#143828" title="List[Types.this.Type]">ts</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#143830" title="List[Nothing]">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="List[Types.this.Type]" id="143852">t</a> :: <a title="List[Types.this.Type]" id="143853">ts1</a> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="143854">rest</a> = <a href="#143826" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSub0</a><span class="delimiter">(</span><a href="#143853" title="List[Types.this.Type]">ts1</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a title="Types.this.Type" id="143858">t1</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#40320" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#143858" title="Types.this.Type">t1</a>, <a href="#143852" title="Types.this.Type">t</a>, <a href="#40056" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#143265" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#143854" title="List[Types.this.Type]">rest</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a title="Types.this.Type" id="143869">t1</a> =&gt; <a href="#40320" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#143852" title="Types.this.Type">t</a>, <a href="#143869" title="Types.this.Type">t1</a>, <a href="#40056" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#143265" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#143854" title="List[Types.this.Type]">rest</a> <span class="keyword">else</span> <a href="#143852" title="Types.this.Type">t</a> <a href="#143874" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#143854" title="List[Types.this.Type]">rest</a>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="List[Types.this.Type]" id="143827">ts0</a> = <a href="#143826" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSub0</a><span class="delimiter">(</span><a href="#143264" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
    <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#143827" title="List[Types.this.Type]">ts0</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#143827" title="List[Types.this.Type]">ts0</a>.<span title="=&gt; List[Types.this.Type]">tail</span>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#143827" title="List[Types.this.Type]">ts0</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="143881">ts1</a> = <a href="#143827" title="List[Types.this.Type]">ts0</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a title="Types.this.Type" id="143888">t</a> =&gt; <a href="#40351" title="(t: Types.this.Type)Types.this.Type">elimAnonymousClass</a><span class="delimiter">(</span><a href="#143888" title="Types.this.Type">t</a>.<a href="#42731" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#143881" title="List[Types.this.Type]">ts1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#143827" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span> <a href="#143827" title="List[Types.this.Type]">ts0</a>
      <span class="keyword">else</span> <a href="#40353" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">elimSub</a><span class="delimiter">(</span><a href="#143881" title="List[Types.this.Type]">ts1</a>, <a href="#143265" title="Int">depth</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])(List[Types.this.Type], List[Types.this.Symbol])" id="40354">stripExistentialsAndTypeVars</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143890">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span>, List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="143892">quantified</a> = <a href="#143890" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">flatMap</span> <a href="#143911" title="List[Types.this.Symbol]" class="delimiter">{</a>
      <span class="keyword">case</span> <span title="List[Types.this.Symbol]">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="143912">qs</a>, _<span class="delimiter">)</span> =&gt; <a href="#143912" title="List[Types.this.Symbol]">qs</a>
      <span class="keyword">case</span> <a title="List[Nothing]" id="143913">t</a> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="143893">stripType</a><span class="delimiter">(</span><a title="Types.this.Type" id="143948">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#143948" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="143949">res</a><span class="delimiter">)</span> =&gt;
        <a href="#143949" title="Types.this.Type">res</a>
      <span class="keyword">case</span> <a href="#84241" title="Types.this.Type">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="143951">constr</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#143951" title="Types.this.TypeConstraint">constr</a>.<a href="#84304" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#143951" title="Types.this.TypeConstraint">constr</a>.<a href="#84302" title="=&gt; Types.this.Type">inst</a>
        <span class="keyword">else</span> <a href="SymbolTable.scala.html#36939" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><span title="String(&quot;trying to do lub/glb of typevar &quot;)" class="string">&quot;trying to do lub/glb of typevar &quot;</span><span title="(x$1: Any)String">+</span><a href="#143948" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="143956">t</a> =&gt; <a href="#143956" title="Types.this.Type">t</a>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="List[Types.this.Type]" id="143894">strippedTypes</a> = <a href="#143890" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <a href="#143893" title="(tp: Types.this.Type)Types.this.Type">stripType</a>
    <span title="(_1: List[Types.this.Type], _2: List[Types.this.Symbol])(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</span><a href="#143894" title="List[Types.this.Type]">strippedTypes</a>, <a href="#143892" title="List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])(Types.this.Type, Boolean)" id="40355">weakLub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143971">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#143971" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#143971" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <a href="Definitions.scala.html#46785" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#40357" title="(ts: List[Types.this.Type])Types.this.Type">numericLub</a><span class="delimiter">(</span><a href="#143971" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#143971" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#143971" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#144010" title="Types.this.Type">_</a>.<a href="#42821" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="AnnotationCheckers.scala.html#36290" title="(tpe: Types.this.Type, ts: List[Types.this.Type])Types.this.Type">annotationsLub</a><span class="delimiter">(</span><a href="#40365" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#143971" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#144038" title="Types.this.Type">_</a>.<a href="#42822" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#143971" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#40365" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#143971" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])(Types.this.Type, Boolean)" id="40356">weakGlb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144078">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#144078" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#144078" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <a href="Definitions.scala.html#46785" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="144088">nglb</a> = <a href="#40358" title="(ts: List[Types.this.Type])Types.this.Type">numericGlb</a><span class="delimiter">(</span><a href="#144078" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
      <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#144088" title="Types.this.Type">nglb</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#144088" title="Types.this.Type">nglb</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#40374" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#144078" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#144078" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#144078" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#144132" title="Types.this.Type">_</a>.<a href="#42821" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="AnnotationCheckers.scala.html#36291" title="(tpe: Types.this.Type, ts: List[Types.this.Type])Types.this.Type">annotationsGlb</a><span class="delimiter">(</span><a href="#40374" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#144078" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#144160" title="Types.this.Type">_</a>.<a href="#42822" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#144078" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#40374" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#144078" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="40357">numericLub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143985">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#143985" title="List[Types.this.Type]">ts</a> <span title="(f: (Types.this.Type, Types.this.Type) =&gt; Types.this.Type)Types.this.Type">reduceLeft</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="144000">t1</a>, <a title="Types.this.Type" id="144001">t2</a><span class="delimiter">)</span> =&gt;
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#40360" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#144000" title="Types.this.Type">t1</a>, <a href="#144001" title="Types.this.Type">t2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#144001" title="Types.this.Type">t2</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#40360" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#144001" title="Types.this.Type">t2</a>, <a href="#144000" title="Types.this.Type">t1</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#144000" title="Types.this.Type">t1</a>
      <span class="keyword">else</span> <a href="Definitions.scala.html#46842" title="=&gt; Types.this.Symbol">IntClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="40358">numericGlb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144089">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#144089" title="List[Types.this.Type]">ts</a> <span title="(f: (Types.this.Type, Types.this.Type) =&gt; Types.this.Type)Types.this.Type">reduceLeft</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="144104">t1</a>, <a title="Types.this.Type" id="144105">t2</a><span class="delimiter">)</span> =&gt;
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#40360" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#144104" title="Types.this.Type">t1</a>, <a href="#144105" title="Types.this.Type">t2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#144104" title="Types.this.Type">t1</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#40360" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#144105" title="Types.this.Type">t2</a>, <a href="#144104" title="Types.this.Type">t1</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#144105" title="Types.this.Type">t2</a>
      <span class="keyword">else</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="40359">isWeakSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="130142">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="130143">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
    <a href="#130142" title="Types.this.Type">tp1</a>.<a href="#42733" title="=&gt; Types.this.Type">deconst</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="130147">sym1</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="Definitions.scala.html#46830" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#130147" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> =&gt;
        <a href="#130143" title="Types.this.Type">tp2</a>.<a href="#42733" title="=&gt; Types.this.Type">deconst</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="130151">sym2</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="Definitions.scala.html#46830" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#130151" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> =&gt;
            <a href="Definitions.scala.html#46829" title="(sub: Types.this.Symbol, sup: Types.this.Symbol)Boolean">isNumericSubClass</a><span class="delimiter">(</span><a href="#130147" title="Types.this.Symbol">sym1</a>, <a href="#130151" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <a title="Boolean" id="130154">tv2</a> @ <a href="#84241" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
            <a href="#130154" title="Types.this.TypeVar">tv2</a>.<a href="#84218" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#130142" title="Types.this.Type">tp1</a>, isLowerBound = <span title="Boolean(true)" class="keyword">true</span>, isNumericBound = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#40319" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a><span class="delimiter">(</span><a href="#130142" title="Types.this.Type">tp1</a>, <a href="#130143" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Boolean" id="130165">tv1</a> @ <a href="#84241" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
        <a href="#130143" title="Types.this.Type">tp2</a>.<a href="#42733" title="=&gt; Types.this.Type">deconst</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="130168">sym2</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="Definitions.scala.html#46830" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#130168" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> =&gt;
            <a href="#130165" title="Types.this.TypeVar">tv1</a>.<a href="#84218" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#130143" title="Types.this.Type">tp2</a>, isLowerBound = <span title="Boolean(false)" class="keyword">false</span>, isNumericBound = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#40319" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a><span class="delimiter">(</span><a href="#130142" title="Types.this.Type">tp1</a>, <a href="#130143" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#40319" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a><span class="delimiter">(</span><a href="#130142" title="Types.this.Type">tp1</a>, <a href="#130143" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  /** The isNumericValueType tests appear redundant, but without them
   *  test/continuations-neg/function3.scala goes into an infinite loop.
   *  (Even if the calls are to typeSymbolDirect.)
   */
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="40360">isNumericSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="137764">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="137765">tp2</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
       <a href="Definitions.scala.html#46785" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#137764" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
    <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#46785" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#137765" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
    <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#46829" title="(sub: Types.this.Symbol, sup: Types.this.Symbol)Boolean">isNumericSubClass</a><span class="delimiter">(</span><a href="#137764" title="Types.this.Type">tp1</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#137765" title="Types.this.Type">tp2</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
  <span class="delimiter">)</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" id="40361">lubResults</a> = <span title="()scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">HashMap</span><span class="delimiter">[</span><span class="delimiter">(</span>Int, List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>, Type<span class="delimiter">]</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" id="40363">glbResults</a> = <span title="()scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">HashMap</span><span class="delimiter">[</span><span class="delimiter">(</span>Int, List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>, Type<span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="40365">lub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="142117">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#142117" title="List[Types.this.Type]">ts</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#144201" title="Types.this.Type">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a>.<a href="Symbols.scala.html#70289" title="=&gt; Types.this.Type">tpe</a>
    <span class="keyword">case</span> <a href="#144213" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="144224">t</a><span class="delimiter">)</span> =&gt; <a href="#144224" title="Types.this.Type">t</a>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#40366" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#142117" title="List[Types.this.Type]">ts</a>, <a href="#40293" title="(ts: List[Types.this.Type])Int">lubDepth</a><span class="delimiter">(</span><a href="#142117" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
        <a href="#40361" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">lubResults</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#40363" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">glbResults</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** The least upper bound wrt &lt;:&lt; of a list of types */
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)Types.this.Type" id="40366">lub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="142123">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="142124">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="144229">lub0</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144232">ts0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40353" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">elimSub</a><span class="delimiter">(</span><a href="#144232" title="List[Types.this.Type]">ts0</a>, <a href="#142124" title="Int">depth</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#144234" title="Types.this.Type">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a>.<a href="Symbols.scala.html#70289" title="=&gt; Types.this.Type">tpe</a>
      <span class="keyword">case</span> <a href="#144246" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="144257">t</a><span class="delimiter">)</span> =&gt; <a href="#144257" title="Types.this.Type">t</a>
      <span class="keyword">case</span> <a title="Types.this.PolyType" id="144258">ts</a> @ PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="144263">tparams</a>, _<span class="delimiter">)</span> :: _ =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="144264">tparams1</a> = <a href="util/Collections.scala.html#39578" title="(xs1: List[Types.this.Symbol], xs2: List[List[Types.this.Type]])(f: (Types.this.Symbol, List[Types.this.Type]) =&gt; Types.this.Symbol)List[Types.this.Symbol]">map2</a><span class="delimiter">(</span><a href="#144263" title="List[Types.this.Symbol]">tparams</a>, <a href="#40381" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[List[Types.this.Type]]">matchingBounds</a><span class="delimiter">(</span><a href="#144258" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#144263" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>.<span title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.GenTraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="144347">tparam</a>, <a title="List[Types.this.Type]" id="144348">bounds</a><span class="delimiter">)</span> =&gt;
          <a href="#144347" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47970" title="=&gt; Types.this.Symbol">cloneSymbol</a>.<a href="Symbols.scala.html#47922" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a><span class="delimiter">(</span><a href="#40375" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#144348" title="List[Types.this.Type]">bounds</a>, <a href="#142124" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#67004" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#144264" title="List[Types.this.Symbol]">tparams1</a>, <a href="#144229" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#40382" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">matchingInstTypes</a><span class="delimiter">(</span><a href="#144258" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#144264" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.MethodType" id="144366">ts</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="144371">params</a>, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="144372">rest</a> =&gt;
        <a href="#66899" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#144371" title="List[Types.this.Symbol]">params</a>, <a href="#144229" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#40383" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span><a href="#144366" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#144371" title="List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#144392" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.NullaryMethodType" id="144420">ts</a> @ NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="144425">rest</a> =&gt;
        <a href="#66963" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#144229" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#40383" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span><a href="#144420" title="collection.immutable.::[Types.this.Type]">ts</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.TypeBounds" id="144426">ts</a> @ TypeBounds<span class="delimiter">(</span>_, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="144431">rest</a> =&gt;
        <a href="#66838" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#40375" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#144426" title="collection.immutable.::[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#144452" title="Types.this.Type">_</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66878" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#142124" title="Int">depth</a><span class="delimiter">)</span>, <a href="#40366" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#144426" title="collection.immutable.::[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#144494" title="Types.this.Type">_</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#142124" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="144522">ts</a> =&gt;
        <a href="#40361" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">lubResults</a> <span title="(key: (Int, List[Types.this.Type]))Option[Types.this.Type]">get</span> <span class="delimiter">(</span><a href="#142124" title="Int">depth</a>, <a href="#144522" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Types.this.Type">Some</span><span class="delimiter">(</span><a title="Types.this.Type" id="144533">lubType</a><span class="delimiter">)</span> =&gt;
            <a href="#144533" title="Types.this.Type">lubType</a>
          <span class="keyword">case</span> <span title="Types.this.Type">None</span> =&gt;
            <a href="#40361" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">lubResults</a><span class="delimiter">(</span><span title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</span><a href="#142124" title="Int">depth</a>, <a href="#144522" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="144534">res</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#142124" title="Int">depth</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#144230" title="(ts0: List[Types.this.Type])Types.this.Type">lub1</a><span class="delimiter">(</span><a href="#144522" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
            <a href="#40361" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">lubResults</a><span class="delimiter">(</span><span title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</span><a href="#142124" title="Int">depth</a>, <a href="#144522" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="#144534" title="Types.this.Type">res</a>
            <a href="#144534" title="Types.this.Type">res</a>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="144230">lub1</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144549">ts0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#144557" title="(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</a><a href="#144556" title="List[Types.this.Type]" id="144557">ts</a>, <a href="#144556" title="List[Types.this.Symbol]" id="144558">tparams</a><span class="delimiter">)</span> = <a href="#40354" title="(ts: List[Types.this.Type])(List[Types.this.Type], List[Types.this.Symbol])">stripExistentialsAndTypeVars</a><span title="(List[Types.this.Type], List[Types.this.Symbol]) @unchecked" class="delimiter">(</span><a href="#144549" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="144559">lubBaseTypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#40347" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">lubList</a><span class="delimiter">(</span><a href="#144557" title="List[Types.this.Type]">ts</a>, <a href="#142124" title="Int">depth</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="144560">lubParents</a> = <a href="#40349" title="(ts: List[Types.this.Type])List[Types.this.Type]">spanningTypes</a><span class="delimiter">(</span><a href="#144559" title="List[Types.this.Type]">lubBaseTypes</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="144561">lubOwner</a> = <a href="#40281" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#144557" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="144562">lubBase</a> = <a href="#40202" title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="#144560" title="List[Types.this.Type]">lubParents</a>, <a href="#144561" title="Types.this.Symbol">lubOwner</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="144563">lubType</a> =
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#142124" title="Int">depth</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#144562" title="Types.this.Type">lubBase</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="144588">lubRefined</a>  = <a href="#40196" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#144560" title="List[Types.this.Type]">lubParents</a>, <a href="#144561" title="Types.this.Symbol">lubOwner</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="144589">lubThisType</a> = <a href="#144588" title="Types.this.Type">lubRefined</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47980" title="=&gt; Types.this.Type">thisType</a>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="144590">narrowts</a>    = <a href="#144557" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#144615" title="Types.this.Type">_</a>.<a href="#42735" title="=&gt; Types.this.Type">narrow</a><span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="144591">excludeFromLub</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="144643">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
               <a href="#144643" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47757" title="=&gt; Boolean">isClass</a>
            <span title="(x: Boolean)Boolean">||</span> <a href="#144643" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47804" title="=&gt; Boolean">isConstructor</a>
            <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#144643" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#48094" title="=&gt; Boolean">isPublic</a>
            <span title="(x: Boolean)Boolean">||</span> <a href="Definitions.scala.html#46831" title="(sym: Types.this.Symbol)Boolean">isGetClass</a><span class="delimiter">(</span><a href="#144643" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <span title="(x: Boolean)Boolean">||</span> <a href="#144590" title="List[Types.this.Type]">narrowts</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a title="Types.this.Type" id="144651">t</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#144593" title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean">refines</a><span class="delimiter">(</span><a href="#144651" title="Types.this.Type">t</a>, <a href="#144643" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(proto: Types.this.Symbol)Types.this.Symbol" id="144592">lubsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="144654">proto</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="144655">prototp</a> = <a href="#144589" title="Types.this.Type">lubThisType</a>.<a href="#42779" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#144654" title="Types.this.Symbol">proto</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="144656">syms</a> = <a href="#144590" title="List[Types.this.Type]">narrowts</a> <span title="(f: Types.this.Type =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <span class="delimiter">(</span><a title="Types.this.Type" id="144673">t</a> =&gt;
              <a href="#144673" title="Types.this.Type">t</a>.<a href="#42770" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#144654" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#47969" title="(cond: Types.this.Symbol =&gt; Boolean)Types.this.Symbol">suchThat</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="144676">sym</a> =&gt;
                <a href="#144676" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a> <a href="#42801" title="(that: Types.this.Type)Boolean">matches</a> <a href="#144655" title="Types.this.Type">prototp</a>.<a href="#42784" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#144589" title="Types.this.Type">lubThisType</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#144673" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#144656" title="List[Types.this.Symbol]">syms</a> <span title="(elem: Any)Boolean">contains</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a>
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="List[Types.this.Type]" id="144708">symtypes</a> =
                <a href="util/Collections.scala.html#39578" title="(xs1: List[Types.this.Type], xs2: List[Types.this.Symbol])(f: (Types.this.Type, Types.this.Symbol) =&gt; Types.this.Type)List[Types.this.Type]">map2</a><span class="delimiter">(</span><a href="#144590" title="List[Types.this.Type]">narrowts</a>, <a href="#144656" title="List[Types.this.Symbol]">syms</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="144743">t</a>, <a title="Types.this.Symbol" id="144744">sym</a><span class="delimiter">)</span> =&gt; <a href="#144743" title="Types.this.Type">t</a>.<a href="#42779" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#144744" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#42784" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#144743" title="Types.this.Type">t</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#144589" title="Types.this.Type">lubThisType</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#144654" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#47755" title="=&gt; Boolean">isTerm</a><span class="delimiter">)</span> // possible problem: owner of info is still the old one, instead of new refinement class
                <a href="#144654" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#47971" title="(owner: Types.this.Symbol)Types.this.Symbol">cloneSymbol</a><span class="delimiter">(</span><a href="#144588" title="Types.this.Type">lubRefined</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#47925" title="(info: Types.this.Type)Types.this.Symbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span><a href="#40366" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#144708" title="List[Types.this.Type]">symtypes</a>, <a href="#40056" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#142124" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#144708" title="List[Types.this.Type]">symtypes</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#144708" title="List[Types.this.Type]">symtypes</a>.<a href="#144772" title="=&gt; Types.this.Type">head</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#144654" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#47971" title="(owner: Types.this.Symbol)Types.this.Symbol">cloneSymbol</a><span class="delimiter">(</span><a href="#144588" title="Types.this.Type">lubRefined</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#47925" title="(info: Types.this.Type)Types.this.Symbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span><a href="#144708" title="List[Types.this.Type]">symtypes</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span class="delimiter">{</span>
                <span class="keyword">def</span> <a title="(bnds: List[Types.this.TypeBounds])Types.this.TypeBounds" id="144778">lubBounds</a><span class="delimiter">(</span><a title="List[Types.this.TypeBounds]" id="144779">bnds</a>: <span title="List[Types.this.TypeBounds]">List</span><span class="delimiter">[</span>TypeBounds<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#66864" title="Types.this.TypeBounds">TypeBounds</a> =
                  <a href="#66838" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#40375" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#144779" title="List[Types.this.TypeBounds]">bnds</a> <span title="(f: Types.this.TypeBounds =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeBounds],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#144800" title="Types.this.TypeBounds">_</a>.<a href="#66878" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#40056" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#142124" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#40366" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#144779" title="List[Types.this.TypeBounds]">bnds</a> <span title="(f: Types.this.TypeBounds =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeBounds],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#144842" title="Types.this.TypeBounds">_</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#40056" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#142124" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#144588" title="Types.this.Type">lubRefined</a>.<a href="#42728" title="Types.this.Symbol" id="144880">typeSymbol</a>.<a href="Symbols.scala.html#75714" title="Long" id="144883">newAbstractType</a><span class="delimiter">(</span><a href="#144654" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#53413" title="Types.this.TypeName" id="144881">toTypeName</a>, <a href="#144654" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#47694" title="Types.this.Position" id="144882">pos</a><span class="delimiter">)</span>
                  .<a href="Symbols.scala.html#47925" title="(info: Types.this.Type)Types.this.Symbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span><a href="#144778" title="(bnds: List[Types.this.TypeBounds])Types.this.TypeBounds">lubBounds</a><span class="delimiter">(</span><a href="#144708" title="List[Types.this.Type]">symtypes</a> <span title="(f: Types.this.Type =&gt; Types.this.TypeBounds)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.TypeBounds,List[Types.this.TypeBounds]])List[Types.this.TypeBounds]">map</span> <span class="delimiter">(</span><a href="#144900" title="Types.this.Type">_</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean" id="144593">refines</a><span class="delimiter">(</span><a title="Types.this.Type" id="144652">tp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="144653">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="144928">syms</a> = <a href="#144652" title="Types.this.Type">tp</a>.<a href="#42770" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#144653" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#47967" title="=&gt; List[Types.this.Symbol]">alternatives</a>;
            <span title="=&gt; Boolean">!</span><a href="#144928" title="List[Types.this.Symbol]">syms</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#144928" title="List[Types.this.Symbol]">syms</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="144936">alt</a> =&gt;
              // todo alt != sym is strictly speaking not correct, but without it we lose
              // efficiency.
              <a href="#144936" title="Types.this.Symbol">alt</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#144653" title="Types.this.Symbol">sym</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#40333" title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#144589" title="Types.this.Type">lubThisType</a>, <a href="#144653" title="Types.this.Symbol">sym</a>, <a href="#144652" title="Types.this.Type">tp</a>, <a href="#144936" title="Types.this.Symbol">alt</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          // add a refinement symbol for all non-class members of lubBase
          // which are refined by every type in ts.
          <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="144955">sym</a> &lt;- <a href="#144562" title="Types.this.Type">lubBase</a>.<a href="#42765" title="(f: Types.this.Symbol =&gt; Unit)Unit">nonPrivateMembers</a> ; <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#144591" title="(sym: Types.this.Symbol)Boolean">excludeFromLub</a><span class="delimiter">(</span><a href="#144955" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">try</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Symbol" id="144956">lsym</a> = <a href="#144592" title="(proto: Types.this.Symbol)Types.this.Symbol">lubsym</a><span class="delimiter">(</span><a href="#144955" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
              <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#144956" title="Types.this.Symbol">lsym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#40380" title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol)Unit">addMember</a><span class="delimiter">(</span><a href="#144589" title="Types.this.Type">lubThisType</a>, <a href="#144588" title="Types.this.Type">lubRefined</a>, <a href="#144956" title="Types.this.Symbol">lsym</a><span class="delimiter">)</span>
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <a title="Unit" id="144961">ex</a>: <a href="#40385" title="Types.this.NoCommonType">NoCommonType</a> =&gt;
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#144588" title="Types.this.Type">lubRefined</a>.<a href="#42760" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61748" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#144562" title="Types.this.Type">lubBase</a>
          <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span title="Boolean(true)">verifyLubs</span><span class="delimiter">)</span> <a href="#144588" title="Types.this.Type">lubRefined</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            // Verify that every given type conforms to the calculated lub.
            // In theory this should not be necessary, but higher-order type
            // parameters are not handled correctly.
            <span class="keyword">val</span> <a title="Boolean" id="144967">ok</a> = <a href="#144557" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">{</span> <a title="Types.this.Type" id="144974">t</a> =&gt;
              <span class="delimiter">(</span><a href="#144974" title="Types.this.Type">t</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#144588" title="Types.this.Type">lubRefined</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">{</span>
                <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75538" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">||</span> <a href="#40057" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <span title="object Console">Console</span>.<span title="(x: Any)Unit">println</span><span class="delimiter">(</span>
                    <span title="String(&quot;Malformed lub: &quot;)" class="string">&quot;Malformed lub: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#144588" title="Types.this.Type">lubRefined</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span> <span title="(x$1: Any)String">+</span>
                    <span title="String(&quot;Argument &quot;)" class="string">&quot;Argument &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#144974" title="Types.this.Type">t</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; does not conform.  Falling back to &quot;)" class="string">&quot; does not conform.  Falling back to &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#144562" title="Types.this.Type">lubBase</a>
                  <span class="delimiter">)</span>
                <span class="delimiter">}</span>
                <span title="Boolean(false)" class="keyword">false</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            // If not, fall back on the more conservative calculation.
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#144967" title="Boolean">ok</a><span class="delimiter">)</span> <a href="#144588" title="Types.this.Type">lubRefined</a>
            <span class="keyword">else</span> <a href="#144562" title="Types.this.Type">lubBase</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <a href="#40208" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#144558" title="List[Types.this.Symbol]">tparams</a>, <a href="#144563" title="Types.this.Type">lubType</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#40057" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#40389" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;lub of &quot;)" class="string">&quot;lub of &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#142123" title="List[Types.this.Type]">ts</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; at depth &quot;)" class="string">&quot; at depth &quot;</span><span title="(x$1: Any)String">+</span><a href="#142124" title="Int">depth</a><span class="delimiter">)</span>//debug
      <a href="#40389" title="(x$1: String)Unit">indent</a> = <a href="#40389" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#40389" title="=&gt; String">indent</a>.<span title="()Int">length</span> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(100)" class="int">100</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="Types.this.Type" id="144231">res</a> = <a href="#144229" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#142123" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#40057" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#40389" title="(x$1: String)Unit">indent</a> = <a href="#40389" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">indent</a> <span title="(suffix: String)String">stripSuffix</span> <span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
      <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#40389" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;lub of &quot;)" class="string">&quot;lub of &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#142123" title="List[Types.this.Type]">ts</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; is &quot;)" class="string">&quot; is &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#144231" title="Types.this.Type">res</a><span class="delimiter">)</span>//debug
    <span class="delimiter">}</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#142123" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#145001" title="Types.this.Type">_</a>.<a href="#42717" title="=&gt; Boolean">isNotNull</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#144231" title="Types.this.Type">res</a>.<a href="#42754" title="=&gt; Types.this.Type">notNull</a> <span class="keyword">else</span> <a href="#144231" title="Types.this.Type">res</a>
  <span class="delimiter">}</span>

  <span class="keyword">val</span> <a title="Throwable" id="40367">GlbFailure</a> = <span title="Throwable" class="keyword">new</span> <span title="Throwable">Throwable</span>

  /** A global counter for glb calls in the `specializes` query connected to the `addMembers`
   *  call in `glb`. There's a possible infinite recursion when `specializes` calls
   *  memberType, which calls baseTypeSeq, which calls mergePrefixAndArgs, which calls glb.
   *  The counter breaks this recursion after two calls.
   *  If the recursion is broken, no member is added to the glb.
   */
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="40370">globalGlbDepth</a> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(2)" id="40372">globalGlbLimit</a> = <span title="Int(2)" class="int">2</span>

  /** The greatest lower bound wrt &lt;:&lt; of a list of types */
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="40374">glb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="142099">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40350" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSuper</a><span class="delimiter">(</span><a href="#142099" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#145003" title="Types.this.Type">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>
    <span class="keyword">case</span> <a href="#145015" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="145026">t</a><span class="delimiter">)</span> =&gt; <a href="#145026" title="Types.this.Type">t</a>
    <span class="keyword">case</span> <a title="Types.this.Type" id="145027">ts0</a> =&gt;
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#40376" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glbNorm</a><span class="delimiter">(</span><a href="#145027" title="List[Types.this.Type]">ts0</a>, <a href="#40293" title="(ts: List[Types.this.Type])Int">lubDepth</a><span class="delimiter">(</span><a href="#145027" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
        <a href="#40361" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">lubResults</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#40363" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">glbResults</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)Types.this.Type" id="40375">glb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="142105">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="142106">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#40350" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSuper</a><span class="delimiter">(</span><a href="#142105" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#145032" title="Types.this.Type">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>
    <span class="keyword">case</span> <a href="#145044" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="145055">t</a><span class="delimiter">)</span> =&gt; <a href="#145055" title="Types.this.Type">t</a>
    <span class="keyword">case</span> <a title="Types.this.Type" id="145056">ts0</a> =&gt; <a href="#40376" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glbNorm</a><span class="delimiter">(</span><a href="#145056" title="List[Types.this.Type]">ts0</a>, <a href="#142106" title="Int">depth</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** The greatest lower bound wrt &lt;:&lt; of a list of types, which have been normalized
   *  wrt elimSuper */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)Types.this.Type" id="40376">glbNorm</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="145028">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="145029">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="145057">glb0</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="145060">ts0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#145060" title="List[Types.this.Type]">ts0</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#145062" title="Types.this.Type">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>
      <span class="keyword">case</span> <a href="#145074" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="145085">t</a><span class="delimiter">)</span> =&gt; <a href="#145085" title="Types.this.Type">t</a>
      <span class="keyword">case</span> <a title="Types.this.PolyType" id="145086">ts</a> @ PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="145091">tparams</a>, _<span class="delimiter">)</span> :: _ =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="145092">tparams1</a> = <a href="util/Collections.scala.html#39578" title="(xs1: List[Types.this.Symbol], xs2: List[List[Types.this.Type]])(f: (Types.this.Symbol, List[Types.this.Type]) =&gt; Types.this.Symbol)List[Types.this.Symbol]">map2</a><span class="delimiter">(</span><a href="#145091" title="List[Types.this.Symbol]">tparams</a>, <a href="#40381" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[List[Types.this.Type]]">matchingBounds</a><span class="delimiter">(</span><a href="#145086" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#145091" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>.<span title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.GenTraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="145164">tparam</a>, <a title="List[Types.this.Type]" id="145165">bounds</a><span class="delimiter">)</span> =&gt;
          <a href="#145164" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47970" title="=&gt; Types.this.Symbol">cloneSymbol</a>.<a href="Symbols.scala.html#47922" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a><span class="delimiter">(</span><a href="#40366" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#145165" title="List[Types.this.Type]">bounds</a>, <a href="#145029" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#67004" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#145092" title="List[Types.this.Symbol]">tparams1</a>, <a href="#40376" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glbNorm</a><span class="delimiter">(</span><a href="#40382" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">matchingInstTypes</a><span class="delimiter">(</span><a href="#145086" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#145092" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>, <a href="#145029" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.MethodType" id="145177">ts</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="145182">params</a>, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="145183">rest</a> =&gt;
        <a href="#66899" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#145182" title="List[Types.this.Symbol]">params</a>, <a href="#40376" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glbNorm</a><span class="delimiter">(</span><a href="#40383" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span><a href="#145177" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#145182" title="List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#145200" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#145029" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.NullaryMethodType" id="145228">ts</a> @ NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="145233">rest</a> =&gt;
        <a href="#66963" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#40376" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glbNorm</a><span class="delimiter">(</span><a href="#40383" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span><a href="#145228" title="collection.immutable.::[Types.this.Type]">ts</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span>, <a href="#145029" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.TypeBounds" id="145234">ts</a> @ TypeBounds<span class="delimiter">(</span>_, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="145239">rest</a> =&gt;
        <a href="#66838" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#40366" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#145234" title="collection.immutable.::[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#145260" title="Types.this.Type">_</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66878" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#145029" title="Int">depth</a><span class="delimiter">)</span>, <a href="#40375" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#145234" title="collection.immutable.::[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#145302" title="Types.this.Type">_</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#145029" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="145330">ts</a> =&gt;
        <a href="#40363" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">glbResults</a> <span title="(key: (Int, List[Types.this.Type]))Option[Types.this.Type]">get</span> <span class="delimiter">(</span><a href="#145029" title="Int">depth</a>, <a href="#145330" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Types.this.Type">Some</span><span class="delimiter">(</span><a title="Types.this.Type" id="145341">glbType</a><span class="delimiter">)</span> =&gt;
            <a href="#145341" title="Types.this.Type">glbType</a>
          <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
            <a href="#40363" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">glbResults</a><span class="delimiter">(</span><span title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</span><a href="#145029" title="Int">depth</a>, <a href="#145330" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a>.<a href="Symbols.scala.html#70289" title="=&gt; Types.this.Type">tpe</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="145342">res</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#145029" title="Int">depth</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a>.<a href="Symbols.scala.html#70289" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#145058" title="(ts0: List[Types.this.Type])Types.this.Type">glb1</a><span class="delimiter">(</span><a href="#145330" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
            <a href="#40363" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">glbResults</a><span class="delimiter">(</span><span title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</span><a href="#145029" title="Int">depth</a>, <a href="#145330" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="#145342" title="Types.this.Type">res</a>
            <a href="#145342" title="Types.this.Type">res</a>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="145058">glb1</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="145357">ts0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a href="#145365" title="(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</a><a href="#145364" title="List[Types.this.Type]" id="145365">ts</a>, <a href="#145364" title="List[Types.this.Symbol]" id="145366">tparams</a><span class="delimiter">)</span> = <a href="#40354" title="(ts: List[Types.this.Type])(List[Types.this.Type], List[Types.this.Symbol])">stripExistentialsAndTypeVars</a><span title="(List[Types.this.Type], List[Types.this.Symbol]) @unchecked" class="delimiter">(</span><a href="#145357" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="145367">glbOwner</a> = <a href="#40281" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#145365" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="(t: Types.this.Type)List[Types.this.Type]" id="145368">refinedToParents</a><span class="delimiter">(</span><a title="Types.this.Type" id="145389">t</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#145389" title="Types.this.Type">t</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="List[Types.this.Type]">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="145390">ps</a>, _<span class="delimiter">)</span> =&gt; <a href="#145390" title="List[Types.this.Type]">ps</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">flatMap</span> <a href="#145368" title="(t: Types.this.Type)List[Types.this.Type]">refinedToParents</a>
          <span class="keyword">case</span> <span title="List[Types.this.Type]">_</span> =&gt; <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#145389" title="Types.this.Type">t</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(t: Types.this.Type)List[Types.this.Scope]" id="145369">refinedToDecls</a><span class="delimiter">(</span><a title="Types.this.Type" id="145442">t</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="List[Types.this.Scope]">List</span><span class="delimiter">[</span>Scope<span class="delimiter">]</span> = <a href="#145442" title="Types.this.Type">t</a> <span title="List[Types.this.Scope]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="List[Types.this.Scope]">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="145443">ps</a>, <a title="Types.this.Scope" id="145444">decls</a><span class="delimiter">)</span> =&gt;
            <span class="keyword">val</span> <a title="List[Types.this.Scope]" id="145445">dss</a> = <a href="#145443" title="List[Types.this.Type]">ps</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Scope])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Scope,List[Types.this.Scope]])List[Types.this.Scope]">flatMap</span> <a href="#145369" title="(t: Types.this.Type)List[Types.this.Scope]">refinedToDecls</a>
            <span title="List[Types.this.Scope]" class="keyword">if</span> <span class="delimiter">(</span><a href="#145444" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61748" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#145445" title="List[Types.this.Scope]">dss</a> <span class="keyword">else</span> <a href="#145444" title="Types.this.Scope">decls</a> <a href="#145490" title="(x: Types.this.Scope)List[Types.this.Scope]">::</a> <a href="#145445" title="List[Types.this.Scope]">dss</a>
          <span class="keyword">case</span> <span title="List[Nothing]">_</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="145370">ts1</a> = <a href="#145365" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">flatMap</span> <a href="#145368" title="(t: Types.this.Type)List[Types.this.Type]">refinedToParents</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="145371">glbBase</a> = <a href="#40202" title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="#145370" title="List[Types.this.Type]">ts1</a>, <a href="#145367" title="Types.this.Symbol">glbOwner</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="145372">glbType</a> =
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#145029" title="Int">depth</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#145371" title="Types.this.Type">glbBase</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="145555">glbRefined</a> = <a href="#40196" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#145370" title="List[Types.this.Type]">ts1</a>, <a href="#145367" title="Types.this.Symbol">glbOwner</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="145556">glbThisType</a> = <a href="#145555" title="Types.this.Type">glbRefined</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#47980" title="=&gt; Types.this.Type">thisType</a>
            <span class="keyword">def</span> <a title="(proto: Types.this.Symbol)Types.this.Symbol" id="145557">glbsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="145563">proto</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="145564">prototp</a> = <a href="#145556" title="Types.this.Type">glbThisType</a>.<a href="#42779" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#145563" title="Types.this.Symbol">proto</a><span class="delimiter">)</span>
              <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="145565">syms</a> = <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="145577">t</a> &lt;- <a href="#145365" title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">ts</a>;
                    <a title="Types.this.Symbol" id="145593">alt</a> &lt;- <span class="delimiter">(</span><a href="#145577" title="Types.this.Type">t</a>.<a href="#42770" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#145563" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#47967" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">alternatives</a><span class="delimiter">)</span>;
                <span class="keyword">if</span> <a href="#145556" title="Types.this.Type">glbThisType</a>.<a href="#42779" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#145593" title="Types.this.Symbol">alt</a><span class="delimiter">)</span> <a href="#42801" title="(that: Types.this.Type)Boolean">matches</a> <a href="#145564" title="Types.this.Type">prototp</a>
              <span class="delimiter">)</span> <span class="keyword">yield</span> <a href="#145593" title="Types.this.Symbol">alt</a>
              <span class="keyword">val</span> <a title="List[Types.this.Type]" id="145566">symtypes</a> = <a href="#145565" title="List[Types.this.Symbol]">syms</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#145556" title="Types.this.Type">glbThisType</a>.<a href="#42779" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a>
              <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#145566" title="List[Types.this.Type]">symtypes</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
              <a href="#145563" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#47971" title="(owner: Types.this.Symbol)Types.this.Symbol">cloneSymbol</a><span class="delimiter">(</span><a href="#145555" title="Types.this.Type">glbRefined</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#47925" title="(info: Types.this.Type)Types.this.Symbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span>
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#145563" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#47755" title="=&gt; Boolean">isTerm</a><span class="delimiter">)</span> <a href="#40375" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#145566" title="List[Types.this.Type]">symtypes</a>, <a href="#40056" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#145029" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span class="delimiter">{</span>
                  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="145703">isTypeBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="145707">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#145707" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
                    <span class="keyword">case</span> <span title="Boolean(true)">TypeBounds</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
                    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
                  <span class="delimiter">}</span>
                  <span class="keyword">def</span> <a title="(bnds: List[Types.this.Type])Types.this.TypeBounds" id="145704">glbBounds</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="145708">bnds</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#66864" title="Types.this.TypeBounds">TypeBounds</a> = <span class="delimiter">{</span>
                    <span class="keyword">val</span> <a title="Types.this.Type" id="145709">lo</a> = <a href="#40366" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#145708" title="List[Types.this.Type]">bnds</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#145731" title="Types.this.Type">_</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66878" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#40056" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#145029" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="keyword">val</span> <a title="Types.this.Type" id="145710">hi</a> = <a href="#40375" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#145708" title="List[Types.this.Type]">bnds</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#145773" title="Types.this.Type">_</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#40056" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#145029" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span title="Types.this.TypeBounds" class="keyword">if</span> <span class="delimiter">(</span><a href="#145709" title="Types.this.Type">lo</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#145710" title="Types.this.Type">hi</a><span class="delimiter">)</span> <a href="#66838" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#145709" title="Types.this.Type">lo</a>, <a href="#145710" title="Types.this.Type">hi</a><span class="delimiter">)</span>
                    <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <a href="#40367" title="=&gt; Throwable">GlbFailure</a>
                  <span class="delimiter">}</span>
                  <span class="keyword">val</span> <a title="List[Types.this.Type]" id="145705">symbounds</a> = <a href="#145566" title="List[Types.this.Type]">symtypes</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <a href="#145703" title="(tp: Types.this.Type)Boolean">isTypeBound</a>
                  <span class="keyword">var</span> <a title="Types.this.Type" id="145706">result</a>: <a href="#40083" title="Types.this.Type">Type</a> =
                    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#145705" title="List[Types.this.Type]">symbounds</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
                      <a href="#131099" title="object Types.this.TypeBounds">TypeBounds</a>.<a href="#66835" title="=&gt; Types.this.TypeBounds">empty</a>
                    <span class="keyword">else</span> <a href="#145704" title="(bnds: List[Types.this.Type])Types.this.TypeBounds">glbBounds</a><span class="delimiter">(</span><a href="#145705" title="List[Types.this.Type]">symbounds</a><span class="delimiter">)</span>
                  <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="145814">t</a> &lt;- <a href="#145566" title="(f: Types.this.Type =&gt; Unit)Unit">symtypes</a> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#145703" title="(tp: Types.this.Type)Boolean">isTypeBound</a><span class="delimiter">(</span><a href="#145814" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#145706" title="Types.this.Type">result</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a> <a href="#66859" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#145814" title="Types.this.Type">t</a><span class="delimiter">)</span> <a href="#145706" title="Types.this.Type">result</a> = <a href="#145814" title="Types.this.Type">t</a>
                    <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <a href="#40367" title="=&gt; Throwable">GlbFailure</a>
                  <a href="#145706" title="Types.this.Type">result</a>
                <span class="delimiter">}</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#40370" title="=&gt; Int">globalGlbDepth</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(2)">globalGlbLimit</span><span class="delimiter">)</span>
              <span class="keyword">try</span> <span class="delimiter">{</span>
                <a href="#40370" title="(x$1: Int)Unit">globalGlbDepth</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
                <span class="keyword">val</span> <a title="List[Types.this.Scope]" id="145820">dss</a> = <a href="#145365" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Scope])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Scope,List[Types.this.Scope]])List[Types.this.Scope]">flatMap</span> <a href="#145369" title="(t: Types.this.Type)List[Types.this.Scope]">refinedToDecls</a>
                <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Scope" id="145882">ds</a> &lt;- <a href="#145820" title="(f: Types.this.Scope =&gt; Unit)Unit">dss</a>; <a title="Types.this.Symbol" id="145893">sym</a> &lt;- <a href="#145882" title="Types.this.Scope">ds</a>.<a href="Scopes.scala.html#61765" title="(f: Types.this.Symbol =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span>
                  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#40370" title="=&gt; Int">globalGlbDepth</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(2)">globalGlbLimit</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#145556" title="Types.this.Type">glbThisType</a> <a href="#42800" title="(sym: Types.this.Symbol)Boolean">specializes</a> <a href="#145893" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="keyword">try</span> <span class="delimiter">{</span>
                      <a href="#40380" title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol)Unit">addMember</a><span class="delimiter">(</span><a href="#145556" title="Types.this.Type">glbThisType</a>, <a href="#145555" title="Types.this.Type">glbRefined</a>, <a href="#145557" title="(proto: Types.this.Symbol)Types.this.Symbol">glbsym</a><span class="delimiter">(</span><a href="#145893" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
                      <span class="keyword">case</span> <a title="Unit" id="145898">ex</a>: <a href="#40385" title="Types.this.NoCommonType">NoCommonType</a> =&gt;
                    <span class="delimiter">}</span>
              <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                <a href="#40370" title="(x$1: Int)Unit">globalGlbDepth</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
              <span class="delimiter">}</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#145555" title="Types.this.Type">glbRefined</a>.<a href="#42760" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#61748" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#145371" title="Types.this.Type">glbBase</a> <span class="keyword">else</span> <a href="#145555" title="Types.this.Type">glbRefined</a>
          <span class="delimiter">}</span>
        <a href="#40208" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#145366" title="List[Types.this.Symbol]">tparams</a>, <a href="#145372" title="Types.this.Type">glbType</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="#40367" title="Types.this.Type">GlbFailure</a> =&gt;
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#145028" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.Type" id="145912">t</a> =&gt; <a href="Definitions.scala.html#46291" title="object Types.this.definitions.NullClass">NullClass</a>.<a href="Symbols.scala.html#70289" title="=&gt; Types.this.Type">tpe</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#145912" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Definitions.scala.html#46291" title="object Types.this.definitions.NullClass">NullClass</a>.<a href="Symbols.scala.html#70289" title="=&gt; Types.this.Type">tpe</a>
          <span class="keyword">else</span> <a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a>.<a href="Symbols.scala.html#70289" title="=&gt; Types.this.Type">tpe</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    // if (settings.debug.value) { println(indent + &quot;glb of &quot; + ts + &quot; at depth &quot;+depth); indent = indent + &quot;  &quot; } //DEBUG

    <span class="keyword">val</span> <a title="Types.this.Type" id="145059">res</a> = <a href="#145057" title="(ts0: List[Types.this.Type])Types.this.Type">glb0</a><span class="delimiter">(</span><a href="#145028" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>

    // if (settings.debug.value) { indent = indent.substring(0, indent.length() - 2); log(indent + &quot;glb of &quot; + ts + &quot; is &quot; + res) }//DEBUG

    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#145028" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#145921" title="Types.this.Type">_</a>.<a href="#42717" title="=&gt; Boolean">isNotNull</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#145059" title="Types.this.Type">res</a>.<a href="#42754" title="=&gt; Types.this.Type">notNull</a> <span class="keyword">else</span> <a href="#145059" title="Types.this.Type">res</a>
  <span class="delimiter">}</span>
  
  /** A list of the typevars in a type. */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)List[Types.this.TypeVar]" id="40377">typeVarsInType</a><span class="delimiter">(</span><a title="Types.this.Type" id="145922">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="List[Types.this.TypeVar]">List</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="List[Types.this.TypeVar]" id="145924">tvs</a>: <span title="List[Types.this.TypeVar]">List</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> = <span title="object Nil">Nil</span>
    <a href="#145922" title="Types.this.Type">tp</a> <a href="#42790" title="(f: Types.this.Type =&gt; Unit)Unit">foreach</a> <a href="#145927" title="Unit" class="delimiter">{</a>
      <span class="keyword">case</span> <a title="Unit" id="145928">t</a>: <a href="#40176" title="Types.this.TypeVar">TypeVar</a> =&gt; <a href="#145924" title="List[Types.this.TypeVar]">tvs</a> <span title="(x: Types.this.TypeVar)List[Types.this.TypeVar]">::=</span> <a href="#145928" title="Types.this.TypeVar">t</a>
      <span class="keyword">case</span> <span title="Unit">_</span>          =&gt; 
    <span class="delimiter">}</span>
    <a href="#145924" title="List[Types.this.TypeVar]">tvs</a>.<span title="=&gt; List[Types.this.TypeVar]">reverse</span>
  <span class="delimiter">}</span>
  /** Make each type var in this type use its original type for comparisons instead
   * of collecting constraints.
   */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)List[Types.this.TypeVar]" id="40378">suspendTypeVarsInType</a><span class="delimiter">(</span><a title="Types.this.Type" id="130369">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="List[Types.this.TypeVar]">List</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="List[Types.this.TypeVar]" id="145941">tvs</a> = <a href="#40377" title="(tp: Types.this.Type)List[Types.this.TypeVar]">typeVarsInType</a><span class="delimiter">(</span><a href="#130369" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    // !!! Is it somehow guaranteed that this will not break under nesting?
    // In general one has to save and restore the contents of the field...
    <a href="#145941" title="List[Types.this.TypeVar]">tvs</a> <span title="(f: Types.this.TypeVar =&gt; Unit)Unit">foreach</span> <span class="delimiter">(</span><a href="#145961" title="Types.this.TypeVar">_</a>.<a href="#84216" title="(x$1: Boolean)Unit">suspended</a> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <a href="#145941" title="List[Types.this.TypeVar]">tvs</a> 
  <span class="delimiter">}</span>

  /** Compute lub (if `variance == 1`) or glb (if `variance == -1`) of given list
   *  of types `tps`. All types in `tps` are typerefs or singletypes
   *  with the same symbol.
   *  Return `Some(x)` if the computation succeeds with result `x`.
   *  Return `None` if the computation fails.
   */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], variance: Int, depth: Int)Option[Types.this.Type]" id="40379">mergePrefixAndArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="61816">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="61817">variance</a>: <span title="Int">Int</span>, <a title="Int" id="61818">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Option[Types.this.Type]">Option</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#61816" title="List[Types.this.Type]">tps</a> <span title="Option[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#145964" title="Some[Types.this.Type]">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="145975">tp</a><span class="delimiter">)</span> =&gt;
      <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#145975" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Option[Types.this.Type]">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="145983">sym</a>, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="145984">rest</a> =&gt;
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="145985">pres</a> = <a href="#61816" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#146005" title="Types.this.Type">_</a>.<a href="#42738" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span> // prefix normalizes automatically
      <span class="keyword">val</span> <a title="Types.this.Type" id="145986">pre</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#61817" title="Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#40366" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#145985" title="List[Types.this.Type]">pres</a>, <a href="#61818" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#40375" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#145985" title="List[Types.this.Type]">pres</a>, <a href="#61818" title="Int">depth</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="145987">argss</a> = <a href="#61816" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a href="#146055" title="Types.this.Type">_</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a>.<a href="#42741" title="=&gt; List[Types.this.Type]">typeArgs</a><span class="delimiter">)</span> // symbol equality (of the tp in tps) was checked using typeSymbol, which normalizes, so should normalize before retrieving arguments
      <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[Types.this.Symbol]" id="145988">capturedParams</a> = <span title="scala.collection.mutable.ListBuffer[Types.this.Symbol]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">ListBuffer</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#145983" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#46442" title="=&gt; Types.this.Symbol">ArrayClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          // special treatment for lubs of array types after erasure:
          // if argss contain one value type and some other type, the lub is Object
          // if argss contain several reference types, the lub is an array over lub of argtypes
          <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#145987" title="List[List[Types.this.Type]]">argss</a> <span title="(p: List[Types.this.Type] =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#146093" title="List[Types.this.Type]">_</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="object None">None</span>  // something is wrong: an array without a type arg.
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[Types.this.Type]" id="146094">args</a> = <a href="#145987" title="List[List[Types.this.Type]]">argss</a> <span title="(f: List[Types.this.Type] =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#146111" title="List[Types.this.Type]">_</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span>
            <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#146094" title="List[Types.this.Type]">args</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#146147" title="Types.this.Type">_</a> <a href="#42799" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#146094" title="List[Types.this.Type]">args</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#40198" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#145986" title="Types.this.Type">pre</a>, <a href="#145983" title="Types.this.Symbol">sym</a>, <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#146094" title="List[Types.this.Type]">args</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword">else</span> <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#146094" title="List[Types.this.Type]">args</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a title="Types.this.Type" id="146165">arg</a> =&gt; <a href="Definitions.scala.html#46780" title="(sym: Types.this.Symbol)Boolean">isValueClass</a><span class="delimiter">(</span><a href="#146165" title="Types.this.Type">arg</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="Definitions.scala.html#46278" title="=&gt; Types.this.Symbol">ObjectClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#40198" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#145986" title="Types.this.Type">pre</a>, <a href="#145983" title="Types.this.Symbol">sym</a>, <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#40365" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#146094" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="146183">args</a> = <a href="util/Collections.scala.html#39578" title="(xs1: List[Types.this.Symbol], xs2: List[List[Types.this.Type]])(f: (Types.this.Symbol, List[Types.this.Type]) =&gt; Types.this.Type)List[Types.this.Type]">map2</a><span class="delimiter">(</span><a href="#145983" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#145987" title="List[List[Types.this.Type]]">argss</a>.<span title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.GenTraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="146256">tparam</a>, <a title="List[Types.this.Type]" id="146257">as</a><span class="delimiter">)</span> =&gt;
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#61818" title="Int">depth</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#146256" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47874" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <a href="#61817" title="Int">variance</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                // Take the intersection of the upper bounds of the type parameters
                // rather than falling all the way back to &quot;Any&quot;, otherwise we end up not
                // conforming to bounds.
                <span class="keyword">val</span> <a title="List[Types.this.Type]" id="146267">bounds0</a> = <a href="#145983" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47940" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#146287" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42736" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#66879" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</span> <span class="delimiter">(</span><a href="#146320" title="Types.this.Type">_</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span>
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#146267" title="List[Types.this.Type]">bounds0</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>
                <span class="keyword">else</span> <a href="#40203" title="(tps: List[Types.this.Type])Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="#146267" title="List[Types.this.Type]">bounds0</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a title="Types.this.Type" id="146346">b</a> =&gt; <a href="#146346" title="Types.this.Type">b</a>.<a href="#42778" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#61816" title="List[Types.this.Type]">tps</a>.<span title="=&gt; Types.this.Type">head</span>, <a href="#145983" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="delimiter">}</span>
              <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#146256" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47874" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="=&gt; Int">-</span><a href="#61817" title="Int">variance</a><span class="delimiter">)</span> <a href="Definitions.scala.html#46289" title="object Types.this.definitions.NothingClass">NothingClass</a>.<a href="Symbols.scala.html#70289" title="=&gt; Types.this.Type">tpe</a>
              <span class="keyword">else</span> <a href="#130794" title="object Types.this.NoType">NoType</a>
            <span class="delimiter">}</span>
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#146256" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47874" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <a href="#61817" title="Int">variance</a><span class="delimiter">)</span> <a href="#40366" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#146257" title="List[Types.this.Type]">as</a>, <a href="#40056" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#61818" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#146256" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47874" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="=&gt; Int">-</span><a href="#61817" title="Int">variance</a><span class="delimiter">)</span> <a href="#40375" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#146257" title="List[Types.this.Type]">as</a>, <a href="#40056" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#61818" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span class="delimiter">{</span>
                <span class="keyword">val</span> <a title="Types.this.Type" id="146399">l</a> = <a href="#40366" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#146257" title="List[Types.this.Type]">as</a>, <a href="#40056" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#61818" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">val</span> <a title="Types.this.Type" id="146400">g</a> = <a href="#40375" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#146257" title="List[Types.this.Type]">as</a>, <a href="#40056" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#61818" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#146399" title="Types.this.Type">l</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#146400" title="Types.this.Type">g</a><span class="delimiter">)</span> <a href="#146399" title="Types.this.Type">l</a>
                <span class="keyword">else</span> <span class="delimiter">{</span> // Martin: I removed this, because incomplete. Not sure there is a good way to fix it. For the moment we
                       // just err on the conservative side, i.e. with a bound that is too high.
                       // if(!(tparam.info.bounds contains tparam))   //@M can't deal with f-bounds, see #2251

                  <span class="keyword">val</span> <a title="Types.this.Symbol" id="146410">qvar</a> = <a href="#40281" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#146257" title="List[Types.this.Type]">as</a><span class="delimiter">)</span> <a href="Symbols.scala.html#47730" title="(suffix: String)Types.this.Symbol">freshExistential</a> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <a href="Symbols.scala.html#47922" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a> <a href="#66838" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#146400" title="Types.this.Type">g</a>, <a href="#146399" title="Types.this.Type">l</a><span class="delimiter">)</span>
                  <a href="#145988" title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">capturedParams</a> <span title="(x: Types.this.Symbol)capturedParams.type">+=</span> <a href="#146410" title="Types.this.Symbol">qvar</a>
                  <a href="#146410" title="Types.this.Symbol">qvar</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#146183" title="List[Types.this.Type]">args</a> <span title="(elem: Any)Boolean">contains</span> <a href="#130794" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="object None">None</span>
          <span class="keyword">else</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#40208" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#145988" title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">capturedParams</a>.<span title="=&gt; List[Types.this.Symbol]">toList</span>, <a href="#40198" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#145986" title="Types.this.Type">pre</a>, <a href="#145983" title="Types.this.Symbol">sym</a>, <a href="#146183" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="None.type" id="146431">ex</a>: <a href="#40386" title="Types.this.MalformedType">MalformedType</a> =&gt; <span title="object None">None</span>
        <span class="keyword">case</span> <a title="None.type" id="146432">ex</a>: <span title="IndexOutOfBoundsException">IndexOutOfBoundsException</span> =&gt;  // transpose freaked out because of irregular argss
        // catching just in case (shouldn't happen, but also doesn't cost us)
        <a href="SymbolTable.scala.html#36941" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><span title="String(&quot;transposed irregular matrix!?&quot;)" class="string">&quot;transposed irregular matrix!?&quot;</span><span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="#61816" title="List[Types.this.Type]">tps</a>, <a href="#145987" title="List[List[Types.this.Type]]">argss</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="object None">None</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> <span title="Option[Types.this.Type]">SingleType</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="146445">sym</a><span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="146446">rest</a> =&gt;
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="146447">pres</a> = <a href="#61816" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#146465" title="Types.this.Type">_</a>.<a href="#42738" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="146448">pre</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#61817" title="Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#40366" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#146447" title="List[Types.this.Type]">pres</a>, <a href="#61818" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#40375" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#146447" title="List[Types.this.Type]">pres</a>, <a href="#61818" title="Int">depth</a><span class="delimiter">)</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#40194" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#146448" title="Types.this.Type">pre</a>, <a href="#146445" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="None.type" id="146508">ex</a>: <a href="#40386" title="Types.this.MalformedType">MalformedType</a> =&gt; <span title="object None">None</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> <span title="Option[Types.this.Type]">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="146513">tparams</a>, <a title="Types.this.Type" id="146514">quantified</a><span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="146515">rest</a> =&gt;
      <a href="#40379" title="(tps: List[Types.this.Type], variance: Int, depth: Int)Option[Types.this.Type]">mergePrefixAndArgs</a><span class="delimiter">(</span><a href="#146514" title="Types.this.Type">quantified</a> <a href="#146516" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#146515" title="List[Types.this.Type]">rest</a>, <a href="#61817" title="Int">variance</a>, <a href="#61818" title="Int">depth</a><span class="delimiter">)</span> <span title="(f: Types.this.Type =&gt; Types.this.Type)Option[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#40208" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#146513" title="List[Types.this.Symbol]">tparams</a>, <a href="#146526" title="Types.this.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="None.type">_</span> =&gt;
      <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span>, <a href="#61816" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>; <span title="object None">None</span>
  <span class="delimiter">}</span>

  /** Make symbol `sym` a member of scope `tp.decls`
   *  where `thistp` is the narrowed owner type of the scope.
   */
  <span class="keyword">def</span> <a title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol)Unit" id="40380">addMember</a><span class="delimiter">(</span><a title="Types.this.Type" id="115060">thistp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="115061">tp</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="115062">sym</a>: <a href="Symbols.scala.html#40001" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#115062" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Symbols.scala.html#40013" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
    // debuglog(&quot;add member &quot; + sym+&quot;:&quot;+sym.info+&quot; to &quot;+thistp) //DEBUG
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#115060" title="Types.this.Type">thistp</a> <a href="#42800" title="(sym: Types.this.Symbol)Boolean">specializes</a> <a href="#115062" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#115062" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47755" title="=&gt; Boolean">isTerm</a><span class="delimiter">)</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="146557">alt</a> &lt;- <a href="#115061" title="Types.this.Type">tp</a>.<a href="#42763" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateDecl</a><span class="delimiter">(</span><a href="#115062" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#47883" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#47967" title="(f: Types.this.Symbol =&gt; Unit)Unit">alternatives</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#40333" title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#115060" title="Types.this.Type">thistp</a>, <a href="#115062" title="Types.this.Symbol">sym</a>, <a href="#115060" title="Types.this.Type">thistp</a>, <a href="#146557" title="Types.this.Symbol">alt</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#115061" title="Types.this.Type">tp</a>.<a href="#42760" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#61758" title="(sym: Types.this.Symbol)Unit">unlink</a> <a href="#146557" title="Types.this.Symbol">alt</a>;
      <a href="#115061" title="Types.this.Type">tp</a>.<a href="#42760" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#61752" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#115062" title="Types.this.Symbol">sym</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** All types in list must be polytypes with type parameter lists of
   *  same length as tparams.
   *  Returns list of list of bounds infos, where corresponding type
   *  parameters are renamed to tparams.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[List[Types.this.Type]]" id="40381">matchingBounds</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144279">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="144280">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[List[Types.this.Type]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)List[Types.this.Type]" id="146570">getBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="146571">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#146571" title="Types.this.Type">tp</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="List[Types.this.Type]">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="146572">tparams1</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#146572" title="List[Types.this.Symbol]">tparams1</a>, <a href="#144280" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> =&gt;
        <a href="#146572" title="List[Types.this.Symbol]">tparams1</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="146591">tparam</a> =&gt; <a href="#146591" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#47920" title="=&gt; Types.this.Type">info</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#146572" title="List[Types.this.Symbol]">tparams1</a>, <a href="#144280" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="List[Types.this.Type]" id="146619">tp</a> =&gt;
        <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#146619" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#146619" title="Types.this.Type">tp</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#146570" title="(tp: Types.this.Type)List[Types.this.Type]">getBounds</a><span class="delimiter">(</span><a href="#146619" title="Types.this.Type">tp</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <span title="Types.this.NoCommonType" class="keyword">new</span> <a href="#40385" title="Types.this.NoCommonType">NoCommonType</a><span class="delimiter">(</span><a href="#144279" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#144279" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <a href="#146570" title="(tp: Types.this.Type)List[Types.this.Type]">getBounds</a>
  <span class="delimiter">}</span>

  /** All types in list must be polytypes with type parameter lists of
   *  same length as tparams.
   *  Returns list of instance types, where corresponding type
   *  parameters are renamed to tparams.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]" id="40382">matchingInstTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144363">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="144364">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="146665">transformResultType</a><span class="delimiter">(</span><a title="Types.this.Type" id="146666">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> = <a href="#146666" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="146667">tparams1</a>, <a title="Types.this.Type" id="146668">restpe</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#40309" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#146667" title="List[Types.this.Symbol]">tparams1</a>, <a href="#144364" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> =&gt;
        <a href="#146668" title="Types.this.Type">restpe</a>.<a href="#42783" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#146667" title="List[Types.this.Symbol]">tparams1</a>, <a href="#144364" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="146671">tp</a> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#146671" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#146671" title="Types.this.Type">tp</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#146665" title="(tp: Types.this.Type)Types.this.Type">transformResultType</a><span class="delimiter">(</span><a href="#146671" title="Types.this.Type">tp</a>.<a href="#42758" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <span title="Types.this.NoCommonType" class="keyword">new</span> <a href="#40385" title="Types.this.NoCommonType">NoCommonType</a><span class="delimiter">(</span><a href="#144363" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#144363" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#146665" title="(tp: Types.this.Type)Types.this.Type">transformResultType</a>
  <span class="delimiter">}</span>

  /** All types in list must be method types with equal parameter types.
   *  Returns list of their result types.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]" id="40383">matchingRestypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144373">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="144374">pts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> =
    <a href="#144373" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#146732" title="Types.this.Type" class="delimiter">{</a>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="146733">params1</a>, <a title="Types.this.Type" id="146734">res</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#40308" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span><a href="#146733" title="List[Types.this.Symbol]">params1</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#146751" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>, <a href="#144374" title="List[Types.this.Type]">pts</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <a href="#146734" title="Types.this.Type">res</a>
      <span class="keyword">case</span> <span title="Types.this.Type">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="146779">res</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#144374" title="List[Types.this.Type]">pts</a> <span title="=&gt; Boolean">isEmpty</span> =&gt;
        <a href="#146779" title="Types.this.Type">res</a>
      <span class="keyword">case</span> <span title="Nothing">_</span> =&gt;
        <span title="Nothing" class="keyword">throw</span> <span title="Types.this.NoCommonType" class="keyword">new</span> <a href="#40385" title="Types.this.NoCommonType">NoCommonType</a><span class="delimiter">(</span><a href="#144373" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

// Errors and Diagnostics -----------------------------------------------------

  /** A throwable signalling a type error */
  <span class="keyword">class</span> <a title="class TypeError extends Throwable with ScalaObject" id="40384">TypeError</a><a href="#40384" title="ScalaObject" class="delimiter">(</a><span class="keyword">var</span> <a title="Types.this.Position" id="67279">pos</a>: <span title="Types.this.Position">Position</span>, <span class="keyword">val</span> <a title="String" id="67280">msg</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="Throwable">Throwable</span><span class="delimiter">(</span><a href="#67280" title="String">msg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(msg: String)Types.this.TypeError" id="67275" class="keyword">this</a><span class="delimiter">(</span><a title="String" id="67278">msg</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#40384" title="TypeError.this.type" class="keyword">this</a><span class="delimiter">(</span><a href="#8614" title="=&gt; Types.this.Position">NoPosition</a>, <a href="#67278" title="String">msg</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class NoCommonType extends Throwable with scala.util.control.ControlThrowable with ScalaObject" id="40385">NoCommonType</a><a href="#40385" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Type]" id="146620">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="Throwable">Throwable</span><span class="delimiter">(</span>
    <span title="String(&quot;lub/glb of incompatible types: &quot;)" class="string">&quot;lub/glb of incompatible types: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#146620" title="List[Types.this.Type]">tps</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="String(&quot; and &quot;)" class="string">&quot; and &quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">with</span> <span title="scala.util.control.ControlThrowable">ControlThrowable</span>

  /** A throwable signalling a malformed type */
  <span class="keyword">class</span> <a title="class MalformedType extends Types.this.TypeError with ScalaObject" id="40386">MalformedType</a><a href="#67275" title="ScalaObject" class="delimiter">(</a><a title="String" id="140685">msg</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40384" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><a href="#140685" title="String">msg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, tp: String)Types.this.MalformedType" id="139793" class="keyword">this</a><span class="delimiter">(</span><a title="Types.this.Type" id="140683">pre</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="String" id="140684">tp</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#40386" title="MalformedType.this.type" class="keyword">this</a><span class="delimiter">(</span><span title="String(&quot;malformed type: &quot;)" class="string">&quot;malformed type: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#140683" title="Types.this.Type">pre</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#140684" title="String">tp</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** An exception signalling a variance annotation/usage conflict */
  <span class="keyword">class</span> <a title="class VarianceError extends Types.this.TypeError with ScalaObject" id="40387">VarianceError</a><a href="#67275" title="ScalaObject" class="delimiter">(</a><a title="String" id="146855">msg</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#40384" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><a href="#146855" title="String">msg</a><span class="delimiter">)</span>

  /** The current indentation string for traces */
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="String" id="40389">indent</a>: <span title="String">String</span> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>

  /** Perform operation `p` on arguments `tp1`, `arg2` and print trace of computation. */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T](op: String, p: (Types.this.Type, T) =&gt; Boolean, tp1: Types.this.Type, arg2: T)Boolean" id="40391">explain</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40393">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="129987">op</a>: <span title="String">String</span>, <a title="(Types.this.Type, T) =&gt; Boolean" id="129988">p</a>: <span class="delimiter">(</span>Type, T<span class="delimiter">)</span> =&gt; Boolean, <a title="Types.this.Type" id="129989">tp1</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="T" id="129990">arg2</a>: <a href="#40393" title="T">T</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span title="object Console">Console</span>.<span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#40389" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <a href="#129989" title="Types.this.Type">tp1</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#129987" title="String">op</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#129990" title="T">arg2</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span> /* + &quot;(&quot;+tp1.getClass+&quot;,&quot;+arg2.getClass+&quot;)&quot;*/<span class="delimiter">)</span>
    <a href="#40389" title="(x$1: String)Unit">indent</a> = <a href="#40389" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
    <span class="keyword">val</span> <a title="Boolean" id="146859">result</a> = <a href="#129988" title="(v1: Types.this.Type, v2: T)Boolean">p</a><span class="delimiter">(</span><a href="#129989" title="Types.this.Type">tp1</a>, <a href="#129990" title="T">arg2</a><span class="delimiter">)</span>
    <a href="#40389" title="(x$1: String)Unit">indent</a> = <a href="#40389" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">indent</a> <span title="(suffix: String)String">stripSuffix</span> <span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
    <span title="object Console">Console</span>.<span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#40389" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <a href="#146859" title="Boolean">result</a><span class="delimiter">)</span>
    <a href="#146859" title="Boolean">result</a>
  <span class="delimiter">}</span>

  /** If option `explaintypes` is set, print a subtype trace for `found &lt;:&lt; required`. */
  <span class="keyword">def</span> <a title="(found: Types.this.Type, required: Types.this.Type)Unit" id="40394">explainTypes</a><span class="delimiter">(</span><a title="Types.this.Type" id="146869">found</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="146870">required</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75540" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">explaintypes</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#40396" title="(op: =&gt; Boolean)Boolean">withTypesExplained</a><span title="Unit" class="delimiter">(</span><a href="#146869" title="Types.this.Type">found</a> <a href="#42795" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#146870" title="Types.this.Type">required</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** If option `explaintypes` is set, print a subtype trace for `op(found, required)`. */
  <span class="keyword">def</span> <a title="(op: (Types.this.Type, Types.this.Type) =&gt; Any, found: Types.this.Type, required: Types.this.Type)Unit" id="40395">explainTypes</a><span class="delimiter">(</span><a title="(Types.this.Type, Types.this.Type) =&gt; Any" id="146882">op</a>: <span class="delimiter">(</span>Type, Type<span class="delimiter">)</span> =&gt; Any, <a title="Types.this.Type" id="146883">found</a>: <a href="#40083" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="146884">required</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#40687" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#75540" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">explaintypes</a>.<a href="settings/MutableSettings.scala.html#75565" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#40396" title="(op: =&gt; Any)Any">withTypesExplained</a><span title="Unit" class="delimiter">(</span><a href="#146882" title="(v1: Types.this.Type, v2: Types.this.Type)Any">op</a><span class="delimiter">(</span><a href="#146883" title="Types.this.Type">found</a>, <a href="#146884" title="Types.this.Type">required</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Execute `op` while printing a trace of the operations on types executed. */
  <span class="keyword">def</span> <a title="[A](op: =&gt; A)A" id="40396">withTypesExplained</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40398">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="146875">op</a>: =&gt; A<span class="delimiter">)</span>: <a href="#40398" title="A">A</a> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Boolean" id="146894">s</a> = <a href="#40044" title="=&gt; Boolean">explainSwitch</a>
    <span class="keyword">try</span> <span class="delimiter">{</span> <a href="#40044" title="(x$1: Boolean)Unit">explainSwitch</a> = <span title="Boolean(true)" class="keyword">true</span>; <a href="#146875" title="=&gt; A">op</a> <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span> <a href="#40044" title="(x$1: Boolean)Unit">explainSwitch</a> = <a href="#146894" title="Boolean">s</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="40399">objToAny</a><span class="delimiter">(</span><a title="Types.this.Type" id="146895">tp</a>: <a href="#40083" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#40083" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#36963" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#70383" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#146895" title="Types.this.Type">tp</a>.<a href="#42728" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#46278" title="=&gt; Types.this.Symbol">ObjectClass</a><span class="delimiter">)</span> <a href="Definitions.scala.html#46274" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#47918" title="=&gt; Types.this.Type">tpe</a>
    <span class="keyword">else</span> <a href="#146895" title="Types.this.Type">tp</a>

  <span class="keyword">val</span> <a title="scala.collection.immutable.Set[String]" id="40400">shorthands</a> = <span title="(elems: String*)scala.collection.immutable.Set[String]">Set</span><span class="delimiter">(</span>
    <span title="String(&quot;scala.collection.immutable.List&quot;)" class="string">&quot;scala.collection.immutable.List&quot;</span>,
    <span title="String(&quot;scala.collection.immutable.Nil&quot;)" class="string">&quot;scala.collection.immutable.Nil&quot;</span>,
    <span title="String(&quot;scala.collection.Seq&quot;)" class="string">&quot;scala.collection.Seq&quot;</span>,
    <span title="String(&quot;scala.collection.Traversable&quot;)" class="string">&quot;scala.collection.Traversable&quot;</span>,
    <span title="String(&quot;scala.collection.Iterable&quot;)" class="string">&quot;scala.collection.Iterable&quot;</span>,
    <span title="String(&quot;scala.collection.mutable.StringBuilder&quot;)" class="string">&quot;scala.collection.mutable.StringBuilder&quot;</span>,
    <span title="String(&quot;scala.collection.IndexedSeq&quot;)" class="string">&quot;scala.collection.IndexedSeq&quot;</span>,
    <span title="String(&quot;scala.collection.Iterator&quot;)" class="string">&quot;scala.collection.Iterator&quot;</span><span class="delimiter">)</span>


  /** The maximum number of recursions allowed in toString
   */
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="40402">maxTostringRecursions</a> = <span title="Int(50)" class="int">50</span>

  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="40405">tostringRecursions</a> = <span title="Int(0)" class="int">0</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>