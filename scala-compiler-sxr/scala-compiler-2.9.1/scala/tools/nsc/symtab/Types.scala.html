<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/tools/nsc/symtab/Types.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* NSC -- new Scala compiler
 * Copyright 2005-2011 LAMP/EPFL
 * @author  Martin Odersky
 */</span>

<span class="keyword">package</span> scala.tools.nsc
<span class="keyword">package</span> symtab

<span class="keyword">import</span> scala.collection.<span class="delimiter">{</span> mutable, immutable <span class="delimiter">}</span>
<span class="keyword">import</span> scala.ref.WeakReference
<span class="keyword">import</span> mutable.ListBuffer
<span class="keyword">import</span> ast.TreeGen
<span class="keyword">import</span> util.<span class="delimiter">{</span> Position, NoPosition <span class="delimiter">}</span>
<span class="keyword">import</span> util.<a href="../util/Statistics.scala.html#30925" title="object scala.tools.nsc.util.Statistics">Statistics</a>._
<span class="keyword">import</span> <a href="Flags.scala.html#24068" title="object scala.tools.nsc.symtab.Flags">Flags</a>._
<span class="keyword">import</span> scala.util.control.ControlThrowable
<span class="keyword">import</span> scala.annotation.tailrec

<span class="comment">/* A standard type pattern match:
  case ErrorType =&gt;
    // internal: error
  case WildcardType =&gt;
    // internal: unknown
  case NoType =&gt;
  case NoPrefix =&gt;
  case ThisType(sym) =&gt;
    // sym.this.type
  case SuperType(thistpe, supertpe) =&gt;
    // super references
  case SingleType(pre, sym) =&gt;
    // pre.sym.type
  case ConstantType(value) =&gt;
    // Int(2)
  case TypeRef(pre, sym, args) =&gt; 
    // pre.sym[targs]
    // Outer.this.C would be represented as TypeRef(ThisType(Outer), C, List())
  case RefinedType(parents, defs) =&gt;
    // parent1 with ... with parentn { defs }
  case ExistentialType(tparams, result) =&gt;
    // result forSome { tparams }
  case AnnotatedType(annots, tp, selfsym) =&gt;
    // tp @annots

  // the following are non-value types; you cannot write them down in Scala source.

  case TypeBounds(lo, hi) =&gt;  
    // &gt;: lo &lt;: hi
  case ClassInfoType(parents, defs, clazz) =&gt;
    // same as RefinedType except as body of class
  case MethodType(paramtypes, result) =&gt;
    // (paramtypes)result 
    // For instance def m(): T is represented as MethodType(List(), T)
  case NullaryMethodType(result) =&gt; // eliminated by uncurry
    // an eval-by-name type
    // For instance def m: T is represented as NullaryMethodType(T)
  case PolyType(tparams, result) =&gt;
    // [tparams]result where result is a (Nullary)MethodType or ClassInfoType

  // The remaining types are not used after phase `typer'. 
  case OverloadedType(pre, tparams, alts) =&gt;
    // all alternatives of an overloaded ident
  case AntiPolyType(pre, targs) =&gt;
    // rarely used, disappears when combined with a PolyType
  case TypeVar(inst, constr) =&gt;
    // a type variable
    // Replace occurrences of type parameters with type vars, where
    // inst is the instantiation and constr is a list of bounds.
  case DeBruijnIndex(level, index)
    // for dependent method types: a type referring to a method parameter.
    // Not presently used, it seems.
*/</span>

<span class="keyword">trait</span> <a title="trait Types extends java.lang.Object with scala.reflect.generic.Types with ScalaObject" id="24037">Types</a> <span title="ScalaObject" class="keyword">extends</span> reflect.generic.<span title="scala.reflect.generic.Types">Types</span> <span class="delimiter">{</span> self: SymbolTable =&gt;
  <span class="keyword">import</span> <a href="Definitions.scala.html#67699" title="object Types.this.definitions">definitions</a>._
  
  <span class="comment">//statistics</span>
  <span class="keyword">def</span> <a title="=&gt; Int" id="67359">uniqueTypeCount</a> = <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#67501" title="=&gt; scala.tools.nsc.util.HashSet[Types.this.Type]">uniques</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> <span class="keyword">else</span> <a href="#67501" title="=&gt; scala.tools.nsc.util.HashSet[Types.this.Type]">uniques</a>.<a href="../util/HashSet.scala.html#120359" title="=&gt; Int">size</a>

  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Boolean" id="67361">explainSwitch</a> = <span title="Boolean(false)" class="keyword">false</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="67363">emptySymbolSet</a> = immutable.<span title="object scala.collection.immutable.Set">Set</span>.<span title="[A]=&gt; scala.collection.immutable.Set[A]">empty</span><span title="scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span>

  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean(false)" id="67365">alternativeNarrow</a> = <span title="Boolean(false)" class="keyword">false</span>

  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="67367">LogPendingSubTypesThreshold</a> = <span title="Int(50)" class="int">50</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="67369">LogPendingBaseTypesThreshold</a> = <span title="Int(50)" class="int">50</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="67371">LogVolatileThreshold</a> = <span title="Int(50)" class="int">50</span>

  <span class="comment">/** A don't care value for the depth parameter in lubs/glbs and related operations */</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(-3)" id="67373">AnyDepth</a> = -<span title="Int(-3)" class="int">3</span>

  <span class="comment">/** Decrement depth unless it is a don't care */</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="(depth: Int)Int" id="67375">decr</a><span class="delimiter">(</span><a title="Int" id="449320">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#449320" title="Int">depth</a> <span title="(x: Int)Boolean">==</span> <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span> <span title="Int(-3)">AnyDepth</span> <span class="keyword">else</span> <a href="#449320" title="Int">depth</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>

  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean(false)" id="67376">printLubs</a> = <span title="Boolean(false)" class="keyword">false</span>
  <span class="comment">/** In case anyone wants to turn off lub verification without reverting anything. */</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean(true)" id="67378">verifyLubs</a> = <span title="Boolean(true)" class="keyword">true</span>

  <span class="comment">/** The current skolemization level, needed for the algorithms
   *  in isSameType, isSubType that do constraint solving under a prefix 
   */</span>
  <span class="keyword">var</span> <a title="Int" id="67381">skolemizationLevel</a> = <span title="Int(0)" class="int">0</span>

  <span class="comment">/** A log of type variable with their original constraints. Used in order
   *  to undo constraints in the case of isSubType/isSameType failure.
   */</span>
  <span class="keyword">object</span> <a title="object Types.this.undoLog" id="67383">undoLog</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">type</span> <a title="List[(Types.this.TypeVar, Types.this.TypeConstraint)]" id="106876">UndoLog</a> = <span title="List[(Types.this.TypeVar, Types.this.TypeConstraint)]">List</span><span class="delimiter">[</span><span class="delimiter">(</span>TypeVar, TypeConstraint<span class="delimiter">)</span><span class="delimiter">]</span>
    <span class="keyword">private</span><span class="delimiter">[</span>nsc<span class="delimiter">]</span> <span class="keyword">var</span> <a title="scala.tools.nsc.symtab.Types.undoLog.UndoLog" id="106878">log</a>: <span title="scala.tools.nsc.symtab.Types.undoLog.UndoLog">UndoLog</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">/** Undo all changes to constraints to type variables upto `limit'
     */</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(limit: scala.tools.nsc.symtab.Types.undoLog.UndoLog)Unit" id="106880">undoTo</a><span class="delimiter">(</span><a title="scala.tools.nsc.symtab.Types.undoLog.UndoLog" id="449340">limit</a>: <span title="List[(Types.this.TypeVar, Types.this.TypeConstraint)]">UndoLog</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#106878" title="=&gt; scala.tools.nsc.symtab.Types.undoLog.UndoLog">log</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#449340" title="scala.tools.nsc.symtab.Types.undoLog.UndoLog">limit</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#106878" title="=&gt; scala.tools.nsc.symtab.Types.undoLog.UndoLog">log</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#449342" title="()Unit" class="delimiter">{</a>
        <span class="keyword">val</span> <a href="#449349" title="(Types.this.TypeVar, Types.this.TypeConstraint)" class="delimiter">(</a><a href="#449348" title="Types.this.TypeVar" id="449349">tv</a>, <a href="#449348" title="Types.this.TypeConstraint" id="449350">constr</a><span class="delimiter">)</span> = <a href="#106878" title="=&gt; scala.tools.nsc.symtab.Types.undoLog.UndoLog">log</a>.<span title="=&gt; (Types.this.TypeVar, Types.this.TypeConstraint)">head</span>
        <a href="#449349" title="Types.this.TypeVar">tv</a>.<a href="#449001" title="(x$1: Types.this.TypeConstraint)Unit">constr</a> = <a href="#449350" title="Types.this.TypeConstraint">constr</a>
        <a href="#106878" title="(x$1: scala.tools.nsc.symtab.Types.undoLog.UndoLog)Unit">log</a> = <a href="#106878" title="=&gt; scala.tools.nsc.symtab.Types.undoLog.UndoLog">log</a>.<span title="=&gt; List[(Types.this.TypeVar, Types.this.TypeConstraint)]">tail</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">private</span><span class="delimiter">[</span>Types<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(tv: Types.this.TypeVar)Unit" id="106881">record</a><span class="delimiter">(</span><a title="Types.this.TypeVar" id="449398">tv</a>: <a href="#67469" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#106878" title="(x$1: scala.tools.nsc.symtab.Types.undoLog.UndoLog)Unit">log</a> <span title="(x: (Types.this.TypeVar, Types.this.TypeConstraint))List[(Types.this.TypeVar, Types.this.TypeConstraint)]">::=</span> <span class="delimiter">(</span><a href="#449398" title="Types.this.TypeVar">tv</a>, <a href="#449398" title="Types.this.TypeVar">tv</a>.<a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449392" title="=&gt; Types.this.TypeConstraint">cloneInternal</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">private</span><span class="delimiter">[</span>nsc<span class="delimiter">]</span> <span class="keyword">def</span> <a title="()Unit" id="106882">clear</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span>
        <a href="#24037" title="Types.this.type">self</a>.<a href="SymbolTable.scala.html#64789" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;Clearing &quot;)" class="string">&quot;Clearing &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#106878" title="=&gt; scala.tools.nsc.symtab.Types.undoLog.UndoLog">log</a>.<span title="=&gt; Int">size</span> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; entries from the undoLog.&quot;)" class="string">&quot; entries from the undoLog.&quot;</span><span class="delimiter">)</span>

      <a href="#106878" title="(x$1: scala.tools.nsc.symtab.Types.undoLog.UndoLog)Unit">log</a> = <span title="object Nil">Nil</span>
    <span class="delimiter">}</span>

    <span class="comment">// `block` should not affect constraints on typevars</span>
    <span class="keyword">def</span> <a title="[T](block: =&gt; T)T" id="106883">undo</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="106885">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; T" id="106887">block</a>: =&gt; T<span class="delimiter">)</span>: <a href="#106885" title="T">T</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.tools.nsc.symtab.Types.undoLog.UndoLog" id="449432">before</a> = <a href="#106878" title="=&gt; scala.tools.nsc.symtab.Types.undoLog.UndoLog">log</a>

      <span class="keyword">try</span> <a href="#106887" title="=&gt; T">block</a>
      <span class="keyword">finally</span> <a href="#106880" title="(limit: scala.tools.nsc.symtab.Types.undoLog.UndoLog)Unit">undoTo</a><span class="delimiter">(</span><a href="#449432" title="scala.tools.nsc.symtab.Types.undoLog.UndoLog">before</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// if `block` evaluates to false, it should not affect constraints on typevars</span>
    <span class="keyword">def</span> <a title="(block: =&gt; Boolean)Boolean" id="106886">undoUnless</a><span class="delimiter">(</span><a title="=&gt; Boolean" id="449433">block</a>: =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.tools.nsc.symtab.Types.undoLog.UndoLog" id="449435">before</a> = <a href="#106878" title="=&gt; scala.tools.nsc.symtab.Types.undoLog.UndoLog">log</a>
      <span class="keyword">var</span> <a title="Boolean" id="449436">result</a> = <span title="Boolean(false)" class="keyword">false</span>
      
      <span class="keyword">try</span> <a href="#449436" title="Boolean">result</a> = <a href="#449433" title="=&gt; Boolean">block</a>
      <span class="keyword">finally</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#449436" title="Boolean">result</a><span class="delimiter">)</span> <a href="#106880" title="(limit: scala.tools.nsc.symtab.Types.undoLog.UndoLog)Unit">undoTo</a><span class="delimiter">(</span><a href="#449435" title="scala.tools.nsc.symtab.Types.undoLog.UndoLog">before</a><span class="delimiter">)</span>
      
      <a href="#449436" title="Boolean">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map from lists to compound types that have the given list as parents.
   *  This is used to avoid duplication in the computation of base type sequences and baseClasses.
   *  It makes use of the fact that these two operations depend only on the parents,
   *  not on the refinement.
   */</span>
  <span class="keyword">val</span> <a title="scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]" id="67385">intersectionWitness</a> = <span title="scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]">WeakHashMap</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span>, WeakReference<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="keyword">private</span> <span class="keyword">object</span> <a title="object Types.this.gen" id="67387">gen</a> <span title="ScalaObject" class="keyword">extends</span> <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Types.this.type" id="449443">global</a> : Types.<span class="keyword">this</span>.<span class="keyword">type</span> = <a href="#24037" title="Types.this.type">Types</a>.<span class="keyword">this</span>
  <span class="delimiter">}</span> <span class="keyword">with</span> <a href="../ast/TreeGen.scala.html#11885" title="scala.tools.nsc.ast.TreeGen">TreeGen</a>

  <span class="keyword">import</span> <a href="#67387" title="object Types.this.gen">gen</a>._

  <span class="comment">/** A proxy for a type (identified by field `underlying') that forwards most 
   *  operations to it (for exceptions, see WrappingProxy, which forwards even more operations).
   *  every operation that is overridden for some kind of types should be forwarded.
   */</span>
  <span class="keyword">trait</span> <a title="trait SimpleTypeProxy extends Types.this.Type with ScalaObject" id="67390">SimpleTypeProxy</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67392" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148288">underlying</a>: <a href="#67392" title="Types.this.Type">Type</a>

    <span class="comment">// the following operations + those in RewrappingTypeProxy are all operations </span>
    <span class="comment">// in class Type that are overridden in some subclass</span>
    <span class="comment">// Important to keep this up-to-date when new operations are added!</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148289">isTrivial</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105444" title="=&gt; Boolean">isTrivial</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148290">isHigherKinded</a>: <span title="Boolean">Boolean</span> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105445" title="=&gt; Boolean">isHigherKinded</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148291">typeConstructor</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105466" title="=&gt; Types.this.Type">typeConstructor</a> 
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148292">isNotNull</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105448" title="=&gt; Boolean">isNotNull</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148293">isError</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105485" title="=&gt; Boolean">isError</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148294">isErroneous</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105486" title="=&gt; Boolean">isErroneous</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148295">isStable</a>: <span title="Boolean">Boolean</span> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105446" title="=&gt; Boolean">isStable</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148296">isVolatile</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105447" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148297">finalResultType</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105472" title="=&gt; Types.this.Type">finalResultType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148298">paramSectionCount</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105473" title="=&gt; Int">paramSectionCount</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="148299">paramss</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105474" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148300">params</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105475" title="=&gt; List[Types.this.Symbol]">params</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148301">paramTypes</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105476" title="=&gt; List[Types.this.Type]">paramTypes</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148302">termSymbol</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105453" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148303">termSymbolDirect</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105455" title="=&gt; Types.this.Symbol">termSymbolDirect</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148304">typeParams</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105477" title="=&gt; List[Types.this.Symbol]">typeParams</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="148305">boundSyms</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105478" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148306">typeSymbol</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148307">typeSymbolDirect</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105456" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148308">widen</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105458" title="=&gt; Types.this.Type">widen</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148309">typeOfThis</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105460" title="=&gt; Types.this.Type">typeOfThis</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="148310">bounds</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148311">parents</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105463" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148312">prefix</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105464" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="148313">decls</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105487" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="148314">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="449523">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105499" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#449523" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="148315">baseTypeSeq</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105524" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148316">baseTypeSeqDepth</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105525" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148317">baseClasses</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105526" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A proxy for a type (identified by field `underlying') that forwards most 
   *  operations to it. Every operation that is overridden for some kind of types is
   *  forwarded here. Some operations are rewrapped again.
   */</span>
  <span class="keyword">trait</span> <a title="trait RewrappingTypeProxy extends Types.this.Type with Types.this.SimpleTypeProxy with ScalaObject" id="67391">RewrappingTypeProxy</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67390" title="Types.this.SimpleTypeProxy">SimpleTypeProxy</a> <span class="delimiter">{</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="149018">maybeRewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="449537">newtp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#449537" title="Types.this.Type">newtp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#105457" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span> <a href="#67391" title="Types.this.RewrappingTypeProxy" class="keyword">this</a> <span class="keyword">else</span> <a href="#149019" title="(newtp: Types.this.Type)Types.this.Type">rewrap</a><span class="delimiter">(</span><a href="#449537" title="Types.this.Type">newtp</a><span class="delimiter">)</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="149019">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="449540">newtp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a>

    <span class="comment">// the following are all operations in class Type that are overridden in some subclass</span>
    <span class="comment">// Important to keep this up-to-date when new operations are added!</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149020">widen</a> = <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105458" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149021">narrow</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105461" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149022">deconst</a> = <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105459" title="=&gt; Types.this.Type">deconst</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149023">resultType</a> = <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105468" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(actuals: List[Types.this.Type])Types.this.Type" id="149024">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="449559">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105469" title="(actuals: List[Types.this.Type])Types.this.Type">resultType</a><span class="delimiter">(</span><a href="#449559" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149025">finalResultType</a> = <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105472" title="=&gt; Types.this.Type">finalResultType</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="149026">paramSectionCount</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="149027">paramss</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="149028">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="149029">paramTypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="149030">typeArgs</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105467" title="=&gt; List[Types.this.Type]">typeArgs</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149031">notNull</a> = <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105479" title="=&gt; Types.this.Type">notNull</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="149032">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="449607">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="449608">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105480" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#449607" title="List[Types.this.Symbol]">formals</a>, <a href="#449608" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="149033">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="449614">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="449615">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105481" title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type">skolemizeExistential</a><span class="delimiter">(</span><a href="#449614" title="Types.this.Symbol">owner</a>, <a href="#449615" title="AnyRef">origin</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149034">normalize</a> = <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149035">dealias</a> = <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105484" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="149036">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="449628">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105528" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#449628" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="149037">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="449631">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105529" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#449631" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="149038">prefixString</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105533" title="=&gt; java.lang.String">prefixString</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="149039">isComplete</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<span title="=&gt; Boolean">isComplete</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="149040">complete</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="449640">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<span title="(sym: Types.this.Symbol)Unit">complete</span><span class="delimiter">(</span><a href="#449640" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="149041">load</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="449645">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105536" title="(sym: Types.this.Symbol)Unit">load</a><span class="delimiter">(</span><a href="#449645" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="149042">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="449647">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105543" title="(annots: List[Types.this.AnnotationInfo])Types.this.Type">withAnnotations</a><span class="delimiter">(</span><a href="#449647" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149043">withoutAnnotations</a> = <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105544" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The base class for all types */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Type extends Types.this.AbsType with ScalaObject" id="67392">Type</a> <a href="#67392" title="ScalaObject" class="keyword">extends</a> <a href="#24037" title="Types.this.AbsType">AbsType</a> <span class="delimiter">{</span>
    
    <span class="comment">/** Types for which asSeenFrom always is the identity, no matter what
     *  prefix or owner.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105444">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** Is this type higher-kinded, i.e., is it a type constructor @M */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105445">isHigherKinded</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span> 
    
    <span class="comment">/** Does this type denote a stable reference (i.e. singleton type)? */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105446">isStable</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** Is this type dangerous (i.e. it might contain conflicting
     *  type information when empty, so that it can be constructed
     *  so that type unsoundness results.) A dangerous type has an underlying
     *  type of the form T_1 with T_n { decls }, where one of the
     *  T_i (i &gt; 1) is an abstract type.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105447">isVolatile</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** Is this type guaranteed not to have `null' as a value? */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105448">isNotNull</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** Is this type a structural refinement type (it 'refines' members that have not been inherited) */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105449">isStructuralRefinement</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** Does this type depend immediately on an enclosing method parameter? 
      * i.e., is it a singleton type whose termSymbol refers to an argument of the symbol's owner (which is a method)
      */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105450">isImmediatelyDependent</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** Does this depend on an enclosing method parameter? */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105451">isDependent</a>: <span title="Boolean">Boolean</span> = <a href="#67539" title="object Types.this.IsDependentCollector">IsDependentCollector</a>.<a href="#449299" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/** True for WildcardType or BoundedWildcardType */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105452">isWildcard</a> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** The term symbol associated with the type
      * Note that the symbol of the normalized type is returned (@see normalize)
      */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="105453">termSymbol</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a>

    <span class="comment">/** The type symbol associated with the type
      * Note that the symbol of the normalized type is returned (@see normalize)
      */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="105454">typeSymbol</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a>

    <span class="comment">/** The term symbol *directly* associated with the type
      */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="105455">termSymbolDirect</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <a href="#105453" title="=&gt; Types.this.Symbol">termSymbol</a>

    <span class="comment">/** The type symbol *directly* associated with the type
      */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="105456">typeSymbolDirect</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>

    <span class="comment">/** The base type underlying a type proxy,
     *  identity on all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105457">underlying</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Widen from singleton type to its underlying non-singleton
     *  base type by applying one or more `underlying' dereferences,
     *  identity for all other types.
     *  
     *  class Outer { class C ; val x: C }
     *  val o: Outer
     *  &lt;o.x.type&gt;.widen = o.C
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105458">widen</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Map a constant type or not-null-type to its underlying base type,
     *  identity for all other types.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105459">deconst</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** The type of `this' of a class type or reference type
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105460">typeOfThis</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107599" title="=&gt; Types.this.Type">typeOfThis</a>

    <span class="comment">/** Map to a singleton type which is a subtype of this type.
     *  The fallback implemented here gives
     *    T.narrow  =  (T {}).this.type
     *  Overridden where we know more about where types come from.
     *
     *  todo: change to singleton type of an existentially defined variable
     *  of the right type instead of making this a `this` of a refined type.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105461">narrow</a>: <a href="#67392" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#67392" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="Boolean(false)">alternativeNarrow</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// investigate why this does not work!</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="449675">tparam</a> = <a href="#67660" title="(t: Types.this.Type)Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span> <a href="Symbols.scala.html#107445" title="(suffix: String)Types.this.Symbol">freshExistential</a> <span title="java.lang.String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span> <a href="Symbols.scala.html#107566" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a> <a href="#67530" title="(hi: Types.this.Type)Types.this.TypeBounds">singletonBounds</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#449675" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="449703">cowner</a> = <a href="#67660" title="(t: Types.this.Type)Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#67480" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>, <a href="#449703" title="Types.this.Symbol">cowner</a>, <a href="Scopes.scala.html#67693" title="object Types.this.EmptyScope">EmptyScope</a>, <a href="#449703" title="Types.this.Symbol">cowner</a>.<a href="Symbols.scala.html#107404" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>.<a href="#105461" title="=&gt; Types.this.Type">narrow</a>
      <span class="delimiter">}</span>

    <span class="comment">/** For a TypeBounds type, itself;
     *  for a reference denoting an abstract type, its bounds,
     *  for all other types, a TypeBounds type all of whose bounds are this type.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="105462">bounds</a>: <a href="#148517" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#148501" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/** For a class or intersection type, its parents.
     *  For a TypeBounds type, the parents of its hi bound.
     *  inherited by typerefs, singleton types, and refinement types,
     *  The empty list for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="105463">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">/** For a typeref or single-type, the prefix of the normalized type (@see normalize).
     *  NoType for all other types. */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105464">prefix</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#450913" title="object Types.this.NoType">NoType</a>

    <span class="comment">/** A chain of all typeref or singletype prefixes of this type, longest first.
     *  (Only used from safeToString.)
     */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="105465">prefixChain</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#67392" title="Types.this.Type" class="keyword">this</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="List[Types.this.Type]">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="449730">pre</a>, _, _<span class="delimiter">)</span> =&gt; <a href="#449730" title="Types.this.Type">pre</a> <a href="#449731" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#449730" title="Types.this.Type">pre</a>.<a href="#105465" title="=&gt; List[Types.this.Type]">prefixChain</a>
      <span class="keyword">case</span> <span title="List[Types.this.Type]">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="449737">pre</a>, _<span class="delimiter">)</span> =&gt; <a href="#449737" title="Types.this.Type">pre</a> <a href="#449738" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#449737" title="Types.this.Type">pre</a>.<a href="#105465" title="=&gt; List[Types.this.Type]">prefixChain</a>
      <span class="keyword">case</span> <span title="List[Nothing]">_</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** This type, without its type arguments @M */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105466">typeConstructor</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** For a typeref, its arguments. The empty list for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="105467">typeArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">/** For a (nullary) method or poly type, its direct result type, 
     *  the type itself for all other types. */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105468">resultType</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="keyword">def</span> <a title="(actuals: List[Types.this.Type])Types.this.Type" id="105469">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="204865">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Only used for dependent method types. */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105470">resultApprox</a>: <a href="#67392" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span><span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36819" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">YdepMethTpes</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#449764" title="(tp: Types.this.Type)Types.this.Type">ApproximateDependentMap</a><span class="delimiter">(</span><a href="#105468" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#105468" title="=&gt; Types.this.Type">resultType</a>

    <span class="comment">/** If this is a TypeRef `clazz`[`T`], return the argument `T`
     *  otherwise return this type
     */</span>
    <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="105471">remove</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="449777">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** For a curried/nullary method or poly type its non-method result type, 
     *  the type itself for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105472">finalResultType</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** For a method type, the number of its value parameter sections,
     *  0 for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; Int" id="105473">paramSectionCount</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>

    <span class="comment">/** For a method or poly type, a list of its value parameter sections,
     *  the empty list for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="105474">paramss</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">/** For a method or poly type, its first value parameter section,
     *  the empty list for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="105475">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">/** For a method or poly type, the types of its first value parameter section,
     *  the empty list for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="105476">paramTypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    
    <span class="comment">/** For a (potentially wrapped) poly type, its type parameters,
     *  the empty list for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="105477">typeParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
  
    <span class="comment">/** For a (potentially wrapped) poly or existential type, its bound symbols,
     *  the empty list for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="105478">boundSyms</a>: immutable.<span title="scala.collection.immutable.Set[Types.this.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#67363" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">emptySymbolSet</a>

    <span class="comment">/** Mixin a NotNull trait unless type already has one
     *  ...if the option is given, since it is causing typing bugs.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105479">notNull</a>: <a href="#67392" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36817" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">Ynotnull</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">||</span> <a href="#105448" title="=&gt; Boolean">isNotNull</a> <span title="(x: Boolean)Boolean">||</span> <a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#67392" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#449814" title="(underlying: Types.this.Type)Types.this.NotNullType">NotNullType</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
    
    <span class="comment">/** Replace formal type parameter symbols with actual type arguments. 
     *
     * Amounts to substitution except for higher-kinded types. (See overridden method in TypeRef) -- @M
     */</span>
    <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="105480">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="449610">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="449611">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#449610" title="List[Types.this.Symbol]">formals</a>, <a href="#449611" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#67392" title="Type.this.type" class="keyword">this</a>.<a href="#105504" title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#449610" title="List[Types.this.Symbol]">formals</a>, <a href="#449611" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#450846" title="object Types.this.ErrorType">ErrorType</a>

    <span class="comment">/** If this type is an existential, turn all existentially bound variables to type skolems.
     *  @param  owner    The owner of the created type skolems
     *  @param  origin   The tree whose type was an existential for which the skolem was created.
     */</span>
    <span class="keyword">def</span> <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="105481">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="375792">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="375793">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#67392" title="Types.this.Type" class="keyword">this</a>
    
    <span class="comment">/** A simple version of skolemizeExistential for situations where
     *  owner or unpack location do not matter (typically used in subtype tests)
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105482">skolemizeExistential</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#105481" title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type">skolemizeExistential</a><span class="delimiter">(</span><a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a>, <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
    
    <span class="comment">/** Reduce to beta eta-long normal form.
     *  Expands type aliases and converts higher-kinded TypeRefs to PolyTypes.
     *  Functions on types are also implemented as PolyTypes.
     * 
     *  Example: (in the below, &lt;List&gt; is the type constructor of List)
     *    TypeRef(pre, &lt;List&gt;, List()) is replaced by
     *    PolyType(X, TypeRef(pre, &lt;List&gt;, List(X)))
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105483">normalize</a> = <a href="#67392" title="Types.this.Type" class="keyword">this</a> <span class="comment">// @MAT</span>
    
    <span class="comment">/** Expands type aliases. */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105484">dealias</a> = <a href="#67392" title="Types.this.Type" class="keyword">this</a>
    
    <span class="comment">/** Is this type produced as a repair for an error? */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105485">isError</a>: <span title="Boolean">Boolean</span> = <a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107478" title="=&gt; Boolean">isError</a> <span title="(x: Boolean)Boolean">||</span> <a href="#105453" title="=&gt; Types.this.Symbol">termSymbol</a>.<a href="Symbols.scala.html#107478" title="=&gt; Boolean">isError</a>

    <span class="comment">/** Is this type produced as a repair for an error? */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105486">isErroneous</a>: <span title="Boolean">Boolean</span> = <a href="#67555" title="object Types.this.ErroneousCollector">ErroneousCollector</a>.<a href="#449299" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/** Does this type denote a reference type which can be null? */</span>
    <span class="comment">// def isNullable: Boolean = false</span>

    <span class="comment">/** For a classtype or refined type, its defined or declared members;
     *  inherited by subtypes and typerefs.
     *  The empty scope for all other types.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="105487">decls</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a> = <a href="Scopes.scala.html#67693" title="object Types.this.EmptyScope">EmptyScope</a>

    <span class="comment">/** The defined or declared members with name `name' in this type;
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Alternatives of overloaded symbol appear in the order they are declared.
     */</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="105488">decl</a><span class="delimiter">(</span><a title="Types.this.Name" id="222928">name</a>: <a href="Names.scala.html#66925" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <a href="#105537" title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol">findDecl</a><span class="delimiter">(</span><a href="#222928" title="Types.this.Name">name</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>

    <span class="comment">/** The non-private defined or declared members with name `name' in this type;
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Alternatives of overloaded symbol appear in the order they are declared.
     */</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="105489">nonPrivateDecl</a><span class="delimiter">(</span><a title="Types.this.Name" id="348367">name</a>: <a href="Names.scala.html#66925" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <a href="#105537" title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol">findDecl</a><span class="delimiter">(</span><a href="#348367" title="Types.this.Name">name</a>, <span title="Int(4)">PRIVATE</span><span class="delimiter">)</span>

    <span class="comment">/** A list of all members of this type (defined or inherited)
     *  Members appear in linearization order of their owners.
     *  Members with the same owner appear in reverse order of their declarations.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="105490">members</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#105538" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="StdNames.scala.html#67724" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115414" title="=&gt; Types.this.nme.NameType">ANYNAME</a>, <span title="Long(0L)" class="int">0</span>, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#107591" title="=&gt; List[Types.this.Symbol]">alternatives</a>

    <span class="comment">/** A list of all non-private members of this type (defined or inherited) */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="105491">nonPrivateMembers</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#105538" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="StdNames.scala.html#67724" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115414" title="=&gt; Types.this.nme.NameType">ANYNAME</a>, PRIVATE <span title="Long(4398113619972L)">|</span> BRIDGES, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#107591" title="=&gt; List[Types.this.Symbol]">alternatives</a>

    <span class="comment">/** A list of all non-private members of this type  (defined or inherited),
     *  admitting members with given flags `admit`
     */</span>
    <span class="keyword">def</span> <a title="(admit: Long)List[Types.this.Symbol]" id="105492">nonPrivateMembersAdmitting</a><span class="delimiter">(</span><a title="Long" id="449858">admit</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#105538" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="StdNames.scala.html#67724" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115414" title="=&gt; Types.this.nme.NameType">ANYNAME</a>, <span class="delimiter">(</span>PRIVATE <span title="Long(4398113619972L)">|</span> BRIDGES<span class="delimiter">)</span> <span title="(x: Long)Long">&amp;</span> <span title="=&gt; Long">~</span><a href="#449858" title="Long">admit</a>, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#107591" title="=&gt; List[Types.this.Symbol]">alternatives</a>

    <span class="comment">/** A list of all implicit symbols of this type  (defined or inherited) */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="105493">implicitMembers</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#105538" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="StdNames.scala.html#67724" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115414" title="=&gt; Types.this.nme.NameType">ANYNAME</a>, <span title="Long(4398113619968L)">BRIDGES</span>, <span title="Long(512L)">IMPLICIT</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#107591" title="=&gt; List[Types.this.Symbol]">alternatives</a>

    <span class="comment">/** A list of all deferred symbols of this type  (defined or inherited) */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="105494">deferredMembers</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#105538" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="StdNames.scala.html#67724" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115414" title="=&gt; Types.this.nme.NameType">ANYNAME</a>, <span title="Long(4398113619968L)">BRIDGES</span>, <span title="Long(16L)">DEFERRED</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#107591" title="=&gt; List[Types.this.Symbol]">alternatives</a>

    <span class="comment">/** The member with given name, 
     *  an OverloadedSymbol if several exist, NoSymbol if none exist */</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="105495">member</a><span class="delimiter">(</span><a title="Types.this.Name" id="122462">name</a>: <a href="Names.scala.html#66925" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <a href="#105538" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#122462" title="Types.this.Name">name</a>, <span title="Long(4398113619968L)">BRIDGES</span>, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

    <span class="comment">/** The non-private member with given name,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Bridges are excluded from the result
     */</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="105496">nonPrivateMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="132689">name</a>: <a href="Names.scala.html#66925" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> =
      <a href="#105538" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#132689" title="Types.this.Name">name</a>, PRIVATE <span title="Long(4398113619972L)">|</span> BRIDGES, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
  
    <span class="comment">/** The non-private member with given name, admitting members with given flags `admit`
     *  an OverloadedSymbol if several exist, NoSymbol if none exist
     */</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name, admit: Long)Types.this.Symbol" id="105497">nonPrivateMemberAdmitting</a><span class="delimiter">(</span><a title="Types.this.Name" id="446724">name</a>: <a href="Names.scala.html#66925" title="Types.this.Name">Name</a>, <a title="Long" id="446725">admit</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> =
      <a href="#105538" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#446724" title="Types.this.Name">name</a>, <span class="delimiter">(</span>PRIVATE <span title="Long(4398113619972L)">|</span> BRIDGES<span class="delimiter">)</span> <span title="(x: Long)Long">&amp;</span> <span title="=&gt; Long">~</span><a href="#446725" title="Long">admit</a>, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
  
    <span class="comment">/** The non-local member with given name,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist */</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="105498">nonLocalMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="449882">name</a>: <a href="Names.scala.html#66925" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> =
      <a href="#105538" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#449882" title="Types.this.Name">name</a>, LOCAL <span title="Long(4398114144256L)">|</span> BRIDGES, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

    <span class="comment">/** The least type instance of given class which is a supertype
     *  of this type.  Example:
     *    class D[T]
     *    class C extends p.D[Int]
     *    ThisType(C).baseType(D) = p.D[Int]
     */</span>
    <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="105499">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="298413">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#450913" title="object Types.this.NoType">NoType</a>

    <span class="comment">/** This type as seen from prefix `pre' and class `clazz'. This means:
     *  Replace all thistypes of `clazz' or one of its subclasses
     *  by `pre' and instantiate all parameters by arguments of `pre'.
     *  Proceed analogously for thistypes referring to outer classes.
     *
     *  Example:
     *    class D[T] { def m: T }
     *    class C extends p.D[Int]
     *    T.asSeenFrom(ThisType(C), D)  (where D is owner of m)
     *      = Int
     */</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="105500">asSeenFrom</a><span class="delimiter">(</span><a title="Types.this.Type" id="133705">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="133706">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#105444" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#133705" title="Types.this.Type">pre</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106394" title="=&gt; Types.this.Symbol">ArrayClass</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="../util/Statistics.scala.html#67162" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67207" title="=&gt; scala.tools.nsc.util.Statistics.Counter">asSeenFromCount</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="scala.tools.nsc.util.Statistics.LongPair" id="449893">start</a> = <a href="../util/Statistics.scala.html#67166" title="(tm: scala.tools.nsc.util.Statistics.Timer)scala.tools.nsc.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67209" title="=&gt; scala.tools.nsc.util.Statistics.Timer">asSeenFromNanos</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.AsSeenFromMap" id="449894">m</a> = <span title="Types.this.AsSeenFromMap" class="keyword">new</span> <a href="#67531" title="Types.this.AsSeenFromMap">AsSeenFromMap</a><span class="delimiter">(</span><a href="#133705" title="Types.this.Type">pre</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a>, <a href="#133706" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="449895">tp</a> = <a href="#449894" title="Types.this.AsSeenFromMap">m</a> <a href="#449915" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#67392" title="Types.this.Type" class="keyword">this</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="449896">result</a> = <a href="#67493" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#449894" title="Types.this.AsSeenFromMap">m</a>.<a href="#449907" title="=&gt; List[Types.this.Symbol]">capturedParams</a>, <a href="#449895" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <a href="../util/Statistics.scala.html#67167" title="(tm: scala.tools.nsc.util.Statistics.Timer, start: scala.tools.nsc.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67209" title="=&gt; scala.tools.nsc.util.Statistics.Timer">asSeenFromNanos</a>, <a href="#449893" title="scala.tools.nsc.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
        <a href="#449896" title="Types.this.Type">result</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** The info of `sym', seen as a member of this type.
     *
     *  Example:
     *    class D[T] { def m: T }
     *    class C extends p.D[Int]
     *    ThisType(C).memberType(m) = Int
     */</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="105501">memberInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="236279">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#236279" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105500" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#236279" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** The type of `sym', seen as a member of this type. */</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="105502">memberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="132697">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#132697" title="Types.this.Symbol">sym</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="449922">meth</a>: <a href="Symbols.scala.html#67334" title="Types.this.MethodSymbol">MethodSymbol</a> =&gt;
        <a href="#449922" title="Types.this.MethodSymbol">meth</a>.<a href="Symbols.scala.html#210950" title="(pre: Types.this.Type)Types.this.Type">typeAsMemberOf</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#105503" title="(sym: Types.this.Symbol)Types.this.Type">computeMemberType</a><span class="delimiter">(</span><a href="#132697" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="105503">computeMemberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="447424">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#447424" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107563" title="=&gt; Types.this.Type">tpeHK</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span> <span class="comment">//@M don't prematurely instantiate higher-kinded types, they will be instantiated by transform, typedTypeApply, etc. when really necessary</span>
      <span class="keyword">case</span> <span title="Types.this.OverloadedType">OverloadedType</span><span class="delimiter">(</span>_, <a title="List[Types.this.Symbol]" id="449924">alts</a><span class="delimiter">)</span> =&gt;
        <a href="#251496" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.OverloadedType">OverloadedType</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#449924" title="List[Types.this.Symbol]">alts</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="449927">tp</a> =&gt;
        <a href="#449927" title="Types.this.Type">tp</a>.<a href="#105500" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#447424" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Substitute types `to' for occurrences of references to
     *  symbols `from' in this type.
     */</span>
    <span class="keyword">def</span> <a title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type" id="105504">subst</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="449834">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="449835">to</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#449834" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#67392" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.SubstTypeMap" class="keyword">new</span> <a href="#67535" title="Types.this.SubstTypeMap">SubstTypeMap</a><span class="delimiter">(</span><a href="#449834" title="List[Types.this.Symbol]">from</a>, <a href="#449835" title="List[Types.this.Type]">to</a><span class="delimiter">)</span> <a href="#167447" title="(tp0: Types.this.Type)Types.this.Type">apply</a> <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Substitute symbols `to' for occurrences of symbols
     *  `from' in this type.
     * !!! NOTE !!!: If you need to do a substThis and a substSym, the substThis has to come
     * first, as otherwise symbols will immediately get rebound in typeRef to the old 
     * symbol.
     */</span>
    <span class="keyword">def</span> <a title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type" id="105505">substSym</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="313977">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="313978">to</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#313977" title="List[Types.this.Symbol]">from</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#313978" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <a href="#67392" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.SubstSymMap" class="keyword">new</span> <a href="#67534" title="Types.this.SubstSymMap">SubstSymMap</a><span class="delimiter">(</span><a href="#313977" title="List[Types.this.Symbol]">from</a>, <a href="#313978" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <a href="#167577" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Substitute all occurrences of `ThisType(from)' in this type
     *  by `to'.
     * !!! NOTE !!!: If you need to do a substThis and a substSym, the substThis has to come
     * first, as otherwise symbols will immediately get rebound in typeRef to the old 
     * symbol.
     */</span>
    <span class="keyword">def</span> <a title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type" id="105506">substThis</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="446254">from</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="446255">to</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
      <span title="Types.this.SubstThisMap" class="keyword">new</span> <a href="#67536" title="Types.this.SubstThisMap">SubstThisMap</a><span class="delimiter">(</span><a href="#446254" title="Types.this.Symbol">from</a>, <a href="#446255" title="Types.this.Type">to</a><span class="delimiter">)</span> <a href="#449937" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="keyword">def</span> <a title="(from: Types.this.Type, to: Types.this.Type)Types.this.Type" id="105507">substSuper</a><span class="delimiter">(</span><a title="Types.this.Type" id="449945">from</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="449946">to</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
      <span title="Types.this.SubstSuperMap" class="keyword">new</span> <a href="#67537" title="Types.this.SubstSuperMap">SubstSuperMap</a><span class="delimiter">(</span><a href="#449945" title="Types.this.Type">from</a>, <a href="#449946" title="Types.this.Type">to</a><span class="delimiter">)</span> <a href="#449953" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Returns all parts of this type which satisfy predicate `p' */</span>
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]" id="105508">filter</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="449961">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="Types.this.FilterTypeCollector" class="keyword">new</span> <a href="#67552" title="Types.this.FilterTypeCollector">FilterTypeCollector</a><span class="delimiter">(</span><a href="#449961" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span>.<a href="#449299" title="(tp: Types.this.Type)scala.collection.mutable.ListBuffer[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>.<span title="=&gt; List[Types.this.Type]">toList</span>

    <span class="comment">/** Returns optionally first type (in a preorder traversal) which satisfies predicate `p',
     *  or None if none exists. 
     */</span>
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Option[Types.this.Type]" id="105509">find</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="449980">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <span title="Option[Types.this.Type]">Option</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="Types.this.FindTypeCollector" class="keyword">new</span> <a href="#67554" title="Types.this.FindTypeCollector">FindTypeCollector</a><span class="delimiter">(</span><a href="#449980" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span>.<a href="#449299" title="(tp: Types.this.Type)Option[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/** Apply `f' to each part of this type */</span>
    <span class="keyword">def</span> <a title="(f: Types.this.Type =&gt; Unit)Unit" id="105510">foreach</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Unit" id="449987">f</a>: Type =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Types.this.ForEachTypeTraverser" class="keyword">new</span> <a href="#67553" title="Types.this.ForEachTypeTraverser">ForEachTypeTraverser</a><span class="delimiter">(</span><a href="#449987" title="Types.this.Type =&gt; Unit">f</a><span class="delimiter">)</span>.<a href="#449992" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span> <span class="delimiter">}</span>

    <span class="comment">/** Apply `f' to each part of this type; children get mapped before their parents */</span>
    <span class="keyword">def</span> <a title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.Type" id="105511">map</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Types.this.Type" id="449997">f</a>: Type =&gt; Type<span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#449999" title="Types.this.TypeMap" class="keyword">new</a> <a href="#67514" title="anonymous class $anon extends Types.this.TypeMap" id="449999">TypeMap</a> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(x: Types.this.Type)Types.this.Type" id="450001">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="450002">x</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#449997" title="(v1: Types.this.Type)Types.this.Type">f</a><span class="delimiter">(</span><a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#450002" title="Types.this.Type">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <a href="#450001" title="(x: Types.this.Type)Types.this.Type">apply</a> <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Is there part of this type which satisfies predicate `p'? */</span>
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Boolean" id="105512">exists</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="450021">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="=&gt; Boolean">!</span><a href="#105509" title="(p: Types.this.Type =&gt; Boolean)Option[Types.this.Type]">find</a><span class="delimiter">(</span><a href="#450021" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span>.<span title="=&gt; Boolean">isEmpty</span>

    <span class="comment">/** Does this type contain a reference to this symbol? */</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="105513">contains</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="450023">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="Types.this.ContainsCollector" class="keyword">new</span> <a href="#67550" title="Types.this.ContainsCollector">ContainsCollector</a><span class="delimiter">(</span><a href="#450023" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#449299" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/** Does this type contain a reference to this type */</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="105514">containsTp</a><span class="delimiter">(</span><a title="Types.this.Type" id="450034">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="Types.this.ContainsTypeCollector" class="keyword">new</span> <a href="#67551" title="Types.this.ContainsTypeCollector">ContainsTypeCollector</a><span class="delimiter">(</span><a href="#450034" title="Types.this.Type">tp</a><span class="delimiter">)</span>.<a href="#449299" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/** Is this type a subtype of that type? */</span>
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="105515">&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="151943">that</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span>util.<a href="../util/Statistics.scala.html#30925" title="object scala.tools.nsc.util.Statistics">Statistics</a>.<a href="../util/Statistics.scala.html#67155" title="=&gt; Boolean">enabled</a><span class="delimiter">)</span> <a href="#105518" title="(that: Types.this.Type)Boolean">stat_&lt;:&lt;</a><span class="delimiter">(</span><a href="#151943" title="Types.this.Type">that</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="delimiter">(</span><a href="#67392" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#151943" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
        <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67361" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#67676" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="java.lang.String(&quot;&lt;:&quot;)" class="string">&quot;&lt;:&quot;</span>, <a href="#67594" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a>, <a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#151943" title="Types.this.Type">that</a><span class="delimiter">)</span>
         <span class="keyword">else</span> <a href="#67595" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#151943" title="Types.this.Type">that</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    
    <span class="comment">/** Can this type only be subtyped by bottom types?
     *  This is assessed to be the case if the class is final,
     *  and all type parameters (if any) are invariant.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105516">isFinalType</a> = <span class="delimiter">(</span>
      <a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isFinal</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span class="delimiter">(</span><a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#210549" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107540" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    
    <span class="comment">/** Is this type a subtype of that type in a pattern context?
     *  Any type arguments on the right hand side are replaced with
     *  fresh existentials, except for Arrays.
     *
     *  See bug1434.scala for an example of code which would fail
     *  if only a &lt;:&lt; test were applied.
     */</span>     
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="105517">matchesPattern</a><span class="delimiter">(</span><a title="Types.this.Type" id="403380">that</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="delimiter">(</span><a href="#67392" title="Type.this.type" class="keyword">this</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#403380" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#403380" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>        
        <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>TypeRef<span class="delimiter">(</span>_, <a href="Definitions.scala.html#106394" title="=&gt; Types.this.Symbol">ArrayClass</a>, <a href="#450087" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="450098">arg1</a><span class="delimiter">)</span><span class="delimiter">)</span>, TypeRef<span class="delimiter">(</span>_, <a href="Definitions.scala.html#106394" title="=&gt; Types.this.Symbol">ArrayClass</a>, <a href="#450100" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="450111">arg2</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#450111" title="Types.this.Type">arg2</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">nonEmpty</span> =&gt;
          <a href="#450098" title="Types.this.Type">arg1</a> <a href="#105517" title="(that: Types.this.Type)Boolean">matchesPattern</a> <a href="#450111" title="Types.this.Type">arg2</a>
        <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>_, TypeRef<span class="delimiter">(</span>_, _, <a title="List[Types.this.Type]" id="450115">args</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="450116">newtp</a> = <a href="#67493" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#450115" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <span class="delimiter">(</span><a href="#450133" title="Types.this.Type">_</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>, <a href="#403380" title="Types.this.Type">that</a><span class="delimiter">)</span>
          <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#403380" title="Types.this.Type">that</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#450116" title="Types.this.Type">newtp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#67392" title="Type.this.type" class="keyword">this</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#450116" title="Types.this.Type">newtp</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
          <span title="Boolean(false)" class="keyword">false</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="105518">stat_&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="450045">that</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="../util/Statistics.scala.html#67162" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67211" title="=&gt; scala.tools.nsc.util.Statistics.Counter">subtypeCount</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.tools.nsc.util.Statistics.LongPair" id="450161">start</a> = <a href="../util/Statistics.scala.html#67166" title="(tm: scala.tools.nsc.util.Statistics.Timer)scala.tools.nsc.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67213" title="=&gt; scala.tools.nsc.util.Statistics.Timer">subtypeNanos</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Boolean" id="450162">result</a> = 
        <span class="delimiter">(</span><a href="#67392" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450045" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
        <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67361" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#67676" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="java.lang.String(&quot;&lt;:&quot;)" class="string">&quot;&lt;:&quot;</span>, <a href="#67594" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a>, <a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#450045" title="Types.this.Type">that</a><span class="delimiter">)</span>
         <span class="keyword">else</span> <a href="#67595" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#450045" title="Types.this.Type">that</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="../util/Statistics.scala.html#67167" title="(tm: scala.tools.nsc.util.Statistics.Timer, start: scala.tools.nsc.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67213" title="=&gt; scala.tools.nsc.util.Statistics.Timer">subtypeNanos</a>, <a href="#450161" title="scala.tools.nsc.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
      <a href="#450162" title="Boolean">result</a>
    <span class="delimiter">}</span>

    <span class="comment">/** Is this type a weak subtype of that type? True also for numeric types, i.e. Int weak_&lt;:&lt; Long.
     */</span>
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="105519">weak_&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="450187">that</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="../util/Statistics.scala.html#67162" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67211" title="=&gt; scala.tools.nsc.util.Statistics.Counter">subtypeCount</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.tools.nsc.util.Statistics.LongPair" id="450189">start</a> = <a href="../util/Statistics.scala.html#67166" title="(tm: scala.tools.nsc.util.Statistics.Timer)scala.tools.nsc.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67213" title="=&gt; scala.tools.nsc.util.Statistics.Timer">subtypeNanos</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Boolean" id="450190">result</a> =
        <span class="delimiter">(</span><span class="delimiter">(</span><a href="#67392" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450187" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
         <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67361" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#67676" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="java.lang.String(&quot;weak_&lt;:&quot;)" class="string">&quot;weak_&lt;:&quot;</span>, <a href="#67643" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isWeakSubType</a>, <a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#450187" title="Types.this.Type">that</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#67643" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isWeakSubType</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#450187" title="Types.this.Type">that</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="../util/Statistics.scala.html#67167" title="(tm: scala.tools.nsc.util.Statistics.Timer, start: scala.tools.nsc.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67213" title="=&gt; scala.tools.nsc.util.Statistics.Timer">subtypeNanos</a>, <a href="#450189" title="scala.tools.nsc.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
      <a href="#450190" title="Boolean">result</a>
    <span class="delimiter">}</span>

    <span class="comment">/** Is this type equivalent to that type? */</span>
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="105520">=:=</a><span class="delimiter">(</span><a title="Types.this.Type" id="210557">that</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span>
      <span class="delimiter">(</span><a href="#67392" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#210557" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
      <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67361" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#67676" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="java.lang.String(&quot;=&quot;)" class="string">&quot;=&quot;</span>, <a href="#67577" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a>, <a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#210557" title="Types.this.Type">that</a><span class="delimiter">)</span>
       <span class="keyword">else</span> <a href="#67577" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#210557" title="Types.this.Type">that</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>;

    <span class="comment">/** Does this type implement symbol `sym' with same or stronger type?
     */</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="105521">specializes</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="450249">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67361" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#67676" title="(op: String, p: (Types.this.Type, Types.this.Symbol) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Symbol)Boolean">explain</a><span class="delimiter">(</span><span title="java.lang.String(&quot;specializes&quot;)" class="string">&quot;specializes&quot;</span>, <a href="#67614" title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean">specializesSym</a>, <a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#450249" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#67614" title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#450249" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>

    <span class="comment">/** Is this type close enough to that type so that members
     *  with the two type would override each other?
     *  This means: 
     *    - Either both types are polytypes with the same number of
     *      type parameters and their result types match after renaming 
     *      corresponding type parameters
     *    - Or both types are (nullary) method types with equivalent type parameter types
     *      and matching result types
     *    - Or both types are equivalent
     *    - Or phase.erasedTypes is false and both types are neither method nor
     *      poly types.
     */</span>
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="105522">matches</a><span class="delimiter">(</span><a title="Types.this.Type" id="314104">that</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#67616" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#314104" title="Types.this.Type">that</a>, <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>

    <span class="comment">/** Same as matches, except that non-method types are always assumed to match.
     */</span>
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="105523">looselyMatches</a><span class="delimiter">(</span><a title="Types.this.Type" id="450281">that</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#67616" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#450281" title="Types.this.Type">that</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

    <span class="comment">/** The shortest sorted upwards closed array of types that contains
     *  this type as first element.
     *
     *  A list or array of types ts is upwards closed if
     *
     *    for all t in ts:
     *      for all typerefs p.s[args] such that t &lt;: p.s[args] 
     *      there exists a typeref p'.s[args'] in ts such that 
     *      t &lt;: p'.s['args] &lt;: p.s[args],
     *
     *      and
     *
     *      for all singleton types p.s such that t &lt;: p.s 
     *      there exists a singleton type p'.s in ts such that 
     *      t &lt;: p'.s &lt;: p.s
     *
     *  Sorting is with respect to Symbol.isLess() on type symbols.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="105524">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#67704" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="BaseTypeSeqs.scala.html#67707" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">baseTypeSingletonSeq</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/** The maximum depth (@see maxDepth)
     *  of each type in the BaseTypeSeq of this type.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Int" id="105525">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <span title="Int(1)" class="int">1</span>

    <span class="comment">/** The list of all baseclasses of this type (including its own typeSymbol)
     *  in reverse linearization order, starting with the class itself and ending
     *  in class Any.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="105526">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">/**
     *  @param sym the class symbol
     *  @return    the index of given class symbol in the BaseTypeSeq of this type,
     *             or -1 if no base type with given class symbol exists.
     */</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Int" id="105527">baseTypeIndex</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="446369">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="450291">bts</a> = <a href="#105524" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
      <span class="keyword">var</span> <a title="Int" id="450292">lo</a> = <span title="Int(0)" class="int">0</span>
      <span class="keyword">var</span> <a title="Int" id="450293">hi</a> = <a href="#450291" title="Types.this.BaseTypeSeq">bts</a>.<a href="BaseTypeSeqs.scala.html#197569" title="=&gt; Int">length</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#450292" title="Int">lo</a> <span title="(x: Int)Boolean">&lt;=</span> <a href="#450293" title="Int">hi</a><span class="delimiter">)</span> <a href="#450294" title="()Unit" class="delimiter">{</a>
        <span class="keyword">val</span> <a title="Int" id="450303">mid</a> = <span class="delimiter">(</span><a href="#450292" title="Int">lo</a> <span title="(x: Int)Int">+</span> <a href="#450293" title="Int">hi</a><span class="delimiter">)</span> <span title="(x: Int)Int">/</span> <span title="Int(2)" class="int">2</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="450304">btssym</a> = <a href="#450291" title="Types.this.BaseTypeSeq">bts</a>.<a href="BaseTypeSeqs.scala.html#197574" title="(i: Int)Types.this.Symbol">typeSymbol</a><span class="delimiter">(</span><a href="#450303" title="Int">mid</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#446369" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450304" title="Types.this.Symbol">btssym</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#450303" title="Int">mid</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#446369" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#107586" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#450304" title="Types.this.Symbol">btssym</a><span class="delimiter">)</span> <a href="#450293" title="Int">hi</a> = <a href="#450303" title="Int">mid</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450304" title="Types.this.Symbol">btssym</a> <a href="Symbols.scala.html#107586" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#446369" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#450292" title="Int">lo</a> = <a href="#450303" title="Int">mid</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>
        <span class="keyword">else</span> <a href="SymbolTable.scala.html#64791" title="()Nothing">abort</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      -<span title="Int(-1)" class="int">1</span>
    <span class="delimiter">}</span>

    <span class="comment">/** If this is a poly- or methodtype, a copy with cloned type / value parameters
     *  owned by `owner'. Identity for all other types.
     */</span>
    <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="105528">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="323822">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Make sure this type is correct as the info of given owner; clone it if not.
     */</span>
    <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="105529">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="445897">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="105530">objectPrefix</a> = <span title="java.lang.String(&quot;object &quot;)" class="string">&quot;object &quot;</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="105531">packagePrefix</a> = <span title="java.lang.String(&quot;package &quot;)" class="string">&quot;package &quot;</span>

    <span class="keyword">def</span> <a title="(str: String)java.lang.String" id="105532">trimPrefix</a><span class="delimiter">(</span><a title="String" id="411298">str</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#411298" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">str</a> <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">stripPrefix</span> <a href="#105530" title="=&gt; java.lang.String">objectPrefix</a> <span title="(prefix: String)java.lang.String">stripPrefix</span> <a href="#105531" title="=&gt; java.lang.String">packagePrefix</a>

    <span class="comment">/** The string representation of this type used as a prefix */</span>
    <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="105533">prefixString</a> = <a href="#105532" title="(str: String)java.lang.String">trimPrefix</a><span class="delimiter">(</span><a href="#67392" title="()String">toString</a><span class="delimiter">)</span> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;#&quot;)" class="string">&quot;#&quot;</span>

    <span class="comment">/** The string representation of this type, with singletypes explained */</span>
    <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="105534">toLongString</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="448945">str</a> = <a href="#67392" title="()String">toString</a>
      <span title="java.lang.String" class="keyword">if</span> <span class="delimiter">(</span><a href="#448945" title="String">str</a> <span title="(x$1: java.lang.String)Boolean">endsWith</span> <span title="java.lang.String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span><span class="delimiter">)</span> <a href="#448945" title="String">str</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; (with underlying type &quot;)" class="string">&quot; (with underlying type &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#105458" title="=&gt; Types.this.Type">widen</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
      <span class="keyword">else</span> <a href="#448945" title="String">str</a>
    <span class="delimiter">}</span>

    <span class="comment">/** A test whether a type contains any unification type variables */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105535">isGround</a>: <span title="Boolean">Boolean</span> = <a href="#67392" title="Types.this.Type" class="keyword">this</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#448979" title="Boolean">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="450334">constr</a><span class="delimiter">)</span> =&gt; 
        <a href="#450334" title="Types.this.TypeConstraint">constr</a>.<a href="#449391" title="=&gt; Boolean">instValid</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#450334" title="Types.this.TypeConstraint">constr</a>.<a href="#449389" title="=&gt; Types.this.Type">inst</a>.<a href="#105535" title="=&gt; Boolean">isGround</a>
      <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="450338">pre</a>, <a title="Types.this.Symbol" id="450339">sym</a>, <a title="List[Types.this.Type]" id="450340">args</a><span class="delimiter">)</span> =&gt;
        <a href="#450339" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span> <span title="(x: Boolean)Boolean">||</span> <a href="#450338" title="Types.this.Type">pre</a>.<a href="#105535" title="=&gt; Boolean">isGround</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#450340" title="List[Types.this.Type]">args</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#450347" title="Types.this.Type">_</a>.<a href="#105535" title="=&gt; Boolean">isGround</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="450348">pre</a>, <a title="Types.this.Symbol" id="450349">sym</a><span class="delimiter">)</span> =&gt;
        <a href="#450349" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span> <span title="(x: Boolean)Boolean">||</span> <a href="#450348" title="Types.this.Type">pre</a>.<a href="#105535" title="=&gt; Boolean">isGround</a>
      <span class="keyword">case</span> <span title="Boolean(true)">ThisType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> | <a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a> | <a href="#450864" title="object Types.this.WildcardType">WildcardType</a> | <a href="#450913" title="object Types.this.NoType">NoType</a> | <a href="#450846" title="object Types.this.ErrorType">ErrorType</a> | ConstantType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
        <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt; 
        <a href="#450351" title="(tp: Types.this.Type)Types.this.Type">typeVarToOriginMap</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#67392" title="Types.this.Type" class="keyword">this</a>
    <span class="delimiter">}</span>

    <span class="comment">/** If this is a symbol loader type, load and assign a new type to
     *  `sym'.
     */</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="105536">load</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="440576">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol" id="105537">findDecl</a><span class="delimiter">(</span><a title="Types.this.Name" id="449846">name</a>: <a href="Names.scala.html#66925" title="Types.this.Name">Name</a>, <a title="Int" id="449847">excludedFlags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="450356">alts</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="450357">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a>
      <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="450358">e</a>: <a href="Scopes.scala.html#67689" title="Types.this.ScopeEntry">ScopeEntry</a> = <a href="#105487" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113095" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#449846" title="Types.this.Name">name</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#450358" title="Types.this.ScopeEntry">e</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#450359" title="()Unit" class="delimiter">{</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#450358" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#113275" title="=&gt; Types.this.Symbol">sym</a>.<span title="(mask: Long)Boolean">hasFlag</span><span class="delimiter">(</span><a href="#449847" title="=&gt; Long">excludedFlags</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450357" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#450357" title="Types.this.Symbol">sym</a> = <a href="#450358" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#113275" title="=&gt; Types.this.Symbol">sym</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450356" title="List[Types.this.Symbol]">alts</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#450356" title="List[Types.this.Symbol]">alts</a> = <span title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</span><span class="delimiter">(</span><a href="#450357" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <a href="#450356" title="List[Types.this.Symbol]">alts</a> = <a href="#450358" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#113275" title="=&gt; Types.this.Symbol">sym</a> <a href="#450382" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#450356" title="List[Types.this.Symbol]">alts</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <a href="#450358" title="Types.this.ScopeEntry">e</a> = <a href="#105487" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113096" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a><span class="delimiter">(</span><a href="#450358" title="Types.this.ScopeEntry">e</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#450356" title="List[Types.this.Symbol]">alts</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#450357" title="Types.this.Symbol">sym</a>
      <span class="keyword">else</span> <span class="delimiter">(</span><a href="#105526" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#107435" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.Symbol">newOverloaded</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#450356" title="List[Types.this.Symbol]">alts</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    
    <span class="comment">/**
     *  Find member(s) in this type. If several members matching criteria are found, they are
     *  returned in an OverloadedSymbol
     *  
     *  @param name           The member's name, where nme.ANYNAME means `unspecified' 
     *  @param excludedFlags  Returned members do not have these flags
     *  @param requiredFlags  Returned members do have these flags
     *  @param stableOnly     If set, return only members that are types or stable values
     */</span>
    <span class="comment">//TODO: use narrow only for modules? (correct? efficiency gain?)</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol" id="105538">findMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="449849">name</a>: <a href="Names.scala.html#66925" title="Types.this.Name">Name</a>, <a title="Long" id="449850">excludedFlags</a>: <span title="Long">Long</span>, <a title="Long" id="449851">requiredFlags</a>: <span title="Long">Long</span>, <a title="Boolean" id="449852">stableOnly</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="scala.collection.mutable.HashSet[Types.this.TypeVar]" id="450393">suspension</a>: mutable.<span title="scala.collection.mutable.HashSet[Types.this.TypeVar]">HashSet</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> = <span title="Null(null)" class="keyword">null</span>
      <span class="comment">// if this type contains type variables, put them to sleep for a while -- don't just wipe them out by</span>
      <span class="comment">// replacing them by the corresponding type parameter, as that messes up (e.g.) type variables in type refinements</span>
      <span class="comment">// without this, the matchesType call would lead to type variables on both sides</span>
      <span class="comment">// of a subtyping/equality judgement, which can lead to recursive types being constructed.</span>
      <span class="comment">// See (t0851) for a situation where this happens.</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#67392" title="Type.this.type" class="keyword">this</a>.<a href="#105535" title="=&gt; Boolean">isGround</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">// PP: The foreach below was formerly expressed as:</span>
        <span class="comment">//   for(tv @ TypeVar(_, _) &lt;- this) { suspension suspend tv }</span>
        <span class="comment">//</span>
        <span class="comment">// The tree checker failed this saying a TypeVar is required, but a (Type @unchecked) was found.</span>
        <span class="comment">// This is a consequence of using a pattern match and variable binding + ticket #1503, which</span>
        <span class="comment">// was addressed by weakening the type of bindings in pattern matches if they occur on the right.</span>
        <span class="comment">// So I'm not quite sure why this works at all, as the checker is right that it is mistyped.</span>
        <span class="comment">// For now I modified it as below, which achieves the same without error.</span>
        <span class="comment">//</span>
        <span class="comment">// make each type var in this type use its original type for comparisons instead of collecting constraints</span>
        <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.TypeVar]" id="450402">susp</a> = <span title="()scala.collection.mutable.HashSet[Types.this.TypeVar]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Types.this.TypeVar]">HashSet</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> <span class="comment">// use a local val so it remains unboxed</span>
        <a href="#67392" title="Type.this.type" class="keyword">this</a> <a href="#105510" title="(f: Types.this.Type =&gt; Unit)Unit">foreach</a> <a href="#450405" title="Unit" class="delimiter">{</a>
          <span class="keyword">case</span> <a title="Unit" id="450406">tv</a>: <a href="#67469" title="Types.this.TypeVar">TypeVar</a>  =&gt; <a href="#450406" title="Types.this.TypeVar">tv</a>.<a href="#449011" title="(x$1: Boolean)Unit">suspended</a> = <span title="Boolean(true)" class="keyword">true</span>; <a href="#450402" title="scala.collection.mutable.HashSet[Types.this.TypeVar]">susp</a> <span title="(elem: Types.this.TypeVar)susp.type">+=</span> <a href="#450406" title="Types.this.TypeVar">tv</a>
          <span class="keyword">case</span> <span title="Unit">_</span>            =&gt; 
        <span class="delimiter">}</span>
        <a href="#450393" title="scala.collection.mutable.HashSet[Types.this.TypeVar]">suspension</a> = <a href="#450402" title="scala.collection.mutable.HashSet[Types.this.TypeVar]">susp</a>
      <span class="delimiter">}</span>

      <a href="../util/Statistics.scala.html#67162" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67199" title="=&gt; scala.tools.nsc.util.Statistics.Counter">findMemberCount</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.tools.nsc.util.Statistics.LongPair" id="450394">start</a> = <a href="../util/Statistics.scala.html#67166" title="(tm: scala.tools.nsc.util.Statistics.Timer)scala.tools.nsc.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67205" title="=&gt; scala.tools.nsc.util.Statistics.Timer">findMemberNanos</a><span class="delimiter">)</span>

      <span class="comment">//Console.println(&quot;find member &quot; + name.decode + &quot; in &quot; + this + &quot;:&quot; + this.baseClasses)//DEBUG</span>
      <span class="keyword">var</span> <a title="Types.this.Scope" id="450395">members</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a> = <span title="Null(null)" class="keyword">null</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="450396">member</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a>
      <span class="keyword">var</span> <a title="Long" id="450397">excluded</a> = <a href="#449850" title="Long">excludedFlags</a> <span title="(x: Int)Long">|</span> <span title="Int(16)">DEFERRED</span>
      <span class="keyword">var</span> <a title="Boolean" id="450398">continue</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">var</span> <a title="Types.this.Type" id="450399">self</a>: <a href="#67392" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
      <span class="keyword">var</span> <a title="Types.this.Type" id="450400">membertpe</a>: <a href="#67392" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#450398" title="Boolean">continue</a><span class="delimiter">)</span> <a href="#450401" title="()Unit" class="delimiter">{</a>
        <a href="#450398" title="Boolean">continue</a> = <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="450423">bcs0</a> = <a href="#105526" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
        <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="450424">bcs</a> = <a href="#450423" title="List[Types.this.Symbol]">bcs0</a>
        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#450424" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#450425" title="()Unit" class="delimiter">{</a>
          <span class="keyword">val</span> <a title="Types.this.Scope" id="450427">decls</a> = <a href="#450424" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105487" title="=&gt; Types.this.Scope">decls</a>
          <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="450428">entry</a> =
            <span title="Types.this.ScopeEntry" class="keyword">if</span> <span class="delimiter">(</span><a href="#449849" title="Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#67724" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115414" title="=&gt; Types.this.nme.NameType">ANYNAME</a><span class="delimiter">)</span> <a href="#450427" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113061" title="=&gt; Types.this.ScopeEntry">elems</a> <span class="keyword">else</span> <a href="#450427" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113095" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#449849" title="Types.this.Name">name</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#450428" title="Types.this.ScopeEntry">entry</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#450429" title="()Unit" class="delimiter">{</a>
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="450437">sym</a> = <a href="#450428" title="Types.this.ScopeEntry">entry</a>.<a href="Scopes.scala.html#113275" title="=&gt; Types.this.Symbol">sym</a>
            <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#450437" title="Types.this.Symbol">sym</a> <span title="(mask: Long)Boolean">hasAllFlags</span> <a href="#449851" title="Long">requiredFlags</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Long" id="450438">excl</a> = <a href="#450437" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107555" title="(mask: Long)Long">getFlag</a><span class="delimiter">(</span><a href="#450397" title="Long">excluded</a><span class="delimiter">)</span>
              <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#450438" title="Long">excl</a> <span title="(x: Long)Boolean">==</span> <span title="Long(0L)" class="long">0L</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
                  <span class="delimiter">(</span><span class="comment">// omit PRIVATE LOCALS unless selector class is contained in class owning the def.</span>
                   <span class="delimiter">(</span><a href="#450424" title="List[Types.this.Symbol]">bcs</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450423" title="List[Types.this.Symbol]">bcs0</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
                   <span title="=&gt; Boolean">!</span><a href="#450437" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPrivateLocal</span> <span title="(x: Boolean)Boolean">||</span>
                   <span class="delimiter">(</span><a href="#450423" title="List[Types.this.Symbol]">bcs0</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#107547" title="(sym: Types.this.Symbol)Boolean">hasTransOwner</a><span class="delimiter">(</span><a href="#450424" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Types.this.Symbol">head</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#449849" title="Types.this.Name">name</a>.<a href="Names.scala.html#96597" title="=&gt; Boolean">isTypeName</a> <span title="(x: Boolean)Boolean">||</span> <a href="#449852" title="Boolean">stableOnly</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#450437" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107514" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <a href="../util/Statistics.scala.html#67167" title="(tm: scala.tools.nsc.util.Statistics.Timer, start: scala.tools.nsc.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67205" title="=&gt; scala.tools.nsc.util.Statistics.Timer">findMemberNanos</a>, <a href="#450394" title="scala.tools.nsc.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
                  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450393" title="scala.collection.mutable.HashSet[Types.this.TypeVar]">suspension</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#450393" title="scala.collection.mutable.HashSet[Types.this.TypeVar]">suspension</a> <span title="(f: Types.this.TypeVar =&gt; Unit)Unit">foreach</span> <span class="delimiter">(</span><a href="#450474" title="Types.this.TypeVar">_</a>.<a href="#449011" title="(x$1: Boolean)Unit">suspended</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
                  <span title="Nothing" class="keyword">return</span> <a href="#450437" title="Types.this.Symbol">sym</a>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#450396" title="Types.this.Symbol">member</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <a href="#450396" title="Types.this.Symbol">member</a> = <a href="#450437" title="Types.this.Symbol">sym</a>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#450395" title="Types.this.Scope">members</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450396" title="Types.this.Symbol">member</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#450437" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a> <span title="(x: Boolean)Boolean">||</span> 
                      <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#450396" title="Types.this.Symbol">member</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450437" title="Types.this.Symbol">sym</a> <span title="(x: Boolean)Boolean">||</span>
                        <a href="#450396" title="Types.this.Symbol">member</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#450437" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                        <span title="=&gt; Boolean">!</span><a href="#450437" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPrivate</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
                          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450399" title="Types.this.Type">self</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#450399" title="Types.this.Type">self</a> = <a href="#67392" title="Type.this.type" class="keyword">this</a>.<a href="#105461" title="=&gt; Types.this.Type">narrow</a>
                          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450400" title="Types.this.Type">membertpe</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#450400" title="Types.this.Type">membertpe</a> = <a href="#450399" title="Types.this.Type">self</a>.<a href="#105502" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#450396" title="Types.this.Symbol">member</a><span class="delimiter">)</span>
                          <span class="delimiter">(</span><a href="#450400" title="Types.this.Type">membertpe</a> <a href="#105522" title="(that: Types.this.Type)Boolean">matches</a> <a href="#450399" title="Types.this.Type">self</a>.<a href="#105502" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#450437" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                        <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#450395" title="Types.this.Scope">members</a> = <a href="Scopes.scala.html#113081" title="(decls: List[Types.this.Symbol])Types.this.Scope" class="keyword">new</a> <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a><span class="delimiter">(</span><span title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</span><span class="delimiter">(</span><a href="#450396" title="Types.this.Symbol">member</a>, <a href="#450437" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  <span class="delimiter">}</span>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                  <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="450512">prevEntry</a> = <a href="#450395" title="Types.this.Scope">members</a>.<a href="Scopes.scala.html#113095" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#450437" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
                  <span class="keyword">var</span> <a title="Types.this.Type" id="450513">symtpe</a>: <a href="#67392" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
                  <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#450512" title="Types.this.ScopeEntry">prevEntry</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                         <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#450512" title="Types.this.ScopeEntry">prevEntry</a>.<a href="Scopes.scala.html#113275" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450437" title="Types.this.Symbol">sym</a> <span title="(x: Boolean)Boolean">||</span>
                           <a href="#450512" title="Types.this.ScopeEntry">prevEntry</a>.<a href="Scopes.scala.html#113275" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#450437" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                           <span title="=&gt; Boolean">!</span><a href="#450437" title="Types.this.Symbol">sym</a>.<span title="(mask: Long)Boolean">hasFlag</span><span class="delimiter">(</span><span title="Long(4L)">PRIVATE</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
                             <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450399" title="Types.this.Type">self</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#450399" title="Types.this.Type">self</a> = <a href="#67392" title="Type.this.type" class="keyword">this</a>.<a href="#105461" title="=&gt; Types.this.Type">narrow</a>
                             <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450513" title="Types.this.Type">symtpe</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#450513" title="Types.this.Type">symtpe</a> = <a href="#450399" title="Types.this.Type">self</a>.<a href="#105502" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#450437" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
                             <a href="#450399" title="Types.this.Type">self</a>.<a href="#105502" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#450512" title="Types.this.ScopeEntry">prevEntry</a>.<a href="Scopes.scala.html#113275" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#105522" title="(that: Types.this.Type)Boolean">matches</a> <a href="#450513" title="Types.this.Type">symtpe</a>
                           <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#450512" title="Types.this.ScopeEntry">prevEntry</a> = <a href="#450395" title="Types.this.Scope">members</a> <a href="Scopes.scala.html#113096" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a> <a href="#450512" title="Types.this.ScopeEntry">prevEntry</a>
                  <span class="delimiter">}</span>
                  <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#450512" title="Types.this.ScopeEntry">prevEntry</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#450395" title="Types.this.Scope">members</a> <a href="Scopes.scala.html#113086" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#450437" title="Types.this.Symbol">sym</a>
                  <span class="delimiter">}</span>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450438" title="Long">excl</a> <span title="(x: Long)Boolean">==</span> <span title="Int(16)">DEFERRED</span>.<span title="=&gt; Long">toLong</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="#450398" title="Boolean">continue</a> = <span title="Boolean(true)" class="keyword">true</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <a href="#450428" title="Types.this.ScopeEntry">entry</a> = <span title="Types.this.ScopeEntry" class="keyword">if</span> <span class="delimiter">(</span><a href="#449849" title="Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#67724" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115414" title="=&gt; Types.this.nme.NameType">ANYNAME</a><span class="delimiter">)</span> <a href="#450428" title="Types.this.ScopeEntry">entry</a>.<a href="Scopes.scala.html#113283" title="=&gt; Types.this.ScopeEntry">next</a> <span class="keyword">else</span> <a href="#450427" title="Types.this.Scope">decls</a> <a href="Scopes.scala.html#113096" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a> <a href="#450428" title="Types.this.ScopeEntry">entry</a>
          <span class="delimiter">}</span> <span class="comment">// while (entry ne null)</span>
          <span class="comment">// excluded = excluded | LOCAL</span>
          <a href="#450424" title="List[Types.this.Symbol]">bcs</a> = <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#449849" title="Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#67724" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115416" title="=&gt; Types.this.nme.NameType">CONSTRUCTOR</a><span class="delimiter">)</span> <span title="object Nil">Nil</span> <span class="keyword">else</span> <a href="#450424" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>
        <span class="delimiter">}</span> <span class="comment">// while (!bcs.isEmpty)</span>
        <a href="#450397" title="Long">excluded</a> = <a href="#449850" title="Long">excludedFlags</a>
      <span class="delimiter">}</span> <span class="comment">// while (continue)</span>
      <a href="../util/Statistics.scala.html#67167" title="(tm: scala.tools.nsc.util.Statistics.Timer, start: scala.tools.nsc.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67205" title="=&gt; scala.tools.nsc.util.Statistics.Timer">findMemberNanos</a>, <a href="#450394" title="scala.tools.nsc.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450393" title="scala.collection.mutable.HashSet[Types.this.TypeVar]">suspension</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#450393" title="scala.collection.mutable.HashSet[Types.this.TypeVar]">suspension</a> <span title="(f: Types.this.TypeVar =&gt; Unit)Unit">foreach</span> <span class="delimiter">(</span><a href="#450580" title="Types.this.TypeVar">_</a>.<a href="#449011" title="(x$1: Boolean)Unit">suspended</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#450395" title="Types.this.Scope">members</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450396" title="Types.this.Symbol">member</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="../util/Statistics.scala.html#67162" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67201" title="=&gt; scala.tools.nsc.util.Statistics.Counter">noMemberCount</a><span class="delimiter">)</span>
        <a href="#450396" title="Types.this.Symbol">member</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="../util/Statistics.scala.html#67162" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67203" title="=&gt; scala.tools.nsc.util.Statistics.Counter">multMemberCount</a><span class="delimiter">)</span>
        <a href="#105526" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#107435" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.Symbol">newOverloaded</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="#450395" title="Types.this.Scope">members</a>.<a href="Scopes.scala.html#113097" title="=&gt; List[Types.this.Symbol]">toList</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** The existential skolems and existentially quantified variables which are free in this type */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="105539">existentialSkolems</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="450595">boundSyms</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="450596">skolems</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="450612">t</a> &lt;- <a href="#105510" title="(f: Types.this.Type =&gt; Unit)Unit" class="keyword">this</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#450612" title="Types.this.Type">t</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Unit">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="450613">quantified</a>, <a title="Types.this.Type" id="450614">qtpe</a><span class="delimiter">)</span> =&gt;
            <a href="#450595" title="List[Types.this.Symbol]">boundSyms</a> = <a href="#450595" title="List[Types.this.Symbol]">boundSyms</a> <a href="#450615" title="(prefix: List[Types.this.Symbol])List[Types.this.Symbol]">:::</a> <a href="#450613" title="List[Types.this.Symbol]">quantified</a>
          <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="450623">sym</a>, _<span class="delimiter">)</span> =&gt;
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#450623" title="Types.this.Symbol">sym</a> <span title="(mask: Long)Boolean">hasFlag</span> <span title="Long(34359738368L)">EXISTENTIAL</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#450595" title="List[Types.this.Symbol]">boundSyms</a> <span title="(elem: Any)Boolean">contains</span> <a href="#450623" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#450596" title="List[Types.this.Symbol]">skolems</a> <span title="(elem: Any)Boolean">contains</span> <a href="#450623" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#450596" title="List[Types.this.Symbol]">skolems</a> = <a href="#450623" title="Types.this.Symbol">sym</a> <a href="#450624" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#450596" title="List[Types.this.Symbol]">skolems</a>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#450596" title="List[Types.this.Symbol]">skolems</a>
    <span class="delimiter">}</span>

    <span class="comment">/** Return the annotations on this type. */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.AnnotationInfo]" id="105540">annotations</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span> = <span title="object Nil">Nil</span>

    <span class="comment">/** Test for the presence of an annotation */</span>
    <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Boolean" id="105541">hasAnnotation</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="450628">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#105540" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a> <span title="(p: Types.this.AnnotationInfo =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <a href="#450643" title="Types.this.AnnotationInfo">_</a>.<a href="AnnotationInfos.scala.html#133491" title="=&gt; Types.this.Type">atp</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450628" title="Types.this.Symbol">clazz</a> <span class="delimiter">}</span>

    <span class="comment">/** Add an annotation to this type */</span>
    <span class="keyword">def</span> <a title="(annot: Types.this.AnnotationInfo)Types.this.Type" id="105542">withAnnotation</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="450649">annot</a>: <a href="AnnotationInfos.scala.html#67754" title="Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span> = <a href="#105543" title="(annots: List[Types.this.AnnotationInfo])Types.this.Type">withAnnotations</a><span class="delimiter">(</span><span title="(xs: Types.this.AnnotationInfo*)List[Types.this.AnnotationInfo]">List</span><span class="delimiter">(</span><a href="#450649" title="Types.this.AnnotationInfo">annot</a><span class="delimiter">)</span><span class="delimiter">)</span>
    
    <span class="comment">/** Add a number of annotations to this type */</span>
    <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="105543">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="449649">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
      <a href="#449649" title="List[Types.this.AnnotationInfo]">annots</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">Nil</span> =&gt; <a href="#67392" title="Types.this.Type" class="keyword">this</a>
        <span class="keyword">case</span> <span title="Types.this.AnnotatedType">_</span> =&gt; <a href="#149016" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#449649" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#67392" title="Types.this.Type" class="keyword">this</a>, <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      
    <span class="comment">/** Remove any annotations from this type */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105544">withoutAnnotations</a> = <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Remove any annotations from this type and from any
     *  types embedded in this type. */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105545">stripAnnotations</a> = <a href="#450673" title="(tp: Types.this.Type)Types.this.Type">StripAnnotationsMap</a><span class="delimiter">(</span><a href="#67392" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/** Set the self symbol of an annotated type, or do nothing
     *  otherwise.  */</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="105546">withSelfsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="450678">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#67392" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** The selfsym of an annotated type, or NoSymbol of anything else */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="105547">selfsym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a>

    <span class="comment">/** The kind of this type; used for debugging */</span>
    <span class="keyword">def</span> <a title="=&gt; String" id="105548">kind</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;unknown type of class &quot;)" class="string">&quot;unknown type of class &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#67392" title="()java.lang.Class[_]">getClass</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

<span class="comment">// Subclasses ------------------------------------------------------------</span>

  <span class="keyword">trait</span> <a title="trait UniqueType extends java.lang.Object with ScalaObject" id="67393">UniqueType</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Int" id="450688">hashCode</a>: <span title="Int">Int</span> = <a href="#67393" title="Types.this.UniqueType" class="keyword">super</a>.<span title="()Int">hashCode</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

 <span class="comment">/** A base class for types that defer some operations
   *  to their immediate supertype.
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SubType extends Types.this.Type with ScalaObject" id="67394">SubType</a> <a href="#67394" title="ScalaObject" class="keyword">extends</a> <a href="#67392" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148256">supertype</a>: <a href="#67392" title="Types.this.Type">Type</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148257">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#148256" title="=&gt; Types.this.Type">supertype</a>.<a href="#105463" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="148258">decls</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a> = <a href="#148256" title="=&gt; Types.this.Type">supertype</a>.<a href="#105487" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="148259">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="450697">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#148256" title="=&gt; Types.this.Type">supertype</a>.<a href="#105499" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#450697" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="148260">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#67704" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#148256" title="=&gt; Types.this.Type">supertype</a>.<a href="#105524" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148261">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#148256" title="=&gt; Types.this.Type">supertype</a>.<a href="#105525" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148262">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#148256" title="=&gt; Types.this.Type">supertype</a>.<a href="#105526" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148263">isNotNull</a> = <a href="#148256" title="=&gt; Types.this.Type">supertype</a>.<a href="#105448" title="=&gt; Boolean">isNotNull</a>
  <span class="delimiter">}</span>

  case <span class="keyword">class</span> <a title="class NotNullType extends Types.this.SubType with Types.this.RewrappingTypeProxy with ScalaObject with Product with Serializable" id="449814">NotNullType</a><a href="#449814" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="449828">underlying</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67394" title="Types.this.SubType">SubType</a> <span class="keyword">with</span> <a href="#67391" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="449819">supertype</a> = <a href="#449828" title="=&gt; Types.this.Type">underlying</a>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="449820">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="450714">newtp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#449814" title="(underlying: Types.this.Type)Types.this.NotNullType">NotNullType</a><span class="delimiter">(</span><a href="#450714" title="Types.this.Type">newtp</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="449821">isNotNull</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.NotNullType" id="449822">notNull</a> = <a href="#449814" title="Types.this.NotNullType" class="keyword">this</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="449823">deconst</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#449828" title="=&gt; Types.this.Type">underlying</a> <span class="comment">//todo: needed?</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="449824">safeToString</a>: <span title="String">String</span> = <a href="#449828" title="=&gt; Types.this.Type">underlying</a>.<span title="()String">toString</span> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; with NotNull&quot;)" class="string">&quot; with NotNull&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="449825">kind</a> = <span title="java.lang.String(&quot;NotNullType&quot;)" class="string">&quot;NotNullType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A base class for types that represent a single value
   *  (single-types and this-types).
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SingletonType extends Types.this.SubType with Types.this.SimpleTypeProxy with ScalaObject" id="67398">SingletonType</a> <a href="#67398" title="ScalaObject" class="keyword">extends</a> <a href="#67394" title="Types.this.SubType">SubType</a> <span class="keyword">with</span> <a href="#67390" title="Types.this.SimpleTypeProxy">SimpleTypeProxy</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148265">supertype</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148266">isTrivial</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148267">isStable</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148268">isVolatile</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105447" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148269">widen</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105458" title="=&gt; Types.this.Type">widen</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="148270">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#67704" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      <a href="../util/Statistics.scala.html#67162" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67193" title="=&gt; scala.tools.nsc.util.Statistics.Counter">singletonBaseTypeSeqCount</a><span class="delimiter">)</span>
      <a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105524" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#197577" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">prepend</a> <a href="#67398" title="Types.this.SingletonType" class="keyword">this</a>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148271">isHigherKinded</a> = <span title="Boolean(false)" class="keyword">false</span> <span class="comment">// singleton type classifies objects, thus must be kind *</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148272">safeToString</a>: <span title="String">String</span> = <a href="#105533" title="=&gt; java.lang.String">prefixString</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;type&quot;)" class="string">&quot;type&quot;</span>
<span class="comment">/*
    override def typeOfThis: Type = typeSymbol.typeOfThis
    override def bounds: TypeBounds = TypeBounds(this, this)
    override def prefix: Type = NoType
    override def typeArgs: List[Type] = List()
    override def typeParams: List[Symbol] = List()
*/</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An object representing an erroneous type */</span>
  case <span class="keyword">object</span> <a href="#450843" title="object Types.this.ErrorType" id="450846">ErrorType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67392" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="comment">// todo see whether we can do without</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148242">isError</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="148243">decls</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a> = <span title="Types.this.ErrorScope" class="keyword">new</span> <a href="Scopes.scala.html#67695" title="Types.this.ErrorScope">ErrorScope</a><span class="delimiter">(</span><a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol" id="148244">findMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="450799">name</a>: <a href="Names.scala.html#66925" title="Types.this.Name">Name</a>, <a title="Long" id="450800">excludedFlags</a>: <span title="Long">Long</span>, <a title="Long" id="450801">requiredFlags</a>: <span title="Long">Long</span>, <a title="Boolean" id="450802">stableOnly</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="450804">sym</a> = <a href="#148243" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#113093" title="(name: Types.this.Name)Types.this.Symbol">lookup</a> <a href="#450799" title="Types.this.Name">name</a>
      <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#450804" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#450804" title="Types.this.Symbol">sym</a> = <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a>.<a href="Symbols.scala.html#107458" title="(name: Types.this.Name)Types.this.Symbol">newErrorSymbol</a><span class="delimiter">(</span><a href="#450799" title="Types.this.Name">name</a><span class="delimiter">)</span>
        <a href="#148243" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#113086" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#450804" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span>
      <a href="#450804" title="Types.this.Symbol">sym</a>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="148245">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="450830">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="keyword">this</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148246">safeToString</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;&lt;error&gt;&quot;)" class="string">&quot;&lt;error&gt;&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148247">narrow</a>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="keyword">this</span>
    <span class="comment">// override def isNullable: Boolean = true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148248">kind</a> = <span title="java.lang.String(&quot;ErrorType&quot;)" class="string">&quot;ErrorType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An object representing an unknown type, used during type inference.
   *  If you see WildcardType outside of inference it is almost certainly a bug.
   */</span>
  case <span class="keyword">object</span> <a href="#450861" title="object Types.this.WildcardType" id="450864">WildcardType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67392" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148250">isWildcard</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148251">safeToString</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;?&quot;)" class="string">&quot;?&quot;</span>
    <span class="comment">// override def isNullable: Boolean = true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148252">kind</a> = <span title="java.lang.String(&quot;WildcardType&quot;)" class="string">&quot;WildcardType&quot;</span>
  <span class="delimiter">}</span>

  case <span class="keyword">class</span> <a title="class BoundedWildcardType extends Types.this.Type with ScalaObject with Product with Serializable" id="258485">BoundedWildcardType</a><a href="#258485" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.TypeBounds" id="456763">bounds</a>: <a href="#148517" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67392" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="258490">isWildcard</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="258491">safeToString</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;?&quot;)" class="string">&quot;?&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#456763" title="=&gt; Types.this.TypeBounds">bounds</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="258492">kind</a> = <span title="java.lang.String(&quot;BoundedWildcardType&quot;)" class="string">&quot;BoundedWildcardType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An object representing a non-existing type */</span>
  case <span class="keyword">object</span> <a href="#450910" title="object Types.this.NoType" id="450913">NoType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67392" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="132719">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="132720">safeToString</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;&lt;notype&gt;&quot;)" class="string">&quot;&lt;notype&gt;&quot;</span>
    <span class="comment">// override def isNullable: Boolean = true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="132721">kind</a> = <span title="java.lang.String(&quot;NoType&quot;)" class="string">&quot;NoType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An object representing a non-existing prefix */</span>
  case <span class="keyword">object</span> <a href="#450932" title="object Types.this.NoPrefix" id="450935">NoPrefix</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67392" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133407">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133408">isStable</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="133409">prefixString</a> = <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="133410">safeToString</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;&lt;noprefix&gt;&quot;)" class="string">&quot;&lt;noprefix&gt;&quot;</span>
    <span class="comment">// override def isNullable: Boolean = true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="133411">kind</a> = <span title="java.lang.String(&quot;NoPrefixType&quot;)" class="string">&quot;NoPrefixType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class for this-types of the form &lt;sym&gt;.this.type 
   */</span>
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a title="class ThisType extends Types.this.SingletonType with ScalaObject with Product with Serializable" id="148319">ThisType</a><a href="#148319" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="148327">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67398" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="comment">//assert(sym.isClass &amp;&amp; !sym.isModuleClass || sym.isRoot, sym)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148277">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#148327" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148278">isNotNull</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148279">typeSymbol</a> = <a href="#148327" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148280">underlying</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#148327" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107599" title="=&gt; Types.this.Type">typeOfThis</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148281">isVolatile</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148282">isHigherKinded</a> = <a href="#148327" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isRefinementClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#148280" title="=&gt; Types.this.Type">underlying</a>.<a href="#105445" title="=&gt; Boolean">isHigherKinded</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148283">prefixString</a> =
      <span title="java.lang.String" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#148327" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107655" title="=&gt; java.lang.String">nameString</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;.this.&quot;)" class="string">&quot;.this.&quot;</span>
      <span class="keyword">else</span> <span title="java.lang.String" class="keyword">if</span> <span class="delimiter">(</span><a href="#148327" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107489" title="=&gt; Boolean">isAnonOrRefinementClass</a><span class="delimiter">)</span> <span title="java.lang.String(&quot;this.&quot;)" class="string">&quot;this.&quot;</span>
      <span class="keyword">else</span> <span title="java.lang.String" class="keyword">if</span> <span class="delimiter">(</span><a href="#148327" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107500" title="=&gt; Boolean">printWithoutPrefix</a><span class="delimiter">)</span> <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <span title="java.lang.String" class="keyword">if</span> <span class="delimiter">(</span><a href="#148327" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isModuleClass</span><span class="delimiter">)</span> <a href="#148327" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; String">fullName</span> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      <span class="keyword">else</span> <a href="#148327" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107655" title="=&gt; java.lang.String">nameString</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;.this.&quot;)" class="string">&quot;.this.&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148284">safeToString</a>: <span title="String">String</span> =
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#148327" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isRoot</span><span class="delimiter">)</span> <span title="java.lang.String(&quot;&lt;root&gt;&quot;)" class="string">&quot;&lt;root&gt;&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#148327" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isEmptyPackageClass</span><span class="delimiter">)</span> <span title="java.lang.String(&quot;&lt;empty&gt;&quot;)" class="string">&quot;&lt;empty&gt;&quot;</span>
      <span class="keyword">else</span> <a href="#148319" title="Types.this.ThisType" class="keyword">super</a>.<a href="#148272" title="=&gt; String">safeToString</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148285">narrow</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#148319" title="Types.this.ThisType" class="keyword">this</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148286">kind</a> = <span title="java.lang.String(&quot;ThisType&quot;)" class="string">&quot;ThisType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueThisType extends Types.this.ThisType with Types.this.UniqueType with ScalaObject" id="67413">UniqueThisType</a><a href="#67413" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="450992">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#148319" title="Types.this.ThisType">ThisType</a><span class="delimiter">(</span><a href="#450992" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#67393" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object Types.this.ThisType" id="67411">ThisType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24037" title="Types.this.ThisTypeExtractor">ThisTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="148254">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="159891">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#67506" title="(tp: Types.this.UniqueThisType)Types.this.UniqueThisType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueThisType" class="keyword">new</span> <a href="#67413" title="Types.this.UniqueThisType">UniqueThisType</a><span class="delimiter">(</span><a href="#159891" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#159891" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isImplClass</span><span class="delimiter">)</span> <a href="#159891" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107599" title="=&gt; Types.this.Type">typeOfThis</a>
      <span class="keyword">else</span> <a href="#159891" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class for singleton types of the form &lt;prefix&gt;.&lt;sym.name&gt;.type.
   *  Cannot be created directly; one should always use
   *  `singleType' for creation.
   */</span>
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a title="class SingleType extends Types.this.SingletonType with ScalaObject with Product with Serializable" id="148357">SingleType</a><a href="#148357" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="148371">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="148372">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67398" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="148339">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#148371" title="=&gt; Types.this.Type">pre</a>.<a href="#105444" title="=&gt; Boolean">isTrivial</a>
    <span class="comment">// override def isNullable = underlying.isNullable</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148341">isNotNull</a> = <a href="#148348" title="=&gt; Types.this.Type">underlying</a>.<a href="#105448" title="=&gt; Boolean">isNotNull</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="148343">underlyingCache</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#450913" title="object Types.this.NoType">NoType</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="148346">underlyingPeriod</a> = <span title="Int(0)">NoPeriod</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148348">underlying</a>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="451010">period</a> = <a href="#148346" title="=&gt; Int">underlyingPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#451010" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#64812" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#148346" title="(x$1: Int)Unit">underlyingPeriod</a> = <a href="SymbolTable.scala.html#64812" title="=&gt; Types.this.Period">currentPeriod</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64821" title="(period: Types.this.Period)Boolean">isValid</a><span class="delimiter">(</span><a href="#451010" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#148343" title="(x$1: Types.this.Type)Unit">underlyingCache</a> = <a href="#148371" title="=&gt; Types.this.Type">pre</a>.<a href="#105502" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#148372" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#105468" title="=&gt; Types.this.Type">resultType</a>;
          <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#148343" title="=&gt; Types.this.Type">underlyingCache</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#148357" title="Types.this.SingleType" class="keyword">this</a>, <a href="#148357" title="Types.this.SingleType" class="keyword">this</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#148343" title="=&gt; Types.this.Type">underlyingCache</a>
    <span class="delimiter">}</span>

    <span class="comment">// more precise conceptually, but causes cyclic errors:    (paramss exists (_ contains sym))</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148349">isImmediatelyDependent</a> = <span class="delimiter">(</span><a href="#148372" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#148372" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>.<span title="=&gt; Boolean">isMethod</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#148372" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107470" title="=&gt; Boolean">isValueParameter</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148350">isVolatile</a> : <span title="Boolean">Boolean</span> = <a href="#148348" title="=&gt; Types.this.Type">underlying</a>.<a href="#105447" title="=&gt; Boolean">isVolatile</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#148372" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107514" title="=&gt; Boolean">isStable</a>
<span class="comment">/*
    override def narrow: Type = {
      if (phase.erasedTypes) this
      else {
        val thissym = refinedType(List(this), sym.owner, EmptyScope).typeSymbol
        if (sym.owner != NoSymbol) {
          //Console.println(&quot;narrowing module &quot; + sym + thissym.owner);
          thissym.typeOfThis = this
        }
        thissym.thisType
      }
    }
*/</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148351">narrow</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#148357" title="Types.this.SingleType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148352">termSymbol</a> = <a href="#148372" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148353">prefix</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#148371" title="=&gt; Types.this.Type">pre</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148354">prefixString</a>: <span title="String">String</span> = 
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#148372" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isEmptyPackage</span> <span title="(x: Boolean)Boolean">||</span> <a href="#148372" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107511" title="=&gt; Boolean">isInterpreterWrapper</a> <span title="(x: Boolean)Boolean">||</span> <a href="#148372" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107495" title="=&gt; Boolean">isPredefModule</a> <span title="(x: Boolean)Boolean">||</span> <a href="#148372" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107496" title="=&gt; Boolean">isScalaPackage</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <a href="#148371" title="=&gt; Types.this.Type">pre</a>.<a href="#105533" title="=&gt; java.lang.String">prefixString</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="#148372" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107655" title="=&gt; java.lang.String">nameString</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148355">kind</a> = <span title="java.lang.String(&quot;SingleType&quot;)" class="string">&quot;SingleType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueSingleType extends Types.this.SingleType with Types.this.UniqueType with ScalaObject" id="67417">UniqueSingleType</a><a href="#67417" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="451069">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="451070">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#148357" title="Types.this.SingleType">SingleType</a><span class="delimiter">(</span><a href="#451069" title="Types.this.Type">pre</a>, <a href="#451070" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#67393" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object Types.this.SingleType" id="67415">SingleType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24037" title="Types.this.SingleTypeExtractor">SingleTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="148331">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="451072">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="451073">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#67506" title="(tp: Types.this.UniqueSingleType)Types.this.UniqueSingleType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueSingleType" class="keyword">new</span> <a href="#67417" title="Types.this.UniqueSingleType">UniqueSingleType</a><span class="delimiter">(</span><a href="#451072" title="Types.this.Type">pre</a>, <a href="#451073" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a title="class SuperType extends Types.this.SingletonType with ScalaObject with Product with Serializable" id="149280">SuperType</a><a href="#149280" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="149294">thistpe</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="149295">supertpe</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67398" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="149270">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#149294" title="=&gt; Types.this.Type">thistpe</a>.<a href="#105444" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#149295" title="=&gt; Types.this.Type">supertpe</a>.<a href="#105444" title="=&gt; Boolean">isTrivial</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="149272">isNotNull</a> = <span title="Boolean(true)" class="keyword">true</span>;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="149273">typeSymbol</a> = <a href="#149294" title="=&gt; Types.this.Type">thistpe</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149274">underlying</a> = <a href="#149295" title="=&gt; Types.this.Type">supertpe</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149275">prefix</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#149295" title="=&gt; Types.this.Type">supertpe</a>.<a href="#105464" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="149276">prefixString</a> = <a href="#149294" title="=&gt; Types.this.Type">thistpe</a>.<a href="#105533" title="=&gt; java.lang.String">prefixString</a>.<span title="(x$1: java.lang.String, x$2: java.lang.String)java.lang.String">replaceAll</span><span class="delimiter">(</span><span title="java.lang.String(&quot;this\\.$&quot;)" class="string">&quot;&quot;&quot;this\.$&quot;&quot;&quot;</span>, <span title="java.lang.String(&quot;super.&quot;)" class="string">&quot;super.&quot;</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149277">narrow</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#149294" title="=&gt; Types.this.Type">thistpe</a>.<a href="#105461" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="149278">kind</a> = <span title="java.lang.String(&quot;SuperType&quot;)" class="string">&quot;SuperType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueSuperType extends Types.this.SuperType with Types.this.UniqueType with ScalaObject" id="67421">UniqueSuperType</a><a href="#67421" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="451131">thistp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="451132">supertp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#149280" title="Types.this.SuperType">SuperType</a><span class="delimiter">(</span><a href="#451131" title="Types.this.Type">thistp</a>, <a href="#451132" title="Types.this.Type">supertp</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#67393" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object Types.this.SuperType" id="67419">SuperType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24037" title="Types.this.SuperTypeExtractor">SuperTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(thistp: Types.this.Type, supertp: Types.this.Type)Types.this.Type" id="149262">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="451134">thistp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="451135">supertp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#451135" title="Types.this.Type">supertp</a>
      <span class="keyword">else</span> <a href="#67506" title="(tp: Types.this.UniqueSuperType)Types.this.UniqueSuperType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueSuperType" class="keyword">new</span> <a href="#67421" title="Types.this.UniqueSuperType">UniqueSuperType</a><span class="delimiter">(</span><a href="#451134" title="Types.this.Type">thistp</a>, <a href="#451135" title="Types.this.Type">supertp</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class for the bounds of abstract types and type parameters
   */</span>
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a title="class TypeBounds extends Types.this.SubType with ScalaObject with Product with Serializable" id="148517">TypeBounds</a><a href="#148517" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="148531">lo</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="148532">hi</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67394" title="Types.this.SubType">SubType</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148509">supertype</a> = <a href="#148532" title="=&gt; Types.this.Type">hi</a>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="148510">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#148531" title="=&gt; Types.this.Type">lo</a>.<a href="#105444" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#148532" title="=&gt; Types.this.Type">hi</a>.<a href="#105444" title="=&gt; Boolean">isTrivial</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="148512">bounds</a>: <a href="#148517" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#148517" title="Types.this.TypeBounds" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="148513">containsType</a><span class="delimiter">(</span><a title="Types.this.Type" id="258515">that</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#258515" title="Types.this.Type">that</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">TypeBounds</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#258515" title="Types.this.Type">that</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#148517" title="Types.this.TypeBounds" class="keyword">this</a> 
      <span class="keyword">case</span> <span title="Boolean">_</span>                =&gt; <a href="#148531" title="=&gt; Types.this.Type">lo</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#258515" title="Types.this.Type">that</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#258515" title="Types.this.Type">that</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#148532" title="=&gt; Types.this.Type">hi</a>
    <span class="delimiter">}</span>
    <span class="comment">// override def isNullable: Boolean = NullClass.tpe &lt;:&lt; lo;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148514">safeToString</a> = <span title="java.lang.String(&quot;&gt;: &quot;)" class="string">&quot;&gt;: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#148531" title="=&gt; Types.this.Type">lo</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &lt;: &quot;)" class="string">&quot; &lt;: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#148532" title="=&gt; Types.this.Type">hi</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148515">kind</a> = <span title="java.lang.String(&quot;TypeBoundsType&quot;)" class="string">&quot;TypeBoundsType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueTypeBounds extends Types.this.TypeBounds with Types.this.UniqueType with ScalaObject" id="67425">UniqueTypeBounds</a><a href="#67425" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="451185">lo</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="451186">hi</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#148517" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#451185" title="Types.this.Type">lo</a>, <a href="#451186" title="Types.this.Type">hi</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#67393" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object Types.this.TypeBounds" id="67423">TypeBounds</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24037" title="Types.this.TypeBoundsExtractor">TypeBoundsExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="148498">empty</a>: <a href="#148517" title="Types.this.TypeBounds">TypeBounds</a>           = <a href="#148501" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>, <a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(hi: Types.this.Type)Types.this.TypeBounds" id="148499">upper</a><span class="delimiter">(</span><a title="Types.this.Type" id="446264">hi</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#148517" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#148501" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>, <a href="#446264" title="Types.this.Type">hi</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(lo: Types.this.Type)Types.this.TypeBounds" id="148500">lower</a><span class="delimiter">(</span><a title="Types.this.Type" id="451190">lo</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#148517" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#148501" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="#451190" title="Types.this.Type">lo</a>, <a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds" id="148501">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="236412">lo</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="236413">hi</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#148517" title="Types.this.TypeBounds">TypeBounds</a> = <span class="delimiter">{</span>
      <a href="#67506" title="(tp: Types.this.UniqueTypeBounds)Types.this.UniqueTypeBounds">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueTypeBounds" class="keyword">new</span> <a href="#67425" title="Types.this.UniqueTypeBounds">UniqueTypeBounds</a><span class="delimiter">(</span><a href="#236412" title="Types.this.Type">lo</a>, <a href="#236413" title="Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.TypeBounds" class="delimiter">[</span><a href="#148517" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">]</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A common base class for intersection types and class types 
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class CompoundType extends Types.this.Type with ScalaObject" id="67426">CompoundType</a> <a href="#67426" title="ScalaObject" class="keyword">extends</a> <a href="#67392" title="Types.this.Type">Type</a> <span class="delimiter">{</span>

    <span class="keyword">var</span> <a title="Types.this.BaseTypeSeq" id="148579">baseTypeSeqCache</a>: <a href="BaseTypeSeqs.scala.html#67704" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="148582">baseTypeSeqPeriod</a> = <span title="Int(0)">NoPeriod</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="148585">baseClassesCache</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="148588">baseClassesPeriod</a> = <span title="Int(0)">NoPeriod</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="148590">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#67704" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="451202">period</a> = <a href="#148582" title="=&gt; Int">baseTypeSeqPeriod</a>;
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#451202" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#64812" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// no caching in IDE</span>
        <a href="#148582" title="(x$1: Int)Unit">baseTypeSeqPeriod</a> = <a href="SymbolTable.scala.html#64812" title="=&gt; Types.this.Period">currentPeriod</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64822" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#451202" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#105463" title="=&gt; List[Types.this.Type]">parents</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#451220" title="Types.this.Type">_</a>.<a href="#105512" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#451222" title="Types.this.Type">_</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#67469" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="comment">// rename type vars to fresh type params, take base type sequence of</span>
            <span class="comment">// resulting type, and rename back all the entries in that sequence</span>
            <span class="keyword">var</span> <a title="scala.collection.immutable.Set[Types.this.TypeVar]" id="451223">tvs</a> = <span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.TypeVar*)scala.collection.immutable.Set[Types.this.TypeVar]" class="delimiter">[</span><a href="#67469" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
            <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="451251">p</a> &lt;- <a href="#105463" title="(f: Types.this.Type =&gt; Unit)Unit">parents</a><span class="delimiter">)</span>
              <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="451253">t</a> &lt;- <a href="#105510" title="(f: Types.this.Type =&gt; Unit)Unit">p</a><span class="delimiter">)</span> <a href="#451253" title="Types.this.Type">t</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <a title="Unit" id="451254">tv</a>: <a href="#67469" title="Types.this.TypeVar">TypeVar</a> =&gt; <a href="#451223" title="scala.collection.immutable.Set[Types.this.TypeVar]">tvs</a> <span title="(elem: Types.this.TypeVar)scala.collection.immutable.Set[Types.this.TypeVar]">+=</span> <a href="#451254" title="Types.this.TypeVar">tv</a>
                <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
              <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="Map[Types.this.Type,Types.this.Symbol]" id="451224">varToParamMap</a>: <span title="Map[Types.this.Type,Types.this.Symbol]">Map</span><span class="delimiter">[</span>Type, Symbol<span class="delimiter">]</span> = <a href="#451223" title="scala.collection.immutable.Set[Types.this.TypeVar]">tvs</a> <span title="(f: Types.this.TypeVar =&gt; (Types.this.TypeVar, Types.this.Symbol))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[Types.this.TypeVar],(Types.this.TypeVar, Types.this.Symbol),scala.collection.immutable.Set[(Types.this.TypeVar, Types.this.Symbol)]])scala.collection.immutable.Set[(Types.this.TypeVar, Types.this.Symbol)]">map</span> <span class="delimiter">(</span><a title="Types.this.TypeVar" id="451298">tv</a> =&gt; <a href="#451298" title="(x: Types.this.TypeVar)ArrowAssoc[Types.this.TypeVar]">tv</a> <span title="(y: Types.this.Symbol)(Types.this.TypeVar, Types.this.Symbol)">-&gt;</span> <a href="#451298" title="Types.this.TypeVar">tv</a>.<a href="#454817" title="=&gt; Types.this.Type">origin</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107594" title="=&gt; Types.this.Symbol">cloneSymbol</a><span class="delimiter">)</span> <span title="(implicit ev: &lt;:&lt;[(Types.this.TypeVar, Types.this.Symbol),(Types.this.Type, Types.this.Symbol)])scala.collection.immutable.Map[Types.this.Type,Types.this.Symbol]">toMap</span> 
            <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]" id="451225">paramToVarMap</a> = <a href="#451224" title="Map[Types.this.Type,Types.this.Symbol]">varToParamMap</a> <span title="(f: (Types.this.Type, Types.this.Symbol) =&gt; (Types.this.Symbol, Types.this.Type))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[Types.this.Type,Types.this.Symbol],(Types.this.Symbol, Types.this.Type),scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]])scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#451384" title="(Types.this.Type, Types.this.Symbol)">_</a>.<span title="=&gt; (Types.this.Symbol, Types.this.Type)">swap</span><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.TypeMap" id="451226">varToParam</a> = <a href="#451423" title="Types.this.TypeMap" class="keyword">new</a> <a href="#67514" title="anonymous class $anon extends Types.this.TypeMap" id="451423">TypeMap</a> <span class="delimiter">{</span>
              <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="451425">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="451426">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#451224" title="Map[Types.this.Type,Types.this.Symbol]">varToParamMap</a> <span title="(key: Types.this.Type)Option[Types.this.Symbol]">get</span> <a href="#451426" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Types.this.Type">Some</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="451431">sym</a><span class="delimiter">)</span> =&gt; <a href="#451431" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
                <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#451426" title="Types.this.Type">tp</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="Types.this.TypeMap" id="451227">paramToVar</a> = <a href="#451450" title="Types.this.TypeMap" class="keyword">new</a> <a href="#67514" title="anonymous class $anon extends Types.this.TypeMap" id="451450">TypeMap</a> <span class="delimiter">{</span>
              <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="451452">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="451453">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#451453" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="451455">tsym</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#451225" title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]">paramToVarMap</a>.<span title="(key: Types.this.Symbol)Boolean">isDefinedAt</span><span class="delimiter">(</span><a href="#451455" title="Types.this.Symbol">tsym</a><span class="delimiter">)</span> =&gt; <a href="#451225" title="(key: Types.this.Symbol)Types.this.Type">paramToVarMap</a><span class="delimiter">(</span><a href="#451455" title="Types.this.Symbol">tsym</a><span class="delimiter">)</span>
                <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#451453" title="Types.this.Type">tp</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="451228">bts</a> = <a href="#67482" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#67426" title="CompoundType.this.type" class="keyword">this</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.RefinedType" class="delimiter">[</span><a href="#148576" title="Types.this.RefinedType">RefinedType</a><span class="delimiter">]</span>, <a href="#105463" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#451226" title="Types.this.TypeMap">varToParam</a>, <a href="#451226" title="Types.this.TypeMap">varToParam</a> <a href="#133460" title="(scope: Types.this.Scope)Types.this.Scope">mapOver</a> <a href="#105487" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span>.<a href="#105524" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
            <a href="#148579" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="#451228" title="Types.this.BaseTypeSeq">bts</a> <a href="BaseTypeSeqs.scala.html#197580" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">lateMap</a> <a href="#451227" title="Types.this.TypeMap">paramToVar</a>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <a href="../util/Statistics.scala.html#67162" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67195" title="=&gt; scala.tools.nsc.util.Statistics.Counter">compoundBaseTypeSeqCount</a><span class="delimiter">)</span>
            <a href="#148579" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="BaseTypeSeqs.scala.html#67705" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a>
            <a href="#148579" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <span title="Types.this.BaseTypeSeq" class="keyword">if</span> <span class="delimiter">(</span><a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isRefinementClass</span><span class="delimiter">)</span>
              <a href="#148593" title="(op1: =&gt; Types.this.BaseTypeSeq)(op2: Types.this.Type =&gt; Types.this.BaseTypeSeq)Types.this.BaseTypeSeq">memo</a><span class="delimiter">(</span><a href="BaseTypeSeqs.scala.html#67708" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">compoundBaseTypeSeq</a><span class="delimiter">(</span><a href="#67426" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#451646" title="Types.this.Type">_</a>.<a href="#105524" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#197578" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">updateHead</a> <a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
            <span class="keyword">else</span>
              <a href="BaseTypeSeqs.scala.html#67708" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">compoundBaseTypeSeq</a><span class="delimiter">(</span><a href="#67426" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span>
            <span class="comment">// [Martin] suppressing memo-ization solves the problem with &quot;same type after erasure&quot; errors</span>
            <span class="comment">// when compiling with </span>
            <span class="comment">// scalac scala.collection.IterableViewLike.scala scala.collection.IterableLike.scala</span>
            <span class="comment">// I have not yet figured out precisely why this is the case.</span>
            <span class="comment">// My current assumption is that taking memos forces baseTypeSeqs to be computed</span>
            <span class="comment">// at stale types (i.e. the underlying typeSymbol has already another type).</span>
            <span class="comment">// I do not yet see precisely why this would cause a problem, but it looks</span>
            <span class="comment">// fishy in any case.</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="comment">//Console.println(&quot;baseTypeSeq(&quot; + typeSymbol + &quot;) = &quot; + baseTypeSeqCache.toList);//DEBUG</span>
      <span class="delimiter">}</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#148579" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="BaseTypeSeqs.scala.html#67705" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">throw</span> <a href="#313958" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#67669" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="java.lang.String(&quot;illegal cyclic inheritance involving &quot;)" class="string">&quot;illegal cyclic inheritance involving &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
      <a href="#148579" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148591">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#148590" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#197582" title="=&gt; Int">maxDepth</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148592">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="451655">computeBaseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
        <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#105463" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</span><span class="delimiter">(</span><a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="comment">//Console.println(&quot;computing base classes of &quot; + typeSymbol + &quot; at phase &quot; + phase);//DEBUG</span>
          <span class="comment">// optimized, since this seems to be performance critical</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="451665">superclazz</a> = <a href="#105463" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Types.this.Type">head</span>
          <span class="keyword">var</span> <a title="List[Types.this.Type]" id="451666">mixins</a> = <a href="#105463" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; List[Types.this.Type]">tail</span>
          <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="451667">sbcs</a> = <a href="#451665" title="Types.this.Type">superclazz</a>.<a href="#105526" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
          <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="451668">bcs</a> = <a href="#451667" title="List[Types.this.Symbol]">sbcs</a>
          <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Boolean" id="451669">isNew</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="451673">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span>
            <a href="#451665" title="Types.this.Type">superclazz</a>.<a href="#105527" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#451673" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <span class="delimiter">{</span> <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="451678">p</a> = <a href="#451668" title="List[Types.this.Symbol]">bcs</a>;
              <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#451678" title="List[Types.this.Symbol]">p</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#451667" title="List[Types.this.Symbol]">sbcs</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#451678" title="List[Types.this.Symbol]">p</a>.<span title="=&gt; Types.this.Symbol">head</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#451673" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#451678" title="List[Types.this.Symbol]">p</a> = <a href="#451678" title="List[Types.this.Symbol]">p</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>;
              <a href="#451678" title="List[Types.this.Symbol]">p</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#451667" title="List[Types.this.Symbol]">sbcs</a>
            <span class="delimiter">}</span>
          <span class="delimiter">)</span>;
          <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#451666" title="List[Types.this.Type]">mixins</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#451670" title="()Unit" class="delimiter">{</a>
            <span class="keyword">def</span> <a title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]" id="451688">addMixinBaseClasses</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="451689">mbcs</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
              <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#451689" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#451668" title="List[Types.this.Symbol]">bcs</a>
              <span class="keyword">else</span> <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#451669" title="(clazz: Types.this.Symbol)Boolean">isNew</a><span class="delimiter">(</span><a href="#451689" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; Types.this.Symbol">head</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#451689" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; Types.this.Symbol">head</span> <a href="#451690" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#451688" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#451689" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <a href="#451688" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#451689" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span><span class="delimiter">)</span>;
            <a href="#451668" title="List[Types.this.Symbol]">bcs</a> = <a href="#451688" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#451666" title="List[Types.this.Type]">mixins</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#105526" title="=&gt; List[Types.this.Symbol]">baseClasses</a><span class="delimiter">)</span>
            <a href="#451666" title="List[Types.this.Type]">mixins</a> = <a href="#451666" title="List[Types.this.Type]">mixins</a>.<span title="=&gt; List[Types.this.Type]">tail</span>
          <span class="delimiter">}</span>
          <a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="#451696" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#451668" title="List[Types.this.Symbol]">bcs</a>
         <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="Int" id="451656">period</a> = <a href="#148588" title="=&gt; Int">baseClassesPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#451656" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#64812" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#148588" title="(x$1: Int)Unit">baseClassesPeriod</a> = <a href="SymbolTable.scala.html#64812" title="=&gt; Types.this.Period">currentPeriod</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64822" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#451656" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#148585" title="(x$1: List[Types.this.Symbol])Unit">baseClassesCache</a> = <span title="Null(null)" class="keyword">null</span>
          <a href="#148585" title="(x$1: List[Types.this.Symbol])Unit">baseClassesCache</a> = <a href="#148593" title="(op1: =&gt; List[Types.this.Symbol])(op2: Types.this.Type =&gt; List[Types.this.Symbol])List[Types.this.Symbol]">memo</a><span class="delimiter">(</span><a href="#451655" title="=&gt; List[Types.this.Symbol]">computeBaseClasses</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="#451713" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#451712" title="Types.this.Type">_</a>.<a href="#105526" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#148585" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">throw</span> <a href="#313958" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#67669" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="java.lang.String(&quot;illegal cyclic reference involving &quot;)" class="string">&quot;illegal cyclic reference involving &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
      <a href="#148585" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a>
    <span class="delimiter">}</span>

    <span class="comment">/** The slightly less idiomatic use of Options is due to 
     *  performance considerations. A version using for comprehensions
     *  might be too slow (this is deemed a hotspot of the type checker).
     *  
     *  See with Martin before changing this method.
     */</span>
    <span class="keyword">def</span> <a title="[A](op1: =&gt; A)(op2: Types.this.Type =&gt; A)A" id="148593">memo</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="148595">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="451632">op1</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; A" id="451633">op2</a>: Type =&gt; A<span class="delimiter">)</span>: <a href="#148595" title="A">A</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="()A" id="451722">updateCache</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#148595" title="A">A</a> = <span class="delimiter">{</span>
        <a href="#67385" title="(k: List[Types.this.Type], v: scala.ref.WeakReference[Types.this.Type])Unit">intersectionWitness</a><span class="delimiter">(</span><a href="#105463" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> = <span title="(value: Types.this.CompoundType)scala.ref.WeakReference[Types.this.CompoundType]" class="keyword">new</span> <span title="scala.ref.WeakReference[Types.this.CompoundType]">WeakReference</span><span class="delimiter">(</span><a href="#67426" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#451632" title="=&gt; A">op1</a>
      <span class="delimiter">}</span>
      
      <a href="#67385" title="=&gt; scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]">intersectionWitness</a> <span title="(k: List[Types.this.Type])Option[scala.ref.WeakReference[Types.this.Type]]">get</span> <a href="#105463" title="=&gt; List[Types.this.Type]">parents</a> <span title="A" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="A">Some</span><span class="delimiter">(</span><a title="scala.ref.WeakReference[Types.this.Type]" id="451757">ref</a><span class="delimiter">)</span> =&gt;
          <a href="#451757" title="scala.ref.WeakReference[Types.this.Type]">ref</a>.<span title="=&gt; Option[Types.this.Type]">get</span> <span title="A" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="A">Some</span><span class="delimiter">(</span><a title="Types.this.Type" id="451759">w</a><span class="delimiter">)</span> =&gt; <span title="A" class="keyword">if</span> <span class="delimiter">(</span><a href="#451759" title="Types.this.Type">w</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#67426" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span> <a href="#451632" title="=&gt; A">op1</a> <span class="keyword">else</span> <a href="#451633" title="(v1: Types.this.Type)A">op2</a><span class="delimiter">(</span><a href="#451759" title="Types.this.Type">w</a><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="A">None</span> =&gt; <a href="#451722" title="()A">updateCache</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="keyword">case</span> <span title="A">None</span> =&gt; <a href="#451722" title="()A">updateCache</a><span class="delimiter">(</span><span class="delimiter">)</span> 
      <span class="delimiter">}</span>
     
    <span class="delimiter">}</span>
 
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="148596">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="451761">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="451763">index</a> = <a href="#105527" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#451761" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#451763" title="Int">index</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="BaseTypeSeqs.scala.html#197572" title="(i: Int)Types.this.Type">baseTypeSeq</a><span class="delimiter">(</span><a href="#451763" title="Int">index</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#450913" title="object Types.this.NoType">NoType</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148597">narrow</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107600" title="=&gt; Types.this.Type">thisType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148598">isNotNull</a>: <span title="Boolean">Boolean</span> = <a href="#105463" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#451780" title="Types.this.Type">_</a>.<a href="#105448" title="=&gt; Boolean">isNotNull</a><span class="delimiter">)</span>
    
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148599">isStructuralRefinement</a>: <span title="Boolean">Boolean</span> =
      <a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107489" title="=&gt; Boolean">isAnonOrRefinementClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <span class="delimiter">(</span><a href="#105487" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113097" title="=&gt; List[Types.this.Symbol]">toList</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="451792">entry</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#451792" title="Types.this.Symbol">entry</a>.<a href="Symbols.scala.html#107475" title="=&gt; Boolean">isConstructor</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#451792" title="Types.this.Symbol">entry</a>.<a href="Symbols.scala.html#107632" title="=&gt; List[Types.this.Symbol]">allOverriddenSymbols</a>.<span title="=&gt; Boolean">isEmpty</span> <span class="delimiter">}</span><span class="delimiter">)</span>

    <span class="comment">// override def isNullable: Boolean =</span>
    <span class="comment">// parents forall (p =&gt; p.isNullable &amp;&amp; !p.typeSymbol.isAbstractType);</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148600">safeToString</a>: <span title="String">String</span> =
      <a href="#105463" title="=&gt; List[Types.this.Type]">parents</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot; with &quot;)" class="string">&quot; with &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)java.lang.String">+</span>
      <span class="delimiter">(</span><span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">||</span> <a href="#105463" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#105487" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113061" title="=&gt; Types.this.ScopeEntry">elems</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#105487" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113104" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="java.lang.String(&quot;{&quot;)" class="string">&quot;{&quot;</span>, <span title="java.lang.String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="java.lang.String(&quot;}&quot;)" class="string">&quot;}&quot;</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class representing intersection types with refinements of the form
   *    `&lt;parents_0&gt; with ... with &lt;parents_n&gt; { decls }'
   *  Cannot be created directly;
   *  one should always use `refinedType' for creation.
   */</span>
  case <span class="keyword">class</span> <a title="class RefinedType extends Types.this.CompoundType with ScalaObject with Product with Serializable" id="148576">RefinedType</a><a href="#148576" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Type]" id="236369">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>,
                         <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Scope" id="236370">decls</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67426" title="Types.this.CompoundType">CompoundType</a> <span class="delimiter">{</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148608">isHigherKinded</a> = <span class="delimiter">(</span>
      <a href="#236369" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
      <span class="delimiter">(</span><a href="#236369" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#451818" title="Types.this.Type">_</a>.<a href="#105445" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a>    <span class="comment">// @MO to AM: please check this class!</span>
    <span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148609">typeParams</a> = 
      <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#148608" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#236369" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#105477" title="=&gt; List[Types.this.Symbol]">typeParams</a>
      <span class="keyword">else</span> <a href="#148576" title="Types.this.RefinedType" class="keyword">super</a>.<a href="#105477" title="=&gt; List[Types.this.Symbol]">typeParams</a>

    <span class="comment">//@M may result in an invalid type (references to higher-order args become dangling )</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148610">typeConstructor</a> = 
      <a href="#67482" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#148576" title="Types.this.RefinedType" class="keyword">this</a>, <a href="#236369" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#451842" title="Types.this.Type">_</a>.<a href="#105466" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>, <a href="#236370" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span>
    
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148611">dummyArgs</a> = <a href="#148609" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#451892" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107577" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>

    <span class="comment">/* MO to AM: This is probably not correct
     * If they are several higher-kinded parents with different bounds we need
     * to take the intersection of their bounds
     */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148612">normalize</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#148608" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#67492" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span>
          <a href="#148609" title="=&gt; List[Types.this.Symbol]">typeParams</a>,
          <a href="#148575" title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span>
            <a href="#236369" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#451953" title="Types.this.Type" class="delimiter">{</a>
              <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="451954">pre</a>, <a title="Types.this.Symbol" id="451955">sym</a>, <a href="#451957" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#133525" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#451954" title="Types.this.Type">pre</a>, <a href="#451955" title="Types.this.Symbol">sym</a>, <a href="#148611" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>
              <span class="keyword">case</span> <a title="Types.this.Type" id="451971">p</a> =&gt; <a href="#451971" title="Types.this.Type">p</a>
            <span class="delimiter">}</span>,
            <a href="#236370" title="=&gt; Types.this.Scope">decls</a>,
            <a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#148576" title="Types.this.RefinedType" class="keyword">super</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a>
    <span class="delimiter">}</span>

    <span class="comment">/** A refined type P1 with ... with Pn { decls } is volatile if
     *  one of the parent types Pi is an abstract type, and
     *  either i &gt; 1, or decls or a following parent Pj, j &gt; 1, contributes
     *  an abstract member.
     *  A type contributes an abstract member if it has an abstract member which
     *  is also a member of the whole refined type. A scope `decls' contributes
     *  an abstract member if it has an abstract definition which is also
     *  a member of the whole type.
     */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148613">isVolatile</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(m: Types.this.Symbol)Boolean" id="452003">isVisible</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="452005">m</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = 
        <a href="#148576" title="RefinedType.this.type" class="keyword">this</a>.<a href="#105496" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#452005" title="Types.this.Symbol">m</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107591" title="=&gt; List[Types.this.Symbol]">alternatives</a> <span title="(elem: Any)Boolean">contains</span> <a href="#452005" title="Types.this.Symbol">m</a>
      <span class="keyword">def</span> <a title="(p: Types.this.Type)Boolean" id="452004">contributesAbstractMembers</a><span class="delimiter">(</span><a title="Types.this.Type" id="452006">p</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = 
        <a href="#452006" title="Types.this.Type">p</a>.<a href="#105494" title="=&gt; List[Types.this.Symbol]">deferredMembers</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <a href="#452003" title="(m: Types.this.Symbol)Boolean">isVisible</a>

      <span class="delimiter">(</span><span class="delimiter">(</span><a href="#236369" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#452022" title="Types.this.Type">_</a>.<a href="#105447" title="=&gt; Boolean">isVolatile</a><span class="delimiter">)</span><span class="delimiter">)</span> 
       <span title="(x: Boolean)Boolean">||</span>
       <span class="delimiter">(</span><a href="#236369" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">dropWhile</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span> <a href="#452027" title="Types.this.Type">_</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isAbstractType</span><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
         <span class="keyword">case</span> <a title="Boolean" id="452028">ps</a> @ <span class="delimiter">(</span>_ :: <a title="List[Types.this.Type]" id="452033">ps1</a><span class="delimiter">)</span> =&gt; 
           <span class="delimiter">(</span><a href="#452028" title="collection.immutable.::[Types.this.Type]">ps</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#236369" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
           <span class="delimiter">(</span><a href="#452033" title="List[Types.this.Type]">ps1</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <a href="#452004" title="(p: Types.this.Type)Boolean">contributesAbstractMembers</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
           <span class="delimiter">(</span><a href="#236370" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113099" title="=&gt; Iterator[Types.this.Symbol]">iterator</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="452047">m</a> =&gt; <a href="#452047" title="Types.this.Symbol">m</a>.<span title="=&gt; Boolean">isDeferred</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#452003" title="(m: Types.this.Symbol)Boolean">isVisible</a><span class="delimiter">(</span><a href="#452047" title="Types.this.Symbol">m</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
         <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
           <span title="Boolean(false)" class="keyword">false</span>
       <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148614">kind</a> = <span title="java.lang.String(&quot;RefinedType&quot;)" class="string">&quot;RefinedType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class RefinedType0 extends Types.this.RefinedType with ScalaObject" id="67430">RefinedType0</a><a href="#67430" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Type]" id="452095">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="452096">decls</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="452097">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#148576" title="Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#452095" title="List[Types.this.Type]">parents</a>, <a href="#452096" title="Types.this.Scope">decls</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="452090">typeSymbol</a> = <a href="#452097" title="Types.this.Symbol">clazz</a>
  <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object Types.this.RefinedType" id="67428">RefinedType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24037" title="Types.this.RefinedTypeExtractor">RefinedTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType" id="148575">apply</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="236354">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="236355">decls</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="236356">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#148576" title="Types.this.RefinedType">RefinedType</a> =
      <span title="Types.this.RefinedType0" class="keyword">new</span> <a href="#67430" title="Types.this.RefinedType0">RefinedType0</a><span class="delimiter">(</span><a href="#236354" title="List[Types.this.Type]">parents</a>, <a href="#236355" title="Types.this.Scope">decls</a>, <a href="#236356" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class representing a class info
   */</span>
  case <span class="keyword">class</span> <a title="class ClassInfoType extends Types.this.CompoundType with ScalaObject with Product with Serializable" id="148665">ClassInfoType</a><a href="#148665" title="ScalaObject" class="delimiter">(</a>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Type]" id="399181">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>,
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Scope" id="399182">decls</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a>,
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Symbol" id="399183">typeSymbol</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67426" title="Types.this.CompoundType">CompoundType</a> 
  <span class="delimiter">{</span>
    
    <span class="comment">/** refs indices */</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(0)" id="148676">NonExpansive</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(1)" id="148678">Expansive</a> = <span title="Int(1)" class="int">1</span>

    <span class="comment">/** initialization states */</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(0)" id="148680">UnInitialized</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(1)" id="148682">Initializing</a> = <span title="Int(1)" class="int">1</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(2)" id="148684">Initialized</a> = <span title="Int(2)" class="int">2</span>

    <span class="keyword">private</span> <span class="keyword">type</span> <a title="Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]" id="148686">RefMap</a> = <span title="Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">Map</span><span class="delimiter">[</span>Symbol, immutable.Set<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span>

    <span class="comment">/** All type parameters reachable from given type parameter
     *  by a path which contains at least one expansive reference.
     *  @See Kennedy, Pierce: On Decidability of Nominal Subtyping with Variance
     */</span>
    <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Set[Types.this.Symbol]" id="148687">expansiveRefs</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="452108">tparam</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#148692" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)">UnInitialized</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#148698" title="()Unit">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#148692" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(2)">Initialized</span><span class="delimiter">)</span> <a href="#148699" title="()Boolean">propagate</a><a href="#452117" title="()Unit" class="delimiter">(</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#148694" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#452108" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/* The rest of this class is auxiliary code for `expansiveRefs'
     */</span>

    <span class="comment">/** The type parameters which are referenced type parameters of this class.
     *  Two entries: refs(0): Non-expansive references
     *               refs(1): Expansive references
     */</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Array[ClassInfoType.this.RefMap]" id="148689">refs</a>: <span title="Array[ClassInfoType.this.RefMap]">Array</span><span class="delimiter">[</span>RefMap<span class="delimiter">]</span> = _

    <span class="comment">/** The initialization state of the class: UnInialized --&gt; Initializing --&gt; Initialized
     */</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="148692">state</a> = <span title="Int(0)">UnInitialized</span>

    <span class="comment">/** Get references for given type parameter
     *  @param  which in {NonExpansive, Expansive}
     *  @param  from  The type parameter from which references originate.
     */</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]" id="148694">getRefs</a><span class="delimiter">(</span><a title="Int" id="452124">which</a>: <span title="Int">Int</span>, <a title="Types.this.Symbol" id="452125">from</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Set[Types.this.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#148689" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#452124" title="Int">which</a><span class="delimiter">)</span> <span title="(key: Types.this.Symbol)Option[scala.collection.immutable.Set[Types.this.Symbol]]">get</span> <a href="#452125" title="Types.this.Symbol">from</a> <span title="Set[Types.this.Symbol]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="scala.collection.immutable.Set[Types.this.Symbol]">Some</span><span class="delimiter">(</span><a title="scala.collection.immutable.Set[Types.this.Symbol]" id="452140">set</a><span class="delimiter">)</span> =&gt; <a href="#452140" title="scala.collection.immutable.Set[Types.this.Symbol]">set</a>
      <span class="keyword">case</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="452141">none</a> =&gt; <span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]">Set</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Augment existing refs map with reference &lt;pre&gt;from -&gt; to&lt;/pre&gt; 
     *  @param  which &lt;- {NonExpansive, Expansive}
     */</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit" id="148695">addRef</a><span class="delimiter">(</span><a title="Int" id="452145">which</a>: <span title="Int">Int</span>, <a title="Types.this.Symbol" id="452146">from</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="452147">to</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#148689" title="(i: Int, x: ClassInfoType.this.RefMap)Unit">refs</a><span class="delimiter">(</span><a href="#452145" title="Int">which</a><span class="delimiter">)</span> = <a href="#148689" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#452145" title="Int">which</a><span class="delimiter">)</span> <span title="(kv: (Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol]))scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">+</span> <span class="delimiter">(</span><a href="#452146" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">from</a> <span title="(y: scala.collection.immutable.Set[Types.this.Symbol])(Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])">-&gt;</span> <span class="delimiter">(</span><a href="#148694" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><a href="#452145" title="Int">which</a>, <a href="#452146" title="Types.this.Symbol">from</a><span class="delimiter">)</span> <span title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">+</span> <a href="#452147" title="Types.this.Symbol">to</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Augment existing refs map with references &lt;pre&gt;from -&gt; sym&lt;/pre&gt;, for
     *  all elements &lt;pre&gt;sym&lt;/pre&gt; of set `to'.
     *  @param  which &lt;- {NonExpansive, Expansive}
     */</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit" id="148696">addRefs</a><span class="delimiter">(</span><a title="Int" id="452255">which</a>: <span title="Int">Int</span>, <a title="Types.this.Symbol" id="452256">from</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Set[Types.this.Symbol]" id="452257">to</a>: <span title="Set[Types.this.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#148689" title="(i: Int, x: ClassInfoType.this.RefMap)Unit">refs</a><span class="delimiter">(</span><a href="#452255" title="Int">which</a><span class="delimiter">)</span> = <a href="#148689" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#452255" title="Int">which</a><span class="delimiter">)</span> <span title="(kv: (Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol]))scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">+</span> <span class="delimiter">(</span><a href="#452256" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">from</a> <span title="(y: scala.collection.immutable.Set[Types.this.Symbol])(Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])">-&gt;</span> <span class="delimiter">(</span><a href="#148694" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><a href="#452255" title="Int">which</a>, <a href="#452256" title="Types.this.Symbol">from</a><span class="delimiter">)</span> <span title="(elems: scala.collection.GenTraversableOnce[Types.this.Symbol])scala.collection.immutable.Set[Types.this.Symbol]">++</span> <a href="#452257" title="Set[Types.this.Symbol]">to</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** The ClassInfoType which belongs to the class containing given type parameter 
     */</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Types.this.ClassInfoType" id="148697">classInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="452394">tparam</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#148665" title="Types.this.ClassInfoType">ClassInfoType</a> = 
      <a href="#452394" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105468" title="=&gt; Types.this.Type">resultType</a> <span title="Types.this.ClassInfoType" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="Types.this.ClassInfoType" id="452399">ci</a>: <a href="#148665" title="Types.this.ClassInfoType">ClassInfoType</a> =&gt; <a href="#452399" title="Types.this.ClassInfoType">ci</a>
        <span class="keyword">case</span> <span title="Types.this.ClassInfoType">_</span> =&gt; <a href="#148697" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><a href="Definitions.scala.html#106220" title="=&gt; Types.this.Symbol">ObjectClass</a><span class="delimiter">)</span> <span class="comment">// something's wrong; fall back to safe value</span>
                                         <span class="comment">// (this can happen only for erroneous programs).</span>
      <span class="delimiter">}</span>

    <span class="comment">/** Compute initial (one-step) references and set state to `Initializing'.
     */</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="()Unit" id="148698">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#148689" title="(x$1: Array[ClassInfoType.this.RefMap])Unit">refs</a> = <span title="(xs: ClassInfoType.this.RefMap*)(implicit evidence$2: scala.reflect.ClassManifest[ClassInfoType.this.RefMap])Array[ClassInfoType.this.RefMap]">Array</span><a href="#24037" title="(clazz: java.lang.Class[_], arg1: scala.reflect.OptManifest[_], args: scala.reflect.OptManifest[_]*)scala.reflect.ClassManifest[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" class="delimiter">(</a><span title="(elems: (Types.this.Symbol, Nothing)*)scala.collection.immutable.Map[Types.this.Symbol,Nothing]">Map</span><span class="delimiter">(</span><span class="delimiter">)</span>, <span title="(elems: (Types.this.Symbol, Nothing)*)scala.collection.immutable.Map[Types.this.Symbol,Nothing]">Map</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="452494">tparam</a> &lt;- <a href="#399183" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107579" title="(f: Types.this.Symbol =&gt; Unit)Unit">typeParams</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.TypeMap" id="452495">enterRefs</a> = <a href="#452496" title="Types.this.TypeMap" class="keyword">new</a> <a href="#67514" title="anonymous class $anon extends Types.this.TypeMap" id="452496">TypeMap</a> <span class="delimiter">{</span>
          <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="452498">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="452499">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
            <a href="#452499" title="Types.this.Type">tp</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="452502">sym</a>, <a title="List[Types.this.Type]" id="452503">args</a><span class="delimiter">)</span> =&gt;
                <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="452599">tparam1</a>, <a title="Types.this.Type" id="452600">arg</a><span class="delimiter">)</span> &lt;- <a href="#452502" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105477" title="=&gt; List[Types.this.Symbol]">typeParams</a> <a href="#452570" title="(f: (Types.this.Symbol, Types.this.Type) =&gt; Unit)Unit">zip</a> <a href="#452503" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
                  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#452600" title="Types.this.Type">arg</a> <a href="#105513" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#452494" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#148695" title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit">addRef</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#452494" title="Types.this.Symbol">tparam</a>, <a href="#452599" title="Types.this.Symbol">tparam1</a><span class="delimiter">)</span>
                    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#452600" title="Types.this.Type">arg</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#452494" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span> <a href="#148695" title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit">addRef</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#452494" title="Types.this.Symbol">tparam</a>, <a href="#452599" title="Types.this.Symbol">tparam1</a><span class="delimiter">)</span>
                  <span class="delimiter">}</span>
              <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
            <span class="delimiter">}</span>
            <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#452499" title="Types.this.Type">tp</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="452643">p</a> &lt;- <a href="#399181" title="(f: Types.this.Type =&gt; Types.this.Type)Unit">parents</a><span class="delimiter">)</span> <a href="#452495" title="(v1: Types.this.Type)Types.this.Type">enterRefs</a><span class="delimiter">(</span><a href="#452643" title="Types.this.Type">p</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#148692" title="(x$1: Int)Unit">state</a> = <span title="Int(1)">Initializing</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Propagate to form transitive closure.
     *  Set state to Initialized if no change resulted from propagation.
     *  @return   true iff there as a change in last iteration
     */</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="()Boolean" id="148699">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#148692" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)">UnInitialized</span><span class="delimiter">)</span> <a href="#148698" title="()Unit">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="comment">//Console.println(&quot;Propagate &quot;+symbol+&quot;, initial expansive = &quot;+refs(Expansive)+&quot;, nonexpansive = &quot;+refs(NonExpansive))//DEBUG</span>
      <span class="keyword">val</span> <a title="Array[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" id="452647">lastRefs</a> = <span title="(xs: ClassInfoType.this.RefMap*)(implicit evidence$2: scala.reflect.ClassManifest[ClassInfoType.this.RefMap])Array[ClassInfoType.this.RefMap]">Array</span><a href="#24037" title="(clazz: java.lang.Class[_], arg1: scala.reflect.OptManifest[_], args: scala.reflect.OptManifest[_]*)scala.reflect.ClassManifest[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" class="delimiter">(</a><a href="#148689" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>, <a href="#148689" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#148692" title="(x$1: Int)Unit">state</a> = <span title="Int(2)">Initialized</span>
      <span class="keyword">var</span> <a title="Boolean" id="452648">change</a> = <span title="Boolean(false)" class="keyword">false</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="452743">from</a>, <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="452744">targets</a><span class="delimiter">)</span> &lt;- <a href="#148689" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span><span class="delimiter">)</span>.<a href="#452725" title="(f: (Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol]) =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="452761">target</a> &lt;- <a href="#452744" title="(f: Types.this.Symbol =&gt; Unit)Unit">targets</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">var</span> <a title="Types.this.ClassInfoType" id="452762">thatInfo</a> = <a href="#148697" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><a href="#452761" title="Types.this.Symbol">target</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#452762" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#148692" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(2)">Initialized</span><span class="delimiter">)</span> 
            <a href="#452648" title="Boolean">change</a> = <a href="#452648" title="Boolean">change</a> <span title="(x: Boolean)Boolean">|</span> <a href="#452762" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#148699" title="()Boolean">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#148696" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#452743" title="Types.this.Symbol">from</a>, <a href="#452762" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#148694" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#452761" title="Types.this.Symbol">target</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#148696" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#452743" title="Types.this.Symbol">from</a>, <a href="#452762" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#148694" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#452761" title="Types.this.Symbol">target</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="452790">from</a>, <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="452791">targets</a><span class="delimiter">)</span> &lt;- <a href="#148689" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span><span class="delimiter">)</span>.<a href="#452772" title="(f: (Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol]) =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="452808">target</a> &lt;- <a href="#452791" title="(f: Types.this.Symbol =&gt; Unit)Unit">targets</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">var</span> <a title="Types.this.ClassInfoType" id="452809">thatInfo</a> = <a href="#148697" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><a href="#452808" title="Types.this.Symbol">target</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#452809" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#148692" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(2)">Initialized</span><span class="delimiter">)</span> 
            <a href="#452648" title="Boolean">change</a> = <a href="#452648" title="Boolean">change</a> <span title="(x: Boolean)Boolean">|</span> <a href="#452809" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#148699" title="()Boolean">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#148696" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#452790" title="Types.this.Symbol">from</a>, <a href="#452809" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#148694" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#452808" title="Types.this.Symbol">target</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <a href="#452648" title="Boolean">change</a> = <a href="#452648" title="Boolean">change</a> <span title="(x: Boolean)Boolean">||</span> <a href="#148689" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#452647" title="(i: Int)scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">lastRefs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#148689" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#452647" title="(i: Int)scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">lastRefs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#452648" title="Boolean">change</a><span class="delimiter">)</span> <a href="#148692" title="(x$1: Int)Unit">state</a> = <span title="Int(1)">Initializing</span>
      <span class="comment">//else Console.println(&quot;Propagate &quot;+symbol+&quot;, final expansive = &quot;+refs(Expansive)+&quot;, nonexpansive = &quot;+refs(NonExpansive))//DEBUG</span>
      <a href="#452648" title="Boolean">change</a>
    <span class="delimiter">}</span>

    <span class="comment">// override def isNullable: Boolean =</span>
    <span class="comment">// symbol == AnyClass ||</span>
    <span class="comment">// symbol != NothingClass &amp;&amp; (symbol isSubClass ObjectClass) &amp;&amp; !(symbol isSubClass NonNullClass);</span>

    <span class="comment">// override def isNonNull: Boolean = symbol == NonNullClass || super.isNonNull;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148700">kind</a> = <span title="java.lang.String(&quot;ClassInfoType&quot;)" class="string">&quot;ClassInfoType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.ClassInfoType" id="67432">ClassInfoType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24037" title="Types.this.ClassInfoTypeExtractor">ClassInfoTypeExtractor</a>

  <span class="keyword">class</span> <a title="class PackageClassInfoType extends Types.this.ClassInfoType with ScalaObject" id="67434">PackageClassInfoType</a><a href="#67434" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Scope" id="440729">decls</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="440730">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="#148665" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">(</span>List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#440729" title="Types.this.Scope">decls</a>, <a href="#440730" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>

  <span class="comment">/** A class representing a constant type.
   *
   *  @param value ...
   */</span>
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a title="class ConstantType extends Types.this.SingletonType with ScalaObject with Product with Serializable" id="148422">ConstantType</a><a href="#148422" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Constant" id="148430">value</a>: <span title="Types.this.Constant">Constant</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67398" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148415">underlying</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#148430" title="=&gt; Types.this.Constant">value</a>.<span title="=&gt; Types.this.Type">tpe</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#148415" title="=&gt; Types.this.Type">underlying</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#106718" title="=&gt; Types.this.Symbol">UnitClass</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148416">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148417">isNotNull</a> = <a href="#148430" title="=&gt; Types.this.Constant">value</a>.<span title="=&gt; Any">value</span> <span title="(x$1: Any)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148418">deconst</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#148415" title="=&gt; Types.this.Type">underlying</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148419">safeToString</a>: <span title="String">String</span> =
      <a href="#148415" title="=&gt; Types.this.Type">underlying</a>.<span title="()String">toString</span> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#148430" title="=&gt; Types.this.Constant">value</a>.<span title="=&gt; String">escapedStringValue</span> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
    <span class="comment">// override def isNullable: Boolean = value.value eq null</span>
    <span class="comment">// override def isNonNull: Boolean = value.value ne null</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148420">kind</a> = <span title="java.lang.String(&quot;ConstantType&quot;)" class="string">&quot;ConstantType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueConstantType extends Types.this.ConstantType with Types.this.UniqueType with ScalaObject" id="67438">UniqueConstantType</a><a href="#67438" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Constant" id="452919">value</a>: <span title="Types.this.Constant">Constant</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#148422" title="Types.this.ConstantType">ConstantType</a><span class="delimiter">(</span><a href="#452919" title="Types.this.Constant">value</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#67393" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span>
    <span class="comment">/** Save the type of 'value'. For Java enums, it depends on finding the linked class,
     *  which might not be found after 'flatten'. */</span>
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.Type" id="452915">_tpe</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#452919" title="Types.this.Constant">value</a>.<span title="=&gt; Types.this.Type">tpe</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="452916">underlying</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#452914" title="=&gt; Types.this.Type">_tpe</a>
  <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object Types.this.ConstantType" id="67436">ConstantType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24037" title="Types.this.ConstantTypeExtractor">ConstantTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(value: Types.this.Constant)Types.this.ConstantType" id="148410">apply</a><span class="delimiter">(</span><a title="Types.this.Constant" id="151984">value</a>: <span title="Types.this.Constant">Constant</span><span class="delimiter">)</span>: <a href="#148422" title="Types.this.ConstantType">ConstantType</a> = <span class="delimiter">{</span>
      <a href="#67506" title="(tp: Types.this.UniqueConstantType)Types.this.UniqueConstantType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueConstantType" class="keyword">new</span> <a href="#67438" title="Types.this.UniqueConstantType">UniqueConstantType</a><span class="delimiter">(</span><a href="#151984" title="Types.this.Constant">value</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.ConstantType" class="delimiter">[</span><a href="#148422" title="Types.this.ConstantType">ConstantType</a><span class="delimiter">]</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="67440">volatileRecursions</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.Symbol]" id="67442">pendingVolatiles</a> = <span title="()scala.collection.mutable.HashSet[Types.this.Symbol]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Types.this.Symbol]">HashSet</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

  <span class="comment">/** A class for named types of the form
   *  `&lt;prefix&gt;.&lt;sym.name&gt;[args]'
   *  Cannot be created directly; one should always use `typeRef'
   *  for creation. (@M: Otherwise hashing breaks)
   *
   * @M: a higher-kinded type is represented as a TypeRef with sym.info.typeParams.nonEmpty, but args.isEmpty
   *  @param pre  ...
   *  @param sym  ...
   *  @param args ...
   */</span>
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a title="class TypeRef extends Types.this.Type with ScalaObject with Product with Serializable" id="133603">TypeRef</a><a href="#133603" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="133631">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="133632">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="133633">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67392" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
<span class="comment">//    assert(!sym.isAbstractType || pre.isStable || pre.isError)</span>
<span class="comment">//    assert(!pre.isInstanceOf[ClassInfoType], this)</span>
<span class="comment">//    assert(!(sym hasFlag (PARAM | EXISTENTIAL)) || pre == NoPrefix, this)</span>
<span class="comment">//    assert(args.isEmpty || !sym.info.typeParams.isEmpty, this)</span>
<span class="comment">//    assert(args.isEmpty || ((sym ne AnyClass) &amp;&amp; (sym ne NothingClass))</span>

    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[Types.this.Type]" id="133537">parentsCache</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="133540">parentsPeriod</a> = <span title="Int(0)">NoPeriod</span>
    
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.BaseTypeSeq" id="133543">baseTypeSeqCache</a>: <a href="BaseTypeSeqs.scala.html#67704" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="133546">baseTypeSeqPeriod</a> = <span title="Int(0)">NoPeriod</span>

    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="133549">symInfoCache</a>: <a href="#67392" title="Types.this.Type">Type</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="133552">memberInfoCache</a>: <a href="#67392" title="Types.this.Type">Type</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="133555">thisInfoCache</a>: <a href="#67392" title="Types.this.Type">Type</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="133558">relativeInfoCache</a>: <a href="#67392" title="Types.this.Type">Type</a> = _

    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="133561">normalized</a>: <a href="#67392" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
    

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133563">isStable</a>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="#133632" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a> <span title="(x: Boolean)Boolean">||</span>
      <a href="#133632" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106344" title="=&gt; Types.this.Symbol">SingletonClass</a> <span title="(x: Boolean)Boolean">||</span>
      <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#133593" title="=&gt; Types.this.Type">normalize</a>.<a href="#105446" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">||</span>
      <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAbstractType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#133576" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#107589" title="(that: Types.this.Symbol)Boolean">isSubClass</a> <a href="Definitions.scala.html#106344" title="=&gt; Types.this.Symbol">SingletonClass</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133564">isVolatile</a>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#133593" title="=&gt; Types.this.Type">normalize</a>.<a href="#105447" title="=&gt; Boolean">isVolatile</a> <span title="(x: Boolean)Boolean">||</span>
      <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAbstractType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
        <span class="comment">// need to be careful not to fall into an infinite recursion here</span>
        <span class="comment">// because volatile checking is done before all cycles are detected.</span>
        <span class="comment">// the case to avoid is an abstract type directly or</span>
        <span class="comment">// indirectly upper-bounded by itself. See #2918</span>
        <span class="keyword">try</span> <span class="delimiter">{</span>
          <a href="#67440" title="(x$1: Int)Unit">volatileRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67440" title="=&gt; Int">volatileRecursions</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(50)">LogVolatileThreshold</span><span class="delimiter">)</span>
            <a href="#133576" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a>.<a href="#105447" title="=&gt; Boolean">isVolatile</a>
          <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67442" title="(elem: Types.this.Symbol)Boolean">pendingVolatiles</a><span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span title="Boolean(true)" class="keyword">true</span> <span class="comment">// we can return true here, because a cycle will be detected</span>
                 <span class="comment">// here afterwards and an error will result anyway.</span>
          <span class="keyword">else</span> 
            <span class="keyword">try</span> <span class="delimiter">{</span>
              <a href="#67442" title="=&gt; scala.collection.mutable.HashSet[Types.this.Symbol]">pendingVolatiles</a> <span title="(elem: Types.this.Symbol)Types.this.pendingVolatiles.type">+=</span> <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>
              <a href="#133576" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a>.<a href="#105447" title="=&gt; Boolean">isVolatile</a>
            <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
              <a href="#67442" title="=&gt; scala.collection.mutable.HashSet[Types.this.Symbol]">pendingVolatiles</a> <span title="(elem: Types.this.Symbol)Types.this.pendingVolatiles.type">-=</span> <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
          <a href="#67440" title="(x$1: Int)Unit">volatileRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="133566">isTrivial</a>: <span title="Boolean">Boolean</span> =
      <span title="=&gt; Boolean">!</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isTypeParameter</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#133631" title="=&gt; Types.this.Type">pre</a>.<a href="#105444" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#133633" title="=&gt; List[Types.this.Type]">args</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#453009" title="Types.this.Type">_</a>.<a href="#105444" title="=&gt; Boolean">isTrivial</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133567">isNotNull</a> = 
      <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isModuleClass</span> <span title="(x: Boolean)Boolean">||</span> <a href="#133632" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="Definitions.scala.html#106661" title="(sym: Types.this.Symbol)Boolean">isValueClass</a><span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#133603" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105448" title="=&gt; Boolean">isNotNull</a>

    <span class="comment">// @M: propagate actual type params (args) to `tp', by replacing formal type parameters with actual ones</span>
    <span class="comment">// if tp is higher kinded, the &quot;actual&quot; type arguments are types that simply reference the corresponding type parameters  (unbound type variables) </span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="133568">transform</a><span class="delimiter">(</span><a title="Types.this.Type" id="453020">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="453022">res</a> = <a href="#453020" title="Types.this.Type">tp</a>.<a href="#105500" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#133631" title="=&gt; Types.this.Type">pre</a>, <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#133633" title="=&gt; List[Types.this.Type]">args</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#453030" title="Types.this.Type">_</a>.<a href="#105485" title="=&gt; Boolean">isError</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#67526" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>, <a href="#133633" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="comment">/*#2266/2305*/</span><span class="delimiter">)</span> <a href="#453022" title="Types.this.Type">res</a>
      <span class="keyword">else</span> <a href="#453022" title="Types.this.Type">res</a>.<a href="#105480" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#133582" title="=&gt; List[Types.this.Type]">typeArgsOrDummies</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">//@M! use appliedType on the polytype that represents the bounds (or if aliastype, the rhs)</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="133569">transformInfo</a><span class="delimiter">(</span><a title="Types.this.Type" id="453091">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#67489" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#453091" title="Types.this.Type">tp</a>.<a href="#105500" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#133631" title="=&gt; Types.this.Type">pre</a>, <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>, <a href="#133582" title="=&gt; List[Types.this.Type]">typeArgsOrDummies</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133570">thisInfo</a>: <a href="#67392" title="Types.this.Type">Type</a> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <a href="#133593" title="=&gt; Types.this.Type">normalize</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107462" title="=&gt; Boolean">isNonClassType</a><span class="delimiter">)</span> <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="453095">symInfo</a> = <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133555" title="=&gt; Types.this.Type">thisInfoCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#453095" title="Types.this.Type">symInfo</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#133549" title="=&gt; Types.this.Type">symInfoCache</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#133549" title="(x$1: Types.this.Type)Unit">symInfoCache</a> = <a href="#453095" title="Types.this.Type">symInfo</a>
          <a href="#133555" title="(x$1: Types.this.Type)Unit">thisInfoCache</a> = <a href="#133569" title="(tp: Types.this.Type)Types.this.Type">transformInfo</a><span class="delimiter">(</span><a href="#453095" title="Types.this.Type">symInfo</a><span class="delimiter">)</span>            
        <span class="delimiter">}</span>
        <a href="#133555" title="=&gt; Types.this.Type">thisInfoCache</a>
      <span class="delimiter">}</span>
    
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133571">relativeInfo</a>: <a href="#67392" title="Types.this.Type">Type</a> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107462" title="=&gt; Boolean">isNonClassType</a><span class="delimiter">)</span> <a href="#133631" title="=&gt; Types.this.Type">pre</a>.<a href="#105501" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="453103">memberInfo</a> = <a href="#133631" title="=&gt; Types.this.Type">pre</a>.<a href="#105501" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133558" title="=&gt; Types.this.Type">relativeInfoCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#453103" title="Types.this.Type">memberInfo</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#133552" title="=&gt; Types.this.Type">memberInfoCache</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#133552" title="(x$1: Types.this.Type)Unit">memberInfoCache</a> = <a href="#453103" title="Types.this.Type">memberInfo</a>
          <a href="#133558" title="(x$1: Types.this.Type)Unit">relativeInfoCache</a> = <a href="#133569" title="(tp: Types.this.Type)Types.this.Type">transformInfo</a><span class="delimiter">(</span><a href="#453103" title="Types.this.Type">memberInfo</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#133558" title="=&gt; Types.this.Type">relativeInfoCache</a>
      <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="133572">typeSymbol</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <a href="#133593" title="=&gt; Types.this.Type">normalize</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span class="keyword">else</span> <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="133573">termSymbol</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <a href="#133593" title="=&gt; Types.this.Type">normalize</a>.<a href="#105453" title="=&gt; Types.this.Symbol">termSymbol</a> <span class="keyword">else</span> <a href="#133603" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105453" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="133574">typeSymbolDirect</a> = <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="133575">termSymbolDirect</a> = <a href="#133603" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105453" title="=&gt; Types.this.Symbol">termSymbol</a>

<span class="comment">/* @MAT
whenever you see `tp.typeSymbol.isXXXX' and then act on tp based on that predicate, you're on thin ice, 
as `typeSymbol' (and `prefix') automatically normalize, but the other inspectors don't. 
In other words, even if `tp.normalize.sym.isXXX' is true, `tp.sym.isXXX' may be false (if sym were a public method to access the non-normalized typeSymbol)...

In retrospect, I think `tp.typeSymbol.isXXX' or (worse) `tp.typeSymbol==XXX' should be replaced by `val tp = tp0.asXXX'.  
A type's typeSymbol should never be inspected directly.
*/</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="133576">bounds</a>: <a href="#148517" title="Types.this.TypeBounds">TypeBounds</a> =
      <span title="Types.this.TypeBounds" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAbstractType</span><span class="delimiter">)</span> <a href="#133570" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a> <span class="comment">// transform(thisInfo.bounds).asInstanceOf[TypeBounds] // ??? seems to be doing asSeenFrom twice</span>
      <span class="keyword">else</span> <a href="#133603" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="133577">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span> 
      <span class="keyword">val</span> <a title="Int" id="453120">period</a> = <a href="#133540" title="=&gt; Int">parentsPeriod</a> 
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#453120" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#64812" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span> 
        <a href="#133540" title="(x$1: Int)Unit">parentsPeriod</a> = <a href="SymbolTable.scala.html#64812" title="=&gt; Types.this.Period">currentPeriod</a> 
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64822" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#453120" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> 
          <a href="#133537" title="(x$1: List[Types.this.Type])Unit">parentsCache</a> = <a href="#133570" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#105463" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#133568" title="(tp: Types.this.Type)Types.this.Type">transform</a> 
        <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133537" title="=&gt; List[Types.this.Type]">parentsCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// seems this can happen if things are currupted enough, see #2641 </span>
          <a href="#133537" title="(x$1: List[Types.this.Type])Unit">parentsCache</a> = <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span> 
        <span class="delimiter">}</span> 
      <span class="delimiter">}</span> 
      <a href="#133537" title="=&gt; List[Types.this.Type]">parentsCache</a> 
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133578">typeOfThis</a> = <a href="#133568" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107599" title="=&gt; Types.this.Type">typeOfThis</a><span class="delimiter">)</span>

<span class="comment">/*
    override def narrow =
      if (sym.isModuleClass) transform(sym.thisType) 
      else if (sym.isAliasType) normalize.narrow      
      else super.narrow
*/</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133579">narrow</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isModuleClass</span><span class="delimiter">)</span> <a href="#67479" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#133631" title="=&gt; Types.this.Type">pre</a>, <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Types.this.Symbol">sourceModule</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <a href="#133593" title="=&gt; Types.this.Type">normalize</a>.<a href="#105461" title="=&gt; Types.this.Type">narrow</a>      
      <span class="keyword">else</span> <a href="#133603" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105461" title="=&gt; Types.this.Type">narrow</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133580">prefix</a>: <a href="#67392" title="Types.this.Type">Type</a> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <a href="#133593" title="=&gt; Types.this.Type">normalize</a>.<a href="#105464" title="=&gt; Types.this.Type">prefix</a>
      <span class="keyword">else</span> <a href="#133631" title="=&gt; Types.this.Type">pre</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="133581">typeArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#133633" title="=&gt; List[Types.this.Type]">args</a>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="133582">typeArgsOrDummies</a> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#133587" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#133633" title="=&gt; List[Types.this.Type]">args</a> <span class="keyword">else</span> <a href="#133584" title="=&gt; List[Types.this.Type]">dummyArgs</a>
    <span class="comment">// def hasFishyArgs = args == dummyArgs</span>

    <span class="comment">// @MAT was typeSymbol.unsafeTypeParams, but typeSymbol normalizes now</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="133583">typeParamsDirect</a> =
      <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#106171" title="=&gt; Boolean">isDefinitionsInitialized</a><span class="delimiter">)</span> <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>
      <span class="keyword">else</span> <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107578" title="=&gt; List[Types.this.Symbol]">unsafeTypeParams</a>

    <span class="comment">// placeholders derived from type params</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="133584">dummyArgs</a> = <span class="delimiter">{</span>
      <span class="comment">// @PP to @AM: this appears to me a place where</span>
      <span class="comment">// higher-order tparams are going off the beam.</span>
      <span class="comment">// if (sym.isAbstractType) { something goes wrong }</span>

      <span class="comment">//@M must be .typeConstructor</span>
      <a href="#133583" title="=&gt; List[Types.this.Symbol]">typeParamsDirect</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#453063" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107577" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// (!result.isEmpty) IFF isHigherKinded</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="133585">typeParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#133587" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#133583" title="=&gt; List[Types.this.Symbol]">typeParamsDirect</a> <span class="keyword">else</span> List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">// note: does not go through typeRef. There's no need to because</span>
    <span class="comment">// neither `pre` nor `sym` changes.  And there's a performance</span>
    <span class="comment">// advantage to call TypeRef directly.</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133586">typeConstructor</a> = <a href="#133525" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#133631" title="=&gt; Types.this.Type">pre</a>, <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span> 

    <span class="comment">// A reference (in a Scala program) to a type that has type</span>
    <span class="comment">// parameters, but where the reference does not include type</span>
    <span class="comment">// arguments. Note that it doesn't matter whether the symbol refers</span>
    <span class="comment">// to a java or scala symbol, it does matter whether it occurs in</span>
    <span class="comment">// java or scala code. TypeRefs w/o type params that occur in java</span>
    <span class="comment">// signatures/code are considered raw types, and are represented as</span>
    <span class="comment">// existential types.</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133587">isHigherKinded</a> = <a href="#133633" title="=&gt; List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#133583" title="=&gt; List[Types.this.Symbol]">typeParamsDirect</a>.<span title="=&gt; Boolean">nonEmpty</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="133588">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="453207">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="453208">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133587" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="453210">substTps</a> = <a href="#453207" title="List[Types.this.Symbol]">formals</a>.<span title="(that: scala.collection.GenSeq[Types.this.Symbol])List[Types.this.Symbol]">intersect</span><span class="delimiter">(</span><a href="#133585" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span>
        
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#453210" title="List[Types.this.Symbol]">substTps</a>, <a href="#133585" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#67484" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#133603" title="Types.this.TypeRef" class="keyword">this</a>, <a href="#133631" title="=&gt; Types.this.Type">pre</a>, <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>, <a href="#453208" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#453207" title="List[Types.this.Symbol]">formals</a>, <a href="#453208" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// partial application (needed in infer when bunching type arguments from classes and methods together)</span>
          <a href="#67484" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#133603" title="Types.this.TypeRef" class="keyword">this</a>, <a href="#133631" title="=&gt; Types.this.Type">pre</a>, <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>, <a href="#133584" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>.<a href="#105504" title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#453207" title="List[Types.this.Symbol]">formals</a>, <a href="#453208" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#450846" title="object Types.this.ErrorType">ErrorType</a>
      <span class="delimiter">}</span>
      <span class="keyword">else</span>
        <a href="#133603" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105480" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#453207" title="List[Types.this.Symbol]">formals</a>, <a href="#453208" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>


    <span class="comment">/** @pre: sym.info.typeParams.length == typeArgs.length */</span>
    @inline <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133589">betaReduce</a>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="comment">// isHKSubType0 introduces synthetic type params so that</span>
      <span class="comment">// betaReduce can first apply sym.info to typeArgs before calling</span>
      <span class="comment">// asSeenFrom.  asSeenFrom then skips synthetic type params, which</span>
      <span class="comment">// are used to reduce HO subtyping to first-order subtyping, but</span>
      <span class="comment">// which can't be instantiated from the given prefix and class.</span>
      <a href="#133568" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105468" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
      <span class="comment">//</span>
      <span class="comment">// this crashes pos/depmet_implicit_tpbetareduce.scala</span>
      <span class="comment">// appliedType(sym.info, typeArgs).asSeenFrom(pre, sym.owner)</span>
    <span class="delimiter">}</span>

    <span class="comment">// @M: initialize (by sym.info call) needed (see test/files/pos/ticket0137.scala)</span>
    @inline <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133590">etaExpand</a>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="453235">tpars</a> = <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105477" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span class="comment">// must go through sym.info for typeParams to initialise symbol</span>
      <a href="#67491" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFunAnon</a><span class="delimiter">(</span><a href="#453235" title="List[Types.this.Symbol]">tpars</a>, <a href="#67484" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#133603" title="Types.this.TypeRef" class="keyword">this</a>, <a href="#133631" title="=&gt; Types.this.Type">pre</a>, <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>, <a href="#453235" title="List[Types.this.Symbol]">tpars</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#453255" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107563" title="=&gt; Types.this.Type">tpeHK</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// todo: also beta-reduce?</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133591">dealias</a>: <a href="#67392" title="Types.this.Type">Type</a> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105477" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#133633" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#133589" title="=&gt; Types.this.Type">betaReduce</a>.<a href="#105484" title="=&gt; Types.this.Type">dealias</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#133603" title="Types.this.TypeRef" class="keyword">this</a>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133592">normalize0</a>: <a href="#67392" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133631" title="=&gt; Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450864" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span> <a href="#450864" title="object Types.this.WildcardType">WildcardType</a> <span class="comment">// arises when argument-dependent types are approximated (see def depoly in implicits)</span>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133587" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#133590" title="=&gt; Types.this.Type">etaExpand</a>   <span class="comment">// eta-expand, subtyping relies on eta-expansion of higher-kinded types</span>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105477" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#133633" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
                               <a href="#133589" title="=&gt; Types.this.Type">betaReduce</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a> <span class="comment">// beta-reduce, but don't do partial application -- cycles have been checked in typeRef</span>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isRefinementClass</span><span class="delimiter">)</span> 
                               <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a> <span class="comment">// I think this is okay, but see #1241 (r12414), #2208, and typedTypeConstructor in Typers</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span title="Types.this.Type" class="keyword">if</span><span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <a href="#450846" title="object Types.this.ErrorType">ErrorType</a> <span class="comment">//println(&quot;!!error: &quot;+(pre, sym, sym.info, sym.info.typeParams, args))</span>
        <span class="keyword">else</span> <a href="#133603" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a>
      <span class="delimiter">}</span>

   <span class="comment">// TODO: test case that is compiled  in a specific order and in different runs</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133593">normalize</a>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#133592" title="=&gt; Types.this.Type">normalize0</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133561" title="=&gt; Types.this.Type">normalized</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
          <a href="#133561" title="(x$1: Types.this.Type)Unit">normalized</a> = <a href="#133592" title="=&gt; Types.this.Type">normalize0</a>
        
        <a href="#133561" title="=&gt; Types.this.Type">normalized</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="133594">decls</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a> = <span class="delimiter">{</span>
      <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="453299">sym1</a>, _<span class="delimiter">)</span> =&gt;
          <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#453299" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>, <a href="#133603" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span> <span class="comment">// @MAT was != typeSymbol</span>
        <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
      <span class="delimiter">}</span>
      <a href="#133570" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#105487" title="=&gt; Types.this.Scope">decls</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="133595">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="453306">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#453306" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <a href="#133603" title="Types.this.TypeRef" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isClass</span><span class="delimiter">)</span> <a href="#133568" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105499" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#453306" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> 
        <span class="keyword">try</span> <span class="delimiter">{</span> 
          <a href="#67590" title="(x$1: Int)Unit">basetypeRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67590" title="=&gt; Int">basetypeRecursions</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(50)">LogPendingBaseTypesThreshold</span><span class="delimiter">)</span>
            <a href="#133571" title="=&gt; Types.this.Type">relativeInfo</a>.<a href="#105499" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#453306" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67592" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <span title="(elem: Types.this.Type)Boolean">contains</span> <a href="#133603" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#453306" title="Types.this.Symbol">clazz</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span> <a href="#453306" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#450913" title="object Types.this.NoType">NoType</a>
          <span class="keyword">else</span>
            <span class="keyword">try</span> <span class="delimiter">{</span>
              <a href="#67592" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <span title="(elem: Types.this.Type)Types.this.pendingBaseTypes.type">+=</span> <a href="#133603" title="Types.this.TypeRef" class="keyword">this</a>
              <a href="#133571" title="=&gt; Types.this.Type">relativeInfo</a>.<a href="#105499" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#453306" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
            <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
              <a href="#67592" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <span title="(elem: Types.this.Type)Types.this.pendingBaseTypes.type">-=</span> <a href="#133603" title="Types.this.TypeRef" class="keyword">this</a>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
          <a href="#67590" title="(x$1: Int)Unit">basetypeRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
        <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="133596">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#67704" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="453350">period</a> = <a href="#133546" title="=&gt; Int">baseTypeSeqPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#453350" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#64812" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#133546" title="(x$1: Int)Unit">baseTypeSeqPeriod</a> = <a href="SymbolTable.scala.html#64812" title="=&gt; Types.this.Period">currentPeriod</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64822" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#453350" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="../util/Statistics.scala.html#67162" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67197" title="=&gt; scala.tools.nsc.util.Statistics.Counter">typerefBaseTypeSeqCount</a><span class="delimiter">)</span>
          <a href="#133543" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="BaseTypeSeqs.scala.html#67705" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a>
          <a href="#133543" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> =
            <span title="Types.this.BaseTypeSeq" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAbstractType</span><span class="delimiter">)</span> <a href="#133568" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#133576" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>.<a href="#105524" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#197577" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">prepend</a> <a href="#133603" title="Types.this.TypeRef" class="keyword">this</a>
            <span class="keyword">else</span> <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105524" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#197579" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">map</a> <a href="#133568" title="(tp: Types.this.Type)Types.this.Type">transform</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133543" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="BaseTypeSeqs.scala.html#67705" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">throw</span> <a href="#313958" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#67669" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="java.lang.String(&quot;illegal cyclic inheritance involving &quot;)" class="string">&quot;illegal cyclic inheritance involving &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#133632" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <a href="#133543" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="133597">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#133596" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#197582" title="=&gt; Int">maxDepth</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="133598">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#133570" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#105526" title="=&gt; List[Types.this.Symbol]">baseClasses</a>

    <span class="comment">// override def isNullable: Boolean = sym.info.isNullable</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="133599">safeToString</a>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#133603" title="Types.this.TypeRef" class="keyword">this</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Nothing">TypeRef</span><span class="delimiter">(</span>_, <a href="Definitions.scala.html#106352" title="=&gt; Types.this.Symbol">RepeatedParamClass</a>, <a title="Types.this.Type" id="453382">arg</a> :: _<span class="delimiter">)</span> =&gt; <span title="Nothing" class="keyword">return</span> <a href="#453382" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">arg</a> <span title="(other: String)java.lang.String">+</span> <span title="java.lang.String(&quot;*&quot;)" class="string">&quot;*&quot;</span>
          <span class="keyword">case</span> <span title="Nothing">TypeRef</span><span class="delimiter">(</span>_, <a href="Definitions.scala.html#106365" title="=&gt; Types.this.Symbol">ByNameParamClass</a>, <a title="Types.this.Type" id="453389">arg</a> :: _<span class="delimiter">)</span>   =&gt; <span title="Nothing" class="keyword">return</span> <span title="java.lang.String(&quot;=&gt; &quot;)" class="string">&quot;=&gt; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#453389" title="Types.this.Type">arg</a>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#106493" title="(tp: Types.this.Type)Boolean">isFunctionType</a><span class="delimiter">(</span><a href="#133603" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="List[Types.this.Type]" id="453391">targs</a> = <a href="#133593" title="=&gt; Types.this.Type">normalize</a>.<a href="#105467" title="=&gt; List[Types.this.Type]">typeArgs</a>
              <span class="comment">// Aesthetics: printing Function1 as T =&gt; R rather than (T) =&gt; R</span>
              <span class="keyword">val</span> <a title="java.lang.String" id="453392">paramlist</a> = <a href="#453391" title="List[Types.this.Type]">targs</a>.<span title="=&gt; List[Types.this.Type]">init</span> <span title="java.lang.String" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="java.lang.String(&quot;()&quot;)">Nil</span>      =&gt; <span title="java.lang.String(&quot;()&quot;)" class="string">&quot;()&quot;</span>
                <span class="keyword">case</span> <a title="java.lang.String" id="453397">x</a> :: <span title="object Nil">Nil</span> =&gt; <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#453397" title="Types.this.Type">x</a>
                <span class="keyword">case</span> <a title="String" id="453398">xs</a>       =&gt; <a href="#453398" title="List[Types.this.Type]">xs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="java.lang.String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
              <span class="delimiter">}</span>
              <span title="Nothing" class="keyword">return</span> <a href="#453392" title="java.lang.String">paramlist</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; =&gt; &quot;)" class="string">&quot; =&gt; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#453391" title="List[Types.this.Type]">targs</a>.<span title="=&gt; Types.this.Type">last</span>
            <span class="delimiter">}</span>
            <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#106475" title="(tp: Types.this.Type)Boolean">isTupleTypeOrSubtype</a><span class="delimiter">(</span><a href="#133603" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> 
              <span title="Nothing" class="keyword">return</span> <a href="#133593" title="=&gt; Types.this.Type">normalize</a>.<a href="#105467" title="=&gt; List[Types.this.Type]">typeArgs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="java.lang.String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#67586" title="(xs: List[_], len: Int)Boolean">hasLength</a><span class="delimiter">(</span><a href="#133593" title="=&gt; Types.this.Type">normalize</a>.<a href="#105467" title="=&gt; List[Types.this.Type]">typeArgs</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="java.lang.String(&quot;,)&quot;)" class="string">&quot;,)&quot;</span> <span class="keyword">else</span> <span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
            <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#105465" title="=&gt; List[Types.this.Type]">prefixChain</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#453425" title="Types.this.Type">_</a>.<a href="#105453" title="=&gt; Types.this.Symbol">termSymbol</a>.<span title="=&gt; Boolean">isSynthetic</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="453426">normed</a> = <a href="#133593" title="=&gt; Types.this.Type">normalize</a>;
              <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#453426" title="Types.this.Type">normed</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#133603" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#453426" title="Types.this.Type">normed</a>.<span title="()String">toString</span>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="String" id="453373">monopart</a> = 
        <span title="String" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
            <span class="delimiter">(</span><a href="#67685" title="=&gt; scala.collection.immutable.Set[java.lang.String]">shorthands</a> <span title="(elem: java.lang.String)Boolean">contains</span> <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; String">fullName</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107544" title="=&gt; List[Types.this.Symbol]">ownerChain</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#453442" title="Types.this.Symbol">_</a>.<span title="=&gt; Boolean">isClass</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// ensure that symbol is not a local copy with a name coincidence </span>
          <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#96604" title="()String">toString</a>
        <span class="keyword">else</span> 
          <a href="#133631" title="=&gt; Types.this.Type">pre</a>.<a href="#105533" title="=&gt; java.lang.String">prefixString</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107655" title="=&gt; java.lang.String">nameString</a>
      
      <span class="keyword">var</span> <a title="java.lang.String" id="453374">str</a> = <a href="#453373" title="String">monopart</a> <span title="(x$1: Any)java.lang.String">+</span> <span class="delimiter">(</span><span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#133633" title="=&gt; List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="#133633" title="=&gt; List[Types.this.Type]">args</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="java.lang.String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="java.lang.String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span><span class="delimiter">)</span>
        <a href="#105531" title="=&gt; java.lang.String">packagePrefix</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="#453374" title="java.lang.String">str</a>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isModuleClass</span><span class="delimiter">)</span>
        <a href="#105530" title="=&gt; java.lang.String">objectPrefix</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="#453374" title="java.lang.String">str</a>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107487" title="=&gt; Boolean">isAnonymousClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107538" title="=&gt; Boolean">isInitialized</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
        <a href="#133570" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#105463" title="=&gt; List[Types.this.Type]">parents</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot; with &quot;)" class="string">&quot; with &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)java.lang.String">+</span> <span class="delimiter">{</span>
          <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107534" title="=&gt; Boolean">isStructuralRefinement</a><span class="delimiter">)</span>
            <span class="delimiter">(</span><span class="delimiter">(</span><a href="#133594" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113097" title="=&gt; List[Types.this.Symbol]">toList</a> <span title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">filter</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="453458">entry</a> =&gt;
              <span title="=&gt; Boolean">!</span><a href="#453458" title="Types.this.Symbol">entry</a>.<a href="Symbols.scala.html#107475" title="=&gt; Boolean">isConstructor</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#453458" title="Types.this.Symbol">entry</a>.<a href="Symbols.scala.html#107632" title="=&gt; List[Types.this.Symbol]">allOverriddenSymbols</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#453458" title="Types.this.Symbol">entry</a>.<span title="=&gt; Boolean">isPrivate</span>
            <span class="delimiter">}</span><span class="delimiter">)</span> <span title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],String,List[String]])List[String]">map</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="453479">entry</a> =&gt; <a href="#453479" title="Types.this.Symbol">entry</a>.<a href="Symbols.scala.html#107667" title="=&gt; String">defString</a> <span class="delimiter">}</span><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;{&quot;)" class="string">&quot;{&quot;</span>, <span title="java.lang.String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="java.lang.String(&quot;}&quot;)" class="string">&quot;}&quot;</span><span class="delimiter">)</span> 
          <span class="keyword">else</span>
            <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
        <span class="delimiter">}</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isRefinementClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107538" title="=&gt; Boolean">isInitialized</a><span class="delimiter">)</span>
        <a href="#133570" title="=&gt; Types.this.Type">thisInfo</a>.<span title="()String">toString</span>
      <span class="keyword">else</span> <a href="#453374" title="java.lang.String">str</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="133600">prefixString</a> = <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <span class="delimiter">(</span>
      <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> 
        <a href="#133603" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105533" title="=&gt; java.lang.String">prefixString</a>
      <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107500" title="=&gt; Boolean">printWithoutPrefix</a><span class="delimiter">)</span> 
        <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span><span class="delimiter">)</span> 
        <a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; String">fullName</span> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#133563" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="StdNames.scala.html#67724" title="object Types.this.nme">nme</a>.<a href="NameManglers.scala.html#115751" title="(name: Types.this.Name)Boolean">isSingletonName</a><span class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="StdNames.scala.html#67724" title="object Types.this.nme">nme</a>.<a href="NameManglers.scala.html#115763" title="(name: Types.this.Name)Types.this.TypeName">dropSingletonName</a><span title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd" class="delimiter">(</span><a href="#133632" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span> <span title="(other: String)java.lang.String">+</span> <span title="java.lang.String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      <span class="keyword">else</span> 
        <a href="#133603" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105533" title="=&gt; java.lang.String">prefixString</a>
    <span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="133601">kind</a> = <span title="java.lang.String(&quot;TypeRef&quot;)" class="string">&quot;TypeRef&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueTypeRef extends Types.this.TypeRef with Types.this.UniqueType with ScalaObject" id="67447">UniqueTypeRef</a><a href="#67447" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="453565">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="453566">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="453567">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#133603" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">(</span><a href="#453565" title="Types.this.Type">pre</a>, <a href="#453566" title="Types.this.Symbol">sym</a>, <a href="#453567" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#67393" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object Types.this.TypeRef" id="67445">TypeRef</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24037" title="Types.this.TypeRefExtractor">TypeRefExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="133525">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="236546">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="236547">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="236548">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#67506" title="(tp: Types.this.UniqueTypeRef)Types.this.UniqueTypeRef">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueTypeRef" class="keyword">new</span> <a href="#67447" title="Types.this.UniqueTypeRef">UniqueTypeRef</a><span class="delimiter">(</span><a href="#236546" title="Types.this.Type">pre</a>, <a href="#236547" title="Types.this.Symbol">sym</a>, <a href="#236548" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class representing a method type with parameters.
   *  Note that a parameterless method is represented by a NullaryMethodType:
   *
   *    def m(): Int        MethodType(Nil, Int)
   *    def m: Int          NullaryMethodType(Int)
   */</span>
  case <span class="keyword">class</span> <a title="class MethodType extends Types.this.Type with ScalaObject with Product with Serializable" id="148762">MethodType</a><a href="#148762" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="151895">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
                        <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="151896">resultType</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67392" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148770">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#148771" title="=&gt; Boolean">isTrivial0</a>
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="148772">isTrivial0</a> =
      <a href="#151896" title="=&gt; Types.this.Type">resultType</a>.<a href="#105444" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#151895" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span><span class="delimiter">{</span><a title="Types.this.Symbol" id="453586">p</a> =&gt; <a href="#453586" title="Types.this.Symbol">p</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>.<a href="#105444" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>  <span class="delimiter">(</span>
        <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36819" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">YdepMethTpes</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#151895" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#453596" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>.<a href="#105513" title="(sym: Types.this.Symbol)Boolean">contains</a><span class="delimiter">(</span><a href="#453586" title="Types.this.Symbol">p</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#151896" title="=&gt; Types.this.Type">resultType</a>.<a href="#105513" title="(sym: Types.this.Symbol)Boolean">contains</a><span class="delimiter">(</span><a href="#453586" title="Types.this.Symbol">p</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="=&gt; Boolean" id="148773">isImplicit</a> = <a href="#151895" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#151895" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Types.this.Symbol">head</span>.<span title="=&gt; Boolean">isImplicit</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="148774">isJava</a> = <span title="Boolean(false)" class="keyword">false</span> <span class="comment">// can we do something like for implicits? I.e. do Java methods without parameters need to be recognized?</span>

    <span class="comment">//assert(paramTypes forall (pt =&gt; !pt.typeSymbol.isImplClass))//DEBUG</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148775">paramSectionCount</a>: <span title="Int">Int</span> = <a href="#151896" title="=&gt; Types.this.Type">resultType</a>.<a href="#105473" title="=&gt; Int">paramSectionCount</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="148776">paramss</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#151895" title="=&gt; List[Types.this.Symbol]">params</a> <a href="#453614" title="(x: List[Types.this.Symbol])List[List[Types.this.Symbol]]">::</a> <a href="#151896" title="=&gt; Types.this.Type">resultType</a>.<a href="#105474" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>
    
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148777">paramTypes</a> = <a href="#151895" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#412334" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="148778">boundSyms</a> = immutable.<span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#151895" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(that: scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">++</span> <a href="#151896" title="=&gt; Types.this.Type">resultType</a>.<a href="#105478" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>: _*<span class="delimiter">)</span>
    
    <span class="comment">// AM to TR: #dropNonContraintAnnotations</span>
    <span class="comment">// this is needed for plugins to work correctly, only TypeConstraint annotations are supposed to be carried over</span>
    <span class="comment">// TODO: this should probably be handled in a more structured way in adapt -- remove this map in resultType and watch the continuations tests fail</span>
    <span class="keyword">object</span> <a title="object MethodType.this.dropNonContraintAnnotations" id="148779">dropNonContraintAnnotations</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="262045">dropNonConstraintAnnotations</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">def</span> <a title="(x: Types.this.Type)Types.this.Type" id="262047">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="262048">x</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#262048" title="Types.this.Type">x</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(actuals: List[Types.this.Type])Types.this.Type" id="148781">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="262035">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#148770" title="=&gt; Boolean">isTrivial</a><span class="delimiter">)</span> <a href="#262047" title="(x: Types.this.Type)Types.this.Type">dropNonContraintAnnotations</a><span class="delimiter">(</span><a href="#151896" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#262035" title="List[Types.this.Type]">actuals</a>, <a href="#151895" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.InstantiateDependentMap" id="262110">idm</a> = <span title="Types.this.InstantiateDependentMap" class="keyword">new</span> <a href="#67543" title="Types.this.InstantiateDependentMap">InstantiateDependentMap</a><span class="delimiter">(</span><a href="#151895" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#262035" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="262111">res</a> = <a href="#262123" title="(tp: Types.this.Type)Types.this.Type">idm</a><span class="delimiter">(</span><a href="#151896" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
          <span class="comment">// println(&quot;resultTypeDep &quot;+(params, actuals, resultType, idm.existentialsNeeded, &quot;\n= &quot;+ res))</span>
          <a href="#67493" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#262110" title="Types.this.InstantiateDependentMap">idm</a>.<a href="#262124" title="=&gt; List[Types.this.Symbol]">existentialsNeeded</a>, <a href="#262111" title="Types.this.Type">res</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="comment">// Thread.dumpStack()</span>
          <span class="comment">// println(&quot;resultType &quot;+(params, actuals, resultType))</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#151896" title="=&gt; Types.this.Type">resultType</a>
          <span class="keyword">else</span> <a href="#67493" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#151895" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#151896" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

    <span class="comment">// implicit args can only be depended on in result type: TODO this may be generalised so that the only constraint is dependencies are acyclic</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.MethodType" id="148782">approximate</a>: <a href="#148762" title="Types.this.MethodType">MethodType</a> = <a href="#148762" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#151895" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#105470" title="=&gt; Types.this.Type">resultApprox</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148783">finalResultType</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#151896" title="=&gt; Types.this.Type">resultType</a>.<a href="#105472" title="=&gt; Types.this.Type">finalResultType</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148784">safeToString</a> = <a href="TypeDebugging.scala.html#67947" title="(tp: Types.this.Type)String">paramString</a><span class="delimiter">(</span><a href="#148762" title="Types.this.MethodType" class="keyword">this</a><span class="delimiter">)</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#151896" title="=&gt; Types.this.Type">resultType</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="148785">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="453702">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="453705">vparams</a> = <a href="Symbols.scala.html#67344" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#151895" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#453702" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#67486" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#148762" title="Types.this.MethodType" class="keyword">this</a>, <a href="#453705" title="List[Types.this.Symbol]">vparams</a>, <a href="#151896" title="=&gt; Types.this.Type">resultType</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#151895" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#453705" title="List[Types.this.Symbol]">vparams</a><span class="delimiter">)</span>.<a href="#105528" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#453702" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="148786">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="453768">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#151895" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#453772" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#453768" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#151896" title="=&gt; Types.this.Type">resultType</a>.<a href="#105529" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#453768" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#151896" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#148785" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#453768" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> 
      <span class="keyword">else</span>
        <a href="#148762" title="Types.this.MethodType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148787">kind</a> = <span title="java.lang.String(&quot;MethodType&quot;)" class="string">&quot;MethodType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.MethodType" id="67449">MethodType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24037" title="Types.this.MethodTypeExtractor">MethodTypeExtractor</a>

  <span class="keyword">class</span> <a title="class JavaMethodType extends Types.this.MethodType with ScalaObject" id="67451">JavaMethodType</a><a href="#67451" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="453835">ps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="453836">rt</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#148762" title="Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#453835" title="List[Types.this.Symbol]">ps</a>, <a href="#453836" title="Types.this.Type">rt</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="453831">isJava</a> = <span title="Boolean(true)" class="keyword">true</span>
  <span class="delimiter">}</span>
  
  case <span class="keyword">class</span> <a title="class NullaryMethodType extends Types.this.Type with ScalaObject with Product with Serializable" id="148865">NullaryMethodType</a><a href="#148865" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="423876">resultType</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67392" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="comment">// AM to TR: #dropNonContraintAnnotations</span>
    <span class="comment">// change isTrivial to the commented version and watch continuations-run/t3225.scala fail</span>
    <span class="comment">// isTrivial implies asSeenFrom is bypassed, since it's supposed to be the identity map</span>
    <span class="comment">// it's not really the identity due to dropNonContraintAnnotations</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148870">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span> <span class="comment">//resultType.isTrivial -- `false` to make continuations plugin work (so that asSeenFromMap drops non-constrain annotations even when type doesn't change otherwise)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148871">prefix</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#423876" title="=&gt; Types.this.Type">resultType</a>.<a href="#105464" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148872">narrow</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#423876" title="=&gt; Types.this.Type">resultType</a>.<a href="#105461" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148873">finalResultType</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#423876" title="=&gt; Types.this.Type">resultType</a>.<a href="#105472" title="=&gt; Types.this.Type">finalResultType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148874">termSymbol</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <a href="#423876" title="=&gt; Types.this.Type">resultType</a>.<a href="#105453" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148875">typeSymbol</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <a href="#423876" title="=&gt; Types.this.Type">resultType</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148876">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#423876" title="=&gt; Types.this.Type">resultType</a>.<a href="#105463" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="148877">decls</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a> = <a href="#423876" title="=&gt; Types.this.Type">resultType</a>.<a href="#105487" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="148878">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#67704" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#423876" title="=&gt; Types.this.Type">resultType</a>.<a href="#105524" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148879">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#423876" title="=&gt; Types.this.Type">resultType</a>.<a href="#105525" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148880">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#423876" title="=&gt; Types.this.Type">resultType</a>.<a href="#105526" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="148881">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="453904">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#423876" title="=&gt; Types.this.Type">resultType</a>.<a href="#105499" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#453904" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="148882">boundSyms</a> = <a href="#423876" title="=&gt; Types.this.Type">resultType</a>.<a href="#105478" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148883">isVolatile</a> = <a href="#423876" title="=&gt; Types.this.Type">resultType</a>.<a href="#105447" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148884">safeToString</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;=&gt; &quot;)" class="string">&quot;=&gt; &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#423876" title="=&gt; Types.this.Type">resultType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148885">kind</a> = <span title="java.lang.String(&quot;NullaryMethodType&quot;)" class="string">&quot;NullaryMethodType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.NullaryMethodType" id="67453">NullaryMethodType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24037" title="Types.this.NullaryMethodTypeExtractor">NullaryMethodTypeExtractor</a> 

  <span class="comment">/** A type function or the type of a polymorphic value (and thus of kind *).
   *
   * Before the introduction of NullaryMethodType, a polymorphic nullary method (e.g, def isInstanceOf[T]: Boolean) 
   * used to be typed as PolyType(tps, restpe), and a monomorphic one as PolyType(Nil, restpe)
   * This is now: PolyType(tps, NullaryMethodType(restpe)) and NullaryMethodType(restpe)
   * by symmetry to MethodTypes: PolyType(tps, MethodType(params, restpe)) and MethodType(params, restpe)
   *
   * Thus, a PolyType(tps, TypeRef(...)) unambiguously indicates a type function (which results from eta-expanding a type constructor alias).
   * Similarly, PolyType(tps, ClassInfoType(...)) is a type constructor.
   * 
   * A polytype is of kind * iff its resultType is a (nullary) method type.
   */</span>
  case <span class="keyword">class</span> <a title="class PolyType extends Types.this.Type with ScalaObject with Product with Serializable" id="148921">PolyType</a><a href="#148921" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="300071">typeParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="300072">resultType</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>
       <span class="keyword">extends</span> <a href="#67392" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="comment">//assert(!(typeParams contains NoSymbol), this)</span>
    <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#300071" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="=&gt; Boolean">nonEmpty</span>, <a href="#148921" title="Types.this.PolyType" class="keyword">this</a><span class="delimiter">)</span> <span class="comment">// used to be a marker for nullary method type, illegal now (see @NullaryMethodType)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148929">paramSectionCount</a>: <span title="Int">Int</span> = <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105473" title="=&gt; Int">paramSectionCount</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="148930">paramss</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105474" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148931">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105475" title="=&gt; List[Types.this.Symbol]">params</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148932">paramTypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105476" title="=&gt; List[Types.this.Type]">paramTypes</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148933">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105463" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="148934">decls</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a> = <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105487" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148935">termSymbol</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105453" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148936">typeSymbol</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="148937">boundSyms</a> = immutable.<span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#300071" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(that: scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">++</span> <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105478" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>: _*<span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148938">prefix</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105464" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="148939">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#67704" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105524" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148940">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105525" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148941">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105526" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="148942">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454096">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105499" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#454096" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148943">narrow</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105461" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148944">isVolatile</a> = <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105447" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148945">finalResultType</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105472" title="=&gt; Types.this.Type">finalResultType</a>

    <span class="comment">/** @M: typeDefSig wraps a TypeBounds in a PolyType 
     *  to represent a higher-kinded type parameter
     *  wrap lo&amp;hi in polytypes to bind variables
     */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="148946">bounds</a>: <a href="#148517" title="Types.this.TypeBounds">TypeBounds</a> = 
      <a href="#148501" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#67492" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#300071" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148531" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, 
                 <a href="#67492" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#300071" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148947">isHigherKinded</a> = <span title="=&gt; Boolean">!</span><a href="#300071" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">isEmpty</span>
    
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148948">safeToString</a> = <a href="TypeDebugging.scala.html#67948" title="(tp: Types.this.Type)String">typeParamsString</a><span class="delimiter">(</span><a href="#148921" title="Types.this.PolyType" class="keyword">this</a><span class="delimiter">)</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#300072" title="=&gt; Types.this.Type">resultType</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.PolyType" id="148949">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454144">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="454147">tparams</a> = <a href="Symbols.scala.html#67344" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#300071" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#454144" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#148921" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#454147" title="List[Types.this.Symbol]">tparams</a>, <a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#300071" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#454147" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>.<a href="#105528" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#454144" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="148950">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454190">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#300071" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#454199" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#454190" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#300072" title="=&gt; Types.this.Type">resultType</a>.<a href="#105529" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#454190" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#300072" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#148949" title="(owner: Types.this.Symbol)Types.this.PolyType">cloneInfo</a><span class="delimiter">(</span><a href="#454190" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> 
      <span class="keyword">else</span>
        <a href="#148921" title="Types.this.PolyType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148951">kind</a> = <span title="java.lang.String(&quot;PolyType&quot;)" class="string">&quot;PolyType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.PolyType" id="67456">PolyType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24037" title="Types.this.PolyTypeExtractor">PolyTypeExtractor</a> 

  case <span class="keyword">class</span> <a title="class ExistentialType extends Types.this.Type with Types.this.RewrappingTypeProxy with ScalaObject with Product with Serializable" id="149138">ExistentialType</a><a href="#149138" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="236394">quantified</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, 
                             <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="236395">underlying</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67391" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a>
  <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="149146">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="454256">newtp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#67493" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#454256" title="Types.this.Type">newtp</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="149147">isTrivial</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="149148">isStable</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="149149">bounds</a> = <a href="#148501" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#236395" title="=&gt; Types.this.Type">underlying</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148531" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#236395" title="=&gt; Types.this.Type">underlying</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="149150">parents</a> = <a href="#236395" title="=&gt; Types.this.Type">underlying</a>.<a href="#105463" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="149151">boundSyms</a> = <a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a>.<span title="scala.collection.immutable.Set[Types.this.Symbol]">toSet</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149152">prefix</a> = <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#236395" title="=&gt; Types.this.Type">underlying</a>.<a href="#105464" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="149153">typeArgs</a> = <a href="#236395" title="=&gt; Types.this.Type">underlying</a>.<a href="#105467" title="=&gt; List[Types.this.Type]">typeArgs</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="149154">params</a> = <a href="#236395" title="=&gt; Types.this.Type">underlying</a>.<a href="#105475" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Symbol)List[Types.this.Symbol]">mapConserve</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="454388">param</a> =&gt;
      <span class="keyword">val</span> <a title="Types.this.Type" id="454389">tpe1</a> = <a href="#149146" title="(newtp: Types.this.Type)Types.this.Type">rewrap</a><span class="delimiter">(</span><a href="#454388" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#454389" title="Types.this.Type">tpe1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#454388" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span> <a href="#454388" title="Types.this.Symbol">param</a> <span class="keyword">else</span> <a href="#454388" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#107594" title="=&gt; Types.this.Symbol">cloneSymbol</a>.<a href="Symbols.scala.html#107566" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a><span class="delimiter">(</span><a href="#454389" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="149155">paramTypes</a> = <a href="#236395" title="=&gt; Types.this.Type">underlying</a>.<a href="#105476" title="=&gt; List[Types.this.Type]">paramTypes</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="149156">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="454447">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="454448">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
<span class="comment">//      maybeRewrap(underlying.instantiateTypeParams(formals, actuals))</span>

      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="454451">quantified1</a> = <span title="Types.this.SubstTypeMap" class="keyword">new</span> <a href="#67535" title="Types.this.SubstTypeMap">SubstTypeMap</a><span class="delimiter">(</span><a href="#454447" title="List[Types.this.Symbol]">formals</a>, <a href="#454448" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span> <a href="#133461" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a> <a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="454452">underlying1</a> = <a href="#236395" title="=&gt; Types.this.Type">underlying</a>.<a href="#105480" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#454447" title="List[Types.this.Symbol]">formals</a>, <a href="#454448" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#454451" title="List[Types.this.Symbol]">quantified1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#454452" title="Types.this.Type">underlying1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#236395" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#149138" title="Types.this.ExistentialType" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#67493" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#454451" title="List[Types.this.Symbol]">quantified1</a>, <a href="#454452" title="Types.this.Type">underlying1</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#454451" title="List[Types.this.Symbol]">quantified1</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="149157">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454462">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#236395" title="=&gt; Types.this.Type">underlying</a>.<a href="#105499" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#454462" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="149158">baseTypeSeq</a> = <a href="#236395" title="=&gt; Types.this.Type">underlying</a>.<a href="#105524" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#197579" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">map</a> <a href="#149018" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="149159">isHigherKinded</a> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="149160">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454473">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="454474">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Types.this.Symbol" id="454479">mkSkolem</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454481">tparam</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.TypeSkolem" id="454482">skolem</a> = <span title="Types.this.TypeSkolem" class="keyword">new</span> <a href="Symbols.scala.html#67336" title="Types.this.TypeSkolem">TypeSkolem</a><span class="delimiter">(</span>
          <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#454473" title="Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#454481" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a> <span class="keyword">else</span> <a href="#454473" title="Types.this.Symbol">owner</a>,
          <a href="#454481" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107404" title="=&gt; Types.this.Position">pos</a>, <a href="#454481" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#96599" title="=&gt; Types.this.TypeName">toTypeName</a>, <a href="#454474" title="AnyRef">origin</a><span class="delimiter">)</span>
        <a href="#454482" title="Types.this.TypeSkolem">skolem</a>.<a href="Symbols.scala.html#107566" title="(info: Types.this.Type)skolem.type">setInfo</a><span class="delimiter">(</span><a href="#454481" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105528" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#454482" title="Types.this.TypeSkolem">skolem</a><span class="delimiter">)</span><span class="delimiter">)</span>
              .<a href="Symbols.scala.html#107553" title="(mask: Long)skolem.type">setFlag</a><span class="delimiter">(</span><a href="#454481" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107551" title="=&gt; Long">flags</a> <span title="(x: Long)Long">|</span> <span title="Long(34359738368L)">EXISTENTIAL</span><span class="delimiter">)</span>
              .<a href="Symbols.scala.html#107554" title="(mask: Long)skolem.type">resetFlag</a><span class="delimiter">(</span><span title="Long(8192L)">PARAM</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="454480">skolems</a> = <a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <a href="#454479" title="(tparam: Types.this.Symbol)Types.this.Symbol">mkSkolem</a>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="454559">skolem</a> &lt;- <a href="#454480" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)Unit">skolems</a><span class="delimiter">)</span> 
        <a href="#454559" title="Types.this.Symbol">skolem</a> <a href="Symbols.scala.html#107566" title="(info: Types.this.Type)skolem.type">setInfo</a> <a href="#454559" title="Types.this.Symbol">skolem</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#454480" title="List[Types.this.Symbol]">skolems</a><span class="delimiter">)</span>
      <a href="#236395" title="=&gt; Types.this.Type">underlying</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#454480" title="List[Types.this.Symbol]">skolems</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(available: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]" id="149161">wildcardArgsString</a><span class="delimiter">(</span><a title="Set[Types.this.Symbol]" id="454565">available</a>: <span title="Set[Types.this.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="454566">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[String]">List</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="#454566" title="List[Types.this.Type]">args</a> <span title="List[String]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="List[String]">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="454572">sym</a>, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="454573">args1</a> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#454565" title="Set[Types.this.Symbol]">available</a> <span title="(elem: Types.this.Symbol)Boolean">contains</span> <a href="#454572" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> =&gt;
        <span class="delimiter">(</span><span title="java.lang.String(&quot;_&quot;)" class="string">&quot;_&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#454572" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107661" title="(tp: Types.this.Type)String">infoString</a><span class="delimiter">(</span><a href="#454572" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#454576" title="(x: String)List[String]">::</a> <a href="#149161" title="(available: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]">wildcardArgsString</a><span class="delimiter">(</span><a href="#454565" title="Set[Types.this.Symbol]">available</a> <span title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">-</span> <a href="#454572" title="Types.this.Symbol">sym</a>, <a href="#454573" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="List[String]" id="454595">arg</a> :: <a title="List[Types.this.Type]" id="454596">args1</a> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#454595" title="Types.this.Type">arg</a> <a href="#105513" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#454603" title="Types.this.Symbol">_</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <a href="#454595" title="Types.this.Type">arg</a>.<span title="()String">toString</span> <a href="#454604" title="(x: String)List[String]">::</a> <a href="#149161" title="(available: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]">wildcardArgsString</a><span class="delimiter">(</span><a href="#454565" title="Set[Types.this.Symbol]">available</a>, <a href="#454596" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span> 
      <span class="keyword">case</span> <span title="List[Nothing]">_</span> =&gt;
        List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="149162">safeToString</a>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#454620" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107669" title="=&gt; Boolean">isSingletonExistential</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span>
        <span class="comment">// try to represent with wildcards first</span>
        <a href="#236395" title="=&gt; Types.this.Type">underlying</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="454624">pre</a>, <a title="Types.this.Symbol" id="454625">sym</a>, <a title="List[Types.this.Type]" id="454626">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#454626" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">nonEmpty</span> =&gt;
            <span class="keyword">val</span> <a title="List[String]" id="454627">wargs</a> = <a href="#149161" title="(available: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]">wildcardArgsString</a><span class="delimiter">(</span><a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a>.<span title="scala.collection.immutable.Set[Types.this.Symbol]">toSet</span>, <a href="#454626" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#454627" title="List[String]">wargs</a>, <a href="#454626" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span title="Nothing" class="keyword">return</span> <a href="#133525" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd" class="delimiter">(</span><a href="#454624" title="Types.this.Type">pre</a>, <a href="#454625" title="Types.this.Symbol">sym</a>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(other: String)java.lang.String">+</span> <a href="#454627" title="List[String]">wargs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="java.lang.String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="java.lang.String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">var</span> <a title="String" id="454617">ustr</a> = <a href="#236395" title="=&gt; Types.this.Type">underlying</a>.<span title="()String">toString</span>
      <a href="#236395" title="=&gt; Types.this.Type">underlying</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Unit">MethodType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> | NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> | PolyType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#454617" title="String">ustr</a> = <span title="java.lang.String(&quot;(&quot;)" class="string">&quot;(&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#454617" title="String">ustr</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
        <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
      <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="java.lang.String" id="454618">str</a> = 
        <a href="#454617" title="String">ustr</a><span title="(x$1: Any)java.lang.String">+</span><span class="delimiter">(</span><a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(f: Types.this.Symbol =&gt; java.lang.String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],java.lang.String,List[java.lang.String]])List[java.lang.String]">map</span> <span class="delimiter">(</span><a href="#454655" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107670" title="=&gt; java.lang.String">existentialToString</a><span class="delimiter">)</span> <span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot; forSome { &quot;)" class="string">&quot; forSome { &quot;</span>, <span title="java.lang.String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="java.lang.String(&quot; }&quot;)" class="string">&quot; }&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/StandardScalaSettings.scala.html#36862" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">explaintypes</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="java.lang.String(&quot;(&quot;)" class="string">&quot;(&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#454618" title="java.lang.String">str</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <span class="keyword">else</span> <a href="#454618" title="java.lang.String">str</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.ExistentialType" id="149163">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454691">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="454694">tparams</a> = <a href="Symbols.scala.html#67344" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#454691" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#149138" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">ExistentialType</a><span class="delimiter">(</span><a href="#454694" title="List[Types.this.Symbol]">tparams</a>, <a href="#236395" title="=&gt; Types.this.Type">underlying</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#454694" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="149164">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454733">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#454737" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#454733" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#149163" title="(owner: Types.this.Symbol)Types.this.ExistentialType">cloneInfo</a><span class="delimiter">(</span><a href="#454733" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#149138" title="Types.this.ExistentialType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="149165">kind</a> = <span title="java.lang.String(&quot;ExistentialType&quot;)" class="string">&quot;ExistentialType&quot;</span>

    <span class="keyword">def</span> <a title="(op: Types.this.Type =&gt; Boolean)Boolean" id="149166">withTypeVars</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="454746">op</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#149167" title="(op: Types.this.Type =&gt; Boolean, depth: Int)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#454746" title="Types.this.Type =&gt; Boolean">op</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="(op: Types.this.Type =&gt; Boolean, depth: Int)Boolean" id="149167">withTypeVars</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="454752">op</a>: Type =&gt; Boolean, <a title="Int" id="454753">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="454755">quantifiedFresh</a> = <a href="Symbols.scala.html#67341" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.TypeVar]" id="454756">tvars</a> = <a href="#454755" title="List[Types.this.Symbol]">quantifiedFresh</a> <span title="(f: Types.this.Symbol =&gt; Types.this.TypeVar)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.TypeVar,List[Types.this.TypeVar]])List[Types.this.TypeVar]">map</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="454808">tparam</a> =&gt; <a href="#448981" title="(tparam: Types.this.Symbol)Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#454808" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="454757">underlying1</a> = <a href="#236395" title="=&gt; Types.this.Type">underlying</a>.<a href="#105480" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#236394" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#454756" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span> <span class="comment">// fuse subst quantified -&gt; quantifiedFresh -&gt; tvars</span>
      <a href="#454752" title="(v1: Types.this.Type)Boolean">op</a><span class="delimiter">(</span><a href="#454757" title="Types.this.Type">underlying1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
        <a href="#67624" title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean, depth: Int)Boolean">solve</a><span class="delimiter">(</span><a href="#454756" title="List[Types.this.TypeVar]">tvars</a>, <a href="#454755" title="List[Types.this.Symbol]">quantifiedFresh</a>, <a href="#454755" title="List[Types.this.Symbol]">quantifiedFresh</a> <span title="(f: Types.this.Symbol =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Int,List[Int]])List[Int]">map</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="454919">x</a> =&gt; <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span>, <a href="#454753" title="Int">depth</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <a href="#67625" title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])Boolean">isWithinBounds</a><span class="delimiter">(</span><a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a>, <a href="#454755" title="List[Types.this.Symbol]">quantifiedFresh</a>, <a href="#454756" title="List[Types.this.TypeVar]">tvars</a> <span title="(f: Types.this.TypeVar =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeVar],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#454968" title="Types.this.TypeVar">_</a>.<a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449389" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.ExistentialType" id="67459">ExistentialType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24037" title="Types.this.ExistentialTypeExtractor">ExistentialTypeExtractor</a> 

  <span class="comment">/** A class containing the alternatives and type prefix of an overloaded symbol.
   *  Not used after phase `typer'.
   */</span>
  case <span class="keyword">class</span> <a title="class OverloadedType extends Types.this.Type with ScalaObject with Product with Serializable" id="251496">OverloadedType</a><a href="#251496" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="444575">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="444576">alternatives</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67392" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="251504">prefix</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#444575" title="=&gt; Types.this.Type">pre</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="251505">safeToString</a> =
      <span class="delimiter">(</span><a href="#444576" title="=&gt; List[Types.this.Symbol]">alternatives</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#444575" title="=&gt; Types.this.Type">pre</a>.<a href="#105502" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="java.lang.String(&quot; &lt;and&gt; &quot;)" class="string">&quot; &lt;and&gt; &quot;</span>, <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="251506">kind</a> = <span title="java.lang.String(&quot;OverloadedType&quot;)" class="string">&quot;OverloadedType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class remembering a type instantiation for some a set of overloaded
   *  polymorphic symbols.
   *  Not used after phase `typer'.
   */</span>
  case <span class="keyword">class</span> <a title="class AntiPolyType extends Types.this.Type with ScalaObject with Product with Serializable" id="455162">AntiPolyType</a><a href="#455162" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="456808">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="List[Types.this.Type]" id="456809">targs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67392" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="455126">safeToString</a> =
      <a href="#456808" title="=&gt; Types.this.Type">pre</a>.<span title="()String">toString</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#456809" title="=&gt; List[Types.this.Type]">targs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;(with type arguments &quot;)" class="string">&quot;(with type arguments &quot;</span>, <span title="java.lang.String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="455127">memberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="455140">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#67489" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#456808" title="=&gt; Types.this.Type">pre</a>.<a href="#105502" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#455140" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>, <a href="#456809" title="=&gt; List[Types.this.Type]">targs</a><span class="delimiter">)</span>
<span class="comment">//     override def memberType(sym: Symbol) = pre.memberType(sym) match {</span>
<span class="comment">//       case PolyType(tparams, restp) =&gt; </span>
<span class="comment">//         restp.subst(tparams, targs)</span>
<span class="comment">// /* I don't think this is needed, as existential types close only over value types</span>
<span class="comment">//       case ExistentialType(tparams, qtpe) =&gt; </span>
<span class="comment">//         existentialAbstraction(tparams, qtpe.memberType(sym))</span>
<span class="comment">// */ </span>
<span class="comment">//       case ErrorType =&gt; </span>
<span class="comment">//         ErrorType</span>
<span class="comment">//     }</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="455128">kind</a> = <span title="java.lang.String(&quot;AntiPolyType&quot;)" class="string">&quot;AntiPolyType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">//private var tidCount = 0  //DEBUG</span>

  <span class="comment">//@M </span>
  <span class="comment">// a TypeVar used to be a case class with only an origin and a constr</span>
  <span class="comment">// then, constr became mutable (to support UndoLog, I guess),</span>
  <span class="comment">// but pattern-matching returned the original constr0 (a bug)</span>
  <span class="comment">// now, pattern-matching returns the most recent constr</span>
  <span class="keyword">object</span> <a title="object Types.this.TypeVar" id="67467">TypeVar</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="comment">// encapsulate suspension so we can automatically link the suspension of cloned</span>
    <span class="comment">// typevars to their original if this turns out to be necessary</span>
<span class="comment">/*
    def Suspension = new Suspension
    class Suspension {
      private val suspended = mutable.HashSet[TypeVar]()
      def suspend(tv: TypeVar): Unit = {
        tv.suspended = true
        suspended += tv
      }
      def resumeAll(): Unit = {
        for (tv &lt;- suspended) {
          tv.suspended = false
        }
        suspended.clear()
      }
    }
*/</span>
    <span class="keyword">def</span> <a title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]" id="448979">unapply</a><span class="delimiter">(</span><a title="Types.this.TypeVar" id="448983">tv</a>: <a href="#67469" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">)</span>: <span title="Some[(Types.this.Type, Types.this.TypeConstraint)]">Some</span><span class="delimiter">[</span><span class="delimiter">(</span>Type, TypeConstraint<span class="delimiter">)</span><span class="delimiter">]</span> = <span title="(x: (Types.this.Type, Types.this.TypeConstraint))Some[(Types.this.Type, Types.this.TypeConstraint)]">Some</span><span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.TypeConstraint)(Types.this.Type, Types.this.TypeConstraint)" class="delimiter">(</span><a href="#448983" title="Types.this.TypeVar">tv</a>.<a href="#454817" title="=&gt; Types.this.Type">origin</a>, <a href="#448983" title="Types.this.TypeVar">tv</a>.<a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(origin: Types.this.Type, constr: Types.this.TypeConstraint)Types.this.TypeVar" id="448980">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="454833">origin</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.TypeConstraint" id="454834">constr</a>: <a href="#67513" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">)</span> = <span title="Types.this.TypeVar" class="keyword">new</span> <a href="#67469" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#454833" title="Types.this.Type">origin</a>, <a href="#454834" title="Types.this.TypeConstraint">constr</a>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="comment">// TODO why not initialise TypeConstraint with bounds of tparam?</span>
    <span class="comment">// @PP: I tried that, didn't work out so well for me.</span>
    <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Types.this.TypeVar" id="448981">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454821">tparam</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span title="Types.this.TypeVar" class="keyword">new</span> <a href="#67469" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#454821" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107563" title="=&gt; Types.this.Type">tpeHK</a>, <a href="#449370" title="()Types.this.TypeConstraint" class="keyword">new</a> <a href="#67513" title="Types.this.TypeConstraint">TypeConstraint</a>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#454821" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span> 
    <span class="keyword">def</span> <a title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar" id="448982">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="454811">origin</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.TypeConstraint" id="454812">constr</a>: <a href="#67513" title="Types.this.TypeConstraint">TypeConstraint</a>, <a title="List[Types.this.Type]" id="454813">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="454814">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> =
      <span title="Types.this.TypeVar" class="keyword">new</span> <a href="#67469" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#454811" title="Types.this.Type">origin</a>, <a href="#454812" title="Types.this.TypeConstraint">constr</a>, <a href="#454813" title="List[Types.this.Type]">args</a>, <a href="#454814" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/** A class representing a type variable 
   * Not used after phase `typer'.
   * A higher-kinded type variable has type arguments (a list of Type's) and type parameters (list of Symbols)
   * A TypeVar whose list of args is non-empty can only be instantiated by a higher-kinded type that can be applied to these args   
   * a typevar is much like a typeref, except it has special logic for type equality/subtyping
   */</span>
  <span class="keyword">class</span> <a title="class TypeVar extends Types.this.Type with ScalaObject" id="67469">TypeVar</a><a href="#67469" title="ScalaObject" class="delimiter">(</a><span class="keyword">val</span> <a title="Types.this.Type" id="454817">origin</a>: <a href="#67392" title="Types.this.Type">Type</a>, <span class="keyword">val</span> <a title="Types.this.TypeConstraint" id="454818">constr0</a>: <a href="#67513" title="Types.this.TypeConstraint">TypeConstraint</a>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Type]" id="454819">typeArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="454820">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67392" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="comment">// params are needed to keep track of variance (see mapOverArgs in SubstMap)</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#454819" title="=&gt; List[Types.this.Type]">typeArgs</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#454819" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#454820" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="comment">// var tid = { tidCount += 1; tidCount } //DEBUG</span>

    <span class="comment">/** The constraint associated with the variable */</span>
    <span class="keyword">var</span> <a title="Types.this.TypeConstraint" id="449001">constr</a> = <a href="#454818" title="=&gt; Types.this.TypeConstraint">constr0</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="449003">instValid</a> = <a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449391" title="=&gt; Boolean">instValid</a>
    
    <span class="comment">/** The variable's skolemization level */</span>
    <span class="keyword">val</span> <a title="Int" id="449004">level</a> = <a href="#67381" title="=&gt; Int">skolemizationLevel</a>

    <span class="comment">/**
     *  two occurrences of a higher-kinded typevar, e.g. ?CC[Int] and ?CC[String], correspond to 
     *  *two instances* of TypeVar that share the *same* TypeConstraint
     *  constr for ?CC only tracks type constructors anyway, so when ?CC[Int] &lt;:&lt; List[Int] and ?CC[String] &lt;:&lt; Iterable[String]
     *  ?CC's hibounds contains List and Iterable
     */</span>
    <span class="keyword">def</span> <a title="(newArgs: List[Types.this.Type])Types.this.TypeVar" id="449006">applyArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="455227">newArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67469" title="Types.this.TypeVar">TypeVar</a> =
      <span title="Types.this.TypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#455227" title="List[Types.this.Type]">newArgs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#67469" title="Types.this.TypeVar" class="keyword">this</a> <span class="comment">// SubstMap relies on this (though this check is redundant when called from appliedType...)</span>
      <span class="keyword">else</span> <a href="#448982" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#454817" title="=&gt; Types.this.Type">origin</a>, <a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>, <a href="#455227" title="List[Types.this.Type]">newArgs</a>, <a href="#454820" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span> <span class="comment">// @M TODO: interaction with undoLog??</span>
        <span class="comment">// newArgs.length may differ from args.length (could've been empty before)</span>
      <span class="comment">// example: when making new typevars, you start out with C[A], then you replace C by ?C, which should yield ?C[A], then A by ?A, ?C[?A]</span>
      <span class="comment">// we need to track a TypeVar's arguments, and map over them (see TypeMap::mapOver)</span>
      <span class="comment">// TypeVars get applied to different arguments over time (in asSeenFrom)</span>
       <span class="comment">// -- see pos/tcpoly_infer_implicit_tuplewrapper.scala</span>
      <span class="comment">// thus: make new TypeVar's for every application of a TV to args,</span>
      <span class="comment">// inference may generate several TypeVar's for a single type parameter that must be inferred,</span>
      <span class="comment">// only one of them is in the set of tvars that need to be solved, but</span>
      <span class="comment">// they share the same TypeConstraint instance</span>

    <span class="comment">// &lt;region name=&quot;constraint mutators + undoLog&quot;&gt;</span>
    <span class="comment">// invariant: before mutating constr, save old state in undoLog (undoLog is used to reset constraints to avoid piling up unrelated ones)</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449007">setInst</a><span class="delimiter">(</span><a title="Types.this.Type" id="455235">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
<span class="comment">//      assert(!(tp containsTp this), this)</span>
      <a href="#67383" title="object Types.this.undoLog">undoLog</a> <a href="#106881" title="(tv: Types.this.TypeVar)Unit">record</a> <a href="#67469" title="Types.this.TypeVar" class="keyword">this</a>
      <a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449389" title="(x$1: Types.this.Type)Unit">inst</a> = <a href="#455235" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="449008">addLoBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="455237">tp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Boolean" id="455240">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#455237" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#67469" title="Types.this.TypeVar" class="keyword">this</a><span class="delimiter">)</span> <span class="comment">// implies there is a cycle somewhere (?)</span>
      <span class="comment">//println(&quot;addLoBound: &quot;+(safeToString, debugString(tp))) //DEBUG</span>
      <a href="#67383" title="object Types.this.undoLog">undoLog</a> <a href="#106881" title="(tv: Types.this.TypeVar)Unit">record</a> <a href="#67469" title="Types.this.TypeVar" class="keyword">this</a>
      <a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449385" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a><span class="delimiter">(</span><a href="#455237" title="Types.this.Type">tp</a>, <a href="#455240" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="449009">addHiBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="455251">tp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Boolean" id="455254">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// assert(tp != this)</span>
      <span class="comment">//println(&quot;addHiBound: &quot;+(safeToString, debugString(tp))) //DEBUG</span>
      <a href="#67383" title="object Types.this.undoLog">undoLog</a> <a href="#106881" title="(tv: Types.this.TypeVar)Unit">record</a> <a href="#67469" title="Types.this.TypeVar" class="keyword">this</a>
      <a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449386" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a><span class="delimiter">(</span><a href="#455251" title="Types.this.Type">tp</a>, <a href="#455254" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="comment">// &lt;/region&gt;</span>

    <span class="comment">// ignore subtyping&amp;equality checks while true -- see findMember</span>
    <span class="keyword">private</span><span class="delimiter">[</span>Types<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Boolean" id="449011">suspended</a> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** Called when a TypeVar is involved in a subtyping check.  Result is whether
     *  this TypeVar could plausibly be a [super/sub]type of argument `tp` and if so,
     *  tracks tp as a [lower/upper] bound of this TypeVar.
     *
     *  if (isLowerBound)   this typevar could be a subtype, track tp as a lower bound
     *  if (!isLowerBound)  this typevar could be a supertype, track tp as an upper bound
     *
     *  If isNumericBound is true, the subtype check is performed with weak_&lt;:&lt; instead of &lt;:&lt;.
     */</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean" id="449013">registerBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="450210">tp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Boolean" id="450211">isLowerBound</a>: <span title="Boolean">Boolean</span>, <a title="Boolean" id="450214">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="comment">// println(&quot;regBound: &quot;+(safeToString, debugString(tp), isLowerBound)) //@MDEBUG</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450211" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#450210" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#67469" title="Types.this.TypeVar" class="keyword">this</a><span class="delimiter">)</span>

      <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="455259">checkSubtypeLower</a><span class="delimiter">(</span><a title="Types.this.Type" id="455271">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="455272">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#450214" title="Boolean">isNumericBound</a><span class="delimiter">)</span> <a href="#455271" title="Types.this.Type">tp1</a> <a href="#105519" title="(that: Types.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#455272" title="Types.this.Type">tp2</a>
        <span class="keyword">else</span> <a href="#455271" title="Types.this.Type">tp1</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#455272" title="Types.this.Type">tp2</a>
      
      <span class="comment">// swaps the arguments if it's an upper bound</span>
      <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="455260">checkSubtype</a><span class="delimiter">(</span><a title="Types.this.Type" id="455273">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="455274">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#450211" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#455259" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">checkSubtypeLower</a><span class="delimiter">(</span><a href="#455273" title="Types.this.Type">tp1</a>, <a href="#455274" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#455259" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">checkSubtypeLower</a><span class="delimiter">(</span><a href="#455274" title="Types.this.Type">tp2</a>, <a href="#455273" title="Types.this.Type">tp1</a><span class="delimiter">)</span>

      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="455261">addBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="455275">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span> 
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450211" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#449008" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a><span class="delimiter">(</span><a href="#455275" title="Types.this.Type">tp</a>, <a href="#450214" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#449009" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a><span class="delimiter">(</span><a href="#455275" title="Types.this.Type">tp</a>, <a href="#450214" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
        <span class="comment">// println(&quot;addedBound: &quot;+(this, tp)) // @MDEBUG</span>
        <span title="Boolean(true)" class="keyword">true</span>
      <span class="delimiter">}</span>
      
      <span class="comment">/** Simple case: type arguments can be ignored, because either this typevar has
       *  no type parameters, or we are comparing to Any/Nothing.
       *
       *  The latter condition is needed because HK unification is limited to constraints of the shape
       *    TC1[T1,..., TN] &lt;: TC2[T'1,...,T'N]
       *  which would preclude the following important constraints:
       *    Nothing &lt;: ?TC[?T]
       *    ?TC[?T] &lt;: Any
       */</span>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="455262">unifySimple</a> = <span class="delimiter">(</span><a href="#454820" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#450210" title="Types.this.Type">tp</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="#450210" title="Types.this.Type">tp</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
        <a href="#455261" title="(tp: Types.this.Type)Boolean">addBound</a><span class="delimiter">(</span><a href="#450210" title="Types.this.Type">tp</a><span class="delimiter">)</span>

      <span class="comment">/** Full case: involving a check of the form
       *    TC1[T1,..., TN] &lt;: TC2[T'1,...,T'N]
       *  Checks subtyping of higher-order type vars, and uses variances as defined in the
       *  type parameter we're trying to infer (the result will be sanity-checked later)
       */</span>
      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="455263">unifyFull</a><span class="delimiter">(</span><a title="Types.this.Type" id="455286">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#454819" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#455286" title="Types.this.Type">tp</a>.<a href="#105467" title="=&gt; List[Types.this.Type]">typeArgs</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span> <span class="comment">// this is a higher-kinded type var with same arity as tp</span>
        <span class="comment">// side effect: adds the type constructor itself as a bound</span>
        <a href="#455261" title="(tp: Types.this.Type)Boolean">addBound</a><span class="delimiter">(</span><a href="#455286" title="Types.this.Type">tp</a>.<a href="#105466" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#450211" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#67610" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean">isSubArgs</a><span class="delimiter">(</span><a href="#455286" title="Types.this.Type">tp</a>.<a href="#105467" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#454819" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#454820" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#67610" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean">isSubArgs</a><span class="delimiter">(</span><a href="#454819" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#455286" title="Types.this.Type">tp</a>.<a href="#105467" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#454820" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="comment">/** TODO: need positive/negative test cases demonstrating this is correct.
       */</span>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="455264">unifyParents</a> =
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#450211" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#450210" title="Types.this.Type">tp</a>.<a href="#105463" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <a href="#455263" title="(tp: Types.this.Type)Boolean">unifyFull</a>
        <span class="keyword">else</span> <a href="#450210" title="Types.this.Type">tp</a>.<a href="#105463" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <a href="#455263" title="(tp: Types.this.Type)Boolean">unifyFull</a>        
      
      <span class="comment">// TODO: fancier unification, maybe rewrite constraint as follows?</span>
      <span class="comment">// val sym = constr.hiBounds map {_.typeSymbol} find { _.typeParams.length == typeArgs.length}</span>
      <span class="comment">// this &lt;: tp.baseType(sym)</span>
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#449011" title="=&gt; Boolean">suspended</a><span class="delimiter">)</span> <a href="#455260" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">checkSubtype</a><span class="delimiter">(</span><a href="#450210" title="Types.this.Type">tp</a>, <a href="#454817" title="=&gt; Types.this.Type">origin</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449391" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#455260" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">checkSubtype</a><span class="delimiter">(</span><a href="#450210" title="Types.this.Type">tp</a>, <a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449389" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>  <span class="comment">// type var is already set</span>
      <span class="keyword">else</span> <a href="#449016" title="(tp: Types.this.Type)Boolean">isRelatable</a><span class="delimiter">(</span><a href="#450210" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span> <span class="comment">// gradually let go of some type precision in hopes of finding a type that has the same shape as the type variable</span>
        <span class="comment">// okay, this just screams &quot;CLEAN ME UP&quot; -- I think we could use tp.widen instead of tp straight from the get-go in registerBound, since we don't infer singleton types anyway (but maybe that'll change?)</span>
        <a href="#455262" title="=&gt; Boolean">unifySimple</a> <span title="(x: Boolean)Boolean">||</span> <a href="#455263" title="(tp: Types.this.Type)Boolean">unifyFull</a><span class="delimiter">(</span><a href="#450210" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#455263" title="(tp: Types.this.Type)Boolean">unifyFull</a><span class="delimiter">(</span><a href="#450210" title="Types.this.Type">tp</a>.<a href="#105484" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#455263" title="(tp: Types.this.Type)Boolean">unifyFull</a><span class="delimiter">(</span><a href="#450210" title="Types.this.Type">tp</a>.<a href="#105458" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#455263" title="(tp: Types.this.Type)Boolean">unifyFull</a><span class="delimiter">(</span><a href="#450210" title="Types.this.Type">tp</a>.<a href="#105458" title="=&gt; Types.this.Type">widen</a>.<a href="#105484" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#455264" title="=&gt; Boolean">unifyParents</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean" id="449014">registerTypeEquality</a><span class="delimiter">(</span><a title="Types.this.Type" id="455313">tp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Boolean" id="455314">typeVarLHS</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="comment">//println(&quot;regTypeEq: &quot;+(safeToString, debugString(tp), typeVarLHS)) //@MDEBUG</span>
      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="455316">checkIsSameType</a><span class="delimiter">(</span><a title="Types.this.Type" id="455317">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = 
        <span title="Boolean" class="keyword">if</span><span class="delimiter">(</span><a href="#455314" title="Boolean">typeVarLHS</a><span class="delimiter">)</span> <a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449389" title="=&gt; Types.this.Type">inst</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#455317" title="Types.this.Type">tp</a>
        <span class="keyword">else</span>           <a href="#455317" title="Types.this.Type">tp</a>          <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449389" title="=&gt; Types.this.Type">inst</a>

      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#449011" title="=&gt; Boolean">suspended</a><span class="delimiter">)</span> <a href="#455313" title="Types.this.Type">tp</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#454817" title="=&gt; Types.this.Type">origin</a>
      <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449391" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#455316" title="(tp: Types.this.Type)Boolean">checkIsSameType</a><span class="delimiter">(</span><a href="#455313" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#449016" title="(tp: Types.this.Type)Boolean">isRelatable</a><span class="delimiter">(</span><a href="#455313" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="455318">newInst</a> = <a href="#455320" title="(tp: Types.this.Type)Types.this.Type">wildcardToTypeVarMap</a><span class="delimiter">(</span><a href="#455313" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449387" title="(tp: Types.this.Type)Boolean">isWithinBounds</a><span class="delimiter">(</span><a href="#455318" title="Types.this.Type">newInst</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#449007" title="(tp: Types.this.Type)Unit">setInst</a><span class="delimiter">(</span><a href="#455313" title="Types.this.Type">tp</a><span class="delimiter">)</span>
          <span title="Boolean(true)" class="keyword">true</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Boolean(false)" class="keyword">false</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * ?A.T =:= tp is rewritten as the constraint ?A &lt;: {type T = tp}
     *
     * TODO: make these constraints count (incorporate them into implicit search in applyImplicitArgs)
     * (T corresponds to @param sym)
     */</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, tp: Types.this.Type)Boolean" id="449015">registerTypeSelection</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="455327">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="455328">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="455330">bound</a> = <a href="#67481" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><span title="(xs: Types.this.WildcardType.type*)List[Types.this.WildcardType.type]">List</span><span class="delimiter">(</span><a href="#450864" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span>, <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.TypeSymbol" id="455331">bsym</a> = <a href="#455330" title="Types.this.Type">bound</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107438" title="(pos: Types.this.Position, name: Types.this.TypeName)Types.this.TypeSymbol">newAliasType</a><span class="delimiter">(</span><a href="Positions.scala.html#67902" title="=&gt; tools.nsc.util.NoPosition.type">NoPosition</a>, <a href="#455327" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#96599" title="=&gt; Types.this.TypeName">toTypeName</a><span class="delimiter">)</span>
      <a href="#455331" title="Types.this.TypeSymbol">bsym</a> <a href="Symbols.scala.html#107566" title="(info: Types.this.Type)bsym.type">setInfo</a> <a href="#455328" title="Types.this.Type">tp</a>
      <a href="#455330" title="Types.this.Type">bound</a>.<a href="#105487" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#113086" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#455331" title="Types.this.TypeSymbol">bsym</a>
      <a href="#449013" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#455330" title="Types.this.Type">bound</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Can this variable be related in a constraint to type `tp'?
     *  This is not the case if `tp' contains type skolems whose
     *  skolemization level is higher than the level of this variable.
     */</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="449016">isRelatable</a><span class="delimiter">(</span><a title="Types.this.Type" id="455311">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <span title="=&gt; Boolean">!</span><a href="#455311" title="Types.this.Type">tp</a>.<a href="#105512" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">{</span> <a title="Types.this.Type" id="455372">t</a> =&gt;
        <a href="#455372" title="Types.this.Type">t</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="455373">ts</a>: <a href="Symbols.scala.html#67336" title="Types.this.TypeSkolem">TypeSkolem</a> =&gt; <a href="#455373" title="Types.this.TypeSkolem">ts</a>.<a href="Symbols.scala.html#444800" title="=&gt; Int">level</a> <span title="(x: Int)Boolean">&gt;</span> <a href="#449004" title="=&gt; Int">level</a>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="449017">isHigherKinded</a> = <a href="#454819" title="=&gt; List[Types.this.Type]">typeArgs</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#454820" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Boolean">nonEmpty</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="449019">normalize</a>: <a href="#67392" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449391" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449389" title="=&gt; Types.this.Type">inst</a>
      <span class="comment">// get here when checking higher-order subtyping of the typevar by itself</span>
      <span class="comment">// TODO: check whether this ever happens?</span>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#449017" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#67492" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#454820" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#449006" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#454820" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#455396" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107577" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#67469" title="Types.this.TypeVar" class="keyword">super</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="449020">typeSymbol</a> = <a href="#454817" title="=&gt; Types.this.Type">origin</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="449021">isStable</a> = <a href="#454817" title="=&gt; Types.this.Type">origin</a>.<a href="#105446" title="=&gt; Boolean">isStable</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="449022">isVolatile</a> = <a href="#454817" title="=&gt; Types.this.Type">origin</a>.<a href="#105447" title="=&gt; Boolean">isVolatile</a>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Any" id="449023">levelString</a> = <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/StandardScalaSettings.scala.html#36862" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">explaintypes</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#449004" title="=&gt; Int">level</a> <span class="keyword">else</span> <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="449024">safeToString</a> = <a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449389" title="=&gt; Types.this.Type">inst</a> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="java.lang.String" class="keyword">null</span>   =&gt; <span title="java.lang.String(&quot;&lt;null &quot;)" class="string">&quot;&lt;null &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#454817" title="=&gt; Types.this.Type">origin</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;&gt;&quot;)" class="string">&quot;&gt;&quot;</span>
      <span class="keyword">case</span> <a href="#450913" title="java.lang.String">NoType</a> =&gt; <span title="java.lang.String(&quot;?&quot;)" class="string">&quot;?&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#449023" title="=&gt; Any">levelString</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="#454817" title="=&gt; Types.this.Type">origin</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="TypeDebugging.scala.html#67949" title="(tp: Types.this.Type)String">typeArgsString</a><span class="delimiter">(</span><a href="#67469" title="Types.this.TypeVar" class="keyword">this</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="java.lang.String" id="455453">x</a>      =&gt; <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#455453" title="Types.this.Type">x</a>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="449025">kind</a> = <span title="java.lang.String(&quot;TypeVar&quot;)" class="string">&quot;TypeVar&quot;</span>

    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeVar" id="449026">cloneInternal</a> = <span class="delimiter">{</span>
      <span class="comment">// cloning a suspended type variable when it's suspended will cause the clone</span>
      <span class="comment">// to never be resumed with the current implementation</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#449011" title="=&gt; Boolean">suspended</a><span class="delimiter">)</span> 
      <a href="#448982" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#454817" title="=&gt; Types.this.Type">origin</a>, <a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a> <a href="#449392" title="=&gt; Types.this.TypeConstraint">cloneInternal</a>, <a href="#454819" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#454820" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span> <span class="comment">// @M TODO: clone args/params?</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A type carrying some annotations. Created by the typechecker
   *  when eliminating ``Annotated'' trees (see typedAnnotated).
   *
   *  @param annotations the list of annotations on the type
   *  @param underlying the type without the annotation
   *  @param selfsym a &quot;self&quot; symbol with type &lt;code&gt;underlying&lt;/code&gt;;
   *    only available if -Yself-in-annots is turned on. Can be NoSymbol
   *    if it is not used.
   */</span>
  case <span class="keyword">class</span> <a title="class AnnotatedType extends Types.this.Type with Types.this.RewrappingTypeProxy with ScalaObject with Product with Serializable" id="149016">AnnotatedType</a><a href="#149016" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="450659">annotations</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span>, 
                           <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="450660">underlying</a>: <a href="#67392" title="Types.this.Type">Type</a>,
                           <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Symbol" id="450661">selfsym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> 
  <span class="keyword">extends</span> <a href="#67391" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a> <span class="delimiter">{</span>

    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#450659" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.AnnotatedType" id="149054">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="455485">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#149016" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#450659" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>, <a href="#455485" title="Types.this.Type">tp</a>, <a href="#450661" title="=&gt; Types.this.Symbol">selfsym</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="149055">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#149056" title="=&gt; Boolean">isTrivial0</a>
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="149057">isTrivial0</a> = <a href="#450660" title="=&gt; Types.this.Type">underlying</a>.<a href="#105444" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#450659" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a> <span title="(p: Types.this.AnnotationInfo =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#455482" title="Types.this.AnnotationInfo">_</a>.<a href="AnnotationInfos.scala.html#133503" title="=&gt; Boolean">isTrivial</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="149058">safeToString</a>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="java.lang.String" id="455492">attString</a> =
        <span title="java.lang.String" class="keyword">if</span> <span class="delimiter">(</span><a href="#450659" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
          <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
        <span class="keyword">else</span>
          <a href="#450659" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot; @&quot;)" class="string">&quot; @&quot;</span>, <span title="java.lang.String(&quot; @&quot;)" class="string">&quot; @&quot;</span>, <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>

      <a href="#450660" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">underlying</a> <span title="(other: String)java.lang.String">+</span> <a href="#455492" title="java.lang.String">attString</a>
    <span class="delimiter">}</span>
    
    <span class="comment">/** Add a number of annotations to this type */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="149059">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="455497">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
      <a href="#149016" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">copy</a><span class="delimiter">(</span><a href="#455497" title="List[Types.this.AnnotationInfo]">annots</a><a href="#455512" title="(prefix: List[Types.this.AnnotationInfo])List[Types.this.AnnotationInfo]">:::</a><a href="#149016" title="AnnotatedType.this.type" class="keyword">this</a>.<a href="#450659" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a><span class="delimiter">)</span>

    <span class="comment">/** Remove any annotations from this type */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149060">withoutAnnotations</a> = <a href="#450660" title="=&gt; Types.this.Type">underlying</a>.<a href="#105544" title="=&gt; Types.this.Type">withoutAnnotations</a>

    <span class="comment">/** Set the self symbol */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.AnnotatedType" id="149061">withSelfsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="455523">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = 
      <a href="#149016" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#450659" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>, <a href="#450660" title="=&gt; Types.this.Type">underlying</a>, <a href="#455523" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>

    <span class="comment">/** Drop the annotations on the bounds, unless but the low and high
     *  bounds are exactly tp.
     */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="149062">bounds</a>: <a href="#148517" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#450660" title="=&gt; Types.this.Type">underlying</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a> <span title="Types.this.TypeBounds" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.TypeBounds">TypeBounds</span><span class="delimiter">(</span>_: <span class="keyword">this</span>.<span class="keyword">type</span>, _: <span class="keyword">this</span>.<span class="keyword">type</span><span class="delimiter">)</span> =&gt; <a href="#148501" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#149016" title="Types.this.AnnotatedType" class="keyword">this</a>, <a href="#149016" title="Types.this.AnnotatedType" class="keyword">this</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.TypeBounds" id="455528">oftp</a>                                   =&gt; <a href="#455528" title="Types.this.TypeBounds">oftp</a>
    <span class="delimiter">}</span>

    <span class="comment">// ** Replace formal type parameter symbols with actual type arguments. * /</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="149063">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="455529">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="455530">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="455533">annotations1</a> = <a href="#450659" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="(f: Types.this.AnnotationInfo =&gt; Types.this.AnnotationInfo)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.AnnotationInfo],Types.this.AnnotationInfo,List[Types.this.AnnotationInfo]])List[Types.this.AnnotationInfo]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.AnnotationInfo,List[Types.this.AnnotationInfo]]" class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="455551">info</a> =&gt; <a href="AnnotationInfos.scala.html#134310" title="(atp: Types.this.Type, args: List[Types.this.Tree], assocs: List[(Types.this.Name, Types.this.ClassfileAnnotArg)])Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">(</span><a href="#455551" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#133491" title="=&gt; Types.this.Type">atp</a>.<a href="#105480" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span>
          <a href="#455529" title="List[Types.this.Symbol]">formals</a>, <a href="#455530" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>, <a href="#455551" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#133493" title="=&gt; List[Types.this.Tree]">args</a>, <a href="#455551" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#133495" title="=&gt; List[(Types.this.Name, Types.this.ClassfileAnnotArg)]">assocs</a><span class="delimiter">)</span>.<a href="AnnotationInfos.scala.html#133502" title="(pos: scala.tools.nsc.util.Position)Types.this.AnnotationInfo">setPos</a><span class="delimiter">(</span><a href="#455551" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#133501" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="455534">underlying1</a> = <a href="#450660" title="=&gt; Types.this.Type">underlying</a>.<a href="#105480" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#455529" title="List[Types.this.Symbol]">formals</a>, <a href="#455530" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#455533" title="List[Types.this.AnnotationInfo]">annotations1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450659" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#455534" title="Types.this.Type">underlying1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450660" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#149016" title="Types.this.AnnotatedType" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#149016" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#455533" title="List[Types.this.AnnotationInfo]">annotations1</a>, <a href="#455534" title="Types.this.Type">underlying1</a>, <a href="#450661" title="=&gt; Types.this.Symbol">selfsym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Return the base type sequence of tp, dropping the annotations, unless the base type sequence of tp
      * is precisely tp itself. */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="149064">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#67704" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
       <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="455591">oftp</a> = <a href="#450660" title="=&gt; Types.this.Type">underlying</a>.<a href="#105524" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
       <span title="Types.this.BaseTypeSeq" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#455591" title="Types.this.BaseTypeSeq">oftp</a>.<a href="BaseTypeSeqs.scala.html#197569" title="=&gt; Int">length</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="BaseTypeSeqs.scala.html#197572" title="(i: Int)Types.this.Type">oftp</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450660" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span>
         <a href="BaseTypeSeqs.scala.html#67707" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">baseTypeSingletonSeq</a><span class="delimiter">(</span><a href="#149016" title="Types.this.AnnotatedType" class="keyword">this</a><span class="delimiter">)</span>
       <span class="keyword">else</span>
         <a href="#455591" title="Types.this.BaseTypeSeq">oftp</a>
     <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="149065">kind</a> = <span title="java.lang.String(&quot;AnnotatedType&quot;)" class="string">&quot;AnnotatedType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.AnnotatedType" id="67471">AnnotatedType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24037" title="Types.this.AnnotatedTypeExtractor">AnnotatedTypeExtractor</a>

  <span class="comment">/** A class representing types with a name. When an application uses
   *  named arguments, the named argument types for calling isApplicable
   *  are represented as NamedType.
   */</span>
  case <span class="keyword">class</span> <a title="class NamedType extends Types.this.Type with ScalaObject with Product with Serializable" id="455662">NamedType</a><a href="#455662" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Name" id="465588">name</a>: <a href="Names.scala.html#66925" title="Types.this.Name">Name</a>, <a title="Types.this.Type" id="465589">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67392" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="455637">safeToString</a>: <span title="String">String</span> = <a href="#465588" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#96604" title="()String">toString</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;: &quot;)" class="string">&quot;: &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#465589" title="=&gt; Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A class representing an as-yet unevaluated type.
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class LazyType extends Types.this.Type with Types.this.AbsLazyType with ScalaObject" id="67476">LazyType</a> <a href="#67476" title="ScalaObject" class="keyword">extends</a> <a href="#67392" title="Types.this.Type">Type</a> <span class="keyword">with</span> <span title="Types.this.AbsLazyType">AbsLazyType</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="105550">kind</a> = <span title="java.lang.String(&quot;LazyType&quot;)" class="string">&quot;LazyType&quot;</span>
  <span class="delimiter">}</span>

<span class="comment">// Creators ---------------------------------------------------------------</span>

  <span class="comment">/** Rebind symbol `sym' to an overriding member in type `pre'.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol" id="67477">rebind</a><span class="delimiter">(</span><a title="Types.this.Type" id="455709">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="455710">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Types.this.Symbol" id="455712">owner</a> = <a href="#455710" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>
    <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#455712" title="Types.this.Symbol">owner</a>.<span title="=&gt; Boolean">isClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#455712" title="Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#455709" title="Types.this.Type">pre</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#455710" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107529" title="=&gt; Boolean">isEffectivelyFinal</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#455710" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isClass</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">//Console.println(&quot;rebind &quot;+pre+&quot; &quot;+sym)//DEBUG</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="455717">rebind</a> = <a href="#455709" title="Types.this.Type">pre</a>.<a href="#105496" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#455710" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107593" title="(cond: Types.this.Symbol =&gt; Boolean)Types.this.Symbol">suchThat</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="455720">sym</a> =&gt; <a href="#455720" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isType</span> <span title="(x: Boolean)Boolean">||</span> <a href="#455720" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107514" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#455717" title="Types.this.Symbol">rebind</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#455710" title="Types.this.Symbol">sym</a> 
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="comment">// Console.println(&quot;rebound &quot;+pre+&quot; &quot;+sym+&quot; to &quot;+rebind)//DEBUG</span>
        <a href="#455717" title="Types.this.Symbol">rebind</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#455710" title="Types.this.Symbol">sym</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Convert a `super' prefix to a this-type if `sym'
   *  is abstract or final.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="67478">removeSuper</a><span class="delimiter">(</span><a title="Types.this.Type" id="455725">tp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="455726">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#455725" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">SuperType</span><span class="delimiter">(</span><a title="Types.this.Type" id="455728">thistp</a>, _<span class="delimiter">)</span> =&gt;
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#455726" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107529" title="=&gt; Boolean">isEffectivelyFinal</a> <span title="(x: Boolean)Boolean">||</span> <a href="#455726" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isDeferred</span><span class="delimiter">)</span> <a href="#455728" title="Types.this.Type">thistp</a>
      <span class="keyword">else</span> <a href="#455725" title="Types.this.Type">tp</a>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <a href="#455725" title="Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The canonical creator for single-types */</span>
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="67479">singleType</a><span class="delimiter">(</span><a title="Types.this.Type" id="132692">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="132693">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
      <a href="#132693" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>.<a href="#105468" title="=&gt; Types.this.Type">resultType</a>
    <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#132693" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isRootPackage</span><span class="delimiter">)</span>
      <a href="#148254" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="Definitions.scala.html#106177" title="=&gt; Types.this.ModuleClassSymbol">RootClass</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="455732">sym1</a> = <a href="#67477" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#132692" title="Types.this.Type">pre</a>, <a href="#132693" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="455733">pre1</a> = <a href="#67478" title="(tp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">removeSuper</a><span class="delimiter">(</span><a href="#132692" title="Types.this.Type">pre</a>, <a href="#455732" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#455733" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#132692" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#455732" title="Types.this.Symbol">sym1</a> = <a href="#67477" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#455733" title="Types.this.Type">pre1</a>, <a href="#455732" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      <a href="#148331" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">SingleType</a><span class="delimiter">(</span><a href="#455733" title="Types.this.Type">pre1</a>, <a href="#455732" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** the canonical creator for a refined type with a given scope */</span>
  <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type" id="67480">refinedType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="446135">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="446136">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Scope" id="446137">decls</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a>, <a title="Types.this.Position" id="446138">pos</a>: <a href="../util/Position.scala.html#30588" title="Types.this.Position">Position</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#446135" title="List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="Definitions.scala.html#106220" title="=&gt; Types.this.Symbol">ObjectClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#446135" title="List[Types.this.Type]">parents</a>.<span title="=&gt; Types.this.Type">head</span>
    <span class="keyword">else</span> <span class="delimiter">{</span> 
      <span class="keyword">val</span> <a title="Types.this.ClassSymbol" id="455736">clazz</a> = <a href="#446136" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#107455" title="(pos: Types.this.Position)Types.this.ClassSymbol">newRefinementClass</a><span class="delimiter">(</span><a href="Positions.scala.html#67902" title="=&gt; tools.nsc.util.NoPosition.type">NoPosition</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.RefinedType" id="455737">result</a> = <a href="#148575" title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#446135" title="List[Types.this.Type]">parents</a>, <a href="#446137" title="Types.this.Scope">decls</a>, <a href="#455736" title="Types.this.ClassSymbol">clazz</a><span class="delimiter">)</span>
      <a href="#455736" title="Types.this.ClassSymbol">clazz</a>.<a href="Symbols.scala.html#107566" title="(info: Types.this.Type)clazz.type">setInfo</a><span class="delimiter">(</span><a href="#455737" title="Types.this.RefinedType">result</a><span class="delimiter">)</span>
      <a href="#455737" title="Types.this.RefinedType">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The canonical creator for a refined type with an initially empty scope.
   *
   *  @param parents ...
   *  @param owner   ...
   *  @return        ...
   */</span>
  <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type" id="67481">refinedType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="446130">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="446131">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
    <a href="#67480" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#446130" title="List[Types.this.Type]">parents</a>, <a href="#446131" title="Types.this.Symbol">owner</a>, <a href="Scopes.scala.html#113079" title="()Types.this.Scope" class="keyword">new</a> <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a>, <a href="#446131" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#107404" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type" id="67482">copyRefinedType</a><span class="delimiter">(</span><a title="Types.this.RefinedType" id="451500">original</a>: <a href="#148576" title="Types.this.RefinedType">RefinedType</a>, <a title="List[Types.this.Type]" id="451501">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="451502">decls</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a><span class="delimiter">)</span> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#451501" title="List[Types.this.Type]">parents</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#451500" title="Types.this.RefinedType">original</a>.<a href="#236369" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#451502" title="Types.this.Scope">decls</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#451500" title="Types.this.RefinedType">original</a>.<a href="#236370" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#451500" title="Types.this.RefinedType">original</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="451505">owner</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#451500" title="Types.this.RefinedType">original</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a> <span class="keyword">else</span> <a href="#451500" title="Types.this.RefinedType">original</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="451506">result</a> = <a href="#67481" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#451501" title="List[Types.this.Type]">parents</a>, <a href="#451505" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="451507">syms1</a> = <a href="#451502" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113097" title="=&gt; List[Types.this.Symbol]">toList</a>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="451539">sym</a> &lt;- <a href="#451507" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)Unit">syms1</a><span class="delimiter">)</span>
        <a href="#451506" title="Types.this.Type">result</a>.<a href="#105487" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113086" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a><span class="delimiter">(</span><a href="#451539" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107595" title="(owner: Types.this.Symbol)Types.this.Symbol">cloneSymbol</a><span class="delimiter">(</span><a href="#451506" title="Types.this.Type">result</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="451508">syms2</a> = <a href="#451506" title="Types.this.Type">result</a>.<a href="#105487" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113097" title="=&gt; List[Types.this.Symbol]">toList</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="451509">resultThis</a> = <a href="#451506" title="Types.this.Type">result</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107600" title="=&gt; Types.this.Type">thisType</a>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="451574">sym</a> &lt;- <a href="#451508" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)Unit">syms2</a><span class="delimiter">)</span>
        <a href="#451574" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107566" title="(info: Types.this.Type)sym.type">setInfo</a><span class="delimiter">(</span><a href="#451574" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105506" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#451500" title="Types.this.RefinedType">original</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#451509" title="Types.this.Type">resultThis</a><span class="delimiter">)</span>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#451507" title="List[Types.this.Symbol]">syms1</a>, <a href="#451508" title="List[Types.this.Symbol]">syms2</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#451506" title="Types.this.Type">result</a>
    <span class="delimiter">}</span>

  <span class="comment">/** The canonical creator for typerefs 
   *  todo: see how we can clean this up a bit
   */</span>
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="67483">typeRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="133399">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="133400">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="133401">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span class="comment">// type alias selections are rebound in TypeMap (&quot;coevolved&quot;, actually -- see #3731)</span>
    <span class="comment">// e.g., when type parameters that are referenced by the alias are instantiated in</span>
    <span class="comment">// the prefix.  See pos/depmet_rebind_typealias.</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol" id="455752">rebindTR</a><span class="delimiter">(</span><a title="Types.this.Type" id="455754">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="455755">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#455755" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAbstractType</span><span class="delimiter">)</span> <a href="#67477" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#455754" title="Types.this.Type">pre</a>, <a href="#455755" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#455755" title="Types.this.Symbol">sym</a>
      
    <span class="keyword">val</span> <a title="Types.this.Symbol" id="455753">sym1</a> = <a href="#455752" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebindTR</a><span class="delimiter">(</span><a href="#133399" title="Types.this.Type">pre</a>, <a href="#133400" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>

    <span class="comment">// we require that object is initialized, thus info.typeParams instead of typeParams.</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#455753" title="Types.this.Symbol">sym1</a>.<span title="=&gt; Boolean">isAliasType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#455753" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105477" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#133401" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#455753" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107459" title="=&gt; Boolean">lockOK</a><span class="delimiter">)</span> <a href="#133525" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#133399" title="Types.this.Type">pre</a>, <a href="#455753" title="Types.this.Symbol">sym1</a>, <a href="#133401" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="comment">// don't expand type alias (cycles checked by lockOK)</span>
      <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <a href="#313958" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#67669" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="java.lang.String(&quot;illegal cyclic reference involving &quot;)" class="string">&quot;illegal cyclic reference involving &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#455753" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="455760">pre1</a> = <a href="#67478" title="(tp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">removeSuper</a><span class="delimiter">(</span><a href="#133399" title="Types.this.Type">pre</a>, <a href="#455753" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#455760" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#133399" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <a href="#67483" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#455760" title="Types.this.Type">pre1</a>, <a href="#455752" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebindTR</a><span class="delimiter">(</span><a href="#455760" title="Types.this.Type">pre1</a>, <a href="#455753" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>, <a href="#133401" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#133399" title="Types.this.Type">pre</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span>: <a href="#67426" title="Types.this.CompoundType">CompoundType</a> <span class="keyword">if</span> <a href="#455753" title="Types.this.Symbol">sym1</a>.<span title="=&gt; Boolean">isClass</span> =&gt;
          <span class="comment">// sharpen prefix so that it is maximal and still contains the class.</span>
          <a href="#133399" title="Types.this.Type">pre</a>.<a href="#105463" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; List[Types.this.Type]">reverse</span> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">dropWhile</span> <span class="delimiter">(</span><a href="#455768" title="Types.this.Type">_</a>.<a href="#105495" title="(name: Types.this.Name)Types.this.Symbol">member</a><span class="delimiter">(</span><a href="#455753" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#455753" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Types.this.Type">Nil</span>         =&gt; <a href="#133525" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#133399" title="Types.this.Type">pre</a>, <a href="#455753" title="Types.this.Symbol">sym1</a>, <a href="#133401" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
            <span class="keyword">case</span> <a title="Types.this.Type" id="455778">parent</a> :: _ =&gt; <a href="#67483" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#455778" title="Types.this.Type">parent</a>, <a href="#455753" title="Types.this.Symbol">sym1</a>, <a href="#133401" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#133525" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#133399" title="Types.this.Type">pre</a>, <a href="#455753" title="Types.this.Symbol">sym1</a>, <a href="#133401" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="67484">copyTypeRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="159929">tp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="159930">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="159931">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="159932">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#159929" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="455779">pre0</a>, <a title="Types.this.Symbol" id="455780">sym0</a>, <a title="List[Types.this.Type]" id="455781">args0</a><span class="delimiter">)</span> =&gt;
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#159930" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#455779" title="Types.this.Type">pre0</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#159931" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#455780" title="Types.this.Symbol">sym0</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>

        <span class="keyword">val</span> <a title="Types.this.Symbol" id="455791">sym1</a> = <a href="#159931" title="Types.this.Symbol">sym</a>
        <span class="comment">// we require that object is initialized, thus info.typeParams instead of typeParams.</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#455791" title="Types.this.Symbol">sym1</a>.<span title="=&gt; Boolean">isAliasType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#455791" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105477" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#159932" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#455791" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107459" title="=&gt; Boolean">lockOK</a><span class="delimiter">)</span> <a href="#133525" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#159930" title="Types.this.Type">pre</a>, <a href="#455791" title="Types.this.Symbol">sym1</a>, <a href="#159932" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="comment">// don't expand type alias (cycles checked by lockOK)</span>
          <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <a href="#313958" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#67669" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="java.lang.String(&quot;illegal cyclic reference involving &quot;)" class="string">&quot;illegal cyclic reference involving &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#455791" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <a href="#133525" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#159930" title="Types.this.Type">pre</a>, <a href="#455791" title="Types.this.Symbol">sym1</a>, <a href="#159932" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        
      <span class="delimiter">}</span> <span class="keyword">else</span>
        <a href="#67483" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#159930" title="Types.this.Type">pre</a>, <a href="#159931" title="Types.this.Symbol">sym</a>, <a href="#159932" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>




  <span class="comment">/** The canonical creator for implicit method types */</span>
  <span class="keyword">def</span> <a title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.JavaMethodType" id="67485">JavaMethodType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="455796">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="455797">resultType</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67451" title="Types.this.JavaMethodType">JavaMethodType</a> =
    <span title="Types.this.JavaMethodType" class="keyword">new</span> <a href="#67451" title="Types.this.JavaMethodType">JavaMethodType</a><span class="delimiter">(</span><a href="#455796" title="List[Types.this.Symbol]">params</a>, <a href="#455797" title="Types.this.Type">resultType</a><span class="delimiter">)</span> <span class="comment">// don't unique this!</span>

  <span class="comment">/** Create a new MethodType of the same class as tp, i.e. keep JavaMethodType */</span>
  <span class="keyword">def</span> <a title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type" id="67486">copyMethodType</a><span class="delimiter">(</span><a title="Types.this.Type" id="453760">tp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="453761">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="453762">restpe</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#453760" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.JavaMethodType">_</span>: <a href="#67451" title="Types.this.JavaMethodType">JavaMethodType</a> =&gt; <a href="#67485" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.JavaMethodType">JavaMethodType</a><span class="delimiter">(</span><a href="#453761" title="List[Types.this.Symbol]">params</a>, <a href="#453762" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.MethodType">_</span> =&gt; <a href="#148762" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#453761" title="List[Types.this.Symbol]">params</a>, <a href="#453762" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A creator for intersection type where intersections of a single type are
   *  replaced by the type itself, and repeated parent classes are merged.
   */</span>
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type" id="67487">intersectionType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="422192">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="422193">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#422192" title="List[Types.this.Type]">tps</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#455800" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="455811">tp</a><span class="delimiter">)</span> =&gt;
      <a href="#455811" title="Types.this.Type">tp</a>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
       <a href="#67481" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#422192" title="List[Types.this.Type]">tps</a>, <a href="#422193" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
<span class="comment">/*
      def merge(tps: List[Type]): List[Type] = tps match {
        case tp :: tps1 =&gt;
          val tps1a = tps1 filter (_.typeSymbol.==(tp.typeSymbol))
          val tps1b = tps1 filter (_.typeSymbol.!=(tp.typeSymbol))
          mergePrefixAndArgs(tps1a, -1) match {
            case Some(tp1) =&gt; tp1 :: merge(tps1b)
            case None =&gt; throw new MalformedType(
              &quot;malformed type: &quot;+refinedType(tps, owner)+&quot; has repeated parent class &quot;+
              tp.typeSymbol+&quot; with incompatible prefixes or type arguments&quot;)
          }
        case _ =&gt; tps
      } 
      refinedType(merge(tps), owner)
*/</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A creator for intersection type where intersections of a single type are
   *  replaced by the type itself. */</span>
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type])Types.this.Type" id="67488">intersectionType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="422189">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#422189" title="List[Types.this.Type]">tps</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#455817" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="455828">tp</a><span class="delimiter">)</span> =&gt; <a href="#455828" title="Types.this.Type">tp</a>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#67481" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#422189" title="List[Types.this.Type]">tps</a>, <a href="#67661" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#422189" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/** A creator for type applications */</span>
  <span class="keyword">def</span> <a title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type" id="67489">appliedType</a><span class="delimiter">(</span><a title="Types.this.Type" id="299005">tycon</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="List[Types.this.Type]" id="299006">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =  
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#299006" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#299005" title="Types.this.Type">tycon</a> <span class="comment">//@M! `if (args.isEmpty) tycon' is crucial (otherwise we create new types in phases after typer and then they don't get adapted (??))</span>
    <span class="keyword">else</span> <a href="#299005" title="Types.this.Type">tycon</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span> 
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="455839">pre</a>, <a title="Types.this.Symbol" id="455840">sym</a> @ <span class="delimiter">(</span><a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a>|<a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#67484" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#299005" title="Types.this.Type">tycon</a>, <a href="#455839" title="Types.this.Type">pre</a>, <a href="#455840" title="Types.this.Symbol">sym</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span>   <span class="comment">//@M drop type args to Any/Nothing</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="455841">pre</a>, <a title="Types.this.Symbol" id="455842">sym</a>, _<span class="delimiter">)</span>                           =&gt; <a href="#67484" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#299005" title="Types.this.Type">tycon</a>, <a href="#455841" title="Types.this.Type">pre</a>, <a href="#455842" title="Types.this.Symbol">sym</a>, <a href="#299006" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="455843">tparams</a>, <a title="Types.this.Type" id="455844">restpe</a><span class="delimiter">)</span>                      =&gt; <a href="#455844" title="Types.this.Type">restpe</a>.<a href="#105480" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#455843" title="List[Types.this.Symbol]">tparams</a>, <a href="#299006" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.ExistentialType">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="455845">tparams</a>, <a title="Types.this.Type" id="455846">restpe</a><span class="delimiter">)</span>               =&gt; <a href="#149138" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">ExistentialType</a><span class="delimiter">(</span><a href="#455845" title="List[Types.this.Symbol]">tparams</a>, <a href="#67489" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#455846" title="Types.this.Type">restpe</a>, <a href="#299006" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="455847">st</a>: <a href="#67398" title="Types.this.SingletonType">SingletonType</a>                              =&gt; <a href="#67489" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#455847" title="Types.this.SingletonType">st</a>.<a href="#148269" title="=&gt; Types.this.Type">widen</a>, <a href="#299006" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="comment">// @M TODO: what to do? see bug1</span>
      <span class="keyword">case</span> <span title="Types.this.RefinedType">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="455848">parents</a>, <a title="Types.this.Scope" id="455849">decls</a><span class="delimiter">)</span>                    =&gt; <a href="#148576" title="(parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#455848" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#67489" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#455872" title="Types.this.Type">_</a>, <a href="#299006" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#455849" title="Types.this.Scope">decls</a><span class="delimiter">)</span> <span class="comment">// MO to AM: please check</span>
      <span class="keyword">case</span> <span title="Types.this.TypeBounds">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="455900">lo</a>, <a title="Types.this.Type" id="455901">hi</a><span class="delimiter">)</span>                             =&gt; <a href="#148501" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#67489" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#455900" title="Types.this.Type">lo</a>, <a href="#299006" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, <a href="#67489" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#455901" title="Types.this.Type">hi</a>, <a href="#299006" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.TypeVar" id="455902">tv</a>@<a href="#448979" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span>                               =&gt; <a href="#455902" title="Types.this.TypeVar">tv</a>.<a href="#449006" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#299006" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.AnnotatedType">AnnotatedType</span><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="455904">annots</a>, <a title="Types.this.Type" id="455905">underlying</a>, <a title="Types.this.Symbol" id="455906">self</a><span class="delimiter">)</span>        =&gt; <a href="#149016" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#455904" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#67489" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#455905" title="Types.this.Type">underlying</a>, <a href="#299006" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, <a href="#455906" title="Types.this.Symbol">self</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="#450846" title="Types.this.Type">ErrorType</a>                                      =&gt; <a href="#299005" title="Types.this.Type">tycon</a>
      <span class="keyword">case</span> <a href="#450864" title="Types.this.Type">WildcardType</a>                                   =&gt; <a href="#299005" title="Types.this.Type">tycon</a> <span class="comment">// needed for neg/t0226</span>
      <span class="keyword">case</span> <span title="Nothing">_</span>                                              =&gt; <a href="SymbolTable.scala.html#64790" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><a href="TypeDebugging.scala.html#67950" title="(tp: Types.this.Type)String">debugString</a><span class="delimiter">(</span><a href="#299005" title="Types.this.Type">tycon</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/** A creator for type parameterizations that strips empty type parameter lists.
   * Use this factory method to indicate the type has kind * (it's a polymorphic value) 
   * until we start tracking explicit kinds equivalent to typeFun (except that the latter requires tparams nonEmpty)
   */</span>
  <span class="keyword">def</span> <a title="(tparams: List[Types.this.Symbol], tpe: Types.this.Type)Types.this.Type" id="67490">polyType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="399166">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="399167">tpe</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = 
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#399166" title="List[Types.this.Symbol]">tparams</a> <span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#67492" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#399166" title="List[Types.this.Symbol]">tparams</a>, <a href="#399167" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <a href="#399167" title="Types.this.Type">tpe</a> <span class="comment">// it's okay to be forgiving here</span>

  <span class="comment">/** A creator for anonymous type functions, where the symbol for the type function still needs to be created 
   *
   * TODO:
   * type params of anonymous type functions, which currently can only arise from normalising type aliases, are owned by the type alias of which they are the eta-expansion
   * higher-order subtyping expects eta-expansion of type constructors that arise from a class; here, the type params are owned by that class, but is that the right thing to do?
   */</span>
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type" id="67491">typeFunAnon</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="453236">tps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="453237">body</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#67492" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#453236" title="List[Types.this.Symbol]">tps</a>, <a href="#453237" title="Types.this.Type">body</a><span class="delimiter">)</span>
  
  <span class="comment">/** A creator for a type functions, assuming the type parameters tps already have the right owner 
   */</span>
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type" id="67492">typeFun</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="451923">tps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="451924">body</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#148921" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#451923" title="List[Types.this.Symbol]">tps</a>, <a href="#451924" title="Types.this.Type">body</a><span class="delimiter">)</span>

  <span class="comment">/** A creator for existential types. This generates:
   *  
   *  tpe1 where { tparams }
   *
   *  where `tpe1' is the result of extrapolating `tpe' wrt to `tparams'. Extrapolating means
   *  that type variables in `tparams' occurring in covariant positions are replaced by upper bounds,
   *  (minus any SingletonClass markers),
   *  type variables in `tparams' occurring in contravariant positions are replaced by upper bounds,
   *  provided the resulting type is legal wrt to stability, and does not contain any
   *  type variable in `tparams'.
   *  The abstraction drops all type parameters that are not directly or indirectly 
   *  referenced by type `tpe1'.
   *  If there are no remaining type parameters, simply returns result type `tpe'. 
   */</span>
  <span class="keyword">def</span> <a title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type" id="67493">existentialAbstraction</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="262146">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="262147">tpe0</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = 
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#262146" title="List[Types.this.Symbol]">tparams</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#262147" title="Types.this.Type">tpe0</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Int]" id="455912">occurCount</a> = <a href="#67522" title="=&gt; scala.collection.immutable.Map[Types.this.Symbol,Int]">emptySymCount</a> <span title="(xs: scala.collection.GenTraversableOnce[(Types.this.Symbol, Int)])scala.collection.immutable.Map[Types.this.Symbol,Int]">++</span> <span class="delimiter">(</span><a href="#262146" title="List[Types.this.Symbol]">tparams</a> <span title="(f: Types.this.Symbol =&gt; (Types.this.Symbol, Int))(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],(Types.this.Symbol, Int),List[(Types.this.Symbol, Int)]])List[(Types.this.Symbol, Int)]">map</span> <span class="delimiter">(</span><a href="#455973" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">_</a> <span title="(y: Int)(Types.this.Symbol, Int)">-&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="455913">tpe</a> = <a href="#456050" title="(tp: Types.this.Type)Types.this.Type">deAlias</a><span class="delimiter">(</span><a href="#262147" title="Types.this.Type">tpe0</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="455914">countOccs</a><span class="delimiter">(</span><a title="Types.this.Type" id="456055">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="456057">t</a> &lt;- <a href="#105510" title="(f: Types.this.Type =&gt; Unit)Unit">tp</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#456057" title="Types.this.Type">t</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="456058">sym</a>, _<span class="delimiter">)</span> =&gt;
              <a href="#455912" title="scala.collection.immutable.Map[Types.this.Symbol,Int]">occurCount</a> <span title="(key: Types.this.Symbol)Option[Int]">get</span> <a href="#456058" title="Types.this.Symbol">sym</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Unit">Some</span><span class="delimiter">(</span><a title="Int" id="456068">count</a><span class="delimiter">)</span> =&gt; <a href="#455912" title="scala.collection.immutable.Map[Types.this.Symbol,Int]">occurCount</a> <span title="(kv: (Types.this.Symbol, Int))scala.collection.immutable.Map[Types.this.Symbol,Int]">+=</span> <span class="delimiter">(</span><a href="#456058" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">sym</a> <span title="(y: Int)(Types.this.Symbol, Int)">-&gt;</span> <span class="delimiter">(</span><a href="#456068" title="Int">count</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">case</span> <a title="Unit" id="456155">none</a> =&gt;
              <span class="delimiter">}</span>
            <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <a href="#455914" title="(tp: Types.this.Type)Unit">countOccs</a><span class="delimiter">(</span><a href="#455913" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="456175">tparam</a> &lt;- <a href="#262146" title="(f: Types.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span> <a href="#455914" title="(tp: Types.this.Type)Unit">countOccs</a><span class="delimiter">(</span><a href="#456175" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span>
          
      <span class="keyword">val</span> <a title="Types.this.TypeMap" id="455915">extrapolate</a> = <a href="#456177" title="Types.this.TypeMap" class="keyword">new</a> <a href="#67514" title="anonymous class $anon extends Types.this.TypeMap" id="456177">TypeMap</a> <span class="delimiter">{</span>
        <a href="#133450" title="(x$1: Int)Unit">variance</a> = <span title="Int(1)" class="int">1</span>
        <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="456179">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="456182">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="456205">tp1</a> = <a href="#456180" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#456182" title="Types.this.Type">tp</a><span class="delimiter">)</span> 
          <a href="#456205" title="Types.this.Type">tp1</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="456212">pre</a>, <a title="Types.this.Symbol" id="456213">sym</a>, <a title="List[Types.this.Type]" id="456214">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#133450" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#455912" title="scala.collection.immutable.Map[Types.this.Symbol,Int]">occurCount</a> <span title="(key: Types.this.Symbol)Boolean">isDefinedAt</span> <a href="#456213" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> =&gt;
              <span class="keyword">val</span> <a title="Types.this.Type" id="456224">repl</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133450" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#447272" title="(tp: Types.this.Type)Types.this.Type">dropSingletonType</a><span class="delimiter">(</span><a href="#456205" title="Types.this.Type">tp1</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#456205" title="Types.this.Type">tp1</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148531" title="=&gt; Types.this.Type">lo</a>
              <span class="comment">//println(&quot;eliminate &quot;+sym+&quot;/&quot;+repl+&quot;/&quot;+occurCount(sym)+&quot;/&quot;+(tparams exists (repl.contains)))//DEBUG</span>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456224" title="Types.this.Type">repl</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#456224" title="Types.this.Type">repl</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#106226" title="=&gt; Types.this.Symbol">NullClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
                  <a href="#455912" title="(key: Types.this.Symbol)Int">occurCount</a><span class="delimiter">(</span><a href="#456213" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#262146" title="List[Types.this.Symbol]">tparams</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#456224" title="Types.this.Type">repl</a>.<a href="#105513" title="(sym: Types.this.Symbol)Boolean">contains</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#456224" title="Types.this.Type">repl</a>
              <span class="keyword">else</span> <a href="#456205" title="Types.this.Type">tp1</a>
            <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
              <a href="#456205" title="Types.this.Type">tp1</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="456180">mapOver</a><span class="delimiter">(</span><a title="Types.this.Type" id="456185">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#456185" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="456273">pre</a>, <a title="Types.this.Symbol" id="456274">sym</a><span class="delimiter">)</span> =&gt;
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456274" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span><span class="delimiter">)</span> <a href="#456185" title="Types.this.Type">tp</a> <span class="comment">// short path</span>
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="456275">pre1</a> = <a href="#456179" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456273" title="Types.this.Type">pre</a><span class="delimiter">)</span>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456275" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456273" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#456275" title="Types.this.Type">pre1</a>.<a href="#105446" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#456185" title="Types.this.Type">tp</a>
              <span class="keyword">else</span> <a href="#67479" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#456275" title="Types.this.Type">pre1</a>, <a href="#456274" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#456177" title="Types.this.TypeMap" class="keyword">super</a>.<a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#456185" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Option[Types.this.Tree]" id="456181">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="456188">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = 
          <a href="#456188" title="Types.this.Tree">tree</a> <span title="Option[Types.this.Tree]" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a title="Some[Types.this.Ident]" id="456191">tree</a>:<span title="Types.this.Ident">Ident</span> <span class="keyword">if</span> <a href="#456191" title="Types.this.Ident">tree</a>.<span title="=&gt; Types.this.Type">tpe</span>.<a href="#105446" title="=&gt; Boolean">isStable</a> =&gt;
              <span class="comment">// Do not discard the types of existential ident's.</span>
              <span class="comment">// The symbol of the Ident itself cannot be listed</span>
              <span class="comment">// in the existential's parameters, so the</span>
              <span class="comment">// resulting existential type would be ill-formed.</span>
              <span title="(x: Types.this.Ident)Some[Types.this.Ident]">Some</span><span class="delimiter">(</span><a href="#456191" title="Types.this.Ident">tree</a><span class="delimiter">)</span>

            <span class="keyword">case</span> <span title="Option[Types.this.Tree]">_</span> =&gt;
              <a href="#456177" title="Types.this.TypeMap" class="keyword">super</a>.<a href="#133465" title="(tree: Types.this.Tree)Option[Types.this.Tree]">mapOver</a><span class="delimiter">(</span><a href="#456188" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="455916">tpe1</a> = <a href="#455915" title="(v1: Types.this.Type)Types.this.Type">extrapolate</a><span class="delimiter">(</span><a href="#455913" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="455917">tparams0</a> = <a href="#262146" title="List[Types.this.Symbol]">tparams</a>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="455918">tparams1</a> = <a href="#455917" title="List[Types.this.Symbol]">tparams0</a> <span title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">filter</span> <a href="#455916" title="Types.this.Type">tpe1</a>.<a href="#105513" title="(sym: Types.this.Symbol)Boolean">contains</a>

      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#455918" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#455917" title="List[Types.this.Symbol]">tparams0</a><span class="delimiter">)</span> <a href="#455919" title="()Unit" class="delimiter">{</a>
        <a href="#455917" title="List[Types.this.Symbol]">tparams0</a> = <a href="#455918" title="List[Types.this.Symbol]">tparams1</a>
        <a href="#455918" title="List[Types.this.Symbol]">tparams1</a> = <a href="#262146" title="List[Types.this.Symbol]">tparams</a> <span title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">filter</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="456331">p</a> =&gt;
          <a href="#455918" title="List[Types.this.Symbol]">tparams1</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="456340">p1</a> =&gt; <a href="#456340" title="Types.this.Symbol">p1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#456331" title="Types.this.Symbol">p</a> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#456340" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a> <a href="#105513" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#456331" title="Types.this.Symbol">p</a><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#455918" title="List[Types.this.Symbol]">tparams1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#455916" title="Types.this.Type">tpe1</a> 
      <span class="keyword">else</span> <a href="#455916" title="Types.this.Type">tpe1</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.ExistentialType">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="456346">tparams2</a>, <a title="Types.this.Type" id="456347">tpe2</a><span class="delimiter">)</span> =&gt; <a href="#149138" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">ExistentialType</a><span class="delimiter">(</span><a href="#455918" title="List[Types.this.Symbol]">tparams1</a> <a href="#456348" title="(prefix: List[Types.this.Symbol])List[Types.this.Symbol]">:::</a> <a href="#456346" title="List[Types.this.Symbol]">tparams2</a>, <a href="#456347" title="Types.this.Type">tpe2</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.ExistentialType">_</span> =&gt; <a href="#149138" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">ExistentialType</a><span class="delimiter">(</span><a href="#455918" title="List[Types.this.Symbol]">tparams1</a>, <a href="#455916" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Remove any occurrences of type aliases from this type */</span>
  <span class="keyword">object</span> <a title="object Types.this.deAlias" id="67494">deAlias</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="456050">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="456051">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a> <span class="delimiter">{</span>
      <a href="#456051" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="456365">pre</a>, <a title="Types.this.Symbol" id="456366">sym</a>, <a title="List[Types.this.Type]" id="456367">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#456366" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span> =&gt; <a href="#456051" title="Types.this.Type">tp</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#456051" title="Types.this.Type">tp</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Remove any occurrence of type &lt;singleton&gt; from this type and its parents */</span>
  <span class="keyword">object</span> <a title="object Types.this.dropSingletonType" id="67496">dropSingletonType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="447272">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="447273">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#447273" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span>_, <a href="Definitions.scala.html#106344" title="=&gt; Types.this.Symbol">SingletonClass</a>, _<span class="delimiter">)</span> =&gt;
          <a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
        <span class="keyword">case</span> <a title="Types.this.Type" id="456369">tp1</a> @ RefinedType<span class="delimiter">(</span><a title="List[Types.this.Type]" id="456370">parents</a>, <a title="Types.this.Scope" id="456371">decls</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">var</span> <a title="List[Types.this.Type]" id="456372">parents1</a> = <a href="#456370" title="List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a href="#456376" title="Types.this.Type">_</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#106344" title="=&gt; Types.this.Symbol">SingletonClass</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#456372" title="List[Types.this.Type]">parents1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#456372" title="List[Types.this.Type]">parents1</a> = <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456372" title="List[Types.this.Type]">parents1</a>.<span title="=&gt; List[Types.this.Type]">tail</span>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#456371" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113083" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#456372" title="List[Types.this.Type]">parents1</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#67482" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#456369" title="Types.this.RefinedType">tp1</a>, <a href="#456372" title="List[Types.this.Type]">parents1</a>, <a href="#456371" title="Types.this.Scope">decls</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <a title="Types.this.Type" id="456412">tp1</a> =&gt; 
          <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#456412" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
<span class="comment">// Hash consing --------------------------------------------------------------</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="Int" id="67498">initialUniquesCapacity</a> = <span title="Int(4096)" class="int">4096</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="scala.tools.nsc.util.HashSet[Types.this.Type]" id="67501">uniques</a>: util.<a href="../util/HashSet.scala.html#30357" title="scala.tools.nsc.util.HashSet[Types.this.Type]">HashSet</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = _
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="67504">uniqueRunId</a> = <span title="Int(0)">NoRunId</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T &lt;: Types.this.Type](tp: T)T" id="67506">unique</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Types.this.Type" id="67508">T</a> &lt;: Type<span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="450994">tp</a>: <a href="#67508" title="T">T</a><span class="delimiter">)</span>: <a href="#67508" title="T">T</a> = <span class="delimiter">{</span>
    <a href="../util/Statistics.scala.html#67162" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67217" title="=&gt; scala.tools.nsc.util.Statistics.Counter">rawTypeCount</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#67504" title="=&gt; Int">uniqueRunId</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#64808" title="=&gt; Types.this.RunId">currentRunId</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#67501" title="(x$1: scala.tools.nsc.util.HashSet[Types.this.Type])Unit">uniques</a> = util.<a href="../util/HashSet.scala.html#167953" title="[T &gt;: Null &lt;: AnyRef](label: String, initialCapacity: Int)scala.tools.nsc.util.HashSet[T]">HashSet</a><span title="(label: String, initialCapacity: Int)scala.tools.nsc.util.HashSet[Types.this.Type]" class="delimiter">[</span><a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="java.lang.String(&quot;uniques&quot;)" class="string">&quot;uniques&quot;</span>, <a href="#67498" title="=&gt; Int">initialUniquesCapacity</a><span class="delimiter">)</span>
      <a href="#67504" title="(x$1: Int)Unit">uniqueRunId</a> = <a href="SymbolTable.scala.html#64808" title="=&gt; Types.this.RunId">currentRunId</a>
    <span class="delimiter">}</span>
    <span class="delimiter">(</span><a href="#67501" title="=&gt; scala.tools.nsc.util.HashSet[Types.this.Type]">uniques</a> <a href="../util/HashSet.scala.html#120361" title="(x: Types.this.Type)Types.this.Type">findEntryOrUpdate</a> <a href="#450994" title="T">tp</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#67508" title="T">T</a><span class="delimiter">]</span>
  <span class="delimiter">}</span>

<span class="comment">// Helper Classes ---------------------------------------------------------</span>

  <span class="comment">/** @PP: Unable to see why these apparently constant types should need vals
   *  in every TypeConstraint, I lifted them out.
   */</span>
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.Type" id="67510">numericLoBound</a> = <a href="Definitions.scala.html#106726" title="=&gt; Types.this.Symbol">IntClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.Type" id="67512">numericHiBound</a> = <a href="#67487" title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">intersectionType</a><span class="delimiter">(</span><span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="Definitions.scala.html#106720" title="=&gt; Types.this.Symbol">ByteClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>, <a href="Definitions.scala.html#106724" title="=&gt; Types.this.Symbol">CharClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>, <a href="Definitions.scala.html#106187" title="=&gt; Types.this.Symbol">ScalaPackageClass</a><span class="delimiter">)</span>

  <span class="comment">/** A class expressing upper and lower bounds constraints of type variables, 
   * as well as their instantiations.
   */</span>
  <span class="keyword">class</span> <a title="class TypeConstraint extends java.lang.Object with ScalaObject" id="67513">TypeConstraint</a><a href="#67513" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Type]" id="449419">lo0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="449420">hi0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Type" id="449421">numlo0</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="449422">numhi0</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span> 
    <span class="keyword">def</span> <a title="(lo0: List[Types.this.Type], hi0: List[Types.this.Type])Types.this.TypeConstraint" id="449369" class="keyword">this</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="449417">lo0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="449418">hi0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#67513" title="TypeConstraint.this.type" class="keyword">this</a><span class="delimiter">(</span><a href="#449417" title="List[Types.this.Type]">lo0</a>, <a href="#449418" title="List[Types.this.Type]">hi0</a>, <a href="#450913" title="object Types.this.NoType">NoType</a>, <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="()Types.this.TypeConstraint" id="449370" class="keyword">this</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="#449369" title="(lo0: List[Types.this.Type], hi0: List[Types.this.Type])Types.this.TypeConstraint" class="keyword">this</a><span class="delimiter">(</span>List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[Types.this.Type]" id="449372">lobounds</a> = <a href="#449419" title="List[Types.this.Type]">lo0</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[Types.this.Type]" id="449375">hibounds</a> = <a href="#449420" title="List[Types.this.Type]">hi0</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="449378">numlo</a> = <a href="#449421" title="Types.this.Type">numlo0</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="449381">numhi</a> = <a href="#449422" title="Types.this.Type">numhi0</a>

    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="449383">loBounds</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#449378" title="=&gt; Types.this.Type">numlo</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <a href="#449372" title="=&gt; List[Types.this.Type]">lobounds</a> <span class="keyword">else</span> <a href="#449378" title="=&gt; Types.this.Type">numlo</a> <a href="#456486" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#449372" title="=&gt; List[Types.this.Type]">lobounds</a>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="449384">hiBounds</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#449381" title="=&gt; Types.this.Type">numhi</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <a href="#449375" title="=&gt; List[Types.this.Type]">hibounds</a> <span class="keyword">else</span> <a href="#449381" title="=&gt; Types.this.Type">numhi</a> <a href="#456499" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#449375" title="=&gt; List[Types.this.Type]">hibounds</a>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="449385">addLoBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="455247">tp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Boolean" id="455250">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#455250" title="Boolean">isNumericBound</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#106666" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#455247" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#449378" title="=&gt; Types.this.Type">numlo</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450913" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">||</span> <a href="#67644" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#449378" title="=&gt; Types.this.Type">numlo</a>, <a href="#455247" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#449378" title="(x$1: Types.this.Type)Unit">numlo</a> = <a href="#455247" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#67644" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#455247" title="Types.this.Type">tp</a>, <a href="#449378" title="=&gt; Types.this.Type">numlo</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#449378" title="(x$1: Types.this.Type)Unit">numlo</a> = <a href="#67509" title="=&gt; Types.this.Type">numericLoBound</a>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#449372" title="(x$1: List[Types.this.Type])Unit">lobounds</a> <span title="(x: Types.this.Type)List[Types.this.Type]">::=</span> <a href="#455247" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="449386">addHiBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="455255">tp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Boolean" id="455258">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#455258" title="Boolean">isNumericBound</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#106666" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#455255" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#449381" title="=&gt; Types.this.Type">numhi</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450913" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">||</span> <a href="#67644" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#455255" title="Types.this.Type">tp</a>, <a href="#449381" title="=&gt; Types.this.Type">numhi</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#449381" title="(x$1: Types.this.Type)Unit">numhi</a> = <a href="#455255" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#67644" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#449381" title="=&gt; Types.this.Type">numhi</a>, <a href="#455255" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#449381" title="(x$1: Types.this.Type)Unit">numhi</a> = <a href="#67511" title="=&gt; Types.this.Type">numericHiBound</a>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#449375" title="(x$1: List[Types.this.Type])Unit">hibounds</a> <span title="(x: Types.this.Type)List[Types.this.Type]">::=</span> <a href="#455255" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="449387">isWithinBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="455325">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <a href="#449372" title="=&gt; List[Types.this.Type]">lobounds</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#456536" title="Types.this.Type">_</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#455325" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
      <a href="#449375" title="=&gt; List[Types.this.Type]">hibounds</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#455325" title="Types.this.Type">tp</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#456545" title="Types.this.Type">_</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span class="delimiter">(</span><a href="#449378" title="=&gt; Types.this.Type">numlo</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450913" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#449378" title="=&gt; Types.this.Type">numlo</a> <a href="#105519" title="(that: Types.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#455325" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span class="delimiter">(</span><a href="#449381" title="=&gt; Types.this.Type">numhi</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450913" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#455325" title="Types.this.Type">tp</a> <a href="#105519" title="(that: Types.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#449381" title="=&gt; Types.this.Type">numhi</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">var</span> <a title="Types.this.Type" id="449389">inst</a>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#450913" title="object Types.this.NoType">NoType</a> <span class="comment">// @M reduce visibility?</span>

    <span class="keyword">def</span> <a title="=&gt; Boolean" id="449391">instValid</a> = <span class="delimiter">(</span><a href="#449389" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#449389" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeConstraint" id="449392">cloneInternal</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.TypeConstraint" id="449414">tc</a> = <span title="Types.this.TypeConstraint" class="keyword">new</span> <a href="#67513" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">(</span><a href="#449372" title="=&gt; List[Types.this.Type]">lobounds</a>, <a href="#449375" title="=&gt; List[Types.this.Type]">hibounds</a>, <a href="#449378" title="=&gt; Types.this.Type">numlo</a>, <a href="#449381" title="=&gt; Types.this.Type">numhi</a><span class="delimiter">)</span>
      <a href="#449414" title="Types.this.TypeConstraint">tc</a>.<a href="#449389" title="(x$1: Types.this.Type)Unit">inst</a> = <a href="#449389" title="=&gt; Types.this.Type">inst</a>
      <a href="#449414" title="Types.this.TypeConstraint">tc</a>
    <span class="delimiter">}</span>
    
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="449393">toString</a> =
      <span class="delimiter">(</span><a href="#449383" title="=&gt; List[Types.this.Type]">loBounds</a> <span title="(f: Types.this.Type =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],String,List[String]])List[String]">map</span> <span class="delimiter">(</span><a href="#456578" title="Types.this.Type">_</a>.<span title="=&gt; String">safeToString</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;[ _&gt;:(&quot;)" class="string">&quot;[ _&gt;:(&quot;</span>, <span title="java.lang.String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="java.lang.String(&quot;) &quot;)" class="string">&quot;) &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)java.lang.String">+</span>
      <span class="delimiter">(</span><a href="#449384" title="=&gt; List[Types.this.Type]">hiBounds</a> <span title="(f: Types.this.Type =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],String,List[String]])List[String]">map</span> <span class="delimiter">(</span><a href="#456628" title="Types.this.Type">_</a>.<span title="=&gt; String">safeToString</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;| _&lt;:(&quot;)" class="string">&quot;| _&lt;:(&quot;</span>, <span title="java.lang.String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="java.lang.String(&quot;) ] _= &quot;)" class="string">&quot;) ] _= &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)java.lang.String">+</span> 
      <a href="#449389" title="=&gt; Types.this.Type">inst</a>.<span title="=&gt; String">safeToString</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A prototype for mapping a function over all possible types
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeMap extends java.lang.Object with Types.this.Type =&gt; Types.this.Type with ScalaObject" id="67514">TypeMap</a> <a href="#67514" title="ScalaObject" class="keyword">extends</a> <span title="Types.this.Type =&gt; Types.this.Type">Function1</span><span class="delimiter">[</span>Type, Type<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="comment">// deferred inherited: def apply(tp: Type): Type</span>

    <span class="comment">/** The variance relative to start. If you want variances to be significant, set
     *  variance = 1
     *  at the top of the typemap.
     */</span>
    <span class="keyword">var</span> <a title="Int" id="133450">variance</a> = <span title="Int(0)" class="int">0</span>

    <span class="comment">/** Should this map drop annotations that are not
     *  type-constraint annotations?
     */</span>
    <span class="keyword">val</span> <a title="Boolean" id="133452">dropNonConstraintAnnotations</a> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** Check whether two lists have elements that are eq-equal */</span>
    <span class="keyword">def</span> <a title="[T &lt;: AnyRef](l1: List[T], l2: List[T])Boolean" id="133454">allEq</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef" id="133456">T</a> &lt;: AnyRef<span class="delimiter">]</span><span class="delimiter">(</span><a title="List[T]" id="456664">l1</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="List[T]" id="456665">l2</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> =
      <span class="delimiter">(</span><a href="#456664" title="List[T]">l1</a> <span title="(that: scala.collection.GenSeq[T])(p: (T, T) =&gt; Boolean)Boolean">corresponds</span> <a href="#456665" title="List[T]">l2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#456696" title="T">_</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456697" title="T">_</a><span class="delimiter">)</span>

    <span class="comment">// #3731: return sym1 for which holds: pre bound sym.name to sym and pre1 now binds sym.name to sym1, conceptually exactly the same symbol as sym</span>
    <span class="comment">// the selection of sym on pre must be updated to the selection of sym1 on pre1,</span>
    <span class="comment">// since sym's info was probably updated by the TypeMap to yield a new symbol sym1 with transformed info</span>
    <span class="comment">// @returns sym1</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(pre: Types.this.Type, pre1: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol" id="133457">coevolveSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="456700">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="456701">pre1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="456702">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> =
      <span title="Types.this.Symbol" class="keyword">if</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#456700" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#456701" title="Types.this.Type">pre1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#456702" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <span class="comment">// only need to rebind type aliases here, as typeRef already handles abstract types (they are allowed to be rebound more liberally)</span>
        <span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#456700" title="Types.this.Type">pre</a>, <a href="#456701" title="Types.this.Type">pre1</a><span class="delimiter">)</span> <span title="Types.this.Symbol" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Types.this.Symbol" class="delimiter">(</span>RefinedType<span class="delimiter">(</span>_, <a title="Types.this.Scope" id="456712">decls</a><span class="delimiter">)</span>, RefinedType<span class="delimiter">(</span>_, <a title="Types.this.Scope" id="456713">decls1</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span class="comment">// don't look at parents -- it would be an error to override alias types anyway</span>
            <span class="comment">//val sym1 =</span>
            <a href="#456713" title="Types.this.Scope">decls1</a>.<a href="Scopes.scala.html#113093" title="(name: Types.this.Name)Types.this.Symbol">lookup</a><span class="delimiter">(</span><a href="#456702" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
<span class="comment">//            assert(decls.lookupAll(sym.name).toList.length == 1)</span>
<span class="comment">//            assert(decls1.lookupAll(sym.name).toList.length == 1)</span>
<span class="comment">//            assert(sym1.isAliasType)</span>
<span class="comment">//            println(&quot;coevolved &quot;+ sym +&quot; : &quot;+ sym.info +&quot; to &quot;+ sym1 +&quot; : &quot;+ sym1.info +&quot; with &quot;+ pre +&quot; -&gt; &quot;+ pre1)</span>
<span class="comment">//            sym1</span>
          <span class="keyword">case</span> <span title="Types.this.Symbol">_</span> =&gt; <span class="comment">// TODO: is there another way a typeref's symbol can refer to a symbol defined in its pre?</span>
<span class="comment">//            val sym1 = pre1.nonPrivateMember(sym.name).suchThat(sym =&gt; sym.isAliasType)</span>
<span class="comment">//            println(&quot;??coevolve &quot;+ sym +&quot; : &quot;+ sym.info +&quot; to &quot;+ sym1 +&quot; : &quot;+ sym1.info +&quot; with &quot;+ pre +&quot; -&gt; &quot;+ pre1)</span>
            <a href="#456702" title="Types.this.Symbol">sym</a>
        <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#456702" title="Types.this.Symbol">sym</a>

    <span class="comment">/** Map this function over given type */</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="133458">mapOver</a><span class="delimiter">(</span><a title="Types.this.Type" id="133518">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#133518" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="456715">pre</a>, <a title="Types.this.Symbol" id="456716">sym</a>, <a title="List[Types.this.Type]" id="456717">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="456718">pre1</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456715" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span class="comment">//val args1 = args mapConserve this(_)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="456719">args1</a> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#456717" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#456717" title="List[Types.this.Type]">args</a>
                    <span class="keyword">else</span> <span class="delimiter">{</span>
                      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="456721">tparams</a> = <a href="#456716" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>
                      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#456721" title="List[Types.this.Symbol]">tparams</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#456717" title="List[Types.this.Type]">args</a>
                      <span class="keyword">else</span> <a href="#133459" title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">mapOverArgs</a><span class="delimiter">(</span><a href="#456717" title="List[Types.this.Type]">args</a>, <a href="#456721" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
                    <span class="delimiter">}</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456718" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456715" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#456719" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456717" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133518" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#67484" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#133518" title="Types.this.Type">tp</a>, <a href="#456718" title="Types.this.Type">pre1</a>, <a href="#133457" title="(pre: Types.this.Type, pre1: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">coevolveSym</a><span class="delimiter">(</span><a href="#456715" title="Types.this.Type">pre</a>, <a href="#456718" title="Types.this.Type">pre1</a>, <a href="#456716" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>, <a href="#456719" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span> 
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#133518" title="Types.this.Type">tp</a>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="456725">pre</a>, <a title="Types.this.Symbol" id="456726">sym</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456726" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span><span class="delimiter">)</span> <a href="#133518" title="Types.this.Type">tp</a> <span class="comment">// short path</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="456727">pre1</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456725" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456727" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456725" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#133518" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#67479" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#456727" title="Types.this.Type">pre1</a>, <a href="#456726" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="456728">params</a>, <a title="Types.this.Type" id="456729">result</a><span class="delimiter">)</span> =&gt;
        <a href="#133450" title="(x$1: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#133450" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="456730">params1</a> = <a href="#133461" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#456728" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
        <a href="#133450" title="(x$1: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#133450" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="456731">result1</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456729" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456730" title="List[Types.this.Symbol]">params1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456728" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#456731" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456729" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133518" title="Types.this.Type">tp</a>
        <span class="comment">// for new dependent types: result1.substSym(params, params1)?</span>
        <span class="keyword">else</span> <a href="#67486" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#133518" title="Types.this.Type">tp</a>, <a href="#456730" title="List[Types.this.Symbol]">params1</a>, <a href="#456731" title="Types.this.Type">result1</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#456728" title="List[Types.this.Symbol]">params</a>, <a href="#456730" title="List[Types.this.Symbol]">params1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="456738">tparams</a>, <a title="Types.this.Type" id="456739">result</a><span class="delimiter">)</span> =&gt;
        <a href="#133450" title="(x$1: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#133450" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="456740">tparams1</a> = <a href="#133461" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#456738" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
        <a href="#133450" title="(x$1: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#133450" title="=&gt; Int">variance</a>
        <span class="keyword">var</span> <a title="Types.this.Type" id="456741">result1</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456739" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456740" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456738" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#456741" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456739" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133518" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#148921" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#456740" title="List[Types.this.Symbol]">tparams1</a>, <a href="#456741" title="Types.this.Type">result1</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#456738" title="List[Types.this.Symbol]">tparams</a>, <a href="#456740" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="456748">result</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="456749">result1</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456748" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456749" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456748" title="Types.this.Type">result</a><span class="delimiter">)</span> <a href="#133518" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#148865" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#456749" title="Types.this.Type">result1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ConstantType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#133518" title="Types.this.Type">tp</a>
      <span class="keyword">case</span> <span title="Types.this.Type">SuperType</span><span class="delimiter">(</span><a title="Types.this.Type" id="456751">thistp</a>, <a title="Types.this.Type" id="456752">supertp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="456753">thistp1</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456751" title="Types.this.Type">thistp</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="456754">supertp1</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456752" title="Types.this.Type">supertp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456753" title="Types.this.Type">thistp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456751" title="Types.this.Type">thistp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#456754" title="Types.this.Type">supertp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456752" title="Types.this.Type">supertp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133518" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#149262" title="(thistp: Types.this.Type, supertp: Types.this.Type)Types.this.Type">SuperType</a><span class="delimiter">(</span><a href="#456753" title="Types.this.Type">thistp1</a>, <a href="#456754" title="Types.this.Type">supertp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="456757">lo</a>, <a title="Types.this.Type" id="456758">hi</a><span class="delimiter">)</span> =&gt;
        <a href="#133450" title="(x$1: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#133450" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="456759">lo1</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456757" title="Types.this.Type">lo</a><span class="delimiter">)</span>
        <a href="#133450" title="(x$1: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#133450" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="456760">hi1</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456758" title="Types.this.Type">hi</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456759" title="Types.this.Type">lo1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456757" title="Types.this.Type">lo</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#456760" title="Types.this.Type">hi1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456758" title="Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133518" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#148501" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#456759" title="Types.this.Type">lo1</a>, <a href="#456760" title="Types.this.Type">hi1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="456761">bounds</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="456762">bounds1</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456761" title="Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456762" title="Types.this.Type">bounds1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456761" title="Types.this.TypeBounds">bounds</a><span class="delimiter">)</span> <a href="#133518" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#258485" title="(bounds: Types.this.TypeBounds)Types.this.BoundedWildcardType">BoundedWildcardType</a><span class="delimiter">(</span><a href="#456762" title="Types.this.Type">bounds1</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.TypeBounds" class="delimiter">[</span><a href="#148517" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">]</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="456767">rtp</a> @ RefinedType<span class="delimiter">(</span><a title="List[Types.this.Type]" id="456768">parents</a>, <a title="Types.this.Scope" id="456769">decls</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="456770">parents1</a> = <a href="#456768" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a href="#67514" title="Types.this.TypeMap" class="keyword">this</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Scope" id="456771">decls1</a> = <a href="#133460" title="(scope: Types.this.Scope)Types.this.Scope">mapOver</a><span class="delimiter">(</span><a href="#456769" title="Types.this.Scope">decls</a><span class="delimiter">)</span>
        <span class="comment">//if ((parents1 eq parents) &amp;&amp; (decls1 eq decls)) tp</span>
        <span class="comment">//else refinementOfClass(tp.typeSymbol, parents1, decls1)</span>
        <a href="#67482" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#456767" title="Types.this.RefinedType">rtp</a>, <a href="#456770" title="List[Types.this.Type]">parents1</a>, <a href="#456771" title="Types.this.Scope">decls1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="456784">tparams</a>, <a title="Types.this.Type" id="456785">result</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="456786">tparams1</a> = <a href="#133461" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#456784" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
        <span class="keyword">var</span> <a title="Types.this.Type" id="456787">result1</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456785" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456786" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456784" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#456787" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456785" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133518" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#149138" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">ExistentialType</a><span class="delimiter">(</span><a href="#456786" title="List[Types.this.Symbol]">tparams1</a>, <a href="#456787" title="Types.this.Type">result1</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#456784" title="List[Types.this.Symbol]">tparams</a>, <a href="#456786" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">OverloadedType</span><span class="delimiter">(</span><a title="Types.this.Type" id="456795">pre</a>, <a title="List[Types.this.Symbol]" id="456796">alts</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="456797">pre1</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456795" title="Types.this.Type">pre</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#148665" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#456795" title="Types.this.Type">pre</a> <span class="keyword">else</span> <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456795" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456797" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456795" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#133518" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#251496" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.OverloadedType">OverloadedType</a><span class="delimiter">(</span><a href="#456797" title="Types.this.Type">pre1</a>, <a href="#456796" title="List[Types.this.Symbol]">alts</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">AntiPolyType</span><span class="delimiter">(</span><a title="Types.this.Type" id="456798">pre</a>, <a title="List[Types.this.Type]" id="456799">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="456800">pre1</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456798" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="456801">args1</a> = <a href="#456799" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a href="#67514" title="Types.this.TypeMap" class="keyword">this</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456800" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456798" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#456801" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456799" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133518" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#455162" title="(pre: Types.this.Type, targs: List[Types.this.Type])Types.this.AntiPolyType">AntiPolyType</a><span class="delimiter">(</span><a href="#456800" title="Types.this.Type">pre1</a>, <a href="#456801" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="456815">tv</a>@<a href="#448979" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="456817">constr</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456817" title="Types.this.TypeConstraint">constr</a>.<a href="#449391" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456817" title="Types.this.TypeConstraint">constr</a>.<a href="#449389" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#456815" title="Types.this.TypeVar">tv</a>.<a href="#449006" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#133459" title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">mapOverArgs</a><span class="delimiter">(</span><a href="#456815" title="Types.this.TypeVar">tv</a>.<a href="#454819" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#456815" title="Types.this.TypeVar">tv</a>.<a href="#454820" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span>  <span class="comment">//@M !args.isEmpty implies !typeParams.isEmpty </span>
      <span class="keyword">case</span> <span title="Types.this.Type">NotNullType</span><span class="delimiter">(</span><a title="Types.this.Type" id="456818">tp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="456819">tp1</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456818" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456819" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456818" title="Types.this.Type">tp</a><span class="delimiter">)</span> <a href="#456818" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#449814" title="(underlying: Types.this.Type)Types.this.NotNullType">NotNullType</a><span class="delimiter">(</span><a href="#456819" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">AnnotatedType</span><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="456821">annots</a>, <a title="Types.this.Type" id="456822">atp</a>, <a title="Types.this.Symbol" id="456823">selfsym</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="456824">annots1</a> = <a href="#133462" title="(annots: List[Types.this.AnnotationInfo])List[Types.this.AnnotationInfo]">mapOverAnnotations</a><span class="delimiter">(</span><a href="#456821" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="456825">atp1</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456822" title="Types.this.Type">atp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456824" title="List[Types.this.AnnotationInfo]">annots1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456821" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#456825" title="Types.this.Type">atp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456822" title="Types.this.Type">atp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133518" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456824" title="List[Types.this.AnnotationInfo]">annots1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#456825" title="Types.this.Type">atp1</a>
        <span class="keyword">else</span> <a href="#149016" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#456824" title="List[Types.this.AnnotationInfo]">annots1</a>, <a href="#456825" title="Types.this.Type">atp1</a>, <a href="#456823" title="Types.this.Symbol">selfsym</a><span class="delimiter">)</span>
<span class="comment">/*
      case ErrorType =&gt; tp
      case WildcardType =&gt; tp
      case NoType =&gt; tp
      case NoPrefix =&gt; tp
*/</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#133518" title="Types.this.Type">tp</a>
        <span class="comment">// throw new Error(&quot;mapOver inapplicable for &quot; + tp);</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]" id="133459">mapOverArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="456722">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="456723">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = 
      <a href="#67618" title="(xs: List[Types.this.Type], ys: List[Types.this.Symbol])(f: (Types.this.Type, Types.this.Symbol) =&gt; Types.this.Type)List[Types.this.Type]">map2Conserve</a><span class="delimiter">(</span><a href="#456722" title="List[Types.this.Type]">args</a>, <a href="#456723" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Type" id="456869">arg</a>, <a title="Types.this.Symbol" id="456870">tparam</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Int" id="456871">v</a> = <a href="#133450" title="=&gt; Int">variance</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#456870" title="Types.this.Symbol">tparam</a>.<span title="=&gt; Boolean">isContravariant</span><span class="delimiter">)</span> <a href="#133450" title="(x$1: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#133450" title="=&gt; Int">variance</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#456870" title="Types.this.Symbol">tparam</a>.<span title="=&gt; Boolean">isCovariant</span><span class="delimiter">)</span> <a href="#133450" title="(x$1: Int)Unit">variance</a> = <span title="Int(0)" class="int">0</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="456872">arg1</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456869" title="Types.this.Type">arg</a><span class="delimiter">)</span>
        <a href="#133450" title="(x$1: Int)Unit">variance</a> = <a href="#456871" title="Int">v</a>
        <a href="#456872" title="Types.this.Type">arg1</a>
      <span class="delimiter">}</span>

    <span class="comment">/** Map this function over given scope */</span>
    <span class="keyword">def</span> <a title="(scope: Types.this.Scope)Types.this.Scope" id="133460">mapOver</a><span class="delimiter">(</span><a title="Types.this.Scope" id="133515">scope</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a><span class="delimiter">)</span>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="456873">elems</a> = <a href="#133515" title="Types.this.Scope">scope</a>.<a href="Scopes.scala.html#113097" title="=&gt; List[Types.this.Symbol]">toList</a>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="456874">elems1</a> = <a href="#133461" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#456873" title="List[Types.this.Symbol]">elems</a><span class="delimiter">)</span>
      <span title="Types.this.Scope" class="keyword">if</span> <span class="delimiter">(</span><a href="#456874" title="List[Types.this.Symbol]">elems1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456873" title="List[Types.this.Symbol]">elems</a><span class="delimiter">)</span> <a href="#133515" title="Types.this.Scope">scope</a>
      <span class="keyword">else</span> <a href="Scopes.scala.html#113081" title="(decls: List[Types.this.Symbol])Types.this.Scope" class="keyword">new</a> <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a><span class="delimiter">(</span><a href="#456874" title="List[Types.this.Symbol]">elems1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Map this function over given list of symbols */</span>
    <span class="keyword">def</span> <a title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]" id="133461">mapOver</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="133512">origSyms</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span> 
      <span class="keyword">val</span> <a title="Boolean" id="456885">change</a> = <a href="#133512" title="List[Types.this.Symbol]">origSyms</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="456892">sym</a> =&gt;
        <span class="keyword">val</span> <a title="Int" id="456893">v</a> = <a href="#133450" title="=&gt; Int">variance</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#456892" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <a href="#133450" title="(x$1: Int)Unit">variance</a> = <span title="Int(0)" class="int">0</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="456894">result</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456892" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span>
        <a href="#133450" title="(x$1: Int)Unit">variance</a> = <a href="#456893" title="Int">v</a>
        <a href="#456894" title="Types.this.Type">result</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#456892" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>
      <span class="delimiter">}</span>
      <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#456885" title="Boolean">change</a><span class="delimiter">)</span> <a href="#133512" title="List[Types.this.Symbol]">origSyms</a> <span class="comment">// fast path in case nothing changes due to map</span>
      <span class="keyword">else</span> <span class="delimiter">{</span> <span class="comment">// map is not the identity --&gt; do cloning properly</span>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="456895">clonedSyms</a> = <a href="#133512" title="List[Types.this.Symbol]">origSyms</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <span class="delimiter">(</span><a href="#456914" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107594" title="=&gt; Types.this.Symbol">cloneSymbol</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="456896">clonedInfos</a> = <a href="#456895" title="List[Types.this.Symbol]">clonedSyms</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#456961" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#133512" title="List[Types.this.Symbol]">origSyms</a>, <a href="#456895" title="List[Types.this.Symbol]">clonedSyms</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="456897">transformedInfos</a> = <a href="#456896" title="List[Types.this.Type]">clonedInfos</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a href="#67514" title="Types.this.TypeMap" class="keyword">this</a><span class="delimiter">)</span>
        <span title="(_1: List[Types.this.Symbol], _2: List[Types.this.Type])(List[Types.this.Symbol], List[Types.this.Type])" class="delimiter">(</span><a href="#456895" title="List[Types.this.Symbol]">clonedSyms</a>, <a href="#456897" title="List[Types.this.Type]">transformedInfos</a><span class="delimiter">)</span>.<span title="(implicit w1: List[Types.this.Symbol] =&gt; scala.collection.TraversableLike[Types.this.Symbol,List[Types.this.Symbol]], implicit w2: List[Types.this.Type] =&gt; scala.collection.IterableLike[Types.this.Type,List[Types.this.Type]])(List[Types.this.Symbol], List[Types.this.Type])#Zipped[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Type],Types.this.Type]">zipped</span> <span title="(f: (Types.this.Symbol, Types.this.Type) =&gt; Types.this.Symbol)(implicit cbf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <span class="delimiter">(</span><a href="#457049" title="Types.this.Symbol">_</a> <a href="Symbols.scala.html#107566" title="(info: Types.this.Type)x$66.type">setInfo</a> <a href="#457050" title="Types.this.Type">_</a><span class="delimiter">)</span>
        
        <a href="#456895" title="List[Types.this.Symbol]">clonedSyms</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>


    <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])List[Types.this.AnnotationInfo]" id="133462">mapOverAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="456826">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>
    : <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="457082">newAnnots</a> = <a href="#456826" title="List[Types.this.AnnotationInfo]">annots</a>.<span title="(f: Types.this.AnnotationInfo =&gt; scala.collection.GenTraversableOnce[Types.this.AnnotationInfo])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.AnnotationInfo],Types.this.AnnotationInfo,List[Types.this.AnnotationInfo]])List[Types.this.AnnotationInfo]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.AnnotationInfo,List[Types.this.AnnotationInfo]]" class="delimiter">(</span><a href="#133463" title="(annot: Types.this.AnnotationInfo)Option[Types.this.AnnotationInfo]">mapOver</a><span title="(xo: Option[Types.this.AnnotationInfo])Iterable[Types.this.AnnotationInfo]" class="delimiter">(</span><a href="#457099" title="Types.this.AnnotationInfo">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="List[Types.this.AnnotationInfo]" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="(l1: List[Types.this.AnnotationInfo], l2: List[Types.this.AnnotationInfo])Boolean">allEq</a><span class="delimiter">(</span><a href="#457082" title="List[Types.this.AnnotationInfo]">newAnnots</a>, <a href="#456826" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#456826" title="List[Types.this.AnnotationInfo]">annots</a>
      <span class="keyword">else</span>
        <a href="#457082" title="List[Types.this.AnnotationInfo]">newAnnots</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(annot: Types.this.AnnotationInfo)Option[Types.this.AnnotationInfo]" id="133463">mapOver</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="133484">annot</a>: <a href="AnnotationInfos.scala.html#67754" title="Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span>: <span title="Option[Types.this.AnnotationInfo]">Option</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> AnnotationInfo<a href="#457325" title="(Types.this.Type, List[Types.this.Tree], List[(Types.this.Name, Types.this.ClassfileAnnotArg)])" class="delimiter">(</a><a href="#457324" title="Types.this.Type" id="457325">atp</a>, <a href="#457324" title="List[Types.this.Tree]" id="457326">args</a>, <a href="#457324" title="List[(Types.this.Name, Types.this.ClassfileAnnotArg)]" id="457327">assocs</a><span class="delimiter">)</span> = <a href="#133484" title="Types.this.AnnotationInfo">annot</a>

      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133452" title="=&gt; Boolean">dropNonConstraintAnnotations</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
          <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#457325" title="Types.this.Type">atp</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#107588" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="Definitions.scala.html#106342" title="=&gt; Types.this.Symbol">TypeConstraintClass</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">return</span> <span title="object None">None</span>

      <span class="keyword">val</span> <a title="Types.this.Type" id="457328">atp1</a> = <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#457325" title="Types.this.Type">atp</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Tree]" id="457329">args1</a> = <a href="#133464" title="(args: List[Types.this.Tree])List[Types.this.Tree]">mapOverAnnotArgs</a><span class="delimiter">(</span><a href="#457326" title="List[Types.this.Tree]">args</a><span class="delimiter">)</span>
      <span class="comment">// there is no need to rewrite assocs, as they are constants</span>

      <span title="Option[Types.this.AnnotationInfo]" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#457326" title="List[Types.this.Tree]">args</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#457329" title="List[Types.this.Tree]">args1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#457325" title="Types.this.Type">atp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#457328" title="Types.this.Type">atp1</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="(x: Types.this.AnnotationInfo)Some[Types.this.AnnotationInfo]">Some</span><span class="delimiter">(</span><a href="#133484" title="Types.this.AnnotationInfo">annot</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Option[Types.this.AnnotationInfo]" class="keyword">if</span> <span class="delimiter">(</span><a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#457329" title="List[Types.this.Tree]">args1</a>, <a href="#457326" title="List[Types.this.Tree]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="(x: Types.this.AnnotationInfo)Some[Types.this.AnnotationInfo]">Some</span><span class="delimiter">(</span><a href="AnnotationInfos.scala.html#134310" title="(atp: Types.this.Type, args: List[Types.this.Tree], assocs: List[(Types.this.Name, Types.this.ClassfileAnnotArg)])Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">(</span><a href="#457328" title="Types.this.Type">atp1</a>, <a href="#457329" title="List[Types.this.Tree]">args1</a>, <a href="#457327" title="List[(Types.this.Name, Types.this.ClassfileAnnotArg)]">assocs</a><span class="delimiter">)</span>.<a href="AnnotationInfos.scala.html#133502" title="(pos: scala.tools.nsc.util.Position)Types.this.AnnotationInfo">setPos</a><span class="delimiter">(</span><a href="#133484" title="Types.this.AnnotationInfo">annot</a>.<a href="AnnotationInfos.scala.html#133501" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <span title="object None">None</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Map over a set of annotation arguments.  If any
     *  of the arguments cannot be mapped, then return Nil.  */</span>
    <span class="keyword">def</span> <a title="(args: List[Types.this.Tree])List[Types.this.Tree]" id="133464">mapOverAnnotArgs</a><span class="delimiter">(</span><a title="List[Types.this.Tree]" id="457374">args</a>: <span title="List[Types.this.Tree]">List</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Tree]">List</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Tree]" id="457384">args1</a> = <a href="#457374" title="List[Types.this.Tree]">args</a> <span title="(f: Types.this.Tree =&gt; scala.collection.GenTraversableOnce[Types.this.Tree])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Tree],Types.this.Tree,List[Types.this.Tree]])List[Types.this.Tree]">flatMap</span> <span class="delimiter">(</span><a title="Types.this.Tree" id="457401">x</a> =&gt; <a href="#133465" title="(tree: Types.this.Tree)Option[Types.this.Tree]">mapOver</a><span title="(xo: Option[Types.this.Tree])Iterable[Types.this.Tree]" class="delimiter">(</span><a href="#457401" title="Types.this.Tree">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="List[Types.this.Tree]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#457384" title="List[Types.this.Tree]">args1</a>, <a href="#457374" title="List[Types.this.Tree]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="object Nil">Nil</span>
      <span class="keyword">else</span> <span title="List[Types.this.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="(l1: List[Types.this.Tree], l2: List[Types.this.Tree])Boolean">allEq</a><span class="delimiter">(</span><a href="#457374" title="List[Types.this.Tree]">args</a>, <a href="#457384" title="List[Types.this.Tree]">args1</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#457374" title="List[Types.this.Tree]">args</a>
      <span class="keyword">else</span>
        <a href="#457384" title="List[Types.this.Tree]">args1</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Option[Types.this.Tree]" id="133465">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="133481">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Option[Types.this.Tree]">Option</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span> =
      <span title="(x: Types.this.Tree)Some[Types.this.Tree]">Some</span><span class="delimiter">(</span><a href="#133466" title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree">mapOver</a><span class="delimiter">(</span><a href="#133481" title="Types.this.Tree">tree</a>, <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;<span title="Nothing" class="keyword">return</span> <span title="object None">None</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">/** Map a tree that is part of an annotation argument.
     *  If the tree cannot be mapped, then invoke giveup().
     *  The default is to transform the tree with
     *  TypeMapTransformer.
     */</span>
    <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="133466">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="133476">tree</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="133477">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = 
      <span class="delimiter">(</span><span title="TypeMap.this.TypeMapTransformer" class="keyword">new</span> <a href="#133467" title="TypeMap.this.TypeMapTransformer">TypeMapTransformer</a><span class="delimiter">)</span>.<a href="#457639" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#133476" title="Types.this.Tree">tree</a><span class="delimiter">)</span>

    <span class="comment">/** This transformer leaves the tree alone except to remap
     *  its types. */</span>
    <span class="keyword">class</span> <a title="class TypeMapTransformer extends Types.this.Transformer with ScalaObject" id="133467">TypeMapTransformer</a> <a href="#133467" title="ScalaObject" class="keyword">extends</a> <a href="../ast/Trees.scala.html#67836" title="Types.this.Transformer">Transformer</a> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="457639">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="457641">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Tree" id="457645">tree1</a> = <a href="#133467" title="TypeMap.this.TypeMapTransformer" class="keyword">super</a>.<a href="../ast/Trees.scala.html#162576" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#457641" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="457646">tpe1</a> = <a href="#67514" title="(v1: Types.this.Type)Types.this.Type">TypeMap</a>.<span class="keyword">this</span><span class="delimiter">(</span><a href="#457645" title="Types.this.Tree">tree1</a>.<span title="=&gt; Types.this.Type">tpe</span><span class="delimiter">)</span>
        <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#457641" title="Types.this.Tree">tree</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#457645" title="Types.this.Tree">tree1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#457641" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Type">tpe</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#457646" title="Types.this.Type">tpe1</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#457641" title="Types.this.Tree">tree</a>
        <span class="keyword">else</span>
          <a href="../ast/Trees.scala.html#67788" title="implicit scala.tools.nsc.ast.Trees.treeWrapper : (tree: Types.this.Tree)Types.this.TreeOps">tree1</a>.<a href="../ast/Trees.scala.html#109182" title="=&gt; Types.this.Tree">shallowDuplicate</a>.<span title="(tp: Types.this.Type)Types.this.Tree">setType</span><span class="delimiter">(</span><a href="#457646" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A type map that always returns the input type unchanged */</span>
  <span class="keyword">object</span> <a title="object Types.this.IdentityTypeMap" id="67515">IdentityTypeMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="457659">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="457661">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#457661" title="Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeTraverser extends Types.this.TypeMap with ScalaObject" id="67517">TypeTraverser</a> <a href="#67517" title="ScalaObject" class="keyword">extends</a> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449291">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="449669">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Unit">Unit</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="449292">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="457666">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span> <a href="#449291" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#457666" title="Types.this.Type">tp</a><span class="delimiter">)</span>; <a href="#457666" title="Types.this.Type">tp</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeCollector[T] extends Types.this.TypeTraverser with ScalaObject" id="67518">TypeCollector</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67519">T</a><span class="delimiter">]</span><a href="#67518" title="ScalaObject" class="delimiter">(</a><a title="T" id="449302">initial</a>: <a href="#67519" title="T">T</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67517" title="Types.this.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="T" id="449297">result</a>: <a href="#67519" title="T">T</a> = _
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)T" id="449299">collect</a><span class="delimiter">(</span><a title="Types.this.Type" id="449665">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#449297" title="(x$1: T)Unit">result</a> = <a href="#449302" title="T">initial</a>
      <a href="#449291" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#449665" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <a href="#449297" title="=&gt; T">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]" id="67520">emptySymMap</a>   = immutable.<span title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</span><span title="(elems: (Types.this.Symbol, Types.this.Symbol)*)scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span> 
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Int]" id="67522">emptySymCount</a> = immutable.<span title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</span><span title="(elems: (Types.this.Symbol, Int)*)scala.collection.immutable.Map[Types.this.Symbol,Int]" class="delimiter">[</span><a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <span title="Int">Int</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span> 

  <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol, tparams: List[Types.this.Symbol])List[Types.this.Symbol]" id="67524">typeParamsToExistentials</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="425431">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="425432">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="457671">eparams</a> = <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="457742">tparam</a>, <a title="Int" id="457743">i</a><span class="delimiter">)</span> &lt;- <a href="#425432" title="List[Types.this.Symbol]">tparams</a>.<a href="#457715" title="(f: (Types.this.Symbol, Int) =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Symbol, Int)],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">zipWithIndex</a><span class="delimiter">)</span> <span class="keyword">yield</span> <span class="delimiter">{</span>
      <a href="#425431" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107444" title="(pos: Types.this.Position, name: Types.this.TypeName)Types.this.Symbol">newExistential</a><span class="delimiter">(</span><a href="#425431" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107404" title="=&gt; Types.this.Position">pos</a>, <a href="Names.scala.html#66917" title="(s: String)Types.this.TypeName">newTypeName</a><span class="delimiter">(</span><span title="java.lang.String(&quot;?&quot;)" class="string">&quot;?&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#457743" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#107566" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a><span class="delimiter">(</span><a href="#457742" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="457799">tparam</a> &lt;- <a href="#457671" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)Unit">eparams</a><span class="delimiter">)</span> <a href="#457799" title="Types.this.Symbol">tparam</a> <a href="Symbols.scala.html#107566" title="(info: Types.this.Type)tparam.type">setInfo</a> <a href="#457799" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#425432" title="List[Types.this.Symbol]">tparams</a>, <a href="#457671" title="List[Types.this.Symbol]">eparams</a><span class="delimiter">)</span>
    <a href="#457671" title="List[Types.this.Symbol]">eparams</a>
  <span class="delimiter">}</span>
  
  <span class="comment">//  note: it's important to write the two tests in this order,</span>
  <span class="comment">//  as only typeParams forces the classfile to be read. See #400</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="67525">isRawIfWithoutArgs</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="258566">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
    <a href="#258566" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#258566" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#258566" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isJavaDefined</span>

  <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean" id="67526">isRaw</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="258562">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="258563">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = 
    <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67525" title="(sym: Types.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span><a href="#258562" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#258563" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span>
  
  <span class="comment">/** Is type tp a ``raw type''? */</span>
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="67527">isRawType</a><span class="delimiter">(</span><a title="Types.this.Type" id="258557">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#258557" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="258560">sym</a>, <a title="List[Types.this.Type]" id="258561">args</a><span class="delimiter">)</span> =&gt; <a href="#67526" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><span class="delimiter">(</span><a href="#258560" title="Types.this.Symbol">sym</a>, <a href="#258561" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>
      
  <span class="comment">/** The raw to existential map converts a ``raw type'' to an existential type.
   *  It is necessary because we might have read a raw type of a 
   *  parameterized Java class from a class file. At the time we read the type
   *  the corresponding class file might still not be read, so we do not
   *  know what the type parameters of the type are. Therefore
   *  the conversion of raw types to existential types might not have taken place
   *  in ClassFileparser.sigToType (where it is usually done)
   */</span>
  <span class="keyword">object</span> <a title="object Types.this.rawToExistential" id="67528">rawToExistential</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="258572">expanded</a> = immutable.<span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="scala.collection.immutable.Set[Types.this.Type]" id="258575">generated</a> = immutable.<span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.Type*)scala.collection.immutable.Set[Types.this.Type]" class="delimiter">[</span><a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="258577">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="258578">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#258578" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="457810">pre</a>, <a title="Types.this.Symbol" id="457811">sym</a>, <a href="#457813" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#67525" title="(sym: Types.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span><a href="#457811" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#258572" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">expanded</a> <span title="(elem: Types.this.Symbol)Boolean">contains</span> <a href="#457811" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="Definitions.scala.html#106218" title="=&gt; Types.this.Symbol">AnyRefClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
        <span class="keyword">else</span> <span class="keyword">try</span> <span class="delimiter">{</span>
          <a href="#258572" title="(x$1: scala.collection.immutable.Set[Types.this.Symbol])Unit">expanded</a> <span title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">+=</span> <a href="#457811" title="Types.this.Symbol">sym</a>
          <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="457828">eparams</a> = <a href="#133461" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#67524" title="(clazz: Types.this.Symbol, tparams: List[Types.this.Symbol])List[Types.this.Symbol]">typeParamsToExistentials</a><span class="delimiter">(</span><a href="#457811" title="Types.this.Symbol">sym</a>, <a href="#457811" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#67493" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#457828" title="List[Types.this.Symbol]">eparams</a>, <a href="#67483" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#258577" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#457810" title="Types.this.Type">pre</a><span class="delimiter">)</span>, <a href="#457811" title="Types.this.Symbol">sym</a>, <a href="#457828" title="List[Types.this.Symbol]">eparams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#457863" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> 
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
          <a href="#258572" title="(x$1: scala.collection.immutable.Set[Types.this.Symbol])Unit">expanded</a> <span title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">-=</span> <a href="#457811" title="Types.this.Symbol">sym</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#258575" title="=&gt; scala.collection.immutable.Set[Types.this.Type]">generated</a> <span title="(elem: Types.this.Type)Boolean">contains</span> <a href="#258578" title="Types.this.Type">tp</a><span class="delimiter">)</span> =&gt; <span class="comment">// to avoid infinite expansions. todo: not sure whether this is needed</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="457916">result</a> = <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#258578" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <a href="#258575" title="(x$1: scala.collection.immutable.Set[Types.this.Type])Unit">generated</a> <span title="(elem: Types.this.Type)scala.collection.immutable.Set[Types.this.Type]">+=</span> <a href="#457916" title="Types.this.Type">result</a>
        <a href="#457916" title="Types.this.Type">result</a>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#258578" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(hi: Types.this.Type)Types.this.TypeBounds" id="67530">singletonBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="449689">hi</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#67423" title="object Types.this.TypeBounds">TypeBounds</a>.<a href="#148499" title="(hi: Types.this.Type)Types.this.TypeBounds">upper</a><span class="delimiter">(</span><a href="#67488" title="(tps: List[Types.this.Type])Types.this.Type">intersectionType</a><span class="delimiter">(</span><span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#449689" title="Types.this.Type">hi</a>, <a href="Definitions.scala.html#106344" title="=&gt; Types.this.Symbol">SingletonClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to compute the asSeenFrom method  */</span>
  <span class="keyword">class</span> <a title="class AsSeenFromMap extends Types.this.TypeMap with ScalaObject" id="67531">AsSeenFromMap</a><a href="#67531" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="449916">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="449917">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="449904">dropNonConstraintAnnotations</a> = <span title="Boolean(true)" class="keyword">true</span>

    <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="449907">capturedParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span> 

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="449909">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="457954">tree</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="457955">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="object annotationArgRewriter" id="457958">annotationArgRewriter</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#133467" title="AsSeenFromMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>
        <span class="comment">/** Rewrite `This` trees in annotation argument trees */</span>
        <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="457961">rewriteThis</a><span class="delimiter">(</span><a title="Types.this.Tree" id="457964">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> =
          <a href="#457964" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Types.this.Tree">This</span><span class="delimiter">(</span>_<span class="delimiter">)</span>
            <span class="keyword">if</span> <span class="delimiter">(</span><a href="#457964" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span> <a href="Symbols.scala.html#107588" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#449917" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
               <span class="delimiter">(</span><a href="#449916" title="Types.this.Type">pre</a>.<a href="#105458" title="=&gt; Types.this.Type">widen</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#107588" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#457964" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span> =&gt;
              <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#449916" title="Types.this.Type">pre</a>.<a href="#105446" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// XXX why is this in this method? pull it out and guard the call `annotationArgRewriter.transform(tree)`?</span>
                <span class="keyword">val</span> <a title="Types.this.TermSymbol" id="457970">termSym</a> =
                  <a href="#449916" title="Types.this.Type">pre</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#107420" title="(pos: Types.this.Position, name: Types.this.TermName)Types.this.TermSymbol">newValue</a><span class="delimiter">(</span>
                    <a href="#449916" title="Types.this.Type">pre</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107404" title="=&gt; Types.this.Position">pos</a>,
                    <a href="#449916" title="Types.this.Type">pre</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#96598" title="=&gt; Types.this.TermName">toTermName</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107566" title="(info: Types.this.Type)Types.this.TermSymbol">setInfo</a><span class="delimiter">(</span><a href="#449916" title="Types.this.Type">pre</a><span class="delimiter">)</span>  <span class="comment">// what symbol should really be used?</span>
                <a href="../ast/TreeGen.scala.html#105565" title="(tpe: Types.this.gen.global.Type, termSym: Types.this.gen.global.Symbol)Types.this.gen.global.Tree">mkAttributedQualifier</a><span class="delimiter">(</span><a href="#449916" title="Types.this.Type">pre</a>, <a href="#457970" title="Types.this.TermSymbol">termSym</a><span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">else</span>
                <a href="#457955" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span>
            
            <span class="keyword">case</span> <a title="Types.this.Tree" id="457996">tree</a> =&gt; <a href="#457996" title="Types.this.Tree">tree</a>
          <span class="delimiter">}</span>

        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="457962">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="457997">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Tree" id="458000">tree1</a> = <a href="#457961" title="(tree: Types.this.Tree)Types.this.Tree">rewriteThis</a><span class="delimiter">(</span><span class="keyword">super</span>.<a href="#457639" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#457997" title="Types.this.Tree">tree</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#458000" title="Types.this.Tree">tree1</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#457958" title="object annotationArgRewriter">annotationArgRewriter</a>.<a href="#457962" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#457954" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">var</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]" id="449911">capturedPre</a> = <a href="#67520" title="=&gt; scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]">emptySymMap</a>

    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="449913">stabilize</a><span class="delimiter">(</span><a title="Types.this.Type" id="458004">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="458005">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
      <a href="#449911" title="=&gt; scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]">capturedPre</a>.<span title="(key: Types.this.Symbol, default: =&gt; Types.this.Symbol)Types.this.Symbol">getOrElse</span><span class="delimiter">(</span><a href="#458005" title="Types.this.Symbol">clazz</a>, <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="458015">qvar</a> = <a href="#458005" title="Types.this.Symbol">clazz</a> <a href="Symbols.scala.html#107445" title="(suffix: String)Types.this.Symbol">freshExistential</a> <span title="java.lang.String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span> <a href="Symbols.scala.html#107566" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a> <a href="#67530" title="(hi: Types.this.Type)Types.this.TypeBounds">singletonBounds</a><span class="delimiter">(</span><a href="#458004" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <a href="#449911" title="(x$1: scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol])Unit">capturedPre</a> <span title="(kv: (Types.this.Symbol, Types.this.Symbol))scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]">+=</span> <span class="delimiter">(</span><a href="#458005" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">clazz</a> <span title="(y: Types.this.Symbol)(Types.this.Symbol, Types.this.Symbol)">-&gt;</span> <a href="#458015" title="Types.this.Symbol">qvar</a><span class="delimiter">)</span>
          <a href="#449907" title="(x$1: List[Types.this.Symbol])Unit">capturedParams</a> = <a href="#458015" title="Types.this.Symbol">qvar</a> <a href="#458109" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#449907" title="=&gt; List[Types.this.Symbol]">capturedParams</a>
          <a href="#458015" title="Types.this.Symbol">qvar</a>
      <span class="delimiter">}</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>

    <span class="comment">/** Return pre.baseType(clazz), or if that's NoType and clazz is a refinement, pre itself.
     *  See bug397.scala for an example where the second alternative is needed.
     *  The problem is that when forming the base type sequence of an abstract type,
     *  any refinements in the base type list might be regenerated, and thus acquire
     *  new class symbols. However, since refinements always have non-interesting prefixes
     *  it looks OK to me to just take the prefix directly. */</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="449914">base</a><span class="delimiter">(</span><a title="Types.this.Type" id="458118">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="458119">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="458122">b</a> = <a href="#458118" title="Types.this.Type">pre</a>.<a href="#105499" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#458119" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458122" title="Types.this.Type">b</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450913" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#458119" title="Types.this.Symbol">clazz</a>.<span title="=&gt; Boolean">isRefinementClass</span><span class="delimiter">)</span> <a href="#458118" title="Types.this.Type">pre</a>
      <span class="keyword">else</span> <a href="#458122" title="Types.this.Type">b</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="449915">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="449918">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#449916" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#449916" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#449917" title="Types.this.Symbol">clazz</a>.<span title="=&gt; Boolean">isClass</span><span class="delimiter">)</span> <a href="#449918" title="Types.this.Type">tp</a>
      <span class="keyword">else</span> <a href="#449918" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="458127">sym</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="458128">toPrefix</a><span class="delimiter">(</span><a title="Types.this.Type" id="458129">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="458130">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#458129" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#458129" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#458130" title="Types.this.Symbol">clazz</a>.<span title="=&gt; Boolean">isClass</span><span class="delimiter">)</span> <a href="#449918" title="Types.this.Type">tp</a>
            <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#458127" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#107588" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#458130" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
                     <span class="delimiter">(</span><a href="#458129" title="Types.this.Type">pre</a>.<a href="#105458" title="=&gt; Types.this.Type">widen</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#107588" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#458127" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="458134">pre1</a> = <a href="#458129" title="Types.this.Type">pre</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Types.this.Type">SuperType</span><span class="delimiter">(</span><a title="Types.this.Type" id="458135">thistp</a>, _<span class="delimiter">)</span> =&gt; <a href="#458135" title="Types.this.Type">thistp</a>
                <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#458129" title="Types.this.Type">pre</a>
              <span class="delimiter">}</span>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#458134" title="Types.this.Type">pre1</a>.<a href="#105446" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">||</span> 
                    <a href="#458134" title="Types.this.Type">pre1</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isPackageClass</span> <span title="(x: Boolean)Boolean">||</span> 
                    <a href="#458134" title="Types.this.Type">pre1</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isModuleClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#458134" title="Types.this.Type">pre1</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107525" title="=&gt; Boolean">isStatic</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="#449913" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">stabilize</a><span class="delimiter">(</span><a href="#458134" title="Types.this.Type">pre1</a>, <a href="#458127" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                <a href="#458134" title="Types.this.Type">pre1</a>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <a href="#458128" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toPrefix</a><span class="delimiter">(</span><a href="#449914" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">base</a><span class="delimiter">(</span><a href="#458129" title="Types.this.Type">pre</a>, <a href="#458130" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>.<a href="#105464" title="=&gt; Types.this.Type">prefix</a>, <a href="#458130" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
          <a href="#458128" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toPrefix</a><span class="delimiter">(</span><a href="#449916" title="Types.this.Type">pre</a>, <a href="#449917" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="458136">pre</a>, <a title="Types.this.Symbol" id="458137">sym</a><span class="delimiter">)</span> =&gt;
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458137" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span><span class="delimiter">)</span> <a href="#449918" title="Types.this.Type">tp</a> <span class="comment">// short path</span>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="458138">pre1</a> = <a href="#449915" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#458136" title="Types.this.Type">pre</a><span class="delimiter">)</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458138" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#458136" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#449918" title="Types.this.Type">tp</a>
            <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458138" title="Types.this.Type">pre1</a>.<a href="#105446" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#67479" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#458138" title="Types.this.Type">pre1</a>, <a href="#458137" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> 
            <span class="keyword">else</span> <a href="#458138" title="Types.this.Type">pre1</a>.<a href="#105502" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#458137" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#105468" title="=&gt; Types.this.Type">resultType</a> <span class="comment">//todo: this should be rolled into existential abstraction</span>
          <span class="delimiter">}</span>
        <span class="comment">// AM: Martin, is this description accurate?</span>
        <span class="comment">// walk the owner chain of `clazz` (the original argument to asSeenFrom) until we find the type param's owner (while rewriting pre as we crawl up the owner chain)</span>
        <span class="comment">// once we're at the owner, extract the information that pre encodes about the type param,</span>
        <span class="comment">// by minimally subsuming pre to the type instance of the class that owns the type param,</span>
        <span class="comment">// the type we're looking for is the type instance's type argument at the position corresponding to the type parameter</span>
        <span class="comment">// optimisation: skip this type parameter if it's not owned by a class, as those params are not influenced by the prefix through which they are seen</span>
        <span class="comment">// (concretely: type params of anonymous type functions, which currently can only arise from normalising type aliases, are owned by the type alias of which they are the eta-expansion) </span>
        <span class="comment">// (skolems also aren't affected: they are ruled out by the isTypeParameter check)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="458149">prefix</a>, <a title="Types.this.Symbol" id="458150">sym</a>, <a title="List[Types.this.Type]" id="458151">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#458150" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isTypeParameter</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#458150" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>.<span title="=&gt; Boolean">isClass</span><span class="delimiter">)</span> =&gt;
          <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="458152">toInstance</a><span class="delimiter">(</span><a title="Types.this.Type" id="458153">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="458154">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#458153" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#458153" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#458154" title="Types.this.Symbol">clazz</a>.<span title="=&gt; Boolean">isClass</span><span class="delimiter">)</span> <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#449918" title="Types.this.Type">tp</a><span class="delimiter">)</span> 
            <span class="comment">//@M! see test pos/tcpoly_return_overriding.scala why mapOver is necessary</span>
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span class="keyword">def</span> <a title="=&gt; Nothing" id="458163">throwError</a> = <a href="SymbolTable.scala.html#64790" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#449918" title="Types.this.Type">tp</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="#458150" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107659" title="=&gt; java.lang.String">locationString</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; cannot be instantiated from &quot;)" class="string">&quot; cannot be instantiated from &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#458153" title="Types.this.Type">pre</a>.<a href="#105458" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
                                    
              <span class="keyword">def</span> <a title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type" id="458164">instParam</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="458170">ps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="458171">as</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = 
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458170" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#458163" title="=&gt; Nothing">throwError</a>
                <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458150" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#458170" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; Types.this.Symbol">head</span><span class="delimiter">)</span>  
                  <span class="comment">// @M! don't just replace the whole thing, might be followed by type application</span>
                  <a href="#67489" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#458171" title="List[Types.this.Type]">as</a>.<span title="=&gt; Types.this.Type">head</span>, <a href="#458151" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a href="#67531" title="Types.this.AsSeenFromMap" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// @M: was as.head   </span>
                <span class="keyword">else</span> <a href="#458164" title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type">instParam</a><span class="delimiter">(</span><a href="#458170" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>, <a href="#458171" title="List[Types.this.Type]">as</a>.<span title="=&gt; List[Types.this.Type]">tail</span><span class="delimiter">)</span>;
              <span class="keyword">val</span> <a title="Types.this.Symbol" id="458165">symclazz</a> = <a href="#458150" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458165" title="Types.this.Symbol">symclazz</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#458154" title="Types.this.Symbol">clazz</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#458153" title="Types.this.Type">pre</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#67469" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#458153" title="Types.this.Type">pre</a>.<a href="#105458" title="=&gt; Types.this.Type">widen</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#107588" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#458165" title="Types.this.Symbol">symclazz</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="comment">// have to deconst because it may be a Class[T].</span>
                <a href="#458153" title="Types.this.Type">pre</a>.<a href="#105499" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#458165" title="Types.this.Symbol">symclazz</a><span class="delimiter">)</span>.<a href="#105459" title="=&gt; Types.this.Type">deconst</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
                  <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="458183">basesym</a>, <a title="List[Types.this.Type]" id="458184">baseargs</a><span class="delimiter">)</span> =&gt;
                    <span class="comment">//Console.println(&quot;instantiating &quot; + sym + &quot; from &quot; + basesym + &quot; with &quot; + basesym.typeParams + &quot; and &quot; + baseargs+&quot;, pre = &quot;+pre+&quot;, symclazz = &quot;+symclazz);//DEBUG</span>
                    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#458183" title="Types.this.Symbol">basesym</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#458184" title="List[Types.this.Type]">baseargs</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                      <a href="#458164" title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type">instParam</a><span class="delimiter">(</span><a href="#458183" title="Types.this.Symbol">basesym</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#458184" title="List[Types.this.Type]">baseargs</a><span class="delimiter">)</span>
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                      <span title="Nothing" class="keyword">throw</span> <a href="#313958" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#67669" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span>
                        <span title="java.lang.String(&quot;something is wrong (wrong class file?): &quot;)" class="string">&quot;something is wrong (wrong class file?): &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#458183" title="Types.this.Symbol">basesym</a><span title="(x$1: Any)java.lang.String">+</span> 
                        <span title="java.lang.String(&quot; with type parameters &quot;)" class="string">&quot; with type parameters &quot;</span><span title="(x$1: Any)java.lang.String">+</span>
                        <a href="#458183" title="Types.this.Symbol">basesym</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="(f: Types.this.Symbol =&gt; Types.this.Name)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Name,List[Types.this.Name]])List[Types.this.Name]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.Name,List[Types.this.Name]]" class="delimiter">(</span><a href="#458208" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;[&quot;)" class="string">&quot;[&quot;</span>,<span title="java.lang.String(&quot;,&quot;)" class="string">&quot;,&quot;</span>,<span title="java.lang.String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span><span title="(x$1: Any)java.lang.String">+</span>
                        <span title="java.lang.String(&quot; gets applied to arguments &quot;)" class="string">&quot; gets applied to arguments &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#458184" title="List[Types.this.Type]">baseargs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;[&quot;)" class="string">&quot;[&quot;</span>,<span title="java.lang.String(&quot;,&quot;)" class="string">&quot;,&quot;</span>,<span title="java.lang.String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;, phase = &quot;)" class="string">&quot;, phase = &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a><span class="delimiter">)</span>
                    <span class="delimiter">}</span>
                  <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="458245">tparams</a>, <a title="Types.this.Type" id="458246">qtpe</a><span class="delimiter">)</span> =&gt;
                    <a href="#449907" title="(x$1: List[Types.this.Symbol])Unit">capturedParams</a> = <a href="#449907" title="=&gt; List[Types.this.Symbol]">capturedParams</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">union</span> <a href="#458245" title="List[Types.this.Symbol]">tparams</a>
                    <a href="#458152" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toInstance</a><span class="delimiter">(</span><a href="#458246" title="Types.this.Type">qtpe</a>, <a href="#458154" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
                  <span class="keyword">case</span> <span title="Nothing">_</span> =&gt;
                    <a href="#458163" title="=&gt; Nothing">throwError</a>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#458152" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toInstance</a><span class="delimiter">(</span><a href="#449914" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">base</a><span class="delimiter">(</span><a href="#458153" title="Types.this.Type">pre</a>, <a href="#458154" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>.<a href="#105464" title="=&gt; Types.this.Type">prefix</a>, <a href="#458154" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <a href="#458152" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toInstance</a><span class="delimiter">(</span><a href="#449916" title="Types.this.Type">pre</a>, <a href="#449917" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#449918" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A base class to compute all substitutions */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SubstMap[T] extends Types.this.TypeMap with ScalaObject" id="67532">SubstMap</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67533">T</a><span class="delimiter">]</span><a href="#67532" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="167451">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[T]" id="167452">to</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Types.this.Symbol =&gt; Boolean" id="167442">fromContains</a> = <span class="delimiter">(</span>x: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =&gt; <a href="#167451" title="List[Types.this.Symbol]">from</a>.<span title="(elem: Any)Boolean">contains</span><span class="delimiter">(</span><a href="#167481" title="Types.this.Symbol">x</a><span class="delimiter">)</span> <span class="comment">//from.toSet &lt;-- traversing short lists seems to be faster than allocating sets</span>
    <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#167451" title="List[Types.this.Symbol]">from</a>, <a href="#167452" title="List[T]">to</a><span class="delimiter">)</span>, <span title="java.lang.String(&quot;Unsound substitution from &quot;)" class="string">&quot;Unsound substitution from &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#167451" title="List[Types.this.Symbol]">from</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; to &quot;)" class="string">&quot; to &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#167452" title="List[T]">to</a><span class="delimiter">)</span>

    <span class="comment">/** Are `sym' and `sym1' the same.
     *  Can be tuned by subclasses.
     */</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, sym1: Types.this.Symbol)Boolean" id="167444">matches</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="458317">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="458318">sym1</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#458317" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#458318" title="Types.this.Symbol">sym1</a>

    <span class="comment">/** Map target to type, can be tuned by subclasses */</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(fromtp: Types.this.Type, tp: T)Types.this.Type" id="167445">toType</a><span class="delimiter">(</span><a title="Types.this.Type" id="458320">fromtp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="T" id="458321">tp</a>: <a href="#67533" title="T">T</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a>

    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="167446">renameBoundSyms</a><span class="delimiter">(</span><a title="Types.this.Type" id="458323">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#458323" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="458325">ps</a>, <a title="Types.this.Type" id="458326">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="458327">ps1</a> = <a href="Symbols.scala.html#67341" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#458325" title="List[Types.this.Symbol]">ps</a><span class="delimiter">)</span>
        <a href="#67486" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#458323" title="Types.this.Type">tp</a>, <a href="#458327" title="List[Types.this.Symbol]">ps1</a>, <a href="#167446" title="(tp: Types.this.Type)Types.this.Type">renameBoundSyms</a><span class="delimiter">(</span><a href="#458326" title="Types.this.Type">restp</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#458325" title="List[Types.this.Symbol]">ps</a>, <a href="#458327" title="List[Types.this.Symbol]">ps1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.PolyType">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="458362">bs</a>, <a title="Types.this.Type" id="458363">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="458364">bs1</a> = <a href="Symbols.scala.html#67341" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#458362" title="List[Types.this.Symbol]">bs</a><span class="delimiter">)</span>
        <a href="#148921" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#458364" title="List[Types.this.Symbol]">bs1</a>, <a href="#167446" title="(tp: Types.this.Type)Types.this.Type">renameBoundSyms</a><span class="delimiter">(</span><a href="#458363" title="Types.this.Type">restp</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#458362" title="List[Types.this.Symbol]">bs</a>, <a href="#458364" title="List[Types.this.Symbol]">bs1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.ExistentialType">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="458399">bs</a>, <a title="Types.this.Type" id="458400">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="458401">bs1</a> = <a href="Symbols.scala.html#67341" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#458399" title="List[Types.this.Symbol]">bs</a><span class="delimiter">)</span>
        <a href="#149138" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">ExistentialType</a><span class="delimiter">(</span><a href="#458401" title="List[Types.this.Symbol]">bs1</a>, <a href="#458400" title="Types.this.Type">restp</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#458399" title="List[Types.this.Symbol]">bs</a>, <a href="#458401" title="List[Types.this.Symbol]">bs1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#458323" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp0: Types.this.Type)Types.this.Type" id="167447">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="167490">tp0</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#167451" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#167490" title="Types.this.Type">tp0</a> <span class="keyword">else</span> <span class="delimiter">{</span>
      @tailrec <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type" id="458436">subst</a><span class="delimiter">(</span><a title="Types.this.Type" id="458440">tp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="458441">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="458442">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[T]" id="458443">to</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458442" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#458440" title="Types.this.Type">tp</a>
        <span class="comment">// else if (to.isEmpty) error(&quot;Unexpected substitution on '%s': from = %s but to == Nil&quot;.format(tp, from))</span>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#167444" title="(sym: Types.this.Symbol, sym1: Types.this.Symbol)Boolean">matches</a><span class="delimiter">(</span><a href="#458442" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Types.this.Symbol">head</span>, <a href="#458441" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#167445" title="(fromtp: Types.this.Type, tp: T)Types.this.Type">toType</a><span class="delimiter">(</span><a href="#458440" title="Types.this.Type">tp</a>, <a href="#458443" title="List[T]">to</a>.<span title="=&gt; T">head</span><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#458436" title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#458440" title="Types.this.Type">tp</a>, <a href="#458441" title="Types.this.Symbol">sym</a>, <a href="#458442" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>, <a href="#458443" title="List[T]">to</a>.<span title="=&gt; List[T]">tail</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="458437">boundSyms</a> = <a href="#167490" title="Types.this.Type">tp0</a>.<a href="#105478" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="458438">tp1</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458437" title="scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <a href="#167442" title="=&gt; Types.this.Symbol =&gt; Boolean">fromContains</a><span class="delimiter">)</span> <a href="#167446" title="(tp: Types.this.Type)Types.this.Type">renameBoundSyms</a><span class="delimiter">(</span><a href="#167490" title="Types.this.Type">tp0</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#167490" title="Types.this.Type">tp0</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="458439">tp</a> = <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#458438" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
      
      <a href="#458439" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="comment">// @M </span>
        <span class="comment">// 1) arguments must also be substituted (even when the &quot;head&quot; of the </span>
        <span class="comment">// applied type has already been substituted)</span>
        <span class="comment">// example: (subst RBound[RT] from [type RT,type RBound] to </span>
        <span class="comment">// [type RT&amp;,type RBound&amp;]) = RBound&amp;[RT&amp;]</span>
        <span class="comment">// 2) avoid loops (which occur because alpha-conversion is </span>
        <span class="comment">// not performed properly imo)</span>
        <span class="comment">// e.g. if in class Iterable[a] there is a new Iterable[(a,b)], </span>
        <span class="comment">// we must replace the a in Iterable[a] by (a,b)</span>
        <span class="comment">// (must not recurse --&gt; loops)</span>
        <span class="comment">// 3) replacing m by List in m[Int] should yield List[Int], not just List</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="458454">sym</a>, <a title="List[Types.this.Type]" id="458455">args</a><span class="delimiter">)</span> =&gt;
          <a href="#67489" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#458436" title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#458439" title="Types.this.Type">tp</a>, <a href="#458454" title="Types.this.Symbol">sym</a>, <a href="#167451" title="List[Types.this.Symbol]">from</a>, <a href="#167452" title="List[T]">to</a><span class="delimiter">)</span>, <a href="#458455" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="comment">// if args.isEmpty, appliedType is the identity</span>
        <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="458456">sym</a><span class="delimiter">)</span> =&gt;
          <a href="#458436" title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#458439" title="Types.this.Type">tp</a>, <a href="#458456" title="Types.this.Symbol">sym</a>, <a href="#167451" title="List[Types.this.Symbol]">from</a>, <a href="#167452" title="List[T]">to</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#458439" title="Types.this.Type">tp</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `substSym' method. */</span>
  <span class="keyword">class</span> <a title="class SubstSymMap extends Types.this.SubstMap[Types.this.Symbol] with ScalaObject" id="67534">SubstSymMap</a><a href="#67534" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="167579">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="167580">to</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67532" title="Types.this.SubstMap[Types.this.Symbol]">SubstMap</a><span class="delimiter">(</span><a href="#167579" title="List[Types.this.Symbol]">from</a>, <a href="#167580" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(fromtp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="167576">toType</a><span class="delimiter">(</span><a title="Types.this.Type" id="458478">fromtp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="458479">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#458478" title="Types.this.Type">fromtp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="458484">pre</a>, _, <a title="List[Types.this.Type]" id="458485">args</a><span class="delimiter">)</span> =&gt; <a href="#67484" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#458478" title="Types.this.Type">fromtp</a>, <a href="#458484" title="Types.this.Type">pre</a>, <a href="#458479" title="Types.this.Symbol">sym</a>, <a href="#458485" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="458486">pre</a>, _<span class="delimiter">)</span> =&gt; <a href="#67479" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#458486" title="Types.this.Type">pre</a>, <a href="#458479" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="167577">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="167590">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#167579" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#167590" title="Types.this.Type">tp</a> <span class="keyword">else</span> <span class="delimiter">{</span>
      @tailrec <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol" id="458487">subst</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="458488">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="458489">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="458490">to</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> =
        <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#458489" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#458488" title="Types.this.Symbol">sym</a>
        <span class="comment">// else if (to.isEmpty) error(&quot;Unexpected substitution on '%s': from = %s but to == Nil&quot;.format(sym, from))</span>
        <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#167444" title="(sym: Types.this.Symbol, sym1: Types.this.Symbol)Boolean">matches</a><span class="delimiter">(</span><a href="#458489" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Types.this.Symbol">head</span>, <a href="#458488" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#458490" title="List[Types.this.Symbol]">to</a>.<span title="=&gt; Types.this.Symbol">head</span>
        <span class="keyword">else</span> <a href="#458487" title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol">subst</a><span class="delimiter">(</span><a href="#458488" title="Types.this.Symbol">sym</a>, <a href="#458489" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>, <a href="#458490" title="List[Types.this.Symbol]">to</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span><span class="delimiter">)</span>
      <a href="#167590" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="458491">pre</a>, <a title="Types.this.Symbol" id="458492">sym</a>, <a title="List[Types.this.Type]" id="458493">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#458491" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="458494">newSym</a> = <a href="#458487" title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol">subst</a><span class="delimiter">(</span><a href="#458492" title="Types.this.Symbol">sym</a>, <a href="#167579" title="List[Types.this.Symbol]">from</a>, <a href="#167580" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span>
          <span class="comment">// assert(newSym.typeParams.length == sym.typeParams.length, &quot;typars mismatch in SubstSymMap: &quot;+(sym, sym.typeParams, newSym, newSym.typeParams))</span>
          <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#67484" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#167590" title="Types.this.Type">tp</a>, <a href="#458491" title="Types.this.Type">pre</a>, <a href="#458494" title="Types.this.Symbol">newSym</a>, <a href="#458493" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// mapOver takes care of subst'ing in args</span>
        <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="458507">pre</a>, <a title="Types.this.Symbol" id="458508">sym</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#458507" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a> =&gt;
          <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#67479" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#458507" title="Types.this.Type">pre</a>, <a href="#458487" title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol">subst</a><span class="delimiter">(</span><a href="#458508" title="Types.this.Symbol">sym</a>, <a href="#167579" title="List[Types.this.Symbol]">from</a>, <a href="#167580" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#67534" title="Types.this.SubstSymMap" class="keyword">super</a>.<a href="#167447" title="(tp0: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#167590" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>


    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="167578">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="458495">tree</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="458496">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="object trans" id="458519">trans</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#133467" title="SubstSymMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>

        <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Option[Types.this.Symbol]" id="458522">termMapsTo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="458525">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
          <span title="Option[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#167442" title="(v1: Types.this.Symbol)Boolean">fromContains</a><span class="delimiter">(</span><a href="#458525" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</span><span class="delimiter">(</span><a href="#167580" title="(n: Int)Types.this.Symbol">to</a><span class="delimiter">(</span><a href="#167579" title="List[Types.this.Symbol]">from</a>.<span title="(elem: Types.this.Symbol)Int">indexOf</span><span class="delimiter">(</span><a href="#458525" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">else</span>
            <span title="object None">None</span>

        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="458523">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="458565">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = 
          <a href="#458565" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a title="Types.this.Tree" id="458570">tree</a>@Ident<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
              <a href="#458522" title="(sym: Types.this.Symbol)Option[Types.this.Symbol]">termMapsTo</a><span class="delimiter">(</span><a href="#458570" title="Types.this.Ident">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Types.this.Tree">Some</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="458575">tosym</a><span class="delimiter">)</span> =&gt;
                  <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#458575" title="Types.this.Symbol">tosym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#107589" title="(that: Types.this.Symbol)Boolean">isSubClass</a> <a href="Definitions.scala.html#106344" title="=&gt; Types.this.Symbol">SingletonClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#24037" title="(name: Types.this.Name)Types.this.Ident">Ident</a><span class="delimiter">(</span><a href="#458575" title="Types.this.Symbol">tosym</a>.<a href="#24037" title="implicit scala.reflect.generic.StdNames.stringToTermName : (s: String)Types.this.TermName">existentialToString</a><span class="delimiter">)</span>
                      .<span title="(sym: Types.this.Symbol)Types.this.Ident">setSymbol</span><span class="delimiter">(</span><a href="#458575" title="Types.this.Symbol">tosym</a><span class="delimiter">)</span>
                      .<span title="(pos: scala.tools.nsc.util.Position)Types.this.Ident">setPos</span><span class="delimiter">(</span><a href="#458575" title="Types.this.Symbol">tosym</a>.<a href="Symbols.scala.html#107404" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>
                      .<span title="(tp: Types.this.Type)Types.this.Ident">setType</span><span class="delimiter">(</span><a href="#447272" title="(tp: Types.this.Type)Types.this.Type">dropSingletonType</a><span class="delimiter">(</span><a href="#458575" title="Types.this.Symbol">tosym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                    <a href="#458496" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span>
                  <span class="delimiter">}</span>
                <span class="keyword">case</span> <a title="Types.this.Tree" id="458604">none</a> =&gt; <span class="keyword">super</span>.<a href="#457639" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#458570" title="Types.this.Ident">tree</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="keyword">case</span> <a title="Types.this.Tree" id="458607">tree</a> =&gt; <span class="keyword">super</span>.<a href="#457639" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#458607" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#458519" title="object trans">trans</a>.<a href="#458523" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#458495" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `subst' method. */</span>
  <span class="keyword">class</span> <a title="class SubstTypeMap extends Types.this.SubstMap[Types.this.Type] with ScalaObject" id="67535">SubstTypeMap</a><a href="#67535" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="167473">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="167474">to</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="#67532" title="Types.this.SubstMap[Types.this.Type]">SubstMap</a><span class="delimiter">(</span><a href="#167473" title="List[Types.this.Symbol]">from</a>, <a href="#167474" title="List[Types.this.Type]">to</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(fromtp: Types.this.Type, tp: Types.this.Type)Types.this.Type" id="167471">toType</a><span class="delimiter">(</span><a title="Types.this.Type" id="458631">fromtp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="458632">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#458632" title="Types.this.Type">tp</a> 

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="167472">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="454454">tree</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="454455">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="object trans" id="458637">trans</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#133467" title="SubstTypeMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="458640">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="458642">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = 
          <a href="#458642" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Types.this.Tree">Ident</span><span class="delimiter">(</span><a title="Types.this.Name" id="458649">name</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#167442" title="(v1: Types.this.Symbol)Boolean">fromContains</a><span class="delimiter">(</span><a href="#458642" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span> =&gt;
              <span class="keyword">val</span> <a title="Types.this.Type" id="458651">totpe</a> = <a href="#167474" title="(n: Int)Types.this.Type">to</a><span class="delimiter">(</span><a href="#167473" title="List[Types.this.Symbol]">from</a>.<span title="(elem: Types.this.Symbol)Int">indexOf</span><span class="delimiter">(</span><a href="#458642" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#458651" title="Types.this.Type">totpe</a>.<a href="#105446" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#454455" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <a href="#24037" title="(name: Types.this.Name)Types.this.Ident">Ident</a><span class="delimiter">(</span><a href="#458649" title="Types.this.Name">name</a><span class="delimiter">)</span>.<span title="(pos: scala.tools.nsc.util.Position)Types.this.Ident">setPos</span><span class="delimiter">(</span><a href="#458642" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Position">pos</span><span class="delimiter">)</span>.<span title="(sym: Types.this.Symbol)Types.this.Ident">setSymbol</span><span class="delimiter">(</span><a href="#458642" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span>.<span title="(tp: Types.this.Type)Types.this.Ident">setType</span><span class="delimiter">(</span><a href="#458651" title="Types.this.Type">totpe</a><span class="delimiter">)</span>

            <span class="keyword">case</span> <span title="Types.this.Tree">_</span> =&gt; <span class="keyword">super</span>.<a href="#457639" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#458642" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#458637" title="object trans">trans</a>.<a href="#458640" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#454454" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `substThis' method. */</span>
  <span class="keyword">class</span> <a title="class SubstThisMap extends Types.this.TypeMap with ScalaObject" id="67536">SubstThisMap</a><a href="#67536" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="449938">from</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="449939">to</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="449937">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="449941">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#449941" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="458693">sym</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#458693" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#449938" title="Types.this.Symbol">from</a><span class="delimiter">)</span> =&gt; <a href="#449939" title="Types.this.Type">to</a>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#449941" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class SubstSuperMap extends Types.this.TypeMap with ScalaObject" id="67537">SubstSuperMap</a><a href="#67537" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="449954">from</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="449955">to</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="449953">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="449957">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#449957" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#449954" title="Types.this.Type">from</a><span class="delimiter">)</span> <a href="#449955" title="Types.this.Type">to</a> <span class="keyword">else</span> <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#449957" title="Types.this.Type">tp</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class SubstWildcardMap extends Types.this.TypeMap with ScalaObject" id="67538">SubstWildcardMap</a><a href="#67538" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="458723">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span> 
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="458720">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="458724">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
      <a href="#458724" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.BoundedWildcardType">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="458727">sym</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#458723" title="List[Types.this.Symbol]">from</a> <span title="(elem: Any)Boolean">contains</span> <a href="#458727" title="Types.this.Symbol">sym</a> =&gt;
          <a href="#258485" title="(bounds: Types.this.TypeBounds)Types.this.BoundedWildcardType">BoundedWildcardType</a><span class="delimiter">(</span><a href="#458727" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; 
          <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#458724" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Types.this.WildcardType.type" id="458737">ex</a>: <a href="#67671" title="Types.this.MalformedType">MalformedType</a> =&gt;
        <a href="#450864" title="object Types.this.WildcardType">WildcardType</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="comment">// dependent method types</span>
  <span class="keyword">object</span> <a title="object Types.this.IsDependentCollector" id="67539">IsDependentCollector</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67518" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449664">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="458747">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#458747" title="Types.this.Type">tp</a> <a href="#105450" title="=&gt; Boolean">isImmediatelyDependent</a><span class="delimiter">)</span> <a href="#449297" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#449297" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#458747" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.ApproximateDependentMap" id="67541">ApproximateDependentMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="449764">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="449765">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = 
      <span title="Types.this.Type" class="keyword">if</span><span class="delimiter">(</span><a href="#449765" title="Types.this.Type">tp</a> <a href="#105450" title="=&gt; Boolean">isImmediatelyDependent</a><span class="delimiter">)</span> <a href="#450864" title="object Types.this.WildcardType">WildcardType</a>
      <span class="keyword">else</span> <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#449765" title="Types.this.Type">tp</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class InstantiateDependentMap extends Types.this.TypeMap with ScalaObject" id="67543">InstantiateDependentMap</a><a href="#67543" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="262130">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="262131">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.IndexedSeq[Types.this.Type]" id="262117">actualsIndexed</a> = <a href="#262131" title="List[Types.this.Type]">actuals</a>.<span title="scala.collection.immutable.IndexedSeq[Types.this.Type]">toIndexedSeq</span>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="262119">dropNonConstraintAnnotations</a> = <span title="Boolean(true)" class="keyword">true</span>

    <span class="keyword">object</span> <a title="object InstantiateDependentMap.this.ParamWithActual" id="262121">ParamWithActual</a> <span title="ScalaObject" class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Option[Types.this.Type]" id="458778">unapply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="458780">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Option[Types.this.Type]">Option</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Int" id="458782">pid</a> = <a href="#262130" title="List[Types.this.Symbol]">params</a> <span title="(elem: Types.this.Symbol)Int">indexOf</span> <a href="#458780" title="Types.this.Symbol">sym</a>
        <span title="Option[Types.this.Type]" class="keyword">if</span><span class="delimiter">(</span><a href="#458782" title="Int">pid</a> <span title="(x: Int)Boolean">!=</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#262117" title="(idx: Int)Types.this.Type">actualsIndexed</a><span class="delimiter">(</span><a href="#458782" title="Int">pid</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="object None">None</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="262123">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="262133">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
      <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#262133" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="#458778" title="(sym: Types.this.Symbol)Option[Types.this.Type]">ParamWithActual</a><span class="delimiter">(</span><a title="Types.this.Type" id="458835">arg</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#458835" title="Types.this.Type">arg</a>.<a href="#105446" title="=&gt; Boolean">isStable</a> =&gt; <a href="#458835" title="Types.this.Type">arg</a> <span class="comment">// unsound to replace args by unstable actual #3873</span>
        <span class="comment">// (soundly) expand type alias selections on implicit arguments, see depmet_implicit_oopsla* test cases -- typically, `param.isImplicit`</span>
        <span class="keyword">case</span> <a title="Types.this.Type" id="458836">tp1</a>@TypeRef<span class="delimiter">(</span>SingleType<span class="delimiter">(</span><a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="#458778" title="(sym: Types.this.Symbol)Option[Types.this.Type]">ParamWithActual</a><span class="delimiter">(</span><a title="Types.this.Type" id="458838">arg</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a title="Types.this.Symbol" id="458839">sym</a>, <a title="List[Types.this.Type]" id="458840">targs</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="458841">res</a> = <a href="#67483" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#458838" title="Types.this.Type">arg</a>, <a href="#458839" title="Types.this.Symbol">sym</a>, <a href="#458840" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span><span class="delimiter">(</span><a href="#458841" title="Types.this.Type">res</a>.<a href="#105456" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <a href="#458841" title="Types.this.Type">res</a>.<a href="#105484" title="=&gt; Types.this.Type">dealias</a>
          <span class="keyword">else</span> <a href="#458836" title="Types.this.TypeRef">tp1</a>
        <span class="keyword">case</span> <a title="Types.this.Type" id="458842">tp1</a> =&gt; <a href="#458842" title="Types.this.Type">tp1</a> <span class="comment">// don't return the original `tp`, which may be different from `tp1`, due to `dropNonConstraintAnnotations`</span>
      <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="262124">existentialsNeeded</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#262125" title="(xs: Array[Types.this.Symbol])scala.collection.mutable.ArrayOps[Types.this.Symbol]">existSyms</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Array[Types.this.Symbol]">filter</span><span title="(xs: Array[Types.this.Symbol])scala.collection.mutable.ArrayOps[Types.this.Symbol]" class="delimiter">(</span><a href="#459041" title="Types.this.Symbol">_</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>.<span title="=&gt; List[Types.this.Symbol]">toList</span>

    <span class="keyword">private</span> <span class="keyword">val</span> <a title="Array[Types.this.Symbol]" id="262125">existSyms</a>: <span title="Array[Types.this.Symbol]">Array</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span title="Array[Types.this.Symbol]" class="keyword">new</span> <span title="Array[Types.this.Symbol]">Array</span><span class="delimiter">(</span><a href="#262117" title="=&gt; scala.collection.immutable.IndexedSeq[Types.this.Type]">actualsIndexed</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(i: Int)Boolean" id="262127">haveExistential</a><span class="delimiter">(</span><a title="Int" id="459148">i</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span class="delimiter">{</span><span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#459148" title="Int">i</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#459148" title="Int">i</a> <span title="(x: Int)Boolean">&lt;=</span> <a href="#262117" title="=&gt; scala.collection.immutable.IndexedSeq[Types.this.Type]">actualsIndexed</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span><span class="delimiter">)</span>; <a href="#262125" title="(i: Int)Types.this.Symbol">existSyms</a><span class="delimiter">(</span><a href="#459148" title="Int">i</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">}</span>

    <span class="comment">/* Return the type symbol for referencing a parameter inside the existential quantifier. 
     * (Only needed if the actual is unstable.)
     */</span>
    <span class="keyword">def</span> <a title="(actualIdx: Int)Types.this.Symbol" id="262128">existSymFor</a><span class="delimiter">(</span><a title="Int" id="459161">actualIdx</a>: <span title="Int">Int</span><span class="delimiter">)</span> =
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#262127" title="(i: Int)Boolean">haveExistential</a><span class="delimiter">(</span><a href="#459161" title="Int">actualIdx</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#262125" title="(i: Int)Types.this.Symbol">existSyms</a><span class="delimiter">(</span><a href="#459161" title="Int">actualIdx</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="459164">oldSym</a> = <a href="#262130" title="(n: Int)Types.this.Symbol">params</a><span class="delimiter">(</span><a href="#459161" title="Int">actualIdx</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="459165">symowner</a> = <a href="#459164" title="Types.this.Symbol">oldSym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>
        <span class="keyword">val</span> <a title="Types.this.TypeBounds" id="459166">bound</a> = <a href="#67530" title="(hi: Types.this.Type)Types.this.TypeBounds">singletonBounds</a><span class="delimiter">(</span><a href="#262117" title="(idx: Int)Types.this.Type">actualsIndexed</a><span class="delimiter">(</span><a href="#459161" title="Int">actualIdx</a><span class="delimiter">)</span><span class="delimiter">)</span>

        <span class="keyword">val</span> <a title="Types.this.Symbol" id="459167">sym</a> = <a href="#459165" title="Types.this.Symbol">symowner</a>.<a href="Symbols.scala.html#107444" title="(pos: Types.this.Position, name: Types.this.TypeName)Types.this.Symbol">newExistential</a><span class="delimiter">(</span><a href="#459164" title="Types.this.Symbol">oldSym</a>.<a href="Symbols.scala.html#107404" title="=&gt; Types.this.Position">pos</a>, <a href="Names.scala.html#66917" title="(s: String)Types.this.TypeName">newTypeName</a><span class="delimiter">(</span><a href="#459164" title="Types.this.Symbol">oldSym</a>.<a href="Symbols.scala.html#107548" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">name</a> <span title="(other: String)java.lang.String">+</span> <span title="java.lang.String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#459167" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107566" title="(info: Types.this.Type)sym.type">setInfo</a><span class="delimiter">(</span><a href="#459166" title="Types.this.TypeBounds">bound</a><span class="delimiter">)</span>
        <a href="#459167" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107553" title="(mask: Long)sym.type">setFlag</a><span class="delimiter">(</span><a href="#459164" title="Types.this.Symbol">oldSym</a>.<a href="Symbols.scala.html#107551" title="=&gt; Long">flags</a><span class="delimiter">)</span>

        <a href="#262125" title="(i: Int, x: Types.this.Symbol)Unit">existSyms</a><span class="delimiter">(</span><a href="#459161" title="Int">actualIdx</a><span class="delimiter">)</span> = <a href="#459167" title="Types.this.Symbol">sym</a>
        <a href="#459167" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span>

    <span class="comment">//AM propagate more info to annotations -- this seems a bit ad-hoc... (based on code by spoon)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(arg: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="262129">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="458824">arg</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="458825">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="object treeTrans" id="459193">treeTrans</a> <span title="ScalaObject" class="keyword">extends</span> <a href="../ast/Trees.scala.html#67836" title="Types.this.Transformer">Transformer</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="459196">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="459200">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
          <a href="#459200" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a href="#459204" title="Types.this.Tree">RefParamAt</a><span class="delimiter">(</span><a title="Int" id="459208">pid</a><span class="delimiter">)</span> =&gt;
              <span class="comment">// TODO: this should be simplified; in the stable case, one can probably</span>
              <span class="comment">// just use an Ident to the tree.symbol. Why an existential in the non-stable case?</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="459209">actual</a> = <a href="#262117" title="(idx: Int)Types.this.Type">actualsIndexed</a><span class="delimiter">(</span><a href="#459208" title="Int">pid</a><span class="delimiter">)</span>
              <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#459209" title="Types.this.Type">actual</a>.<a href="#105446" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#459209" title="Types.this.Type">actual</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="../ast/TreeGen.scala.html#105565" title="(tpe: Types.this.gen.global.Type, termSym: Types.this.gen.global.Symbol)Types.this.gen.global.Tree">mkAttributedQualifier</a><span class="delimiter">(</span><a href="#262117" title="(idx: Int)Types.this.Type">actualsIndexed</a><span class="delimiter">(</span><a href="#459208" title="Int">pid</a><span class="delimiter">)</span>, <a href="#459200" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                <span class="keyword">val</span> <a title="Types.this.Symbol" id="459231">sym</a> = <a href="#262128" title="(actualIdx: Int)Types.this.Symbol">existSymFor</a><span class="delimiter">(</span><a href="#459208" title="Int">pid</a><span class="delimiter">)</span>
                <span class="delimiter">(</span><a href="#24037" title="(name: Types.this.Name)Types.this.Ident">Ident</a><span class="delimiter">(</span><a href="#459231" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
                 <span title="(tree: Types.this.Tree)Types.this.Ident">copyAttrs</span> <a href="#459200" title="Types.this.Tree">tree</a>
                 <span title="(tp: Types.this.Type)Types.this.Ident">setType</span> <a href="#67483" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="#459231" title="Types.this.Symbol">sym</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="keyword">case</span> <span title="Types.this.Tree">_</span> =&gt; <span class="keyword">super</span>.<a href="../ast/Trees.scala.html#162576" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#459200" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">object</span> <a title="object scala.tools.nsc.symtab.Types.InstantiateDependentMap.treeTrans.RefParamAt" id="459197">RefParamAt</a> <span title="ScalaObject" class="delimiter">{</span>
          <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Option[Int]" id="459204">unapply</a><span class="delimiter">(</span><a title="Types.this.Tree" id="459205">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Option[Int]">Option</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> = <a href="#459205" title="Types.this.Tree">tree</a> <span title="Option[Int]" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Option[Int]">Ident</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <span title="(x: Int)Some[Int]">Some</span><span class="delimiter">(</span><a href="#262130" title="List[Types.this.Symbol]">params</a> <span title="(elem: Types.this.Symbol)Int">indexOf</span> <a href="#459205" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span> <span title="(p: Int =&gt; Boolean)Option[Int]">filterNot</span> <span class="delimiter">(</span><a href="#459268" title="Int">_</a> <span title="(x: Int)Boolean">==</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="None.type">_</span>        =&gt; <span title="object None">None</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#459193" title="object treeTrans">treeTrans</a>.<a href="#459196" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#458824" title="Types.this.Tree">arg</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  <span class="keyword">object</span> <a title="object Types.this.StripAnnotationsMap" id="67544">StripAnnotationsMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="450673">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="450674">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#450674" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">AnnotatedType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="459275">atp</a>, _<span class="delimiter">)</span> =&gt;
        <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#459275" title="Types.this.Type">atp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="459284">tp</a> =&gt;
        <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#459284" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to convert every occurrence of a wildcard type to a fresh
   *  type variable */</span>
  <span class="keyword">object</span> <a title="object Types.this.wildcardToTypeVarMap" id="67546">wildcardToTypeVarMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="455320">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="455321">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#455321" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#450864" title="Types.this.TypeVar">WildcardType</a> =&gt;
        <a href="#448980" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint)Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#455321" title="Types.this.Type">tp</a>, <a href="#449370" title="()Types.this.TypeConstraint" class="keyword">new</a> <a href="#67513" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.TypeVar">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="459302">bounds</a><span class="delimiter">)</span> =&gt;
        <a href="#448980" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint)Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#455321" title="Types.this.Type">tp</a>, <a href="#449369" title="(lo0: List[Types.this.Type], hi0: List[Types.this.Type])Types.this.TypeConstraint" class="keyword">new</a> <a href="#67513" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">(</span><span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#459302" title="Types.this.TypeBounds">bounds</a>.<a href="#148531" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#459302" title="Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#455321" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to convert every occurrence of a type variable to a
      wildcard type */</span>
  <span class="keyword">object</span> <a title="object Types.this.typeVarToOriginMap" id="67548">typeVarToOriginMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="450351">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="450352">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#450352" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#448979" title="Types.this.Type">TypeVar</a><span class="delimiter">(</span><a title="Types.this.Type" id="459335">origin</a>, _<span class="delimiter">)</span> =&gt; <a href="#459335" title="Types.this.Type">origin</a>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#450352" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `contains' method */</span>
  <span class="keyword">class</span> <a title="class ContainsCollector extends Types.this.TypeCollector[Boolean] with ScalaObject" id="67550">ContainsCollector</a><a href="#67550" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="450033">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67518" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="450031">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="459350">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#449297" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#459350" title="Types.this.Type">tp</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="459352">sym1</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#450033" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#459352" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> =&gt; <a href="#449297" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span title="Unit">SingleType</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="459358">sym1</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#450033" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#459358" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> =&gt; <a href="#449297" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt; <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#459350" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(arg: Types.this.Tree)Some[Types.this.Tree]" id="450032">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="459363">arg</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Tree" id="459454">t</a> &lt;- <a href="../ast/Trees.scala.html#109174" title="(f: Types.this.Tree =&gt; Unit)Unit">arg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#450031" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#459454" title="Types.this.Tree">t</a>.<span title="=&gt; Types.this.Type">tpe</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#459454" title="Types.this.Tree">t</a>.<span title="=&gt; Types.this.Symbol">symbol</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450033" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <a href="#449297" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="delimiter">}</span>
      <span title="(x: Types.this.Tree)Some[Types.this.Tree]">Some</span><span class="delimiter">(</span><a href="#459363" title="Types.this.Tree">arg</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/** A map to implement the `contains' method */</span>
  <span class="keyword">class</span> <a title="class ContainsTypeCollector extends Types.this.TypeCollector[Boolean] with ScalaObject" id="67551">ContainsTypeCollector</a><a href="#67551" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="450044">t</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67518" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="450042">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="459475">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#449297" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#459475" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450044" title="Types.this.Type">t</a><span class="delimiter">)</span> <a href="#449297" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
        <span class="keyword">else</span> <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#459475" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(arg: Types.this.Tree)Some[Types.this.Tree]" id="450043">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="459478">arg</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Tree" id="459568">t</a> &lt;- <a href="../ast/Trees.scala.html#109174" title="(f: Types.this.Tree =&gt; Unit)Unit">arg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#450042" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#459568" title="Types.this.Tree">t</a>.<span title="=&gt; Types.this.Type">tpe</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span title="(x: Types.this.Tree)Some[Types.this.Tree]">Some</span><span class="delimiter">(</span><a href="#459478" title="Types.this.Tree">arg</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `filter' method */</span>
  <span class="keyword">class</span> <a title="class FilterTypeCollector extends Types.this.TypeCollector[scala.collection.mutable.ListBuffer[Types.this.Type]] with ScalaObject" id="67552">FilterTypeCollector</a><a href="#67552" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type =&gt; Boolean" id="449974">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67518" title="Types.this.TypeCollector[scala.collection.mutable.ListBuffer[Types.this.Type]]">TypeCollector</a><span class="delimiter">(</span><span title="scala.collection.mutable.ListBuffer[Types.this.Type]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[Types.this.Type]">ListBuffer</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449973">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="459584">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#449974" title="(v1: Types.this.Type)Boolean">p</a><span class="delimiter">(</span><a href="#459584" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#449297" title="=&gt; scala.collection.mutable.ListBuffer[Types.this.Type]">result</a> <span title="(x: Types.this.Type)scala.collection.mutable.ListBuffer[Types.this.Type]">+=</span> <a href="#459584" title="Types.this.Type">tp</a>
      <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#459584" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class ForEachTypeTraverser extends Types.this.TypeTraverser with ScalaObject" id="67553">ForEachTypeTraverser</a><a href="#67553" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type =&gt; Unit" id="449993">f</a>: Type =&gt; Unit<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67517" title="Types.this.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449992">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="449995">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#449993" title="(v1: Types.this.Type)Unit">f</a><span class="delimiter">(</span><a href="#449995" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#449995" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `filter' method */</span>
  <span class="keyword">class</span> <a title="class FindTypeCollector extends Types.this.TypeCollector[Option[Types.this.Type]] with ScalaObject" id="67554">FindTypeCollector</a><a href="#67554" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type =&gt; Boolean" id="449986">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67518" title="Types.this.TypeCollector[Option[Types.this.Type]]">TypeCollector</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="object None">None</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449985">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="459635">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#449297" title="=&gt; Option[Types.this.Type]">result</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#449986" title="(v1: Types.this.Type)Boolean">p</a><span class="delimiter">(</span><a href="#459635" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#449297" title="(x$1: Option[Types.this.Type])Unit">result</a> = <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#459635" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#459635" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `contains' method */</span>
  <span class="keyword">object</span> <a title="object Types.this.ErroneousCollector" id="67555">ErroneousCollector</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67518" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449845">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="459653">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#449297" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#449297" title="(x$1: Boolean)Unit">result</a> = <a href="#459653" title="Types.this.Type">tp</a>.<a href="#105485" title="=&gt; Boolean">isError</a>
        <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#459653" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to compute the most deeply nested owner that contains all the symbols
   *  of thistype or prefixless typerefs/singletype occurrences in given type.
   */</span>
  <span class="keyword">object</span> <a title="object Types.this.commonOwnerMap" id="67557">commonOwnerMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="Types.this.Symbol" id="459664">result</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = _
    <span class="keyword">def</span> <a title="()Unit" id="459666">init</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span class="delimiter">{</span> <a href="#459664" title="(x$1: Types.this.Symbol)Unit">result</a> = <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a> <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="459667">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="459673">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#459673" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
      <a href="#459673" title="Types.this.Type">tp</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a> <span title="Any" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Unit">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="459678">sym</a><span class="delimiter">)</span> =&gt;
          <a href="#459668" title="(sym: Types.this.Symbol)Unit">register</a><span class="delimiter">(</span><a href="#459678" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span><a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="459681">sym</a>, <a title="List[Types.this.Type]" id="459682">args</a><span class="delimiter">)</span> =&gt;
          <a href="#459668" title="(sym: Types.this.Symbol)Unit">register</a><span class="delimiter">(</span><a href="#459681" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>; <a href="#459682" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)Unit">foreach</span> <a href="#459667" title="(tp: Types.this.Type)Types.this.Type">apply</a>
        <span class="keyword">case</span> <span title="Unit">SingleType</span><span class="delimiter">(</span><a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="459704">sym</a><span class="delimiter">)</span> =&gt;
          <a href="#459668" title="(sym: Types.this.Symbol)Unit">register</a><span class="delimiter">(</span><a href="#459704" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#459673" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#459673" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="459668">register</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="459679">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#459664" title="=&gt; Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#459679" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#459664" title="=&gt; Types.this.Symbol">result</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#459679" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#107587" title="(that: Types.this.Symbol)Boolean">isNestedIn</a> <a href="#459664" title="=&gt; Types.this.Symbol">result</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#459664" title="(x$1: Types.this.Symbol)Unit">result</a> = <a href="#459664" title="=&gt; Types.this.Symbol">result</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>;
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class MissingAliasControl extends java.lang.Throwable with scala.util.control.ControlThrowable with ScalaObject" id="67559">MissingAliasControl</a> <a href="#67559" title="ScalaObject" class="keyword">extends</a> <span title="scala.util.control.ControlThrowable">ControlThrowable</span>
  <span class="keyword">val</span> <a title="Types.this.MissingAliasControl" id="67560">missingAliasException</a> = <span title="Types.this.MissingAliasControl" class="keyword">new</span> <a href="#67559" title="Types.this.MissingAliasControl">MissingAliasControl</a>
  <span class="keyword">class</span> <a title="class MissingTypeControl extends java.lang.Throwable with scala.util.control.ControlThrowable with ScalaObject" id="67562">MissingTypeControl</a> <a href="#67562" title="ScalaObject" class="keyword">extends</a> <span title="scala.util.control.ControlThrowable">ControlThrowable</span>

  <span class="keyword">object</span> <a title="object Types.this.adaptToNewRunMap" id="67563">adaptToNewRunMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67514" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol" id="313925">adaptToNewRun</a><span class="delimiter">(</span><a title="Types.this.Type" id="459740">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="459741">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102983" title="=&gt; Boolean">flatClasses</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#459741" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#459741" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isModuleClass</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#313925" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#459740" title="Types.this.Type">pre</a>, <a href="#459741" title="Types.this.Symbol">sym</a>.<span title="=&gt; Types.this.Symbol">sourceModule</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#107627" title="=&gt; Types.this.Symbol">moduleClass</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#459740" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#459740" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#459741" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#459741" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">var</span> <a title="Types.this.Symbol" id="459744">rebind0</a> = <a href="#459740" title="Types.this.Type">pre</a>.<a href="#105538" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#459741" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a>, <span title="Long(67108864L)">BRIDGE</span>, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#459744" title="Types.this.Symbol">rebind0</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#459741" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <a href="#67560" title="=&gt; Types.this.MissingAliasControl">missingAliasException</a>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#459740" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">pre</a><span title="(other: String)java.lang.String">+</span><span title="java.lang.String(&quot;.&quot;)" class="string">&quot;.&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459741" title="Types.this.Symbol">sym</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; does no longer exist, phase = &quot;)" class="string">&quot; does no longer exist, phase = &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <span title="Types.this.MissingTypeControl" class="keyword">new</span> <a href="#67562" title="Types.this.MissingTypeControl">MissingTypeControl</a> <span class="comment">// For build manager and presentation compiler purposes</span>
          <span class="comment">//assert(false, pre+&quot;.&quot;+sym+&quot; does no longer exist, phase = &quot;+phase)</span>
        <span class="delimiter">}</span>
        <span class="comment">/** The two symbols have the same fully qualified name */</span>
        <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean" id="459745">corresponds</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="459759">sym1</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="459760">sym2</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
          <a href="#459759" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#459760" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#459759" title="Types.this.Symbol">sym1</a>.<span title="=&gt; Boolean">isPackageClass</span> <span title="(x: Boolean)Boolean">||</span> <a href="#459745" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#459759" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>, <a href="#459760" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#459745" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#459741" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>, <a href="#459744" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span>
            <a href="SymbolTable.scala.html#64789" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;ADAPT1 pre = &quot;)" class="string">&quot;ADAPT1 pre = &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459740" title="Types.this.Type">pre</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;, sym = &quot;)" class="string">&quot;, sym = &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459741" title="Types.this.Symbol">sym</a><span title="(x$1: Any)java.lang.String">+</span><a href="#459741" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107659" title="=&gt; java.lang.String">locationString</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;, rebind = &quot;)" class="string">&quot;, rebind = &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459744" title="Types.this.Symbol">rebind0</a><span title="(x$1: Any)java.lang.String">+</span><a href="#459744" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#107659" title="=&gt; java.lang.String">locationString</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="459767">bcs</a> = <a href="#459740" title="Types.this.Type">pre</a>.<a href="#105526" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">dropWhile</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="459777">bc</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#459745" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#459777" title="Types.this.Symbol">bc</a>, <a href="#459741" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>;
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#459767" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
            <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#459740" title="Types.this.Type">pre</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isRefinementClass</span>, <a href="#459740" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span class="comment">// if pre is a refinementclass it might be a structural type =&gt; OK to leave it in.</span>
          <span class="keyword">else</span> 
            <a href="#459744" title="Types.this.Symbol">rebind0</a> = <a href="#459740" title="Types.this.Type">pre</a>.<a href="#105499" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#459767" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Types.this.Symbol">head</span><span class="delimiter">)</span>.<a href="#105495" title="(name: Types.this.Name)Types.this.Symbol">member</a><span class="delimiter">(</span><a href="#459741" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="SymbolTable.scala.html#64789" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span>
            <span title="java.lang.String(&quot;ADAPT2 pre = &quot;)" class="string">&quot;ADAPT2 pre = &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#459740" title="Types.this.Type">pre</a> <span title="(x$1: Any)java.lang.String">+</span>
            <span title="java.lang.String(&quot;, bcs.head = &quot;)" class="string">&quot;, bcs.head = &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#459767" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Types.this.Symbol">head</span> <span title="(x$1: Any)java.lang.String">+</span>
            <span title="java.lang.String(&quot;, sym = &quot;)" class="string">&quot;, sym = &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#459741" title="Types.this.Symbol">sym</a><span title="(x$1: Any)java.lang.String">+</span><a href="#459741" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107659" title="=&gt; java.lang.String">locationString</a> <span title="(x$1: Any)java.lang.String">+</span>
            <span title="java.lang.String(&quot;, rebind = &quot;)" class="string">&quot;, rebind = &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#459744" title="Types.this.Symbol">rebind0</a> <span title="(x$1: Any)java.lang.String">+</span> <span class="delimiter">(</span>
              <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#459744" title="Types.this.Symbol">rebind0</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
              <span class="keyword">else</span> <a href="#459744" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#107659" title="=&gt; java.lang.String">locationString</a>
            <span class="delimiter">)</span>
          <span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="459746">rebind</a> = <a href="#459744" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#107593" title="(cond: Types.this.Symbol =&gt; Boolean)Types.this.Symbol">suchThat</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="459789">sym</a> =&gt; <a href="#459789" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isType</span> <span title="(x: Boolean)Boolean">||</span> <a href="#459789" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107514" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#459746" title="Types.this.Symbol">rebind</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="SymbolTable.scala.html#64789" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102983" title="=&gt; Boolean">flatClasses</a><span title="(x$1: Any)java.lang.String">+</span><a href="#459741" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a><span title="(x$1: Any)java.lang.String">+</span><a href="#459741" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459741" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isType</span><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <a href="#458741" title="(pre: Types.this.Type, tp: String)Types.this.MalformedType" class="keyword">new</a> <a href="#67671" title="Types.this.MalformedType">MalformedType</a><span class="delimiter">(</span><a href="#459740" title="Types.this.Type">pre</a>, <a href="#459741" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107655" title="=&gt; java.lang.String">nameString</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#459746" title="Types.this.Symbol">rebind</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="313926">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="313927">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#313927" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="459802">sym</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">try</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="459803">sym1</a> = <a href="#313925" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#459802" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#107600" title="=&gt; Types.this.Type">thisType</a>, <a href="#459802" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459803" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#459802" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#313927" title="Types.this.Type">tp</a> <span class="keyword">else</span> <a href="#148254" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="#459803" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        	<span class="keyword">case</span> <a title="Types.this.Type" id="459808">ex</a>: <a href="#67562" title="Types.this.MissingTypeControl">MissingTypeControl</a> =&gt;
            <a href="#313927" title="Types.this.Type">tp</a> 
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="459809">pre</a>, <a title="Types.this.Symbol" id="459810">sym</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459810" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackage</span><span class="delimiter">)</span> <a href="#313927" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="459811">pre1</a> = <a href="#313926" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#459809" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="459812">sym1</a> = <a href="#313925" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#459811" title="Types.this.Type">pre1</a>, <a href="#459810" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#459811" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459809" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#459812" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459810" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#313927" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#67479" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#459811" title="Types.this.Type">pre1</a>, <a href="#459812" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="459814">pre</a>, <a title="Types.this.Symbol" id="459815">sym</a>, <a title="List[Types.this.Type]" id="459816">args</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459815" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span><span class="delimiter">)</span> <a href="#313927" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="459817">pre1</a> = <a href="#313926" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#459814" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="459818">args1</a> = <a href="#459816" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>
          <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="459825">sym1</a> = <a href="#313925" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#459817" title="Types.this.Type">pre1</a>, <a href="#459815" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#459817" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459814" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#459825" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459815" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#459818" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459816" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="comment">/* &amp;&amp; sym.isExternal*/</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#313927" title="Types.this.Type">tp</a>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459825" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="java.lang.String(&quot;adapt fail: &quot;)" class="string">&quot;adapt fail: &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459814" title="Types.this.Type">pre</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459817" title="Types.this.Type">pre1</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459815" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
              <a href="#313927" title="Types.this.Type">tp</a>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <a href="#67484" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#313927" title="Types.this.Type">tp</a>, <a href="#459817" title="Types.this.Type">pre1</a>, <a href="#459825" title="Types.this.Symbol">sym1</a>, <a href="#459818" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a title="Types.this.Type" id="459835">ex</a>: <a href="#67559" title="Types.this.MissingAliasControl">MissingAliasControl</a> =&gt;
              <a href="#313926" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#313927" title="Types.this.Type">tp</a>.<a href="#105484" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="Types.this.Type">_</span>: <a href="#67562" title="Types.this.MissingTypeControl">MissingTypeControl</a> =&gt;
              <a href="#313927" title="Types.this.Type">tp</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="459837">params</a>, <a title="Types.this.Type" id="459838">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="459839">restp1</a> = <a href="#313926" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#459838" title="Types.this.Type">restp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459839" title="Types.this.Type">restp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459838" title="Types.this.Type">restp</a><span class="delimiter">)</span> <a href="#313927" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#67486" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#313927" title="Types.this.Type">tp</a>, <a href="#459837" title="List[Types.this.Symbol]">params</a>, <a href="#459839" title="Types.this.Type">restp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="459841">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="459842">restp1</a> = <a href="#313926" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#459841" title="Types.this.Type">restp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459842" title="Types.this.Type">restp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459841" title="Types.this.Type">restp</a><span class="delimiter">)</span> <a href="#313927" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#148865" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#459842" title="Types.this.Type">restp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="459843">tparams</a>, <a title="Types.this.Type" id="459844">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="459845">restp1</a> = <a href="#313926" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#459844" title="Types.this.Type">restp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459845" title="Types.this.Type">restp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459844" title="Types.this.Type">restp</a><span class="delimiter">)</span> <a href="#313927" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#148921" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#459843" title="List[Types.this.Symbol]">tparams</a>, <a href="#459845" title="Types.this.Type">restp1</a><span class="delimiter">)</span>

      <span class="comment">// Lukas: we need to check (together) whether we should also include parameter types</span>
      <span class="comment">// of PolyType and MethodType in adaptToNewRun</span>
      
      <span class="keyword">case</span> <span title="Types.this.Type">ClassInfoType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="459846">parents</a>, <a title="Types.this.Scope" id="459847">decls</a>, <a title="Types.this.Symbol" id="459848">clazz</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459848" title="Types.this.Symbol">clazz</a>.<span title="=&gt; Boolean">isPackageClass</span><span class="delimiter">)</span> <a href="#313927" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="459849">parents1</a> = <a href="#459846" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459849" title="List[Types.this.Type]">parents1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459846" title="List[Types.this.Type]">parents</a><span class="delimiter">)</span> <a href="#313927" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#148665" title="(parents: List[Types.this.Type], decls: Types.this.Scope, typeSymbol: Types.this.Symbol)Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">(</span><a href="#459849" title="List[Types.this.Type]">parents1</a>, <a href="#459847" title="Types.this.Scope">decls</a>, <a href="#459848" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="459859">parents</a>, <a title="Types.this.Scope" id="459860">decls</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="459861">parents1</a> = <a href="#459859" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459861" title="List[Types.this.Type]">parents1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459859" title="List[Types.this.Type]">parents</a><span class="delimiter">)</span> <a href="#313927" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#67480" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#459861" title="List[Types.this.Type]">parents1</a>, <a href="#313927" title="Types.this.Type">tp</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>, <a href="#459860" title="Types.this.Scope">decls</a>, <a href="#313927" title="Types.this.Type">tp</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#107404" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SuperType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#313927" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeBounds</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#313927" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="#448979" title="Types.this.Type">TypeVar</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#313927" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">AnnotatedType</span><span class="delimiter">(</span>_,_,_<span class="delimiter">)</span> =&gt; <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#313927" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">NotNullType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#313927" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#313927" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#313927" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class SubTypePair extends java.lang.Object with ScalaObject" id="67565">SubTypePair</a><a href="#67565" title="ScalaObject" class="delimiter">(</a><span class="keyword">val</span> <a title="Types.this.Type" id="459936">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <span class="keyword">val</span> <a title="Types.this.Type" id="459937">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()Int" id="459930">hashCode</a> = <a href="#459936" title="=&gt; Types.this.Type">tp1</a>.<span title="()Int">hashCode</span> <span title="(x: Int)Int">*</span> <span title="Int(41)" class="int">41</span> <span title="(x: Int)Int">+</span> <a href="#459937" title="=&gt; Types.this.Type">tp2</a>.<span title="()Int">hashCode</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(other: Any)Boolean" id="459931">equals</a><span class="delimiter">(</span><a title="Any" id="459949">other</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <a href="#459949" title="Any">other</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="459952">stp</a>: <a href="#67565" title="Types.this.SubTypePair">SubTypePair</a> =&gt; 
        <span class="delimiter">(</span><a href="#459936" title="=&gt; Types.this.Type">tp1</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#459952" title="Types.this.SubTypePair">stp</a>.<a href="#459936" title="=&gt; Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#459937" title="=&gt; Types.this.Type">tp2</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#459952" title="Types.this.SubTypePair">stp</a>.<a href="#459937" title="=&gt; Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
        <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="459932">toString</a> = <a href="#459936" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">tp1</a><span title="(other: String)java.lang.String">+</span><span title="java.lang.String(&quot; &lt;:&lt;? &quot;)" class="string">&quot; &lt;:&lt;? &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459937" title="=&gt; Types.this.Type">tp2</a>
  <span class="delimiter">}</span>

<span class="comment">// Helper Methods  -------------------------------------------------------------</span>

  <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(0)" id="67566">LubGlbMargin</a> = <span title="Int(0)" class="int">0</span>

  <span class="comment">/** The maximum allowable depth of lubs or glbs over types `ts'
    * This is the maximum depth of all types in the base type sequences 
    * of each of the types `ts', plus LubGlbMargin
    */</span>
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Int" id="67568">lubDepth</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="419366">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="Int" id="419369">d</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="419389">tp</a> &lt;- <a href="#419366" title="(f: Types.this.Type =&gt; Unit)Unit">ts</a><span class="delimiter">)</span> <a href="#419369" title="Int">d</a> = math.<span title="(x: Int, y: Int)Int">max</span><span class="delimiter">(</span><a href="#419369" title="Int">d</a>, <a href="#419389" title="Types.this.Type">tp</a>.<a href="#105525" title="=&gt; Int">baseTypeSeqDepth</a><span class="delimiter">)</span>
    <a href="#419369" title="Int">d</a> <span title="(x: Int)Int">+</span> <span title="Int(0)">LubGlbMargin</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Is intersection of given types populated? That is,
   *  for all types tp1, tp2 in intersection
   *    for all common base classes bc of tp1 and tp2
   *      let bt1, bt2 be the base types of tp1, tp2 relative to class bc
   *      Then:
   *        bt1 and bt2 have the same prefix, and
   *        any corresponding non-variant type arguments of bt1 and bt2 are the same
   */</span>
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67569">isPopulated</a><span class="delimiter">(</span><a title="Types.this.Type" id="159926">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="159927">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="459958">isConsistent</a><span class="delimiter">(</span><a title="Types.this.Type" id="459960">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="459961">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#459960" title="Types.this.Type">tp1</a>, <a href="#459961" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="459970">pre1</a>, <a title="Types.this.Symbol" id="459971">sym1</a>, <a title="List[Types.this.Type]" id="459972">args1</a><span class="delimiter">)</span>, TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="459973">pre2</a>, <a title="Types.this.Symbol" id="459974">sym2</a>, <a title="List[Types.this.Type]" id="459975">args2</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#459971" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#459974" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>
        <a href="#459970" title="Types.this.Type">pre1</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#459973" title="Types.this.Type">pre2</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <span class="delimiter">(</span><span title="(_1: List[Types.this.Type], _2: List[Types.this.Type], _3: List[Types.this.Symbol])(List[Types.this.Type], List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</span><a href="#459972" title="List[Types.this.Type]">args1</a>, <a href="#459975" title="List[Types.this.Type]">args2</a>, <a href="#459971" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span>.<span title="(implicit w1: List[Types.this.Type] =&gt; scala.collection.TraversableLike[Types.this.Type,List[Types.this.Type]], implicit w2: List[Types.this.Type] =&gt; scala.collection.IterableLike[Types.this.Type,List[Types.this.Type]], implicit w3: List[Types.this.Symbol] =&gt; scala.collection.IterableLike[Types.this.Symbol,List[Types.this.Symbol]])(List[Types.this.Type], List[Types.this.Type], List[Types.this.Symbol])#Zipped[List[Types.this.Type],Types.this.Type,List[Types.this.Type],Types.this.Type,List[Types.this.Symbol],Types.this.Symbol]">zipped</span> <span title="(f: (Types.this.Type, Types.this.Type, Types.this.Symbol) =&gt; Boolean)Boolean">forall</span> <span class="delimiter">{</span>
          <span class="delimiter">(</span><a title="Types.this.Type" id="460047">arg1</a>, <a title="Types.this.Type" id="460048">arg2</a>, <a title="Types.this.Symbol" id="460049">tparam</a><span class="delimiter">)</span> =&gt; 
            <span class="comment">//if (tparam.variance == 0 &amp;&amp; !(arg1 =:= arg2)) Console.println(&quot;inconsistent: &quot;+arg1+&quot;!=&quot;+arg2)//DEBUG</span>
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460049" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107540" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#460047" title="Types.this.Type">arg1</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460048" title="Types.this.Type">arg2</a>
          <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460047" title="Types.this.Type">arg1</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#67469" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span><span class="delimiter">)</span> 
            <span class="comment">// if left-hand argument is a typevar, make it compatible with variance</span>
            <span class="comment">// this is for more precise pattern matching</span>
            <span class="comment">// todo: work this in the spec of this method</span>
            <span class="comment">// also: think what happens if there are embedded typevars?</span>
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460049" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107540" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#460047" title="Types.this.Type">arg1</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460048" title="Types.this.Type">arg2</a> <span class="keyword">else</span> <a href="#460048" title="Types.this.Type">arg2</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460047" title="Types.this.Type">arg1</a>
          <span class="keyword">else</span> <span title="Boolean(true)" class="keyword">true</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span><a title="Types.this.ExistentialType" id="460061">et</a>: <a href="#149138" title="Types.this.ExistentialType">ExistentialType</a>, _<span class="delimiter">)</span> =&gt;
        <a href="#460061" title="Types.this.ExistentialType">et</a>.<a href="#149166" title="(op: Types.this.Type =&gt; Boolean)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#459958" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#460065" title="Types.this.Type">_</a>, <a href="#459961" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>_, <a title="Types.this.ExistentialType" id="460068">et</a>: <a href="#149138" title="Types.this.ExistentialType">ExistentialType</a><span class="delimiter">)</span> =&gt;
        <a href="#460068" title="Types.this.ExistentialType">et</a>.<a href="#149166" title="(op: Types.this.Type =&gt; Boolean)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#459958" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#459960" title="Types.this.Type">tp1</a>, <a href="#460072" title="Types.this.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>    

    <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="459959">check</a><span class="delimiter">(</span><a title="Types.this.Type" id="460073">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460074">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = 
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460073" title="Types.this.Type">tp1</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460073" title="Types.this.Type">tp1</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="(mask: Long)Boolean">hasFlag</span><span class="delimiter">(</span><span title="Long(32L)">FINAL</span><span class="delimiter">)</span><span class="delimiter">)</span> 
        <a href="#460073" title="Types.this.Type">tp1</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460074" title="Types.this.Type">tp2</a> <span title="(x: Boolean)Boolean">||</span> <a href="Definitions.scala.html#106712" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#460073" title="Types.this.Type">tp1</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#106712" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#460074" title="Types.this.Type">tp2</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#460073" title="Types.this.Type">tp1</a>.<a href="#105526" title="=&gt; List[Types.this.Symbol]">baseClasses</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="460084">bc</a> =&gt; 
        <a href="#460074" title="Types.this.Type">tp2</a>.<a href="#105527" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#460084" title="Types.this.Symbol">bc</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#459958" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#460073" title="Types.this.Type">tp1</a>.<a href="#105499" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#460084" title="Types.this.Symbol">bc</a><span class="delimiter">)</span>, <a href="#460074" title="Types.this.Type">tp2</a>.<a href="#105499" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#460084" title="Types.this.Symbol">bc</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <a href="#459959" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">check</a><span class="delimiter">(</span><a href="#159926" title="Types.this.Type">tp1</a>, <a href="#159927" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="comment">/* &amp;&amp; check(tp2, tp1)*/</span> <span class="comment">// need to investgate why this can't be made symmetric -- neg/gadts1 fails, and run/existials also.</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Does a pattern of type `patType' need an outer test when executed against
   *  selector type `selType' in context defined by `currentOwner'?
   */</span>
  <span class="keyword">def</span> <a title="(patType: Types.this.Type, selType: Types.this.Type, currentOwner: Types.this.Symbol)Boolean" id="67570">needsOuterTest</a><span class="delimiter">(</span><a title="Types.this.Type" id="159864">patType</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="159865">selType</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="159866">currentOwner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type)Types.this.Type" id="159869">createDummyClone</a><span class="delimiter">(</span><a title="Types.this.Type" id="159871">pre</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.TermSymbol" id="159872">dummy</a> = <a href="#159866" title="Types.this.Symbol">currentOwner</a>.<span title="=&gt; Types.this.Symbol">enclClass</span>.<a href="Symbols.scala.html#107420" title="(pos: Types.this.Position, name: Types.this.TermName)Types.this.TermSymbol">newValue</a><span class="delimiter">(</span><a href="Positions.scala.html#67902" title="=&gt; tools.nsc.util.NoPosition.type">NoPosition</a>, <a href="StdNames.scala.html#67724" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115414" title="=&gt; Types.this.nme.NameType">ANYNAME</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107566" title="(info: Types.this.Type)Types.this.TermSymbol">setInfo</a><span class="delimiter">(</span><a href="#159871" title="Types.this.Type">pre</a>.<a href="#105458" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
      <a href="#67479" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#148254" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="#159866" title="Types.this.Symbol">currentOwner</a>.<span title="=&gt; Types.this.Symbol">enclClass</span><span class="delimiter">)</span>, <a href="#159872" title="Types.this.TermSymbol">dummy</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="159870">maybeCreateDummyClone</a><span class="delimiter">(</span><a title="Types.this.Type" id="159895">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="159896">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#159895" title="Types.this.Type">pre</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="159897">pre1</a>, <a title="Types.this.Symbol" id="159898">sym1</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#159898" title="Types.this.Symbol">sym1</a>.<span title="=&gt; Boolean">isModule</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#159898" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107525" title="=&gt; Boolean">isStatic</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#450913" title="object Types.this.NoType">NoType</a>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#159898" title="Types.this.Symbol">sym1</a>.<span title="=&gt; Boolean">isModule</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#159896" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#159898" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107627" title="=&gt; Types.this.Symbol">moduleClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="159904">pre2</a> = <a href="#159870" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span><a href="#159897" title="Types.this.Type">pre1</a>, <a href="#159898" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#159904" title="Types.this.Type">pre2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <a href="#159904" title="Types.this.Type">pre2</a>
          <span class="keyword">else</span> <a href="#67479" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#159904" title="Types.this.Type">pre2</a>, <a href="#159898" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <a href="#159869" title="(pre: Types.this.Type)Types.this.Type">createDummyClone</a><span class="delimiter">(</span><a href="#159895" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="159905">clazz</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#159905" title="Types.this.Symbol">clazz</a>.<span title="=&gt; Boolean">isModuleClass</span><span class="delimiter">)</span>
          <a href="#159870" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span><a href="#159905" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107599" title="=&gt; Types.this.Type">typeOfThis</a>, <a href="#159896" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#159896" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#159905" title="Types.this.Symbol">clazz</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#159896" title="Types.this.Symbol">sym</a>.<span title="(mask: Long)Boolean">hasFlag</span><span class="delimiter">(</span><span title="Long(4L)">PRIVATE</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#159896" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107418" title="=&gt; Types.this.Symbol">privateWithin</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#159905" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#450913" title="object Types.this.NoType">NoType</a>
        <span class="keyword">else</span> 
          <a href="#159869" title="(pre: Types.this.Type)Types.this.Type">createDummyClone</a><span class="delimiter">(</span><a href="#159895" title="Types.this.Type">pre</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.NoType.type">_</span> =&gt;
        <a href="#450913" title="object Types.this.NoType">NoType</a>
    <span class="delimiter">}</span>
    <a href="#159864" title="Types.this.Type">patType</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="159922">pre</a>, <a title="Types.this.Symbol" id="159923">sym</a>, <a title="List[Types.this.Type]" id="159924">args</a><span class="delimiter">)</span> =&gt; 
        <span class="keyword">val</span> <a title="Types.this.Type" id="159925">pre1</a> = <a href="#159870" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span><a href="#159922" title="Types.this.Type">pre</a>, <a href="#159923" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="#159925" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67569" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isPopulated</a><span class="delimiter">(</span><a href="#67484" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#159864" title="Types.this.Type">patType</a>, <a href="#159925" title="Types.this.Type">pre1</a>, <a href="#159923" title="Types.this.Symbol">sym</a>, <a href="#159924" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, <a href="#159865" title="Types.this.Type">selType</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
        <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="67572">subsametypeRecursions</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(pre1: Types.this.Type, pre2: Types.this.Type)Boolean" id="67574">isUnifiable</a><span class="delimiter">(</span><a title="Types.this.Type" id="460089">pre1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460090">pre2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
    <span class="delimiter">(</span><a href="#67596" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#460089" title="Types.this.Type">pre1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#67596" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#460090" title="Types.this.Type">pre2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#460089" title="Types.this.Type">pre1</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460090" title="Types.this.Type">pre2</a><span class="delimiter">)</span>

  <span class="comment">/** Returns true iff we are past phase specialize,
   *  sym1 and sym2 are two existential skolems with equal names and bounds,
   *  and pre1 and pre2 are equal prefixes
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol, pre1: Types.this.Type, pre2: Types.this.Type)Boolean" id="67575">isSameSpecializedSkolem</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="460095">sym1</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="460096">sym2</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="460097">pre1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460098">pre2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#460095" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107484" title="=&gt; Boolean">isExistentialSkolem</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460096" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107484" title="=&gt; Boolean">isExistentialSkolem</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
    <a href="#460095" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#460096" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
    <a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102981" title="=&gt; Boolean">specialized</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
    <a href="#460095" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460096" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
    <a href="#460097" title="Types.this.Type">pre1</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460098" title="Types.this.Type">pre2</a>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean" id="67576">equalSymsAndPrefixes</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="460106">sym1</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="460107">pre1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="460108">sym2</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="460109">pre2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460106" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#460108" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> <a href="#460106" title="Types.this.Symbol">sym1</a>.<span title="=&gt; Boolean">hasPackageFlag</span> <span title="(x: Boolean)Boolean">||</span> <a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#460107" title="Types.this.Type">pre1</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460109" title="Types.this.Type">pre2</a>
    <span class="keyword">else</span> <span class="delimiter">(</span><a href="#460106" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#460108" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67574" title="(pre1: Types.this.Type, pre2: Types.this.Type)Boolean">isUnifiable</a><span class="delimiter">(</span><a href="#460107" title="Types.this.Type">pre1</a>, <a href="#460109" title="Types.this.Type">pre2</a><span class="delimiter">)</span>

  <span class="comment">/** Do `tp1' and `tp2' denote equivalent types?
   */</span>
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67577">isSameType</a><span class="delimiter">(</span><a title="Types.this.Type" id="261948">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="261949">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="../util/Statistics.scala.html#67162" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67215" title="=&gt; scala.tools.nsc.util.Statistics.Counter">sametypeCount</a><span class="delimiter">)</span>
    <a href="#67572" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <a href="#67383" title="object Types.this.undoLog">undoLog</a> <a href="#106886" title="(block: =&gt; Boolean)Boolean">undoUnless</a> <span class="delimiter">{</span>
      <a href="#67581" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType1</a><span class="delimiter">(</span><a href="#261948" title="Types.this.Type">tp1</a>, <a href="#261949" title="Types.this.Type">tp2</a><span class="delimiter">)</span> 
    <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#67572" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
    <span class="comment">// XXX AM TODO: figure out when it is safe and needed to clear the log -- the commented approach below is too eager (it breaks #3281, #3866)</span>
    <span class="comment">// it doesn't help to keep separate recursion counts for the three methods that now share it</span>
    <span class="comment">// if (subsametypeRecursions == 0) undoLog.clear()</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67578">isDifferentType</a><span class="delimiter">(</span><a title="Types.this.Type" id="460133">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460134">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="#67572" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <a href="#67383" title="object Types.this.undoLog">undoLog</a> <a href="#106883" title="(block: =&gt; Boolean)Boolean">undo</a> <span class="delimiter">{</span> <span class="comment">// undo type constraints that arise from operations in this block</span>
      <span title="=&gt; Boolean">!</span><a href="#67581" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType1</a><span class="delimiter">(</span><a href="#460133" title="Types.this.Type">tp1</a>, <a href="#460134" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#67572" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
    <span class="comment">// XXX AM TODO: figure out when it is safe and needed to clear the log -- the commented approach below is too eager (it breaks #3281, #3866)</span>
    <span class="comment">// it doesn't help to keep separate recursion counts for the three methods that now share it</span>
    <span class="comment">// if (subsametypeRecursions == 0) undoLog.clear()</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67579">isDifferentTypeConstructor</a><span class="delimiter">(</span><a title="Types.this.Type" id="460147">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460148">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#460147" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="460150">pre1</a>, <a title="Types.this.Symbol" id="460151">sym1</a>, _<span class="delimiter">)</span> =&gt; 
      <a href="#460148" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="460152">pre2</a>, <a title="Types.this.Symbol" id="460153">sym2</a>, _<span class="delimiter">)</span> =&gt; <a href="#460151" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#460153" title="Types.this.Symbol">sym2</a> <span title="(x: Boolean)Boolean">||</span> <a href="#67578" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isDifferentType</a><span class="delimiter">(</span><a href="#460150" title="Types.this.Type">pre1</a>, <a href="#460152" title="Types.this.Type">pre2</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Boolean(true)">_</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> <span title="Boolean(true)">_</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="67580">normalizePlus</a><span class="delimiter">(</span><a title="Types.this.Type" id="258554">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = 
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67527" title="(tp: Types.this.Type)Boolean">isRawType</a><span class="delimiter">(</span><a href="#258554" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#258577" title="(tp: Types.this.Type)Types.this.Type">rawToExistential</a><span class="delimiter">(</span><a href="#258554" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <a href="#258554" title="Types.this.Type">tp</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a>

  <span class="comment">/*
  todo: change to:
  def normalizePlus(tp: Type) = tp match {
    case TypeRef(pre, sym, List()) =&gt;
      if (!sym.isInitialized) sym.rawInfo.load(sym)
      if (sym.isJavaDefined &amp;&amp; !sym.typeParams.isEmpty) rawToExistential(tp)
      else tp.normalize
    case _ =&gt; tp.normalize
  }
  */</span>
<span class="comment">/*
  private def isSameType0(tp1: Type, tp2: Type): Boolean = {
    if (tp1 eq tp2) return true
    ((tp1, tp2) match {
      case (ErrorType, _) =&gt; true
      case (WildcardType, _) =&gt; true
      case (_, ErrorType) =&gt; true
      case (_, WildcardType) =&gt; true

      case (NoType, _) =&gt; false
      case (NoPrefix, _) =&gt; tp2.typeSymbol.isPackageClass
      case (_, NoType) =&gt; false
      case (_, NoPrefix) =&gt; tp1.typeSymbol.isPackageClass

      case (ThisType(sym1), ThisType(sym2))
      if (sym1 == sym2) =&gt;
        true
      case (SingleType(pre1, sym1), SingleType(pre2, sym2))
      if (equalSymsAndPrefixes(sym1, pre1, sym2, pre2)) =&gt;
        true
/*
      case (SingleType(pre1, sym1), ThisType(sym2))
      if (sym1.isModule &amp;&amp; 
          sym1.moduleClass == sym2 &amp;&amp;
          pre1 =:= sym2.owner.thisType) =&gt;
        true
      case (ThisType(sym1), SingleType(pre2, sym2))
      if (sym2.isModule &amp;&amp; 
          sym2.moduleClass == sym1 &amp;&amp;
          pre2 =:= sym1.owner.thisType) =&gt;
        true
*/
      case (ConstantType(value1), ConstantType(value2)) =&gt;
        value1 == value2
      case (TypeRef(pre1, sym1, args1), TypeRef(pre2, sym2, args2)) =&gt;
        equalSymsAndPrefixes(sym1, pre1, sym2, pre2) &amp;&amp;
        ((tp1.isHigherKinded &amp;&amp; tp2.isHigherKinded &amp;&amp; tp1.normalize =:= tp2.normalize) || 
         isSameTypes(args1, args2))
         // @M! normalize reduces higher-kinded case to PolyType's
      case (RefinedType(parents1, ref1), RefinedType(parents2, ref2)) =&gt;
        def isSubScope(s1: Scope, s2: Scope): Boolean = s2.toList.forall {
          sym2 =&gt;
            var e1 = s1.lookupEntry(sym2.name)
            (e1 ne null) &amp;&amp; {
              val substSym = sym2.info.substThis(sym2.owner, e1.sym.owner.thisType)
              var isEqual = false
              while (!isEqual &amp;&amp; (e1 ne null)) { 
                isEqual = e1.sym.info =:= substSym
                e1 = s1.lookupNextEntry(e1)
              }
              isEqual
            }
        }
        //Console.println(&quot;is same? &quot; + tp1 + &quot; &quot; + tp2 + &quot; &quot; + tp1.typeSymbol.owner + &quot; &quot; + tp2.typeSymbol.owner)//DEBUG
        isSameTypes(parents1, parents2) &amp;&amp; isSubScope(ref1, ref2) &amp;&amp; isSubScope(ref2, ref1)
      case (MethodType(params1, res1), MethodType(params2, res2)) =&gt;
        // new dependent types: probably fix this, use substSym as done for PolyType
        (isSameTypes(tp1.paramTypes, tp2.paramTypes) &amp;&amp;
         res1 =:= res2 &amp;&amp;
         tp1.isImplicit == tp2.isImplicit)
      case (PolyType(tparams1, res1), PolyType(tparams2, res2)) =&gt; 
        // assert((tparams1 map (_.typeParams.length)) == (tparams2 map (_.typeParams.length)))
        (tparams1.length == tparams2.length) &amp;&amp; (tparams1 corresponds tparams2)(_.info =:= _.info.substSym(tparams2, tparams1)) &amp;&amp; // @M looks like it might suffer from same problem as #2210 
          res1 =:= res2.substSym(tparams2, tparams1)
      case (ExistentialType(tparams1, res1), ExistentialType(tparams2, res2)) =&gt;
        (tparams1.length == tparams2.length) &amp;&amp; (tparams1 corresponds tparams2)(_.info =:= _.info.substSym(tparams2, tparams1)) &amp;&amp; // @M looks like it might suffer from same problem as #2210
          res1 =:= res2.substSym(tparams2, tparams1)
      case (TypeBounds(lo1, hi1), TypeBounds(lo2, hi2)) =&gt;
        lo1 =:= lo2 &amp;&amp; hi1 =:= hi2
      case (BoundedWildcardType(bounds), _) =&gt;
        bounds containsType tp2
      case (_, BoundedWildcardType(bounds)) =&gt;
        bounds containsType tp1
      case (tv @ TypeVar(_,_), tp) =&gt;
        tv.registerTypeEquality(tp, true)
      case (tp, tv @ TypeVar(_,_)) =&gt;
        tv.registerTypeEquality(tp, false)
      case (AnnotatedType(_,_,_), _) =&gt;
        annotationsConform(tp1, tp2) &amp;&amp; annotationsConform(tp2, tp1) &amp;&amp; tp1.withoutAnnotations =:= tp2.withoutAnnotations
      case (_, AnnotatedType(_,_,_)) =&gt;
        annotationsConform(tp1, tp2) &amp;&amp; annotationsConform(tp2, tp1) &amp;&amp; tp1.withoutAnnotations =:= tp2.withoutAnnotations
      case (_: SingletonType, _: SingletonType) =&gt;
        var origin1 = tp1
        while (origin1.underlying.isInstanceOf[SingletonType]) {
          assert(origin1 ne origin1.underlying, origin1)
          origin1 = origin1.underlying
        }
        var origin2 = tp2
        while (origin2.underlying.isInstanceOf[SingletonType]) {
          assert(origin2 ne origin2.underlying, origin2)
          origin2 = origin2.underlying
        }
        ((origin1 ne tp1) || (origin2 ne tp2)) &amp;&amp; (origin1 =:= origin2)
      case _ =&gt;
        false
    }) || {
      val tp1n = normalizePlus(tp1)
      val tp2n = normalizePlus(tp2)
      ((tp1n ne tp1) || (tp2n ne tp2)) &amp;&amp; isSameType(tp1n, tp2n)
    }
  }
*/</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67581">isSameType1</a><span class="delimiter">(</span><a title="Types.this.Type" id="460126">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460127">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#460126" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#460127" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> 
        <span class="delimiter">(</span><a href="#460126" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450846" title="object Types.this.ErrorType">ErrorType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#460126" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450864" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
        <span class="delimiter">(</span><a href="#460127" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450846" title="object Types.this.ErrorType">ErrorType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#460127" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450864" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#460126" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#460127" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460126" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> 
      <a href="#460127" title="Types.this.Type">tp2</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isPackageClass</span>
    <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460127" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span>
      <a href="#460126" title="Types.this.Type">tp1</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isPackageClass</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <a href="#67582" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType2</a><span class="delimiter">(</span><a href="#460126" title="Types.this.Type">tp1</a>, <a href="#460127" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="460161">tp1n</a> = <a href="#67580" title="(tp: Types.this.Type)Types.this.Type">normalizePlus</a><span class="delimiter">(</span><a href="#460126" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="460162">tp2n</a> = <a href="#67580" title="(tp: Types.this.Type)Types.this.Type">normalizePlus</a><span class="delimiter">(</span><a href="#460127" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><span class="delimiter">(</span><a href="#460161" title="Types.this.Type">tp1n</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#460126" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#460162" title="Types.this.Type">tp2n</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#460127" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67577" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a><span class="delimiter">(</span><a href="#460161" title="Types.this.Type">tp1n</a>, <a href="#460162" title="Types.this.Type">tp2n</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67582">isSameType2</a><span class="delimiter">(</span><a title="Types.this.Type" id="460158">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460159">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <a href="#460158" title="Types.this.Type">tp1</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Unit" id="460163">tr1</a>: <a href="#133603" title="Types.this.TypeRef">TypeRef</a> =&gt;
        <a href="#460159" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Nothing" id="460164">tr2</a>: <a href="#133603" title="Types.this.TypeRef">TypeRef</a> =&gt;
            <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span><a href="#67576" title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean">equalSymsAndPrefixes</a><span class="delimiter">(</span><a href="#460163" title="Types.this.TypeRef">tr1</a>.<a href="#133632" title="=&gt; Types.this.Symbol">sym</a>, <a href="#460163" title="Types.this.TypeRef">tr1</a>.<a href="#133631" title="=&gt; Types.this.Type">pre</a>, <a href="#460164" title="Types.this.TypeRef">tr2</a>.<a href="#133632" title="=&gt; Types.this.Symbol">sym</a>, <a href="#460164" title="Types.this.TypeRef">tr2</a>.<a href="#133631" title="=&gt; Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <span class="delimiter">(</span><span class="delimiter">(</span><a href="#460158" title="Types.this.Type">tp1</a>.<a href="#105445" title="=&gt; Boolean">isHigherKinded</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460159" title="Types.this.Type">tp2</a>.<a href="#105445" title="=&gt; Boolean">isHigherKinded</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460158" title="Types.this.Type">tp1</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460159" title="Types.this.Type">tp2</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> 
               <a href="#67583" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span><a href="#460163" title="Types.this.TypeRef">tr1</a>.<a href="#133633" title="=&gt; List[Types.this.Type]">args</a>, <a href="#460164" title="Types.this.TypeRef">tr2</a>.<a href="#133633" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
               <span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#460163" title="Types.this.TypeRef">tr1</a>.<a href="#133631" title="=&gt; Types.this.Type">pre</a>, <a href="#460164" title="Types.this.TypeRef">tr2</a>.<a href="#133631" title="=&gt; Types.this.Type">pre</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
                 <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span><a title="Types.this.TypeVar" id="460176">tv</a> @ <a href="#448979" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#460176" title="Types.this.TypeVar">tv</a>.<a href="#449015" title="(sym: Types.this.Symbol, tp: Types.this.Type)Boolean">registerTypeSelection</a><span class="delimiter">(</span><a href="#460163" title="Types.this.TypeRef">tr1</a>.<a href="#133632" title="=&gt; Types.this.Symbol">sym</a>, <a href="#460164" title="Types.this.TypeRef">tr2</a><span class="delimiter">)</span>
                 <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>_, <a title="Types.this.TypeVar" id="460180">tv</a> @ <a href="#448979" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#460180" title="Types.this.TypeVar">tv</a>.<a href="#449015" title="(sym: Types.this.Symbol, tp: Types.this.Type)Boolean">registerTypeSelection</a><span class="delimiter">(</span><a href="#460164" title="Types.this.TypeRef">tr2</a>.<a href="#133632" title="=&gt; Types.this.Symbol">sym</a>, <a href="#460163" title="Types.this.TypeRef">tr1</a><span class="delimiter">)</span>
                 <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
               <span class="delimiter">}</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="460182">tt1</a>: <a href="#148319" title="Types.this.ThisType">ThisType</a> =&gt;
        <a href="#460159" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Unit" id="460183">tt2</a>: <a href="#148319" title="Types.this.ThisType">ThisType</a> =&gt;
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#460182" title="Types.this.ThisType">tt1</a>.<a href="#148327" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#460183" title="Types.this.ThisType">tt2</a>.<a href="#148327" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="460188">st1</a>: <a href="#148357" title="Types.this.SingleType">SingleType</a> =&gt;
        <a href="#460159" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Unit" id="460189">st2</a>: <a href="#148357" title="Types.this.SingleType">SingleType</a> =&gt;
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#67576" title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean">equalSymsAndPrefixes</a><span class="delimiter">(</span><a href="#460188" title="Types.this.SingleType">st1</a>.<a href="#148372" title="=&gt; Types.this.Symbol">sym</a>, <a href="#460188" title="Types.this.SingleType">st1</a>.<a href="#148371" title="=&gt; Types.this.Type">pre</a>, <a href="#460189" title="Types.this.SingleType">st2</a>.<a href="#148372" title="=&gt; Types.this.Symbol">sym</a>, <a href="#460189" title="Types.this.SingleType">st2</a>.<a href="#148371" title="=&gt; Types.this.Type">pre</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="460190">ct1</a>: <a href="#148422" title="Types.this.ConstantType">ConstantType</a> =&gt;
        <a href="#460159" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Nothing" id="460191">ct2</a>: <a href="#148422" title="Types.this.ConstantType">ConstantType</a> =&gt;
            <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span><a href="#460190" title="Types.this.ConstantType">ct1</a>.<a href="#148430" title="=&gt; Types.this.Constant">value</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#460191" title="Types.this.ConstantType">ct2</a>.<a href="#148430" title="=&gt; Types.this.Constant">value</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="460196">rt1</a>: <a href="#148576" title="Types.this.RefinedType">RefinedType</a> =&gt;
        <a href="#460159" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Nothing" id="460197">rt2</a>: <a href="#148576" title="Types.this.RefinedType">RefinedType</a> =&gt; <span class="comment">// </span>
            <span class="keyword">def</span> <a title="(s1: Types.this.Scope, s2: Types.this.Scope)Boolean" id="460198">isSubScope</a><span class="delimiter">(</span><a title="Types.this.Scope" id="460199">s1</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a>, <a title="Types.this.Scope" id="460200">s2</a>: <a href="Scopes.scala.html#67691" title="Types.this.Scope">Scope</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#460200" title="Types.this.Scope">s2</a>.<a href="Scopes.scala.html#113097" title="=&gt; List[Types.this.Symbol]">toList</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">{</span>
              <a title="Types.this.Symbol" id="460209">sym2</a> =&gt;
                <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="460210">e1</a> = <a href="#460199" title="Types.this.Scope">s1</a>.<a href="Scopes.scala.html#113095" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#460209" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
                <span class="delimiter">(</span><a href="#460210" title="Types.this.ScopeEntry">e1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
                  <span class="keyword">val</span> <a title="Types.this.Type" id="460212">substSym</a> = <a href="#460209" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105506" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#460209" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>, <a href="#460210" title="Types.this.ScopeEntry">e1</a>.<a href="Scopes.scala.html#113275" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#107600" title="=&gt; Types.this.Type">thisType</a><span class="delimiter">)</span>
                  <span class="keyword">var</span> <a title="Boolean" id="460213">isEqual</a> = <span title="Boolean(false)" class="keyword">false</span>
                  <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#460213" title="Boolean">isEqual</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#460210" title="Types.this.ScopeEntry">e1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#460214" title="()Unit" class="delimiter">{</a> 
                    <a href="#460213" title="Boolean">isEqual</a> = <a href="#460210" title="Types.this.ScopeEntry">e1</a>.<a href="Scopes.scala.html#113275" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460212" title="Types.this.Type">substSym</a>
                    <a href="#460210" title="Types.this.ScopeEntry">e1</a> = <a href="#460199" title="Types.this.Scope">s1</a>.<a href="Scopes.scala.html#113096" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a><span class="delimiter">(</span><a href="#460210" title="Types.this.ScopeEntry">e1</a><span class="delimiter">)</span>
                  <span class="delimiter">}</span>
                  <a href="#460213" title="Boolean">isEqual</a>
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="comment">//Console.println(&quot;is same? &quot; + tp1 + &quot; &quot; + tp2 + &quot; &quot; + tp1.typeSymbol.owner + &quot; &quot; + tp2.typeSymbol.owner)//DEBUG</span>
            <span title="Nothing" class="keyword">return</span> <a href="#67583" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span><a href="#460196" title="Types.this.RefinedType">rt1</a>.<a href="#236369" title="=&gt; List[Types.this.Type]">parents</a>, <a href="#460197" title="Types.this.RefinedType">rt2</a>.<a href="#236369" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Scope" id="460218">decls1</a> = <a href="#460196" title="Types.this.RefinedType">rt1</a>.<a href="#236370" title="=&gt; Types.this.Scope">decls</a>
              <span class="keyword">val</span> <a title="Types.this.Scope" id="460219">decls2</a> = <a href="#460197" title="Types.this.RefinedType">rt2</a>.<a href="#236370" title="=&gt; Types.this.Scope">decls</a>
              <a href="#460198" title="(s1: Types.this.Scope, s2: Types.this.Scope)Boolean">isSubScope</a><span class="delimiter">(</span><a href="#460218" title="Types.this.Scope">decls1</a>, <a href="#460219" title="Types.this.Scope">decls2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460198" title="(s1: Types.this.Scope, s2: Types.this.Scope)Boolean">isSubScope</a><span class="delimiter">(</span><a href="#460219" title="Types.this.Scope">decls2</a>, <a href="#460218" title="Types.this.Scope">decls1</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="460220">mt1</a>: <a href="#148762" title="Types.this.MethodType">MethodType</a> =&gt;
        <a href="#460159" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Nothing" id="460221">mt2</a>: <a href="#148762" title="Types.this.MethodType">MethodType</a> =&gt;
            <span class="comment">// DEPMETTODO new dependent types: probably fix this, use substSym as done for PolyType</span>
            <span title="Nothing" class="keyword">return</span> <a href="#67583" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span><a href="#460220" title="Types.this.MethodType">mt1</a>.<a href="#148777" title="=&gt; List[Types.this.Type]">paramTypes</a>, <a href="#460221" title="Types.this.MethodType">mt2</a>.<a href="#148777" title="=&gt; List[Types.this.Type]">paramTypes</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <a href="#460220" title="Types.this.MethodType">mt1</a>.<a href="#151896" title="=&gt; Types.this.Type">resultType</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460221" title="Types.this.MethodType">mt2</a>.<a href="#151896" title="=&gt; Types.this.Type">resultType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <a href="#460220" title="Types.this.MethodType">mt1</a>.<a href="#148773" title="=&gt; Boolean">isImplicit</a> <span title="(x: Boolean)Boolean">==</span> <a href="#460221" title="Types.this.MethodType">mt2</a>.<a href="#148773" title="=&gt; Boolean">isImplicit</a>
          <span class="comment">// note: no case NullaryMethodType(restpe) =&gt; return mt1.params.isEmpty &amp;&amp; mt1.resultType =:= restpe</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Unit">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="460231">restpe1</a><span class="delimiter">)</span> =&gt;
        <a href="#460159" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="comment">// note: no case mt2: MethodType =&gt; return mt2.params.isEmpty &amp;&amp; restpe  =:= mt2.resultType</span>
          <span class="keyword">case</span> <span title="Nothing">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="460232">restpe2</a><span class="delimiter">)</span> =&gt;
            <span title="Nothing" class="keyword">return</span> <a href="#460231" title="Types.this.Type">restpe1</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460232" title="Types.this.Type">restpe2</a>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Unit">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460233">tparams1</a>, <a title="Types.this.Type" id="460234">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#460159" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Nothing">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460235">tparams2</a>, <a title="Types.this.Type" id="460236">res2</a><span class="delimiter">)</span> =&gt;
<span class="comment">//            assert((tparams1 map (_.typeParams.length)) == (tparams2 map (_.typeParams.length)))</span>
              <span class="comment">// @M looks like it might suffer from same problem as #2210</span>
              <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span>
                <span class="delimiter">(</span><a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#460233" title="List[Types.this.Symbol]">tparams1</a>, <a href="#460235" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="comment">// corresponds does not check length of two sequences before checking the predicate</span>
                <span class="delimiter">(</span><a href="#460233" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#460235" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#460256" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460257" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460235" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460233" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
                <a href="#460234" title="Types.this.Type">res1</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460236" title="Types.this.Type">res2</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460235" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460233" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>
              <span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Unit">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460258">tparams1</a>, <a title="Types.this.Type" id="460259">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#460159" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Nothing">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460260">tparams2</a>, <a title="Types.this.Type" id="460261">res2</a><span class="delimiter">)</span> =&gt;
            <span class="comment">// @M looks like it might suffer from same problem as #2210</span>
            <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span>
              <span class="comment">// corresponds does not check length of two sequences before checking the predicate -- faster &amp; needed to avoid crasher in #2956</span>
              <a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#460258" title="List[Types.this.Symbol]">tparams1</a>, <a href="#460260" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <span class="delimiter">(</span><a href="#460258" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#460260" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#460281" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460282" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460260" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460258" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <a href="#460259" title="Types.this.Type">res1</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460261" title="Types.this.Type">res2</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460260" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460258" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>
            <span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Unit">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="460283">lo1</a>, <a title="Types.this.Type" id="460284">hi1</a><span class="delimiter">)</span> =&gt;
        <a href="#460159" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Nothing">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="460285">lo2</a>, <a title="Types.this.Type" id="460286">hi2</a><span class="delimiter">)</span> =&gt;
            <span title="Nothing" class="keyword">return</span> <a href="#460283" title="Types.this.Type">lo1</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460285" title="Types.this.Type">lo2</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460284" title="Types.this.Type">hi1</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460286" title="Types.this.Type">hi2</a>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Nothing">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="460287">bounds</a><span class="delimiter">)</span> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="#460287" title="Types.this.TypeBounds">bounds</a> <a href="#148513" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#460159" title="Types.this.Type">tp2</a>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#460159" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Nothing">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="460288">bounds</a><span class="delimiter">)</span> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="#460288" title="Types.this.TypeBounds">bounds</a> <a href="#148513" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#460158" title="Types.this.Type">tp1</a>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#460158" title="Types.this.Type">tp1</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Nothing" id="460289">tv</a> @ <a href="#448979" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="#460289" title="Types.this.TypeVar">tv</a>.<a href="#449014" title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean">registerTypeEquality</a><span class="delimiter">(</span><a href="#460159" title="Types.this.Type">tp2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#460159" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Nothing" id="460291">tv</a> @ <a href="#448979" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="#460291" title="Types.this.TypeVar">tv</a>.<a href="#449014" title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean">registerTypeEquality</a><span class="delimiter">(</span><a href="#460158" title="Types.this.Type">tp1</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#460158" title="Types.this.Type">tp1</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Nothing">_</span>: <a href="#149016" title="Types.this.AnnotatedType">AnnotatedType</a> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="AnnotationCheckers.scala.html#67770" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#460158" title="Types.this.Type">tp1</a>, <a href="#460159" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#67770" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#460159" title="Types.this.Type">tp2</a>, <a href="#460158" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460158" title="Types.this.Type">tp1</a>.<a href="#105544" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460159" title="Types.this.Type">tp2</a>.<a href="#105544" title="=&gt; Types.this.Type">withoutAnnotations</a>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#460159" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Nothing">_</span>: <a href="#149016" title="Types.this.AnnotatedType">AnnotatedType</a> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="AnnotationCheckers.scala.html#67770" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#460158" title="Types.this.Type">tp1</a>, <a href="#460159" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#67770" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#460159" title="Types.this.Type">tp2</a>, <a href="#460158" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460158" title="Types.this.Type">tp1</a>.<a href="#105544" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460159" title="Types.this.Type">tp2</a>.<a href="#105544" title="=&gt; Types.this.Type">withoutAnnotations</a>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#460158" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="#67398" title="Types.this.SingletonType">SingletonType</a> =&gt;
        <a href="#460159" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="#67398" title="Types.this.SingletonType">SingletonType</a> =&gt;
            @inline <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="460295">chaseDealiasedUnderlying</a><span class="delimiter">(</span><a title="Types.this.Type" id="460298">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
              <span class="keyword">var</span> <a title="Types.this.Type" id="460299">origin</a> = <a href="#460298" title="Types.this.Type">tp</a>
              <span class="keyword">var</span> <a title="Types.this.Type" id="460300">next</a> = <a href="#460299" title="Types.this.Type">origin</a>.<a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105484" title="=&gt; Types.this.Type">dealias</a>
              <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#460300" title="Types.this.Type">next</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#67398" title="Types.this.SingletonType">SingletonType</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#460301" title="()Unit" class="delimiter">{</a>
                <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#460299" title="Types.this.Type">origin</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#460300" title="Types.this.Type">next</a>, <a href="#460299" title="Types.this.Type">origin</a><span class="delimiter">)</span>
                <a href="#460299" title="Types.this.Type">origin</a> = <a href="#460300" title="Types.this.Type">next</a>
                <a href="#460300" title="Types.this.Type">next</a> = <a href="#460299" title="Types.this.Type">origin</a>.<a href="#105457" title="=&gt; Types.this.Type">underlying</a>.<a href="#105484" title="=&gt; Types.this.Type">dealias</a>
              <span class="delimiter">}</span>
              <a href="#460299" title="Types.this.Type">origin</a>
            <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="460296">origin1</a> = <a href="#460295" title="(tp: Types.this.Type)Types.this.Type">chaseDealiasedUnderlying</a><span class="delimiter">(</span><a href="#460158" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="460297">origin2</a> = <a href="#460295" title="(tp: Types.this.Type)Types.this.Type">chaseDealiasedUnderlying</a><span class="delimiter">(</span><a href="#460159" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
            <span class="delimiter">(</span><span class="delimiter">(</span><a href="#460296" title="Types.this.Type">origin1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#460158" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#460297" title="Types.this.Type">origin2</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#460159" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#460296" title="Types.this.Type">origin1</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460297" title="Types.this.Type">origin2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
        <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Are `tps1' and `tps2' lists of pairwise equivalent
   *  types?
   */</span>
  <span class="keyword">def</span> <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean" id="67583">isSameTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="460165">tps1</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="460166">tps2</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#460165" title="List[Types.this.Type]">tps1</a> <span title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.Type, Types.this.Type) =&gt; Boolean)Boolean">corresponds</span> <a href="#460166" title="List[Types.this.Type]">tps2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#460321" title="Types.this.Type">_</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460322" title="Types.this.Type">_</a><span class="delimiter">)</span>

  <span class="comment">/** True if two lists have the same length.  Since calling length on linear sequences
   *  is O(n), it is an inadvisable way to test length equality.
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(xs1: List[_], xs2: List[_])Boolean" id="67584">sameLength</a><span class="delimiter">(</span><a title="List[_]" id="262084">xs1</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="List[_]" id="262085">xs2</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#67585" title="(xs1: List[_], xs2: List[_])Int">compareLengths</a><span class="delimiter">(</span><a href="#262084" title="List[_]">xs1</a>, <a href="#262085" title="List[_]">xs2</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span>
  @tailrec <span class="keyword">final</span> <span class="keyword">def</span> <a title="(xs1: List[_], xs2: List[_])Int" id="67585">compareLengths</a><span class="delimiter">(</span><a title="List[_]" id="262088">xs1</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="List[_]" id="262089">xs2</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> =
    <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#262088" title="List[_]">xs1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#262089" title="List[_]">xs2</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> <span class="keyword">else</span> -<span title="Int(-1)" class="int">1</span> <span class="delimiter">}</span>
    <span class="keyword">else</span> <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#262089" title="List[_]">xs2</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="Int(1)" class="int">1</span>
    <span class="keyword">else</span> <a href="#67585" title="(xs1: List[_], xs2: List[_])Int">compareLengths</a><span class="delimiter">(</span><a href="#262088" title="List[_]">xs1</a>.<span title="=&gt; List[Any]">tail</span>, <a href="#262089" title="List[_]">xs2</a>.<span title="=&gt; List[Any]">tail</span><span class="delimiter">)</span>
  
  <span class="comment">/** Again avoiding calling length, but the lengthCompare interface is clunky.
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(xs: List[_], len: Int)Boolean" id="67586">hasLength</a><span class="delimiter">(</span><a title="List[_]" id="453405">xs</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Int" id="453406">len</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#453405" title="List[_]">xs</a>.<span title="(len: Int)Int">lengthCompare</span><span class="delimiter">(</span><a href="#453406" title="Int">len</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span>
  
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.SubTypePair]" id="67587">pendingSubTypes</a> = <span title="()scala.collection.mutable.HashSet[Types.this.SubTypePair]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Types.this.SubTypePair]">HashSet</span><span class="delimiter">[</span>SubTypePair<span class="delimiter">]</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="67590">basetypeRecursions</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.Type]" id="67592">pendingBaseTypes</a> = <span title="()scala.collection.mutable.HashSet[Types.this.Type]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Types.this.Type]">HashSet</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67594">isSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="424719">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="424720">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#67595" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#424719" title="Types.this.Type">tp1</a>, <a href="#424720" title="Types.this.Type">tp2</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean" id="67595">isSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="424712">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="424713">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Int" id="424714">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="#67572" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>

    <a href="#67383" title="object Types.this.undoLog">undoLog</a> <a href="#106886" title="(block: =&gt; Boolean)Boolean">undoUnless</a> <span class="delimiter">{</span> <span class="comment">// if subtype test fails, it should not affect constraints on typevars</span>
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67572" title="=&gt; Int">subsametypeRecursions</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(50)">LogPendingSubTypesThreshold</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.SubTypePair" id="460342">p</a> = <span title="Types.this.SubTypePair" class="keyword">new</span> <a href="#67565" title="Types.this.SubTypePair">SubTypePair</a><span class="delimiter">(</span><a href="#424712" title="Types.this.Type">tp1</a>, <a href="#424713" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67587" title="(elem: Types.this.SubTypePair)Boolean">pendingSubTypes</a><span class="delimiter">(</span><a href="#460342" title="Types.this.SubTypePair">p</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">else</span> 
          <span class="keyword">try</span> <span class="delimiter">{</span>
            <a href="#67587" title="=&gt; scala.collection.mutable.HashSet[Types.this.SubTypePair]">pendingSubTypes</a> <span title="(elem: Types.this.SubTypePair)Types.this.pendingSubTypes.type">+=</span> <a href="#460342" title="Types.this.SubTypePair">p</a>
            <a href="#67612" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType2</a><span class="delimiter">(</span><a href="#424712" title="Types.this.Type">tp1</a>, <a href="#424713" title="Types.this.Type">tp2</a>, <a href="#424714" title="Int">depth</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            <a href="#67587" title="=&gt; scala.collection.mutable.HashSet[Types.this.SubTypePair]">pendingSubTypes</a> <span title="(elem: Types.this.SubTypePair)Types.this.pendingSubTypes.type">-=</span> <a href="#460342" title="Types.this.SubTypePair">p</a>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#67612" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType2</a><span class="delimiter">(</span><a href="#424712" title="Types.this.Type">tp1</a>, <a href="#424713" title="Types.this.Type">tp2</a>, <a href="#424714" title="Int">depth</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#67572" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
    <span class="comment">// XXX AM TODO: figure out when it is safe and needed to clear the log -- the commented approach below is too eager (it breaks #3281, #3866)</span>
    <span class="comment">// it doesn't help to keep separate recursion counts for the three methods that now share it</span>
    <span class="comment">// if (subsametypeRecursions == 0) undoLog.clear()</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Does this type have a prefix that begins with a type variable,
   *  or is it a refinement type? For type prefixes that fulfil this condition,
   *  type selections with the same name of equal (wrt) =:= prefixes are
   *  considered equal wrt =:=
   */</span>
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="67596">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a title="Types.this.Type" id="460093">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#460093" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="460387">pre</a>, <a title="Types.this.Symbol" id="460388">sym</a><span class="delimiter">)</span> =&gt;
      <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#460388" title="Types.this.Symbol">sym</a> <span title="(mask: Long)Boolean">hasFlag</span> <span title="Long(16384L)">PACKAGE</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67596" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#460387" title="Types.this.Type">pre</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="Boolean" id="460389">tv</a>@<a href="#448979" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="460391">constr</a><span class="delimiter">)</span> =&gt;
      <span title="=&gt; Boolean">!</span><a href="#460389" title="Types.this.TypeVar">tv</a>.<a href="#449003" title="=&gt; Boolean">instValid</a> <span title="(x: Boolean)Boolean">||</span> <a href="#67596" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#460391" title="Types.this.TypeConstraint">constr</a>.<a href="#449389" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Boolean(true)">RefinedType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; 
      <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
      <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="67597">instTypeVar</a><span class="delimiter">(</span><a title="Types.this.Type" id="460392">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#460392" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="460394">pre</a>, <a title="Types.this.Symbol" id="460395">sym</a>, <a title="List[Types.this.Type]" id="460396">args</a><span class="delimiter">)</span> =&gt;
      <a href="#67484" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#460392" title="Types.this.Type">tp</a>, <a href="#67597" title="(tp: Types.this.Type)Types.this.Type">instTypeVar</a><span class="delimiter">(</span><a href="#460394" title="Types.this.Type">pre</a><span class="delimiter">)</span>, <a href="#460395" title="Types.this.Symbol">sym</a>, <a href="#460396" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="460397">pre</a>, <a title="Types.this.Symbol" id="460398">sym</a><span class="delimiter">)</span> =&gt;
      <a href="#67479" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#67597" title="(tp: Types.this.Type)Types.this.Type">instTypeVar</a><span class="delimiter">(</span><a href="#460397" title="Types.this.Type">pre</a><span class="delimiter">)</span>, <a href="#460398" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a href="#448979" title="Types.this.Type">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="460400">constr</a><span class="delimiter">)</span> =&gt;
      <a href="#67597" title="(tp: Types.this.Type)Types.this.Type">instTypeVar</a><span class="delimiter">(</span><a href="#460400" title="Types.this.TypeConstraint">constr</a>.<a href="#449389" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <a href="#460392" title="Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="67598">isErrorOrWildcard</a><span class="delimiter">(</span><a title="Types.this.Type" id="460401">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#460401" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450846" title="object Types.this.ErrorType">ErrorType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#460401" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450864" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="67599">isSingleType</a><span class="delimiter">(</span><a title="Types.this.Type" id="460404">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#460404" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean(true)">ThisType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> | SuperType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> | SingleType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="67600">isConstantType</a><span class="delimiter">(</span><a title="Types.this.Type" id="402863">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#402863" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean(true)">ConstantType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>

  <span class="comment">// @assume tp1.isHigherKinded || tp2.isHigherKinded</span>
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean" id="67601">isHKSubType0</a><span class="delimiter">(</span><a title="Types.this.Type" id="460407">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460408">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Int" id="460409">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span>
    <a href="#460407" title="Types.this.Type">tp1</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a> 
    <span title="(x: Boolean)Boolean">||</span>
    <a href="#460408" title="Types.this.Type">tp2</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a> <span class="comment">// @M Any and Nothing are super-type resp. subtype of every well-kinded type</span>
    <span title="(x: Boolean)Boolean">||</span> <span class="comment">// @M! normalize reduces higher-kinded case to PolyType's</span>
    <span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#460407" title="Types.this.Type">tp1</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a>.<a href="#105544" title="=&gt; Types.this.Type">withoutAnnotations</a> , <a href="#460408" title="Types.this.Type">tp2</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a>.<a href="#105544" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460429">tparams1</a>, <a title="Types.this.Type" id="460430">res1</a><span class="delimiter">)</span>, PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460431">tparams2</a>, <a title="Types.this.Type" id="460432">res2</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span class="comment">// @assume tp1.isHigherKinded &amp;&amp; tp2.isHigherKinded (as they were both normalized to PolyType)</span>
        <a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#460429" title="List[Types.this.Symbol]">tparams1</a>, <a href="#460431" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460429" title="List[Types.this.Symbol]">tparams1</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>.<span title="=&gt; Boolean">isMethod</span><span class="delimiter">)</span> <span class="delimiter">{</span>  <span class="comment">// fast-path: polymorphic method type -- type params cannot be captured</span>
            <span class="delimiter">(</span><a href="#460429" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#460431" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="460453">p1</a>, <a title="Types.this.Symbol" id="460454">p2</a><span class="delimiter">)</span> =&gt; <a href="#460454" title="Types.this.Symbol">p2</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460431" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460429" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460453" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#460430" title="Types.this.Type">res1</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460432" title="Types.this.Type">res2</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460431" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460429" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span> <span class="comment">// normalized higher-kinded type</span>
            <span class="comment">//@M for an example of why we need to generate fresh symbols, see neg/tcpoly_ticket2101.scala</span>
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="460455">tpsFresh</a> = <a href="Symbols.scala.html#67341" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#460429" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>

            <span class="delimiter">(</span><a href="#460429" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#460431" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="460505">p1</a>, <a title="Types.this.Symbol" id="460506">p2</a><span class="delimiter">)</span> =&gt;
              <a href="#460506" title="Types.this.Symbol">p2</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460431" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460455" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460505" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460429" title="List[Types.this.Symbol]">tparams1</a>, <a href="#460455" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#460430" title="Types.this.Type">res1</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460429" title="List[Types.this.Symbol]">tparams1</a>, <a href="#460455" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460432" title="Types.this.Type">res2</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460431" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460455" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span>

            <span class="comment">//@M the forall in the previous test could be optimised to the following,</span>
            <span class="comment">// but not worth the extra complexity since it only shaves 1s from quick.comp</span>
            <span class="comment">//   (List.forall2(tpsFresh/*optimisation*/, tparams2)((p1, p2) =&gt;</span>
            <span class="comment">//   p2.info.substSym(tparams2, tpsFresh) &lt;:&lt; p1.info /*optimisation, == (p1 from tparams1).info.substSym(tparams1, tpsFresh)*/) &amp;&amp;</span>
            <span class="comment">// this optimisation holds because inlining cloneSymbols in `val tpsFresh = cloneSymbols(tparams1)` gives:</span>
            <span class="comment">// val tpsFresh = tparams1 map (_.cloneSymbol)</span>
            <span class="comment">// for (tpFresh &lt;- tpsFresh) tpFresh.setInfo(tpFresh.info.substSym(tparams1, tpsFresh))</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#67770" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#460407" title="Types.this.Type">tp1</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a>, <a href="#460408" title="Types.this.Type">tp2</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean(false)" class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <span title="Boolean(false)" class="keyword">false</span> <span class="comment">// @assume !tp1.isHigherKinded || !tp2.isHigherKinded </span>
      <span class="comment">// --&gt; thus, cannot be subtypes (Any/Nothing has already been checked)</span>
    <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** True if all three arguments have the same number of elements and
   *  the function is true for all the triples.
   */</span>
  @tailrec <span class="keyword">final</span> <span class="keyword">def</span> <a title="[A, B, C](xs1: List[A], xs2: List[B], xs3: List[C], f: (A, B, C) =&gt; Boolean)Boolean" id="67602">corresponds3</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67606">A</a>, <a title="&gt;: Nothing &lt;: Any" id="67607">B</a>, <a title="&gt;: Nothing &lt;: Any" id="67608">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[A]" id="460509">xs1</a>: <span title="List[A]">List</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="List[B]" id="460510">xs2</a>: <span title="List[B]">List</span><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a title="List[C]" id="460511">xs3</a>: <span title="List[C]">List</span><span class="delimiter">[</span>C<span class="delimiter">]</span>, <a title="(A, B, C) =&gt; Boolean" id="460512">f</a>: <span class="delimiter">(</span>A, B, C<span class="delimiter">)</span> =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460509" title="List[A]">xs1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#460510" title="List[B]">xs2</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460511" title="List[C]">xs3</a>.<span title="=&gt; Boolean">isEmpty</span>
    <span class="keyword">else</span> <span title="=&gt; Boolean">!</span><a href="#460510" title="List[B]">xs2</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#460511" title="List[C]">xs3</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460512" title="(v1: A, v2: B, v3: C)Boolean">f</a><span class="delimiter">(</span><a href="#460509" title="List[A]">xs1</a>.<span title="=&gt; A">head</span>, <a href="#460510" title="List[B]">xs2</a>.<span title="=&gt; B">head</span>, <a href="#460511" title="List[C]">xs3</a>.<span title="=&gt; C">head</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67602" title="(xs1: List[A], xs2: List[B], xs3: List[C], f: (A, B, C) =&gt; Boolean)Boolean">corresponds3</a><span class="delimiter">(</span><a href="#460509" title="List[A]">xs1</a>.<span title="=&gt; List[A]">tail</span>, <a href="#460510" title="List[B]">xs2</a>.<span title="=&gt; List[B]">tail</span>, <a href="#460511" title="List[C]">xs3</a>.<span title="=&gt; List[C]">tail</span>, <a href="#460512" title="(A, B, C) =&gt; Boolean">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">def</span> <a title="(t1: Types.this.Type, t2: Types.this.Type, variance: Int)Boolean" id="67609">isSubArg</a><span class="delimiter">(</span><a title="Types.this.Type" id="460571">t1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460572">t2</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Int" id="460573">variance</a>: <span title="Int">Int</span><span class="delimiter">)</span> =
    <span class="delimiter">(</span><a href="#460573" title="Int">variance</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#460572" title="Types.this.Type">t2</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460571" title="Types.this.Type">t1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#460573" title="Int">variance</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#460571" title="Types.this.Type">t1</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460572" title="Types.this.Type">t2</a><span class="delimiter">)</span>
    
  <span class="keyword">def</span> <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean" id="67610">isSubArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="455289">tps1</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="455290">tps2</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="455291">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#67602" title="(xs1: List[Types.this.Type], xs2: List[Types.this.Type], xs3: List[Int], f: (Types.this.Type, Types.this.Type, Int) =&gt; Boolean)Boolean">corresponds3</a><span class="delimiter">(</span><a href="#455289" title="List[Types.this.Type]">tps1</a>, <a href="#455290" title="List[Types.this.Type]">tps2</a>, <a href="#455291" title="List[Types.this.Symbol]">tparams</a> <span title="(f: Types.this.Symbol =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Int,List[Int]])List[Int]">map</span> <span class="delimiter">(</span><a href="#460618" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107540" title="=&gt; Int">variance</a><span class="delimiter">)</span>, <a href="#67609" title="(t1: Types.this.Type, t2: Types.this.Type, variance: Int)Boolean">isSubArg</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Types.this.Type" id="67611">differentOrNone</a><span class="delimiter">(</span><a title="Types.this.Type" id="460687">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460688">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#460687" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#460688" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <a href="#450913" title="object Types.this.NoType">NoType</a> <span class="keyword">else</span> <a href="#460687" title="Types.this.Type">tp1</a>

  <span class="comment">/** Does type `tp1' conform to `tp2'?
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean" id="67612">isSubType2</a><span class="delimiter">(</span><a title="Types.this.Type" id="460371">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460372">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Int" id="460373">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#460372" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#67598" title="(tp: Types.this.Type)Boolean">isErrorOrWildcard</a><span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#67598" title="(tp: Types.this.Type)Boolean">isErrorOrWildcard</a><span class="delimiter">(</span><a href="#460372" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(true)" class="keyword">true</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#460372" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(false)" class="keyword">false</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span><a href="#460372" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#460372" title="Types.this.Type">tp2</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isPackageClass</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#460372" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450935" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#460371" title="Types.this.Type">tp1</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isPackageClass</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#67599" title="(tp: Types.this.Type)Boolean">isSingleType</a><span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67599" title="(tp: Types.this.Type)Boolean">isSingleType</a><span class="delimiter">(</span><a href="#460372" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#67600" title="(tp: Types.this.Type)Boolean">isConstantType</a><span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67600" title="(tp: Types.this.Type)Boolean">isConstantType</a><span class="delimiter">(</span><a href="#460372" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#460371" title="Types.this.Type">tp1</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460372" title="Types.this.Type">tp2</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a>.<a href="#105445" title="=&gt; Boolean">isHigherKinded</a> <span title="(x: Boolean)Boolean">||</span> <a href="#460372" title="Types.this.Type">tp2</a>.<a href="#105445" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#67601" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isHKSubType0</a><span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a>, <a href="#460372" title="Types.this.Type">tp2</a>, <a href="#460373" title="Int">depth</a><span class="delimiter">)</span>

    <span class="comment">/** First try, on the right:
     *   - unwrap Annotated types, BoundedWildcardTypes,
     *   - bind TypeVars  on the right, if lhs is not Annotated nor BoundedWildcard
     *   - handle common cases for first-kind TypeRefs on both sides as a fast path.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="460691">firstTry</a> = <span class="delimiter">{</span> <a href="../util/Statistics.scala.html#67162" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67297" title="=&gt; scala.tools.nsc.util.Statistics.Counter">ctr1</a><span class="delimiter">)</span>; <a href="#460372" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="comment">// fast path: two typerefs, none of them HK</span>
      <span class="keyword">case</span> <a title="Boolean" id="460698">tr2</a>: <a href="#133603" title="Types.this.TypeRef">TypeRef</a> =&gt;
        <a href="#460371" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="460699">tr1</a>: <a href="#133603" title="Types.this.TypeRef">TypeRef</a> =&gt;
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="460700">sym1</a> = <a href="#460699" title="Types.this.TypeRef">tr1</a>.<a href="#133632" title="=&gt; Types.this.Symbol">sym</a>
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="460701">sym2</a> = <a href="#460698" title="Types.this.TypeRef">tr2</a>.<a href="#133632" title="=&gt; Types.this.Symbol">sym</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="460702">pre1</a> = <a href="#460699" title="Types.this.TypeRef">tr1</a>.<a href="#133631" title="=&gt; Types.this.Type">pre</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="460703">pre2</a> = <a href="#460698" title="Types.this.TypeRef">tr2</a>.<a href="#133631" title="=&gt; Types.this.Type">pre</a>
            <span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460700" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#460701" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> <a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#460702" title="Types.this.Type">pre1</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460703" title="Types.this.Type">pre2</a>
               <span class="keyword">else</span> <span class="delimiter">(</span><a href="#460700" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#460701" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#460700" title="Types.this.Symbol">sym1</a>.<span title="=&gt; Boolean">isModuleClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#460701" title="Types.this.Symbol">sym2</a>.<span title="=&gt; Boolean">isModuleClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                     <span class="delimiter">(</span><a href="#67574" title="(pre1: Types.this.Type, pre2: Types.this.Type)Boolean">isUnifiable</a><span class="delimiter">(</span><a href="#460702" title="Types.this.Type">pre1</a>, <a href="#460703" title="Types.this.Type">pre2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#67575" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol, pre1: Types.this.Type, pre2: Types.this.Type)Boolean">isSameSpecializedSkolem</a><span class="delimiter">(</span><a href="#460700" title="Types.this.Symbol">sym1</a>, <a href="#460701" title="Types.this.Symbol">sym2</a>, <a href="#460702" title="Types.this.Type">pre1</a>, <a href="#460703" title="Types.this.Type">pre2</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                    <a href="#67610" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean">isSubArgs</a><span class="delimiter">(</span><a href="#460699" title="Types.this.TypeRef">tr1</a>.<a href="#133633" title="=&gt; List[Types.this.Type]">args</a>, <a href="#460698" title="Types.this.TypeRef">tr2</a>.<a href="#133633" title="=&gt; List[Types.this.Type]">args</a>, <a href="#460700" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span><span class="delimiter">)</span>
             <span title="(x: Boolean)Boolean">||</span>
             <a href="#460701" title="Types.this.Symbol">sym2</a>.<span title="=&gt; Boolean">isClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
               <span class="keyword">val</span> <a title="Types.this.Type" id="460713">base</a> = <a href="#460699" title="Types.this.TypeRef">tr1</a> <a href="#133595" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a> <a href="#460701" title="Types.this.Symbol">sym2</a>
               <span class="delimiter">(</span><a href="#460713" title="Types.this.Type">base</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#460699" title="Types.this.TypeRef">tr1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460713" title="Types.this.Type">base</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460698" title="Types.this.TypeRef">tr2</a>
             <span class="delimiter">}</span>
             <span title="(x: Boolean)Boolean">||</span>
             <a href="#460693" title="(tp1: Types.this.Type, tp2: Types.this.TypeRef)Boolean">thirdTryRef</a><span class="delimiter">(</span><a href="#460699" title="Types.this.TypeRef">tr1</a>, <a href="#460698" title="Types.this.TypeRef">tr2</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#460692" title="=&gt; Boolean">secondTry</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">AnnotatedType</span><span class="delimiter">(</span>_, _, _<span class="delimiter">)</span> =&gt;
        <a href="#460371" title="Types.this.Type">tp1</a>.<a href="#105544" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460372" title="Types.this.Type">tp2</a>.<a href="#105544" title="=&gt; Types.this.Type">withoutAnnotations</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#67770" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a>, <a href="#460372" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="460822">bounds</a><span class="delimiter">)</span> =&gt;
        <a href="#460371" title="Types.this.Type">tp1</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460822" title="Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a>
      <span class="keyword">case</span> <a title="Boolean" id="460823">tv2</a> @ <a href="#448979" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="460825">constr2</a><span class="delimiter">)</span> =&gt;
        <a href="#460371" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">AnnotatedType</span><span class="delimiter">(</span>_, _, _<span class="delimiter">)</span> | BoundedWildcardType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
            <a href="#460692" title="=&gt; Boolean">secondTry</a>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#460823" title="Types.this.TypeVar">tv2</a>.<a href="#449013" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#460692" title="=&gt; Boolean">secondTry</a>
    <span class="delimiter">}</span><span class="delimiter">}</span>

    <span class="comment">/** Second try, on the left:
     *   - unwrap AnnotatedTypes, BoundedWildcardTypes,
     *   - bind typevars,
     *   - handle existential types by skolemization.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="460692">secondTry</a> = <span class="delimiter">{</span> <a href="../util/Statistics.scala.html#67162" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67299" title="=&gt; scala.tools.nsc.util.Statistics.Counter">ctr2</a><span class="delimiter">)</span>; <a href="#460371" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">AnnotatedType</span><span class="delimiter">(</span>_, _, _<span class="delimiter">)</span> =&gt;
        <a href="#460371" title="Types.this.Type">tp1</a>.<a href="#105544" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460372" title="Types.this.Type">tp2</a>.<a href="#105544" title="=&gt; Types.this.Type">withoutAnnotations</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#67770" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a>, <a href="#460372" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="460718">bounds</a><span class="delimiter">)</span> =&gt;
        <a href="#460371" title="Types.this.Type">tp1</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148531" title="=&gt; Types.this.Type">lo</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460372" title="Types.this.Type">tp2</a>
      <span class="keyword">case</span> <a title="Boolean" id="460719">tv</a> @ <a href="#448979" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt;
        <a href="#460719" title="Types.this.TypeVar">tv</a>.<a href="#449013" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#460372" title="Types.this.Type">tp2</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
        <span class="keyword">try</span> <span class="delimiter">{</span> 
          <a href="#67381" title="(x$1: Int)Unit">skolemizationLevel</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
          <a href="#460371" title="Types.this.Type">tp1</a>.<a href="#105482" title="=&gt; Types.this.Type">skolemizeExistential</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460372" title="Types.this.Type">tp2</a>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
          <a href="#67381" title="(x$1: Int)Unit">skolemizationLevel</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#460694" title="=&gt; Boolean">thirdTry</a>
    <span class="delimiter">}</span><span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.TypeRef)Boolean" id="460693">thirdTryRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="460714">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.TypeRef" id="460715">tp2</a>: <a href="#133603" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span> 
      <a href="../util/Statistics.scala.html#67162" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67301" title="=&gt; scala.tools.nsc.util.Statistics.Counter">ctr3</a><span class="delimiter">)</span>; 
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="460826">sym2</a> = <a href="#460715" title="Types.this.TypeRef">tp2</a>.<a href="#133632" title="=&gt; Types.this.Symbol">sym</a>
      <a href="#460826" title="Types.this.Symbol">sym2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="Definitions.scala.html#106336" title="Boolean">NotNullClass</a> =&gt; <a href="#460714" title="Types.this.Type">tp1</a>.<a href="#105448" title="=&gt; Boolean">isNotNull</a>
        <span class="keyword">case</span> <a href="Definitions.scala.html#106344" title="Boolean">SingletonClass</a> =&gt; <a href="#460714" title="Types.this.Type">tp1</a>.<a href="#105446" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">||</span> <a href="#460695" title="=&gt; Boolean">fourthTry</a>
        <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="Symbols.scala.html#67337" title="Types.this.ClassSymbol">ClassSymbol</a> =&gt;
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67526" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><span class="delimiter">(</span><a href="#460826" title="Types.this.Symbol">sym2</a>, <a href="#460715" title="Types.this.TypeRef">tp2</a>.<a href="#133633" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#67595" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#460714" title="Types.this.Type">tp1</a>, <a href="#258577" title="(tp: Types.this.Type)Types.this.Type">rawToExistential</a><span class="delimiter">(</span><a href="#460715" title="Types.this.TypeRef">tp2</a><span class="delimiter">)</span>, <a href="#460373" title="Int">depth</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460826" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#67720" title="object Types.this.tpnme">tpnme</a>.<span title="=&gt; Types.this.tpnme.NameType">REFINE_CLASS_NAME</span><span class="delimiter">)</span>
            <a href="#67595" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#460714" title="Types.this.Type">tp1</a>, <a href="#460826" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>, <a href="#460373" title="Int">depth</a><span class="delimiter">)</span>
          <span class="keyword">else</span>
            <a href="#460695" title="=&gt; Boolean">fourthTry</a>
        <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="Symbols.scala.html#67335" title="Types.this.TypeSymbol">TypeSymbol</a> =&gt;
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460826" title="Types.this.Symbol">sym2</a> <span title="(mask: Long)Boolean">hasFlag</span> <span title="Long(16L)">DEFERRED</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="460842">tp2a</a> = <a href="#460715" title="Types.this.TypeRef">tp2</a>.<a href="#133576" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148531" title="=&gt; Types.this.Type">lo</a>
            <a href="#67579" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isDifferentTypeConstructor</a><span class="delimiter">(</span><a href="#460715" title="Types.this.TypeRef">tp2</a>, <a href="#460842" title="Types.this.Type">tp2a</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460714" title="Types.this.Type">tp1</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460842" title="Types.this.Type">tp2a</a> <span title="(x: Boolean)Boolean">||</span> <a href="#460695" title="=&gt; Boolean">fourthTry</a>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <a href="#67595" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#460714" title="Types.this.Type">tp1</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a>, <a href="#460715" title="Types.this.TypeRef">tp2</a>.<a href="#133593" title="=&gt; Types.this.Type">normalize</a>, <a href="#460373" title="Int">depth</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
          <a href="#460695" title="=&gt; Boolean">fourthTry</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    
    <span class="comment">/** Third try, on the right:
     *   - decompose refined types.
     *   - handle typerefs, existentials, and notnull types.
     *   - handle left+right method types, polytypes, typebounds
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="460694">thirdTry</a> = <span class="delimiter">{</span> <a href="../util/Statistics.scala.html#67162" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67301" title="=&gt; scala.tools.nsc.util.Statistics.Counter">ctr3</a><span class="delimiter">)</span>; <a href="#460372" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="460733">tr2</a>: <a href="#133603" title="Types.this.TypeRef">TypeRef</a> =&gt;
        <a href="#460693" title="(tp1: Types.this.Type, tp2: Types.this.TypeRef)Boolean">thirdTryRef</a><span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a>, <a href="#460733" title="Types.this.TypeRef">tr2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Boolean" id="460734">rt2</a>: <a href="#148576" title="Types.this.RefinedType">RefinedType</a> =&gt;
        <span class="delimiter">(</span><a href="#460734" title="Types.this.RefinedType">rt2</a>.<a href="#236369" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460741" title="Types.this.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <span class="delimiter">(</span><a href="#460734" title="Types.this.RefinedType">rt2</a>.<a href="#236370" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113097" title="=&gt; List[Types.this.Symbol]">toList</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <a href="#460371" title="Types.this.Type">tp1</a>.<a href="#105521" title="(sym: Types.this.Symbol)Boolean">specializes</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Boolean" id="460751">et2</a>: <a href="#149138" title="Types.this.ExistentialType">ExistentialType</a> =&gt;
        <a href="#460751" title="Types.this.ExistentialType">et2</a>.<a href="#149167" title="(op: Types.this.Type =&gt; Boolean, depth: Int)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460755" title="Types.this.Type">_</a>, <a href="#460373" title="Int">depth</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#460695" title="=&gt; Boolean">fourthTry</a>
      <span class="keyword">case</span> <a title="Boolean" id="460791">nn2</a>: <a href="#449814" title="Types.this.NotNullType">NotNullType</a> =&gt;
        <a href="#460371" title="Types.this.Type">tp1</a>.<a href="#105448" title="=&gt; Boolean">isNotNull</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460371" title="Types.this.Type">tp1</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460791" title="Types.this.NotNullType">nn2</a>.<a href="#449828" title="=&gt; Types.this.Type">underlying</a>
      <span class="keyword">case</span> <a title="Boolean" id="460792">mt2</a>: <a href="#148762" title="Types.this.MethodType">MethodType</a> =&gt;
        <a href="#460371" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="460793">mt1</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460794">params1</a>, <a title="Types.this.Type" id="460795">res1</a><span class="delimiter">)</span> =&gt;
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="460796">params2</a> = <a href="#460792" title="Types.this.MethodType">mt2</a>.<a href="#151895" title="=&gt; List[Types.this.Symbol]">params</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="460797">res2</a> = <a href="#460792" title="Types.this.MethodType">mt2</a>.<a href="#151896" title="=&gt; Types.this.Type">resultType</a>
            <span class="delimiter">(</span><a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#460794" title="List[Types.this.Symbol]">params1</a>, <a href="#460796" title="List[Types.this.Symbol]">params2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
             <a href="#67617" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span><a href="#460794" title="List[Types.this.Symbol]">params1</a>, <a href="#460796" title="List[Types.this.Symbol]">params2</a>, <a href="#460793" title="Types.this.MethodType">mt1</a>.<a href="#148774" title="=&gt; Boolean">isJava</a>, <a href="#460792" title="Types.this.MethodType">mt2</a>.<a href="#148774" title="=&gt; Boolean">isJava</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
             <span class="delimiter">(</span><a href="#460795" title="Types.this.Type">res1</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460797" title="Types.this.Type">res2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
             <a href="#460793" title="Types.this.MethodType">mt1</a>.<a href="#148773" title="=&gt; Boolean">isImplicit</a> <span title="(x: Boolean)Boolean">==</span> <a href="#460792" title="Types.this.MethodType">mt2</a>.<a href="#148773" title="=&gt; Boolean">isImplicit</a><span class="delimiter">)</span>
          <span class="comment">// TODO: if mt1.params.isEmpty, consider NullaryMethodType?</span>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Boolean" id="460812">pt2</a> @ NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
        <a href="#460371" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="comment">// TODO: consider MethodType mt for which mt.params.isEmpty??</span>
          <span class="keyword">case</span> <a title="Boolean" id="460813">pt1</a> @ NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
            <a href="#460813" title="Types.this.NullaryMethodType">pt1</a>.<a href="#423876" title="=&gt; Types.this.Type">resultType</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460812" title="Types.this.NullaryMethodType">pt2</a>.<a href="#423876" title="=&gt; Types.this.Type">resultType</a>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="460818">lo2</a>, <a title="Types.this.Type" id="460819">hi2</a><span class="delimiter">)</span> =&gt;
        <a href="#460371" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="460820">lo1</a>, <a title="Types.this.Type" id="460821">hi1</a><span class="delimiter">)</span> =&gt;
            <a href="#460818" title="Types.this.Type">lo2</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460820" title="Types.this.Type">lo1</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460821" title="Types.this.Type">hi1</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460819" title="Types.this.Type">hi2</a>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#460695" title="=&gt; Boolean">fourthTry</a>
    <span class="delimiter">}</span><span class="delimiter">}</span>

    <span class="comment">/** Fourth try, on the left:
     *   - handle typerefs, refined types, notnull and singleton types. 
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="460695">fourthTry</a> = <span class="delimiter">{</span> <a href="../util/Statistics.scala.html#67162" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67303" title="=&gt; scala.tools.nsc.util.Statistics.Counter">ctr4</a><span class="delimiter">)</span>; <a href="#460371" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="460758">tr1</a> @ TypeRef<span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="460759">sym1</a>, _<span class="delimiter">)</span> =&gt;
        <a href="#460759" title="Types.this.Symbol">sym1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="Definitions.scala.html#106228" title="Boolean(true)">NothingClass</a> =&gt; <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <a href="Definitions.scala.html#106226" title="Boolean">NullClass</a> =&gt;
            <a href="#460372" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="460760">sym2</a>, _<span class="delimiter">)</span> =&gt;
                <a href="#460760" title="Types.this.Symbol">sym2</a>.<span title="=&gt; Boolean">isClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#460760" title="Types.this.Symbol">sym2</a> <a href="Symbols.scala.html#107588" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="Definitions.scala.html#106220" title="=&gt; Types.this.Symbol">ObjectClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#460372" title="Types.this.Type">tp2</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#107588" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="Definitions.scala.html#106336" title="=&gt; Types.this.Symbol">NotNullClass</a><span class="delimiter">)</span>
              <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
                <a href="#67599" title="(tp: Types.this.Type)Boolean">isSingleType</a><span class="delimiter">(</span><a href="#460372" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460371" title="Types.this.Type">tp1</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460372" title="Types.this.Type">tp2</a>.<a href="#105458" title="=&gt; Types.this.Type">widen</a>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="Symbols.scala.html#67337" title="Types.this.ClassSymbol">ClassSymbol</a> =&gt;
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67526" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><span class="delimiter">(</span><a href="#460759" title="Types.this.Symbol">sym1</a>, <a href="#460758" title="Types.this.TypeRef">tr1</a>.<a href="#133633" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> 
              <a href="#67595" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#258577" title="(tp: Types.this.Type)Types.this.Type">rawToExistential</a><span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a><span class="delimiter">)</span>, <a href="#460372" title="Types.this.Type">tp2</a>, <a href="#460373" title="Int">depth</a><span class="delimiter">)</span>
            <span class="keyword">else</span> 
              <a href="#460759" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#67720" title="object Types.this.tpnme">tpnme</a>.<span title="=&gt; Types.this.tpnme.NameType">REFINE_CLASS_NAME</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <a href="#67595" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#460759" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>, <a href="#460372" title="Types.this.Type">tp2</a>, <a href="#460373" title="Int">depth</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="Symbols.scala.html#67335" title="Types.this.TypeSymbol">TypeSymbol</a> =&gt;
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460759" title="Types.this.Symbol">sym1</a> <span title="(mask: Long)Boolean">hasFlag</span> <span title="Long(16L)">DEFERRED</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="460778">tp1a</a> = <a href="#460371" title="Types.this.Type">tp1</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a>
              <a href="#67579" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isDifferentTypeConstructor</a><span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a>, <a href="#460778" title="Types.this.Type">tp1a</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460778" title="Types.this.Type">tp1a</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460372" title="Types.this.Type">tp2</a>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <a href="#67595" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#460371" title="Types.this.Type">tp1</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a>, <a href="#460372" title="Types.this.Type">tp2</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a>, <a href="#460373" title="Int">depth</a><span class="delimiter">)</span>
            <span class="delimiter">}</span> 
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="460783">parents1</a>, _<span class="delimiter">)</span> =&gt;
        <a href="#460783" title="List[Types.this.Type]">parents1</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#460790" title="Types.this.Type">_</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460372" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="#67398" title="Types.this.SingletonType">SingletonType</a> | _: <a href="#449814" title="Types.this.NotNullType">NotNullType</a> =&gt;
        <a href="#460371" title="Types.this.Type">tp1</a>.<a href="#105457" title="=&gt; Types.this.Type">underlying</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460372" title="Types.this.Type">tp2</a>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
        <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span><span class="delimiter">}</span>

    <a href="#460691" title="=&gt; Boolean">firstTry</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Are `tps1' and `tps2' lists of equal length such
   *  that all elements of `tps1' conform to corresponding elements
   *  of `tps2'?
   */</span>
  <span class="keyword">def</span> <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean" id="67613">isSubTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="460847">tps1</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="460848">tps2</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#460847" title="List[Types.this.Type]">tps1</a> <span title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.Type, Types.this.Type) =&gt; Boolean)Boolean">corresponds</span> <a href="#460848" title="List[Types.this.Type]">tps2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#460867" title="Types.this.Type">_</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460868" title="Types.this.Type">_</a><span class="delimiter">)</span>

  <span class="comment">/** Does type `tp' implement symbol `sym' with same or
   *  stronger type? Exact only if `sym' is a member of some
   *  refinement type, otherwise we might return false negatives.
   */</span>
  <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean" id="67614">specializesSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="450265">tp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="450266">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#450265" title="Types.this.Type">tp</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a> <span title="(x: Boolean)Boolean">||</span>
    <a href="#450265" title="Types.this.Type">tp</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106226" title="=&gt; Types.this.Symbol">NullClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#450266" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a> <a href="Symbols.scala.html#107589" title="(that: Types.this.Symbol)Boolean">isSubClass</a> <a href="Definitions.scala.html#106220" title="=&gt; Types.this.Symbol">ObjectClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
    <span class="delimiter">(</span><a href="#450265" title="Types.this.Type">tp</a>.<a href="#105496" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#450266" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107591" title="=&gt; List[Types.this.Symbol]">alternatives</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span>
      <span class="delimiter">(</span><a title="Types.this.Symbol" id="460887">alt</a> =&gt; <a href="#450266" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#460887" title="Types.this.Symbol">alt</a> <span title="(x: Boolean)Boolean">||</span> <a href="#67615" title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#450265" title="Types.this.Type">tp</a>.<a href="#105461" title="=&gt; Types.this.Type">narrow</a>, <a href="#460887" title="Types.this.Symbol">alt</a>, <a href="#450266" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#107600" title="=&gt; Types.this.Type">thisType</a>, <a href="#450266" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Does member `sym1' of `tp1' have a stronger type
   *  than member `sym2' of `tp2'?
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean" id="67615">specializesSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="450260">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="450261">sym1</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="450262">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="450263">sym2</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Types.this.Type" id="460896">info1</a> = <a href="#450260" title="Types.this.Type">tp1</a>.<a href="#105501" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#450261" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Types.this.Type" id="460897">info2</a> = <a href="#450262" title="Types.this.Type">tp2</a>.<a href="#105501" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#450263" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>.<a href="#105506" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#450262" title="Types.this.Type">tp2</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#450260" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
    <span class="comment">//System.out.println(&quot;specializes &quot;+tp1+&quot;.&quot;+sym1+&quot;:&quot;+info1+sym1.locationString+&quot; AND &quot;+tp2+&quot;.&quot;+sym2+&quot;:&quot;+info2)//DEBUG</span>
    <a href="#450263" title="Types.this.Symbol">sym2</a>.<span title="=&gt; Boolean">isTerm</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#460896" title="Types.this.Type">info1</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460897" title="Types.this.Type">info2</a><span class="delimiter">)</span> <span class="comment">/*&amp;&amp; (!sym2.isStable || sym1.isStable) */</span> <span title="(x: Boolean)Boolean">||</span>
    <a href="#450263" title="Types.this.Symbol">sym2</a>.<span title="=&gt; Boolean">isAbstractType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="460898">memberTp1</a> = <a href="#450260" title="Types.this.Type">tp1</a>.<a href="#105502" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#450261" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      <span class="comment">// println(&quot;kinds conform? &quot;+(memberTp1, tp1, sym2, kindsConform(List(sym2), List(memberTp1), tp2, sym2.owner)))</span>
      <a href="#460897" title="Types.this.Type">info2</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148513" title="(that: Types.this.Type)Boolean">containsType</a><span class="delimiter">(</span><a href="#460898" title="Types.this.Type">memberTp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
      <a href="#67667" title="(tparams: List[Types.this.Symbol], targs: List[Types.this.Type], pre: Types.this.Type, owner: Types.this.Symbol)Boolean">kindsConform</a><span class="delimiter">(</span><span title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</span><span class="delimiter">(</span><a href="#450263" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>, <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#460898" title="Types.this.Type">memberTp1</a><span class="delimiter">)</span>, <a href="#450260" title="Types.this.Type">tp1</a>, <a href="#450261" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span> 
    <span class="delimiter">}</span> <span title="(x: Boolean)Boolean">||</span>
    <a href="#450263" title="Types.this.Symbol">sym2</a>.<span title="=&gt; Boolean">isAliasType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#450262" title="Types.this.Type">tp2</a>.<a href="#105502" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#450263" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>.<a href="#105506" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#450262" title="Types.this.Type">tp2</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#450260" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#450260" title="Types.this.Type">tp1</a>.<a href="#105502" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#450261" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> <span class="comment">//@MAT ok</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A function implementing `tp1' matches `tp2' */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean" id="67616">matchesType</a><span class="delimiter">(</span><a title="Types.this.Type" id="313982">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="313983">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Boolean" id="313984">alwaysMatchSimple</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean" id="460918">matchesQuantified</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460920">tparams1</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="460921">tparams2</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="460922">res1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460923">res2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span>
      <a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#460920" title="List[Types.this.Symbol]">tparams1</a>, <a href="#460921" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
      <a href="#67616" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#460922" title="Types.this.Type">res1</a>, <a href="#460923" title="Types.this.Type">res2</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460921" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460920" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>, <a href="#313984" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="460919">lastTry</a> = 
      <a href="#313983" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="460926">res2</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#313984" title="Boolean">alwaysMatchSimple</a> =&gt;
          <a href="#67616" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#313982" title="Types.this.Type">tp1</a>, <a href="#460926" title="Types.this.Type">res2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Boolean(false)">MethodType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
          <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">case</span> <span title="Boolean">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460927">tparams2</a>, <a title="Types.this.Type" id="460928">res2</a><span class="delimiter">)</span> =&gt;
          <a href="#460927" title="List[Types.this.Symbol]">tparams2</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67616" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#313982" title="Types.this.Type">tp1</a>, <a href="#460928" title="Types.this.Type">res2</a>, <a href="#313984" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
          <a href="#313984" title="Boolean">alwaysMatchSimple</a> <span title="(x: Boolean)Boolean">||</span> <a href="#313982" title="Types.this.Type">tp1</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#313983" title="Types.this.Type">tp2</a>
      <span class="delimiter">}</span>
    <a href="#313982" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="460929">mt1</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460930">params1</a>, <a title="Types.this.Type" id="460931">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#313983" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="460932">mt2</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460933">params2</a>, <a title="Types.this.Type" id="460934">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#460930" title="List[Types.this.Symbol]">params1</a>, <a href="#460933" title="List[Types.this.Symbol]">params2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="comment">// useful pre-screening optimization</span>
            <a href="#67617" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span><a href="#460930" title="List[Types.this.Symbol]">params1</a>, <a href="#460933" title="List[Types.this.Symbol]">params2</a>, <a href="#460929" title="Types.this.MethodType">mt1</a>.<a href="#148774" title="=&gt; Boolean">isJava</a>, <a href="#460932" title="Types.this.MethodType">mt2</a>.<a href="#148774" title="=&gt; Boolean">isJava</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
            <a href="#67616" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#460931" title="Types.this.Type">res1</a>, <a href="#460934" title="Types.this.Type">res2</a>, <a href="#313984" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#460929" title="Types.this.MethodType">mt1</a>.<a href="#148773" title="=&gt; Boolean">isImplicit</a> <span title="(x: Boolean)Boolean">==</span> <a href="#460932" title="Types.this.MethodType">mt2</a>.<a href="#148773" title="=&gt; Boolean">isImplicit</a>
          <span class="keyword">case</span> <span title="Boolean">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="460942">res2</a><span class="delimiter">)</span> =&gt; 
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460930" title="List[Types.this.Symbol]">params1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#67616" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#460931" title="Types.this.Type">res1</a>, <a href="#460942" title="Types.this.Type">res2</a>, <a href="#313984" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#67616" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#313982" title="Types.this.Type">tp1</a>, <a href="#460942" title="Types.this.Type">res2</a>, <a href="#313984" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="460943">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#313984" title="Boolean">alwaysMatchSimple</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67616" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#313982" title="Types.this.Type">tp1</a>, <a href="#460943" title="Types.this.Type">res2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Boolean" id="460944">mt1</a> @ NullaryMethodType<span class="delimiter">(</span><a title="Types.this.Type" id="460945">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#313983" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="460946">mt2</a> @ MethodType<span class="delimiter">(</span><span title="object Nil">Nil</span>, <a title="Types.this.Type" id="460947">res2</a><span class="delimiter">)</span>  =&gt; <span class="comment">// could never match if params nonEmpty, and !mt2.isImplicit is implied by empty param list</span>
            <a href="#67616" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#460945" title="Types.this.Type">res1</a>, <a href="#460947" title="Types.this.Type">res2</a>, <a href="#313984" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="460948">res2</a><span class="delimiter">)</span> =&gt; 
            <a href="#67616" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#460945" title="Types.this.Type">res1</a>, <a href="#460948" title="Types.this.Type">res2</a>, <a href="#313984" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="460949">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#313984" title="Boolean">alwaysMatchSimple</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67616" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#313982" title="Types.this.Type">tp1</a>, <a href="#460949" title="Types.this.Type">res2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#67616" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#460945" title="Types.this.Type">res1</a>, <a href="#313983" title="Types.this.Type">tp2</a>, <a href="#313984" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460950">tparams1</a>, <a title="Types.this.Type" id="460951">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#313983" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460952">tparams2</a>, <a title="Types.this.Type" id="460953">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#460918" title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean">matchesQuantified</a><span class="delimiter">(</span><a href="#460950" title="List[Types.this.Symbol]">tparams1</a>, <a href="#460952" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460951" title="Types.this.Type">res1</a>, <a href="#460953" title="Types.this.Type">res2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="460954">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#313984" title="Boolean">alwaysMatchSimple</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67616" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#313982" title="Types.this.Type">tp1</a>, <a href="#460954" title="Types.this.Type">res2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span> <span class="comment">// remember that tparams1.nonEmpty is now an invariant of PolyType</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460955">tparams1</a>, <a title="Types.this.Type" id="460956">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#313983" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460957">tparams2</a>, <a title="Types.this.Type" id="460958">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#460918" title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean">matchesQuantified</a><span class="delimiter">(</span><a href="#460955" title="List[Types.this.Symbol]">tparams1</a>, <a href="#460957" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460956" title="Types.this.Type">res1</a>, <a href="#460958" title="Types.this.Type">res2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#313984" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span> <a href="#67616" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#460956" title="Types.this.Type">res1</a>, <a href="#313983" title="Types.this.Type">tp2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#460919" title="=&gt; Boolean">lastTry</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#460919" title="=&gt; Boolean">lastTry</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="comment">/** matchesType above is an optimized version of the following implementation:

  def matchesType2(tp1: Type, tp2: Type, alwaysMatchSimple: Boolean): Boolean = {
    def matchesQuantified(tparams1: List[Symbol], tparams2: List[Symbol], res1: Type, res2: Type): Boolean = 
      tparams1.length == tparams2.length &amp;&amp;
      matchesType(res1, res2.substSym(tparams2, tparams1), alwaysMatchSimple)
    (tp1, tp2) match {
      case (MethodType(params1, res1), MethodType(params2, res2)) =&gt;
        params1.length == params2.length &amp;&amp; // useful pre-secreening optimization 
        matchingParams(params1, params2, tp1.isInstanceOf[JavaMethodType], tp2.isInstanceOf[JavaMethodType]) &amp;&amp; 
        matchesType(res1, res2, alwaysMatchSimple) &amp;&amp;
        tp1.isImplicit == tp2.isImplicit
      case (PolyType(tparams1, res1), PolyType(tparams2, res2)) =&gt;
        matchesQuantified(tparams1, tparams2, res1, res2)
      case (NullaryMethodType(rtp1), MethodType(List(), rtp2)) =&gt; 
        matchesType(rtp1, rtp2, alwaysMatchSimple)
      case (MethodType(List(), rtp1), NullaryMethodType(rtp2)) =&gt; 
        matchesType(rtp1, rtp2, alwaysMatchSimple)
      case (ExistentialType(tparams1, res1), ExistentialType(tparams2, res2)) =&gt;
        matchesQuantified(tparams1, tparams2, res1, res2)
      case (ExistentialType(_, res1), _) if alwaysMatchSimple =&gt;
        matchesType(res1, tp2, alwaysMatchSimple)
      case (_, ExistentialType(_, res2)) if alwaysMatchSimple =&gt;
        matchesType(tp1, res2, alwaysMatchSimple)
      case (NullaryMethodType(rtp1), _) =&gt; 
        matchesType(rtp1, tp2, alwaysMatchSimple)
      case (_, NullaryMethodType(rtp2)) =&gt; 
        matchesType(tp1, rtp2, alwaysMatchSimple)
      case (MethodType(_, _), _) =&gt; false
      case (PolyType(_, _), _)   =&gt; false
      case (_, MethodType(_, _)) =&gt; false
      case (_, PolyType(_, _))   =&gt; false
      case _ =&gt;
        alwaysMatchSimple || tp1 =:= tp2
    }
  }
*/</span>

  <span class="comment">/** Are `syms1' and `syms2' parameter lists with pairwise equivalent types? */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean" id="67617">matchingParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460802">syms1</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="460803">syms2</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Boolean" id="460804">syms1isJava</a>: <span title="Boolean">Boolean</span>, <a title="Boolean" id="460805">syms2isJava</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#460802" title="List[Types.this.Symbol]">syms1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean">Nil</span> =&gt;
      <a href="#460803" title="List[Types.this.Symbol]">syms2</a>.<span title="=&gt; Boolean">isEmpty</span>
    <span class="keyword">case</span> <a title="Boolean" id="460963">sym1</a> :: <a title="List[Types.this.Symbol]" id="460964">rest1</a> =&gt;
      <a href="#460803" title="List[Types.this.Symbol]">syms2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Boolean(false)">Nil</span> =&gt;
          <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">case</span> <a title="Boolean" id="460969">sym2</a> :: <a title="List[Types.this.Symbol]" id="460970">rest2</a> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="460971">tp1</a> = <a href="#460963" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
          <span class="keyword">val</span> <a title="Types.this.Type" id="460972">tp2</a> = <a href="#460969" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
          <span class="delimiter">(</span><a href="#460971" title="Types.this.Type">tp1</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460972" title="Types.this.Type">tp2</a> <span title="(x: Boolean)Boolean">||</span> 
           <a href="#460804" title="Boolean">syms1isJava</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460972" title="Types.this.Type">tp2</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106220" title="=&gt; Types.this.Symbol">ObjectClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460971" title="Types.this.Type">tp1</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a> <span title="(x: Boolean)Boolean">||</span>
           <a href="#460805" title="Boolean">syms2isJava</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460971" title="Types.this.Type">tp1</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106220" title="=&gt; Types.this.Symbol">ObjectClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460972" title="Types.this.Type">tp2</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
          <a href="#67617" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span><a href="#460964" title="List[Types.this.Symbol]">rest1</a>, <a href="#460970" title="List[Types.this.Symbol]">rest2</a>, <a href="#460804" title="Boolean">syms1isJava</a>, <a href="#460805" title="Boolean">syms2isJava</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** like map2, but returns list `xs' itself - instead of a copy - if function
   *  `f' maps all elements to themselves.
   */</span>
  <span class="keyword">def</span> <a title="[A &lt;: AnyRef, B](xs: List[A], ys: List[B])(f: (A, B) =&gt; A)List[A]" id="67618">map2Conserve</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef" id="67621">A</a> &lt;: AnyRef, <a title="&gt;: Nothing &lt;: Any" id="67622">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[A]" id="456829">xs</a>: <span title="List[A]">List</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="List[B]" id="456830">ys</a>: <span title="List[B]">List</span><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; A" id="456831">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span>: <span title="List[A]">List</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = 
    <span title="List[A]" class="keyword">if</span> <span class="delimiter">(</span><a href="#456829" title="List[A]">xs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#456829" title="List[A]">xs</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="A" id="460993">x1</a> = <a href="#456831" title="(v1: A, v2: B)A">f</a><span class="delimiter">(</span><a href="#456829" title="List[A]">xs</a>.<span title="=&gt; A">head</span>, <a href="#456830" title="List[B]">ys</a>.<span title="=&gt; B">head</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[A]" id="460994">xs1</a> = <a href="#67618" title="(xs: List[A], ys: List[B])(f: (A, B) =&gt; A)List[A]">map2Conserve</a><span class="delimiter">(</span><a href="#456829" title="List[A]">xs</a>.<span title="=&gt; List[A]">tail</span>, <a href="#456830" title="List[B]">ys</a>.<span title="=&gt; List[B]">tail</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#456831" title="(A, B) =&gt; A">f</a><span class="delimiter">)</span>
      <span title="List[A]" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#460993" title="A">x1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456829" title="List[A]">xs</a>.<span title="=&gt; A">head</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#460994" title="List[A]">xs1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456829" title="List[A]">xs</a>.<span title="=&gt; List[A]">tail</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#456829" title="List[A]">xs</a>
      <span class="keyword">else</span> <a href="#460993" title="A">x1</a> <a href="#461033" title="(x: A)List[A]">::</a> <a href="#460994" title="List[A]">xs1</a>
    <span class="delimiter">}</span>    

  <span class="comment">/** Solve constraint collected in types `tvars'.
   *
   *  @param tvars      All type variables to be instantiated.
   *  @param tparams    The type parameters corresponding to `tvars'
   *  @param variances  The variances of type parameters; need to reverse
   *                    solution direction for all contravariant variables.
   *  @param upper      When `true' search for max solution else min.
   */</span>
  <span class="keyword">def</span> <a title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean)Boolean" id="67623">solve</a><span class="delimiter">(</span><a title="List[Types.this.TypeVar]" id="454893">tvars</a>: <span title="List[Types.this.TypeVar]">List</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="454894">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
            <a title="List[Int]" id="454895">variances</a>: <span title="List[Int]">List</span><span class="delimiter">[</span>Int<span class="delimiter">]</span>, <a title="Boolean" id="454896">upper</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
     <a href="#67624" title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean, depth: Int)Boolean">solve</a><span class="delimiter">(</span><a href="#454893" title="List[Types.this.TypeVar]">tvars</a>, <a href="#454894" title="List[Types.this.Symbol]">tparams</a>, <a href="#454895" title="List[Int]">variances</a>, <a href="#454896" title="Boolean">upper</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean, depth: Int)Boolean" id="67624">solve</a><span class="delimiter">(</span><a title="List[Types.this.TypeVar]" id="454887">tvars</a>: <span title="List[Types.this.TypeVar]">List</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="454888">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
            <a title="List[Int]" id="454889">variances</a>: <span title="List[Int]">List</span><span class="delimiter">[</span>Int<span class="delimiter">]</span>, <a title="Boolean" id="454890">upper</a>: <span title="Boolean">Boolean</span>, <a title="Int" id="454891">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="List[(Types.this.TypeVar, (Types.this.Symbol, Int))]" id="461043">config</a> = <a href="#454887" title="List[Types.this.TypeVar]">tvars</a> <span title="(that: scala.collection.GenIterable[(Types.this.Symbol, Int)])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeVar],(Types.this.TypeVar, (Types.this.Symbol, Int)),List[(Types.this.TypeVar, (Types.this.Symbol, Int))]])List[(Types.this.TypeVar, (Types.this.Symbol, Int))]">zip</span> <span class="delimiter">(</span><a href="#454888" title="List[Types.this.Symbol]">tparams</a> <span title="(that: scala.collection.GenIterable[Int])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],(Types.this.Symbol, Int),List[(Types.this.Symbol, Int)]])List[(Types.this.Symbol, Int)]">zip</span> <a href="#454889" title="List[Int]">variances</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="(tvar: Types.this.TypeVar, tparam: Types.this.Symbol, variance: Int)Unit" id="461044">solveOne</a><span class="delimiter">(</span><a title="Types.this.TypeVar" id="461145">tvar</a>: <a href="#67469" title="Types.this.TypeVar">TypeVar</a>, <a title="Types.this.Symbol" id="461146">tparam</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Int" id="461147">variance</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#461145" title="Types.this.TypeVar">tvar</a>.<a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449389" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Boolean" id="461153">up</a> = <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#461147" title="Int">variance</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(131072)">CONTRAVARIANT</span><span class="delimiter">)</span> <a href="#454890" title="Boolean">upper</a> <span class="keyword">else</span> <span title="=&gt; Boolean">!</span><a href="#454890" title="Boolean">upper</a>
        <a href="#461145" title="Types.this.TypeVar">tvar</a>.<a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449389" title="(x$1: Types.this.Type)Unit">inst</a> = <span title="Null(null)" class="keyword">null</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="461154">bound</a>: <a href="#67392" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461153" title="Boolean">up</a><span class="delimiter">)</span> <a href="#461146" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a> <span class="keyword">else</span> <a href="#461146" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148531" title="=&gt; Types.this.Type">lo</a>
        <span class="comment">//Console.println(&quot;solveOne0(tv, tp, v, b)=&quot;+(tvar, tparam, variance, bound))</span>
        <span class="keyword">var</span> <a title="Boolean" id="461155">cyclic</a> = <a href="#461154" title="Types.this.Type">bound</a> <a href="#105513" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#461146" title="Types.this.Symbol">tparam</a>
        <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.TypeVar" id="461199">tvar2</a>, <span class="delimiter">(</span><a title="Types.this.Symbol" id="461202">tparam2</a>, <a title="Int" id="461203">variance2</a><span class="delimiter">)</span><span class="delimiter">)</span> &lt;- <a href="#461043" title="(f: (Types.this.TypeVar, (Types.this.Symbol, Int)) =&gt; Unit)Unit">config</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#461202" title="Types.this.Symbol">tparam2</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#461146" title="Types.this.Symbol">tparam</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <span class="delimiter">(</span><span class="delimiter">(</span><a href="#461154" title="Types.this.Type">bound</a> <a href="#105513" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#461202" title="Types.this.Symbol">tparam2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
               <a href="#461153" title="Boolean">up</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#461202" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148531" title="=&gt; Types.this.Type">lo</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#461146" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
               <span title="=&gt; Boolean">!</span><a href="#461153" title="Boolean">up</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#461202" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#461146" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#461199" title="Types.this.TypeVar">tvar2</a>.<a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449389" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#461155" title="Boolean">cyclic</a> = <span title="Boolean(true)" class="keyword">true</span>
            <a href="#461044" title="(tvar: Types.this.TypeVar, tparam: Types.this.Symbol, variance: Int)Unit">solveOne</a><span class="delimiter">(</span><a href="#461199" title="Types.this.TypeVar">tvar2</a>, <a href="#461202" title="Types.this.Symbol">tparam2</a>, <a href="#461203" title="Int">variance2</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#461155" title="Boolean">cyclic</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#461153" title="Boolean">up</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#461154" title="Types.this.Type">bound</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span>
              <a href="#461145" title="Types.this.TypeVar">tvar</a> <a href="#449009" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a> <a href="#461154" title="Types.this.Type">bound</a>.<a href="#105480" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#454888" title="List[Types.this.Symbol]">tparams</a>, <a href="#454887" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
            <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="461233">tparam2</a> &lt;- <a href="#454888" title="(f: Types.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span>
              <a href="#461233" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148531" title="=&gt; Types.this.Type">lo</a>.<a href="#105484" title="=&gt; Types.this.Type">dealias</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a href="#461146" title="Types.this.Symbol">`tparam`</a>, _<span class="delimiter">)</span> =&gt;
                  <a href="#461145" title="Types.this.TypeVar">tvar</a> <a href="#449009" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a> <a href="#461233" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>.<a href="#105480" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#454888" title="List[Types.this.Symbol]">tparams</a>, <a href="#454887" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
                <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
              <span class="delimiter">}</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#461154" title="Types.this.Type">bound</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#461154" title="Types.this.Type">bound</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#461146" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#461145" title="Types.this.TypeVar">tvar</a> <a href="#449008" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a> <a href="#461154" title="Types.this.Type">bound</a>.<a href="#105480" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#454888" title="List[Types.this.Symbol]">tparams</a>, <a href="#454887" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="461256">tparam2</a> &lt;- <a href="#454888" title="(f: Types.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span>
              <a href="#461256" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a>.<a href="#105484" title="=&gt; Types.this.Type">dealias</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a href="#461146" title="Types.this.Symbol">`tparam`</a>, _<span class="delimiter">)</span> =&gt; 
                  <a href="#461145" title="Types.this.TypeVar">tvar</a> <a href="#449008" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a> <a href="#461256" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>.<a href="#105480" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#454888" title="List[Types.this.Symbol]">tparams</a>, <a href="#454887" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
                <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
              <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <a href="#461145" title="Types.this.TypeVar">tvar</a>.<a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449389" title="(x$1: Types.this.Type)Unit">inst</a> = <a href="#450913" title="object Types.this.NoType">NoType</a> <span class="comment">// necessary because hibounds/lobounds may contain tvar</span>

        <span class="comment">//println(&quot;solving &quot;+tvar+&quot; &quot;+up+&quot; &quot;+(if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds)+((if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds) map (_.widen)))</span>

        <a href="#461145" title="Types.this.TypeVar">tvar</a> <a href="#449007" title="(tp: Types.this.Type)Unit">setInst</a> <span class="delimiter">(</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461153" title="Boolean">up</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#454891" title="Int">depth</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span> <a href="#67659" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#461145" title="Types.this.TypeVar">tvar</a>.<a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449384" title="=&gt; List[Types.this.Type]">hiBounds</a>, <a href="#454891" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#67658" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#461145" title="Types.this.TypeVar">tvar</a>.<a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449384" title="=&gt; List[Types.this.Type]">hiBounds</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#454891" title="Int">depth</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span> <a href="#67650" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#461145" title="Types.this.TypeVar">tvar</a>.<a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449383" title="=&gt; List[Types.this.Type]">loBounds</a>, <a href="#454891" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#67649" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#461145" title="Types.this.TypeVar">tvar</a>.<a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449383" title="=&gt; List[Types.this.Type]">loBounds</a><span class="delimiter">)</span>
          <span class="delimiter">}</span><span class="delimiter">)</span>

        <span class="comment">//Console.println(&quot;solving &quot;+tvar+&quot; &quot;+up+&quot; &quot;+(if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds)+((if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds) map (_.widen))+&quot; = &quot;+tvar.constr.inst)//@MDEBUG</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>    
    
    <span class="comment">// println(&quot;solving &quot;+tvars+&quot;/&quot;+tparams+&quot;/&quot;+(tparams map (_.info)))</span>
    <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.TypeVar" id="461318">tvar</a>, <span class="delimiter">(</span><a title="Types.this.Symbol" id="461321">tparam</a>, <a title="Int" id="461322">variance</a><span class="delimiter">)</span><span class="delimiter">)</span> &lt;- <a href="#461043" title="(f: (Types.this.TypeVar, (Types.this.Symbol, Int)) =&gt; Unit)Unit">config</a><span class="delimiter">)</span>
      <a href="#461044" title="(tvar: Types.this.TypeVar, tparam: Types.this.Symbol, variance: Int)Unit">solveOne</a><span class="delimiter">(</span><a href="#461318" title="Types.this.TypeVar">tvar</a>, <a href="#461321" title="Types.this.Symbol">tparam</a>, <a href="#461322" title="Int">variance</a><span class="delimiter">)</span>

    <a href="#454887" title="List[Types.this.TypeVar]">tvars</a> <span title="(p: Types.this.TypeVar =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.TypeVar" id="461330">tvar</a> =&gt; <a href="#461330" title="Types.this.TypeVar">tvar</a>.<a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449387" title="(tp: Types.this.Type)Boolean">isWithinBounds</a><span class="delimiter">(</span><a href="#461330" title="Types.this.TypeVar">tvar</a>.<a href="#449001" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449389" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Do type arguments `targs' conform to formal parameters
   *  `tparams'?
   *
   *  @param tparams ...
   *  @param targs   ...
   *  @return        ...
   */</span>
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])Boolean" id="67625">isWithinBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="454947">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="454948">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="454949">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="454950">targs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="List[Types.this.TypeBounds]" id="461331">bounds</a> = <a href="#67626" title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]">instantiatedBounds</a><span class="delimiter">(</span><a href="#454947" title="Types.this.Type">pre</a>, <a href="#454948" title="Types.this.Symbol">owner</a>, <a href="#454949" title="List[Types.this.Symbol]">tparams</a>, <a href="#454950" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#454950" title="List[Types.this.Type]">targs</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#461343" title="Types.this.Type">_</a>.<a href="#105540" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#461331" title="List[Types.this.TypeBounds]">bounds</a> = <a href="AnnotationCheckers.scala.html#67773" title="(bounds: List[Types.this.TypeBounds], tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]">adaptBoundsToAnnotations</a><span class="delimiter">(</span><a href="#461331" title="List[Types.this.TypeBounds]">bounds</a>, <a href="#454949" title="List[Types.this.Symbol]">tparams</a>, <a href="#454950" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>
    <span class="delimiter">(</span><a href="#461331" title="List[Types.this.TypeBounds]">bounds</a> <span title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.TypeBounds, Types.this.Type) =&gt; Boolean)Boolean">corresponds</span> <a href="#454950" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#461371" title="Types.this.TypeBounds">_</a> <a href="#148513" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#461372" title="Types.this.Type">_</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]" id="67626">instantiatedBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="461332">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="461333">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="461334">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="461335">targs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.TypeBounds]">List</span><span class="delimiter">[</span>TypeBounds<span class="delimiter">]</span> = 
    <a href="#461334" title="List[Types.this.Symbol]">tparams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.TypeBounds)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.TypeBounds,List[Types.this.TypeBounds]])List[Types.this.TypeBounds]">map</span> <span class="delimiter">(</span><a href="#461400" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105500" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#461332" title="Types.this.Type">pre</a>, <a href="#461333" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>.<a href="#105480" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#461334" title="List[Types.this.Symbol]">tparams</a>, <a href="#461335" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>

<span class="comment">// Lubs and Glbs ---------------------------------------------------------</span>

  <span class="comment">/** Given a matrix `tsBts` whose columns are basetype sequences (and the symbols `tsParams` that should be interpreted as type parameters in this matrix),
   * compute its least sorted upwards closed upper bound relative to the following ordering &lt;= between lists of types:
   *
   *    xs &lt;= ys   iff   forall y in ys exists x in xs such that x &lt;: y
   *
   *
   *  @arg tsParams for each type in the original list of types `ts0`, its list of type parameters (if that type is a type constructor)
   *                (these type parameters may be referred to by type arguments in the BTS column of those types,
   *                and must be interpreted as bound variables; i.e., under a type lambda that wraps the types that refer to these type params)
   *  @arg tsBts    a matrix whose columns are basetype sequences
   *                the first row is the original list of types for which we're computing the lub 
   *                  (except that type constructors have been applied to their dummyArgs)
   *  @See baseTypeSeq  for a definition of sorted and upwards closed.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tsParams: List[List[Types.this.Symbol]], tsBts: List[List[Types.this.Type]], depth: Int)List[Types.this.Type]" id="67627">lubList</a><span class="delimiter">(</span><a title="List[List[Types.this.Symbol]]" id="461428">tsParams</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="List[List[Types.this.Type]]" id="461429">tsBts</a>: <span title="List[List[Types.this.Type]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Int" id="461430">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="comment">// strip typerefs in ts from their arguments if those refer to type parameters that are meant to be bound</span>
    <span class="comment">// TODO: this only deals with the simplest of type constructors</span>
    <span class="comment">// a better fix would be to actually bind those type parameters that appear free in error, but that would require major changes to the BTS infrastructure</span>
    <span class="comment">// example that only kindasorta works now...</span>
      <span class="comment">// given: trait Container[+T]; trait Template[+CC[X] &lt;: Container[X]]; class C1[T] extends Template[Container] with Container[T]</span>
    <span class="comment">// C1's BTS contains Template[Container] with Container[T], but that should really be [T] =&gt; Template[Container] with Container[T]</span>
    <span class="comment">// instead of wrapping it in a polytype, the current approach uses elimHOTparams to patch up this type so that </span>
    <span class="comment">// it looks more like a type ctor: Template[Container] with Container, but this is ill-kinded as Template[Container] is a proper type, whereas Container is not</span>
    <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="461432">elimHOTparams</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461433">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#461433" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#461450" title="Types.this.Type" class="delimiter">{</a> 
      <span class="keyword">case</span> <a title="Types.this.Type" id="461451">tp</a>@TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="461452">pre</a>, <a title="Types.this.Symbol" id="461453">sym</a>, <a title="List[Types.this.Type]" id="461454">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#461454" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#461428" title="List[List[Types.this.Symbol]]">tsParams</a>.<span title="(elem: Any)Boolean">contains</span><span class="delimiter">(</span><a href="#461454" title="List[Types.this.Type]">args</a>.<span title="(f: Types.this.Type =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,Any])Any">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.Symbol,List[Types.this.Symbol]]" class="delimiter">(</span><a href="#461471" title="Types.this.Type">_</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#461451" title="Types.this.TypeRef">tp</a>.<a href="#133586" title="=&gt; Types.this.Type">typeConstructor</a>
      <span class="keyword">case</span> <a title="Types.this.Type" id="461499">tp</a> =&gt; <a href="#461499" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461429" title="List[List[Types.this.Type]]">tsBts</a>.<span title="=&gt; List[List[Types.this.Type]]">tail</span>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#461429" title="List[List[Types.this.Type]]">tsBts</a>.<span title="=&gt; List[Types.this.Type]">head</span>
    <span class="keyword">else</span> <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461429" title="List[List[Types.this.Type]]">tsBts</a> <span title="(p: List[Types.this.Type] =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#461538" title="List[Types.this.Type]">_</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span> List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="461546">ts0</a> = <a href="#461429" title="List[List[Types.this.Type]]">tsBts</a> <span title="(f: List[Types.this.Type] =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#461564" title="List[Types.this.Type]">_</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span> <span class="comment">// ts0 is the 1-dimensional frontier of symbols cutting through 2-dimensional tsBts, </span>
      <span class="comment">// invariant: all symbols &quot;under&quot; (closer to the first row) the frontier are smaller (according to _.isLess) than the ones &quot;on and beyond&quot; the frontier</span>

      <span class="comment">// is the frontier made up of types with the same symbol? </span>
      <span class="comment">// --&gt; produce a single type for this frontier by merging the prefixes and arguments of these typerefs that share the same symbol</span>
      <span class="comment">// due to the invariant, that symbol is the current maximal symbol for which this holds, i.e., the one that conveys most information wrt subtyping</span>
      <span class="comment">// before merging, strip type arguments that refer to bound type params (when we're computing the lub of type constructors)</span>
      <span class="comment">// furthermore, the number of types to merge is reduced without losing information by dropping types that are a subtype of some other type</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="461547">sym0</a> = <a href="#461546" title="List[Types.this.Type]">ts0</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>
      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461546" title="List[Types.this.Type]">ts0</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#461601" title="Types.this.Type">_</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#461547" title="Types.this.Symbol">sym0</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">{</span>
        <a href="#67662" title="(tps: List[Types.this.Type], variance: Int, depth: Int)Option[Types.this.Type]">mergePrefixAndArgs</a><span class="delimiter">(</span><a href="#67637" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">elimSub</a><span class="delimiter">(</span><a href="#461432" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimHOTparams</a><span class="delimiter">(</span><a href="#461546" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>, <a href="#461430" title="Int">depth</a><span class="delimiter">)</span>, <span title="Int(1)" class="int">1</span>, <a href="#461430" title="Int">depth</a><span class="delimiter">)</span>.<span title="=&gt; List[Types.this.Type]">toList</span> <a href="#461607" title="(prefix: List[Types.this.Type])List[Types.this.Type]">:::</a> <a href="#67627" title="(tsParams: List[List[Types.this.Symbol]], tsBts: List[List[Types.this.Type]], depth: Int)List[Types.this.Type]">lubList</a><span class="delimiter">(</span><a href="#461428" title="List[List[Types.this.Symbol]]">tsParams</a>, <a href="#461429" title="List[List[Types.this.Type]]">tsBts</a> <span title="(f: List[Types.this.Type] =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a href="#461632" title="List[Types.this.Type]">_</a>.<span title="=&gt; List[Types.this.Type]">tail</span><span class="delimiter">)</span>, <a href="#461430" title="Int">depth</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span> 
        <span class="comment">// frontier is not uniform yet, move it beyond the current minimal symbol; lather, rince, repeat</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="461678">sym</a> = <a href="#67628" title="(tps: List[Types.this.Type])Types.this.Symbol">minSym</a><span class="delimiter">(</span><a href="#461546" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
        <a href="#67627" title="(tsParams: List[List[Types.this.Symbol]], tsBts: List[List[Types.this.Type]], depth: Int)List[Types.this.Type]">lubList</a><span class="delimiter">(</span><a href="#461428" title="List[List[Types.this.Symbol]]">tsParams</a>, <a href="#461429" title="List[List[Types.this.Type]]">tsBts</a> <span title="(f: List[Types.this.Type] =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a title="List[Types.this.Type]" id="461691">ts</a> =&gt; <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461691" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#461678" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#461691" title="List[Types.this.Type]">ts</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span class="keyword">else</span> <a href="#461691" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <a href="#461430" title="Int">depth</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="comment">// @AM the following problem is solved by elimHOTparams in lublist</span>
  <span class="comment">// @PP lubLists gone bad: lubList(List(</span>
  <span class="comment">//   List(scala.collection.generic.GenericCompanion[scala.collection.immutable.Seq], ScalaObject, java.lang.Object, Any)</span>
  <span class="comment">//   List(scala.collection.generic.GenericCompanion[scala.collection.mutable.Seq], ScalaObject, java.lang.Object, Any)</span>
  <span class="comment">// )) == (</span>
  <span class="comment">//   List(scala.collection.generic.GenericCompanion[Seq**[Any]**], ScalaObject, java.lang.Object, Any)</span>
  <span class="comment">// )</span>

  <span class="comment">/** The minimal symbol (wrt Symbol.isLess) of a list of types */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type])Types.this.Symbol" id="67628">minSym</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461679">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> =
    <span class="delimiter">(</span><a href="#461679" title="List[Types.this.Type]">tps</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="#461725" title="(z: Types.this.Symbol)(op: (Types.this.Symbol, Types.this.Type) =&gt; Types.this.Symbol)Types.this.Symbol">/:</a> <a href="#461679" title="List[Types.this.Type]">tps</a>.<span title="=&gt; List[Types.this.Type]">tail</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="delimiter">(</span><a title="Types.this.Symbol" id="461741">sym1</a>, <a title="Types.this.Type" id="461742">tp2</a><span class="delimiter">)</span> =&gt; <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#461742" title="Types.this.Type">tp2</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#107586" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#461741" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> <a href="#461742" title="Types.this.Type">tp2</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span class="keyword">else</span> <a href="#461741" title="Types.this.Symbol">sym1</a>
    <span class="delimiter">}</span>

  <span class="comment">/** A minimal type list which has a given list of types as its base type sequence */</span> 
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="67629">spanningTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461744">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#461744" title="List[Types.this.Type]">ts</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#461747" title="List[Nothing]">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="List[Types.this.Type]" id="461769">first</a> :: <a title="List[Types.this.Type]" id="461770">rest</a> =&gt;
      <a href="#461769" title="Types.this.Type">first</a> <a href="#461771" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#67629" title="(ts: List[Types.this.Type])List[Types.this.Type]">spanningTypes</a><span class="delimiter">(</span>
        <a href="#461770" title="List[Types.this.Type]">rest</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a title="Types.this.Type" id="461775">t</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#461769" title="Types.this.Type">first</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107589" title="(that: Types.this.Symbol)Boolean">isSubClass</a><span class="delimiter">(</span><a href="#461775" title="Types.this.Type">t</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Eliminate from list of types all elements which are a supertype
   *  of some other element of the list. */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="67630">elimSuper</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461781">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#461781" title="List[Types.this.Type]">ts</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#461784" title="List[Nothing]">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="List[Types.this.Type]" id="461806">t</a> :: <a title="List[Types.this.Type]" id="461807">ts1</a> =&gt;
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="461808">rest</a> = <a href="#67630" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSuper</a><span class="delimiter">(</span><a href="#461807" title="List[Types.this.Type]">ts1</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a title="Types.this.Type" id="461812">t1</a> =&gt; <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#461806" title="Types.this.Type">t</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#461812" title="Types.this.Type">t1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461808" title="List[Types.this.Type]">rest</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a title="Types.this.Type" id="461819">t1</a> =&gt; <a href="#461819" title="Types.this.Type">t1</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#461806" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#461808" title="List[Types.this.Type]">rest</a> <span class="keyword">else</span> <a href="#461806" title="Types.this.Type">t</a> <a href="#461820" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#461808" title="List[Types.this.Type]">rest</a>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(t: Types.this.Type)Types.this.Type" id="67631">elimAnonymousClass</a><span class="delimiter">(</span><a title="Types.this.Type" id="461826">t</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#461826" title="Types.this.Type">t</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="461829">pre</a>, <a title="Types.this.Symbol" id="461830">clazz</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#461830" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107487" title="=&gt; Boolean">isAnonymousClass</a> =&gt;
      <a href="#461830" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107582" title="=&gt; Types.this.Type">classBound</a>.<a href="#105500" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#461829" title="Types.this.Type">pre</a>, <a href="#461830" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <a href="#461826" title="Types.this.Type">t</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A collector that tests for existential types appearing at given variance in a type */</span>
  <span class="keyword">class</span> <a title="class ContainsVariantExistentialCollector extends Types.this.TypeCollector[Boolean] with ScalaObject" id="67632">ContainsVariantExistentialCollector</a><a href="#67632" title="ScalaObject" class="delimiter">(</a><a title="Int" id="449309">v</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67518" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449307">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="461837">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#461837" title="Types.this.Type">tp</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Unit">ExistentialType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#133450" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <a href="#449309" title="Int">v</a><span class="delimiter">)</span> =&gt; <a href="#449297" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt; <a href="#133458" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#461837" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="()Types.this.ContainsVariantExistentialCollector" id="449308">init</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#133450" title="(x$1: Int)Unit">variance</a> = <span title="Int(1)" class="int">1</span>
      <a href="#67632" title="Types.this.ContainsVariantExistentialCollector" class="keyword">this</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">val</span> <a title="Types.this.ContainsVariantExistentialCollector" id="67633">containsCovariantExistentialCollector</a> = <span title="Types.this.ContainsVariantExistentialCollector" class="keyword">new</span> <a href="#67632" title="Types.this.ContainsVariantExistentialCollector">ContainsVariantExistentialCollector</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="Types.this.ContainsVariantExistentialCollector" id="67635">containsContravariantExistentialCollector</a> = <span title="Types.this.ContainsVariantExistentialCollector" class="keyword">new</span> <a href="#67632" title="Types.this.ContainsVariantExistentialCollector">ContainsVariantExistentialCollector</a><span class="delimiter">(</span>-<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span>

  <span class="comment">/** Eliminate from list of types all elements which are a subtype
   *  of some other element of the list. */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]" id="67637">elimSub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461608">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="461609">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="461854">elimSub0</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461856">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#461856" title="List[Types.this.Type]">ts</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#461858" title="List[Nothing]">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="List[Types.this.Type]" id="461880">t</a> :: <a title="List[Types.this.Type]" id="461881">ts1</a> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="461882">rest</a> = <a href="#461854" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSub0</a><span class="delimiter">(</span><a href="#461881" title="List[Types.this.Type]">ts1</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a title="Types.this.Type" id="461886">t1</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#67595" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#461886" title="Types.this.Type">t1</a>, <a href="#461880" title="Types.this.Type">t</a>, <a href="#67375" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#461609" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461882" title="List[Types.this.Type]">rest</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a title="Types.this.Type" id="461897">t1</a> =&gt; <a href="#67595" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#461880" title="Types.this.Type">t</a>, <a href="#461897" title="Types.this.Type">t1</a>, <a href="#67375" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#461609" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#461882" title="List[Types.this.Type]">rest</a> <span class="keyword">else</span> <a href="#461880" title="Types.this.Type">t</a> <a href="#461902" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#461882" title="List[Types.this.Type]">rest</a>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="List[Types.this.Type]" id="461855">ts0</a> = <a href="#461854" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSub0</a><span class="delimiter">(</span><a href="#461608" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
    <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461855" title="List[Types.this.Type]">ts0</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#461855" title="List[Types.this.Type]">ts0</a>.<span title="=&gt; List[Types.this.Type]">tail</span>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#461855" title="List[Types.this.Type]">ts0</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="461909">ts1</a> = <a href="#461855" title="List[Types.this.Type]">ts0</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a title="Types.this.Type" id="461916">t</a> =&gt; <a href="#67631" title="(t: Types.this.Type)Types.this.Type">elimAnonymousClass</a><span class="delimiter">(</span><a href="#461916" title="Types.this.Type">t</a>.<a href="#105457" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461909" title="List[Types.this.Type]">ts1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#461855" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span> <a href="#461855" title="List[Types.this.Type]">ts0</a>
      <span class="keyword">else</span> <a href="#67637" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">elimSub</a><span class="delimiter">(</span><a href="#461909" title="List[Types.this.Type]">ts1</a>, <a href="#461609" title="Int">depth</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])(List[Types.this.Type], List[Types.this.Symbol])" id="67638">stripExistentialsAndTypeVars</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461918">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span>, List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="461920">quantified</a> = <a href="#461918" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">flatMap</span> <a href="#461939" title="List[Types.this.Symbol]" class="delimiter">{</a>
      <span class="keyword">case</span> <span title="List[Types.this.Symbol]">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="461940">qs</a>, _<span class="delimiter">)</span> =&gt; <a href="#461940" title="List[Types.this.Symbol]">qs</a>
      <span class="keyword">case</span> <a title="List[Nothing]" id="461941">t</a> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="461921">stripType</a><span class="delimiter">(</span><a title="Types.this.Type" id="461976">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#461976" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="461977">res</a><span class="delimiter">)</span> =&gt; 
        <a href="#461977" title="Types.this.Type">res</a>
      <span class="keyword">case</span> <a href="#448979" title="Types.this.Type">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="461979">constr</a><span class="delimiter">)</span> =&gt; 
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461979" title="Types.this.TypeConstraint">constr</a>.<a href="#449391" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#461979" title="Types.this.TypeConstraint">constr</a>.<a href="#449389" title="=&gt; Types.this.Type">inst</a>
        <span class="keyword">else</span> <a href="SymbolTable.scala.html#64790" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><span title="java.lang.String(&quot;trying to do lub/glb of typevar &quot;)" class="string">&quot;trying to do lub/glb of typevar &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#461976" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="461984">t</a> =&gt; <a href="#461984" title="Types.this.Type">t</a>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="List[Types.this.Type]" id="461922">strippedTypes</a> = <a href="#461918" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <a href="#461921" title="(tp: Types.this.Type)Types.this.Type">stripType</a>
    <span title="(_1: List[Types.this.Type], _2: List[Types.this.Symbol])(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</span><a href="#461922" title="List[Types.this.Type]">strippedTypes</a>, <a href="#461920" title="List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])(Types.this.Type, Boolean)" id="67639">weakLub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461999">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = 
    <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#461999" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#461999" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <a href="Definitions.scala.html#106666" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#67641" title="(ts: List[Types.this.Type])Types.this.Type">numericLub</a><span class="delimiter">(</span><a href="#461999" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#461999" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#461999" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#462038" title="Types.this.Type">_</a>.<a href="#105540" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="AnnotationCheckers.scala.html#67771" title="(tpe: Types.this.Type, ts: List[Types.this.Type])Types.this.Type">annotationsLub</a><span class="delimiter">(</span><a href="#67649" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#461999" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#462066" title="Types.this.Type">_</a>.<a href="#105544" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#461999" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#67649" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#461999" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])(Types.this.Type, Boolean)" id="67640">weakGlb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="462106">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#462106" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#462106" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <a href="Definitions.scala.html#106666" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="462116">nglb</a> = <a href="#67642" title="(ts: List[Types.this.Type])Types.this.Type">numericGlb</a><span class="delimiter">(</span><a href="#462106" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
      <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#462116" title="Types.this.Type">nglb</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#462116" title="Types.this.Type">nglb</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#67658" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#462106" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#462106" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#462106" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#462160" title="Types.this.Type">_</a>.<a href="#105540" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="AnnotationCheckers.scala.html#67772" title="(tpe: Types.this.Type, ts: List[Types.this.Type])Types.this.Type">annotationsGlb</a><span class="delimiter">(</span><a href="#67658" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#462106" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#462188" title="Types.this.Type">_</a>.<a href="#105544" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#462106" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#67658" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#462106" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="67641">numericLub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="462013">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#462013" title="List[Types.this.Type]">ts</a> <span title="(f: (Types.this.Type, Types.this.Type) =&gt; Types.this.Type)Types.this.Type">reduceLeft</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="462028">t1</a>, <a title="Types.this.Type" id="462029">t2</a><span class="delimiter">)</span> =&gt; 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67644" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#462028" title="Types.this.Type">t1</a>, <a href="#462029" title="Types.this.Type">t2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462029" title="Types.this.Type">t2</a> 
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67644" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#462029" title="Types.this.Type">t2</a>, <a href="#462028" title="Types.this.Type">t1</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462028" title="Types.this.Type">t1</a>
      <span class="keyword">else</span> <a href="Definitions.scala.html#106726" title="=&gt; Types.this.Symbol">IntClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="67642">numericGlb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="462117">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#462117" title="List[Types.this.Type]">ts</a> <span title="(f: (Types.this.Type, Types.this.Type) =&gt; Types.this.Type)Types.this.Type">reduceLeft</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="462132">t1</a>, <a title="Types.this.Type" id="462133">t2</a><span class="delimiter">)</span> =&gt; 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67644" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#462132" title="Types.this.Type">t1</a>, <a href="#462133" title="Types.this.Type">t2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462132" title="Types.this.Type">t1</a> 
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67644" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#462133" title="Types.this.Type">t2</a>, <a href="#462132" title="Types.this.Type">t1</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462133" title="Types.this.Type">t2</a>
      <span class="keyword">else</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67643">isWeakSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="450198">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="450199">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = 
    <a href="#450198" title="Types.this.Type">tp1</a>.<a href="#105459" title="=&gt; Types.this.Type">deconst</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="450202">sym1</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="Definitions.scala.html#106712" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#450202" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> =&gt;
        <a href="#450199" title="Types.this.Type">tp2</a>.<a href="#105459" title="=&gt; Types.this.Type">deconst</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="450205">sym2</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="Definitions.scala.html#106712" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#450205" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> =&gt;
            <a href="Definitions.scala.html#106711" title="(sub: Types.this.Symbol, sup: Types.this.Symbol)Boolean">isNumericSubClass</a><span class="delimiter">(</span><a href="#450202" title="Types.this.Symbol">sym1</a>, <a href="#450205" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <a title="Boolean" id="450208">tv2</a> @ <a href="#448979" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
            <a href="#450208" title="Types.this.TypeVar">tv2</a>.<a href="#449013" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#450198" title="Types.this.Type">tp1</a>, isLowerBound = <span title="Boolean(true)" class="keyword">true</span>, isNumericBound = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#67594" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a><span class="delimiter">(</span><a href="#450198" title="Types.this.Type">tp1</a>, <a href="#450199" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Boolean" id="450219">tv1</a> @ <a href="#448979" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
        <a href="#450199" title="Types.this.Type">tp2</a>.<a href="#105459" title="=&gt; Types.this.Type">deconst</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="450221">sym2</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="Definitions.scala.html#106712" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#450221" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> =&gt;
            <a href="#450219" title="Types.this.TypeVar">tv1</a>.<a href="#449013" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#450199" title="Types.this.Type">tp2</a>, isLowerBound = <span title="Boolean(false)" class="keyword">false</span>, isNumericBound = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#67594" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a><span class="delimiter">(</span><a href="#450198" title="Types.this.Type">tp1</a>, <a href="#450199" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#67594" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a><span class="delimiter">(</span><a href="#450198" title="Types.this.Type">tp1</a>, <a href="#450199" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67644">isNumericSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="456509">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="456510">tp2</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
    <a href="Definitions.scala.html#106666" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#456509" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#106666" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#456510" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>  
    <a href="Definitions.scala.html#106711" title="(sub: Types.this.Symbol, sup: Types.this.Symbol)Boolean">isNumericSubClass</a><span class="delimiter">(</span><a href="#456509" title="Types.this.Type">tp1</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#456510" title="Types.this.Type">tp2</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" id="67645">lubResults</a> = <span title="()scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">HashMap</span><span class="delimiter">[</span><span class="delimiter">(</span>Int, List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>, Type<span class="delimiter">]</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" id="67647">glbResults</a> = <span title="()scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">HashMap</span><span class="delimiter">[</span><span class="delimiter">(</span>Int, List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>, Type<span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="67649">lub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="222405">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="#67650" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#222405" title="List[Types.this.Type]">ts</a>, <a href="#67568" title="(ts: List[Types.this.Type])Int">lubDepth</a><span class="delimiter">(</span><a href="#222405" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#67645" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">lubResults</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#67647" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">glbResults</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
 
  <span class="comment">/** The least upper bound wrt &lt;:&lt; of a list of types */</span>
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)Types.this.Type" id="67650">lub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="222400">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="222401">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="462232">lub0</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="462235">ts0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#67637" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">elimSub</a><span class="delimiter">(</span><a href="#462235" title="List[Types.this.Type]">ts0</a>, <a href="#222401" title="Int">depth</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#462237" title="Types.this.Type">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
      <span class="keyword">case</span> <a href="#462249" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="462260">t</a><span class="delimiter">)</span> =&gt; <a href="#462260" title="Types.this.Type">t</a>
      <span class="keyword">case</span> <a title="Types.this.PolyType" id="462261">ts</a> @ PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="462266">tparams</a>, _<span class="delimiter">)</span> :: _ =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="462267">tparams1</a> = <span title="(_1: List[Types.this.Symbol], _2: List[List[Types.this.Type]])(List[Types.this.Symbol], List[List[Types.this.Type]])" class="delimiter">(</span><a href="#462266" title="List[Types.this.Symbol]">tparams</a>, <a href="#67664" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[List[Types.this.Type]]">matchingBounds</a><span class="delimiter">(</span><a href="#462261" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#462266" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>.<span title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.TraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</span><span class="delimiter">)</span>.<span title="(implicit w1: List[Types.this.Symbol] =&gt; scala.collection.TraversableLike[Types.this.Symbol,List[Types.this.Symbol]], implicit w2: List[List[Types.this.Type]] =&gt; scala.collection.IterableLike[List[Types.this.Type],List[List[Types.this.Type]]])(List[Types.this.Symbol], List[List[Types.this.Type]])#Zipped[List[Types.this.Symbol],Types.this.Symbol,List[List[Types.this.Type]],List[Types.this.Type]]">zipped</span> <span title="(f: (Types.this.Symbol, List[Types.this.Type]) =&gt; Types.this.Symbol)(implicit cbf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span>
          <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="462367">tparam</a>, <a title="List[Types.this.Type]" id="462368">bounds</a><span class="delimiter">)</span> =&gt; <a href="#462367" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107594" title="=&gt; Types.this.Symbol">cloneSymbol</a>.<a href="Symbols.scala.html#107566" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a><span class="delimiter">(</span><a href="#67659" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#462368" title="List[Types.this.Type]">bounds</a>, <a href="#222401" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#148921" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#462267" title="List[Types.this.Symbol]">tparams1</a>, <a href="#462232" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#67665" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">matchingInstTypes</a><span class="delimiter">(</span><a href="#462261" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#462267" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.MethodType" id="462409">ts</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="462414">params</a>, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="462415">rest</a> =&gt;
        <a href="#148762" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#462414" title="List[Types.this.Symbol]">params</a>, <a href="#462232" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#67666" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span><a href="#462409" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#462414" title="List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#462435" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.NullaryMethodType" id="462463">ts</a> @ NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="462468">rest</a> =&gt;
        <a href="#148865" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#462232" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#67666" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span><a href="#462463" title="collection.immutable.::[Types.this.Type]">ts</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.TypeBounds" id="462469">ts</a> @ TypeBounds<span class="delimiter">(</span>_, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="462474">rest</a> =&gt;
        <a href="#148501" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#67659" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#462469" title="collection.immutable.::[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#462495" title="Types.this.Type">_</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148531" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#222401" title="Int">depth</a><span class="delimiter">)</span>, <a href="#67650" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#462469" title="collection.immutable.::[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#462537" title="Types.this.Type">_</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#222401" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="462565">ts</a> =&gt;
        <a href="#67645" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">lubResults</a> <span title="(key: (Int, List[Types.this.Type]))Option[Types.this.Type]">get</span> <span class="delimiter">(</span><a href="#222401" title="Int">depth</a>, <a href="#462565" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Types.this.Type">Some</span><span class="delimiter">(</span><a title="Types.this.Type" id="462576">lubType</a><span class="delimiter">)</span> =&gt; 
            <a href="#462576" title="Types.this.Type">lubType</a>
          <span class="keyword">case</span> <span title="Types.this.Type">None</span> =&gt; 
            <a href="#67645" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">lubResults</a><span class="delimiter">(</span><span title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</span><a href="#222401" title="Int">depth</a>, <a href="#462565" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="462577">res</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#222401" title="Int">depth</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#462233" title="(ts0: List[Types.this.Type])Types.this.Type">lub1</a><span class="delimiter">(</span><a href="#462565" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
            <a href="#67645" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">lubResults</a><span class="delimiter">(</span><span title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</span><a href="#222401" title="Int">depth</a>, <a href="#462565" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="#462577" title="Types.this.Type">res</a>
            <a href="#462577" title="Types.this.Type">res</a>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="462233">lub1</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="462592">ts0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#462600" title="(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</a><a href="#462599" title="List[Types.this.Type]" id="462600">ts</a>, <a href="#462599" title="List[Types.this.Symbol]" id="462601">tparams</a><span class="delimiter">)</span> = <a href="#67638" title="(ts: List[Types.this.Type])(List[Types.this.Type], List[Types.this.Symbol])">stripExistentialsAndTypeVars</a><span title="(List[Types.this.Type], List[Types.this.Symbol]) @unchecked" class="delimiter">(</span><a href="#462592" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="462602">lubBaseTypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#67627" title="(tsParams: List[List[Types.this.Symbol]], tsBts: List[List[Types.this.Type]], depth: Int)List[Types.this.Type]">lubList</a><span class="delimiter">(</span><a href="#462600" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; List[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Symbol],List[List[Types.this.Symbol]]])List[List[Types.this.Symbol]]">map</span> <span class="delimiter">(</span><a href="#462644" title="Types.this.Type">_</a>.<a href="#105477" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span>, <a href="#462600" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a href="#462682" title="Types.this.Type">_</a>.<a href="#105524" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#197575" title="=&gt; List[Types.this.Type]">toList</a><span class="delimiter">)</span>, <a href="#222401" title="Int">depth</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="462603">lubParents</a> = <a href="#67629" title="(ts: List[Types.this.Type])List[Types.this.Type]">spanningTypes</a><span class="delimiter">(</span><a href="#462602" title="List[Types.this.Type]">lubBaseTypes</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="462604">lubOwner</a> = <a href="#67661" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#462600" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="462605">lubBase</a> = <a href="#67487" title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="#462603" title="List[Types.this.Type]">lubParents</a>, <a href="#462604" title="Types.this.Symbol">lubOwner</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="462606">lubType</a> =
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#222401" title="Int">depth</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#462605" title="Types.this.Type">lubBase</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="462724">lubRefined</a> = <a href="#67481" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#462603" title="List[Types.this.Type]">lubParents</a>, <a href="#462604" title="Types.this.Symbol">lubOwner</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="462725">lubThisType</a> = <a href="#462724" title="Types.this.Type">lubRefined</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107600" title="=&gt; Types.this.Type">thisType</a>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="462726">narrowts</a> = <a href="#462600" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#462743" title="Types.this.Type">_</a>.<a href="#105461" title="=&gt; Types.this.Type">narrow</a><span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(proto: Types.this.Symbol)Types.this.Symbol" id="462727">lubsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="462771">proto</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="462772">prototp</a> = <a href="#462725" title="Types.this.Type">lubThisType</a>.<a href="#105501" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#462771" title="Types.this.Symbol">proto</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="462773">syms</a> = <a href="#462726" title="List[Types.this.Type]">narrowts</a> <span title="(f: Types.this.Type =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <span class="delimiter">(</span><a title="Types.this.Type" id="462790">t</a> =&gt;
              <a href="#462790" title="Types.this.Type">t</a>.<a href="#105496" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#462771" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107593" title="(cond: Types.this.Symbol =&gt; Boolean)Types.this.Symbol">suchThat</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="462792">sym</a> =&gt;
                <a href="#462792" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a> <a href="#105522" title="(that: Types.this.Type)Boolean">matches</a> <a href="#462772" title="Types.this.Type">prototp</a>.<a href="#105506" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#462725" title="Types.this.Type">lubThisType</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#462790" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#462773" title="List[Types.this.Symbol]">syms</a> <span title="(elem: Any)Boolean">contains</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a>
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="List[Types.this.Type]" id="462820">symtypes</a> =
                <span title="(_1: List[Types.this.Type], _2: List[Types.this.Symbol])(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</span><a href="#462726" title="List[Types.this.Type]">narrowts</a>, <a href="#462773" title="List[Types.this.Symbol]">syms</a><span class="delimiter">)</span>.<span title="(implicit w1: List[Types.this.Type] =&gt; scala.collection.TraversableLike[Types.this.Type,List[Types.this.Type]], implicit w2: List[Types.this.Symbol] =&gt; scala.collection.IterableLike[Types.this.Symbol,List[Types.this.Symbol]])(List[Types.this.Type], List[Types.this.Symbol])#Zipped[List[Types.this.Type],Types.this.Type,List[Types.this.Symbol],Types.this.Symbol]">zipped</span> <span title="(f: (Types.this.Type, Types.this.Symbol) =&gt; Types.this.Type)(implicit cbf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="462875">t</a>, <a title="Types.this.Symbol" id="462876">sym</a><span class="delimiter">)</span> =&gt; <a href="#462875" title="Types.this.Type">t</a>.<a href="#105501" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#462876" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#105506" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#462875" title="Types.this.Type">t</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#462725" title="Types.this.Type">lubThisType</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#462771" title="Types.this.Symbol">proto</a>.<span title="=&gt; Boolean">isTerm</span><span class="delimiter">)</span> <span class="comment">// possible problem: owner of info is still the old one, instead of new refinement class</span>
                <a href="#462771" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#107595" title="(owner: Types.this.Symbol)Types.this.Symbol">cloneSymbol</a><span class="delimiter">(</span><a href="#462724" title="Types.this.Type">lubRefined</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107567" title="(info: Types.this.Type)Types.this.Symbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span><a href="#67650" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#462820" title="List[Types.this.Type]">symtypes</a>, <a href="#67375" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#222401" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#462820" title="List[Types.this.Type]">symtypes</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#462820" title="List[Types.this.Type]">symtypes</a>.<a href="#462921" title="=&gt; Types.this.Type">head</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#462771" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#107595" title="(owner: Types.this.Symbol)Types.this.Symbol">cloneSymbol</a><span class="delimiter">(</span><a href="#462724" title="Types.this.Type">lubRefined</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107567" title="(info: Types.this.Type)Types.this.Symbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span><a href="#462820" title="List[Types.this.Type]">symtypes</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span class="delimiter">{</span>
                <span class="keyword">def</span> <a title="(bnds: List[Types.this.TypeBounds])Types.this.TypeBounds" id="462926">lubBounds</a><span class="delimiter">(</span><a title="List[Types.this.TypeBounds]" id="462927">bnds</a>: <span title="List[Types.this.TypeBounds]">List</span><span class="delimiter">[</span>TypeBounds<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#148517" title="Types.this.TypeBounds">TypeBounds</a> =
                  <a href="#148501" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#67659" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#462927" title="List[Types.this.TypeBounds]">bnds</a> <span title="(f: Types.this.TypeBounds =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeBounds],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#462948" title="Types.this.TypeBounds">_</a>.<a href="#148531" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#67375" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#222401" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#67650" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#462927" title="List[Types.this.TypeBounds]">bnds</a> <span title="(f: Types.this.TypeBounds =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeBounds],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#462990" title="Types.this.TypeBounds">_</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#67375" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#222401" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#462724" title="Types.this.Type">lubRefined</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107440" title="(pos: Types.this.Position, name: Types.this.TypeName)Types.this.TypeSymbol">newAbstractType</a><span class="delimiter">(</span><a href="#462771" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#107404" title="=&gt; Types.this.Position">pos</a>, <a href="#462771" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#96599" title="=&gt; Types.this.TypeName">toTypeName</a><span class="delimiter">)</span>
                  .<a href="Symbols.scala.html#107567" title="(info: Types.this.Type)Types.this.TypeSymbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span><a href="#462926" title="(bnds: List[Types.this.TypeBounds])Types.this.TypeBounds">lubBounds</a><span class="delimiter">(</span><a href="#462820" title="List[Types.this.Type]">symtypes</a> <span title="(f: Types.this.Type =&gt; Types.this.TypeBounds)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.TypeBounds,List[Types.this.TypeBounds]])List[Types.this.TypeBounds]">map</span> <span class="delimiter">(</span><a href="#463052" title="Types.this.Type">_</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean" id="462728">refines</a><span class="delimiter">(</span><a title="Types.this.Type" id="463080">tp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="463081">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="463082">syms</a> = <a href="#463080" title="Types.this.Type">tp</a>.<a href="#105496" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#463081" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107591" title="=&gt; List[Types.this.Symbol]">alternatives</a>;
            <span title="=&gt; Boolean">!</span><a href="#463082" title="List[Types.this.Symbol]">syms</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#463082" title="List[Types.this.Symbol]">syms</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="463089">alt</a> =&gt;
              <span class="comment">// todo alt != sym is strictly speaking not correct, but without it we lose </span>
              <span class="comment">// efficiency.</span>
              <a href="#463089" title="Types.this.Symbol">alt</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#463081" title="Types.this.Symbol">sym</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#67615" title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#462725" title="Types.this.Type">lubThisType</a>, <a href="#463081" title="Types.this.Symbol">sym</a>, <a href="#463080" title="Types.this.Type">tp</a>, <a href="#463089" title="Types.this.Symbol">alt</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="463119">sym</a> &lt;- <a href="#462605" title="Types.this.Type">lubBase</a>.<a href="#105491" title="(f: Types.this.Symbol =&gt; Unit)Unit">nonPrivateMembers</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="comment">// add a refinement symbol for all non-class members of lubBase</span>
            <span class="comment">// which are refined by every type in ts.</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#463119" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#463119" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107475" title="=&gt; Boolean">isConstructor</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#462726" title="List[Types.this.Type]">narrowts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.Type" id="463126">t</a> =&gt; <a href="#462728" title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean">refines</a><span class="delimiter">(</span><a href="#463126" title="Types.this.Type">t</a>, <a href="#463119" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">try</span> <span class="delimiter">{</span>
                <span class="keyword">val</span> <a title="Types.this.Symbol" id="463127">lsym</a> = <a href="#462727" title="(proto: Types.this.Symbol)Types.this.Symbol">lubsym</a><span class="delimiter">(</span><a href="#463119" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
                <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#463127" title="Types.this.Symbol">lsym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#67663" title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol)Unit">addMember</a><span class="delimiter">(</span><a href="#462725" title="Types.this.Type">lubThisType</a>, <a href="#462724" title="Types.this.Type">lubRefined</a>, <a href="#462727" title="(proto: Types.this.Symbol)Types.this.Symbol">lubsym</a><span class="delimiter">(</span><a href="#463119" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <a title="Unit" id="463132">ex</a>: <a href="#67670" title="Types.this.NoCommonType">NoCommonType</a> =&gt;
              <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#462724" title="Types.this.Type">lubRefined</a>.<a href="#105487" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113083" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#462605" title="Types.this.Type">lubBase</a>
          <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span title="Boolean(true)">verifyLubs</span><span class="delimiter">)</span> <a href="#462724" title="Types.this.Type">lubRefined</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="comment">// Verify that every given type conforms to the calculated lub.</span>
            <span class="comment">// In theory this should not be necessary, but higher-order type</span>
            <span class="comment">// parameters are not handled correctly.</span>
            <span class="keyword">val</span> <a title="Boolean" id="463138">ok</a> = <a href="#462600" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">{</span> <a title="Types.this.Type" id="463145">t</a> =&gt;
              <span class="delimiter">(</span><a href="#463145" title="Types.this.Type">t</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#462724" title="Types.this.Type">lubRefined</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">{</span>
                <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <span title="object Console">Console</span>.<span title="(x: Any)Unit">println</span><span class="delimiter">(</span>
                    <span title="java.lang.String(&quot;Malformed lub: &quot;)" class="string">&quot;Malformed lub: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#462724" title="Types.this.Type">lubRefined</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;\012&quot;)" class="string">&quot;\n&quot;</span> <span title="(x$1: Any)java.lang.String">+</span>
                    <span title="java.lang.String(&quot;Argument &quot;)" class="string">&quot;Argument &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#463145" title="Types.this.Type">t</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; does not conform.  Falling back to &quot;)" class="string">&quot; does not conform.  Falling back to &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#462605" title="Types.this.Type">lubBase</a>
                  <span class="delimiter">)</span>
                <span class="delimiter">}</span>
                <span title="Boolean(false)" class="keyword">false</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="comment">// If not, fall back on the more conservative calculation.</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#463138" title="Boolean">ok</a><span class="delimiter">)</span> <a href="#462724" title="Types.this.Type">lubRefined</a>
            <span class="keyword">else</span> <a href="#462605" title="Types.this.Type">lubBase</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <a href="#67493" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#462601" title="List[Types.this.Symbol]">tparams</a>, <a href="#462606" title="Types.this.Type">lubType</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="Boolean(false)">printLubs</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#67674" title="=&gt; String">indent</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;lub of &quot;)" class="string">&quot;lub of &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#222400" title="List[Types.this.Type]">ts</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; at depth &quot;)" class="string">&quot; at depth &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#222401" title="Int">depth</a><span class="delimiter">)</span><span class="comment">//debug</span>
      <a href="#67674" title="(x$1: String)Unit">indent</a> = <a href="#67674" title="=&gt; String">indent</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#67674" title="=&gt; String">indent</a>.<span title="()Int">length</span> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(100)" class="int">100</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="Types.this.Type" id="462234">res</a> = <a href="#462232" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#222400" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="Boolean(false)">printLubs</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#67674" title="(x$1: String)Unit">indent</a> = <a href="#67674" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">indent</a> <span title="(n: Int)String">dropRight</span> <span title="Int(2)" class="int">2</span>
      <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#67674" title="=&gt; String">indent</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;lub of &quot;)" class="string">&quot;lub of &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#222400" title="List[Types.this.Type]">ts</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; is &quot;)" class="string">&quot; is &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#462234" title="Types.this.Type">res</a><span class="delimiter">)</span><span class="comment">//debug</span>
    <span class="delimiter">}</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#222400" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#463177" title="Types.this.Type">_</a>.<a href="#105448" title="=&gt; Boolean">isNotNull</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462234" title="Types.this.Type">res</a>.<a href="#105479" title="=&gt; Types.this.Type">notNull</a> <span class="keyword">else</span> <a href="#462234" title="Types.this.Type">res</a>
  <span class="delimiter">}</span>

  <span class="keyword">val</span> <a title="java.lang.Throwable" id="67651">GlbFailure</a> = <span title="java.lang.Throwable" class="keyword">new</span> <span title="java.lang.Throwable">Throwable</span>

  <span class="comment">/** A global counter for glb calls in the `specializes' query connected to the `addMembers'
   *  call in `glb'. There's a possible infinite recursion when `specializes' calls
   *  memberType, which calls baseTypeSeq, which calls mergePrefixAndArgs, which calls glb.
   *  The counter breaks this recursion after two calls.
   *  If the recursion is broken, no member is added to the glb.
   */</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="67654">globalGlbDepth</a> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(2)" id="67656">globalGlbLimit</a> = <span title="Int(2)" class="int">2</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="67658">glb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="372375">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="#67659" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#372375" title="List[Types.this.Type]">ts</a>, <a href="#67568" title="(ts: List[Types.this.Type])Int">lubDepth</a><span class="delimiter">(</span><a href="#372375" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#67645" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">lubResults</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#67647" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">glbResults</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The greatest lower bound wrt &lt;:&lt; of a list of types */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)Types.this.Type" id="67659">glb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461266">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="461267">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="463182">glb0</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="463185">ts0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#67630" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSuper</a><span class="delimiter">(</span><a href="#463185" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#463187" title="Types.this.Type">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
      <span class="keyword">case</span> <a href="#463199" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="463210">t</a><span class="delimiter">)</span> =&gt; <a href="#463210" title="Types.this.Type">t</a>
      <span class="keyword">case</span> <a title="Types.this.PolyType" id="463211">ts</a> @ PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="463216">tparams</a>, _<span class="delimiter">)</span> :: _ =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="463217">tparams1</a> = <span title="(_1: List[Types.this.Symbol], _2: List[List[Types.this.Type]])(List[Types.this.Symbol], List[List[Types.this.Type]])" class="delimiter">(</span><a href="#463216" title="List[Types.this.Symbol]">tparams</a>, <a href="#67664" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[List[Types.this.Type]]">matchingBounds</a><span class="delimiter">(</span><a href="#463211" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#463216" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>.<span title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.TraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</span><span class="delimiter">)</span>.<span title="(implicit w1: List[Types.this.Symbol] =&gt; scala.collection.TraversableLike[Types.this.Symbol,List[Types.this.Symbol]], implicit w2: List[List[Types.this.Type]] =&gt; scala.collection.IterableLike[List[Types.this.Type],List[List[Types.this.Type]]])(List[Types.this.Symbol], List[List[Types.this.Type]])#Zipped[List[Types.this.Symbol],Types.this.Symbol,List[List[Types.this.Type]],List[Types.this.Type]]">zipped</span> <span title="(f: (Types.this.Symbol, List[Types.this.Type]) =&gt; Types.this.Symbol)(implicit cbf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span>
          <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="463311">tparam</a>, <a title="List[Types.this.Type]" id="463312">bounds</a><span class="delimiter">)</span> =&gt; <a href="#463311" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107594" title="=&gt; Types.this.Symbol">cloneSymbol</a>.<a href="Symbols.scala.html#107566" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a><span class="delimiter">(</span><a href="#67650" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#463312" title="List[Types.this.Type]">bounds</a>, <a href="#461267" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#148921" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#463217" title="List[Types.this.Symbol]">tparams1</a>, <a href="#463182" title="(ts0: List[Types.this.Type])Types.this.Type">glb0</a><span class="delimiter">(</span><a href="#67665" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">matchingInstTypes</a><span class="delimiter">(</span><a href="#463211" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#463217" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.MethodType" id="463347">ts</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="463352">params</a>, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="463353">rest</a> =&gt;
        <a href="#148762" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#463352" title="List[Types.this.Symbol]">params</a>, <a href="#463182" title="(ts0: List[Types.this.Type])Types.this.Type">glb0</a><span class="delimiter">(</span><a href="#67666" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span><a href="#463347" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#463352" title="List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#463370" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.NullaryMethodType" id="463398">ts</a> @ NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="463403">rest</a> =&gt;
        <a href="#148865" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#463182" title="(ts0: List[Types.this.Type])Types.this.Type">glb0</a><span class="delimiter">(</span><a href="#67666" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span><a href="#463398" title="collection.immutable.::[Types.this.Type]">ts</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.TypeBounds" id="463404">ts</a> @ TypeBounds<span class="delimiter">(</span>_, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="463409">rest</a> =&gt;
        <a href="#148501" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#67650" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#463404" title="collection.immutable.::[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#463430" title="Types.this.Type">_</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148531" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#461267" title="Int">depth</a><span class="delimiter">)</span>, <a href="#67659" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#463404" title="collection.immutable.::[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#463472" title="Types.this.Type">_</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#461267" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="463500">ts</a> =&gt;
        <a href="#67647" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">glbResults</a> <span title="(key: (Int, List[Types.this.Type]))Option[Types.this.Type]">get</span> <span class="delimiter">(</span><a href="#461267" title="Int">depth</a>, <a href="#463500" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Types.this.Type">Some</span><span class="delimiter">(</span><a title="Types.this.Type" id="463511">glbType</a><span class="delimiter">)</span> =&gt;
            <a href="#463511" title="Types.this.Type">glbType</a>
          <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
            <a href="#67647" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">glbResults</a><span class="delimiter">(</span><span title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</span><a href="#461267" title="Int">depth</a>, <a href="#463500" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="463512">res</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461267" title="Int">depth</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#463183" title="(ts0: List[Types.this.Type])Types.this.Type">glb1</a><span class="delimiter">(</span><a href="#463500" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
            <a href="#67647" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">glbResults</a><span class="delimiter">(</span><span title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</span><a href="#461267" title="Int">depth</a>, <a href="#463500" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="#463512" title="Types.this.Type">res</a>
            <a href="#463512" title="Types.this.Type">res</a>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="463183">glb1</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="463527">ts0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a href="#463535" title="(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</a><a href="#463534" title="List[Types.this.Type]" id="463535">ts</a>, <a href="#463534" title="List[Types.this.Symbol]" id="463536">tparams</a><span class="delimiter">)</span> = <a href="#67638" title="(ts: List[Types.this.Type])(List[Types.this.Type], List[Types.this.Symbol])">stripExistentialsAndTypeVars</a><span title="(List[Types.this.Type], List[Types.this.Symbol]) @unchecked" class="delimiter">(</span><a href="#463527" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="463537">glbOwner</a> = <a href="#67661" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#463535" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="(t: Types.this.Type)List[Types.this.Type]" id="463538">refinedToParents</a><span class="delimiter">(</span><a title="Types.this.Type" id="463559">t</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#463559" title="Types.this.Type">t</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="List[Types.this.Type]">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="463560">ps</a>, _<span class="delimiter">)</span> =&gt; <a href="#463560" title="List[Types.this.Type]">ps</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">flatMap</span> <a href="#463538" title="(t: Types.this.Type)List[Types.this.Type]">refinedToParents</a>
          <span class="keyword">case</span> <span title="List[Types.this.Type]">_</span> =&gt; <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#463559" title="Types.this.Type">t</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(t: Types.this.Type)List[Types.this.Scope]" id="463539">refinedToDecls</a><span class="delimiter">(</span><a title="Types.this.Type" id="463612">t</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="List[Types.this.Scope]">List</span><span class="delimiter">[</span>Scope<span class="delimiter">]</span> = <a href="#463612" title="Types.this.Type">t</a> <span title="List[Types.this.Scope]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="List[Types.this.Scope]">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="463613">ps</a>, <a title="Types.this.Scope" id="463614">decls</a><span class="delimiter">)</span> =&gt; 
            <span class="keyword">val</span> <a title="List[Types.this.Scope]" id="463615">dss</a> = <a href="#463613" title="List[Types.this.Type]">ps</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Scope])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Scope,List[Types.this.Scope]])List[Types.this.Scope]">flatMap</span> <a href="#463539" title="(t: Types.this.Type)List[Types.this.Scope]">refinedToDecls</a>
            <span title="List[Types.this.Scope]" class="keyword">if</span> <span class="delimiter">(</span><a href="#463614" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113083" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#463615" title="List[Types.this.Scope]">dss</a> <span class="keyword">else</span> <a href="#463614" title="Types.this.Scope">decls</a> <a href="#463660" title="(x: Types.this.Scope)List[Types.this.Scope]">::</a> <a href="#463615" title="List[Types.this.Scope]">dss</a>
          <span class="keyword">case</span> <span title="List[Nothing]">_</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="463540">ts1</a> = <a href="#463535" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">flatMap</span> <a href="#463538" title="(t: Types.this.Type)List[Types.this.Type]">refinedToParents</a> 
        <span class="keyword">val</span> <a title="Types.this.Type" id="463541">glbBase</a> = <a href="#67487" title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="#463540" title="List[Types.this.Type]">ts1</a>, <a href="#463537" title="Types.this.Symbol">glbOwner</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="463542">glbType</a> = 
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#461267" title="Int">depth</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#463541" title="Types.this.Type">glbBase</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="463725">glbRefined</a> = <a href="#67481" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#463540" title="List[Types.this.Type]">ts1</a>, <a href="#463537" title="Types.this.Symbol">glbOwner</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="463726">glbThisType</a> = <a href="#463725" title="Types.this.Type">glbRefined</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107600" title="=&gt; Types.this.Type">thisType</a>
            <span class="keyword">def</span> <a title="(proto: Types.this.Symbol)Types.this.Symbol" id="463727">glbsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="463732">proto</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="463733">prototp</a> = <a href="#463726" title="Types.this.Type">glbThisType</a>.<a href="#105501" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#463732" title="Types.this.Symbol">proto</a><span class="delimiter">)</span>
              <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="463734">syms</a> = <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="463746">t</a> &lt;- <a href="#463535" title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">ts</a>;
                    <a title="Types.this.Symbol" id="463761">alt</a> &lt;- <span class="delimiter">(</span><a href="#463746" title="Types.this.Type">t</a>.<a href="#105496" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#463732" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107591" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">alternatives</a><span class="delimiter">)</span>;
                <span class="keyword">if</span> <a href="#463726" title="Types.this.Type">glbThisType</a>.<a href="#105501" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#463761" title="Types.this.Symbol">alt</a><span class="delimiter">)</span> <a href="#105522" title="(that: Types.this.Type)Boolean">matches</a> <a href="#463733" title="Types.this.Type">prototp</a>
              <span class="delimiter">)</span> <span class="keyword">yield</span> <a href="#463761" title="Types.this.Symbol">alt</a>
              <span class="keyword">val</span> <a title="List[Types.this.Type]" id="463735">symtypes</a> = <a href="#463734" title="List[Types.this.Symbol]">syms</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#463726" title="Types.this.Type">glbThisType</a>.<a href="#105501" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a>
              <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#463735" title="List[Types.this.Type]">symtypes</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
              <a href="#463732" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#107595" title="(owner: Types.this.Symbol)Types.this.Symbol">cloneSymbol</a><span class="delimiter">(</span><a href="#463725" title="Types.this.Type">glbRefined</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107567" title="(info: Types.this.Type)Types.this.Symbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span>
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#463732" title="Types.this.Symbol">proto</a>.<span title="=&gt; Boolean">isTerm</span><span class="delimiter">)</span> <a href="#67659" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#463735" title="List[Types.this.Type]">symtypes</a>, <a href="#67375" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#461267" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span class="delimiter">{</span>
                  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="463872">isTypeBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="463876">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#463876" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
                    <span class="keyword">case</span> <span title="Boolean(true)">TypeBounds</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
                    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span> 
                  <span class="delimiter">}</span>
                  <span class="keyword">def</span> <a title="(bnds: List[Types.this.Type])Types.this.TypeBounds" id="463873">glbBounds</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="463877">bnds</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#148517" title="Types.this.TypeBounds">TypeBounds</a> = <span class="delimiter">{</span>
                    <span class="keyword">val</span> <a title="Types.this.Type" id="463878">lo</a> = <a href="#67650" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#463877" title="List[Types.this.Type]">bnds</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#463900" title="Types.this.Type">_</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148531" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#67375" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#461267" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="keyword">val</span> <a title="Types.this.Type" id="463879">hi</a> = <a href="#67659" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#463877" title="List[Types.this.Type]">bnds</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#463942" title="Types.this.Type">_</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148532" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#67375" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#461267" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span title="Types.this.TypeBounds" class="keyword">if</span> <span class="delimiter">(</span><a href="#463878" title="Types.this.Type">lo</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#463879" title="Types.this.Type">hi</a><span class="delimiter">)</span> <a href="#148501" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#463878" title="Types.this.Type">lo</a>, <a href="#463879" title="Types.this.Type">hi</a><span class="delimiter">)</span>
                    <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <a href="#67651" title="=&gt; java.lang.Throwable">GlbFailure</a>
                  <span class="delimiter">}</span>
                  <span class="keyword">val</span> <a title="List[Types.this.Type]" id="463874">symbounds</a> = <a href="#463735" title="List[Types.this.Type]">symtypes</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <a href="#463872" title="(tp: Types.this.Type)Boolean">isTypeBound</a>
                  <span class="keyword">var</span> <a title="Types.this.Type" id="463875">result</a>: <a href="#67392" title="Types.this.Type">Type</a> =
                    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#463874" title="List[Types.this.Type]">symbounds</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
                      <a href="#67423" title="object Types.this.TypeBounds">TypeBounds</a>.<a href="#148498" title="=&gt; Types.this.TypeBounds">empty</a>
                    <span class="keyword">else</span> <a href="#463873" title="(bnds: List[Types.this.Type])Types.this.TypeBounds">glbBounds</a><span class="delimiter">(</span><a href="#463874" title="List[Types.this.Type]">symbounds</a><span class="delimiter">)</span>
                  <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="463982">t</a> &lt;- <a href="#463735" title="(f: Types.this.Type =&gt; Unit)Unit">symtypes</a> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#463872" title="(tp: Types.this.Type)Boolean">isTypeBound</a><span class="delimiter">(</span><a href="#463982" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#463875" title="Types.this.Type">result</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a> <a href="#148513" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#463982" title="Types.this.Type">t</a><span class="delimiter">)</span> <a href="#463875" title="Types.this.Type">result</a> = <a href="#463982" title="Types.this.Type">t</a>
                    <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <a href="#67651" title="=&gt; java.lang.Throwable">GlbFailure</a>
                  <a href="#463875" title="Types.this.Type">result</a>
                <span class="delimiter">}</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#67654" title="=&gt; Int">globalGlbDepth</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(2)">globalGlbLimit</span><span class="delimiter">)</span>
              <span class="keyword">try</span> <span class="delimiter">{</span>
                <a href="#67654" title="(x$1: Int)Unit">globalGlbDepth</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
                <span class="keyword">val</span> <a title="List[Types.this.Scope]" id="463988">dss</a> = <a href="#463535" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Scope])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Scope,List[Types.this.Scope]])List[Types.this.Scope]">flatMap</span> <a href="#463539" title="(t: Types.this.Type)List[Types.this.Scope]">refinedToDecls</a>
                <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Scope" id="464050">ds</a> &lt;- <a href="#463988" title="(f: Types.this.Scope =&gt; Unit)Unit">dss</a>; <span class="keyword">val</span> <a title="Types.this.Symbol" id="464061">sym</a> &lt;- <a href="#464050" title="Types.this.Scope">ds</a>.<a href="Scopes.scala.html#113099" title="(f: Types.this.Symbol =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span> 
                  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#67654" title="=&gt; Int">globalGlbDepth</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(2)">globalGlbLimit</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#463726" title="Types.this.Type">glbThisType</a> <a href="#105521" title="(sym: Types.this.Symbol)Boolean">specializes</a> <a href="#464061" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="keyword">try</span> <span class="delimiter">{</span>
                      <a href="#67663" title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol)Unit">addMember</a><span class="delimiter">(</span><a href="#463726" title="Types.this.Type">glbThisType</a>, <a href="#463725" title="Types.this.Type">glbRefined</a>, <a href="#463727" title="(proto: Types.this.Symbol)Types.this.Symbol">glbsym</a><span class="delimiter">(</span><a href="#464061" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
                      <span class="keyword">case</span> <a title="Unit" id="464066">ex</a>: <a href="#67670" title="Types.this.NoCommonType">NoCommonType</a> =&gt;
                    <span class="delimiter">}</span> 
              <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                <a href="#67654" title="(x$1: Int)Unit">globalGlbDepth</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
              <span class="delimiter">}</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#463725" title="Types.this.Type">glbRefined</a>.<a href="#105487" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#113083" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#463541" title="Types.this.Type">glbBase</a> <span class="keyword">else</span> <a href="#463725" title="Types.this.Type">glbRefined</a>
          <span class="delimiter">}</span>
        <a href="#67493" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#463536" title="List[Types.this.Symbol]">tparams</a>, <a href="#463542" title="Types.this.Type">glbType</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="#67651" title="Types.this.Type">GlbFailure</a> =&gt;
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461266" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.Type" id="464080">t</a> =&gt; <a href="Definitions.scala.html#106226" title="=&gt; Types.this.Symbol">NullClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#464080" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Definitions.scala.html#106226" title="=&gt; Types.this.Symbol">NullClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
          <span class="keyword">else</span> <a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="comment">// if (settings.debug.value) { println(indent + &quot;glb of &quot; + ts + &quot; at depth &quot;+depth); indent = indent + &quot;  &quot; } //DEBUG</span>

    <span class="keyword">val</span> <a title="Types.this.Type" id="463184">res</a> = <a href="#463182" title="(ts0: List[Types.this.Type])Types.this.Type">glb0</a><span class="delimiter">(</span><a href="#461266" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>

    <span class="comment">// if (settings.debug.value) { indent = indent.substring(0, indent.length() - 2); log(indent + &quot;glb of &quot; + ts + &quot; is &quot; + res) }//DEBUG</span>

    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461266" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#464087" title="Types.this.Type">_</a>.<a href="#105448" title="=&gt; Boolean">isNotNull</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#463184" title="Types.this.Type">res</a>.<a href="#105479" title="=&gt; Types.this.Type">notNull</a> <span class="keyword">else</span> <a href="#463184" title="Types.this.Type">res</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The most deeply nested owner that contains all the symbols
   *  of thistype or prefixless typerefs/singletype occurrences in given type.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(t: Types.this.Type)Types.this.Symbol" id="67660">commonOwner</a><span class="delimiter">(</span><a title="Types.this.Type" id="449682">t</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
    <a href="#67557" title="object Types.this.commonOwnerMap">commonOwnerMap</a>.<a href="#459666" title="()Unit">init</a>
    <a href="#67557" title="object Types.this.commonOwnerMap">commonOwnerMap</a>.<a href="#459667" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#449682" title="Types.this.Type">t</a><span class="delimiter">)</span>
    <a href="#67557" title="object Types.this.commonOwnerMap">commonOwnerMap</a>.<a href="#459664" title="=&gt; Types.this.Symbol">result</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The most deeply nested owner that contains all the symbols
   *  of thistype or prefixless typerefs/singletype occurrences in given list
   *  of types.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type])Types.this.Symbol" id="67661">commonOwner</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="449680">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
    <span class="comment">// if (settings.debug.value) log(&quot;computing common owner of types &quot; + tps)//DEBUG</span>
    <a href="#67557" title="object Types.this.commonOwnerMap">commonOwnerMap</a>.<a href="#459666" title="()Unit">init</a>
    <a href="#449680" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="Types.this.Type" id="464108">tp</a> =&gt; <a href="#67557" title="object Types.this.commonOwnerMap">commonOwnerMap</a>.<a href="#459667" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#464108" title="Types.this.Type">tp</a><span class="delimiter">)</span>; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#67557" title="object Types.this.commonOwnerMap">commonOwnerMap</a>.<a href="#459664" title="=&gt; Types.this.Symbol">result</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Compute lub (if variance == 1) or glb (if variance == -1) of given list
   *  of types `tps'. All types in `tps' are typerefs or singletypes
   *  with the same symbol.
   *  Return `Some(x)' if the computation succeeds with result `x'.
   *  Return `None' if the computation fails.
   */</span>
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], variance: Int, depth: Int)Option[Types.this.Type]" id="67662">mergePrefixAndArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="419359">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="419360">variance</a>: <span title="Int">Int</span>, <a title="Int" id="419361">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Option[Types.this.Type]">Option</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#419359" title="List[Types.this.Type]">tps</a> <span title="Option[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#464111" title="Some[Types.this.Type]">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="464122">tp</a><span class="delimiter">)</span> =&gt;
      <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#464122" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Option[Types.this.Type]">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="464130">sym</a>, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="464131">rest</a> =&gt;
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="464132">pres</a> = <a href="#419359" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#464152" title="Types.this.Type">_</a>.<a href="#105464" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span> <span class="comment">// prefix normalizes automatically</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="464133">pre</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#419360" title="Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#67650" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#464132" title="List[Types.this.Type]">pres</a>, <a href="#419361" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#67659" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#464132" title="List[Types.this.Type]">pres</a>, <a href="#419361" title="Int">depth</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="464134">argss</a> = <a href="#419359" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a href="#464202" title="Types.this.Type">_</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a>.<a href="#105467" title="=&gt; List[Types.this.Type]">typeArgs</a><span class="delimiter">)</span> <span class="comment">// symbol equality (of the tp in tps) was checked using typeSymbol, which normalizes, so should normalize before retrieving arguments</span>
      <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[Types.this.Symbol]" id="464135">capturedParams</a> = <span title="scala.collection.mutable.ListBuffer[Types.this.Symbol]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">ListBuffer</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464130" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106394" title="=&gt; Types.this.Symbol">ArrayClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="comment">// special treatment for lubs of array types after erasure:</span>
          <span class="comment">// if argss contain one value type and some other type, the lub is Object</span>
          <span class="comment">// if argss contain several reference types, the lub is an array over lub of argtypes</span>
          <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464134" title="List[List[Types.this.Type]]">argss</a> <span title="(p: List[Types.this.Type] =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#464240" title="List[Types.this.Type]">_</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="object None">None</span>  <span class="comment">// something is wrong: an array without a type arg.</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[Types.this.Type]" id="464241">args</a> = <a href="#464134" title="List[List[Types.this.Type]]">argss</a> <span title="(f: List[Types.this.Type] =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#464258" title="List[Types.this.Type]">_</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span>
            <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464241" title="List[Types.this.Type]">args</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#464294" title="Types.this.Type">_</a> <a href="#105520" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#464241" title="List[Types.this.Type]">args</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#67483" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#464133" title="Types.this.Type">pre</a>, <a href="#464130" title="Types.this.Symbol">sym</a>, <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#464241" title="List[Types.this.Type]">args</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword">else</span> <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464241" title="List[Types.this.Type]">args</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a title="Types.this.Type" id="464311">arg</a> =&gt; <a href="Definitions.scala.html#106661" title="(sym: Types.this.Symbol)Boolean">isValueClass</a><span class="delimiter">(</span><a href="#464311" title="Types.this.Type">arg</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="Definitions.scala.html#106220" title="=&gt; Types.this.Symbol">ObjectClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#67483" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#464133" title="Types.this.Type">pre</a>, <a href="#464130" title="Types.this.Symbol">sym</a>, <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#67649" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#464241" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="464329">args</a> = <span title="(_1: List[Types.this.Symbol], _2: List[List[Types.this.Type]])(List[Types.this.Symbol], List[List[Types.this.Type]])" class="delimiter">(</span><a href="#464130" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#464134" title="List[List[Types.this.Type]]">argss</a>.<span title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.TraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</span><span class="delimiter">)</span>.<span title="(implicit w1: List[Types.this.Symbol] =&gt; scala.collection.TraversableLike[Types.this.Symbol,List[Types.this.Symbol]], implicit w2: List[List[Types.this.Type]] =&gt; scala.collection.IterableLike[List[Types.this.Type],List[List[Types.this.Type]]])(List[Types.this.Symbol], List[List[Types.this.Type]])#Zipped[List[Types.this.Symbol],Types.this.Symbol,List[List[Types.this.Type]],List[Types.this.Type]]">zipped</span> <span title="(f: (Types.this.Symbol, List[Types.this.Type]) =&gt; Types.this.Type)(implicit cbf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="464416">tparam</a>, <a title="List[Types.this.Type]" id="464417">as</a><span class="delimiter">)</span> =&gt;
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#419361" title="Int">depth</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#464416" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107540" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <a href="#419360" title="Int">variance</a><span class="delimiter">)</span> <a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
                <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#464416" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107540" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="=&gt; Int">-</span><a href="#419360" title="Int">variance</a><span class="delimiter">)</span> <a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
                <span class="keyword">else</span> <a href="#450913" title="object Types.this.NoType">NoType</a>
              <span class="keyword">else</span> <span class="delimiter">{</span>
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#464416" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107540" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <a href="#419360" title="Int">variance</a><span class="delimiter">)</span> <a href="#67650" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#464417" title="List[Types.this.Type]">as</a>, <a href="#67375" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#419361" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#464416" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107540" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="=&gt; Int">-</span><a href="#419360" title="Int">variance</a><span class="delimiter">)</span> <a href="#67659" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#464417" title="List[Types.this.Type]">as</a>, <a href="#67375" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#419361" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span class="delimiter">{</span>
                  <span class="keyword">val</span> <a title="Types.this.Type" id="464450">l</a> = <a href="#67650" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#464417" title="List[Types.this.Type]">as</a>, <a href="#67375" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#419361" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  <span class="keyword">val</span> <a title="Types.this.Type" id="464451">g</a> = <a href="#67659" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#464417" title="List[Types.this.Type]">as</a>, <a href="#67375" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#419361" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#464450" title="Types.this.Type">l</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#464451" title="Types.this.Type">g</a><span class="delimiter">)</span> <a href="#464450" title="Types.this.Type">l</a>
                  <span class="keyword">else</span> <span class="delimiter">{</span> <span class="comment">// Martin: I removed this, because incomplete. Not sure there is a good way to fix it. For the moment we</span>
                         <span class="comment">// just err on the conservative side, i.e. with a bound that is too high.</span>
                         <span class="comment">// if(!(tparam.info.bounds contains tparam)){ //@M can't deal with f-bounds, see #2251</span>

                    <span class="keyword">val</span> <a title="Types.this.Symbol" id="464460">qvar</a> = <a href="#67661" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#464417" title="List[Types.this.Type]">as</a><span class="delimiter">)</span> <a href="Symbols.scala.html#107445" title="(suffix: String)Types.this.Symbol">freshExistential</a> <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span> <a href="Symbols.scala.html#107566" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a> <a href="#148501" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#464451" title="Types.this.Type">g</a>, <a href="#464450" title="Types.this.Type">l</a><span class="delimiter">)</span>
                    <a href="#464135" title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">capturedParams</a> <span title="(x: Types.this.Symbol)capturedParams.type">+=</span> <a href="#464460" title="Types.this.Symbol">qvar</a>
                    <a href="#464460" title="Types.this.Symbol">qvar</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
                  <span class="delimiter">}</span>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464329" title="List[Types.this.Type]">args</a> <span title="(elem: Any)Boolean">contains</span> <a href="#450913" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="object None">None</span>
          <span class="keyword">else</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#67493" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#464135" title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">capturedParams</a>.<span title="=&gt; List[Types.this.Symbol]">toList</span>, <a href="#67483" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#464133" title="Types.this.Type">pre</a>, <a href="#464130" title="Types.this.Symbol">sym</a>, <a href="#464329" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="None.type" id="464506">ex</a>: <a href="#67671" title="Types.this.MalformedType">MalformedType</a> =&gt; <span title="object None">None</span>
        <span class="keyword">case</span> <a title="None.type" id="464507">ex</a>: <span title="IndexOutOfBoundsException">IndexOutOfBoundsException</span> =&gt;  <span class="comment">// transpose freaked out because of irregular argss</span>
        <span class="comment">// catching just in case (shouldn't happen, but also doesn't cost us)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="SymbolTable.scala.html#64789" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;transposed irregular matrix!?&quot;)" class="string">&quot;transposed irregular matrix!?&quot;</span><span title="(x$1: Any)java.lang.String">+</span> <span class="delimiter">(</span><a href="#419359" title="List[Types.this.Type]">tps</a>, <a href="#464134" title="List[List[Types.this.Type]]">argss</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="object None">None</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> <span title="Option[Types.this.Type]">SingleType</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="464521">sym</a><span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="464522">rest</a> =&gt;
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="464523">pres</a> = <a href="#419359" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#464541" title="Types.this.Type">_</a>.<a href="#105464" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="464524">pre</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#419360" title="Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#67650" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#464523" title="List[Types.this.Type]">pres</a>, <a href="#419361" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#67659" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#464523" title="List[Types.this.Type]">pres</a>, <a href="#419361" title="Int">depth</a><span class="delimiter">)</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#67479" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#464524" title="Types.this.Type">pre</a>, <a href="#464521" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="None.type" id="464584">ex</a>: <a href="#67671" title="Types.this.MalformedType">MalformedType</a> =&gt; <span title="object None">None</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> <span title="Option[Types.this.Type]">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="464589">tparams</a>, <a title="Types.this.Type" id="464590">quantified</a><span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="464591">rest</a> =&gt;
      <a href="#67662" title="(tps: List[Types.this.Type], variance: Int, depth: Int)Option[Types.this.Type]">mergePrefixAndArgs</a><span class="delimiter">(</span><a href="#464590" title="Types.this.Type">quantified</a> <a href="#464592" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#464591" title="List[Types.this.Type]">rest</a>, <a href="#419360" title="Int">variance</a>, <a href="#419361" title="Int">depth</a><span class="delimiter">)</span> <span title="(f: Types.this.Type =&gt; Types.this.Type)Option[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#67493" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#464589" title="List[Types.this.Symbol]">tparams</a>, <a href="#464602" title="Types.this.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="None.type">_</span> =&gt;
      <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span>, <a href="#419359" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>; <span title="object None">None</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Make symbol `sym' a member of scope `tp.decls'
   *  where `thistp' is the narrowed owner type of the scope.
   */</span>
  <span class="keyword">def</span> <a title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol)Unit" id="67663">addMember</a><span class="delimiter">(</span><a title="Types.this.Type" id="446247">thistp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="446248">tp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="446249">sym</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#446249" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
    <span class="comment">// if (settings.debug.value) log(&quot;add member &quot; + sym+&quot;:&quot;+sym.info+&quot; to &quot;+thistp) //DEBUG</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#446247" title="Types.this.Type">thistp</a> <a href="#105521" title="(sym: Types.this.Symbol)Boolean">specializes</a> <a href="#446249" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#446249" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isTerm</span><span class="delimiter">)</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="464633">alt</a> &lt;- <a href="#446248" title="Types.this.Type">tp</a>.<a href="#105489" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateDecl</a><span class="delimiter">(</span><a href="#446249" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107548" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107591" title="(f: Types.this.Symbol =&gt; Unit)Unit">alternatives</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#67615" title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#446247" title="Types.this.Type">thistp</a>, <a href="#446249" title="Types.this.Symbol">sym</a>, <a href="#446247" title="Types.this.Type">thistp</a>, <a href="#464633" title="Types.this.Symbol">alt</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#446248" title="Types.this.Type">tp</a>.<a href="#105487" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#113092" title="(sym: Types.this.Symbol)Unit">unlink</a> <a href="#464633" title="Types.this.Symbol">alt</a>;
      <a href="#446248" title="Types.this.Type">tp</a>.<a href="#105487" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#113086" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#446249" title="Types.this.Symbol">sym</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** All types in list must be polytypes with type parameter lists of
   *  same length as tparams.
   *  Returns list of list of bounds infos, where corresponding type
   *  parameters are renamed to tparams.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[List[Types.this.Type]]" id="67664">matchingBounds</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="462272">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="462273">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[List[Types.this.Type]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)List[Types.this.Type]" id="464655">getBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="464656">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#464656" title="Types.this.Type">tp</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="List[Types.this.Type]">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="464657">tparams1</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#464657" title="List[Types.this.Symbol]">tparams1</a>, <a href="#462273" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> =&gt;
        <a href="#464657" title="List[Types.this.Symbol]">tparams1</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="464676">tparam</a> =&gt; <a href="#464676" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#464657" title="List[Types.this.Symbol]">tparams1</a>, <a href="#462273" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="List[Types.this.Type]" id="464704">tp</a> =&gt;
        <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464704" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#464704" title="Types.this.Type">tp</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#464655" title="(tp: Types.this.Type)List[Types.this.Type]">getBounds</a><span class="delimiter">(</span><a href="#464704" title="Types.this.Type">tp</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <span title="Types.this.NoCommonType" class="keyword">new</span> <a href="#67670" title="Types.this.NoCommonType">NoCommonType</a><span class="delimiter">(</span><a href="#462272" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#462272" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <a href="#464655" title="(tp: Types.this.Type)List[Types.this.Type]">getBounds</a>
  <span class="delimiter">}</span>

  <span class="comment">/** All types in list must be polytypes with type parameter lists of
   *  same length as tparams.
   *  Returns list of instance types, where corresponding type
   *  parameters are renamed to tparams.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]" id="67665">matchingInstTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="462406">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="462407">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="464750">transformResultType</a><span class="delimiter">(</span><a title="Types.this.Type" id="464751">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#464751" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="464752">tparams1</a>, <a title="Types.this.Type" id="464753">restpe</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#464752" title="List[Types.this.Symbol]">tparams1</a>, <a href="#462407" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> =&gt;
        <a href="#464753" title="Types.this.Type">restpe</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#464752" title="List[Types.this.Symbol]">tparams1</a>, <a href="#462407" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="464756">tp</a> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#464756" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#464756" title="Types.this.Type">tp</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#464750" title="(tp: Types.this.Type)Types.this.Type">transformResultType</a><span class="delimiter">(</span><a href="#464756" title="Types.this.Type">tp</a>.<a href="#105483" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <span title="Types.this.NoCommonType" class="keyword">new</span> <a href="#67670" title="Types.this.NoCommonType">NoCommonType</a><span class="delimiter">(</span><a href="#462406" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#462406" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#464750" title="(tp: Types.this.Type)Types.this.Type">transformResultType</a>
  <span class="delimiter">}</span>

  <span class="comment">/** All types in list must be method types with equal parameter types.
   *  Returns list of their result types.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]" id="67666">matchingRestypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="462416">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="462417">pts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> =
    <a href="#462416" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#464817" title="Types.this.Type" class="delimiter">{</a>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="464818">params1</a>, <a title="Types.this.Type" id="464819">res</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#67583" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span><a href="#464818" title="List[Types.this.Symbol]">params1</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#464836" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>, <a href="#462417" title="List[Types.this.Type]">pts</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <a href="#464819" title="Types.this.Type">res</a>
      <span class="keyword">case</span> <span title="Types.this.Type">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="464864">res</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#462417" title="List[Types.this.Type]">pts</a> <span title="=&gt; Boolean">isEmpty</span> =&gt;
        <a href="#464864" title="Types.this.Type">res</a>
      <span class="keyword">case</span> <span title="Nothing">_</span> =&gt;
        <span title="Nothing" class="keyword">throw</span> <span title="Types.this.NoCommonType" class="keyword">new</span> <a href="#67670" title="Types.this.NoCommonType">NoCommonType</a><span class="delimiter">(</span><a href="#462416" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>


  <span class="comment">// TODO: this desperately needs to be cleaned up</span>
  <span class="comment">// plan: split into kind inference and subkinding</span>
  <span class="comment">// every Type has a (cached) Kind</span>
  <span class="keyword">def</span> <a title="(tparams: List[Types.this.Symbol], targs: List[Types.this.Type], pre: Types.this.Type, owner: Types.this.Symbol)Boolean" id="67667">kindsConform</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460899">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="460900">targs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Type" id="460901">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="460902">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#67668" title="(tparams: List[Types.this.Symbol], targs: List[Types.this.Type], pre: Types.this.Type, owner: Types.this.Symbol, explainErrors: Boolean)List[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]">checkKindBounds0</a><span class="delimiter">(</span><a href="#460899" title="List[Types.this.Symbol]">tparams</a>, <a href="#460900" title="List[Types.this.Type]">targs</a>, <a href="#460901" title="Types.this.Type">pre</a>, <a href="#460902" title="Types.this.Symbol">owner</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>.<span title="=&gt; Boolean">isEmpty</span>

  <span class="comment">/** Check well-kindedness of type application (assumes arities are already checked) -- @M
   * 
   * This check is also performed when abstract type members become concrete (aka a &quot;type alias&quot;) -- then tparams.length==1
   * (checked one type member at a time -- in that case, prefix is the name of the type alias)
   *
   * Type application is just like value application: it's &quot;contravariant&quot; in the sense that 
   * the type parameters of the supplied type arguments must conform to the type parameters of 
   * the required type parameters:
   *   - their bounds must be less strict
   *   - variances must match (here, variances are absolute, the variance of a type parameter does not influence the variance of its higher-order parameters)     
   *   - @M TODO: are these conditions correct,sufficient&amp;necessary?
   *
   *  e.g. class Iterable[t, m[+x &lt;: t]] --&gt; the application Iterable[Int, List] is okay, since 
   *       List's type parameter is also covariant and its bounds are weaker than &lt;: Int
   */</span>
  <span class="keyword">def</span> <a title="(tparams: List[Types.this.Symbol], targs: List[Types.this.Type], pre: Types.this.Type, owner: Types.this.Symbol, explainErrors: Boolean)List[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]" id="67668">checkKindBounds0</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="464892">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="464893">targs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Type" id="464894">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="464895">owner</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Boolean" id="464896">explainErrors</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="List[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]">List</span><span class="delimiter">[</span><span class="delimiter">(</span>Type, Symbol, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="Boolean" id="464903">error</a> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="464904">transform</a><span class="delimiter">(</span><a title="Types.this.Type" id="464909">tp</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="464910">clazz</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> = <a href="#464909" title="Types.this.Type">tp</a>.<a href="#105500" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#464894" title="Types.this.Type">pre</a>, <a href="#464910" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <span class="comment">// instantiate type params that come from outside the abstract type we're currently checking</span>
    <span class="keyword">def</span> <a title="(p: Types.this.Symbol, o: Types.this.Symbol)Types.this.Type" id="464905">transformedBounds</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="464911">p</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="464912">o</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#464904" title="(tp: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#464911" title="Types.this.Symbol">p</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105480" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#464892" title="List[Types.this.Symbol]">tparams</a>, <a href="#464893" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>, <a href="#464912" title="Types.this.Symbol">o</a><span class="delimiter">)</span>

    <span class="comment">/** Check whether &lt;arg&gt;sym1&lt;/arg&gt;'s variance conforms to &lt;arg&gt;sym2&lt;/arg&gt;'s variance
     *
     * If &lt;arg&gt;sym2&lt;/arg&gt; is invariant, &lt;arg&gt;sym1&lt;/arg&gt;'s variance is irrelevant. Otherwise they must be equal.
     */</span>
    <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean" id="464906">variancesMatch</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="464913">sym1</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="464914">sym2</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#464914" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107540" title="=&gt; Int">variance</a><span title="(x: Int)Boolean">==</span><span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#464913" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107540" title="=&gt; Int">variance</a><span title="(x: Int)Boolean">==</span><a href="#464914" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107540" title="=&gt; Int">variance</a><span class="delimiter">)</span>

    <span class="comment">// check that the type parameters &lt;arg&gt;hkargs&lt;/arg&gt; to a higher-kinded type conform to the expected params &lt;arg&gt;hkparams&lt;/arg&gt;</span>
    <span class="keyword">def</span> <a title="(hkargs: List[Types.this.Symbol], arg: Types.this.Symbol, param: Types.this.Symbol, paramowner: Types.this.Symbol, underHKParams: List[Types.this.Symbol], withHKArgs: List[Types.this.Symbol])(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" id="464907">checkKindBoundsHK</a><span class="delimiter">(</span>
      <a title="List[Types.this.Symbol]" id="464925">hkargs</a>:        <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
      <a title="Types.this.Symbol" id="464926">arg</a>:           <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>,
      <a title="Types.this.Symbol" id="464927">param</a>:         <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>,
      <a title="Types.this.Symbol" id="464928">paramowner</a>:    <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>,
      <a title="List[Types.this.Symbol]" id="464929">underHKParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
      <a title="List[Types.this.Symbol]" id="464930">withHKArgs</a>:    <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
    <span class="delimiter">)</span>: <span title="(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" class="delimiter">(</span>List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      
      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="464931">bindHKParams</a><span class="delimiter">(</span><a title="Types.this.Type" id="464933">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#464933" title="Types.this.Type">tp</a>.<a href="#105505" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#464929" title="List[Types.this.Symbol]">underHKParams</a>, <a href="#464930" title="List[Types.this.Symbol]">withHKArgs</a><span class="delimiter">)</span>
      <span class="comment">// @M sometimes hkargs != arg.typeParams, the symbol and the type may have very different type parameters</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="464932">hkparams</a> = <a href="#464927" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>

      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="SymbolTable.scala.html#64789" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;checkKindBoundsHK expected: &quot;)" class="string">&quot;checkKindBoundsHK expected: &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#464927" title="Types.this.Symbol">param</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; with params &quot;)" class="string">&quot; with params &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#464932" title="List[Types.this.Symbol]">hkparams</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; by definition in &quot;)" class="string">&quot; by definition in &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#464928" title="Types.this.Symbol">paramowner</a><span class="delimiter">)</span>
        <a href="SymbolTable.scala.html#64789" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;checkKindBoundsHK supplied: &quot;)" class="string">&quot;checkKindBoundsHK supplied: &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#464926" title="Types.this.Symbol">arg</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; with params &quot;)" class="string">&quot; with params &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#464925" title="List[Types.this.Symbol]">hkargs</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; from &quot;)" class="string">&quot; from &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#464895" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
        <a href="SymbolTable.scala.html#64789" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;checkKindBoundsHK under params: &quot;)" class="string">&quot;checkKindBoundsHK under params: &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#464929" title="List[Types.this.Symbol]">underHKParams</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; with args &quot;)" class="string">&quot; with args &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#464930" title="List[Types.this.Symbol]">withHKArgs</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span title="(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#67584" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#464925" title="List[Types.this.Symbol]">hkargs</a>, <a href="#464932" title="List[Types.this.Symbol]">hkparams</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" class="keyword">if</span> <span class="delimiter">(</span><a href="#464926" title="Types.this.Symbol">arg</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="#464926" title="Types.this.Symbol">arg</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106228" title="=&gt; Types.this.Symbol">NothingClass</a><span class="delimiter">)</span> <span title="(_1: scala.collection.immutable.Nil.type, _2: scala.collection.immutable.Nil.type, _3: scala.collection.immutable.Nil.type)(scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type)" class="delimiter">(</span><span title="object Nil">Nil</span>, <span title="object Nil">Nil</span>, <span title="object Nil">Nil</span><span class="delimiter">)</span> <span class="comment">// Any and Nothing are kind-overloaded</span>
        <span class="keyword">else</span> <span class="delimiter">{</span><a href="#464903" title="Boolean">error</a> = <span title="Boolean(true)" class="keyword">true</span>; <span title="(_1: List[(Types.this.Symbol, Types.this.Symbol)], _2: scala.collection.immutable.Nil.type, _3: scala.collection.immutable.Nil.type)(List[(Types.this.Symbol, Types.this.Symbol)], scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type)" class="delimiter">(</span><span title="(xs: (Types.this.Symbol, Types.this.Symbol)*)List[(Types.this.Symbol, Types.this.Symbol)]">List</span><span class="delimiter">(</span><span title="(_1: Types.this.Symbol, _2: Types.this.Symbol)(Types.this.Symbol, Types.this.Symbol)" class="delimiter">(</span><a href="#464926" title="Types.this.Symbol">arg</a>, <a href="#464927" title="Types.this.Symbol">param</a><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="object Nil">Nil</span>, <span title="object Nil">Nil</span><span class="delimiter">)</span> <span class="delimiter">}</span> <span class="comment">// shortcut: always set error, whether explainTypesOrNot</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" id="464991">_arityMismatches</a>    = <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464896" title="Boolean">explainErrors</a><span class="delimiter">)</span> <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">ListBuffer</span><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span> <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>
        <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" id="464992">_varianceMismatches</a> = <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464896" title="Boolean">explainErrors</a><span class="delimiter">)</span> <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">ListBuffer</span><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span> <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>
        <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" id="464993">_stricterBounds</a>     = <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464896" title="Boolean">explainErrors</a><span class="delimiter">)</span> <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">ListBuffer</span><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span> <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>
        
        <span class="keyword">def</span> <a title="(a: Types.this.Symbol, p: Types.this.Symbol)Unit" id="464994">varianceMismatch</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="465003">a</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="465004">p</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#464896" title="Boolean">explainErrors</a><span class="delimiter">)</span> <a href="#464992" title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">_varianceMismatches</a> <span title="(x: (Types.this.Symbol, Types.this.Symbol))_varianceMismatches.type">+=</span> <span class="delimiter">(</span><span title="(_1: Types.this.Symbol, _2: Types.this.Symbol)(Types.this.Symbol, Types.this.Symbol)" class="delimiter">(</span><a href="#465003" title="Types.this.Symbol">a</a>, <a href="#465004" title="Types.this.Symbol">p</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#464903" title="Boolean">error</a> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(a: Types.this.Symbol, p: Types.this.Symbol)Unit" id="464995">stricterBound</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="465020">a</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="465021">p</a>: <a href="Symbols.scala.html#67331" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#464896" title="Boolean">explainErrors</a><span class="delimiter">)</span> <a href="#464993" title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">_stricterBounds</a> <span title="(x: (Types.this.Symbol, Types.this.Symbol))_stricterBounds.type">+=</span> <span class="delimiter">(</span><span title="(_1: Types.this.Symbol, _2: Types.this.Symbol)(Types.this.Symbol, Types.this.Symbol)" class="delimiter">(</span><a href="#465020" title="Types.this.Symbol">a</a>, <a href="#465021" title="Types.this.Symbol">p</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#464903" title="Boolean">error</a> = <span title="Boolean(true)" class="keyword">true</span> <span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(as: Iterable[(Types.this.Symbol, Types.this.Symbol)])Unit" id="464996">arityMismatches</a><span class="delimiter">(</span><a title="Iterable[(Types.this.Symbol, Types.this.Symbol)]" id="465037">as</a>: <span title="Iterable[(Types.this.Symbol, Types.this.Symbol)]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#464896" title="Boolean">explainErrors</a><span class="delimiter">)</span> <a href="#464991" title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">_arityMismatches</a> <span title="(xs: scala.collection.TraversableOnce[(Types.this.Symbol, Types.this.Symbol)])_arityMismatches.type">++=</span> <a href="#465037" title="Iterable[(Types.this.Symbol, Types.this.Symbol)]">as</a> <span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(as: Iterable[(Types.this.Symbol, Types.this.Symbol)])Unit" id="464997">varianceMismatches</a><span class="delimiter">(</span><a title="Iterable[(Types.this.Symbol, Types.this.Symbol)]" id="465045">as</a>: <span title="Iterable[(Types.this.Symbol, Types.this.Symbol)]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#464896" title="Boolean">explainErrors</a><span class="delimiter">)</span> <a href="#464992" title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">_varianceMismatches</a> <span title="(xs: scala.collection.TraversableOnce[(Types.this.Symbol, Types.this.Symbol)])_varianceMismatches.type">++=</span> <a href="#465045" title="Iterable[(Types.this.Symbol, Types.this.Symbol)]">as</a> <span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(as: Iterable[(Types.this.Symbol, Types.this.Symbol)])Unit" id="464998">stricterBounds</a><span class="delimiter">(</span><a title="Iterable[(Types.this.Symbol, Types.this.Symbol)]" id="465053">as</a>: <span title="Iterable[(Types.this.Symbol, Types.this.Symbol)]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#464896" title="Boolean">explainErrors</a><span class="delimiter">)</span> <a href="#464993" title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">_stricterBounds</a> <span title="(xs: scala.collection.TraversableOnce[(Types.this.Symbol, Types.this.Symbol)])_stricterBounds.type">++=</span> <a href="#465053" title="Iterable[(Types.this.Symbol, Types.this.Symbol)]">as</a> <span class="delimiter">}</span>

        <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="465147">hkarg</a>, <a title="Types.this.Symbol" id="465148">hkparam</a><span class="delimiter">)</span> &lt;- <a href="#464925" title="List[Types.this.Symbol]">hkargs</a> <a href="#465118" title="(f: (Types.this.Symbol, Types.this.Symbol) =&gt; Unit)Unit">zip</a> <a href="#464932" title="List[Types.this.Symbol]">hkparams</a><span class="delimiter">)</span> <span class="delimiter">{</span> 
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#465148" title="Types.this.Symbol">hkparam</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#465147" title="Types.this.Symbol">hkarg</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// base-case: kind *</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#464906" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">variancesMatch</a><span class="delimiter">(</span><a href="#465147" title="Types.this.Symbol">hkarg</a>, <a href="#465148" title="Types.this.Symbol">hkparam</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#464994" title="(a: Types.this.Symbol, p: Types.this.Symbol)Unit">varianceMismatch</a><span class="delimiter">(</span><a href="#465147" title="Types.this.Symbol">hkarg</a>, <a href="#465148" title="Types.this.Symbol">hkparam</a><span class="delimiter">)</span>                                         

            <span class="comment">// instantiateTypeParams(tparams, targs) --&gt; higher-order bounds may contain references to type arguments</span>
            <span class="comment">// substSym(hkparams, hkargs) --&gt; these types are going to be compared as types of kind * </span>
            <span class="comment">//    --&gt; their arguments use different symbols, but are conceptually the same </span>
            <span class="comment">//        (could also replace the types by polytypes, but can't just strip the symbols, as ordering is lost then)</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="465151">declaredBounds</a>     = <a href="#464905" title="(p: Types.this.Symbol, o: Types.this.Symbol)Types.this.Type">transformedBounds</a><span class="delimiter">(</span><a href="#465148" title="Types.this.Symbol">hkparam</a>, <a href="#464928" title="Types.this.Symbol">paramowner</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="465152">declaredBoundsInst</a> = <a href="#464931" title="(tp: Types.this.Type)Types.this.Type">bindHKParams</a><span class="delimiter">(</span><a href="#465151" title="Types.this.Type">declaredBounds</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="465153">argumentBounds</a>     = <a href="#464904" title="(tp: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#465147" title="Types.this.Symbol">hkarg</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a>.<a href="#105462" title="=&gt; Types.this.TypeBounds">bounds</a>, <a href="#464895" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>            
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#465152" title="Types.this.Type">declaredBoundsInst</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#465153" title="Types.this.Type">argumentBounds</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#464995" title="(a: Types.this.Symbol, p: Types.this.Symbol)Unit">stricterBound</a><span class="delimiter">(</span><a href="#465147" title="Types.this.Symbol">hkarg</a>, <a href="#465148" title="Types.this.Symbol">hkparam</a><span class="delimiter">)</span>

            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="SymbolTable.scala.html#64789" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span>
              <span title="java.lang.String(&quot;checkKindBoundsHK base case: &quot;)" class="string">&quot;checkKindBoundsHK base case: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#465148" title="Types.this.Symbol">hkparam</a> <span title="(x$1: Any)java.lang.String">+</span>
              <span title="java.lang.String(&quot; declared bounds: &quot;)" class="string">&quot; declared bounds: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#465151" title="Types.this.Type">declaredBounds</a> <span title="(x$1: Any)java.lang.String">+</span>
              <span title="java.lang.String(&quot; after instantiating earlier hkparams: &quot;)" class="string">&quot; after instantiating earlier hkparams: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#465152" title="Types.this.Type">declaredBoundsInst</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;\012&quot;)" class="string">&quot;\n&quot;</span> <span title="(x$1: Any)java.lang.String">+</span>
              <span title="java.lang.String(&quot;checkKindBoundsHK base case: &quot;)" class="string">&quot;checkKindBoundsHK base case: &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#465147" title="Types.this.Symbol">hkarg</a> <span title="(x$1: Any)java.lang.String">+</span> 
              <span title="java.lang.String(&quot; has bounds: &quot;)" class="string">&quot; has bounds: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#465153" title="Types.this.Type">argumentBounds</a>
            <span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36747" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span>
              <a href="SymbolTable.scala.html#64789" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;checkKindBoundsHK recursing to compare params of &quot;)" class="string">&quot;checkKindBoundsHK recursing to compare params of &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#465148" title="Types.this.Symbol">hkparam</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; with &quot;)" class="string">&quot; with &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#465147" title="Types.this.Symbol">hkarg</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a href="#465158" title="(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" class="delimiter">(</a><a href="#465157" title="List[(Types.this.Symbol, Types.this.Symbol)]" id="465158">am</a>, <a href="#465157" title="List[(Types.this.Symbol, Types.this.Symbol)]" id="465159">vm</a>, <a href="#465157" title="List[(Types.this.Symbol, Types.this.Symbol)]" id="465160">sb</a><span class="delimiter">)</span> = <a href="#464907" title="(hkargs: List[Types.this.Symbol], arg: Types.this.Symbol, param: Types.this.Symbol, paramowner: Types.this.Symbol, underHKParams: List[Types.this.Symbol], withHKArgs: List[Types.this.Symbol])(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])">checkKindBoundsHK</a><span title="(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)]) @unchecked" class="delimiter">(</span>
              <a href="#465147" title="Types.this.Symbol">hkarg</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>,
              <a href="#465147" title="Types.this.Symbol">hkarg</a>,
              <a href="#465148" title="Types.this.Symbol">hkparam</a>,
              <a href="#464928" title="Types.this.Symbol">paramowner</a>, 
              <a href="#464929" title="List[Types.this.Symbol]">underHKParams</a> <span title="(that: scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">++</span> <a href="#465148" title="Types.this.Symbol">hkparam</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>,
              <a href="#464930" title="List[Types.this.Symbol]">withHKArgs</a> <span title="(that: scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">++</span> <a href="#465147" title="Types.this.Symbol">hkarg</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>
            <span class="delimiter">)</span>
            <a href="#464996" title="(as: Iterable[(Types.this.Symbol, Types.this.Symbol)])Unit">arityMismatches</a><span class="delimiter">(</span><a href="#465158" title="List[(Types.this.Symbol, Types.this.Symbol)]">am</a><span class="delimiter">)</span>
            <a href="#464997" title="(as: Iterable[(Types.this.Symbol, Types.this.Symbol)])Unit">varianceMismatches</a><span class="delimiter">(</span><a href="#465159" title="List[(Types.this.Symbol, Types.this.Symbol)]">vm</a><span class="delimiter">)</span>
            <a href="#464998" title="(as: Iterable[(Types.this.Symbol, Types.this.Symbol)])Unit">stricterBounds</a><span class="delimiter">(</span><a href="#465160" title="List[(Types.this.Symbol, Types.this.Symbol)]">sb</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#464896" title="Boolean">explainErrors</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#464903" title="Boolean">error</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="(_1: scala.collection.immutable.Nil.type, _2: scala.collection.immutable.Nil.type, _3: scala.collection.immutable.Nil.type)(scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type)" class="delimiter">(</span><span title="object Nil">Nil</span>, <span title="object Nil">Nil</span>, <span title="object Nil">Nil</span><span class="delimiter">)</span> <span class="comment">// stop as soon as we encountered an error</span>
        <span class="delimiter">}</span>
        <span title="(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#464896" title="Boolean">explainErrors</a><span class="delimiter">)</span> <span title="(_1: scala.collection.immutable.Nil.type, _2: scala.collection.immutable.Nil.type, _3: scala.collection.immutable.Nil.type)(scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type)" class="delimiter">(</span><span title="object Nil">Nil</span>, <span title="object Nil">Nil</span>, <span title="object Nil">Nil</span><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="(_1: List[(Types.this.Symbol, Types.this.Symbol)], _2: List[(Types.this.Symbol, Types.this.Symbol)], _3: List[(Types.this.Symbol, Types.this.Symbol)])(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" class="delimiter">(</span><a href="#464991" title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">_arityMismatches</a>.<span title="=&gt; List[(Types.this.Symbol, Types.this.Symbol)]">toList</span>, <a href="#464992" title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">_varianceMismatches</a>.<span title="=&gt; List[(Types.this.Symbol, Types.this.Symbol)]">toList</span>, <a href="#464993" title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">_stricterBounds</a>.<span title="=&gt; List[(Types.this.Symbol, Types.this.Symbol)]">toList</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>    
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]" id="464908">errors</a> = <span title="scala.collection.mutable.ListBuffer[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]">ListBuffer</span><span class="delimiter">[</span><span class="delimiter">(</span>Type, Symbol, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#464892" title="List[Types.this.Symbol]">tparams</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#464893" title="List[Types.this.Type]">targs</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span>
      <a href="SymbolTable.scala.html#64789" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;checkKindBounds0(&quot;)" class="string">&quot;checkKindBounds0(&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#464892" title="List[Types.this.Symbol]">tparams</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#464893" title="List[Types.this.Type]">targs</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#464894" title="Types.this.Type">pre</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#464895" title="Types.this.Symbol">owner</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#464896" title="Boolean">explainErrors</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>

    <span class="keyword">for</span> <span class="delimiter">{</span>
      <span class="delimiter">(</span><a title="Types.this.Symbol" id="465395">tparam</a>, <a title="Types.this.Type" id="465396">targ</a><span class="delimiter">)</span> &lt;- <a href="#464892" title="List[Types.this.Symbol]">tparams</a> <a href="#465368" title="(f: (Types.this.Symbol, Types.this.Type) =&gt; Any)Unit">zip</a> <a href="#464893" title="List[Types.this.Type]">targs</a>
      <span class="comment">// Prevent WildcardType from causing kind errors, as typevars may be higher-order</span>
      <span class="keyword">if</span> <span class="delimiter">(</span><a href="#465396" title="Types.this.Type">targ</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#450864" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#465396" title="Types.this.Type">targ</a>.<a href="#105445" title="=&gt; Boolean">isHigherKinded</a> <span title="(x: Boolean)Boolean">||</span> <a href="#465395" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="delimiter">{</span>
      <span class="comment">// @M must use the typeParams of the *type* targ, not of the *symbol* of targ!!</span>
      <a href="#465396" title="Types.this.Type">targ</a>.<a href="#105456" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>.<a href="Symbols.scala.html#107564" title="=&gt; Types.this.Type">info</a> <span class="comment">// force symbol load for #4205</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="465397">tparamsHO</a> = <a href="#465396" title="Types.this.Type">targ</a>.<a href="#105477" title="=&gt; List[Types.this.Symbol]">typeParams</a>

      <span class="keyword">val</span> <a href="#465399" title="(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" class="delimiter">(</a><a href="#465398" title="List[(Types.this.Symbol, Types.this.Symbol)]" id="465399">arityMismatches</a>, <a href="#465398" title="List[(Types.this.Symbol, Types.this.Symbol)]" id="465400">varianceMismatches</a>, <a href="#465398" title="List[(Types.this.Symbol, Types.this.Symbol)]" id="465401">stricterBounds</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
        <span class="comment">// NOTE: *not* targ.typeSymbol, which normalizes</span>
        <a href="#464907" title="(hkargs: List[Types.this.Symbol], arg: Types.this.Symbol, param: Types.this.Symbol, paramowner: Types.this.Symbol, underHKParams: List[Types.this.Symbol], withHKArgs: List[Types.this.Symbol])(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])">checkKindBoundsHK</a><span title="(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)]) @unchecked" class="delimiter">(</span><a href="#465397" title="List[Types.this.Symbol]">tparamsHO</a>, <a href="#465396" title="Types.this.Type">targ</a>.<a href="#105456" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>, <a href="#465395" title="Types.this.Symbol">tparam</a>, <a href="#465395" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107541" title="=&gt; Types.this.Symbol">owner</a>, <a href="#465395" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107579" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#465397" title="List[Types.this.Symbol]">tparamsHO</a><span class="delimiter">)</span>
      <span class="delimiter">)</span>
      <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#464896" title="Boolean">explainErrors</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#465399" title="List[(Types.this.Symbol, Types.this.Symbol)]">arityMismatches</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#465400" title="List[(Types.this.Symbol, Types.this.Symbol)]">varianceMismatches</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#465401" title="List[(Types.this.Symbol, Types.this.Symbol)]">stricterBounds</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#464908" title="scala.collection.mutable.ListBuffer[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]">errors</a> <span title="(x: (Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)]))errors.type">+=</span> <span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.Symbol, _3: List[(Types.this.Symbol, Types.this.Symbol)], _4: List[(Types.this.Symbol, Types.this.Symbol)], _5: List[(Types.this.Symbol, Types.this.Symbol)])(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" class="delimiter">(</span><a href="#465396" title="Types.this.Type">targ</a>, <a href="#465395" title="Types.this.Symbol">tparam</a>, <a href="#465399" title="List[(Types.this.Symbol, Types.this.Symbol)]">arityMismatches</a>, <a href="#465400" title="List[(Types.this.Symbol, Types.this.Symbol)]">varianceMismatches</a>, <a href="#465401" title="List[(Types.this.Symbol, Types.this.Symbol)]">stricterBounds</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#464903" title="Boolean">error</a><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">return</span> <span title="(xs: (Types.this.NoType.type, Types.this.NoSymbol.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type)*)List[(Types.this.NoType.type, Types.this.NoSymbol.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type)]">List</span><span class="delimiter">(</span><span title="(_1: Types.this.NoType.type, _2: Types.this.NoSymbol.type, _3: scala.collection.immutable.Nil.type, _4: scala.collection.immutable.Nil.type, _5: scala.collection.immutable.Nil.type)(Types.this.NoType.type, Types.this.NoSymbol.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type)" class="delimiter">(</span><a href="#450913" title="object Types.this.NoType">NoType</a>, <a href="Symbols.scala.html#67339" title="object Types.this.NoSymbol">NoSymbol</a>, <span title="object Nil">Nil</span>, <span title="object Nil">Nil</span>, <span title="object Nil">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  
    <a href="#464908" title="scala.collection.mutable.ListBuffer[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]">errors</a>.<span title="=&gt; List[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]">toList</span>
  <span class="delimiter">}</span>

<span class="comment">// Errors and Diagnostics -----------------------------------------------------</span>

  <span class="comment">/** A throwable signalling a type error */</span>
  <span class="keyword">class</span> <a title="class TypeError extends java.lang.Throwable with ScalaObject" id="67669">TypeError</a><a href="#67669" title="ScalaObject" class="delimiter">(</a><span class="keyword">var</span> <a title="Types.this.Position" id="411517">pos</a>: <a href="../util/Position.scala.html#30588" title="Types.this.Position">Position</a>, <span class="keyword">val</span> <a title="String" id="411518">msg</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="java.lang.Throwable">Throwable</span><span class="delimiter">(</span><a href="#411518" title="String">msg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(msg: String)Types.this.TypeError" id="313958" class="keyword">this</a><span class="delimiter">(</span><a title="String" id="411516">msg</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#67669" title="TypeError.this.type" class="keyword">this</a><span class="delimiter">(</span><a href="Positions.scala.html#67902" title="=&gt; tools.nsc.util.NoPosition.type">NoPosition</a>, <a href="#411516" title="String">msg</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class NoCommonType extends java.lang.Throwable with scala.util.control.ControlThrowable with ScalaObject" id="67670">NoCommonType</a><a href="#67670" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Type]" id="464705">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="java.lang.Throwable">Throwable</span><span class="delimiter">(</span>
    <span title="java.lang.String(&quot;lub/glb of incompatible types: &quot;)" class="string">&quot;lub/glb of incompatible types: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#464705" title="List[Types.this.Type]">tps</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="java.lang.String(&quot; and &quot;)" class="string">&quot; and &quot;</span>, <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">with</span> <span title="scala.util.control.ControlThrowable">ControlThrowable</span>

  <span class="comment">/** A throwable signalling a malformed type */</span>
  <span class="keyword">class</span> <a title="class MalformedType extends Types.this.TypeError with ScalaObject" id="67671">MalformedType</a><a href="#313958" title="ScalaObject" class="delimiter">(</a><a title="String" id="459801">msg</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67669" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><a href="#459801" title="String">msg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, tp: String)Types.this.MalformedType" id="458741" class="keyword">this</a><span class="delimiter">(</span><a title="Types.this.Type" id="459799">pre</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="String" id="459800">tp</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#67671" title="MalformedType.this.type" class="keyword">this</a><span class="delimiter">(</span><span title="java.lang.String(&quot;malformed type: &quot;)" class="string">&quot;malformed type: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#459799" title="Types.this.Type">pre</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;#&quot;)" class="string">&quot;#&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#459800" title="String">tp</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An exception signalling a variance annotation/usage conflict */</span>
  <span class="keyword">class</span> <a title="class VarianceError extends Types.this.TypeError with ScalaObject" id="67672">VarianceError</a><a href="#313958" title="ScalaObject" class="delimiter">(</a><a title="String" id="465533">msg</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67669" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><a href="#465533" title="String">msg</a><span class="delimiter">)</span>

  <span class="comment">/** The current indentation string for traces */</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="String" id="67674">indent</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>

  <span class="comment">/** Perform operation `p' on arguments `tp1',
   *  `arg2' and print trace of computation.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T](op: String, p: (Types.this.Type, T) =&gt; Boolean, tp1: Types.this.Type, arg2: T)Boolean" id="67676">explain</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67678">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="450047">op</a>: <span title="String">String</span>, <a title="(Types.this.Type, T) =&gt; Boolean" id="450048">p</a>: <span class="delimiter">(</span>Type, T<span class="delimiter">)</span> =&gt; Boolean, <a title="Types.this.Type" id="450049">tp1</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="T" id="450050">arg2</a>: <a href="#67678" title="T">T</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span title="object Console">Console</span>.<span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#67674" title="=&gt; String">indent</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="#450049" title="Types.this.Type">tp1</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#450047" title="String">op</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#450050" title="T">arg2</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;?&quot;)" class="string">&quot;?&quot;</span> <span class="comment">/* + &quot;(&quot;+tp1.getClass+&quot;,&quot;+arg2.asInstanceOf[AnyRef].getClass+&quot;)&quot;*/</span><span class="delimiter">)</span>
    <a href="#67674" title="(x$1: String)Unit">indent</a> = <a href="#67674" title="=&gt; String">indent</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
    <span class="keyword">val</span> <a title="Boolean" id="465537">result</a> = <a href="#450048" title="(v1: Types.this.Type, v2: T)Boolean">p</a><span class="delimiter">(</span><a href="#450049" title="Types.this.Type">tp1</a>, <a href="#450050" title="T">arg2</a><span class="delimiter">)</span>
    <a href="#67674" title="(x$1: String)Unit">indent</a> = <a href="#67674" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">indent</a> <span title="(n: Int)String">dropRight</span> <span title="Int(2)" class="int">2</span>
    <span title="object Console">Console</span>.<span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#67674" title="=&gt; String">indent</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="#465537" title="Boolean">result</a><span class="delimiter">)</span>
    <a href="#465537" title="Boolean">result</a>
  <span class="delimiter">}</span>

  <span class="comment">/** If option `explaintypes' is set, print a subtype trace for
   *  `found &lt;:&lt; required'.
   */</span>
  <span class="keyword">def</span> <a title="(found: Types.this.Type, required: Types.this.Type)Unit" id="67679">explainTypes</a><span class="delimiter">(</span><a title="Types.this.Type" id="465553">found</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="465554">required</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/StandardScalaSettings.scala.html#36862" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">explaintypes</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#67681" title="(op: =&gt; Boolean)Boolean">withTypesExplained</a><span title="Unit" class="delimiter">(</span><a href="#465553" title="Types.this.Type">found</a> <a href="#105515" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#465554" title="Types.this.Type">required</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** If option `explaintypes' is set, print a subtype trace for
   *  `op(found, required)'.
   */</span>
  <span class="keyword">def</span> <a title="(op: (Types.this.Type, Types.this.Type) =&gt; Any, found: Types.this.Type, required: Types.this.Type)Unit" id="67680">explainTypes</a><span class="delimiter">(</span><a title="(Types.this.Type, Types.this.Type) =&gt; Any" id="465565">op</a>: <span class="delimiter">(</span>Type, Type<span class="delimiter">)</span> =&gt; Any, <a title="Types.this.Type" id="465566">found</a>: <a href="#67392" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="465567">required</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64787" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/StandardScalaSettings.scala.html#36862" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">explaintypes</a>.<a href="../settings/MutableSettings.scala.html#42149" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#67681" title="(op: =&gt; Any)Any">withTypesExplained</a><span title="Unit" class="delimiter">(</span><a href="#465565" title="(v1: Types.this.Type, v2: Types.this.Type)Any">op</a><span class="delimiter">(</span><a href="#465566" title="Types.this.Type">found</a>, <a href="#465567" title="Types.this.Type">required</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Execute `op' while printing a trace of the operations on types executed.
   */</span>
  <span class="keyword">def</span> <a title="[A](op: =&gt; A)A" id="67681">withTypesExplained</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67683">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="465559">op</a>: =&gt; A<span class="delimiter">)</span>: <a href="#67683" title="A">A</a> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Boolean" id="465577">s</a> = <a href="#67361" title="=&gt; Boolean">explainSwitch</a>
    <span class="keyword">try</span> <span class="delimiter">{</span> <a href="#67361" title="(x$1: Boolean)Unit">explainSwitch</a> = <span title="Boolean(true)" class="keyword">true</span>; <a href="#465559" title="=&gt; A">op</a> <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span> <a href="#67361" title="(x$1: Boolean)Unit">explainSwitch</a> = <a href="#465577" title="Boolean">s</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="67684">objToAny</a><span class="delimiter">(</span><a title="Types.this.Type" id="465578">tp</a>: <a href="#67392" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67392" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64806" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102982" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#465578" title="Types.this.Type">tp</a>.<a href="#105454" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106220" title="=&gt; Types.this.Symbol">ObjectClass</a><span class="delimiter">)</span> <a href="Definitions.scala.html#106216" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107562" title="=&gt; Types.this.Type">tpe</a>
    <span class="keyword">else</span> <a href="#465578" title="Types.this.Type">tp</a>

  <span class="keyword">val</span> <a title="scala.collection.immutable.Set[java.lang.String]" id="67685">shorthands</a> = <span title="(elems: java.lang.String*)scala.collection.immutable.Set[java.lang.String]">Set</span><span class="delimiter">(</span>
    <span title="java.lang.String(&quot;scala.collection.immutable.List&quot;)" class="string">&quot;scala.collection.immutable.List&quot;</span>, 
    <span title="java.lang.String(&quot;scala.collection.immutable.Nil&quot;)" class="string">&quot;scala.collection.immutable.Nil&quot;</span>,
    <span title="java.lang.String(&quot;scala.collection.Seq&quot;)" class="string">&quot;scala.collection.Seq&quot;</span>,
    <span title="java.lang.String(&quot;scala.collection.Traversable&quot;)" class="string">&quot;scala.collection.Traversable&quot;</span>,
    <span title="java.lang.String(&quot;scala.collection.Iterable&quot;)" class="string">&quot;scala.collection.Iterable&quot;</span>,
    <span title="java.lang.String(&quot;scala.collection.mutable.StringBuilder&quot;)" class="string">&quot;scala.collection.mutable.StringBuilder&quot;</span>,
    <span title="java.lang.String(&quot;scala.collection.IndexedSeq&quot;)" class="string">&quot;scala.collection.IndexedSeq&quot;</span>,
    <span title="java.lang.String(&quot;scala.collection.Iterator&quot;)" class="string">&quot;scala.collection.Iterator&quot;</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>