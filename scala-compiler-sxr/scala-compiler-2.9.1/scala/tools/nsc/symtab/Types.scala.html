<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/tools/nsc/symtab/Types.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* NSC -- new Scala compiler
 * Copyright 2005-2011 LAMP/EPFL
 * @author  Martin Odersky
 */</span>

<span class="keyword">package</span> scala.tools.nsc
<span class="keyword">package</span> symtab

<span class="keyword">import</span> scala.collection.<span class="delimiter">{</span> mutable, immutable <span class="delimiter">}</span>
<span class="keyword">import</span> scala.ref.WeakReference
<span class="keyword">import</span> mutable.ListBuffer
<span class="keyword">import</span> ast.TreeGen
<span class="keyword">import</span> util.<span class="delimiter">{</span> Position, NoPosition <span class="delimiter">}</span>
<span class="keyword">import</span> util.<a href="../util/Statistics.scala.html#30936" title="object scala.tools.nsc.util.Statistics">Statistics</a>._
<span class="keyword">import</span> <a href="Flags.scala.html#24079" title="object scala.tools.nsc.symtab.Flags">Flags</a>._
<span class="keyword">import</span> scala.util.control.ControlThrowable
<span class="keyword">import</span> scala.annotation.tailrec

<span class="comment">/* A standard type pattern match:
  case ErrorType =&gt;
    // internal: error
  case WildcardType =&gt;
    // internal: unknown
  case NoType =&gt;
  case NoPrefix =&gt;
  case ThisType(sym) =&gt;
    // sym.this.type
  case SuperType(thistpe, supertpe) =&gt;
    // super references
  case SingleType(pre, sym) =&gt;
    // pre.sym.type
  case ConstantType(value) =&gt;
    // Int(2)
  case TypeRef(pre, sym, args) =&gt; 
    // pre.sym[targs]
    // Outer.this.C would be represented as TypeRef(ThisType(Outer), C, List())
  case RefinedType(parents, defs) =&gt;
    // parent1 with ... with parentn { defs }
  case ExistentialType(tparams, result) =&gt;
    // result forSome { tparams }
  case AnnotatedType(annots, tp, selfsym) =&gt;
    // tp @annots

  // the following are non-value types; you cannot write them down in Scala source.

  case TypeBounds(lo, hi) =&gt;  
    // &gt;: lo &lt;: hi
  case ClassInfoType(parents, defs, clazz) =&gt;
    // same as RefinedType except as body of class
  case MethodType(paramtypes, result) =&gt;
    // (paramtypes)result 
    // For instance def m(): T is represented as MethodType(List(), T)
  case NullaryMethodType(result) =&gt; // eliminated by uncurry
    // an eval-by-name type
    // For instance def m: T is represented as NullaryMethodType(T)
  case PolyType(tparams, result) =&gt;
    // [tparams]result where result is a (Nullary)MethodType or ClassInfoType

  // The remaining types are not used after phase `typer'. 
  case OverloadedType(pre, tparams, alts) =&gt;
    // all alternatives of an overloaded ident
  case AntiPolyType(pre, targs) =&gt;
    // rarely used, disappears when combined with a PolyType
  case TypeVar(inst, constr) =&gt;
    // a type variable
    // Replace occurrences of type parameters with type vars, where
    // inst is the instantiation and constr is a list of bounds.
  case DeBruijnIndex(level, index)
    // for dependent method types: a type referring to a method parameter.
    // Not presently used, it seems.
*/</span>

<span class="keyword">trait</span> <a title="trait Types extends java.lang.Object with scala.reflect.generic.Types with ScalaObject" id="24048">Types</a> <span title="ScalaObject" class="keyword">extends</span> reflect.generic.<span title="scala.reflect.generic.Types">Types</span> <span class="delimiter">{</span> self: SymbolTable =&gt;
  <span class="keyword">import</span> <a href="Definitions.scala.html#67688" title="object Types.this.definitions">definitions</a>._
  
  <span class="comment">//statistics</span>
  <span class="keyword">def</span> <a title="=&gt; Int" id="67348">uniqueTypeCount</a> = <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#67490" title="=&gt; scala.tools.nsc.util.HashSet[Types.this.Type]">uniques</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> <span class="keyword">else</span> <a href="#67490" title="=&gt; scala.tools.nsc.util.HashSet[Types.this.Type]">uniques</a>.<a href="../util/HashSet.scala.html#120181" title="=&gt; Int">size</a>

  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Boolean" id="67350">explainSwitch</a> = <span title="Boolean(false)" class="keyword">false</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="67352">emptySymbolSet</a> = immutable.<span title="object scala.collection.immutable.Set">Set</span>.<span title="[A]=&gt; scala.collection.immutable.Set[A]">empty</span><span title="scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span>

  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean(false)" id="67354">alternativeNarrow</a> = <span title="Boolean(false)" class="keyword">false</span>

  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="67356">LogPendingSubTypesThreshold</a> = <span title="Int(50)" class="int">50</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="67358">LogPendingBaseTypesThreshold</a> = <span title="Int(50)" class="int">50</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="67360">LogVolatileThreshold</a> = <span title="Int(50)" class="int">50</span>

  <span class="comment">/** A don't care value for the depth parameter in lubs/glbs and related operations */</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(-3)" id="67362">AnyDepth</a> = -<span title="Int(-3)" class="int">3</span>

  <span class="comment">/** Decrement depth unless it is a don't care */</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="(depth: Int)Int" id="67364">decr</a><span class="delimiter">(</span><a title="Int" id="449257">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#449257" title="Int">depth</a> <span title="(x: Int)Boolean">==</span> <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span> <span title="Int(-3)">AnyDepth</span> <span class="keyword">else</span> <a href="#449257" title="Int">depth</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>

  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean(false)" id="67365">printLubs</a> = <span title="Boolean(false)" class="keyword">false</span>
  <span class="comment">/** In case anyone wants to turn off lub verification without reverting anything. */</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean(true)" id="67367">verifyLubs</a> = <span title="Boolean(true)" class="keyword">true</span>

  <span class="comment">/** The current skolemization level, needed for the algorithms
   *  in isSameType, isSubType that do constraint solving under a prefix 
   */</span>
  <span class="keyword">var</span> <a title="Int" id="67370">skolemizationLevel</a> = <span title="Int(0)" class="int">0</span>

  <span class="comment">/** A log of type variable with their original constraints. Used in order
   *  to undo constraints in the case of isSubType/isSameType failure.
   */</span>
  <span class="keyword">object</span> <a title="object Types.this.undoLog" id="67372">undoLog</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">type</span> <a title="List[(Types.this.TypeVar, Types.this.TypeConstraint)]" id="106735">UndoLog</a> = <span title="List[(Types.this.TypeVar, Types.this.TypeConstraint)]">List</span><span class="delimiter">[</span><span class="delimiter">(</span>TypeVar, TypeConstraint<span class="delimiter">)</span><span class="delimiter">]</span>
    <span class="keyword">private</span><span class="delimiter">[</span>nsc<span class="delimiter">]</span> <span class="keyword">var</span> <a title="scala.tools.nsc.symtab.Types.undoLog.UndoLog" id="106737">log</a>: <span title="scala.tools.nsc.symtab.Types.undoLog.UndoLog">UndoLog</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">/** Undo all changes to constraints to type variables upto `limit'
     */</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(limit: scala.tools.nsc.symtab.Types.undoLog.UndoLog)Unit" id="106739">undoTo</a><span class="delimiter">(</span><a title="scala.tools.nsc.symtab.Types.undoLog.UndoLog" id="449277">limit</a>: <span title="List[(Types.this.TypeVar, Types.this.TypeConstraint)]">UndoLog</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#106737" title="=&gt; scala.tools.nsc.symtab.Types.undoLog.UndoLog">log</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#449277" title="scala.tools.nsc.symtab.Types.undoLog.UndoLog">limit</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#106737" title="=&gt; scala.tools.nsc.symtab.Types.undoLog.UndoLog">log</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#449279" title="()Unit" class="delimiter">{</a>
        <span class="keyword">val</span> <a href="#449286" title="(Types.this.TypeVar, Types.this.TypeConstraint)" class="delimiter">(</a><a href="#449285" title="Types.this.TypeVar" id="449286">tv</a>, <a href="#449285" title="Types.this.TypeConstraint" id="449287">constr</a><span class="delimiter">)</span> = <a href="#106737" title="=&gt; scala.tools.nsc.symtab.Types.undoLog.UndoLog">log</a>.<span title="=&gt; (Types.this.TypeVar, Types.this.TypeConstraint)">head</span>
        <a href="#449286" title="Types.this.TypeVar">tv</a>.<a href="#448938" title="(x$1: Types.this.TypeConstraint)Unit">constr</a> = <a href="#449287" title="Types.this.TypeConstraint">constr</a>
        <a href="#106737" title="(x$1: scala.tools.nsc.symtab.Types.undoLog.UndoLog)Unit">log</a> = <a href="#106737" title="=&gt; scala.tools.nsc.symtab.Types.undoLog.UndoLog">log</a>.<span title="=&gt; List[(Types.this.TypeVar, Types.this.TypeConstraint)]">tail</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">private</span><span class="delimiter">[</span>Types<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(tv: Types.this.TypeVar)Unit" id="106740">record</a><span class="delimiter">(</span><a title="Types.this.TypeVar" id="449335">tv</a>: <a href="#67458" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#106737" title="(x$1: scala.tools.nsc.symtab.Types.undoLog.UndoLog)Unit">log</a> <span title="(x: (Types.this.TypeVar, Types.this.TypeConstraint))List[(Types.this.TypeVar, Types.this.TypeConstraint)]">::=</span> <span class="delimiter">(</span><a href="#449335" title="Types.this.TypeVar">tv</a>, <a href="#449335" title="Types.this.TypeVar">tv</a>.<a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449329" title="=&gt; Types.this.TypeConstraint">cloneInternal</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">private</span><span class="delimiter">[</span>nsc<span class="delimiter">]</span> <span class="keyword">def</span> <a title="()Unit" id="106741">clear</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span>
        <a href="#24048" title="Types.this.type">self</a>.<a href="SymbolTable.scala.html#64778" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;Clearing &quot;)" class="string">&quot;Clearing &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#106737" title="=&gt; scala.tools.nsc.symtab.Types.undoLog.UndoLog">log</a>.<span title="=&gt; Int">size</span> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; entries from the undoLog.&quot;)" class="string">&quot; entries from the undoLog.&quot;</span><span class="delimiter">)</span>

      <a href="#106737" title="(x$1: scala.tools.nsc.symtab.Types.undoLog.UndoLog)Unit">log</a> = <span title="object Nil">Nil</span>
    <span class="delimiter">}</span>

    <span class="comment">// `block` should not affect constraints on typevars</span>
    <span class="keyword">def</span> <a title="[T](block: =&gt; T)T" id="106742">undo</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="106744">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; T" id="106746">block</a>: =&gt; T<span class="delimiter">)</span>: <a href="#106744" title="T">T</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.tools.nsc.symtab.Types.undoLog.UndoLog" id="449369">before</a> = <a href="#106737" title="=&gt; scala.tools.nsc.symtab.Types.undoLog.UndoLog">log</a>

      <span class="keyword">try</span> <a href="#106746" title="=&gt; T">block</a>
      <span class="keyword">finally</span> <a href="#106739" title="(limit: scala.tools.nsc.symtab.Types.undoLog.UndoLog)Unit">undoTo</a><span class="delimiter">(</span><a href="#449369" title="scala.tools.nsc.symtab.Types.undoLog.UndoLog">before</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// if `block` evaluates to false, it should not affect constraints on typevars</span>
    <span class="keyword">def</span> <a title="(block: =&gt; Boolean)Boolean" id="106745">undoUnless</a><span class="delimiter">(</span><a title="=&gt; Boolean" id="449370">block</a>: =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.tools.nsc.symtab.Types.undoLog.UndoLog" id="449372">before</a> = <a href="#106737" title="=&gt; scala.tools.nsc.symtab.Types.undoLog.UndoLog">log</a>
      <span class="keyword">var</span> <a title="Boolean" id="449373">result</a> = <span title="Boolean(false)" class="keyword">false</span>
      
      <span class="keyword">try</span> <a href="#449373" title="Boolean">result</a> = <a href="#449370" title="=&gt; Boolean">block</a>
      <span class="keyword">finally</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#449373" title="Boolean">result</a><span class="delimiter">)</span> <a href="#106739" title="(limit: scala.tools.nsc.symtab.Types.undoLog.UndoLog)Unit">undoTo</a><span class="delimiter">(</span><a href="#449372" title="scala.tools.nsc.symtab.Types.undoLog.UndoLog">before</a><span class="delimiter">)</span>
      
      <a href="#449373" title="Boolean">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map from lists to compound types that have the given list as parents.
   *  This is used to avoid duplication in the computation of base type sequences and baseClasses.
   *  It makes use of the fact that these two operations depend only on the parents,
   *  not on the refinement.
   */</span>
  <span class="keyword">val</span> <a title="scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]" id="67374">intersectionWitness</a> = <span title="scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]">WeakHashMap</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span>, WeakReference<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="keyword">private</span> <span class="keyword">object</span> <a title="object Types.this.gen" id="67376">gen</a> <span title="ScalaObject" class="keyword">extends</span> <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Types.this.type" id="449380">global</a> : Types.<span class="keyword">this</span>.<span class="keyword">type</span> = <a href="#24048" title="Types.this.type">Types</a>.<span class="keyword">this</span>
  <span class="delimiter">}</span> <span class="keyword">with</span> <a href="../ast/TreeGen.scala.html#11896" title="scala.tools.nsc.ast.TreeGen">TreeGen</a>

  <span class="keyword">import</span> <a href="#67376" title="object Types.this.gen">gen</a>._

  <span class="comment">/** A proxy for a type (identified by field `underlying') that forwards most 
   *  operations to it (for exceptions, see WrappingProxy, which forwards even more operations).
   *  every operation that is overridden for some kind of types should be forwarded.
   */</span>
  <span class="keyword">trait</span> <a title="trait SimpleTypeProxy extends Types.this.Type with ScalaObject" id="67379">SimpleTypeProxy</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67381" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148224">underlying</a>: <a href="#67381" title="Types.this.Type">Type</a>

    <span class="comment">// the following operations + those in RewrappingTypeProxy are all operations </span>
    <span class="comment">// in class Type that are overridden in some subclass</span>
    <span class="comment">// Important to keep this up-to-date when new operations are added!</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148225">isTrivial</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105303" title="=&gt; Boolean">isTrivial</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148226">isHigherKinded</a>: <span title="Boolean">Boolean</span> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105304" title="=&gt; Boolean">isHigherKinded</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148227">typeConstructor</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105325" title="=&gt; Types.this.Type">typeConstructor</a> 
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148228">isNotNull</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105307" title="=&gt; Boolean">isNotNull</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148229">isError</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105344" title="=&gt; Boolean">isError</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148230">isErroneous</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105345" title="=&gt; Boolean">isErroneous</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148231">isStable</a>: <span title="Boolean">Boolean</span> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105305" title="=&gt; Boolean">isStable</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148232">isVolatile</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105306" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148233">finalResultType</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105331" title="=&gt; Types.this.Type">finalResultType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148234">paramSectionCount</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105332" title="=&gt; Int">paramSectionCount</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="148235">paramss</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105333" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148236">params</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105334" title="=&gt; List[Types.this.Symbol]">params</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148237">paramTypes</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105335" title="=&gt; List[Types.this.Type]">paramTypes</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148238">termSymbol</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105312" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148239">termSymbolDirect</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105314" title="=&gt; Types.this.Symbol">termSymbolDirect</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148240">typeParams</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105336" title="=&gt; List[Types.this.Symbol]">typeParams</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="148241">boundSyms</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105337" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148242">typeSymbol</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148243">typeSymbolDirect</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105315" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148244">widen</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105317" title="=&gt; Types.this.Type">widen</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148245">typeOfThis</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105319" title="=&gt; Types.this.Type">typeOfThis</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="148246">bounds</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148247">parents</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105322" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148248">prefix</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105323" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="148249">decls</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105346" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="148250">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="449460">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105358" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#449460" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="148251">baseTypeSeq</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105383" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148252">baseTypeSeqDepth</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105384" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148253">baseClasses</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105385" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A proxy for a type (identified by field `underlying') that forwards most 
   *  operations to it. Every operation that is overridden for some kind of types is
   *  forwarded here. Some operations are rewrapped again.
   */</span>
  <span class="keyword">trait</span> <a title="trait RewrappingTypeProxy extends Types.this.Type with Types.this.SimpleTypeProxy with ScalaObject" id="67380">RewrappingTypeProxy</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67379" title="Types.this.SimpleTypeProxy">SimpleTypeProxy</a> <span class="delimiter">{</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="148954">maybeRewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="449474">newtp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#449474" title="Types.this.Type">newtp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#105316" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span> <a href="#67380" title="Types.this.RewrappingTypeProxy" class="keyword">this</a> <span class="keyword">else</span> <a href="#148955" title="(newtp: Types.this.Type)Types.this.Type">rewrap</a><span class="delimiter">(</span><a href="#449474" title="Types.this.Type">newtp</a><span class="delimiter">)</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="148955">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="449477">newtp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a>

    <span class="comment">// the following are all operations in class Type that are overridden in some subclass</span>
    <span class="comment">// Important to keep this up-to-date when new operations are added!</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148956">widen</a> = <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105317" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148957">narrow</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105320" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148958">deconst</a> = <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105318" title="=&gt; Types.this.Type">deconst</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148959">resultType</a> = <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105327" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(actuals: List[Types.this.Type])Types.this.Type" id="148960">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="449496">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105328" title="(actuals: List[Types.this.Type])Types.this.Type">resultType</a><span class="delimiter">(</span><a href="#449496" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148961">finalResultType</a> = <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105331" title="=&gt; Types.this.Type">finalResultType</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148962">paramSectionCount</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="148963">paramss</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148964">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148965">paramTypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148966">typeArgs</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105326" title="=&gt; List[Types.this.Type]">typeArgs</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148967">notNull</a> = <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105338" title="=&gt; Types.this.Type">notNull</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="148968">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="449544">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="449545">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105339" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#449544" title="List[Types.this.Symbol]">formals</a>, <a href="#449545" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="148969">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="449551">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="449552">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105340" title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type">skolemizeExistential</a><span class="delimiter">(</span><a href="#449551" title="Types.this.Symbol">owner</a>, <a href="#449552" title="AnyRef">origin</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148970">normalize</a> = <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148971">dealias</a> = <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105343" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="148972">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="449565">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105387" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#449565" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="148973">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="449568">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105388" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#449568" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148974">prefixString</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105392" title="=&gt; java.lang.String">prefixString</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148975">isComplete</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<span title="=&gt; Boolean">isComplete</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="148976">complete</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="449577">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<span title="(sym: Types.this.Symbol)Unit">complete</span><span class="delimiter">(</span><a href="#449577" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="148977">load</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="449582">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105395" title="(sym: Types.this.Symbol)Unit">load</a><span class="delimiter">(</span><a href="#449582" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="148978">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="449584">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105402" title="(annots: List[Types.this.AnnotationInfo])Types.this.Type">withAnnotations</a><span class="delimiter">(</span><a href="#449584" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148979">withoutAnnotations</a> = <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105403" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The base class for all types */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Type extends Types.this.AbsType with ScalaObject" id="67381">Type</a> <a href="#67381" title="ScalaObject" class="keyword">extends</a> <a href="#24048" title="Types.this.AbsType">AbsType</a> <span class="delimiter">{</span>
    
    <span class="comment">/** Types for which asSeenFrom always is the identity, no matter what
     *  prefix or owner.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105303">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** Is this type higher-kinded, i.e., is it a type constructor @M */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105304">isHigherKinded</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span> 
    
    <span class="comment">/** Does this type denote a stable reference (i.e. singleton type)? */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105305">isStable</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** Is this type dangerous (i.e. it might contain conflicting
     *  type information when empty, so that it can be constructed
     *  so that type unsoundness results.) A dangerous type has an underlying
     *  type of the form T_1 with T_n { decls }, where one of the
     *  T_i (i &gt; 1) is an abstract type.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105306">isVolatile</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** Is this type guaranteed not to have `null' as a value? */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105307">isNotNull</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** Is this type a structural refinement type (it 'refines' members that have not been inherited) */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105308">isStructuralRefinement</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** Does this type depend immediately on an enclosing method parameter? 
      * i.e., is it a singleton type whose termSymbol refers to an argument of the symbol's owner (which is a method)
      */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105309">isImmediatelyDependent</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** Does this depend on an enclosing method parameter? */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105310">isDependent</a>: <span title="Boolean">Boolean</span> = <a href="#67528" title="object Types.this.IsDependentCollector">IsDependentCollector</a>.<a href="#449236" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/** True for WildcardType or BoundedWildcardType */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105311">isWildcard</a> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** The term symbol associated with the type
      * Note that the symbol of the normalized type is returned (@see normalize)
      */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="105312">termSymbol</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a>

    <span class="comment">/** The type symbol associated with the type
      * Note that the symbol of the normalized type is returned (@see normalize)
      */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="105313">typeSymbol</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a>

    <span class="comment">/** The term symbol *directly* associated with the type
      */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="105314">termSymbolDirect</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <a href="#105312" title="=&gt; Types.this.Symbol">termSymbol</a>

    <span class="comment">/** The type symbol *directly* associated with the type
      */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="105315">typeSymbolDirect</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>

    <span class="comment">/** The base type underlying a type proxy,
     *  identity on all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105316">underlying</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Widen from singleton type to its underlying non-singleton
     *  base type by applying one or more `underlying' dereferences,
     *  identity for all other types.
     *  
     *  class Outer { class C ; val x: C }
     *  val o: Outer
     *  &lt;o.x.type&gt;.widen = o.C
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105317">widen</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Map a constant type or not-null-type to its underlying base type,
     *  identity for all other types.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105318">deconst</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** The type of `this' of a class type or reference type
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105319">typeOfThis</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107458" title="=&gt; Types.this.Type">typeOfThis</a>

    <span class="comment">/** Map to a singleton type which is a subtype of this type.
     *  The fallback implemented here gives
     *    T.narrow  =  (T {}).this.type
     *  Overridden where we know more about where types come from.
     *
     *  todo: change to singleton type of an existentially defined variable
     *  of the right type instead of making this a `this` of a refined type.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105320">narrow</a>: <a href="#67381" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#67381" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="Boolean(false)">alternativeNarrow</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// investigate why this does not work!</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="449612">tparam</a> = <a href="#67649" title="(t: Types.this.Type)Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span> <a href="Symbols.scala.html#107304" title="(suffix: String)Types.this.Symbol">freshExistential</a> <span title="java.lang.String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span> <a href="Symbols.scala.html#107425" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a> <a href="#67519" title="(hi: Types.this.Type)Types.this.TypeBounds">singletonBounds</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#449612" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="449640">cowner</a> = <a href="#67649" title="(t: Types.this.Type)Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#67469" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>, <a href="#449640" title="Types.this.Symbol">cowner</a>, <a href="Scopes.scala.html#67682" title="object Types.this.EmptyScope">EmptyScope</a>, <a href="#449640" title="Types.this.Symbol">cowner</a>.<a href="Symbols.scala.html#107263" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>.<a href="#105320" title="=&gt; Types.this.Type">narrow</a>
      <span class="delimiter">}</span>

    <span class="comment">/** For a TypeBounds type, itself;
     *  for a reference denoting an abstract type, its bounds,
     *  for all other types, a TypeBounds type all of whose bounds are this type.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="105321">bounds</a>: <a href="#148453" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#148437" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/** For a class or intersection type, its parents.
     *  For a TypeBounds type, the parents of its hi bound.
     *  inherited by typerefs, singleton types, and refinement types,
     *  The empty list for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="105322">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">/** For a typeref or single-type, the prefix of the normalized type (@see normalize).
     *  NoType for all other types. */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105323">prefix</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#450850" title="object Types.this.NoType">NoType</a>

    <span class="comment">/** A chain of all typeref or singletype prefixes of this type, longest first.
     *  (Only used from safeToString.)
     */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="105324">prefixChain</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#67381" title="Types.this.Type" class="keyword">this</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="List[Types.this.Type]">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="449667">pre</a>, _, _<span class="delimiter">)</span> =&gt; <a href="#449667" title="Types.this.Type">pre</a> <a href="#449668" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#449667" title="Types.this.Type">pre</a>.<a href="#105324" title="=&gt; List[Types.this.Type]">prefixChain</a>
      <span class="keyword">case</span> <span title="List[Types.this.Type]">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="449674">pre</a>, _<span class="delimiter">)</span> =&gt; <a href="#449674" title="Types.this.Type">pre</a> <a href="#449675" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#449674" title="Types.this.Type">pre</a>.<a href="#105324" title="=&gt; List[Types.this.Type]">prefixChain</a>
      <span class="keyword">case</span> <span title="List[Nothing]">_</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** This type, without its type arguments @M */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105325">typeConstructor</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** For a typeref, its arguments. The empty list for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="105326">typeArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">/** For a (nullary) method or poly type, its direct result type, 
     *  the type itself for all other types. */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105327">resultType</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="keyword">def</span> <a title="(actuals: List[Types.this.Type])Types.this.Type" id="105328">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="204801">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Only used for dependent method types. */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105329">resultApprox</a>: <a href="#67381" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span><span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36832" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">YdepMethTpes</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#449701" title="(tp: Types.this.Type)Types.this.Type">ApproximateDependentMap</a><span class="delimiter">(</span><a href="#105327" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#105327" title="=&gt; Types.this.Type">resultType</a>

    <span class="comment">/** If this is a TypeRef `clazz`[`T`], return the argument `T`
     *  otherwise return this type
     */</span>
    <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="105330">remove</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="449714">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** For a curried/nullary method or poly type its non-method result type, 
     *  the type itself for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105331">finalResultType</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** For a method type, the number of its value parameter sections,
     *  0 for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; Int" id="105332">paramSectionCount</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>

    <span class="comment">/** For a method or poly type, a list of its value parameter sections,
     *  the empty list for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="105333">paramss</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">/** For a method or poly type, its first value parameter section,
     *  the empty list for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="105334">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">/** For a method or poly type, the types of its first value parameter section,
     *  the empty list for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="105335">paramTypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    
    <span class="comment">/** For a (potentially wrapped) poly type, its type parameters,
     *  the empty list for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="105336">typeParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
  
    <span class="comment">/** For a (potentially wrapped) poly or existential type, its bound symbols,
     *  the empty list for all other types */</span>
    <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="105337">boundSyms</a>: immutable.<span title="scala.collection.immutable.Set[Types.this.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#67352" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">emptySymbolSet</a>

    <span class="comment">/** Mixin a NotNull trait unless type already has one
     *  ...if the option is given, since it is causing typing bugs.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105338">notNull</a>: <a href="#67381" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36830" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">Ynotnull</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">||</span> <a href="#105307" title="=&gt; Boolean">isNotNull</a> <span title="(x: Boolean)Boolean">||</span> <a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#67381" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#449751" title="(underlying: Types.this.Type)Types.this.NotNullType">NotNullType</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
    
    <span class="comment">/** Replace formal type parameter symbols with actual type arguments. 
     *
     * Amounts to substitution except for higher-kinded types. (See overridden method in TypeRef) -- @M
     */</span>
    <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="105339">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="449547">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="449548">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#449547" title="List[Types.this.Symbol]">formals</a>, <a href="#449548" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#67381" title="Type.this.type" class="keyword">this</a>.<a href="#105363" title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#449547" title="List[Types.this.Symbol]">formals</a>, <a href="#449548" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#450783" title="object Types.this.ErrorType">ErrorType</a>

    <span class="comment">/** If this type is an existential, turn all existentially bound variables to type skolems.
     *  @param  owner    The owner of the created type skolems
     *  @param  origin   The tree whose type was an existential for which the skolem was created.
     */</span>
    <span class="keyword">def</span> <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="105340">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="375729">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="375730">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#67381" title="Types.this.Type" class="keyword">this</a>
    
    <span class="comment">/** A simple version of skolemizeExistential for situations where
     *  owner or unpack location do not matter (typically used in subtype tests)
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105341">skolemizeExistential</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#105340" title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type">skolemizeExistential</a><span class="delimiter">(</span><a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a>, <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
    
    <span class="comment">/** Reduce to beta eta-long normal form.
     *  Expands type aliases and converts higher-kinded TypeRefs to PolyTypes.
     *  Functions on types are also implemented as PolyTypes.
     * 
     *  Example: (in the below, &lt;List&gt; is the type constructor of List)
     *    TypeRef(pre, &lt;List&gt;, List()) is replaced by
     *    PolyType(X, TypeRef(pre, &lt;List&gt;, List(X)))
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105342">normalize</a> = <a href="#67381" title="Types.this.Type" class="keyword">this</a> <span class="comment">// @MAT</span>
    
    <span class="comment">/** Expands type aliases. */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105343">dealias</a> = <a href="#67381" title="Types.this.Type" class="keyword">this</a>
    
    <span class="comment">/** Is this type produced as a repair for an error? */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105344">isError</a>: <span title="Boolean">Boolean</span> = <a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107337" title="=&gt; Boolean">isError</a> <span title="(x: Boolean)Boolean">||</span> <a href="#105312" title="=&gt; Types.this.Symbol">termSymbol</a>.<a href="Symbols.scala.html#107337" title="=&gt; Boolean">isError</a>

    <span class="comment">/** Is this type produced as a repair for an error? */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105345">isErroneous</a>: <span title="Boolean">Boolean</span> = <a href="#67544" title="object Types.this.ErroneousCollector">ErroneousCollector</a>.<a href="#449236" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/** Does this type denote a reference type which can be null? */</span>
    <span class="comment">// def isNullable: Boolean = false</span>

    <span class="comment">/** For a classtype or refined type, its defined or declared members;
     *  inherited by subtypes and typerefs.
     *  The empty scope for all other types.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="105346">decls</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a> = <a href="Scopes.scala.html#67682" title="object Types.this.EmptyScope">EmptyScope</a>

    <span class="comment">/** The defined or declared members with name `name' in this type;
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Alternatives of overloaded symbol appear in the order they are declared.
     */</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="105347">decl</a><span class="delimiter">(</span><a title="Types.this.Name" id="222864">name</a>: <a href="Names.scala.html#66914" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <a href="#105396" title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol">findDecl</a><span class="delimiter">(</span><a href="#222864" title="Types.this.Name">name</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>

    <span class="comment">/** The non-private defined or declared members with name `name' in this type;
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Alternatives of overloaded symbol appear in the order they are declared.
     */</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="105348">nonPrivateDecl</a><span class="delimiter">(</span><a title="Types.this.Name" id="348304">name</a>: <a href="Names.scala.html#66914" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <a href="#105396" title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol">findDecl</a><span class="delimiter">(</span><a href="#348304" title="Types.this.Name">name</a>, <span title="Int(4)">PRIVATE</span><span class="delimiter">)</span>

    <span class="comment">/** A list of all members of this type (defined or inherited)
     *  Members appear in linearization order of their owners.
     *  Members with the same owner appear in reverse order of their declarations.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="105349">members</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#105397" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="StdNames.scala.html#67713" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115274" title="=&gt; Types.this.nme.NameType">ANYNAME</a>, <span title="Long(0L)" class="int">0</span>, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#107450" title="=&gt; List[Types.this.Symbol]">alternatives</a>

    <span class="comment">/** A list of all non-private members of this type (defined or inherited) */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="105350">nonPrivateMembers</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#105397" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="StdNames.scala.html#67713" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115274" title="=&gt; Types.this.nme.NameType">ANYNAME</a>, PRIVATE <span title="Long(4398113619972L)">|</span> BRIDGES, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#107450" title="=&gt; List[Types.this.Symbol]">alternatives</a>

    <span class="comment">/** A list of all non-private members of this type  (defined or inherited),
     *  admitting members with given flags `admit`
     */</span>
    <span class="keyword">def</span> <a title="(admit: Long)List[Types.this.Symbol]" id="105351">nonPrivateMembersAdmitting</a><span class="delimiter">(</span><a title="Long" id="449795">admit</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#105397" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="StdNames.scala.html#67713" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115274" title="=&gt; Types.this.nme.NameType">ANYNAME</a>, <span class="delimiter">(</span>PRIVATE <span title="Long(4398113619972L)">|</span> BRIDGES<span class="delimiter">)</span> <span title="(x: Long)Long">&amp;</span> <span title="=&gt; Long">~</span><a href="#449795" title="Long">admit</a>, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#107450" title="=&gt; List[Types.this.Symbol]">alternatives</a>

    <span class="comment">/** A list of all implicit symbols of this type  (defined or inherited) */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="105352">implicitMembers</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#105397" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="StdNames.scala.html#67713" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115274" title="=&gt; Types.this.nme.NameType">ANYNAME</a>, <span title="Long(4398113619968L)">BRIDGES</span>, <span title="Long(512L)">IMPLICIT</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#107450" title="=&gt; List[Types.this.Symbol]">alternatives</a>

    <span class="comment">/** A list of all deferred symbols of this type  (defined or inherited) */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="105353">deferredMembers</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#105397" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="StdNames.scala.html#67713" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115274" title="=&gt; Types.this.nme.NameType">ANYNAME</a>, <span title="Long(4398113619968L)">BRIDGES</span>, <span title="Long(16L)">DEFERRED</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#107450" title="=&gt; List[Types.this.Symbol]">alternatives</a>

    <span class="comment">/** The member with given name, 
     *  an OverloadedSymbol if several exist, NoSymbol if none exist */</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="105354">member</a><span class="delimiter">(</span><a title="Types.this.Name" id="122284">name</a>: <a href="Names.scala.html#66914" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <a href="#105397" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#122284" title="Types.this.Name">name</a>, <span title="Long(4398113619968L)">BRIDGES</span>, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

    <span class="comment">/** The non-private member with given name,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Bridges are excluded from the result
     */</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="105355">nonPrivateMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="132511">name</a>: <a href="Names.scala.html#66914" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> =
      <a href="#105397" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#132511" title="Types.this.Name">name</a>, PRIVATE <span title="Long(4398113619972L)">|</span> BRIDGES, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
  
    <span class="comment">/** The non-private member with given name, admitting members with given flags `admit`
     *  an OverloadedSymbol if several exist, NoSymbol if none exist
     */</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name, admit: Long)Types.this.Symbol" id="105356">nonPrivateMemberAdmitting</a><span class="delimiter">(</span><a title="Types.this.Name" id="446661">name</a>: <a href="Names.scala.html#66914" title="Types.this.Name">Name</a>, <a title="Long" id="446662">admit</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> =
      <a href="#105397" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#446661" title="Types.this.Name">name</a>, <span class="delimiter">(</span>PRIVATE <span title="Long(4398113619972L)">|</span> BRIDGES<span class="delimiter">)</span> <span title="(x: Long)Long">&amp;</span> <span title="=&gt; Long">~</span><a href="#446662" title="Long">admit</a>, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
  
    <span class="comment">/** The non-local member with given name,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist */</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="105357">nonLocalMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="449819">name</a>: <a href="Names.scala.html#66914" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> =
      <a href="#105397" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#449819" title="Types.this.Name">name</a>, LOCAL <span title="Long(4398114144256L)">|</span> BRIDGES, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

    <span class="comment">/** The least type instance of given class which is a supertype
     *  of this type.  Example:
     *    class D[T]
     *    class C extends p.D[Int]
     *    ThisType(C).baseType(D) = p.D[Int]
     */</span>
    <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="105358">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="298349">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#450850" title="object Types.this.NoType">NoType</a>

    <span class="comment">/** This type as seen from prefix `pre' and class `clazz'. This means:
     *  Replace all thistypes of `clazz' or one of its subclasses
     *  by `pre' and instantiate all parameters by arguments of `pre'.
     *  Proceed analogously for thistypes referring to outer classes.
     *
     *  Example:
     *    class D[T] { def m: T }
     *    class C extends p.D[Int]
     *    T.asSeenFrom(ThisType(C), D)  (where D is owner of m)
     *      = Int
     */</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="105359">asSeenFrom</a><span class="delimiter">(</span><a title="Types.this.Type" id="133527">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="133528">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#105303" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#133527" title="Types.this.Type">pre</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106253" title="=&gt; Types.this.Symbol">ArrayClass</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="../util/Statistics.scala.html#67151" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67196" title="=&gt; scala.tools.nsc.util.Statistics.Counter">asSeenFromCount</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="scala.tools.nsc.util.Statistics.LongPair" id="449830">start</a> = <a href="../util/Statistics.scala.html#67155" title="(tm: scala.tools.nsc.util.Statistics.Timer)scala.tools.nsc.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67198" title="=&gt; scala.tools.nsc.util.Statistics.Timer">asSeenFromNanos</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.AsSeenFromMap" id="449831">m</a> = <span title="Types.this.AsSeenFromMap" class="keyword">new</span> <a href="#67520" title="Types.this.AsSeenFromMap">AsSeenFromMap</a><span class="delimiter">(</span><a href="#133527" title="Types.this.Type">pre</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a>, <a href="#133528" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="449832">tp</a> = <a href="#449831" title="Types.this.AsSeenFromMap">m</a> <a href="#449852" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#67381" title="Types.this.Type" class="keyword">this</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="449833">result</a> = <a href="#67482" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#449831" title="Types.this.AsSeenFromMap">m</a>.<a href="#449844" title="=&gt; List[Types.this.Symbol]">capturedParams</a>, <a href="#449832" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <a href="../util/Statistics.scala.html#67156" title="(tm: scala.tools.nsc.util.Statistics.Timer, start: scala.tools.nsc.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67198" title="=&gt; scala.tools.nsc.util.Statistics.Timer">asSeenFromNanos</a>, <a href="#449830" title="scala.tools.nsc.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
        <a href="#449833" title="Types.this.Type">result</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** The info of `sym', seen as a member of this type.
     *
     *  Example:
     *    class D[T] { def m: T }
     *    class C extends p.D[Int]
     *    ThisType(C).memberType(m) = Int
     */</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="105360">memberInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="236215">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#236215" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105359" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#236215" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** The type of `sym', seen as a member of this type. */</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="105361">memberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="132519">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#132519" title="Types.this.Symbol">sym</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="449859">meth</a>: <a href="Symbols.scala.html#67323" title="Types.this.MethodSymbol">MethodSymbol</a> =&gt;
        <a href="#449859" title="Types.this.MethodSymbol">meth</a>.<a href="Symbols.scala.html#210886" title="(pre: Types.this.Type)Types.this.Type">typeAsMemberOf</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#105362" title="(sym: Types.this.Symbol)Types.this.Type">computeMemberType</a><span class="delimiter">(</span><a href="#132519" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="105362">computeMemberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="447361">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#447361" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107422" title="=&gt; Types.this.Type">tpeHK</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span> <span class="comment">//@M don't prematurely instantiate higher-kinded types, they will be instantiated by transform, typedTypeApply, etc. when really necessary</span>
      <span class="keyword">case</span> <span title="Types.this.OverloadedType">OverloadedType</span><span class="delimiter">(</span>_, <a title="List[Types.this.Symbol]" id="449861">alts</a><span class="delimiter">)</span> =&gt;
        <a href="#251432" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.OverloadedType">OverloadedType</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#449861" title="List[Types.this.Symbol]">alts</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="449864">tp</a> =&gt;
        <a href="#449864" title="Types.this.Type">tp</a>.<a href="#105359" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#447361" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Substitute types `to' for occurrences of references to
     *  symbols `from' in this type.
     */</span>
    <span class="keyword">def</span> <a title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type" id="105363">subst</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="449771">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="449772">to</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#449771" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#67381" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.SubstTypeMap" class="keyword">new</span> <a href="#67524" title="Types.this.SubstTypeMap">SubstTypeMap</a><span class="delimiter">(</span><a href="#449771" title="List[Types.this.Symbol]">from</a>, <a href="#449772" title="List[Types.this.Type]">to</a><span class="delimiter">)</span> <a href="#167383" title="(tp0: Types.this.Type)Types.this.Type">apply</a> <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Substitute symbols `to' for occurrences of symbols
     *  `from' in this type.
     * !!! NOTE !!!: If you need to do a substThis and a substSym, the substThis has to come
     * first, as otherwise symbols will immediately get rebound in typeRef to the old 
     * symbol.
     */</span>
    <span class="keyword">def</span> <a title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type" id="105364">substSym</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="313913">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="313914">to</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#313913" title="List[Types.this.Symbol]">from</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#313914" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <a href="#67381" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.SubstSymMap" class="keyword">new</span> <a href="#67523" title="Types.this.SubstSymMap">SubstSymMap</a><span class="delimiter">(</span><a href="#313913" title="List[Types.this.Symbol]">from</a>, <a href="#313914" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <a href="#167513" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Substitute all occurrences of `ThisType(from)' in this type
     *  by `to'.
     * !!! NOTE !!!: If you need to do a substThis and a substSym, the substThis has to come
     * first, as otherwise symbols will immediately get rebound in typeRef to the old 
     * symbol.
     */</span>
    <span class="keyword">def</span> <a title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type" id="105365">substThis</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="446191">from</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="446192">to</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
      <span title="Types.this.SubstThisMap" class="keyword">new</span> <a href="#67525" title="Types.this.SubstThisMap">SubstThisMap</a><span class="delimiter">(</span><a href="#446191" title="Types.this.Symbol">from</a>, <a href="#446192" title="Types.this.Type">to</a><span class="delimiter">)</span> <a href="#449874" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="keyword">def</span> <a title="(from: Types.this.Type, to: Types.this.Type)Types.this.Type" id="105366">substSuper</a><span class="delimiter">(</span><a title="Types.this.Type" id="449882">from</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="449883">to</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
      <span title="Types.this.SubstSuperMap" class="keyword">new</span> <a href="#67526" title="Types.this.SubstSuperMap">SubstSuperMap</a><span class="delimiter">(</span><a href="#449882" title="Types.this.Type">from</a>, <a href="#449883" title="Types.this.Type">to</a><span class="delimiter">)</span> <a href="#449890" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Returns all parts of this type which satisfy predicate `p' */</span>
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]" id="105367">filter</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="449898">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="Types.this.FilterTypeCollector" class="keyword">new</span> <a href="#67541" title="Types.this.FilterTypeCollector">FilterTypeCollector</a><span class="delimiter">(</span><a href="#449898" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span>.<a href="#449236" title="(tp: Types.this.Type)scala.collection.mutable.ListBuffer[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>.<span title="=&gt; List[Types.this.Type]">toList</span>

    <span class="comment">/** Returns optionally first type (in a preorder traversal) which satisfies predicate `p',
     *  or None if none exists. 
     */</span>
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Option[Types.this.Type]" id="105368">find</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="449917">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <span title="Option[Types.this.Type]">Option</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="Types.this.FindTypeCollector" class="keyword">new</span> <a href="#67543" title="Types.this.FindTypeCollector">FindTypeCollector</a><span class="delimiter">(</span><a href="#449917" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span>.<a href="#449236" title="(tp: Types.this.Type)Option[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/** Apply `f' to each part of this type */</span>
    <span class="keyword">def</span> <a title="(f: Types.this.Type =&gt; Unit)Unit" id="105369">foreach</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Unit" id="449924">f</a>: Type =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Types.this.ForEachTypeTraverser" class="keyword">new</span> <a href="#67542" title="Types.this.ForEachTypeTraverser">ForEachTypeTraverser</a><span class="delimiter">(</span><a href="#449924" title="Types.this.Type =&gt; Unit">f</a><span class="delimiter">)</span>.<a href="#449929" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span> <span class="delimiter">}</span>

    <span class="comment">/** Apply `f' to each part of this type; children get mapped before their parents */</span>
    <span class="keyword">def</span> <a title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.Type" id="105370">map</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Types.this.Type" id="449934">f</a>: Type =&gt; Type<span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#449936" title="Types.this.TypeMap" class="keyword">new</a> <a href="#67503" title="anonymous class $anon extends Types.this.TypeMap" id="449936">TypeMap</a> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(x: Types.this.Type)Types.this.Type" id="449938">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="449939">x</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#449934" title="(v1: Types.this.Type)Types.this.Type">f</a><span class="delimiter">(</span><a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#449939" title="Types.this.Type">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <a href="#449938" title="(x: Types.this.Type)Types.this.Type">apply</a> <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Is there part of this type which satisfies predicate `p'? */</span>
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Boolean" id="105371">exists</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="449958">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="=&gt; Boolean">!</span><a href="#105368" title="(p: Types.this.Type =&gt; Boolean)Option[Types.this.Type]">find</a><span class="delimiter">(</span><a href="#449958" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span>.<span title="=&gt; Boolean">isEmpty</span>

    <span class="comment">/** Does this type contain a reference to this symbol? */</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="105372">contains</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="449960">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="Types.this.ContainsCollector" class="keyword">new</span> <a href="#67539" title="Types.this.ContainsCollector">ContainsCollector</a><span class="delimiter">(</span><a href="#449960" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#449236" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/** Does this type contain a reference to this type */</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="105373">containsTp</a><span class="delimiter">(</span><a title="Types.this.Type" id="449971">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="Types.this.ContainsTypeCollector" class="keyword">new</span> <a href="#67540" title="Types.this.ContainsTypeCollector">ContainsTypeCollector</a><span class="delimiter">(</span><a href="#449971" title="Types.this.Type">tp</a><span class="delimiter">)</span>.<a href="#449236" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/** Is this type a subtype of that type? */</span>
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="105374">&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="151879">that</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span>util.<a href="../util/Statistics.scala.html#30936" title="object scala.tools.nsc.util.Statistics">Statistics</a>.<a href="../util/Statistics.scala.html#67144" title="=&gt; Boolean">enabled</a><span class="delimiter">)</span> <a href="#105377" title="(that: Types.this.Type)Boolean">stat_&lt;:&lt;</a><span class="delimiter">(</span><a href="#151879" title="Types.this.Type">that</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="delimiter">(</span><a href="#67381" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#151879" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
        <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67350" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#67665" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="java.lang.String(&quot;&lt;:&quot;)" class="string">&quot;&lt;:&quot;</span>, <a href="#67583" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a>, <a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#151879" title="Types.this.Type">that</a><span class="delimiter">)</span>
         <span class="keyword">else</span> <a href="#67584" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#151879" title="Types.this.Type">that</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    
    <span class="comment">/** Can this type only be subtyped by bottom types?
     *  This is assessed to be the case if the class is final,
     *  and all type parameters (if any) are invariant.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105375">isFinalType</a> = <span class="delimiter">(</span>
      <a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isFinal</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span class="delimiter">(</span><a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#210485" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107399" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    
    <span class="comment">/** Is this type a subtype of that type in a pattern context?
     *  Any type arguments on the right hand side are replaced with
     *  fresh existentials, except for Arrays.
     *
     *  See bug1434.scala for an example of code which would fail
     *  if only a &lt;:&lt; test were applied.
     */</span>     
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="105376">matchesPattern</a><span class="delimiter">(</span><a title="Types.this.Type" id="403317">that</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="delimiter">(</span><a href="#67381" title="Type.this.type" class="keyword">this</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#403317" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#403317" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>        
        <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>TypeRef<span class="delimiter">(</span>_, <a href="Definitions.scala.html#106253" title="=&gt; Types.this.Symbol">ArrayClass</a>, <a href="#450024" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="450035">arg1</a><span class="delimiter">)</span><span class="delimiter">)</span>, TypeRef<span class="delimiter">(</span>_, <a href="Definitions.scala.html#106253" title="=&gt; Types.this.Symbol">ArrayClass</a>, <a href="#450037" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="450048">arg2</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#450048" title="Types.this.Type">arg2</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">nonEmpty</span> =&gt;
          <a href="#450035" title="Types.this.Type">arg1</a> <a href="#105376" title="(that: Types.this.Type)Boolean">matchesPattern</a> <a href="#450048" title="Types.this.Type">arg2</a>
        <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>_, TypeRef<span class="delimiter">(</span>_, _, <a title="List[Types.this.Type]" id="450052">args</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="450053">newtp</a> = <a href="#67482" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#450052" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <span class="delimiter">(</span><a href="#450070" title="Types.this.Type">_</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>, <a href="#403317" title="Types.this.Type">that</a><span class="delimiter">)</span>
          <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#403317" title="Types.this.Type">that</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#450053" title="Types.this.Type">newtp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#67381" title="Type.this.type" class="keyword">this</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#450053" title="Types.this.Type">newtp</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
          <span title="Boolean(false)" class="keyword">false</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="105377">stat_&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="449982">that</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="../util/Statistics.scala.html#67151" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67200" title="=&gt; scala.tools.nsc.util.Statistics.Counter">subtypeCount</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.tools.nsc.util.Statistics.LongPair" id="450098">start</a> = <a href="../util/Statistics.scala.html#67155" title="(tm: scala.tools.nsc.util.Statistics.Timer)scala.tools.nsc.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67202" title="=&gt; scala.tools.nsc.util.Statistics.Timer">subtypeNanos</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Boolean" id="450099">result</a> = 
        <span class="delimiter">(</span><a href="#67381" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#449982" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
        <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67350" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#67665" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="java.lang.String(&quot;&lt;:&quot;)" class="string">&quot;&lt;:&quot;</span>, <a href="#67583" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a>, <a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#449982" title="Types.this.Type">that</a><span class="delimiter">)</span>
         <span class="keyword">else</span> <a href="#67584" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#449982" title="Types.this.Type">that</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="../util/Statistics.scala.html#67156" title="(tm: scala.tools.nsc.util.Statistics.Timer, start: scala.tools.nsc.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67202" title="=&gt; scala.tools.nsc.util.Statistics.Timer">subtypeNanos</a>, <a href="#450098" title="scala.tools.nsc.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
      <a href="#450099" title="Boolean">result</a>
    <span class="delimiter">}</span>

    <span class="comment">/** Is this type a weak subtype of that type? True also for numeric types, i.e. Int weak_&lt;:&lt; Long.
     */</span>
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="105378">weak_&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="450124">that</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="../util/Statistics.scala.html#67151" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67200" title="=&gt; scala.tools.nsc.util.Statistics.Counter">subtypeCount</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.tools.nsc.util.Statistics.LongPair" id="450126">start</a> = <a href="../util/Statistics.scala.html#67155" title="(tm: scala.tools.nsc.util.Statistics.Timer)scala.tools.nsc.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67202" title="=&gt; scala.tools.nsc.util.Statistics.Timer">subtypeNanos</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Boolean" id="450127">result</a> =
        <span class="delimiter">(</span><span class="delimiter">(</span><a href="#67381" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450124" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
         <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67350" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#67665" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="java.lang.String(&quot;weak_&lt;:&quot;)" class="string">&quot;weak_&lt;:&quot;</span>, <a href="#67632" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isWeakSubType</a>, <a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#450124" title="Types.this.Type">that</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#67632" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isWeakSubType</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#450124" title="Types.this.Type">that</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="../util/Statistics.scala.html#67156" title="(tm: scala.tools.nsc.util.Statistics.Timer, start: scala.tools.nsc.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67202" title="=&gt; scala.tools.nsc.util.Statistics.Timer">subtypeNanos</a>, <a href="#450126" title="scala.tools.nsc.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
      <a href="#450127" title="Boolean">result</a>
    <span class="delimiter">}</span>

    <span class="comment">/** Is this type equivalent to that type? */</span>
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="105379">=:=</a><span class="delimiter">(</span><a title="Types.this.Type" id="210493">that</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span>
      <span class="delimiter">(</span><a href="#67381" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#210493" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
      <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67350" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#67665" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="java.lang.String(&quot;=&quot;)" class="string">&quot;=&quot;</span>, <a href="#67566" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a>, <a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#210493" title="Types.this.Type">that</a><span class="delimiter">)</span>
       <span class="keyword">else</span> <a href="#67566" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#210493" title="Types.this.Type">that</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>;

    <span class="comment">/** Does this type implement symbol `sym' with same or stronger type?
     */</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="105380">specializes</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="450186">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67350" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#67665" title="(op: String, p: (Types.this.Type, Types.this.Symbol) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Symbol)Boolean">explain</a><span class="delimiter">(</span><span title="java.lang.String(&quot;specializes&quot;)" class="string">&quot;specializes&quot;</span>, <a href="#67603" title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean">specializesSym</a>, <a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#450186" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#67603" title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#450186" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>

    <span class="comment">/** Is this type close enough to that type so that members
     *  with the two type would override each other?
     *  This means: 
     *    - Either both types are polytypes with the same number of
     *      type parameters and their result types match after renaming 
     *      corresponding type parameters
     *    - Or both types are (nullary) method types with equivalent type parameter types
     *      and matching result types
     *    - Or both types are equivalent
     *    - Or phase.erasedTypes is false and both types are neither method nor
     *      poly types.
     */</span>
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="105381">matches</a><span class="delimiter">(</span><a title="Types.this.Type" id="314040">that</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#67605" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#314040" title="Types.this.Type">that</a>, <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>

    <span class="comment">/** Same as matches, except that non-method types are always assumed to match.
     */</span>
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="105382">looselyMatches</a><span class="delimiter">(</span><a title="Types.this.Type" id="450218">that</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#67605" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#450218" title="Types.this.Type">that</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

    <span class="comment">/** The shortest sorted upwards closed array of types that contains
     *  this type as first element.
     *
     *  A list or array of types ts is upwards closed if
     *
     *    for all t in ts:
     *      for all typerefs p.s[args] such that t &lt;: p.s[args] 
     *      there exists a typeref p'.s[args'] in ts such that 
     *      t &lt;: p'.s['args] &lt;: p.s[args],
     *
     *      and
     *
     *      for all singleton types p.s such that t &lt;: p.s 
     *      there exists a singleton type p'.s in ts such that 
     *      t &lt;: p'.s &lt;: p.s
     *
     *  Sorting is with respect to Symbol.isLess() on type symbols.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="105383">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#67693" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="BaseTypeSeqs.scala.html#67696" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">baseTypeSingletonSeq</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/** The maximum depth (@see maxDepth)
     *  of each type in the BaseTypeSeq of this type.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Int" id="105384">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <span title="Int(1)" class="int">1</span>

    <span class="comment">/** The list of all baseclasses of this type (including its own typeSymbol)
     *  in reverse linearization order, starting with the class itself and ending
     *  in class Any.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="105385">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">/**
     *  @param sym the class symbol
     *  @return    the index of given class symbol in the BaseTypeSeq of this type,
     *             or -1 if no base type with given class symbol exists.
     */</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Int" id="105386">baseTypeIndex</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="446306">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="450228">bts</a> = <a href="#105383" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
      <span class="keyword">var</span> <a title="Int" id="450229">lo</a> = <span title="Int(0)" class="int">0</span>
      <span class="keyword">var</span> <a title="Int" id="450230">hi</a> = <a href="#450228" title="Types.this.BaseTypeSeq">bts</a>.<a href="BaseTypeSeqs.scala.html#197505" title="=&gt; Int">length</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#450229" title="Int">lo</a> <span title="(x: Int)Boolean">&lt;=</span> <a href="#450230" title="Int">hi</a><span class="delimiter">)</span> <a href="#450231" title="()Unit" class="delimiter">{</a>
        <span class="keyword">val</span> <a title="Int" id="450240">mid</a> = <span class="delimiter">(</span><a href="#450229" title="Int">lo</a> <span title="(x: Int)Int">+</span> <a href="#450230" title="Int">hi</a><span class="delimiter">)</span> <span title="(x: Int)Int">/</span> <span title="Int(2)" class="int">2</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="450241">btssym</a> = <a href="#450228" title="Types.this.BaseTypeSeq">bts</a>.<a href="BaseTypeSeqs.scala.html#197510" title="(i: Int)Types.this.Symbol">typeSymbol</a><span class="delimiter">(</span><a href="#450240" title="Int">mid</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#446306" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450241" title="Types.this.Symbol">btssym</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#450240" title="Int">mid</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#446306" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#107445" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#450241" title="Types.this.Symbol">btssym</a><span class="delimiter">)</span> <a href="#450230" title="Int">hi</a> = <a href="#450240" title="Int">mid</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450241" title="Types.this.Symbol">btssym</a> <a href="Symbols.scala.html#107445" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#446306" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#450229" title="Int">lo</a> = <a href="#450240" title="Int">mid</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>
        <span class="keyword">else</span> <a href="SymbolTable.scala.html#64780" title="()Nothing">abort</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      -<span title="Int(-1)" class="int">1</span>
    <span class="delimiter">}</span>

    <span class="comment">/** If this is a poly- or methodtype, a copy with cloned type / value parameters
     *  owned by `owner'. Identity for all other types.
     */</span>
    <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="105387">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="323758">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Make sure this type is correct as the info of given owner; clone it if not.
     */</span>
    <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="105388">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="445834">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="105389">objectPrefix</a> = <span title="java.lang.String(&quot;object &quot;)" class="string">&quot;object &quot;</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="105390">packagePrefix</a> = <span title="java.lang.String(&quot;package &quot;)" class="string">&quot;package &quot;</span>

    <span class="keyword">def</span> <a title="(str: String)java.lang.String" id="105391">trimPrefix</a><span class="delimiter">(</span><a title="String" id="411235">str</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#411235" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">str</a> <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">stripPrefix</span> <a href="#105389" title="=&gt; java.lang.String">objectPrefix</a> <span title="(prefix: String)java.lang.String">stripPrefix</span> <a href="#105390" title="=&gt; java.lang.String">packagePrefix</a>

    <span class="comment">/** The string representation of this type used as a prefix */</span>
    <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="105392">prefixString</a> = <a href="#105391" title="(str: String)java.lang.String">trimPrefix</a><span class="delimiter">(</span><a href="#67381" title="()String">toString</a><span class="delimiter">)</span> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;#&quot;)" class="string">&quot;#&quot;</span>

    <span class="comment">/** The string representation of this type, with singletypes explained */</span>
    <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="105393">toLongString</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="448882">str</a> = <a href="#67381" title="()String">toString</a>
      <span title="java.lang.String" class="keyword">if</span> <span class="delimiter">(</span><a href="#448882" title="String">str</a> <span title="(x$1: java.lang.String)Boolean">endsWith</span> <span title="java.lang.String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span><span class="delimiter">)</span> <a href="#448882" title="String">str</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; (with underlying type &quot;)" class="string">&quot; (with underlying type &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#105317" title="=&gt; Types.this.Type">widen</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
      <span class="keyword">else</span> <a href="#448882" title="String">str</a>
    <span class="delimiter">}</span>

    <span class="comment">/** A test whether a type contains any unification type variables */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="105394">isGround</a>: <span title="Boolean">Boolean</span> = <a href="#67381" title="Types.this.Type" class="keyword">this</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#448916" title="Boolean">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="450271">constr</a><span class="delimiter">)</span> =&gt; 
        <a href="#450271" title="Types.this.TypeConstraint">constr</a>.<a href="#449328" title="=&gt; Boolean">instValid</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#450271" title="Types.this.TypeConstraint">constr</a>.<a href="#449326" title="=&gt; Types.this.Type">inst</a>.<a href="#105394" title="=&gt; Boolean">isGround</a>
      <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="450275">pre</a>, <a title="Types.this.Symbol" id="450276">sym</a>, <a title="List[Types.this.Type]" id="450277">args</a><span class="delimiter">)</span> =&gt;
        <a href="#450276" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span> <span title="(x: Boolean)Boolean">||</span> <a href="#450275" title="Types.this.Type">pre</a>.<a href="#105394" title="=&gt; Boolean">isGround</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#450277" title="List[Types.this.Type]">args</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#450284" title="Types.this.Type">_</a>.<a href="#105394" title="=&gt; Boolean">isGround</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="450285">pre</a>, <a title="Types.this.Symbol" id="450286">sym</a><span class="delimiter">)</span> =&gt;
        <a href="#450286" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span> <span title="(x: Boolean)Boolean">||</span> <a href="#450285" title="Types.this.Type">pre</a>.<a href="#105394" title="=&gt; Boolean">isGround</a>
      <span class="keyword">case</span> <span title="Boolean(true)">ThisType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> | <a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a> | <a href="#450801" title="object Types.this.WildcardType">WildcardType</a> | <a href="#450850" title="object Types.this.NoType">NoType</a> | <a href="#450783" title="object Types.this.ErrorType">ErrorType</a> | ConstantType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
        <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt; 
        <a href="#450288" title="(tp: Types.this.Type)Types.this.Type">typeVarToOriginMap</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#67381" title="Types.this.Type" class="keyword">this</a>
    <span class="delimiter">}</span>

    <span class="comment">/** If this is a symbol loader type, load and assign a new type to
     *  `sym'.
     */</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="105395">load</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="440513">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol" id="105396">findDecl</a><span class="delimiter">(</span><a title="Types.this.Name" id="449783">name</a>: <a href="Names.scala.html#66914" title="Types.this.Name">Name</a>, <a title="Int" id="449784">excludedFlags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="450293">alts</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="450294">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a>
      <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="450295">e</a>: <a href="Scopes.scala.html#67678" title="Types.this.ScopeEntry">ScopeEntry</a> = <a href="#105346" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112955" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#449783" title="Types.this.Name">name</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#450295" title="Types.this.ScopeEntry">e</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#450296" title="()Unit" class="delimiter">{</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#450295" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#113135" title="=&gt; Types.this.Symbol">sym</a>.<span title="(mask: Long)Boolean">hasFlag</span><span class="delimiter">(</span><a href="#449784" title="=&gt; Long">excludedFlags</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450294" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#450294" title="Types.this.Symbol">sym</a> = <a href="#450295" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#113135" title="=&gt; Types.this.Symbol">sym</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450293" title="List[Types.this.Symbol]">alts</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#450293" title="List[Types.this.Symbol]">alts</a> = <span title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</span><span class="delimiter">(</span><a href="#450294" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <a href="#450293" title="List[Types.this.Symbol]">alts</a> = <a href="#450295" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#113135" title="=&gt; Types.this.Symbol">sym</a> <a href="#450319" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#450293" title="List[Types.this.Symbol]">alts</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <a href="#450295" title="Types.this.ScopeEntry">e</a> = <a href="#105346" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112956" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a><span class="delimiter">(</span><a href="#450295" title="Types.this.ScopeEntry">e</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#450293" title="List[Types.this.Symbol]">alts</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#450294" title="Types.this.Symbol">sym</a>
      <span class="keyword">else</span> <span class="delimiter">(</span><a href="#105385" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#107294" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.Symbol">newOverloaded</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#450293" title="List[Types.this.Symbol]">alts</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    
    <span class="comment">/**
     *  Find member(s) in this type. If several members matching criteria are found, they are
     *  returned in an OverloadedSymbol
     *  
     *  @param name           The member's name, where nme.ANYNAME means `unspecified' 
     *  @param excludedFlags  Returned members do not have these flags
     *  @param requiredFlags  Returned members do have these flags
     *  @param stableOnly     If set, return only members that are types or stable values
     */</span>
    <span class="comment">//TODO: use narrow only for modules? (correct? efficiency gain?)</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol" id="105397">findMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="449786">name</a>: <a href="Names.scala.html#66914" title="Types.this.Name">Name</a>, <a title="Long" id="449787">excludedFlags</a>: <span title="Long">Long</span>, <a title="Long" id="449788">requiredFlags</a>: <span title="Long">Long</span>, <a title="Boolean" id="449789">stableOnly</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="scala.collection.mutable.HashSet[Types.this.TypeVar]" id="450330">suspension</a>: mutable.<span title="scala.collection.mutable.HashSet[Types.this.TypeVar]">HashSet</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> = <span title="Null(null)" class="keyword">null</span>
      <span class="comment">// if this type contains type variables, put them to sleep for a while -- don't just wipe them out by</span>
      <span class="comment">// replacing them by the corresponding type parameter, as that messes up (e.g.) type variables in type refinements</span>
      <span class="comment">// without this, the matchesType call would lead to type variables on both sides</span>
      <span class="comment">// of a subtyping/equality judgement, which can lead to recursive types being constructed.</span>
      <span class="comment">// See (t0851) for a situation where this happens.</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#67381" title="Type.this.type" class="keyword">this</a>.<a href="#105394" title="=&gt; Boolean">isGround</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">// PP: The foreach below was formerly expressed as:</span>
        <span class="comment">//   for(tv @ TypeVar(_, _) &lt;- this) { suspension suspend tv }</span>
        <span class="comment">//</span>
        <span class="comment">// The tree checker failed this saying a TypeVar is required, but a (Type @unchecked) was found.</span>
        <span class="comment">// This is a consequence of using a pattern match and variable binding + ticket #1503, which</span>
        <span class="comment">// was addressed by weakening the type of bindings in pattern matches if they occur on the right.</span>
        <span class="comment">// So I'm not quite sure why this works at all, as the checker is right that it is mistyped.</span>
        <span class="comment">// For now I modified it as below, which achieves the same without error.</span>
        <span class="comment">//</span>
        <span class="comment">// make each type var in this type use its original type for comparisons instead of collecting constraints</span>
        <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.TypeVar]" id="450339">susp</a> = <span title="()scala.collection.mutable.HashSet[Types.this.TypeVar]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Types.this.TypeVar]">HashSet</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> <span class="comment">// use a local val so it remains unboxed</span>
        <a href="#67381" title="Type.this.type" class="keyword">this</a> <a href="#105369" title="(f: Types.this.Type =&gt; Unit)Unit">foreach</a> <a href="#450342" title="Unit" class="delimiter">{</a>
          <span class="keyword">case</span> <a title="Unit" id="450343">tv</a>: <a href="#67458" title="Types.this.TypeVar">TypeVar</a>  =&gt; <a href="#450343" title="Types.this.TypeVar">tv</a>.<a href="#448948" title="(x$1: Boolean)Unit">suspended</a> = <span title="Boolean(true)" class="keyword">true</span>; <a href="#450339" title="scala.collection.mutable.HashSet[Types.this.TypeVar]">susp</a> <span title="(elem: Types.this.TypeVar)susp.type">+=</span> <a href="#450343" title="Types.this.TypeVar">tv</a>
          <span class="keyword">case</span> <span title="Unit">_</span>            =&gt; 
        <span class="delimiter">}</span>
        <a href="#450330" title="scala.collection.mutable.HashSet[Types.this.TypeVar]">suspension</a> = <a href="#450339" title="scala.collection.mutable.HashSet[Types.this.TypeVar]">susp</a>
      <span class="delimiter">}</span>

      <a href="../util/Statistics.scala.html#67151" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67188" title="=&gt; scala.tools.nsc.util.Statistics.Counter">findMemberCount</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.tools.nsc.util.Statistics.LongPair" id="450331">start</a> = <a href="../util/Statistics.scala.html#67155" title="(tm: scala.tools.nsc.util.Statistics.Timer)scala.tools.nsc.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67194" title="=&gt; scala.tools.nsc.util.Statistics.Timer">findMemberNanos</a><span class="delimiter">)</span>

      <span class="comment">//Console.println(&quot;find member &quot; + name.decode + &quot; in &quot; + this + &quot;:&quot; + this.baseClasses)//DEBUG</span>
      <span class="keyword">var</span> <a title="Types.this.Scope" id="450332">members</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a> = <span title="Null(null)" class="keyword">null</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="450333">member</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a>
      <span class="keyword">var</span> <a title="Long" id="450334">excluded</a> = <a href="#449787" title="Long">excludedFlags</a> <span title="(x: Int)Long">|</span> <span title="Int(16)">DEFERRED</span>
      <span class="keyword">var</span> <a title="Boolean" id="450335">continue</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">var</span> <a title="Types.this.Type" id="450336">self</a>: <a href="#67381" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
      <span class="keyword">var</span> <a title="Types.this.Type" id="450337">membertpe</a>: <a href="#67381" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#450335" title="Boolean">continue</a><span class="delimiter">)</span> <a href="#450338" title="()Unit" class="delimiter">{</a>
        <a href="#450335" title="Boolean">continue</a> = <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="450360">bcs0</a> = <a href="#105385" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
        <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="450361">bcs</a> = <a href="#450360" title="List[Types.this.Symbol]">bcs0</a>
        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#450361" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#450362" title="()Unit" class="delimiter">{</a>
          <span class="keyword">val</span> <a title="Types.this.Scope" id="450364">decls</a> = <a href="#450361" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105346" title="=&gt; Types.this.Scope">decls</a>
          <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="450365">entry</a> =
            <span title="Types.this.ScopeEntry" class="keyword">if</span> <span class="delimiter">(</span><a href="#449786" title="Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#67713" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115274" title="=&gt; Types.this.nme.NameType">ANYNAME</a><span class="delimiter">)</span> <a href="#450364" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112921" title="=&gt; Types.this.ScopeEntry">elems</a> <span class="keyword">else</span> <a href="#450364" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112955" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#449786" title="Types.this.Name">name</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#450365" title="Types.this.ScopeEntry">entry</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#450366" title="()Unit" class="delimiter">{</a>
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="450374">sym</a> = <a href="#450365" title="Types.this.ScopeEntry">entry</a>.<a href="Scopes.scala.html#113135" title="=&gt; Types.this.Symbol">sym</a>
            <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#450374" title="Types.this.Symbol">sym</a> <span title="(mask: Long)Boolean">hasAllFlags</span> <a href="#449788" title="Long">requiredFlags</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Long" id="450375">excl</a> = <a href="#450374" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107414" title="(mask: Long)Long">getFlag</a><span class="delimiter">(</span><a href="#450334" title="Long">excluded</a><span class="delimiter">)</span>
              <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#450375" title="Long">excl</a> <span title="(x: Long)Boolean">==</span> <span title="Long(0L)" class="long">0L</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
                  <span class="delimiter">(</span><span class="comment">// omit PRIVATE LOCALS unless selector class is contained in class owning the def.</span>
                   <span class="delimiter">(</span><a href="#450361" title="List[Types.this.Symbol]">bcs</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450360" title="List[Types.this.Symbol]">bcs0</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
                   <span title="=&gt; Boolean">!</span><a href="#450374" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPrivateLocal</span> <span title="(x: Boolean)Boolean">||</span>
                   <span class="delimiter">(</span><a href="#450360" title="List[Types.this.Symbol]">bcs0</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#107406" title="(sym: Types.this.Symbol)Boolean">hasTransOwner</a><span class="delimiter">(</span><a href="#450361" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Types.this.Symbol">head</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#449786" title="Types.this.Name">name</a>.<a href="Names.scala.html#96576" title="=&gt; Boolean">isTypeName</a> <span title="(x: Boolean)Boolean">||</span> <a href="#449789" title="Boolean">stableOnly</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#450374" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107373" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <a href="../util/Statistics.scala.html#67156" title="(tm: scala.tools.nsc.util.Statistics.Timer, start: scala.tools.nsc.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67194" title="=&gt; scala.tools.nsc.util.Statistics.Timer">findMemberNanos</a>, <a href="#450331" title="scala.tools.nsc.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
                  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450330" title="scala.collection.mutable.HashSet[Types.this.TypeVar]">suspension</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#450330" title="scala.collection.mutable.HashSet[Types.this.TypeVar]">suspension</a> <span title="(f: Types.this.TypeVar =&gt; Unit)Unit">foreach</span> <span class="delimiter">(</span><a href="#450411" title="Types.this.TypeVar">_</a>.<a href="#448948" title="(x$1: Boolean)Unit">suspended</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
                  <span title="Nothing" class="keyword">return</span> <a href="#450374" title="Types.this.Symbol">sym</a>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#450333" title="Types.this.Symbol">member</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <a href="#450333" title="Types.this.Symbol">member</a> = <a href="#450374" title="Types.this.Symbol">sym</a>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#450332" title="Types.this.Scope">members</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450333" title="Types.this.Symbol">member</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#450374" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a> <span title="(x: Boolean)Boolean">||</span> 
                      <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#450333" title="Types.this.Symbol">member</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450374" title="Types.this.Symbol">sym</a> <span title="(x: Boolean)Boolean">||</span>
                        <a href="#450333" title="Types.this.Symbol">member</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#450374" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                        <span title="=&gt; Boolean">!</span><a href="#450374" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPrivate</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
                          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450336" title="Types.this.Type">self</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#450336" title="Types.this.Type">self</a> = <a href="#67381" title="Type.this.type" class="keyword">this</a>.<a href="#105320" title="=&gt; Types.this.Type">narrow</a>
                          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450337" title="Types.this.Type">membertpe</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#450337" title="Types.this.Type">membertpe</a> = <a href="#450336" title="Types.this.Type">self</a>.<a href="#105361" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#450333" title="Types.this.Symbol">member</a><span class="delimiter">)</span>
                          <span class="delimiter">(</span><a href="#450337" title="Types.this.Type">membertpe</a> <a href="#105381" title="(that: Types.this.Type)Boolean">matches</a> <a href="#450336" title="Types.this.Type">self</a>.<a href="#105361" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#450374" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                        <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#450332" title="Types.this.Scope">members</a> = <a href="Scopes.scala.html#112941" title="(decls: List[Types.this.Symbol])Types.this.Scope" class="keyword">new</a> <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a><span class="delimiter">(</span><span title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</span><span class="delimiter">(</span><a href="#450333" title="Types.this.Symbol">member</a>, <a href="#450374" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  <span class="delimiter">}</span>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                  <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="450449">prevEntry</a> = <a href="#450332" title="Types.this.Scope">members</a>.<a href="Scopes.scala.html#112955" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#450374" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
                  <span class="keyword">var</span> <a title="Types.this.Type" id="450450">symtpe</a>: <a href="#67381" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
                  <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#450449" title="Types.this.ScopeEntry">prevEntry</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                         <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#450449" title="Types.this.ScopeEntry">prevEntry</a>.<a href="Scopes.scala.html#113135" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450374" title="Types.this.Symbol">sym</a> <span title="(x: Boolean)Boolean">||</span>
                           <a href="#450449" title="Types.this.ScopeEntry">prevEntry</a>.<a href="Scopes.scala.html#113135" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#450374" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                           <span title="=&gt; Boolean">!</span><a href="#450374" title="Types.this.Symbol">sym</a>.<span title="(mask: Long)Boolean">hasFlag</span><span class="delimiter">(</span><span title="Long(4L)">PRIVATE</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
                             <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450336" title="Types.this.Type">self</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#450336" title="Types.this.Type">self</a> = <a href="#67381" title="Type.this.type" class="keyword">this</a>.<a href="#105320" title="=&gt; Types.this.Type">narrow</a>
                             <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450450" title="Types.this.Type">symtpe</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#450450" title="Types.this.Type">symtpe</a> = <a href="#450336" title="Types.this.Type">self</a>.<a href="#105361" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#450374" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
                             <a href="#450336" title="Types.this.Type">self</a>.<a href="#105361" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#450449" title="Types.this.ScopeEntry">prevEntry</a>.<a href="Scopes.scala.html#113135" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#105381" title="(that: Types.this.Type)Boolean">matches</a> <a href="#450450" title="Types.this.Type">symtpe</a>
                           <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#450449" title="Types.this.ScopeEntry">prevEntry</a> = <a href="#450332" title="Types.this.Scope">members</a> <a href="Scopes.scala.html#112956" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a> <a href="#450449" title="Types.this.ScopeEntry">prevEntry</a>
                  <span class="delimiter">}</span>
                  <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#450449" title="Types.this.ScopeEntry">prevEntry</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#450332" title="Types.this.Scope">members</a> <a href="Scopes.scala.html#112946" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#450374" title="Types.this.Symbol">sym</a>
                  <span class="delimiter">}</span>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450375" title="Long">excl</a> <span title="(x: Long)Boolean">==</span> <span title="Int(16)">DEFERRED</span>.<span title="=&gt; Long">toLong</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="#450335" title="Boolean">continue</a> = <span title="Boolean(true)" class="keyword">true</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <a href="#450365" title="Types.this.ScopeEntry">entry</a> = <span title="Types.this.ScopeEntry" class="keyword">if</span> <span class="delimiter">(</span><a href="#449786" title="Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#67713" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115274" title="=&gt; Types.this.nme.NameType">ANYNAME</a><span class="delimiter">)</span> <a href="#450365" title="Types.this.ScopeEntry">entry</a>.<a href="Scopes.scala.html#113143" title="=&gt; Types.this.ScopeEntry">next</a> <span class="keyword">else</span> <a href="#450364" title="Types.this.Scope">decls</a> <a href="Scopes.scala.html#112956" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a> <a href="#450365" title="Types.this.ScopeEntry">entry</a>
          <span class="delimiter">}</span> <span class="comment">// while (entry ne null)</span>
          <span class="comment">// excluded = excluded | LOCAL</span>
          <a href="#450361" title="List[Types.this.Symbol]">bcs</a> = <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#449786" title="Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#67713" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115276" title="=&gt; Types.this.nme.NameType">CONSTRUCTOR</a><span class="delimiter">)</span> <span title="object Nil">Nil</span> <span class="keyword">else</span> <a href="#450361" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>
        <span class="delimiter">}</span> <span class="comment">// while (!bcs.isEmpty)</span>
        <a href="#450334" title="Long">excluded</a> = <a href="#449787" title="Long">excludedFlags</a>
      <span class="delimiter">}</span> <span class="comment">// while (continue)</span>
      <a href="../util/Statistics.scala.html#67156" title="(tm: scala.tools.nsc.util.Statistics.Timer, start: scala.tools.nsc.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67194" title="=&gt; scala.tools.nsc.util.Statistics.Timer">findMemberNanos</a>, <a href="#450331" title="scala.tools.nsc.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450330" title="scala.collection.mutable.HashSet[Types.this.TypeVar]">suspension</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#450330" title="scala.collection.mutable.HashSet[Types.this.TypeVar]">suspension</a> <span title="(f: Types.this.TypeVar =&gt; Unit)Unit">foreach</span> <span class="delimiter">(</span><a href="#450517" title="Types.this.TypeVar">_</a>.<a href="#448948" title="(x$1: Boolean)Unit">suspended</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#450332" title="Types.this.Scope">members</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450333" title="Types.this.Symbol">member</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="../util/Statistics.scala.html#67151" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67190" title="=&gt; scala.tools.nsc.util.Statistics.Counter">noMemberCount</a><span class="delimiter">)</span>
        <a href="#450333" title="Types.this.Symbol">member</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="../util/Statistics.scala.html#67151" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67192" title="=&gt; scala.tools.nsc.util.Statistics.Counter">multMemberCount</a><span class="delimiter">)</span>
        <a href="#105385" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#107294" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.Symbol">newOverloaded</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="#450332" title="Types.this.Scope">members</a>.<a href="Scopes.scala.html#112957" title="=&gt; List[Types.this.Symbol]">toList</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** The existential skolems and existentially quantified variables which are free in this type */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="105398">existentialSkolems</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="450532">boundSyms</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="450533">skolems</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="450549">t</a> &lt;- <a href="#105369" title="(f: Types.this.Type =&gt; Unit)Unit" class="keyword">this</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#450549" title="Types.this.Type">t</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Unit">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="450550">quantified</a>, <a title="Types.this.Type" id="450551">qtpe</a><span class="delimiter">)</span> =&gt;
            <a href="#450532" title="List[Types.this.Symbol]">boundSyms</a> = <a href="#450532" title="List[Types.this.Symbol]">boundSyms</a> <a href="#450552" title="(prefix: List[Types.this.Symbol])List[Types.this.Symbol]">:::</a> <a href="#450550" title="List[Types.this.Symbol]">quantified</a>
          <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="450560">sym</a>, _<span class="delimiter">)</span> =&gt;
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#450560" title="Types.this.Symbol">sym</a> <span title="(mask: Long)Boolean">hasFlag</span> <span title="Long(34359738368L)">EXISTENTIAL</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#450532" title="List[Types.this.Symbol]">boundSyms</a> <span title="(elem: Any)Boolean">contains</span> <a href="#450560" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#450533" title="List[Types.this.Symbol]">skolems</a> <span title="(elem: Any)Boolean">contains</span> <a href="#450560" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#450533" title="List[Types.this.Symbol]">skolems</a> = <a href="#450560" title="Types.this.Symbol">sym</a> <a href="#450561" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#450533" title="List[Types.this.Symbol]">skolems</a>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#450533" title="List[Types.this.Symbol]">skolems</a>
    <span class="delimiter">}</span>

    <span class="comment">/** Return the annotations on this type. */</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.AnnotationInfo]" id="105399">annotations</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span> = <span title="object Nil">Nil</span>

    <span class="comment">/** Test for the presence of an annotation */</span>
    <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Boolean" id="105400">hasAnnotation</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="450565">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#105399" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a> <span title="(p: Types.this.AnnotationInfo =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <a href="#450580" title="Types.this.AnnotationInfo">_</a>.<a href="AnnotationInfos.scala.html#133313" title="=&gt; Types.this.Type">atp</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450565" title="Types.this.Symbol">clazz</a> <span class="delimiter">}</span>

    <span class="comment">/** Add an annotation to this type */</span>
    <span class="keyword">def</span> <a title="(annot: Types.this.AnnotationInfo)Types.this.Type" id="105401">withAnnotation</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="450586">annot</a>: <a href="AnnotationInfos.scala.html#67743" title="Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span> = <a href="#105402" title="(annots: List[Types.this.AnnotationInfo])Types.this.Type">withAnnotations</a><span class="delimiter">(</span><span title="(xs: Types.this.AnnotationInfo*)List[Types.this.AnnotationInfo]">List</span><span class="delimiter">(</span><a href="#450586" title="Types.this.AnnotationInfo">annot</a><span class="delimiter">)</span><span class="delimiter">)</span>
    
    <span class="comment">/** Add a number of annotations to this type */</span>
    <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="105402">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="449586">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
      <a href="#449586" title="List[Types.this.AnnotationInfo]">annots</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">Nil</span> =&gt; <a href="#67381" title="Types.this.Type" class="keyword">this</a>
        <span class="keyword">case</span> <span title="Types.this.AnnotatedType">_</span> =&gt; <a href="#148952" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#449586" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#67381" title="Types.this.Type" class="keyword">this</a>, <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      
    <span class="comment">/** Remove any annotations from this type */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105403">withoutAnnotations</a> = <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** Remove any annotations from this type and from any
     *  types embedded in this type. */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="105404">stripAnnotations</a> = <a href="#450610" title="(tp: Types.this.Type)Types.this.Type">StripAnnotationsMap</a><span class="delimiter">(</span><a href="#67381" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/** Set the self symbol of an annotated type, or do nothing
     *  otherwise.  */</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="105405">withSelfsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="450615">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#67381" title="Types.this.Type" class="keyword">this</a>

    <span class="comment">/** The selfsym of an annotated type, or NoSymbol of anything else */</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="105406">selfsym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a>

    <span class="comment">/** The kind of this type; used for debugging */</span>
    <span class="keyword">def</span> <a title="=&gt; String" id="105407">kind</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;unknown type of class &quot;)" class="string">&quot;unknown type of class &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#67381" title="()java.lang.Class[_]">getClass</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

<span class="comment">// Subclasses ------------------------------------------------------------</span>

  <span class="keyword">trait</span> <a title="trait UniqueType extends java.lang.Object with ScalaObject" id="67382">UniqueType</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Int" id="450625">hashCode</a>: <span title="Int">Int</span> = <a href="#67382" title="Types.this.UniqueType" class="keyword">super</a>.<span title="()Int">hashCode</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

 <span class="comment">/** A base class for types that defer some operations
   *  to their immediate supertype.
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SubType extends Types.this.Type with ScalaObject" id="67383">SubType</a> <a href="#67383" title="ScalaObject" class="keyword">extends</a> <a href="#67381" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148192">supertype</a>: <a href="#67381" title="Types.this.Type">Type</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148193">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#148192" title="=&gt; Types.this.Type">supertype</a>.<a href="#105322" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="148194">decls</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a> = <a href="#148192" title="=&gt; Types.this.Type">supertype</a>.<a href="#105346" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="148195">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="450634">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#148192" title="=&gt; Types.this.Type">supertype</a>.<a href="#105358" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#450634" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="148196">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#67693" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#148192" title="=&gt; Types.this.Type">supertype</a>.<a href="#105383" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148197">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#148192" title="=&gt; Types.this.Type">supertype</a>.<a href="#105384" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148198">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#148192" title="=&gt; Types.this.Type">supertype</a>.<a href="#105385" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148199">isNotNull</a> = <a href="#148192" title="=&gt; Types.this.Type">supertype</a>.<a href="#105307" title="=&gt; Boolean">isNotNull</a>
  <span class="delimiter">}</span>

  case <span class="keyword">class</span> <a title="class NotNullType extends Types.this.SubType with Types.this.RewrappingTypeProxy with ScalaObject with Product with Serializable" id="449751">NotNullType</a><a href="#449751" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="449765">underlying</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67383" title="Types.this.SubType">SubType</a> <span class="keyword">with</span> <a href="#67380" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="449756">supertype</a> = <a href="#449765" title="=&gt; Types.this.Type">underlying</a>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="449757">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="450651">newtp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#449751" title="(underlying: Types.this.Type)Types.this.NotNullType">NotNullType</a><span class="delimiter">(</span><a href="#450651" title="Types.this.Type">newtp</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="449758">isNotNull</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.NotNullType" id="449759">notNull</a> = <a href="#449751" title="Types.this.NotNullType" class="keyword">this</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="449760">deconst</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#449765" title="=&gt; Types.this.Type">underlying</a> <span class="comment">//todo: needed?</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="449761">safeToString</a>: <span title="String">String</span> = <a href="#449765" title="=&gt; Types.this.Type">underlying</a>.<span title="()String">toString</span> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; with NotNull&quot;)" class="string">&quot; with NotNull&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="449762">kind</a> = <span title="java.lang.String(&quot;NotNullType&quot;)" class="string">&quot;NotNullType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A base class for types that represent a single value
   *  (single-types and this-types).
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SingletonType extends Types.this.SubType with Types.this.SimpleTypeProxy with ScalaObject" id="67387">SingletonType</a> <a href="#67387" title="ScalaObject" class="keyword">extends</a> <a href="#67383" title="Types.this.SubType">SubType</a> <span class="keyword">with</span> <a href="#67379" title="Types.this.SimpleTypeProxy">SimpleTypeProxy</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148201">supertype</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148202">isTrivial</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148203">isStable</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148204">isVolatile</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105306" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148205">widen</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105317" title="=&gt; Types.this.Type">widen</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="148206">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#67693" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      <a href="../util/Statistics.scala.html#67151" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67182" title="=&gt; scala.tools.nsc.util.Statistics.Counter">singletonBaseTypeSeqCount</a><span class="delimiter">)</span>
      <a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105383" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#197513" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">prepend</a> <a href="#67387" title="Types.this.SingletonType" class="keyword">this</a>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148207">isHigherKinded</a> = <span title="Boolean(false)" class="keyword">false</span> <span class="comment">// singleton type classifies objects, thus must be kind *</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148208">safeToString</a>: <span title="String">String</span> = <a href="#105392" title="=&gt; java.lang.String">prefixString</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;type&quot;)" class="string">&quot;type&quot;</span>
<span class="comment">/*
    override def typeOfThis: Type = typeSymbol.typeOfThis
    override def bounds: TypeBounds = TypeBounds(this, this)
    override def prefix: Type = NoType
    override def typeArgs: List[Type] = List()
    override def typeParams: List[Symbol] = List()
*/</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An object representing an erroneous type */</span>
  case <span class="keyword">object</span> <a href="#450780" title="object Types.this.ErrorType" id="450783">ErrorType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67381" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="comment">// todo see whether we can do without</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148178">isError</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="148179">decls</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a> = <span title="Types.this.ErrorScope" class="keyword">new</span> <a href="Scopes.scala.html#67684" title="Types.this.ErrorScope">ErrorScope</a><span class="delimiter">(</span><a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol" id="148180">findMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="450736">name</a>: <a href="Names.scala.html#66914" title="Types.this.Name">Name</a>, <a title="Long" id="450737">excludedFlags</a>: <span title="Long">Long</span>, <a title="Long" id="450738">requiredFlags</a>: <span title="Long">Long</span>, <a title="Boolean" id="450739">stableOnly</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="450741">sym</a> = <a href="#148179" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#112953" title="(name: Types.this.Name)Types.this.Symbol">lookup</a> <a href="#450736" title="Types.this.Name">name</a>
      <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#450741" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#450741" title="Types.this.Symbol">sym</a> = <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a>.<a href="Symbols.scala.html#107317" title="(name: Types.this.Name)Types.this.Symbol">newErrorSymbol</a><span class="delimiter">(</span><a href="#450736" title="Types.this.Name">name</a><span class="delimiter">)</span>
        <a href="#148179" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#112946" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#450741" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span>
      <a href="#450741" title="Types.this.Symbol">sym</a>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="148181">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="450767">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="keyword">this</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148182">safeToString</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;&lt;error&gt;&quot;)" class="string">&quot;&lt;error&gt;&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148183">narrow</a>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="keyword">this</span>
    <span class="comment">// override def isNullable: Boolean = true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148184">kind</a> = <span title="java.lang.String(&quot;ErrorType&quot;)" class="string">&quot;ErrorType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An object representing an unknown type, used during type inference.
   *  If you see WildcardType outside of inference it is almost certainly a bug.
   */</span>
  case <span class="keyword">object</span> <a href="#450798" title="object Types.this.WildcardType" id="450801">WildcardType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67381" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148186">isWildcard</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148187">safeToString</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;?&quot;)" class="string">&quot;?&quot;</span>
    <span class="comment">// override def isNullable: Boolean = true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148188">kind</a> = <span title="java.lang.String(&quot;WildcardType&quot;)" class="string">&quot;WildcardType&quot;</span>
  <span class="delimiter">}</span>

  case <span class="keyword">class</span> <a title="class BoundedWildcardType extends Types.this.Type with ScalaObject with Product with Serializable" id="258421">BoundedWildcardType</a><a href="#258421" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.TypeBounds" id="456700">bounds</a>: <a href="#148453" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67381" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="258426">isWildcard</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="258427">safeToString</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;?&quot;)" class="string">&quot;?&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#456700" title="=&gt; Types.this.TypeBounds">bounds</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="258428">kind</a> = <span title="java.lang.String(&quot;BoundedWildcardType&quot;)" class="string">&quot;BoundedWildcardType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An object representing a non-existing type */</span>
  case <span class="keyword">object</span> <a href="#450847" title="object Types.this.NoType" id="450850">NoType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67381" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="132541">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="132542">safeToString</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;&lt;notype&gt;&quot;)" class="string">&quot;&lt;notype&gt;&quot;</span>
    <span class="comment">// override def isNullable: Boolean = true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="132543">kind</a> = <span title="java.lang.String(&quot;NoType&quot;)" class="string">&quot;NoType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An object representing a non-existing prefix */</span>
  case <span class="keyword">object</span> <a href="#450869" title="object Types.this.NoPrefix" id="450872">NoPrefix</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67381" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133229">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133230">isStable</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="133231">prefixString</a> = <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="133232">safeToString</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;&lt;noprefix&gt;&quot;)" class="string">&quot;&lt;noprefix&gt;&quot;</span>
    <span class="comment">// override def isNullable: Boolean = true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="133233">kind</a> = <span title="java.lang.String(&quot;NoPrefixType&quot;)" class="string">&quot;NoPrefixType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class for this-types of the form &lt;sym&gt;.this.type 
   */</span>
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a title="class ThisType extends Types.this.SingletonType with ScalaObject with Product with Serializable" id="148255">ThisType</a><a href="#148255" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="148263">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67387" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="comment">//assert(sym.isClass &amp;&amp; !sym.isModuleClass || sym.isRoot, sym)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148213">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#148263" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148214">isNotNull</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148215">typeSymbol</a> = <a href="#148263" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148216">underlying</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#148263" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107458" title="=&gt; Types.this.Type">typeOfThis</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148217">isVolatile</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148218">isHigherKinded</a> = <a href="#148263" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isRefinementClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#148216" title="=&gt; Types.this.Type">underlying</a>.<a href="#105304" title="=&gt; Boolean">isHigherKinded</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148219">prefixString</a> =
      <span title="java.lang.String" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#148263" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107514" title="=&gt; java.lang.String">nameString</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;.this.&quot;)" class="string">&quot;.this.&quot;</span>
      <span class="keyword">else</span> <span title="java.lang.String" class="keyword">if</span> <span class="delimiter">(</span><a href="#148263" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107348" title="=&gt; Boolean">isAnonOrRefinementClass</a><span class="delimiter">)</span> <span title="java.lang.String(&quot;this.&quot;)" class="string">&quot;this.&quot;</span>
      <span class="keyword">else</span> <span title="java.lang.String" class="keyword">if</span> <span class="delimiter">(</span><a href="#148263" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107359" title="=&gt; Boolean">printWithoutPrefix</a><span class="delimiter">)</span> <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <span title="java.lang.String" class="keyword">if</span> <span class="delimiter">(</span><a href="#148263" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isModuleClass</span><span class="delimiter">)</span> <a href="#148263" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; String">fullName</span> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      <span class="keyword">else</span> <a href="#148263" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107514" title="=&gt; java.lang.String">nameString</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;.this.&quot;)" class="string">&quot;.this.&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148220">safeToString</a>: <span title="String">String</span> =
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#148263" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isRoot</span><span class="delimiter">)</span> <span title="java.lang.String(&quot;&lt;root&gt;&quot;)" class="string">&quot;&lt;root&gt;&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#148263" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isEmptyPackageClass</span><span class="delimiter">)</span> <span title="java.lang.String(&quot;&lt;empty&gt;&quot;)" class="string">&quot;&lt;empty&gt;&quot;</span>
      <span class="keyword">else</span> <a href="#148255" title="Types.this.ThisType" class="keyword">super</a>.<a href="#148208" title="=&gt; String">safeToString</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148221">narrow</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#148255" title="Types.this.ThisType" class="keyword">this</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148222">kind</a> = <span title="java.lang.String(&quot;ThisType&quot;)" class="string">&quot;ThisType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueThisType extends Types.this.ThisType with Types.this.UniqueType with ScalaObject" id="67402">UniqueThisType</a><a href="#67402" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="450929">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#148255" title="Types.this.ThisType">ThisType</a><span class="delimiter">(</span><a href="#450929" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#67382" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object Types.this.ThisType" id="67400">ThisType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24048" title="Types.this.ThisTypeExtractor">ThisTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="148190">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="159827">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#67495" title="(tp: Types.this.UniqueThisType)Types.this.UniqueThisType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueThisType" class="keyword">new</span> <a href="#67402" title="Types.this.UniqueThisType">UniqueThisType</a><span class="delimiter">(</span><a href="#159827" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#159827" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isImplClass</span><span class="delimiter">)</span> <a href="#159827" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107458" title="=&gt; Types.this.Type">typeOfThis</a>
      <span class="keyword">else</span> <a href="#159827" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class for singleton types of the form &lt;prefix&gt;.&lt;sym.name&gt;.type.
   *  Cannot be created directly; one should always use
   *  `singleType' for creation.
   */</span>
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a title="class SingleType extends Types.this.SingletonType with ScalaObject with Product with Serializable" id="148293">SingleType</a><a href="#148293" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="148307">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="148308">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67387" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="148275">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#148307" title="=&gt; Types.this.Type">pre</a>.<a href="#105303" title="=&gt; Boolean">isTrivial</a>
    <span class="comment">// override def isNullable = underlying.isNullable</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148277">isNotNull</a> = <a href="#148284" title="=&gt; Types.this.Type">underlying</a>.<a href="#105307" title="=&gt; Boolean">isNotNull</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="148279">underlyingCache</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#450850" title="object Types.this.NoType">NoType</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="148282">underlyingPeriod</a> = <span title="Int(0)">NoPeriod</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148284">underlying</a>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="450947">period</a> = <a href="#148282" title="=&gt; Int">underlyingPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450947" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#64801" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#148282" title="(x$1: Int)Unit">underlyingPeriod</a> = <a href="SymbolTable.scala.html#64801" title="=&gt; Types.this.Period">currentPeriod</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64810" title="(period: Types.this.Period)Boolean">isValid</a><span class="delimiter">(</span><a href="#450947" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#148279" title="(x$1: Types.this.Type)Unit">underlyingCache</a> = <a href="#148307" title="=&gt; Types.this.Type">pre</a>.<a href="#105361" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#148308" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#105327" title="=&gt; Types.this.Type">resultType</a>;
          <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#148279" title="=&gt; Types.this.Type">underlyingCache</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#148293" title="Types.this.SingleType" class="keyword">this</a>, <a href="#148293" title="Types.this.SingleType" class="keyword">this</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#148279" title="=&gt; Types.this.Type">underlyingCache</a>
    <span class="delimiter">}</span>

    <span class="comment">// more precise conceptually, but causes cyclic errors:    (paramss exists (_ contains sym))</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148285">isImmediatelyDependent</a> = <span class="delimiter">(</span><a href="#148308" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#148308" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>.<span title="=&gt; Boolean">isMethod</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#148308" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107329" title="=&gt; Boolean">isValueParameter</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148286">isVolatile</a> : <span title="Boolean">Boolean</span> = <a href="#148284" title="=&gt; Types.this.Type">underlying</a>.<a href="#105306" title="=&gt; Boolean">isVolatile</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#148308" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107373" title="=&gt; Boolean">isStable</a>
<span class="comment">/*
    override def narrow: Type = {
      if (phase.erasedTypes) this
      else {
        val thissym = refinedType(List(this), sym.owner, EmptyScope).typeSymbol
        if (sym.owner != NoSymbol) {
          //Console.println(&quot;narrowing module &quot; + sym + thissym.owner);
          thissym.typeOfThis = this
        }
        thissym.thisType
      }
    }
*/</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148287">narrow</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#148293" title="Types.this.SingleType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148288">termSymbol</a> = <a href="#148308" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148289">prefix</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#148307" title="=&gt; Types.this.Type">pre</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148290">prefixString</a>: <span title="String">String</span> = 
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#148308" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isEmptyPackage</span> <span title="(x: Boolean)Boolean">||</span> <a href="#148308" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107370" title="=&gt; Boolean">isInterpreterWrapper</a> <span title="(x: Boolean)Boolean">||</span> <a href="#148308" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107354" title="=&gt; Boolean">isPredefModule</a> <span title="(x: Boolean)Boolean">||</span> <a href="#148308" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107355" title="=&gt; Boolean">isScalaPackage</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <a href="#148307" title="=&gt; Types.this.Type">pre</a>.<a href="#105392" title="=&gt; java.lang.String">prefixString</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="#148308" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107514" title="=&gt; java.lang.String">nameString</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148291">kind</a> = <span title="java.lang.String(&quot;SingleType&quot;)" class="string">&quot;SingleType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueSingleType extends Types.this.SingleType with Types.this.UniqueType with ScalaObject" id="67406">UniqueSingleType</a><a href="#67406" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="451006">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="451007">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#148293" title="Types.this.SingleType">SingleType</a><span class="delimiter">(</span><a href="#451006" title="Types.this.Type">pre</a>, <a href="#451007" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#67382" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object Types.this.SingleType" id="67404">SingleType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24048" title="Types.this.SingleTypeExtractor">SingleTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="148267">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="451009">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="451010">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#67495" title="(tp: Types.this.UniqueSingleType)Types.this.UniqueSingleType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueSingleType" class="keyword">new</span> <a href="#67406" title="Types.this.UniqueSingleType">UniqueSingleType</a><span class="delimiter">(</span><a href="#451009" title="Types.this.Type">pre</a>, <a href="#451010" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a title="class SuperType extends Types.this.SingletonType with ScalaObject with Product with Serializable" id="149216">SuperType</a><a href="#149216" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="149230">thistpe</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="149231">supertpe</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67387" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="149206">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#149230" title="=&gt; Types.this.Type">thistpe</a>.<a href="#105303" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#149231" title="=&gt; Types.this.Type">supertpe</a>.<a href="#105303" title="=&gt; Boolean">isTrivial</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="149208">isNotNull</a> = <span title="Boolean(true)" class="keyword">true</span>;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="149209">typeSymbol</a> = <a href="#149230" title="=&gt; Types.this.Type">thistpe</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149210">underlying</a> = <a href="#149231" title="=&gt; Types.this.Type">supertpe</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149211">prefix</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#149231" title="=&gt; Types.this.Type">supertpe</a>.<a href="#105323" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="149212">prefixString</a> = <a href="#149230" title="=&gt; Types.this.Type">thistpe</a>.<a href="#105392" title="=&gt; java.lang.String">prefixString</a>.<span title="(x$1: java.lang.String, x$2: java.lang.String)java.lang.String">replaceAll</span><span class="delimiter">(</span><span title="java.lang.String(&quot;this\\.$&quot;)" class="string">&quot;&quot;&quot;this\.$&quot;&quot;&quot;</span>, <span title="java.lang.String(&quot;super.&quot;)" class="string">&quot;super.&quot;</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149213">narrow</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#149230" title="=&gt; Types.this.Type">thistpe</a>.<a href="#105320" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="149214">kind</a> = <span title="java.lang.String(&quot;SuperType&quot;)" class="string">&quot;SuperType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueSuperType extends Types.this.SuperType with Types.this.UniqueType with ScalaObject" id="67410">UniqueSuperType</a><a href="#67410" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="451068">thistp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="451069">supertp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#149216" title="Types.this.SuperType">SuperType</a><span class="delimiter">(</span><a href="#451068" title="Types.this.Type">thistp</a>, <a href="#451069" title="Types.this.Type">supertp</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#67382" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object Types.this.SuperType" id="67408">SuperType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24048" title="Types.this.SuperTypeExtractor">SuperTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(thistp: Types.this.Type, supertp: Types.this.Type)Types.this.Type" id="149198">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="451071">thistp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="451072">supertp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#451072" title="Types.this.Type">supertp</a>
      <span class="keyword">else</span> <a href="#67495" title="(tp: Types.this.UniqueSuperType)Types.this.UniqueSuperType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueSuperType" class="keyword">new</span> <a href="#67410" title="Types.this.UniqueSuperType">UniqueSuperType</a><span class="delimiter">(</span><a href="#451071" title="Types.this.Type">thistp</a>, <a href="#451072" title="Types.this.Type">supertp</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class for the bounds of abstract types and type parameters
   */</span>
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a title="class TypeBounds extends Types.this.SubType with ScalaObject with Product with Serializable" id="148453">TypeBounds</a><a href="#148453" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="148467">lo</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="148468">hi</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67383" title="Types.this.SubType">SubType</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148445">supertype</a> = <a href="#148468" title="=&gt; Types.this.Type">hi</a>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="148446">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#148467" title="=&gt; Types.this.Type">lo</a>.<a href="#105303" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#148468" title="=&gt; Types.this.Type">hi</a>.<a href="#105303" title="=&gt; Boolean">isTrivial</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="148448">bounds</a>: <a href="#148453" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#148453" title="Types.this.TypeBounds" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="148449">containsType</a><span class="delimiter">(</span><a title="Types.this.Type" id="258451">that</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#258451" title="Types.this.Type">that</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">TypeBounds</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#258451" title="Types.this.Type">that</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#148453" title="Types.this.TypeBounds" class="keyword">this</a> 
      <span class="keyword">case</span> <span title="Boolean">_</span>                =&gt; <a href="#148467" title="=&gt; Types.this.Type">lo</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#258451" title="Types.this.Type">that</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#258451" title="Types.this.Type">that</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#148468" title="=&gt; Types.this.Type">hi</a>
    <span class="delimiter">}</span>
    <span class="comment">// override def isNullable: Boolean = NullClass.tpe &lt;:&lt; lo;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148450">safeToString</a> = <span title="java.lang.String(&quot;&gt;: &quot;)" class="string">&quot;&gt;: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#148467" title="=&gt; Types.this.Type">lo</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &lt;: &quot;)" class="string">&quot; &lt;: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#148468" title="=&gt; Types.this.Type">hi</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148451">kind</a> = <span title="java.lang.String(&quot;TypeBoundsType&quot;)" class="string">&quot;TypeBoundsType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueTypeBounds extends Types.this.TypeBounds with Types.this.UniqueType with ScalaObject" id="67414">UniqueTypeBounds</a><a href="#67414" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="451122">lo</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="451123">hi</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#148453" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#451122" title="Types.this.Type">lo</a>, <a href="#451123" title="Types.this.Type">hi</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#67382" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object Types.this.TypeBounds" id="67412">TypeBounds</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24048" title="Types.this.TypeBoundsExtractor">TypeBoundsExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="148434">empty</a>: <a href="#148453" title="Types.this.TypeBounds">TypeBounds</a>           = <a href="#148437" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>, <a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(hi: Types.this.Type)Types.this.TypeBounds" id="148435">upper</a><span class="delimiter">(</span><a title="Types.this.Type" id="446201">hi</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#148453" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#148437" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>, <a href="#446201" title="Types.this.Type">hi</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(lo: Types.this.Type)Types.this.TypeBounds" id="148436">lower</a><span class="delimiter">(</span><a title="Types.this.Type" id="451127">lo</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#148453" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#148437" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="#451127" title="Types.this.Type">lo</a>, <a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds" id="148437">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="236348">lo</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="236349">hi</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#148453" title="Types.this.TypeBounds">TypeBounds</a> = <span class="delimiter">{</span>
      <a href="#67495" title="(tp: Types.this.UniqueTypeBounds)Types.this.UniqueTypeBounds">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueTypeBounds" class="keyword">new</span> <a href="#67414" title="Types.this.UniqueTypeBounds">UniqueTypeBounds</a><span class="delimiter">(</span><a href="#236348" title="Types.this.Type">lo</a>, <a href="#236349" title="Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.TypeBounds" class="delimiter">[</span><a href="#148453" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">]</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A common base class for intersection types and class types 
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class CompoundType extends Types.this.Type with ScalaObject" id="67415">CompoundType</a> <a href="#67415" title="ScalaObject" class="keyword">extends</a> <a href="#67381" title="Types.this.Type">Type</a> <span class="delimiter">{</span>

    <span class="keyword">var</span> <a title="Types.this.BaseTypeSeq" id="148515">baseTypeSeqCache</a>: <a href="BaseTypeSeqs.scala.html#67693" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="148518">baseTypeSeqPeriod</a> = <span title="Int(0)">NoPeriod</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="148521">baseClassesCache</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="148524">baseClassesPeriod</a> = <span title="Int(0)">NoPeriod</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="148526">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#67693" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="451139">period</a> = <a href="#148518" title="=&gt; Int">baseTypeSeqPeriod</a>;
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#451139" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#64801" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// no caching in IDE</span>
        <a href="#148518" title="(x$1: Int)Unit">baseTypeSeqPeriod</a> = <a href="SymbolTable.scala.html#64801" title="=&gt; Types.this.Period">currentPeriod</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64811" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#451139" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#105322" title="=&gt; List[Types.this.Type]">parents</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#451157" title="Types.this.Type">_</a>.<a href="#105371" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#451159" title="Types.this.Type">_</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#67458" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="comment">// rename type vars to fresh type params, take base type sequence of</span>
            <span class="comment">// resulting type, and rename back all the entries in that sequence</span>
            <span class="keyword">var</span> <a title="scala.collection.immutable.Set[Types.this.TypeVar]" id="451160">tvs</a> = <span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.TypeVar*)scala.collection.immutable.Set[Types.this.TypeVar]" class="delimiter">[</span><a href="#67458" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
            <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="451188">p</a> &lt;- <a href="#105322" title="(f: Types.this.Type =&gt; Unit)Unit">parents</a><span class="delimiter">)</span>
              <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="451190">t</a> &lt;- <a href="#105369" title="(f: Types.this.Type =&gt; Unit)Unit">p</a><span class="delimiter">)</span> <a href="#451190" title="Types.this.Type">t</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <a title="Unit" id="451191">tv</a>: <a href="#67458" title="Types.this.TypeVar">TypeVar</a> =&gt; <a href="#451160" title="scala.collection.immutable.Set[Types.this.TypeVar]">tvs</a> <span title="(elem: Types.this.TypeVar)scala.collection.immutable.Set[Types.this.TypeVar]">+=</span> <a href="#451191" title="Types.this.TypeVar">tv</a>
                <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
              <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="Map[Types.this.Type,Types.this.Symbol]" id="451161">varToParamMap</a>: <span title="Map[Types.this.Type,Types.this.Symbol]">Map</span><span class="delimiter">[</span>Type, Symbol<span class="delimiter">]</span> = <a href="#451160" title="scala.collection.immutable.Set[Types.this.TypeVar]">tvs</a> <span title="(f: Types.this.TypeVar =&gt; (Types.this.TypeVar, Types.this.Symbol))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[Types.this.TypeVar],(Types.this.TypeVar, Types.this.Symbol),scala.collection.immutable.Set[(Types.this.TypeVar, Types.this.Symbol)]])scala.collection.immutable.Set[(Types.this.TypeVar, Types.this.Symbol)]">map</span> <span class="delimiter">(</span><a title="Types.this.TypeVar" id="451235">tv</a> =&gt; <a href="#451235" title="(x: Types.this.TypeVar)ArrowAssoc[Types.this.TypeVar]">tv</a> <span title="(y: Types.this.Symbol)(Types.this.TypeVar, Types.this.Symbol)">-&gt;</span> <a href="#451235" title="Types.this.TypeVar">tv</a>.<a href="#454754" title="=&gt; Types.this.Type">origin</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107453" title="=&gt; Types.this.Symbol">cloneSymbol</a><span class="delimiter">)</span> <span title="(implicit ev: &lt;:&lt;[(Types.this.TypeVar, Types.this.Symbol),(Types.this.Type, Types.this.Symbol)])scala.collection.immutable.Map[Types.this.Type,Types.this.Symbol]">toMap</span> 
            <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]" id="451162">paramToVarMap</a> = <a href="#451161" title="Map[Types.this.Type,Types.this.Symbol]">varToParamMap</a> <span title="(f: (Types.this.Type, Types.this.Symbol) =&gt; (Types.this.Symbol, Types.this.Type))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[Types.this.Type,Types.this.Symbol],(Types.this.Symbol, Types.this.Type),scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]])scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#451321" title="(Types.this.Type, Types.this.Symbol)">_</a>.<span title="=&gt; (Types.this.Symbol, Types.this.Type)">swap</span><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.TypeMap" id="451163">varToParam</a> = <a href="#451360" title="Types.this.TypeMap" class="keyword">new</a> <a href="#67503" title="anonymous class $anon extends Types.this.TypeMap" id="451360">TypeMap</a> <span class="delimiter">{</span>
              <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="451362">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="451363">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#451161" title="Map[Types.this.Type,Types.this.Symbol]">varToParamMap</a> <span title="(key: Types.this.Type)Option[Types.this.Symbol]">get</span> <a href="#451363" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Types.this.Type">Some</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="451368">sym</a><span class="delimiter">)</span> =&gt; <a href="#451368" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
                <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#451363" title="Types.this.Type">tp</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="Types.this.TypeMap" id="451164">paramToVar</a> = <a href="#451387" title="Types.this.TypeMap" class="keyword">new</a> <a href="#67503" title="anonymous class $anon extends Types.this.TypeMap" id="451387">TypeMap</a> <span class="delimiter">{</span>
              <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="451389">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="451390">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#451390" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="451392">tsym</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#451162" title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]">paramToVarMap</a>.<span title="(key: Types.this.Symbol)Boolean">isDefinedAt</span><span class="delimiter">(</span><a href="#451392" title="Types.this.Symbol">tsym</a><span class="delimiter">)</span> =&gt; <a href="#451162" title="(key: Types.this.Symbol)Types.this.Type">paramToVarMap</a><span class="delimiter">(</span><a href="#451392" title="Types.this.Symbol">tsym</a><span class="delimiter">)</span>
                <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#451390" title="Types.this.Type">tp</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="451165">bts</a> = <a href="#67471" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#67415" title="CompoundType.this.type" class="keyword">this</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.RefinedType" class="delimiter">[</span><a href="#148512" title="Types.this.RefinedType">RefinedType</a><span class="delimiter">]</span>, <a href="#105322" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#451163" title="Types.this.TypeMap">varToParam</a>, <a href="#451163" title="Types.this.TypeMap">varToParam</a> <a href="#133282" title="(scope: Types.this.Scope)Types.this.Scope">mapOver</a> <a href="#105346" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span>.<a href="#105383" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
            <a href="#148515" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="#451165" title="Types.this.BaseTypeSeq">bts</a> <a href="BaseTypeSeqs.scala.html#197516" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">lateMap</a> <a href="#451164" title="Types.this.TypeMap">paramToVar</a>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <a href="../util/Statistics.scala.html#67151" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67184" title="=&gt; scala.tools.nsc.util.Statistics.Counter">compoundBaseTypeSeqCount</a><span class="delimiter">)</span>
            <a href="#148515" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="BaseTypeSeqs.scala.html#67694" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a>
            <a href="#148515" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <span title="Types.this.BaseTypeSeq" class="keyword">if</span> <span class="delimiter">(</span><a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isRefinementClass</span><span class="delimiter">)</span>
              <a href="#148529" title="(op1: =&gt; Types.this.BaseTypeSeq)(op2: Types.this.Type =&gt; Types.this.BaseTypeSeq)Types.this.BaseTypeSeq">memo</a><span class="delimiter">(</span><a href="BaseTypeSeqs.scala.html#67697" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">compoundBaseTypeSeq</a><span class="delimiter">(</span><a href="#67415" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#451583" title="Types.this.Type">_</a>.<a href="#105383" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#197514" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">updateHead</a> <a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
            <span class="keyword">else</span>
              <a href="BaseTypeSeqs.scala.html#67697" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">compoundBaseTypeSeq</a><span class="delimiter">(</span><a href="#67415" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span>
            <span class="comment">// [Martin] suppressing memo-ization solves the problem with &quot;same type after erasure&quot; errors</span>
            <span class="comment">// when compiling with </span>
            <span class="comment">// scalac scala.collection.IterableViewLike.scala scala.collection.IterableLike.scala</span>
            <span class="comment">// I have not yet figured out precisely why this is the case.</span>
            <span class="comment">// My current assumption is that taking memos forces baseTypeSeqs to be computed</span>
            <span class="comment">// at stale types (i.e. the underlying typeSymbol has already another type).</span>
            <span class="comment">// I do not yet see precisely why this would cause a problem, but it looks</span>
            <span class="comment">// fishy in any case.</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="comment">//Console.println(&quot;baseTypeSeq(&quot; + typeSymbol + &quot;) = &quot; + baseTypeSeqCache.toList);//DEBUG</span>
      <span class="delimiter">}</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#148515" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="BaseTypeSeqs.scala.html#67694" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">throw</span> <a href="#313894" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#67658" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="java.lang.String(&quot;illegal cyclic inheritance involving &quot;)" class="string">&quot;illegal cyclic inheritance involving &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
      <a href="#148515" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148527">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#148526" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#197518" title="=&gt; Int">maxDepth</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148528">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="451592">computeBaseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
        <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#105322" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</span><span class="delimiter">(</span><a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="comment">//Console.println(&quot;computing base classes of &quot; + typeSymbol + &quot; at phase &quot; + phase);//DEBUG</span>
          <span class="comment">// optimized, since this seems to be performance critical</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="451602">superclazz</a> = <a href="#105322" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Types.this.Type">head</span>
          <span class="keyword">var</span> <a title="List[Types.this.Type]" id="451603">mixins</a> = <a href="#105322" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; List[Types.this.Type]">tail</span>
          <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="451604">sbcs</a> = <a href="#451602" title="Types.this.Type">superclazz</a>.<a href="#105385" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
          <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="451605">bcs</a> = <a href="#451604" title="List[Types.this.Symbol]">sbcs</a>
          <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Boolean" id="451606">isNew</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="451610">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span>
            <a href="#451602" title="Types.this.Type">superclazz</a>.<a href="#105386" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#451610" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <span class="delimiter">{</span> <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="451615">p</a> = <a href="#451605" title="List[Types.this.Symbol]">bcs</a>;
              <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#451615" title="List[Types.this.Symbol]">p</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#451604" title="List[Types.this.Symbol]">sbcs</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#451615" title="List[Types.this.Symbol]">p</a>.<span title="=&gt; Types.this.Symbol">head</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#451610" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#451615" title="List[Types.this.Symbol]">p</a> = <a href="#451615" title="List[Types.this.Symbol]">p</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>;
              <a href="#451615" title="List[Types.this.Symbol]">p</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#451604" title="List[Types.this.Symbol]">sbcs</a>
            <span class="delimiter">}</span>
          <span class="delimiter">)</span>;
          <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#451603" title="List[Types.this.Type]">mixins</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#451607" title="()Unit" class="delimiter">{</a>
            <span class="keyword">def</span> <a title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]" id="451625">addMixinBaseClasses</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="451626">mbcs</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
              <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#451626" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#451605" title="List[Types.this.Symbol]">bcs</a>
              <span class="keyword">else</span> <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#451606" title="(clazz: Types.this.Symbol)Boolean">isNew</a><span class="delimiter">(</span><a href="#451626" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; Types.this.Symbol">head</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#451626" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; Types.this.Symbol">head</span> <a href="#451627" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#451625" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#451626" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <a href="#451625" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#451626" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span><span class="delimiter">)</span>;
            <a href="#451605" title="List[Types.this.Symbol]">bcs</a> = <a href="#451625" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#451603" title="List[Types.this.Type]">mixins</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#105385" title="=&gt; List[Types.this.Symbol]">baseClasses</a><span class="delimiter">)</span>
            <a href="#451603" title="List[Types.this.Type]">mixins</a> = <a href="#451603" title="List[Types.this.Type]">mixins</a>.<span title="=&gt; List[Types.this.Type]">tail</span>
          <span class="delimiter">}</span>
          <a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="#451633" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#451605" title="List[Types.this.Symbol]">bcs</a>
         <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="Int" id="451593">period</a> = <a href="#148524" title="=&gt; Int">baseClassesPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#451593" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#64801" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#148524" title="(x$1: Int)Unit">baseClassesPeriod</a> = <a href="SymbolTable.scala.html#64801" title="=&gt; Types.this.Period">currentPeriod</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64811" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#451593" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#148521" title="(x$1: List[Types.this.Symbol])Unit">baseClassesCache</a> = <span title="Null(null)" class="keyword">null</span>
          <a href="#148521" title="(x$1: List[Types.this.Symbol])Unit">baseClassesCache</a> = <a href="#148529" title="(op1: =&gt; List[Types.this.Symbol])(op2: Types.this.Type =&gt; List[Types.this.Symbol])List[Types.this.Symbol]">memo</a><span class="delimiter">(</span><a href="#451592" title="=&gt; List[Types.this.Symbol]">computeBaseClasses</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="#451650" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#451649" title="Types.this.Type">_</a>.<a href="#105385" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#148521" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">throw</span> <a href="#313894" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#67658" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="java.lang.String(&quot;illegal cyclic reference involving &quot;)" class="string">&quot;illegal cyclic reference involving &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
      <a href="#148521" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a>
    <span class="delimiter">}</span>

    <span class="comment">/** The slightly less idiomatic use of Options is due to 
     *  performance considerations. A version using for comprehensions
     *  might be too slow (this is deemed a hotspot of the type checker).
     *  
     *  See with Martin before changing this method.
     */</span>
    <span class="keyword">def</span> <a title="[A](op1: =&gt; A)(op2: Types.this.Type =&gt; A)A" id="148529">memo</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="148531">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="451569">op1</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; A" id="451570">op2</a>: Type =&gt; A<span class="delimiter">)</span>: <a href="#148531" title="A">A</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="()A" id="451659">updateCache</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#148531" title="A">A</a> = <span class="delimiter">{</span>
        <a href="#67374" title="(k: List[Types.this.Type], v: scala.ref.WeakReference[Types.this.Type])Unit">intersectionWitness</a><span class="delimiter">(</span><a href="#105322" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> = <span title="(value: Types.this.CompoundType)scala.ref.WeakReference[Types.this.CompoundType]" class="keyword">new</span> <span title="scala.ref.WeakReference[Types.this.CompoundType]">WeakReference</span><span class="delimiter">(</span><a href="#67415" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#451569" title="=&gt; A">op1</a>
      <span class="delimiter">}</span>
      
      <a href="#67374" title="=&gt; scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]">intersectionWitness</a> <span title="(k: List[Types.this.Type])Option[scala.ref.WeakReference[Types.this.Type]]">get</span> <a href="#105322" title="=&gt; List[Types.this.Type]">parents</a> <span title="A" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="A">Some</span><span class="delimiter">(</span><a title="scala.ref.WeakReference[Types.this.Type]" id="451694">ref</a><span class="delimiter">)</span> =&gt;
          <a href="#451694" title="scala.ref.WeakReference[Types.this.Type]">ref</a>.<span title="=&gt; Option[Types.this.Type]">get</span> <span title="A" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="A">Some</span><span class="delimiter">(</span><a title="Types.this.Type" id="451696">w</a><span class="delimiter">)</span> =&gt; <span title="A" class="keyword">if</span> <span class="delimiter">(</span><a href="#451696" title="Types.this.Type">w</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#67415" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span> <a href="#451569" title="=&gt; A">op1</a> <span class="keyword">else</span> <a href="#451570" title="(v1: Types.this.Type)A">op2</a><span class="delimiter">(</span><a href="#451696" title="Types.this.Type">w</a><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="A">None</span> =&gt; <a href="#451659" title="()A">updateCache</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="keyword">case</span> <span title="A">None</span> =&gt; <a href="#451659" title="()A">updateCache</a><span class="delimiter">(</span><span class="delimiter">)</span> 
      <span class="delimiter">}</span>
     
    <span class="delimiter">}</span>
 
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="148532">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="451698">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="451700">index</a> = <a href="#105386" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#451698" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#451700" title="Int">index</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="BaseTypeSeqs.scala.html#197508" title="(i: Int)Types.this.Type">baseTypeSeq</a><span class="delimiter">(</span><a href="#451700" title="Int">index</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#450850" title="object Types.this.NoType">NoType</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148533">narrow</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107459" title="=&gt; Types.this.Type">thisType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148534">isNotNull</a>: <span title="Boolean">Boolean</span> = <a href="#105322" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#451717" title="Types.this.Type">_</a>.<a href="#105307" title="=&gt; Boolean">isNotNull</a><span class="delimiter">)</span>
    
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148535">isStructuralRefinement</a>: <span title="Boolean">Boolean</span> =
      <a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107348" title="=&gt; Boolean">isAnonOrRefinementClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <span class="delimiter">(</span><a href="#105346" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112957" title="=&gt; List[Types.this.Symbol]">toList</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="451729">entry</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#451729" title="Types.this.Symbol">entry</a>.<a href="Symbols.scala.html#107334" title="=&gt; Boolean">isConstructor</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#451729" title="Types.this.Symbol">entry</a>.<a href="Symbols.scala.html#107491" title="=&gt; List[Types.this.Symbol]">allOverriddenSymbols</a>.<span title="=&gt; Boolean">isEmpty</span> <span class="delimiter">}</span><span class="delimiter">)</span>

    <span class="comment">// override def isNullable: Boolean =</span>
    <span class="comment">// parents forall (p =&gt; p.isNullable &amp;&amp; !p.typeSymbol.isAbstractType);</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148536">safeToString</a>: <span title="String">String</span> =
      <a href="#105322" title="=&gt; List[Types.this.Type]">parents</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot; with &quot;)" class="string">&quot; with &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)java.lang.String">+</span>
      <span class="delimiter">(</span><span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">||</span> <a href="#105322" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#105346" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112921" title="=&gt; Types.this.ScopeEntry">elems</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#105346" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112964" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="java.lang.String(&quot;{&quot;)" class="string">&quot;{&quot;</span>, <span title="java.lang.String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="java.lang.String(&quot;}&quot;)" class="string">&quot;}&quot;</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class representing intersection types with refinements of the form
   *    `&lt;parents_0&gt; with ... with &lt;parents_n&gt; { decls }'
   *  Cannot be created directly;
   *  one should always use `refinedType' for creation.
   */</span>
  case <span class="keyword">class</span> <a title="class RefinedType extends Types.this.CompoundType with ScalaObject with Product with Serializable" id="148512">RefinedType</a><a href="#148512" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Type]" id="236305">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>,
                         <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Scope" id="236306">decls</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67415" title="Types.this.CompoundType">CompoundType</a> <span class="delimiter">{</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148544">isHigherKinded</a> = <span class="delimiter">(</span>
      <a href="#236305" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
      <span class="delimiter">(</span><a href="#236305" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#451755" title="Types.this.Type">_</a>.<a href="#105304" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a>    <span class="comment">// @MO to AM: please check this class!</span>
    <span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148545">typeParams</a> = 
      <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#148544" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#236305" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#105336" title="=&gt; List[Types.this.Symbol]">typeParams</a>
      <span class="keyword">else</span> <a href="#148512" title="Types.this.RefinedType" class="keyword">super</a>.<a href="#105336" title="=&gt; List[Types.this.Symbol]">typeParams</a>

    <span class="comment">//@M may result in an invalid type (references to higher-order args become dangling )</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148546">typeConstructor</a> = 
      <a href="#67471" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#148512" title="Types.this.RefinedType" class="keyword">this</a>, <a href="#236305" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#451779" title="Types.this.Type">_</a>.<a href="#105325" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>, <a href="#236306" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span>
    
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148547">dummyArgs</a> = <a href="#148545" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#451829" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107436" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>

    <span class="comment">/* MO to AM: This is probably not correct
     * If they are several higher-kinded parents with different bounds we need
     * to take the intersection of their bounds
     */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148548">normalize</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#148544" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#67481" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span>
          <a href="#148545" title="=&gt; List[Types.this.Symbol]">typeParams</a>,
          <a href="#148511" title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span>
            <a href="#236305" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#451890" title="Types.this.Type" class="delimiter">{</a>
              <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="451891">pre</a>, <a title="Types.this.Symbol" id="451892">sym</a>, <a href="#451894" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#133347" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#451891" title="Types.this.Type">pre</a>, <a href="#451892" title="Types.this.Symbol">sym</a>, <a href="#148547" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>
              <span class="keyword">case</span> <a title="Types.this.Type" id="451908">p</a> =&gt; <a href="#451908" title="Types.this.Type">p</a>
            <span class="delimiter">}</span>,
            <a href="#236306" title="=&gt; Types.this.Scope">decls</a>,
            <a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#148512" title="Types.this.RefinedType" class="keyword">super</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a>
    <span class="delimiter">}</span>

    <span class="comment">/** A refined type P1 with ... with Pn { decls } is volatile if
     *  one of the parent types Pi is an abstract type, and
     *  either i &gt; 1, or decls or a following parent Pj, j &gt; 1, contributes
     *  an abstract member.
     *  A type contributes an abstract member if it has an abstract member which
     *  is also a member of the whole refined type. A scope `decls' contributes
     *  an abstract member if it has an abstract definition which is also
     *  a member of the whole type.
     */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148549">isVolatile</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(m: Types.this.Symbol)Boolean" id="451940">isVisible</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="451942">m</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = 
        <a href="#148512" title="RefinedType.this.type" class="keyword">this</a>.<a href="#105355" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#451942" title="Types.this.Symbol">m</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107450" title="=&gt; List[Types.this.Symbol]">alternatives</a> <span title="(elem: Any)Boolean">contains</span> <a href="#451942" title="Types.this.Symbol">m</a>
      <span class="keyword">def</span> <a title="(p: Types.this.Type)Boolean" id="451941">contributesAbstractMembers</a><span class="delimiter">(</span><a title="Types.this.Type" id="451943">p</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = 
        <a href="#451943" title="Types.this.Type">p</a>.<a href="#105353" title="=&gt; List[Types.this.Symbol]">deferredMembers</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <a href="#451940" title="(m: Types.this.Symbol)Boolean">isVisible</a>

      <span class="delimiter">(</span><span class="delimiter">(</span><a href="#236305" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#451959" title="Types.this.Type">_</a>.<a href="#105306" title="=&gt; Boolean">isVolatile</a><span class="delimiter">)</span><span class="delimiter">)</span> 
       <span title="(x: Boolean)Boolean">||</span>
       <span class="delimiter">(</span><a href="#236305" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">dropWhile</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span> <a href="#451964" title="Types.this.Type">_</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isAbstractType</span><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
         <span class="keyword">case</span> <a title="Boolean" id="451965">ps</a> @ <span class="delimiter">(</span>_ :: <a title="List[Types.this.Type]" id="451970">ps1</a><span class="delimiter">)</span> =&gt; 
           <span class="delimiter">(</span><a href="#451965" title="collection.immutable.::[Types.this.Type]">ps</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#236305" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
           <span class="delimiter">(</span><a href="#451970" title="List[Types.this.Type]">ps1</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <a href="#451941" title="(p: Types.this.Type)Boolean">contributesAbstractMembers</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
           <span class="delimiter">(</span><a href="#236306" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112959" title="=&gt; Iterator[Types.this.Symbol]">iterator</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="451984">m</a> =&gt; <a href="#451984" title="Types.this.Symbol">m</a>.<span title="=&gt; Boolean">isDeferred</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#451940" title="(m: Types.this.Symbol)Boolean">isVisible</a><span class="delimiter">(</span><a href="#451984" title="Types.this.Symbol">m</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
         <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
           <span title="Boolean(false)" class="keyword">false</span>
       <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148550">kind</a> = <span title="java.lang.String(&quot;RefinedType&quot;)" class="string">&quot;RefinedType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class RefinedType0 extends Types.this.RefinedType with ScalaObject" id="67419">RefinedType0</a><a href="#67419" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Type]" id="452032">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="452033">decls</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="452034">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#148512" title="Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#452032" title="List[Types.this.Type]">parents</a>, <a href="#452033" title="Types.this.Scope">decls</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="452027">typeSymbol</a> = <a href="#452034" title="Types.this.Symbol">clazz</a>
  <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object Types.this.RefinedType" id="67417">RefinedType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24048" title="Types.this.RefinedTypeExtractor">RefinedTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType" id="148511">apply</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="236290">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="236291">decls</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="236292">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#148512" title="Types.this.RefinedType">RefinedType</a> =
      <span title="Types.this.RefinedType0" class="keyword">new</span> <a href="#67419" title="Types.this.RefinedType0">RefinedType0</a><span class="delimiter">(</span><a href="#236290" title="List[Types.this.Type]">parents</a>, <a href="#236291" title="Types.this.Scope">decls</a>, <a href="#236292" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class representing a class info
   */</span>
  case <span class="keyword">class</span> <a title="class ClassInfoType extends Types.this.CompoundType with ScalaObject with Product with Serializable" id="148601">ClassInfoType</a><a href="#148601" title="ScalaObject" class="delimiter">(</a>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Type]" id="399118">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>,
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Scope" id="399119">decls</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a>,
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Symbol" id="399120">typeSymbol</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67415" title="Types.this.CompoundType">CompoundType</a> 
  <span class="delimiter">{</span>
    
    <span class="comment">/** refs indices */</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(0)" id="148612">NonExpansive</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(1)" id="148614">Expansive</a> = <span title="Int(1)" class="int">1</span>

    <span class="comment">/** initialization states */</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(0)" id="148616">UnInitialized</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(1)" id="148618">Initializing</a> = <span title="Int(1)" class="int">1</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(2)" id="148620">Initialized</a> = <span title="Int(2)" class="int">2</span>

    <span class="keyword">private</span> <span class="keyword">type</span> <a title="Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]" id="148622">RefMap</a> = <span title="Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">Map</span><span class="delimiter">[</span>Symbol, immutable.Set<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span>

    <span class="comment">/** All type parameters reachable from given type parameter
     *  by a path which contains at least one expansive reference.
     *  @See Kennedy, Pierce: On Decidability of Nominal Subtyping with Variance
     */</span>
    <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Set[Types.this.Symbol]" id="148623">expansiveRefs</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="452045">tparam</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#148628" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)">UnInitialized</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#148634" title="()Unit">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#148628" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(2)">Initialized</span><span class="delimiter">)</span> <a href="#148635" title="()Boolean">propagate</a><a href="#452054" title="()Unit" class="delimiter">(</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#148630" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#452045" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/* The rest of this class is auxiliary code for `expansiveRefs'
     */</span>

    <span class="comment">/** The type parameters which are referenced type parameters of this class.
     *  Two entries: refs(0): Non-expansive references
     *               refs(1): Expansive references
     */</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Array[ClassInfoType.this.RefMap]" id="148625">refs</a>: <span title="Array[ClassInfoType.this.RefMap]">Array</span><span class="delimiter">[</span>RefMap<span class="delimiter">]</span> = _

    <span class="comment">/** The initialization state of the class: UnInialized --&gt; Initializing --&gt; Initialized
     */</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="148628">state</a> = <span title="Int(0)">UnInitialized</span>

    <span class="comment">/** Get references for given type parameter
     *  @param  which in {NonExpansive, Expansive}
     *  @param  from  The type parameter from which references originate.
     */</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]" id="148630">getRefs</a><span class="delimiter">(</span><a title="Int" id="452061">which</a>: <span title="Int">Int</span>, <a title="Types.this.Symbol" id="452062">from</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Set[Types.this.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#148625" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#452061" title="Int">which</a><span class="delimiter">)</span> <span title="(key: Types.this.Symbol)Option[scala.collection.immutable.Set[Types.this.Symbol]]">get</span> <a href="#452062" title="Types.this.Symbol">from</a> <span title="Set[Types.this.Symbol]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="scala.collection.immutable.Set[Types.this.Symbol]">Some</span><span class="delimiter">(</span><a title="scala.collection.immutable.Set[Types.this.Symbol]" id="452077">set</a><span class="delimiter">)</span> =&gt; <a href="#452077" title="scala.collection.immutable.Set[Types.this.Symbol]">set</a>
      <span class="keyword">case</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="452078">none</a> =&gt; <span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]">Set</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Augment existing refs map with reference &lt;pre&gt;from -&gt; to&lt;/pre&gt; 
     *  @param  which &lt;- {NonExpansive, Expansive}
     */</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit" id="148631">addRef</a><span class="delimiter">(</span><a title="Int" id="452082">which</a>: <span title="Int">Int</span>, <a title="Types.this.Symbol" id="452083">from</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="452084">to</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#148625" title="(i: Int, x: ClassInfoType.this.RefMap)Unit">refs</a><span class="delimiter">(</span><a href="#452082" title="Int">which</a><span class="delimiter">)</span> = <a href="#148625" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#452082" title="Int">which</a><span class="delimiter">)</span> <span title="(kv: (Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol]))scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">+</span> <span class="delimiter">(</span><a href="#452083" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">from</a> <span title="(y: scala.collection.immutable.Set[Types.this.Symbol])(Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])">-&gt;</span> <span class="delimiter">(</span><a href="#148630" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><a href="#452082" title="Int">which</a>, <a href="#452083" title="Types.this.Symbol">from</a><span class="delimiter">)</span> <span title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">+</span> <a href="#452084" title="Types.this.Symbol">to</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Augment existing refs map with references &lt;pre&gt;from -&gt; sym&lt;/pre&gt;, for
     *  all elements &lt;pre&gt;sym&lt;/pre&gt; of set `to'.
     *  @param  which &lt;- {NonExpansive, Expansive}
     */</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit" id="148632">addRefs</a><span class="delimiter">(</span><a title="Int" id="452192">which</a>: <span title="Int">Int</span>, <a title="Types.this.Symbol" id="452193">from</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Set[Types.this.Symbol]" id="452194">to</a>: <span title="Set[Types.this.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#148625" title="(i: Int, x: ClassInfoType.this.RefMap)Unit">refs</a><span class="delimiter">(</span><a href="#452192" title="Int">which</a><span class="delimiter">)</span> = <a href="#148625" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#452192" title="Int">which</a><span class="delimiter">)</span> <span title="(kv: (Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol]))scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">+</span> <span class="delimiter">(</span><a href="#452193" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">from</a> <span title="(y: scala.collection.immutable.Set[Types.this.Symbol])(Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])">-&gt;</span> <span class="delimiter">(</span><a href="#148630" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><a href="#452192" title="Int">which</a>, <a href="#452193" title="Types.this.Symbol">from</a><span class="delimiter">)</span> <span title="(elems: scala.collection.GenTraversableOnce[Types.this.Symbol])scala.collection.immutable.Set[Types.this.Symbol]">++</span> <a href="#452194" title="Set[Types.this.Symbol]">to</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** The ClassInfoType which belongs to the class containing given type parameter 
     */</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Types.this.ClassInfoType" id="148633">classInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="452331">tparam</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#148601" title="Types.this.ClassInfoType">ClassInfoType</a> = 
      <a href="#452331" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105327" title="=&gt; Types.this.Type">resultType</a> <span title="Types.this.ClassInfoType" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="Types.this.ClassInfoType" id="452336">ci</a>: <a href="#148601" title="Types.this.ClassInfoType">ClassInfoType</a> =&gt; <a href="#452336" title="Types.this.ClassInfoType">ci</a>
        <span class="keyword">case</span> <span title="Types.this.ClassInfoType">_</span> =&gt; <a href="#148633" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><a href="Definitions.scala.html#106079" title="=&gt; Types.this.Symbol">ObjectClass</a><span class="delimiter">)</span> <span class="comment">// something's wrong; fall back to safe value</span>
                                         <span class="comment">// (this can happen only for erroneous programs).</span>
      <span class="delimiter">}</span>

    <span class="comment">/** Compute initial (one-step) references and set state to `Initializing'.
     */</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="()Unit" id="148634">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#148625" title="(x$1: Array[ClassInfoType.this.RefMap])Unit">refs</a> = <span title="(xs: ClassInfoType.this.RefMap*)(implicit evidence$2: scala.reflect.ClassManifest[ClassInfoType.this.RefMap])Array[ClassInfoType.this.RefMap]">Array</span><a href="#24048" title="(clazz: java.lang.Class[_], arg1: scala.reflect.OptManifest[_], args: scala.reflect.OptManifest[_]*)scala.reflect.ClassManifest[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" class="delimiter">(</a><span title="(elems: (Types.this.Symbol, Nothing)*)scala.collection.immutable.Map[Types.this.Symbol,Nothing]">Map</span><span class="delimiter">(</span><span class="delimiter">)</span>, <span title="(elems: (Types.this.Symbol, Nothing)*)scala.collection.immutable.Map[Types.this.Symbol,Nothing]">Map</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="452431">tparam</a> &lt;- <a href="#399120" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107438" title="(f: Types.this.Symbol =&gt; Unit)Unit">typeParams</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.TypeMap" id="452432">enterRefs</a> = <a href="#452433" title="Types.this.TypeMap" class="keyword">new</a> <a href="#67503" title="anonymous class $anon extends Types.this.TypeMap" id="452433">TypeMap</a> <span class="delimiter">{</span>
          <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="452435">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="452436">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
            <a href="#452436" title="Types.this.Type">tp</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="452439">sym</a>, <a title="List[Types.this.Type]" id="452440">args</a><span class="delimiter">)</span> =&gt;
                <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="452536">tparam1</a>, <a title="Types.this.Type" id="452537">arg</a><span class="delimiter">)</span> &lt;- <a href="#452439" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105336" title="=&gt; List[Types.this.Symbol]">typeParams</a> <a href="#452507" title="(f: (Types.this.Symbol, Types.this.Type) =&gt; Unit)Unit">zip</a> <a href="#452440" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
                  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#452537" title="Types.this.Type">arg</a> <a href="#105372" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#452431" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#148631" title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit">addRef</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#452431" title="Types.this.Symbol">tparam</a>, <a href="#452536" title="Types.this.Symbol">tparam1</a><span class="delimiter">)</span>
                    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#452537" title="Types.this.Type">arg</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#452431" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span> <a href="#148631" title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit">addRef</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#452431" title="Types.this.Symbol">tparam</a>, <a href="#452536" title="Types.this.Symbol">tparam1</a><span class="delimiter">)</span>
                  <span class="delimiter">}</span>
              <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
            <span class="delimiter">}</span>
            <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#452436" title="Types.this.Type">tp</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="452580">p</a> &lt;- <a href="#399118" title="(f: Types.this.Type =&gt; Types.this.Type)Unit">parents</a><span class="delimiter">)</span> <a href="#452432" title="(v1: Types.this.Type)Types.this.Type">enterRefs</a><span class="delimiter">(</span><a href="#452580" title="Types.this.Type">p</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#148628" title="(x$1: Int)Unit">state</a> = <span title="Int(1)">Initializing</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Propagate to form transitive closure.
     *  Set state to Initialized if no change resulted from propagation.
     *  @return   true iff there as a change in last iteration
     */</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="()Boolean" id="148635">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#148628" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)">UnInitialized</span><span class="delimiter">)</span> <a href="#148634" title="()Unit">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="comment">//Console.println(&quot;Propagate &quot;+symbol+&quot;, initial expansive = &quot;+refs(Expansive)+&quot;, nonexpansive = &quot;+refs(NonExpansive))//DEBUG</span>
      <span class="keyword">val</span> <a title="Array[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" id="452584">lastRefs</a> = <span title="(xs: ClassInfoType.this.RefMap*)(implicit evidence$2: scala.reflect.ClassManifest[ClassInfoType.this.RefMap])Array[ClassInfoType.this.RefMap]">Array</span><a href="#24048" title="(clazz: java.lang.Class[_], arg1: scala.reflect.OptManifest[_], args: scala.reflect.OptManifest[_]*)scala.reflect.ClassManifest[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" class="delimiter">(</a><a href="#148625" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>, <a href="#148625" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#148628" title="(x$1: Int)Unit">state</a> = <span title="Int(2)">Initialized</span>
      <span class="keyword">var</span> <a title="Boolean" id="452585">change</a> = <span title="Boolean(false)" class="keyword">false</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="452680">from</a>, <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="452681">targets</a><span class="delimiter">)</span> &lt;- <a href="#148625" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span><span class="delimiter">)</span>.<a href="#452662" title="(f: (Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol]) =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="452698">target</a> &lt;- <a href="#452681" title="(f: Types.this.Symbol =&gt; Unit)Unit">targets</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">var</span> <a title="Types.this.ClassInfoType" id="452699">thatInfo</a> = <a href="#148633" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><a href="#452698" title="Types.this.Symbol">target</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#452699" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#148628" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(2)">Initialized</span><span class="delimiter">)</span> 
            <a href="#452585" title="Boolean">change</a> = <a href="#452585" title="Boolean">change</a> <span title="(x: Boolean)Boolean">|</span> <a href="#452699" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#148635" title="()Boolean">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#148632" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#452680" title="Types.this.Symbol">from</a>, <a href="#452699" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#148630" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#452698" title="Types.this.Symbol">target</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#148632" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#452680" title="Types.this.Symbol">from</a>, <a href="#452699" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#148630" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#452698" title="Types.this.Symbol">target</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="452727">from</a>, <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="452728">targets</a><span class="delimiter">)</span> &lt;- <a href="#148625" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span><span class="delimiter">)</span>.<a href="#452709" title="(f: (Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol]) =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="452745">target</a> &lt;- <a href="#452728" title="(f: Types.this.Symbol =&gt; Unit)Unit">targets</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">var</span> <a title="Types.this.ClassInfoType" id="452746">thatInfo</a> = <a href="#148633" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><a href="#452745" title="Types.this.Symbol">target</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#452746" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#148628" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(2)">Initialized</span><span class="delimiter">)</span> 
            <a href="#452585" title="Boolean">change</a> = <a href="#452585" title="Boolean">change</a> <span title="(x: Boolean)Boolean">|</span> <a href="#452746" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#148635" title="()Boolean">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#148632" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#452727" title="Types.this.Symbol">from</a>, <a href="#452746" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#148630" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#452745" title="Types.this.Symbol">target</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <a href="#452585" title="Boolean">change</a> = <a href="#452585" title="Boolean">change</a> <span title="(x: Boolean)Boolean">||</span> <a href="#148625" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#452584" title="(i: Int)scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">lastRefs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#148625" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#452584" title="(i: Int)scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">lastRefs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#452585" title="Boolean">change</a><span class="delimiter">)</span> <a href="#148628" title="(x$1: Int)Unit">state</a> = <span title="Int(1)">Initializing</span>
      <span class="comment">//else Console.println(&quot;Propagate &quot;+symbol+&quot;, final expansive = &quot;+refs(Expansive)+&quot;, nonexpansive = &quot;+refs(NonExpansive))//DEBUG</span>
      <a href="#452585" title="Boolean">change</a>
    <span class="delimiter">}</span>

    <span class="comment">// override def isNullable: Boolean =</span>
    <span class="comment">// symbol == AnyClass ||</span>
    <span class="comment">// symbol != NothingClass &amp;&amp; (symbol isSubClass ObjectClass) &amp;&amp; !(symbol isSubClass NonNullClass);</span>

    <span class="comment">// override def isNonNull: Boolean = symbol == NonNullClass || super.isNonNull;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148636">kind</a> = <span title="java.lang.String(&quot;ClassInfoType&quot;)" class="string">&quot;ClassInfoType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.ClassInfoType" id="67421">ClassInfoType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24048" title="Types.this.ClassInfoTypeExtractor">ClassInfoTypeExtractor</a>

  <span class="keyword">class</span> <a title="class PackageClassInfoType extends Types.this.ClassInfoType with ScalaObject" id="67423">PackageClassInfoType</a><a href="#67423" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Scope" id="440666">decls</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="440667">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="#148601" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">(</span>List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#440666" title="Types.this.Scope">decls</a>, <a href="#440667" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>

  <span class="comment">/** A class representing a constant type.
   *
   *  @param value ...
   */</span>
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a title="class ConstantType extends Types.this.SingletonType with ScalaObject with Product with Serializable" id="148358">ConstantType</a><a href="#148358" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Constant" id="148366">value</a>: <span title="Types.this.Constant">Constant</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67387" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148351">underlying</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#148366" title="=&gt; Types.this.Constant">value</a>.<span title="=&gt; Types.this.Type">tpe</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#148351" title="=&gt; Types.this.Type">underlying</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#106577" title="=&gt; Types.this.Symbol">UnitClass</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148352">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148353">isNotNull</a> = <a href="#148366" title="=&gt; Types.this.Constant">value</a>.<span title="=&gt; Any">value</span> <span title="(x$1: Any)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148354">deconst</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#148351" title="=&gt; Types.this.Type">underlying</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148355">safeToString</a>: <span title="String">String</span> =
      <a href="#148351" title="=&gt; Types.this.Type">underlying</a>.<span title="()String">toString</span> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#148366" title="=&gt; Types.this.Constant">value</a>.<span title="=&gt; String">escapedStringValue</span> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
    <span class="comment">// override def isNullable: Boolean = value.value eq null</span>
    <span class="comment">// override def isNonNull: Boolean = value.value ne null</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148356">kind</a> = <span title="java.lang.String(&quot;ConstantType&quot;)" class="string">&quot;ConstantType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueConstantType extends Types.this.ConstantType with Types.this.UniqueType with ScalaObject" id="67427">UniqueConstantType</a><a href="#67427" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Constant" id="452856">value</a>: <span title="Types.this.Constant">Constant</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#148358" title="Types.this.ConstantType">ConstantType</a><span class="delimiter">(</span><a href="#452856" title="Types.this.Constant">value</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#67382" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span>
    <span class="comment">/** Save the type of 'value'. For Java enums, it depends on finding the linked class,
     *  which might not be found after 'flatten'. */</span>
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.Type" id="452852">_tpe</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#452856" title="Types.this.Constant">value</a>.<span title="=&gt; Types.this.Type">tpe</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="452853">underlying</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#452851" title="=&gt; Types.this.Type">_tpe</a>
  <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object Types.this.ConstantType" id="67425">ConstantType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24048" title="Types.this.ConstantTypeExtractor">ConstantTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(value: Types.this.Constant)Types.this.ConstantType" id="148346">apply</a><span class="delimiter">(</span><a title="Types.this.Constant" id="151920">value</a>: <span title="Types.this.Constant">Constant</span><span class="delimiter">)</span>: <a href="#148358" title="Types.this.ConstantType">ConstantType</a> = <span class="delimiter">{</span>
      <a href="#67495" title="(tp: Types.this.UniqueConstantType)Types.this.UniqueConstantType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueConstantType" class="keyword">new</span> <a href="#67427" title="Types.this.UniqueConstantType">UniqueConstantType</a><span class="delimiter">(</span><a href="#151920" title="Types.this.Constant">value</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.ConstantType" class="delimiter">[</span><a href="#148358" title="Types.this.ConstantType">ConstantType</a><span class="delimiter">]</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="67429">volatileRecursions</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.Symbol]" id="67431">pendingVolatiles</a> = <span title="()scala.collection.mutable.HashSet[Types.this.Symbol]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Types.this.Symbol]">HashSet</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

  <span class="comment">/** A class for named types of the form
   *  `&lt;prefix&gt;.&lt;sym.name&gt;[args]'
   *  Cannot be created directly; one should always use `typeRef'
   *  for creation. (@M: Otherwise hashing breaks)
   *
   * @M: a higher-kinded type is represented as a TypeRef with sym.info.typeParams.nonEmpty, but args.isEmpty
   *  @param pre  ...
   *  @param sym  ...
   *  @param args ...
   */</span>
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a title="class TypeRef extends Types.this.Type with ScalaObject with Product with Serializable" id="133425">TypeRef</a><a href="#133425" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="133453">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="133454">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="133455">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67381" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
<span class="comment">//    assert(!sym.isAbstractType || pre.isStable || pre.isError)</span>
<span class="comment">//    assert(!pre.isInstanceOf[ClassInfoType], this)</span>
<span class="comment">//    assert(!(sym hasFlag (PARAM | EXISTENTIAL)) || pre == NoPrefix, this)</span>
<span class="comment">//    assert(args.isEmpty || !sym.info.typeParams.isEmpty, this)</span>
<span class="comment">//    assert(args.isEmpty || ((sym ne AnyClass) &amp;&amp; (sym ne NothingClass))</span>

    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[Types.this.Type]" id="133359">parentsCache</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="133362">parentsPeriod</a> = <span title="Int(0)">NoPeriod</span>
    
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.BaseTypeSeq" id="133365">baseTypeSeqCache</a>: <a href="BaseTypeSeqs.scala.html#67693" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="133368">baseTypeSeqPeriod</a> = <span title="Int(0)">NoPeriod</span>

    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="133371">symInfoCache</a>: <a href="#67381" title="Types.this.Type">Type</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="133374">memberInfoCache</a>: <a href="#67381" title="Types.this.Type">Type</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="133377">thisInfoCache</a>: <a href="#67381" title="Types.this.Type">Type</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="133380">relativeInfoCache</a>: <a href="#67381" title="Types.this.Type">Type</a> = _

    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="133383">normalized</a>: <a href="#67381" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
    

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133385">isStable</a>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="#133454" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a> <span title="(x: Boolean)Boolean">||</span>
      <a href="#133454" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106203" title="=&gt; Types.this.Symbol">SingletonClass</a> <span title="(x: Boolean)Boolean">||</span>
      <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#133415" title="=&gt; Types.this.Type">normalize</a>.<a href="#105305" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">||</span>
      <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAbstractType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#133398" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#107448" title="(that: Types.this.Symbol)Boolean">isSubClass</a> <a href="Definitions.scala.html#106203" title="=&gt; Types.this.Symbol">SingletonClass</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133386">isVolatile</a>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#133415" title="=&gt; Types.this.Type">normalize</a>.<a href="#105306" title="=&gt; Boolean">isVolatile</a> <span title="(x: Boolean)Boolean">||</span>
      <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAbstractType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
        <span class="comment">// need to be careful not to fall into an infinite recursion here</span>
        <span class="comment">// because volatile checking is done before all cycles are detected.</span>
        <span class="comment">// the case to avoid is an abstract type directly or</span>
        <span class="comment">// indirectly upper-bounded by itself. See #2918</span>
        <span class="keyword">try</span> <span class="delimiter">{</span>
          <a href="#67429" title="(x$1: Int)Unit">volatileRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67429" title="=&gt; Int">volatileRecursions</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(50)">LogVolatileThreshold</span><span class="delimiter">)</span>
            <a href="#133398" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a>.<a href="#105306" title="=&gt; Boolean">isVolatile</a>
          <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67431" title="(elem: Types.this.Symbol)Boolean">pendingVolatiles</a><span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span title="Boolean(true)" class="keyword">true</span> <span class="comment">// we can return true here, because a cycle will be detected</span>
                 <span class="comment">// here afterwards and an error will result anyway.</span>
          <span class="keyword">else</span> 
            <span class="keyword">try</span> <span class="delimiter">{</span>
              <a href="#67431" title="=&gt; scala.collection.mutable.HashSet[Types.this.Symbol]">pendingVolatiles</a> <span title="(elem: Types.this.Symbol)Types.this.pendingVolatiles.type">+=</span> <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>
              <a href="#133398" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a>.<a href="#105306" title="=&gt; Boolean">isVolatile</a>
            <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
              <a href="#67431" title="=&gt; scala.collection.mutable.HashSet[Types.this.Symbol]">pendingVolatiles</a> <span title="(elem: Types.this.Symbol)Types.this.pendingVolatiles.type">-=</span> <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
          <a href="#67429" title="(x$1: Int)Unit">volatileRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="133388">isTrivial</a>: <span title="Boolean">Boolean</span> =
      <span title="=&gt; Boolean">!</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isTypeParameter</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#133453" title="=&gt; Types.this.Type">pre</a>.<a href="#105303" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#133455" title="=&gt; List[Types.this.Type]">args</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#452946" title="Types.this.Type">_</a>.<a href="#105303" title="=&gt; Boolean">isTrivial</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133389">isNotNull</a> = 
      <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isModuleClass</span> <span title="(x: Boolean)Boolean">||</span> <a href="#133454" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="Definitions.scala.html#106520" title="(sym: Types.this.Symbol)Boolean">isValueClass</a><span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#133425" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105307" title="=&gt; Boolean">isNotNull</a>

    <span class="comment">// @M: propagate actual type params (args) to `tp', by replacing formal type parameters with actual ones</span>
    <span class="comment">// if tp is higher kinded, the &quot;actual&quot; type arguments are types that simply reference the corresponding type parameters  (unbound type variables) </span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="133390">transform</a><span class="delimiter">(</span><a title="Types.this.Type" id="452957">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="452959">res</a> = <a href="#452957" title="Types.this.Type">tp</a>.<a href="#105359" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#133453" title="=&gt; Types.this.Type">pre</a>, <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#133455" title="=&gt; List[Types.this.Type]">args</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#452967" title="Types.this.Type">_</a>.<a href="#105344" title="=&gt; Boolean">isError</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#67515" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>, <a href="#133455" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="comment">/*#2266/2305*/</span><span class="delimiter">)</span> <a href="#452959" title="Types.this.Type">res</a>
      <span class="keyword">else</span> <a href="#452959" title="Types.this.Type">res</a>.<a href="#105339" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#133404" title="=&gt; List[Types.this.Type]">typeArgsOrDummies</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">//@M! use appliedType on the polytype that represents the bounds (or if aliastype, the rhs)</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="133391">transformInfo</a><span class="delimiter">(</span><a title="Types.this.Type" id="453028">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#67478" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#453028" title="Types.this.Type">tp</a>.<a href="#105359" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#133453" title="=&gt; Types.this.Type">pre</a>, <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>, <a href="#133404" title="=&gt; List[Types.this.Type]">typeArgsOrDummies</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133392">thisInfo</a>: <a href="#67381" title="Types.this.Type">Type</a> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <a href="#133415" title="=&gt; Types.this.Type">normalize</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107321" title="=&gt; Boolean">isNonClassType</a><span class="delimiter">)</span> <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="453032">symInfo</a> = <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133377" title="=&gt; Types.this.Type">thisInfoCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#453032" title="Types.this.Type">symInfo</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#133371" title="=&gt; Types.this.Type">symInfoCache</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#133371" title="(x$1: Types.this.Type)Unit">symInfoCache</a> = <a href="#453032" title="Types.this.Type">symInfo</a>
          <a href="#133377" title="(x$1: Types.this.Type)Unit">thisInfoCache</a> = <a href="#133391" title="(tp: Types.this.Type)Types.this.Type">transformInfo</a><span class="delimiter">(</span><a href="#453032" title="Types.this.Type">symInfo</a><span class="delimiter">)</span>            
        <span class="delimiter">}</span>
        <a href="#133377" title="=&gt; Types.this.Type">thisInfoCache</a>
      <span class="delimiter">}</span>
    
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133393">relativeInfo</a>: <a href="#67381" title="Types.this.Type">Type</a> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107321" title="=&gt; Boolean">isNonClassType</a><span class="delimiter">)</span> <a href="#133453" title="=&gt; Types.this.Type">pre</a>.<a href="#105360" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="453040">memberInfo</a> = <a href="#133453" title="=&gt; Types.this.Type">pre</a>.<a href="#105360" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133380" title="=&gt; Types.this.Type">relativeInfoCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#453040" title="Types.this.Type">memberInfo</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#133374" title="=&gt; Types.this.Type">memberInfoCache</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#133374" title="(x$1: Types.this.Type)Unit">memberInfoCache</a> = <a href="#453040" title="Types.this.Type">memberInfo</a>
          <a href="#133380" title="(x$1: Types.this.Type)Unit">relativeInfoCache</a> = <a href="#133391" title="(tp: Types.this.Type)Types.this.Type">transformInfo</a><span class="delimiter">(</span><a href="#453040" title="Types.this.Type">memberInfo</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#133380" title="=&gt; Types.this.Type">relativeInfoCache</a>
      <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="133394">typeSymbol</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <a href="#133415" title="=&gt; Types.this.Type">normalize</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span class="keyword">else</span> <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="133395">termSymbol</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <a href="#133415" title="=&gt; Types.this.Type">normalize</a>.<a href="#105312" title="=&gt; Types.this.Symbol">termSymbol</a> <span class="keyword">else</span> <a href="#133425" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105312" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="133396">typeSymbolDirect</a> = <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="133397">termSymbolDirect</a> = <a href="#133425" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105312" title="=&gt; Types.this.Symbol">termSymbol</a>

<span class="comment">/* @MAT
whenever you see `tp.typeSymbol.isXXXX' and then act on tp based on that predicate, you're on thin ice, 
as `typeSymbol' (and `prefix') automatically normalize, but the other inspectors don't. 
In other words, even if `tp.normalize.sym.isXXX' is true, `tp.sym.isXXX' may be false (if sym were a public method to access the non-normalized typeSymbol)...

In retrospect, I think `tp.typeSymbol.isXXX' or (worse) `tp.typeSymbol==XXX' should be replaced by `val tp = tp0.asXXX'.  
A type's typeSymbol should never be inspected directly.
*/</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="133398">bounds</a>: <a href="#148453" title="Types.this.TypeBounds">TypeBounds</a> =
      <span title="Types.this.TypeBounds" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAbstractType</span><span class="delimiter">)</span> <a href="#133392" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a> <span class="comment">// transform(thisInfo.bounds).asInstanceOf[TypeBounds] // ??? seems to be doing asSeenFrom twice</span>
      <span class="keyword">else</span> <a href="#133425" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="133399">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span> 
      <span class="keyword">val</span> <a title="Int" id="453057">period</a> = <a href="#133362" title="=&gt; Int">parentsPeriod</a> 
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#453057" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#64801" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span> 
        <a href="#133362" title="(x$1: Int)Unit">parentsPeriod</a> = <a href="SymbolTable.scala.html#64801" title="=&gt; Types.this.Period">currentPeriod</a> 
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64811" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#453057" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> 
          <a href="#133359" title="(x$1: List[Types.this.Type])Unit">parentsCache</a> = <a href="#133392" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#105322" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#133390" title="(tp: Types.this.Type)Types.this.Type">transform</a> 
        <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133359" title="=&gt; List[Types.this.Type]">parentsCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// seems this can happen if things are currupted enough, see #2641 </span>
          <a href="#133359" title="(x$1: List[Types.this.Type])Unit">parentsCache</a> = <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span> 
        <span class="delimiter">}</span> 
      <span class="delimiter">}</span> 
      <a href="#133359" title="=&gt; List[Types.this.Type]">parentsCache</a> 
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133400">typeOfThis</a> = <a href="#133390" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107458" title="=&gt; Types.this.Type">typeOfThis</a><span class="delimiter">)</span>

<span class="comment">/*
    override def narrow =
      if (sym.isModuleClass) transform(sym.thisType) 
      else if (sym.isAliasType) normalize.narrow      
      else super.narrow
*/</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133401">narrow</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isModuleClass</span><span class="delimiter">)</span> <a href="#67468" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#133453" title="=&gt; Types.this.Type">pre</a>, <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Types.this.Symbol">sourceModule</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <a href="#133415" title="=&gt; Types.this.Type">normalize</a>.<a href="#105320" title="=&gt; Types.this.Type">narrow</a>      
      <span class="keyword">else</span> <a href="#133425" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105320" title="=&gt; Types.this.Type">narrow</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133402">prefix</a>: <a href="#67381" title="Types.this.Type">Type</a> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <a href="#133415" title="=&gt; Types.this.Type">normalize</a>.<a href="#105323" title="=&gt; Types.this.Type">prefix</a>
      <span class="keyword">else</span> <a href="#133453" title="=&gt; Types.this.Type">pre</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="133403">typeArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#133455" title="=&gt; List[Types.this.Type]">args</a>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="133404">typeArgsOrDummies</a> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#133409" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#133455" title="=&gt; List[Types.this.Type]">args</a> <span class="keyword">else</span> <a href="#133406" title="=&gt; List[Types.this.Type]">dummyArgs</a>
    <span class="comment">// def hasFishyArgs = args == dummyArgs</span>

    <span class="comment">// @MAT was typeSymbol.unsafeTypeParams, but typeSymbol normalizes now</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="133405">typeParamsDirect</a> =
      <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#106030" title="=&gt; Boolean">isDefinitionsInitialized</a><span class="delimiter">)</span> <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>
      <span class="keyword">else</span> <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107437" title="=&gt; List[Types.this.Symbol]">unsafeTypeParams</a>

    <span class="comment">// placeholders derived from type params</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="133406">dummyArgs</a> = <span class="delimiter">{</span>
      <span class="comment">// @PP to @AM: this appears to me a place where</span>
      <span class="comment">// higher-order tparams are going off the beam.</span>
      <span class="comment">// if (sym.isAbstractType) { something goes wrong }</span>

      <span class="comment">//@M must be .typeConstructor</span>
      <a href="#133405" title="=&gt; List[Types.this.Symbol]">typeParamsDirect</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#453000" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107436" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// (!result.isEmpty) IFF isHigherKinded</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="133407">typeParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#133409" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#133405" title="=&gt; List[Types.this.Symbol]">typeParamsDirect</a> <span class="keyword">else</span> List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">// note: does not go through typeRef. There's no need to because</span>
    <span class="comment">// neither `pre` nor `sym` changes.  And there's a performance</span>
    <span class="comment">// advantage to call TypeRef directly.</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133408">typeConstructor</a> = <a href="#133347" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#133453" title="=&gt; Types.this.Type">pre</a>, <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span> 

    <span class="comment">// A reference (in a Scala program) to a type that has type</span>
    <span class="comment">// parameters, but where the reference does not include type</span>
    <span class="comment">// arguments. Note that it doesn't matter whether the symbol refers</span>
    <span class="comment">// to a java or scala symbol, it does matter whether it occurs in</span>
    <span class="comment">// java or scala code. TypeRefs w/o type params that occur in java</span>
    <span class="comment">// signatures/code are considered raw types, and are represented as</span>
    <span class="comment">// existential types.</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133409">isHigherKinded</a> = <a href="#133455" title="=&gt; List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#133405" title="=&gt; List[Types.this.Symbol]">typeParamsDirect</a>.<span title="=&gt; Boolean">nonEmpty</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="133410">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="453144">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="453145">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133409" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="453147">substTps</a> = <a href="#453144" title="List[Types.this.Symbol]">formals</a>.<span title="(that: scala.collection.GenSeq[Types.this.Symbol])List[Types.this.Symbol]">intersect</span><span class="delimiter">(</span><a href="#133407" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span>
        
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#453147" title="List[Types.this.Symbol]">substTps</a>, <a href="#133407" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#67473" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#133425" title="Types.this.TypeRef" class="keyword">this</a>, <a href="#133453" title="=&gt; Types.this.Type">pre</a>, <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>, <a href="#453145" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#453144" title="List[Types.this.Symbol]">formals</a>, <a href="#453145" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// partial application (needed in infer when bunching type arguments from classes and methods together)</span>
          <a href="#67473" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#133425" title="Types.this.TypeRef" class="keyword">this</a>, <a href="#133453" title="=&gt; Types.this.Type">pre</a>, <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>, <a href="#133406" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>.<a href="#105363" title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#453144" title="List[Types.this.Symbol]">formals</a>, <a href="#453145" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#450783" title="object Types.this.ErrorType">ErrorType</a>
      <span class="delimiter">}</span>
      <span class="keyword">else</span>
        <a href="#133425" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105339" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#453144" title="List[Types.this.Symbol]">formals</a>, <a href="#453145" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>


    <span class="comment">/** @pre: sym.info.typeParams.length == typeArgs.length */</span>
    @inline <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133411">betaReduce</a>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="comment">// isHKSubType0 introduces synthetic type params so that</span>
      <span class="comment">// betaReduce can first apply sym.info to typeArgs before calling</span>
      <span class="comment">// asSeenFrom.  asSeenFrom then skips synthetic type params, which</span>
      <span class="comment">// are used to reduce HO subtyping to first-order subtyping, but</span>
      <span class="comment">// which can't be instantiated from the given prefix and class.</span>
      <a href="#133390" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105327" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
      <span class="comment">//</span>
      <span class="comment">// this crashes pos/depmet_implicit_tpbetareduce.scala</span>
      <span class="comment">// appliedType(sym.info, typeArgs).asSeenFrom(pre, sym.owner)</span>
    <span class="delimiter">}</span>

    <span class="comment">// @M: initialize (by sym.info call) needed (see test/files/pos/ticket0137.scala)</span>
    @inline <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133412">etaExpand</a>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="453172">tpars</a> = <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105336" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span class="comment">// must go through sym.info for typeParams to initialise symbol</span>
      <a href="#67480" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFunAnon</a><span class="delimiter">(</span><a href="#453172" title="List[Types.this.Symbol]">tpars</a>, <a href="#67473" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#133425" title="Types.this.TypeRef" class="keyword">this</a>, <a href="#133453" title="=&gt; Types.this.Type">pre</a>, <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>, <a href="#453172" title="List[Types.this.Symbol]">tpars</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#453192" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107422" title="=&gt; Types.this.Type">tpeHK</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// todo: also beta-reduce?</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133413">dealias</a>: <a href="#67381" title="Types.this.Type">Type</a> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105336" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#133455" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#133411" title="=&gt; Types.this.Type">betaReduce</a>.<a href="#105343" title="=&gt; Types.this.Type">dealias</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#133425" title="Types.this.TypeRef" class="keyword">this</a>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133414">normalize0</a>: <a href="#67381" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133453" title="=&gt; Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450801" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span> <a href="#450801" title="object Types.this.WildcardType">WildcardType</a> <span class="comment">// arises when argument-dependent types are approximated (see def depoly in implicits)</span>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133409" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#133412" title="=&gt; Types.this.Type">etaExpand</a>   <span class="comment">// eta-expand, subtyping relies on eta-expansion of higher-kinded types</span>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105336" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#133455" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
                               <a href="#133411" title="=&gt; Types.this.Type">betaReduce</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a> <span class="comment">// beta-reduce, but don't do partial application -- cycles have been checked in typeRef</span>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isRefinementClass</span><span class="delimiter">)</span> 
                               <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a> <span class="comment">// I think this is okay, but see #1241 (r12414), #2208, and typedTypeConstructor in Typers</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span title="Types.this.Type" class="keyword">if</span><span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <a href="#450783" title="object Types.this.ErrorType">ErrorType</a> <span class="comment">//println(&quot;!!error: &quot;+(pre, sym, sym.info, sym.info.typeParams, args))</span>
        <span class="keyword">else</span> <a href="#133425" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a>
      <span class="delimiter">}</span>

   <span class="comment">// TODO: test case that is compiled  in a specific order and in different runs</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133415">normalize</a>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#133414" title="=&gt; Types.this.Type">normalize0</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133383" title="=&gt; Types.this.Type">normalized</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
          <a href="#133383" title="(x$1: Types.this.Type)Unit">normalized</a> = <a href="#133414" title="=&gt; Types.this.Type">normalize0</a>
        
        <a href="#133383" title="=&gt; Types.this.Type">normalized</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="133416">decls</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a> = <span class="delimiter">{</span>
      <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="453236">sym1</a>, _<span class="delimiter">)</span> =&gt;
          <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#453236" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>, <a href="#133425" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span> <span class="comment">// @MAT was != typeSymbol</span>
        <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
      <span class="delimiter">}</span>
      <a href="#133392" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#105346" title="=&gt; Types.this.Scope">decls</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="133417">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="453243">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#453243" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <a href="#133425" title="Types.this.TypeRef" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isClass</span><span class="delimiter">)</span> <a href="#133390" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105358" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#453243" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> 
        <span class="keyword">try</span> <span class="delimiter">{</span> 
          <a href="#67579" title="(x$1: Int)Unit">basetypeRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67579" title="=&gt; Int">basetypeRecursions</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(50)">LogPendingBaseTypesThreshold</span><span class="delimiter">)</span>
            <a href="#133393" title="=&gt; Types.this.Type">relativeInfo</a>.<a href="#105358" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#453243" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67581" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <span title="(elem: Types.this.Type)Boolean">contains</span> <a href="#133425" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#453243" title="Types.this.Symbol">clazz</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span> <a href="#453243" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#450850" title="object Types.this.NoType">NoType</a>
          <span class="keyword">else</span>
            <span class="keyword">try</span> <span class="delimiter">{</span>
              <a href="#67581" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <span title="(elem: Types.this.Type)Types.this.pendingBaseTypes.type">+=</span> <a href="#133425" title="Types.this.TypeRef" class="keyword">this</a>
              <a href="#133393" title="=&gt; Types.this.Type">relativeInfo</a>.<a href="#105358" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#453243" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
            <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
              <a href="#67581" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <span title="(elem: Types.this.Type)Types.this.pendingBaseTypes.type">-=</span> <a href="#133425" title="Types.this.TypeRef" class="keyword">this</a>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
          <a href="#67579" title="(x$1: Int)Unit">basetypeRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
        <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="133418">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#67693" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="453287">period</a> = <a href="#133368" title="=&gt; Int">baseTypeSeqPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#453287" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#64801" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#133368" title="(x$1: Int)Unit">baseTypeSeqPeriod</a> = <a href="SymbolTable.scala.html#64801" title="=&gt; Types.this.Period">currentPeriod</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64811" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#453287" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="../util/Statistics.scala.html#67151" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67186" title="=&gt; scala.tools.nsc.util.Statistics.Counter">typerefBaseTypeSeqCount</a><span class="delimiter">)</span>
          <a href="#133365" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="BaseTypeSeqs.scala.html#67694" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a>
          <a href="#133365" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> =
            <span title="Types.this.BaseTypeSeq" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAbstractType</span><span class="delimiter">)</span> <a href="#133390" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#133398" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>.<a href="#105383" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#197513" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">prepend</a> <a href="#133425" title="Types.this.TypeRef" class="keyword">this</a>
            <span class="keyword">else</span> <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105383" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#197515" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">map</a> <a href="#133390" title="(tp: Types.this.Type)Types.this.Type">transform</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133365" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="BaseTypeSeqs.scala.html#67694" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">throw</span> <a href="#313894" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#67658" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="java.lang.String(&quot;illegal cyclic inheritance involving &quot;)" class="string">&quot;illegal cyclic inheritance involving &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#133454" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <a href="#133365" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="133419">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#133418" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#197518" title="=&gt; Int">maxDepth</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="133420">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#133392" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#105385" title="=&gt; List[Types.this.Symbol]">baseClasses</a>

    <span class="comment">// override def isNullable: Boolean = sym.info.isNullable</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="133421">safeToString</a>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#133425" title="Types.this.TypeRef" class="keyword">this</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Nothing">TypeRef</span><span class="delimiter">(</span>_, <a href="Definitions.scala.html#106211" title="=&gt; Types.this.Symbol">RepeatedParamClass</a>, <a title="Types.this.Type" id="453319">arg</a> :: _<span class="delimiter">)</span> =&gt; <span title="Nothing" class="keyword">return</span> <a href="#453319" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">arg</a> <span title="(other: String)java.lang.String">+</span> <span title="java.lang.String(&quot;*&quot;)" class="string">&quot;*&quot;</span>
          <span class="keyword">case</span> <span title="Nothing">TypeRef</span><span class="delimiter">(</span>_, <a href="Definitions.scala.html#106224" title="=&gt; Types.this.Symbol">ByNameParamClass</a>, <a title="Types.this.Type" id="453326">arg</a> :: _<span class="delimiter">)</span>   =&gt; <span title="Nothing" class="keyword">return</span> <span title="java.lang.String(&quot;=&gt; &quot;)" class="string">&quot;=&gt; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#453326" title="Types.this.Type">arg</a>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#106352" title="(tp: Types.this.Type)Boolean">isFunctionType</a><span class="delimiter">(</span><a href="#133425" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="List[Types.this.Type]" id="453328">targs</a> = <a href="#133415" title="=&gt; Types.this.Type">normalize</a>.<a href="#105326" title="=&gt; List[Types.this.Type]">typeArgs</a>
              <span class="comment">// Aesthetics: printing Function1 as T =&gt; R rather than (T) =&gt; R</span>
              <span class="keyword">val</span> <a title="java.lang.String" id="453329">paramlist</a> = <a href="#453328" title="List[Types.this.Type]">targs</a>.<span title="=&gt; List[Types.this.Type]">init</span> <span title="java.lang.String" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="java.lang.String(&quot;()&quot;)">Nil</span>      =&gt; <span title="java.lang.String(&quot;()&quot;)" class="string">&quot;()&quot;</span>
                <span class="keyword">case</span> <a title="java.lang.String" id="453334">x</a> :: <span title="object Nil">Nil</span> =&gt; <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#453334" title="Types.this.Type">x</a>
                <span class="keyword">case</span> <a title="String" id="453335">xs</a>       =&gt; <a href="#453335" title="List[Types.this.Type]">xs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="java.lang.String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
              <span class="delimiter">}</span>
              <span title="Nothing" class="keyword">return</span> <a href="#453329" title="java.lang.String">paramlist</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; =&gt; &quot;)" class="string">&quot; =&gt; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#453328" title="List[Types.this.Type]">targs</a>.<span title="=&gt; Types.this.Type">last</span>
            <span class="delimiter">}</span>
            <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#106334" title="(tp: Types.this.Type)Boolean">isTupleTypeOrSubtype</a><span class="delimiter">(</span><a href="#133425" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> 
              <span title="Nothing" class="keyword">return</span> <a href="#133415" title="=&gt; Types.this.Type">normalize</a>.<a href="#105326" title="=&gt; List[Types.this.Type]">typeArgs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="java.lang.String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#67575" title="(xs: List[_], len: Int)Boolean">hasLength</a><span class="delimiter">(</span><a href="#133415" title="=&gt; Types.this.Type">normalize</a>.<a href="#105326" title="=&gt; List[Types.this.Type]">typeArgs</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="java.lang.String(&quot;,)&quot;)" class="string">&quot;,)&quot;</span> <span class="keyword">else</span> <span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
            <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#105324" title="=&gt; List[Types.this.Type]">prefixChain</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#453362" title="Types.this.Type">_</a>.<a href="#105312" title="=&gt; Types.this.Symbol">termSymbol</a>.<span title="=&gt; Boolean">isSynthetic</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="453363">normed</a> = <a href="#133415" title="=&gt; Types.this.Type">normalize</a>;
              <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#453363" title="Types.this.Type">normed</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#133425" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#453363" title="Types.this.Type">normed</a>.<span title="()String">toString</span>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="String" id="453310">monopart</a> = 
        <span title="String" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
            <span class="delimiter">(</span><a href="#67674" title="=&gt; scala.collection.immutable.Set[java.lang.String]">shorthands</a> <span title="(elem: java.lang.String)Boolean">contains</span> <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; String">fullName</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107403" title="=&gt; List[Types.this.Symbol]">ownerChain</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#453379" title="Types.this.Symbol">_</a>.<span title="=&gt; Boolean">isClass</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// ensure that symbol is not a local copy with a name coincidence </span>
          <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#96583" title="()String">toString</a>
        <span class="keyword">else</span> 
          <a href="#133453" title="=&gt; Types.this.Type">pre</a>.<a href="#105392" title="=&gt; java.lang.String">prefixString</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107514" title="=&gt; java.lang.String">nameString</a>
      
      <span class="keyword">var</span> <a title="java.lang.String" id="453311">str</a> = <a href="#453310" title="String">monopart</a> <span title="(x$1: Any)java.lang.String">+</span> <span class="delimiter">(</span><span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#133455" title="=&gt; List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="#133455" title="=&gt; List[Types.this.Type]">args</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="java.lang.String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="java.lang.String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span><span class="delimiter">)</span>
        <a href="#105390" title="=&gt; java.lang.String">packagePrefix</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="#453311" title="java.lang.String">str</a>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isModuleClass</span><span class="delimiter">)</span>
        <a href="#105389" title="=&gt; java.lang.String">objectPrefix</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="#453311" title="java.lang.String">str</a>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107346" title="=&gt; Boolean">isAnonymousClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107397" title="=&gt; Boolean">isInitialized</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
        <a href="#133392" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#105322" title="=&gt; List[Types.this.Type]">parents</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot; with &quot;)" class="string">&quot; with &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)java.lang.String">+</span> <span class="delimiter">{</span>
          <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107393" title="=&gt; Boolean">isStructuralRefinement</a><span class="delimiter">)</span>
            <span class="delimiter">(</span><span class="delimiter">(</span><a href="#133416" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112957" title="=&gt; List[Types.this.Symbol]">toList</a> <span title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">filter</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="453395">entry</a> =&gt;
              <span title="=&gt; Boolean">!</span><a href="#453395" title="Types.this.Symbol">entry</a>.<a href="Symbols.scala.html#107334" title="=&gt; Boolean">isConstructor</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#453395" title="Types.this.Symbol">entry</a>.<a href="Symbols.scala.html#107491" title="=&gt; List[Types.this.Symbol]">allOverriddenSymbols</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#453395" title="Types.this.Symbol">entry</a>.<span title="=&gt; Boolean">isPrivate</span>
            <span class="delimiter">}</span><span class="delimiter">)</span> <span title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],String,List[String]])List[String]">map</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="453416">entry</a> =&gt; <a href="#453416" title="Types.this.Symbol">entry</a>.<a href="Symbols.scala.html#107526" title="=&gt; String">defString</a> <span class="delimiter">}</span><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;{&quot;)" class="string">&quot;{&quot;</span>, <span title="java.lang.String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="java.lang.String(&quot;}&quot;)" class="string">&quot;}&quot;</span><span class="delimiter">)</span> 
          <span class="keyword">else</span>
            <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
        <span class="delimiter">}</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isRefinementClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107397" title="=&gt; Boolean">isInitialized</a><span class="delimiter">)</span>
        <a href="#133392" title="=&gt; Types.this.Type">thisInfo</a>.<span title="()String">toString</span>
      <span class="keyword">else</span> <a href="#453311" title="java.lang.String">str</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="133422">prefixString</a> = <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <span class="delimiter">(</span>
      <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> 
        <a href="#133425" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105392" title="=&gt; java.lang.String">prefixString</a>
      <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107359" title="=&gt; Boolean">printWithoutPrefix</a><span class="delimiter">)</span> 
        <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span><span class="delimiter">)</span> 
        <a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<span title="=&gt; String">fullName</span> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#133385" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="StdNames.scala.html#67713" title="object Types.this.nme">nme</a>.<a href="NameManglers.scala.html#115611" title="(name: Types.this.Name)Boolean">isSingletonName</a><span class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="StdNames.scala.html#67713" title="object Types.this.nme">nme</a>.<a href="NameManglers.scala.html#115623" title="(name: Types.this.Name)Types.this.TypeName">dropSingletonName</a><span title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd" class="delimiter">(</span><a href="#133454" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span> <span title="(other: String)java.lang.String">+</span> <span title="java.lang.String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      <span class="keyword">else</span> 
        <a href="#133425" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#105392" title="=&gt; java.lang.String">prefixString</a>
    <span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="133423">kind</a> = <span title="java.lang.String(&quot;TypeRef&quot;)" class="string">&quot;TypeRef&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueTypeRef extends Types.this.TypeRef with Types.this.UniqueType with ScalaObject" id="67436">UniqueTypeRef</a><a href="#67436" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="453502">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="453503">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="453504">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#133425" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">(</span><a href="#453502" title="Types.this.Type">pre</a>, <a href="#453503" title="Types.this.Symbol">sym</a>, <a href="#453504" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#67382" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object Types.this.TypeRef" id="67434">TypeRef</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24048" title="Types.this.TypeRefExtractor">TypeRefExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="133347">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="236482">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="236483">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="236484">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#67495" title="(tp: Types.this.UniqueTypeRef)Types.this.UniqueTypeRef">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueTypeRef" class="keyword">new</span> <a href="#67436" title="Types.this.UniqueTypeRef">UniqueTypeRef</a><span class="delimiter">(</span><a href="#236482" title="Types.this.Type">pre</a>, <a href="#236483" title="Types.this.Symbol">sym</a>, <a href="#236484" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class representing a method type with parameters.
   *  Note that a parameterless method is represented by a NullaryMethodType:
   *
   *    def m(): Int        MethodType(Nil, Int)
   *    def m: Int          NullaryMethodType(Int)
   */</span>
  case <span class="keyword">class</span> <a title="class MethodType extends Types.this.Type with ScalaObject with Product with Serializable" id="148698">MethodType</a><a href="#148698" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="151831">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
                        <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="151832">resultType</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67381" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148706">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#148707" title="=&gt; Boolean">isTrivial0</a>
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="148708">isTrivial0</a> =
      <a href="#151832" title="=&gt; Types.this.Type">resultType</a>.<a href="#105303" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#151831" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span><span class="delimiter">{</span><a title="Types.this.Symbol" id="453523">p</a> =&gt; <a href="#453523" title="Types.this.Symbol">p</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>.<a href="#105303" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>  <span class="delimiter">(</span>
        <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36832" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">YdepMethTpes</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#151831" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#453533" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>.<a href="#105372" title="(sym: Types.this.Symbol)Boolean">contains</a><span class="delimiter">(</span><a href="#453523" title="Types.this.Symbol">p</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#151832" title="=&gt; Types.this.Type">resultType</a>.<a href="#105372" title="(sym: Types.this.Symbol)Boolean">contains</a><span class="delimiter">(</span><a href="#453523" title="Types.this.Symbol">p</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="=&gt; Boolean" id="148709">isImplicit</a> = <a href="#151831" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#151831" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Types.this.Symbol">head</span>.<span title="=&gt; Boolean">isImplicit</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="148710">isJava</a> = <span title="Boolean(false)" class="keyword">false</span> <span class="comment">// can we do something like for implicits? I.e. do Java methods without parameters need to be recognized?</span>

    <span class="comment">//assert(paramTypes forall (pt =&gt; !pt.typeSymbol.isImplClass))//DEBUG</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148711">paramSectionCount</a>: <span title="Int">Int</span> = <a href="#151832" title="=&gt; Types.this.Type">resultType</a>.<a href="#105332" title="=&gt; Int">paramSectionCount</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="148712">paramss</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#151831" title="=&gt; List[Types.this.Symbol]">params</a> <a href="#453551" title="(x: List[Types.this.Symbol])List[List[Types.this.Symbol]]">::</a> <a href="#151832" title="=&gt; Types.this.Type">resultType</a>.<a href="#105333" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>
    
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148713">paramTypes</a> = <a href="#151831" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#412271" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="148714">boundSyms</a> = immutable.<span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#151831" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(that: scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">++</span> <a href="#151832" title="=&gt; Types.this.Type">resultType</a>.<a href="#105337" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>: _*<span class="delimiter">)</span>
    
    <span class="comment">// AM to TR: #dropNonContraintAnnotations</span>
    <span class="comment">// this is needed for plugins to work correctly, only TypeConstraint annotations are supposed to be carried over</span>
    <span class="comment">// TODO: this should probably be handled in a more structured way in adapt -- remove this map in resultType and watch the continuations tests fail</span>
    <span class="keyword">object</span> <a title="object MethodType.this.dropNonContraintAnnotations" id="148715">dropNonContraintAnnotations</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="261981">dropNonConstraintAnnotations</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">def</span> <a title="(x: Types.this.Type)Types.this.Type" id="261983">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="261984">x</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#261984" title="Types.this.Type">x</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(actuals: List[Types.this.Type])Types.this.Type" id="148717">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="261971">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#148706" title="=&gt; Boolean">isTrivial</a><span class="delimiter">)</span> <a href="#261983" title="(x: Types.this.Type)Types.this.Type">dropNonContraintAnnotations</a><span class="delimiter">(</span><a href="#151832" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#261971" title="List[Types.this.Type]">actuals</a>, <a href="#151831" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.InstantiateDependentMap" id="262046">idm</a> = <span title="Types.this.InstantiateDependentMap" class="keyword">new</span> <a href="#67532" title="Types.this.InstantiateDependentMap">InstantiateDependentMap</a><span class="delimiter">(</span><a href="#151831" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#261971" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="262047">res</a> = <a href="#262059" title="(tp: Types.this.Type)Types.this.Type">idm</a><span class="delimiter">(</span><a href="#151832" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
          <span class="comment">// println(&quot;resultTypeDep &quot;+(params, actuals, resultType, idm.existentialsNeeded, &quot;\n= &quot;+ res))</span>
          <a href="#67482" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#262046" title="Types.this.InstantiateDependentMap">idm</a>.<a href="#262060" title="=&gt; List[Types.this.Symbol]">existentialsNeeded</a>, <a href="#262047" title="Types.this.Type">res</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="comment">// Thread.dumpStack()</span>
          <span class="comment">// println(&quot;resultType &quot;+(params, actuals, resultType))</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#151832" title="=&gt; Types.this.Type">resultType</a>
          <span class="keyword">else</span> <a href="#67482" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#151831" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#151832" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

    <span class="comment">// implicit args can only be depended on in result type: TODO this may be generalised so that the only constraint is dependencies are acyclic</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.MethodType" id="148718">approximate</a>: <a href="#148698" title="Types.this.MethodType">MethodType</a> = <a href="#148698" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#151831" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#105329" title="=&gt; Types.this.Type">resultApprox</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148719">finalResultType</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#151832" title="=&gt; Types.this.Type">resultType</a>.<a href="#105331" title="=&gt; Types.this.Type">finalResultType</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148720">safeToString</a> = <a href="TypeDebugging.scala.html#67936" title="(tp: Types.this.Type)String">paramString</a><span class="delimiter">(</span><a href="#148698" title="Types.this.MethodType" class="keyword">this</a><span class="delimiter">)</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#151832" title="=&gt; Types.this.Type">resultType</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="148721">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="453639">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="453642">vparams</a> = <a href="Symbols.scala.html#67333" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#151831" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#453639" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#67475" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#148698" title="Types.this.MethodType" class="keyword">this</a>, <a href="#453642" title="List[Types.this.Symbol]">vparams</a>, <a href="#151832" title="=&gt; Types.this.Type">resultType</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#151831" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#453642" title="List[Types.this.Symbol]">vparams</a><span class="delimiter">)</span>.<a href="#105387" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#453639" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="148722">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="453705">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#151831" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#453709" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#453705" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#151832" title="=&gt; Types.this.Type">resultType</a>.<a href="#105388" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#453705" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#151832" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#148721" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#453705" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> 
      <span class="keyword">else</span>
        <a href="#148698" title="Types.this.MethodType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148723">kind</a> = <span title="java.lang.String(&quot;MethodType&quot;)" class="string">&quot;MethodType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.MethodType" id="67438">MethodType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24048" title="Types.this.MethodTypeExtractor">MethodTypeExtractor</a>

  <span class="keyword">class</span> <a title="class JavaMethodType extends Types.this.MethodType with ScalaObject" id="67440">JavaMethodType</a><a href="#67440" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="453772">ps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="453773">rt</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#148698" title="Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#453772" title="List[Types.this.Symbol]">ps</a>, <a href="#453773" title="Types.this.Type">rt</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="453768">isJava</a> = <span title="Boolean(true)" class="keyword">true</span>
  <span class="delimiter">}</span>
  
  case <span class="keyword">class</span> <a title="class NullaryMethodType extends Types.this.Type with ScalaObject with Product with Serializable" id="148801">NullaryMethodType</a><a href="#148801" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="423813">resultType</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67381" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="comment">// AM to TR: #dropNonContraintAnnotations</span>
    <span class="comment">// change isTrivial to the commented version and watch continuations-run/t3225.scala fail</span>
    <span class="comment">// isTrivial implies asSeenFrom is bypassed, since it's supposed to be the identity map</span>
    <span class="comment">// it's not really the identity due to dropNonContraintAnnotations</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148806">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span> <span class="comment">//resultType.isTrivial -- `false` to make continuations plugin work (so that asSeenFromMap drops non-constrain annotations even when type doesn't change otherwise)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148807">prefix</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#423813" title="=&gt; Types.this.Type">resultType</a>.<a href="#105323" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148808">narrow</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#423813" title="=&gt; Types.this.Type">resultType</a>.<a href="#105320" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148809">finalResultType</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#423813" title="=&gt; Types.this.Type">resultType</a>.<a href="#105331" title="=&gt; Types.this.Type">finalResultType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148810">termSymbol</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <a href="#423813" title="=&gt; Types.this.Type">resultType</a>.<a href="#105312" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148811">typeSymbol</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <a href="#423813" title="=&gt; Types.this.Type">resultType</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148812">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#423813" title="=&gt; Types.this.Type">resultType</a>.<a href="#105322" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="148813">decls</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a> = <a href="#423813" title="=&gt; Types.this.Type">resultType</a>.<a href="#105346" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="148814">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#67693" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#423813" title="=&gt; Types.this.Type">resultType</a>.<a href="#105383" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148815">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#423813" title="=&gt; Types.this.Type">resultType</a>.<a href="#105384" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148816">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#423813" title="=&gt; Types.this.Type">resultType</a>.<a href="#105385" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="148817">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="453841">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#423813" title="=&gt; Types.this.Type">resultType</a>.<a href="#105358" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#453841" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="148818">boundSyms</a> = <a href="#423813" title="=&gt; Types.this.Type">resultType</a>.<a href="#105337" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148819">isVolatile</a> = <a href="#423813" title="=&gt; Types.this.Type">resultType</a>.<a href="#105306" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148820">safeToString</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;=&gt; &quot;)" class="string">&quot;=&gt; &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#423813" title="=&gt; Types.this.Type">resultType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148821">kind</a> = <span title="java.lang.String(&quot;NullaryMethodType&quot;)" class="string">&quot;NullaryMethodType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.NullaryMethodType" id="67442">NullaryMethodType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24048" title="Types.this.NullaryMethodTypeExtractor">NullaryMethodTypeExtractor</a> 

  <span class="comment">/** A type function or the type of a polymorphic value (and thus of kind *).
   *
   * Before the introduction of NullaryMethodType, a polymorphic nullary method (e.g, def isInstanceOf[T]: Boolean) 
   * used to be typed as PolyType(tps, restpe), and a monomorphic one as PolyType(Nil, restpe)
   * This is now: PolyType(tps, NullaryMethodType(restpe)) and NullaryMethodType(restpe)
   * by symmetry to MethodTypes: PolyType(tps, MethodType(params, restpe)) and MethodType(params, restpe)
   *
   * Thus, a PolyType(tps, TypeRef(...)) unambiguously indicates a type function (which results from eta-expanding a type constructor alias).
   * Similarly, PolyType(tps, ClassInfoType(...)) is a type constructor.
   * 
   * A polytype is of kind * iff its resultType is a (nullary) method type.
   */</span>
  case <span class="keyword">class</span> <a title="class PolyType extends Types.this.Type with ScalaObject with Product with Serializable" id="148857">PolyType</a><a href="#148857" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="300007">typeParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="300008">resultType</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>
       <span class="keyword">extends</span> <a href="#67381" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="comment">//assert(!(typeParams contains NoSymbol), this)</span>
    <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#300007" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="=&gt; Boolean">nonEmpty</span>, <a href="#148857" title="Types.this.PolyType" class="keyword">this</a><span class="delimiter">)</span> <span class="comment">// used to be a marker for nullary method type, illegal now (see @NullaryMethodType)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148865">paramSectionCount</a>: <span title="Int">Int</span> = <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105332" title="=&gt; Int">paramSectionCount</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="148866">paramss</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105333" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148867">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105334" title="=&gt; List[Types.this.Symbol]">params</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148868">paramTypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105335" title="=&gt; List[Types.this.Type]">paramTypes</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="148869">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105322" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="148870">decls</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a> = <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105346" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148871">termSymbol</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105312" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="148872">typeSymbol</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="148873">boundSyms</a> = immutable.<span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#300007" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(that: scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">++</span> <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105337" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>: _*<span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148874">prefix</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105323" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="148875">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#67693" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105383" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="148876">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105384" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="148877">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105385" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="148878">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454033">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105358" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#454033" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148879">narrow</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105320" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148880">isVolatile</a> = <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105306" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148881">finalResultType</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105331" title="=&gt; Types.this.Type">finalResultType</a>

    <span class="comment">/** @M: typeDefSig wraps a TypeBounds in a PolyType 
     *  to represent a higher-kinded type parameter
     *  wrap lo&amp;hi in polytypes to bind variables
     */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="148882">bounds</a>: <a href="#148453" title="Types.this.TypeBounds">TypeBounds</a> = 
      <a href="#148437" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#67481" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#300007" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148467" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, 
                 <a href="#67481" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#300007" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148883">isHigherKinded</a> = <span title="=&gt; Boolean">!</span><a href="#300007" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">isEmpty</span>
    
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148884">safeToString</a> = <a href="TypeDebugging.scala.html#67937" title="(tp: Types.this.Type)String">typeParamsString</a><span class="delimiter">(</span><a href="#148857" title="Types.this.PolyType" class="keyword">this</a><span class="delimiter">)</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#300008" title="=&gt; Types.this.Type">resultType</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.PolyType" id="148885">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454081">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="454084">tparams</a> = <a href="Symbols.scala.html#67333" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#300007" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#454081" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#148857" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#454084" title="List[Types.this.Symbol]">tparams</a>, <a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#300007" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#454084" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>.<a href="#105387" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#454081" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="148886">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454127">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#300007" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#454136" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#454127" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#300008" title="=&gt; Types.this.Type">resultType</a>.<a href="#105388" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#454127" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#300008" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#148885" title="(owner: Types.this.Symbol)Types.this.PolyType">cloneInfo</a><span class="delimiter">(</span><a href="#454127" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> 
      <span class="keyword">else</span>
        <a href="#148857" title="Types.this.PolyType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="148887">kind</a> = <span title="java.lang.String(&quot;PolyType&quot;)" class="string">&quot;PolyType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.PolyType" id="67445">PolyType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24048" title="Types.this.PolyTypeExtractor">PolyTypeExtractor</a> 

  case <span class="keyword">class</span> <a title="class ExistentialType extends Types.this.Type with Types.this.RewrappingTypeProxy with ScalaObject with Product with Serializable" id="149074">ExistentialType</a><a href="#149074" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="236330">quantified</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, 
                             <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="236331">underlying</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67380" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a>
  <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="149082">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="454193">newtp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#67482" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#454193" title="Types.this.Type">newtp</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="149083">isTrivial</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="149084">isStable</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="149085">bounds</a> = <a href="#148437" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#236331" title="=&gt; Types.this.Type">underlying</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148467" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#236331" title="=&gt; Types.this.Type">underlying</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="149086">parents</a> = <a href="#236331" title="=&gt; Types.this.Type">underlying</a>.<a href="#105322" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="149087">boundSyms</a> = <a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a>.<span title="scala.collection.immutable.Set[Types.this.Symbol]">toSet</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="149088">prefix</a> = <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#236331" title="=&gt; Types.this.Type">underlying</a>.<a href="#105323" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="149089">typeArgs</a> = <a href="#236331" title="=&gt; Types.this.Type">underlying</a>.<a href="#105326" title="=&gt; List[Types.this.Type]">typeArgs</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="149090">params</a> = <a href="#236331" title="=&gt; Types.this.Type">underlying</a>.<a href="#105334" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Symbol)List[Types.this.Symbol]">mapConserve</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="454325">param</a> =&gt;
      <span class="keyword">val</span> <a title="Types.this.Type" id="454326">tpe1</a> = <a href="#149082" title="(newtp: Types.this.Type)Types.this.Type">rewrap</a><span class="delimiter">(</span><a href="#454325" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#454326" title="Types.this.Type">tpe1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#454325" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span> <a href="#454325" title="Types.this.Symbol">param</a> <span class="keyword">else</span> <a href="#454325" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#107453" title="=&gt; Types.this.Symbol">cloneSymbol</a>.<a href="Symbols.scala.html#107425" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a><span class="delimiter">(</span><a href="#454326" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="149091">paramTypes</a> = <a href="#236331" title="=&gt; Types.this.Type">underlying</a>.<a href="#105335" title="=&gt; List[Types.this.Type]">paramTypes</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="149092">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="454384">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="454385">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
<span class="comment">//      maybeRewrap(underlying.instantiateTypeParams(formals, actuals))</span>

      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="454388">quantified1</a> = <span title="Types.this.SubstTypeMap" class="keyword">new</span> <a href="#67524" title="Types.this.SubstTypeMap">SubstTypeMap</a><span class="delimiter">(</span><a href="#454384" title="List[Types.this.Symbol]">formals</a>, <a href="#454385" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span> <a href="#133283" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a> <a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="454389">underlying1</a> = <a href="#236331" title="=&gt; Types.this.Type">underlying</a>.<a href="#105339" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#454384" title="List[Types.this.Symbol]">formals</a>, <a href="#454385" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#454388" title="List[Types.this.Symbol]">quantified1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#454389" title="Types.this.Type">underlying1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#236331" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#149074" title="Types.this.ExistentialType" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#67482" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#454388" title="List[Types.this.Symbol]">quantified1</a>, <a href="#454389" title="Types.this.Type">underlying1</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#454388" title="List[Types.this.Symbol]">quantified1</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="149093">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454399">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#236331" title="=&gt; Types.this.Type">underlying</a>.<a href="#105358" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#454399" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="149094">baseTypeSeq</a> = <a href="#236331" title="=&gt; Types.this.Type">underlying</a>.<a href="#105383" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#197515" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">map</a> <a href="#148954" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="149095">isHigherKinded</a> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="149096">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454410">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="454411">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Types.this.Symbol" id="454416">mkSkolem</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454418">tparam</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.TypeSkolem" id="454419">skolem</a> = <span title="Types.this.TypeSkolem" class="keyword">new</span> <a href="Symbols.scala.html#67325" title="Types.this.TypeSkolem">TypeSkolem</a><span class="delimiter">(</span>
          <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#454410" title="Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#454418" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a> <span class="keyword">else</span> <a href="#454410" title="Types.this.Symbol">owner</a>,
          <a href="#454418" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107263" title="=&gt; Types.this.Position">pos</a>, <a href="#454418" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#96578" title="=&gt; Types.this.TypeName">toTypeName</a>, <a href="#454411" title="AnyRef">origin</a><span class="delimiter">)</span>
        <a href="#454419" title="Types.this.TypeSkolem">skolem</a>.<a href="Symbols.scala.html#107425" title="(info: Types.this.Type)skolem.type">setInfo</a><span class="delimiter">(</span><a href="#454418" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105387" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#454419" title="Types.this.TypeSkolem">skolem</a><span class="delimiter">)</span><span class="delimiter">)</span>
              .<a href="Symbols.scala.html#107412" title="(mask: Long)skolem.type">setFlag</a><span class="delimiter">(</span><a href="#454418" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107410" title="=&gt; Long">flags</a> <span title="(x: Long)Long">|</span> <span title="Long(34359738368L)">EXISTENTIAL</span><span class="delimiter">)</span>
              .<a href="Symbols.scala.html#107413" title="(mask: Long)skolem.type">resetFlag</a><span class="delimiter">(</span><span title="Long(8192L)">PARAM</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="454417">skolems</a> = <a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <a href="#454416" title="(tparam: Types.this.Symbol)Types.this.Symbol">mkSkolem</a>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="454496">skolem</a> &lt;- <a href="#454417" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)Unit">skolems</a><span class="delimiter">)</span> 
        <a href="#454496" title="Types.this.Symbol">skolem</a> <a href="Symbols.scala.html#107425" title="(info: Types.this.Type)skolem.type">setInfo</a> <a href="#454496" title="Types.this.Symbol">skolem</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#454417" title="List[Types.this.Symbol]">skolems</a><span class="delimiter">)</span>
      <a href="#236331" title="=&gt; Types.this.Type">underlying</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#454417" title="List[Types.this.Symbol]">skolems</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(available: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]" id="149097">wildcardArgsString</a><span class="delimiter">(</span><a title="Set[Types.this.Symbol]" id="454502">available</a>: <span title="Set[Types.this.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="454503">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[String]">List</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="#454503" title="List[Types.this.Type]">args</a> <span title="List[String]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="List[String]">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="454509">sym</a>, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="454510">args1</a> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#454502" title="Set[Types.this.Symbol]">available</a> <span title="(elem: Types.this.Symbol)Boolean">contains</span> <a href="#454509" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> =&gt;
        <span class="delimiter">(</span><span title="java.lang.String(&quot;_&quot;)" class="string">&quot;_&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#454509" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107520" title="(tp: Types.this.Type)String">infoString</a><span class="delimiter">(</span><a href="#454509" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#454513" title="(x: String)List[String]">::</a> <a href="#149097" title="(available: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]">wildcardArgsString</a><span class="delimiter">(</span><a href="#454502" title="Set[Types.this.Symbol]">available</a> <span title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">-</span> <a href="#454509" title="Types.this.Symbol">sym</a>, <a href="#454510" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="List[String]" id="454532">arg</a> :: <a title="List[Types.this.Type]" id="454533">args1</a> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#454532" title="Types.this.Type">arg</a> <a href="#105372" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#454540" title="Types.this.Symbol">_</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <a href="#454532" title="Types.this.Type">arg</a>.<span title="()String">toString</span> <a href="#454541" title="(x: String)List[String]">::</a> <a href="#149097" title="(available: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]">wildcardArgsString</a><span class="delimiter">(</span><a href="#454502" title="Set[Types.this.Symbol]">available</a>, <a href="#454533" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span> 
      <span class="keyword">case</span> <span title="List[Nothing]">_</span> =&gt;
        List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="149098">safeToString</a>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#454557" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107528" title="=&gt; Boolean">isSingletonExistential</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span>
        <span class="comment">// try to represent with wildcards first</span>
        <a href="#236331" title="=&gt; Types.this.Type">underlying</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="454561">pre</a>, <a title="Types.this.Symbol" id="454562">sym</a>, <a title="List[Types.this.Type]" id="454563">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#454563" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">nonEmpty</span> =&gt;
            <span class="keyword">val</span> <a title="List[String]" id="454564">wargs</a> = <a href="#149097" title="(available: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]">wildcardArgsString</a><span class="delimiter">(</span><a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a>.<span title="scala.collection.immutable.Set[Types.this.Symbol]">toSet</span>, <a href="#454563" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#454564" title="List[String]">wargs</a>, <a href="#454563" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span title="Nothing" class="keyword">return</span> <a href="#133347" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd" class="delimiter">(</span><a href="#454561" title="Types.this.Type">pre</a>, <a href="#454562" title="Types.this.Symbol">sym</a>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(other: String)java.lang.String">+</span> <a href="#454564" title="List[String]">wargs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="java.lang.String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="java.lang.String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">var</span> <a title="String" id="454554">ustr</a> = <a href="#236331" title="=&gt; Types.this.Type">underlying</a>.<span title="()String">toString</span>
      <a href="#236331" title="=&gt; Types.this.Type">underlying</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Unit">MethodType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> | NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> | PolyType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#454554" title="String">ustr</a> = <span title="java.lang.String(&quot;(&quot;)" class="string">&quot;(&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#454554" title="String">ustr</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
        <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
      <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="java.lang.String" id="454555">str</a> = 
        <a href="#454554" title="String">ustr</a><span title="(x$1: Any)java.lang.String">+</span><span class="delimiter">(</span><a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(f: Types.this.Symbol =&gt; java.lang.String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],java.lang.String,List[java.lang.String]])List[java.lang.String]">map</span> <span class="delimiter">(</span><a href="#454592" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107529" title="=&gt; java.lang.String">existentialToString</a><span class="delimiter">)</span> <span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot; forSome { &quot;)" class="string">&quot; forSome { &quot;</span>, <span title="java.lang.String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="java.lang.String(&quot; }&quot;)" class="string">&quot; }&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/StandardScalaSettings.scala.html#36875" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">explaintypes</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="java.lang.String(&quot;(&quot;)" class="string">&quot;(&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#454555" title="java.lang.String">str</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <span class="keyword">else</span> <a href="#454555" title="java.lang.String">str</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.ExistentialType" id="149099">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454628">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="454631">tparams</a> = <a href="Symbols.scala.html#67333" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#454628" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#149074" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">ExistentialType</a><span class="delimiter">(</span><a href="#454631" title="List[Types.this.Symbol]">tparams</a>, <a href="#236331" title="=&gt; Types.this.Type">underlying</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#454631" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="149100">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454670">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#454674" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#454670" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#149099" title="(owner: Types.this.Symbol)Types.this.ExistentialType">cloneInfo</a><span class="delimiter">(</span><a href="#454670" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#149074" title="Types.this.ExistentialType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="149101">kind</a> = <span title="java.lang.String(&quot;ExistentialType&quot;)" class="string">&quot;ExistentialType&quot;</span>

    <span class="keyword">def</span> <a title="(op: Types.this.Type =&gt; Boolean)Boolean" id="149102">withTypeVars</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="454683">op</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#149103" title="(op: Types.this.Type =&gt; Boolean, depth: Int)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#454683" title="Types.this.Type =&gt; Boolean">op</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="(op: Types.this.Type =&gt; Boolean, depth: Int)Boolean" id="149103">withTypeVars</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="454689">op</a>: Type =&gt; Boolean, <a title="Int" id="454690">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="454692">quantifiedFresh</a> = <a href="Symbols.scala.html#67330" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.TypeVar]" id="454693">tvars</a> = <a href="#454692" title="List[Types.this.Symbol]">quantifiedFresh</a> <span title="(f: Types.this.Symbol =&gt; Types.this.TypeVar)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.TypeVar,List[Types.this.TypeVar]])List[Types.this.TypeVar]">map</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="454745">tparam</a> =&gt; <a href="#448918" title="(tparam: Types.this.Symbol)Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#454745" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="454694">underlying1</a> = <a href="#236331" title="=&gt; Types.this.Type">underlying</a>.<a href="#105339" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#236330" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#454693" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span> <span class="comment">// fuse subst quantified -&gt; quantifiedFresh -&gt; tvars</span>
      <a href="#454689" title="(v1: Types.this.Type)Boolean">op</a><span class="delimiter">(</span><a href="#454694" title="Types.this.Type">underlying1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
        <a href="#67613" title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean, depth: Int)Boolean">solve</a><span class="delimiter">(</span><a href="#454693" title="List[Types.this.TypeVar]">tvars</a>, <a href="#454692" title="List[Types.this.Symbol]">quantifiedFresh</a>, <a href="#454692" title="List[Types.this.Symbol]">quantifiedFresh</a> <span title="(f: Types.this.Symbol =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Int,List[Int]])List[Int]">map</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="454856">x</a> =&gt; <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span>, <a href="#454690" title="Int">depth</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <a href="#67614" title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])Boolean">isWithinBounds</a><span class="delimiter">(</span><a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a>, <a href="#454692" title="List[Types.this.Symbol]">quantifiedFresh</a>, <a href="#454693" title="List[Types.this.TypeVar]">tvars</a> <span title="(f: Types.this.TypeVar =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeVar],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#454905" title="Types.this.TypeVar">_</a>.<a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449326" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.ExistentialType" id="67448">ExistentialType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24048" title="Types.this.ExistentialTypeExtractor">ExistentialTypeExtractor</a> 

  <span class="comment">/** A class containing the alternatives and type prefix of an overloaded symbol.
   *  Not used after phase `typer'.
   */</span>
  case <span class="keyword">class</span> <a title="class OverloadedType extends Types.this.Type with ScalaObject with Product with Serializable" id="251432">OverloadedType</a><a href="#251432" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="444512">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="444513">alternatives</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67381" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="251440">prefix</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#444512" title="=&gt; Types.this.Type">pre</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="251441">safeToString</a> =
      <span class="delimiter">(</span><a href="#444513" title="=&gt; List[Types.this.Symbol]">alternatives</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#444512" title="=&gt; Types.this.Type">pre</a>.<a href="#105361" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="java.lang.String(&quot; &lt;and&gt; &quot;)" class="string">&quot; &lt;and&gt; &quot;</span>, <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="251442">kind</a> = <span title="java.lang.String(&quot;OverloadedType&quot;)" class="string">&quot;OverloadedType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class remembering a type instantiation for some a set of overloaded
   *  polymorphic symbols.
   *  Not used after phase `typer'.
   */</span>
  case <span class="keyword">class</span> <a title="class AntiPolyType extends Types.this.Type with ScalaObject with Product with Serializable" id="455099">AntiPolyType</a><a href="#455099" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="456745">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="List[Types.this.Type]" id="456746">targs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67381" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="455063">safeToString</a> =
      <a href="#456745" title="=&gt; Types.this.Type">pre</a>.<span title="()String">toString</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#456746" title="=&gt; List[Types.this.Type]">targs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;(with type arguments &quot;)" class="string">&quot;(with type arguments &quot;</span>, <span title="java.lang.String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="455064">memberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="455077">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#67478" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#456745" title="=&gt; Types.this.Type">pre</a>.<a href="#105361" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#455077" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>, <a href="#456746" title="=&gt; List[Types.this.Type]">targs</a><span class="delimiter">)</span>
<span class="comment">//     override def memberType(sym: Symbol) = pre.memberType(sym) match {</span>
<span class="comment">//       case PolyType(tparams, restp) =&gt; </span>
<span class="comment">//         restp.subst(tparams, targs)</span>
<span class="comment">// /* I don't think this is needed, as existential types close only over value types</span>
<span class="comment">//       case ExistentialType(tparams, qtpe) =&gt; </span>
<span class="comment">//         existentialAbstraction(tparams, qtpe.memberType(sym))</span>
<span class="comment">// */ </span>
<span class="comment">//       case ErrorType =&gt; </span>
<span class="comment">//         ErrorType</span>
<span class="comment">//     }</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="455065">kind</a> = <span title="java.lang.String(&quot;AntiPolyType&quot;)" class="string">&quot;AntiPolyType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">//private var tidCount = 0  //DEBUG</span>

  <span class="comment">//@M </span>
  <span class="comment">// a TypeVar used to be a case class with only an origin and a constr</span>
  <span class="comment">// then, constr became mutable (to support UndoLog, I guess),</span>
  <span class="comment">// but pattern-matching returned the original constr0 (a bug)</span>
  <span class="comment">// now, pattern-matching returns the most recent constr</span>
  <span class="keyword">object</span> <a title="object Types.this.TypeVar" id="67456">TypeVar</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="comment">// encapsulate suspension so we can automatically link the suspension of cloned</span>
    <span class="comment">// typevars to their original if this turns out to be necessary</span>
<span class="comment">/*
    def Suspension = new Suspension
    class Suspension {
      private val suspended = mutable.HashSet[TypeVar]()
      def suspend(tv: TypeVar): Unit = {
        tv.suspended = true
        suspended += tv
      }
      def resumeAll(): Unit = {
        for (tv &lt;- suspended) {
          tv.suspended = false
        }
        suspended.clear()
      }
    }
*/</span>
    <span class="keyword">def</span> <a title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]" id="448916">unapply</a><span class="delimiter">(</span><a title="Types.this.TypeVar" id="448920">tv</a>: <a href="#67458" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">)</span>: <span title="Some[(Types.this.Type, Types.this.TypeConstraint)]">Some</span><span class="delimiter">[</span><span class="delimiter">(</span>Type, TypeConstraint<span class="delimiter">)</span><span class="delimiter">]</span> = <span title="(x: (Types.this.Type, Types.this.TypeConstraint))Some[(Types.this.Type, Types.this.TypeConstraint)]">Some</span><span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.TypeConstraint)(Types.this.Type, Types.this.TypeConstraint)" class="delimiter">(</span><a href="#448920" title="Types.this.TypeVar">tv</a>.<a href="#454754" title="=&gt; Types.this.Type">origin</a>, <a href="#448920" title="Types.this.TypeVar">tv</a>.<a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(origin: Types.this.Type, constr: Types.this.TypeConstraint)Types.this.TypeVar" id="448917">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="454770">origin</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.TypeConstraint" id="454771">constr</a>: <a href="#67502" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">)</span> = <span title="Types.this.TypeVar" class="keyword">new</span> <a href="#67458" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#454770" title="Types.this.Type">origin</a>, <a href="#454771" title="Types.this.TypeConstraint">constr</a>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="comment">// TODO why not initialise TypeConstraint with bounds of tparam?</span>
    <span class="comment">// @PP: I tried that, didn't work out so well for me.</span>
    <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Types.this.TypeVar" id="448918">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="454758">tparam</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span title="Types.this.TypeVar" class="keyword">new</span> <a href="#67458" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#454758" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107422" title="=&gt; Types.this.Type">tpeHK</a>, <a href="#449307" title="()Types.this.TypeConstraint" class="keyword">new</a> <a href="#67502" title="Types.this.TypeConstraint">TypeConstraint</a>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#454758" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span> 
    <span class="keyword">def</span> <a title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar" id="448919">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="454748">origin</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.TypeConstraint" id="454749">constr</a>: <a href="#67502" title="Types.this.TypeConstraint">TypeConstraint</a>, <a title="List[Types.this.Type]" id="454750">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="454751">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> =
      <span title="Types.this.TypeVar" class="keyword">new</span> <a href="#67458" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#454748" title="Types.this.Type">origin</a>, <a href="#454749" title="Types.this.TypeConstraint">constr</a>, <a href="#454750" title="List[Types.this.Type]">args</a>, <a href="#454751" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/** A class representing a type variable 
   * Not used after phase `typer'.
   * A higher-kinded type variable has type arguments (a list of Type's) and type parameters (list of Symbols)
   * A TypeVar whose list of args is non-empty can only be instantiated by a higher-kinded type that can be applied to these args   
   * a typevar is much like a typeref, except it has special logic for type equality/subtyping
   */</span>
  <span class="keyword">class</span> <a title="class TypeVar extends Types.this.Type with ScalaObject" id="67458">TypeVar</a><a href="#67458" title="ScalaObject" class="delimiter">(</a><span class="keyword">val</span> <a title="Types.this.Type" id="454754">origin</a>: <a href="#67381" title="Types.this.Type">Type</a>, <span class="keyword">val</span> <a title="Types.this.TypeConstraint" id="454755">constr0</a>: <a href="#67502" title="Types.this.TypeConstraint">TypeConstraint</a>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Type]" id="454756">typeArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="454757">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67381" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="comment">// params are needed to keep track of variance (see mapOverArgs in SubstMap)</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#454756" title="=&gt; List[Types.this.Type]">typeArgs</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#454756" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#454757" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="comment">// var tid = { tidCount += 1; tidCount } //DEBUG</span>

    <span class="comment">/** The constraint associated with the variable */</span>
    <span class="keyword">var</span> <a title="Types.this.TypeConstraint" id="448938">constr</a> = <a href="#454755" title="=&gt; Types.this.TypeConstraint">constr0</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="448940">instValid</a> = <a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449328" title="=&gt; Boolean">instValid</a>
    
    <span class="comment">/** The variable's skolemization level */</span>
    <span class="keyword">val</span> <a title="Int" id="448941">level</a> = <a href="#67370" title="=&gt; Int">skolemizationLevel</a>

    <span class="comment">/**
     *  two occurrences of a higher-kinded typevar, e.g. ?CC[Int] and ?CC[String], correspond to 
     *  *two instances* of TypeVar that share the *same* TypeConstraint
     *  constr for ?CC only tracks type constructors anyway, so when ?CC[Int] &lt;:&lt; List[Int] and ?CC[String] &lt;:&lt; Iterable[String]
     *  ?CC's hibounds contains List and Iterable
     */</span>
    <span class="keyword">def</span> <a title="(newArgs: List[Types.this.Type])Types.this.TypeVar" id="448943">applyArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="455164">newArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67458" title="Types.this.TypeVar">TypeVar</a> =
      <span title="Types.this.TypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#455164" title="List[Types.this.Type]">newArgs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#67458" title="Types.this.TypeVar" class="keyword">this</a> <span class="comment">// SubstMap relies on this (though this check is redundant when called from appliedType...)</span>
      <span class="keyword">else</span> <a href="#448919" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#454754" title="=&gt; Types.this.Type">origin</a>, <a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>, <a href="#455164" title="List[Types.this.Type]">newArgs</a>, <a href="#454757" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span> <span class="comment">// @M TODO: interaction with undoLog??</span>
        <span class="comment">// newArgs.length may differ from args.length (could've been empty before)</span>
      <span class="comment">// example: when making new typevars, you start out with C[A], then you replace C by ?C, which should yield ?C[A], then A by ?A, ?C[?A]</span>
      <span class="comment">// we need to track a TypeVar's arguments, and map over them (see TypeMap::mapOver)</span>
      <span class="comment">// TypeVars get applied to different arguments over time (in asSeenFrom)</span>
       <span class="comment">// -- see pos/tcpoly_infer_implicit_tuplewrapper.scala</span>
      <span class="comment">// thus: make new TypeVar's for every application of a TV to args,</span>
      <span class="comment">// inference may generate several TypeVar's for a single type parameter that must be inferred,</span>
      <span class="comment">// only one of them is in the set of tvars that need to be solved, but</span>
      <span class="comment">// they share the same TypeConstraint instance</span>

    <span class="comment">// &lt;region name=&quot;constraint mutators + undoLog&quot;&gt;</span>
    <span class="comment">// invariant: before mutating constr, save old state in undoLog (undoLog is used to reset constraints to avoid piling up unrelated ones)</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="448944">setInst</a><span class="delimiter">(</span><a title="Types.this.Type" id="455172">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
<span class="comment">//      assert(!(tp containsTp this), this)</span>
      <a href="#67372" title="object Types.this.undoLog">undoLog</a> <a href="#106740" title="(tv: Types.this.TypeVar)Unit">record</a> <a href="#67458" title="Types.this.TypeVar" class="keyword">this</a>
      <a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449326" title="(x$1: Types.this.Type)Unit">inst</a> = <a href="#455172" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="448945">addLoBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="455174">tp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Boolean" id="455177">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#455174" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#67458" title="Types.this.TypeVar" class="keyword">this</a><span class="delimiter">)</span> <span class="comment">// implies there is a cycle somewhere (?)</span>
      <span class="comment">//println(&quot;addLoBound: &quot;+(safeToString, debugString(tp))) //DEBUG</span>
      <a href="#67372" title="object Types.this.undoLog">undoLog</a> <a href="#106740" title="(tv: Types.this.TypeVar)Unit">record</a> <a href="#67458" title="Types.this.TypeVar" class="keyword">this</a>
      <a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449322" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a><span class="delimiter">(</span><a href="#455174" title="Types.this.Type">tp</a>, <a href="#455177" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="448946">addHiBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="455188">tp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Boolean" id="455191">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// assert(tp != this)</span>
      <span class="comment">//println(&quot;addHiBound: &quot;+(safeToString, debugString(tp))) //DEBUG</span>
      <a href="#67372" title="object Types.this.undoLog">undoLog</a> <a href="#106740" title="(tv: Types.this.TypeVar)Unit">record</a> <a href="#67458" title="Types.this.TypeVar" class="keyword">this</a>
      <a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449323" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a><span class="delimiter">(</span><a href="#455188" title="Types.this.Type">tp</a>, <a href="#455191" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="comment">// &lt;/region&gt;</span>

    <span class="comment">// ignore subtyping&amp;equality checks while true -- see findMember</span>
    <span class="keyword">private</span><span class="delimiter">[</span>Types<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Boolean" id="448948">suspended</a> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** Called when a TypeVar is involved in a subtyping check.  Result is whether
     *  this TypeVar could plausibly be a [super/sub]type of argument `tp` and if so,
     *  tracks tp as a [lower/upper] bound of this TypeVar.
     *
     *  if (isLowerBound)   this typevar could be a subtype, track tp as a lower bound
     *  if (!isLowerBound)  this typevar could be a supertype, track tp as an upper bound
     *
     *  If isNumericBound is true, the subtype check is performed with weak_&lt;:&lt; instead of &lt;:&lt;.
     */</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean" id="448950">registerBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="450147">tp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Boolean" id="450148">isLowerBound</a>: <span title="Boolean">Boolean</span>, <a title="Boolean" id="450151">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="comment">// println(&quot;regBound: &quot;+(safeToString, debugString(tp), isLowerBound)) //@MDEBUG</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450148" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#450147" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#67458" title="Types.this.TypeVar" class="keyword">this</a><span class="delimiter">)</span>

      <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="455196">checkSubtypeLower</a><span class="delimiter">(</span><a title="Types.this.Type" id="455208">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="455209">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#450151" title="Boolean">isNumericBound</a><span class="delimiter">)</span> <a href="#455208" title="Types.this.Type">tp1</a> <a href="#105378" title="(that: Types.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#455209" title="Types.this.Type">tp2</a>
        <span class="keyword">else</span> <a href="#455208" title="Types.this.Type">tp1</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#455209" title="Types.this.Type">tp2</a>
      
      <span class="comment">// swaps the arguments if it's an upper bound</span>
      <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="455197">checkSubtype</a><span class="delimiter">(</span><a title="Types.this.Type" id="455210">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="455211">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#450148" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#455196" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">checkSubtypeLower</a><span class="delimiter">(</span><a href="#455210" title="Types.this.Type">tp1</a>, <a href="#455211" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#455196" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">checkSubtypeLower</a><span class="delimiter">(</span><a href="#455211" title="Types.this.Type">tp2</a>, <a href="#455210" title="Types.this.Type">tp1</a><span class="delimiter">)</span>

      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="455198">addBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="455212">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span> 
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#450148" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#448945" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a><span class="delimiter">(</span><a href="#455212" title="Types.this.Type">tp</a>, <a href="#450151" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#448946" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a><span class="delimiter">(</span><a href="#455212" title="Types.this.Type">tp</a>, <a href="#450151" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
        <span class="comment">// println(&quot;addedBound: &quot;+(this, tp)) // @MDEBUG</span>
        <span title="Boolean(true)" class="keyword">true</span>
      <span class="delimiter">}</span>
      
      <span class="comment">/** Simple case: type arguments can be ignored, because either this typevar has
       *  no type parameters, or we are comparing to Any/Nothing.
       *
       *  The latter condition is needed because HK unification is limited to constraints of the shape
       *    TC1[T1,..., TN] &lt;: TC2[T'1,...,T'N]
       *  which would preclude the following important constraints:
       *    Nothing &lt;: ?TC[?T]
       *    ?TC[?T] &lt;: Any
       */</span>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="455199">unifySimple</a> = <span class="delimiter">(</span><a href="#454757" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#450147" title="Types.this.Type">tp</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="#450147" title="Types.this.Type">tp</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
        <a href="#455198" title="(tp: Types.this.Type)Boolean">addBound</a><span class="delimiter">(</span><a href="#450147" title="Types.this.Type">tp</a><span class="delimiter">)</span>

      <span class="comment">/** Full case: involving a check of the form
       *    TC1[T1,..., TN] &lt;: TC2[T'1,...,T'N]
       *  Checks subtyping of higher-order type vars, and uses variances as defined in the
       *  type parameter we're trying to infer (the result will be sanity-checked later)
       */</span>
      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="455200">unifyFull</a><span class="delimiter">(</span><a title="Types.this.Type" id="455223">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#454756" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#455223" title="Types.this.Type">tp</a>.<a href="#105326" title="=&gt; List[Types.this.Type]">typeArgs</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span> <span class="comment">// this is a higher-kinded type var with same arity as tp</span>
        <span class="comment">// side effect: adds the type constructor itself as a bound</span>
        <a href="#455198" title="(tp: Types.this.Type)Boolean">addBound</a><span class="delimiter">(</span><a href="#455223" title="Types.this.Type">tp</a>.<a href="#105325" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#450148" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#67599" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean">isSubArgs</a><span class="delimiter">(</span><a href="#455223" title="Types.this.Type">tp</a>.<a href="#105326" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#454756" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#454757" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#67599" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean">isSubArgs</a><span class="delimiter">(</span><a href="#454756" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#455223" title="Types.this.Type">tp</a>.<a href="#105326" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#454757" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="comment">/** TODO: need positive/negative test cases demonstrating this is correct.
       */</span>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="455201">unifyParents</a> =
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#450148" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#450147" title="Types.this.Type">tp</a>.<a href="#105322" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <a href="#455200" title="(tp: Types.this.Type)Boolean">unifyFull</a>
        <span class="keyword">else</span> <a href="#450147" title="Types.this.Type">tp</a>.<a href="#105322" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <a href="#455200" title="(tp: Types.this.Type)Boolean">unifyFull</a>        
      
      <span class="comment">// TODO: fancier unification, maybe rewrite constraint as follows?</span>
      <span class="comment">// val sym = constr.hiBounds map {_.typeSymbol} find { _.typeParams.length == typeArgs.length}</span>
      <span class="comment">// this &lt;: tp.baseType(sym)</span>
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#448948" title="=&gt; Boolean">suspended</a><span class="delimiter">)</span> <a href="#455197" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">checkSubtype</a><span class="delimiter">(</span><a href="#450147" title="Types.this.Type">tp</a>, <a href="#454754" title="=&gt; Types.this.Type">origin</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449328" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#455197" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">checkSubtype</a><span class="delimiter">(</span><a href="#450147" title="Types.this.Type">tp</a>, <a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449326" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>  <span class="comment">// type var is already set</span>
      <span class="keyword">else</span> <a href="#448953" title="(tp: Types.this.Type)Boolean">isRelatable</a><span class="delimiter">(</span><a href="#450147" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span> <span class="comment">// gradually let go of some type precision in hopes of finding a type that has the same shape as the type variable</span>
        <span class="comment">// okay, this just screams &quot;CLEAN ME UP&quot; -- I think we could use tp.widen instead of tp straight from the get-go in registerBound, since we don't infer singleton types anyway (but maybe that'll change?)</span>
        <a href="#455199" title="=&gt; Boolean">unifySimple</a> <span title="(x: Boolean)Boolean">||</span> <a href="#455200" title="(tp: Types.this.Type)Boolean">unifyFull</a><span class="delimiter">(</span><a href="#450147" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#455200" title="(tp: Types.this.Type)Boolean">unifyFull</a><span class="delimiter">(</span><a href="#450147" title="Types.this.Type">tp</a>.<a href="#105343" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#455200" title="(tp: Types.this.Type)Boolean">unifyFull</a><span class="delimiter">(</span><a href="#450147" title="Types.this.Type">tp</a>.<a href="#105317" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#455200" title="(tp: Types.this.Type)Boolean">unifyFull</a><span class="delimiter">(</span><a href="#450147" title="Types.this.Type">tp</a>.<a href="#105317" title="=&gt; Types.this.Type">widen</a>.<a href="#105343" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#455201" title="=&gt; Boolean">unifyParents</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean" id="448951">registerTypeEquality</a><span class="delimiter">(</span><a title="Types.this.Type" id="455250">tp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Boolean" id="455251">typeVarLHS</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="comment">//println(&quot;regTypeEq: &quot;+(safeToString, debugString(tp), typeVarLHS)) //@MDEBUG</span>
      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="455253">checkIsSameType</a><span class="delimiter">(</span><a title="Types.this.Type" id="455254">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = 
        <span title="Boolean" class="keyword">if</span><span class="delimiter">(</span><a href="#455251" title="Boolean">typeVarLHS</a><span class="delimiter">)</span> <a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449326" title="=&gt; Types.this.Type">inst</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#455254" title="Types.this.Type">tp</a>
        <span class="keyword">else</span>           <a href="#455254" title="Types.this.Type">tp</a>          <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449326" title="=&gt; Types.this.Type">inst</a>

      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#448948" title="=&gt; Boolean">suspended</a><span class="delimiter">)</span> <a href="#455250" title="Types.this.Type">tp</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#454754" title="=&gt; Types.this.Type">origin</a>
      <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449328" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#455253" title="(tp: Types.this.Type)Boolean">checkIsSameType</a><span class="delimiter">(</span><a href="#455250" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#448953" title="(tp: Types.this.Type)Boolean">isRelatable</a><span class="delimiter">(</span><a href="#455250" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="455255">newInst</a> = <a href="#455257" title="(tp: Types.this.Type)Types.this.Type">wildcardToTypeVarMap</a><span class="delimiter">(</span><a href="#455250" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449324" title="(tp: Types.this.Type)Boolean">isWithinBounds</a><span class="delimiter">(</span><a href="#455255" title="Types.this.Type">newInst</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#448944" title="(tp: Types.this.Type)Unit">setInst</a><span class="delimiter">(</span><a href="#455250" title="Types.this.Type">tp</a><span class="delimiter">)</span>
          <span title="Boolean(true)" class="keyword">true</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Boolean(false)" class="keyword">false</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * ?A.T =:= tp is rewritten as the constraint ?A &lt;: {type T = tp}
     *
     * TODO: make these constraints count (incorporate them into implicit search in applyImplicitArgs)
     * (T corresponds to @param sym)
     */</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, tp: Types.this.Type)Boolean" id="448952">registerTypeSelection</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="455264">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="455265">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="455267">bound</a> = <a href="#67470" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><span title="(xs: Types.this.WildcardType.type*)List[Types.this.WildcardType.type]">List</span><span class="delimiter">(</span><a href="#450801" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span>, <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.TypeSymbol" id="455268">bsym</a> = <a href="#455267" title="Types.this.Type">bound</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107297" title="(pos: Types.this.Position, name: Types.this.TypeName)Types.this.TypeSymbol">newAliasType</a><span class="delimiter">(</span><a href="Positions.scala.html#67891" title="=&gt; tools.nsc.util.NoPosition.type">NoPosition</a>, <a href="#455264" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#96578" title="=&gt; Types.this.TypeName">toTypeName</a><span class="delimiter">)</span>
      <a href="#455268" title="Types.this.TypeSymbol">bsym</a> <a href="Symbols.scala.html#107425" title="(info: Types.this.Type)bsym.type">setInfo</a> <a href="#455265" title="Types.this.Type">tp</a>
      <a href="#455267" title="Types.this.Type">bound</a>.<a href="#105346" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#112946" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#455268" title="Types.this.TypeSymbol">bsym</a>
      <a href="#448950" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#455267" title="Types.this.Type">bound</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Can this variable be related in a constraint to type `tp'?
     *  This is not the case if `tp' contains type skolems whose
     *  skolemization level is higher than the level of this variable.
     */</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="448953">isRelatable</a><span class="delimiter">(</span><a title="Types.this.Type" id="455248">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <span title="=&gt; Boolean">!</span><a href="#455248" title="Types.this.Type">tp</a>.<a href="#105371" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">{</span> <a title="Types.this.Type" id="455309">t</a> =&gt;
        <a href="#455309" title="Types.this.Type">t</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="455310">ts</a>: <a href="Symbols.scala.html#67325" title="Types.this.TypeSkolem">TypeSkolem</a> =&gt; <a href="#455310" title="Types.this.TypeSkolem">ts</a>.<a href="Symbols.scala.html#444737" title="=&gt; Int">level</a> <span title="(x: Int)Boolean">&gt;</span> <a href="#448941" title="=&gt; Int">level</a>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="448954">isHigherKinded</a> = <a href="#454756" title="=&gt; List[Types.this.Type]">typeArgs</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#454757" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Boolean">nonEmpty</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="448956">normalize</a>: <a href="#67381" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449328" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449326" title="=&gt; Types.this.Type">inst</a>
      <span class="comment">// get here when checking higher-order subtyping of the typevar by itself</span>
      <span class="comment">// TODO: check whether this ever happens?</span>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#448954" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#67481" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#454757" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#448943" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#454757" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#455333" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107436" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#67458" title="Types.this.TypeVar" class="keyword">super</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="448957">typeSymbol</a> = <a href="#454754" title="=&gt; Types.this.Type">origin</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448958">isStable</a> = <a href="#454754" title="=&gt; Types.this.Type">origin</a>.<a href="#105305" title="=&gt; Boolean">isStable</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="448959">isVolatile</a> = <a href="#454754" title="=&gt; Types.this.Type">origin</a>.<a href="#105306" title="=&gt; Boolean">isVolatile</a>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Any" id="448960">levelString</a> = <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/StandardScalaSettings.scala.html#36875" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">explaintypes</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#448941" title="=&gt; Int">level</a> <span class="keyword">else</span> <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="448961">safeToString</a> = <a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449326" title="=&gt; Types.this.Type">inst</a> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="java.lang.String" class="keyword">null</span>   =&gt; <span title="java.lang.String(&quot;&lt;null &quot;)" class="string">&quot;&lt;null &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#454754" title="=&gt; Types.this.Type">origin</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;&gt;&quot;)" class="string">&quot;&gt;&quot;</span>
      <span class="keyword">case</span> <a href="#450850" title="java.lang.String">NoType</a> =&gt; <span title="java.lang.String(&quot;?&quot;)" class="string">&quot;?&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#448960" title="=&gt; Any">levelString</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="#454754" title="=&gt; Types.this.Type">origin</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="TypeDebugging.scala.html#67938" title="(tp: Types.this.Type)String">typeArgsString</a><span class="delimiter">(</span><a href="#67458" title="Types.this.TypeVar" class="keyword">this</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="java.lang.String" id="455390">x</a>      =&gt; <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#455390" title="Types.this.Type">x</a>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="448962">kind</a> = <span title="java.lang.String(&quot;TypeVar&quot;)" class="string">&quot;TypeVar&quot;</span>

    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeVar" id="448963">cloneInternal</a> = <span class="delimiter">{</span>
      <span class="comment">// cloning a suspended type variable when it's suspended will cause the clone</span>
      <span class="comment">// to never be resumed with the current implementation</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#448948" title="=&gt; Boolean">suspended</a><span class="delimiter">)</span> 
      <a href="#448919" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#454754" title="=&gt; Types.this.Type">origin</a>, <a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a> <a href="#449329" title="=&gt; Types.this.TypeConstraint">cloneInternal</a>, <a href="#454756" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#454757" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span> <span class="comment">// @M TODO: clone args/params?</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A type carrying some annotations. Created by the typechecker
   *  when eliminating ``Annotated'' trees (see typedAnnotated).
   *
   *  @param annotations the list of annotations on the type
   *  @param underlying the type without the annotation
   *  @param selfsym a &quot;self&quot; symbol with type &lt;code&gt;underlying&lt;/code&gt;;
   *    only available if -Yself-in-annots is turned on. Can be NoSymbol
   *    if it is not used.
   */</span>
  case <span class="keyword">class</span> <a title="class AnnotatedType extends Types.this.Type with Types.this.RewrappingTypeProxy with ScalaObject with Product with Serializable" id="148952">AnnotatedType</a><a href="#148952" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="450596">annotations</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span>, 
                           <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="450597">underlying</a>: <a href="#67381" title="Types.this.Type">Type</a>,
                           <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Symbol" id="450598">selfsym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> 
  <span class="keyword">extends</span> <a href="#67380" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a> <span class="delimiter">{</span>

    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#450596" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.AnnotatedType" id="148990">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="455422">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#148952" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#450596" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>, <a href="#455422" title="Types.this.Type">tp</a>, <a href="#450598" title="=&gt; Types.this.Symbol">selfsym</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="148991">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#148992" title="=&gt; Boolean">isTrivial0</a>
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="148993">isTrivial0</a> = <a href="#450597" title="=&gt; Types.this.Type">underlying</a>.<a href="#105303" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#450596" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a> <span title="(p: Types.this.AnnotationInfo =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#455419" title="Types.this.AnnotationInfo">_</a>.<a href="AnnotationInfos.scala.html#133325" title="=&gt; Boolean">isTrivial</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="148994">safeToString</a>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="java.lang.String" id="455429">attString</a> =
        <span title="java.lang.String" class="keyword">if</span> <span class="delimiter">(</span><a href="#450596" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
          <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
        <span class="keyword">else</span>
          <a href="#450596" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot; @&quot;)" class="string">&quot; @&quot;</span>, <span title="java.lang.String(&quot; @&quot;)" class="string">&quot; @&quot;</span>, <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>

      <a href="#450597" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">underlying</a> <span title="(other: String)java.lang.String">+</span> <a href="#455429" title="java.lang.String">attString</a>
    <span class="delimiter">}</span>
    
    <span class="comment">/** Add a number of annotations to this type */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="148995">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="455434">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
      <a href="#148952" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">copy</a><span class="delimiter">(</span><a href="#455434" title="List[Types.this.AnnotationInfo]">annots</a><a href="#455449" title="(prefix: List[Types.this.AnnotationInfo])List[Types.this.AnnotationInfo]">:::</a><a href="#148952" title="AnnotatedType.this.type" class="keyword">this</a>.<a href="#450596" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a><span class="delimiter">)</span>

    <span class="comment">/** Remove any annotations from this type */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="148996">withoutAnnotations</a> = <a href="#450597" title="=&gt; Types.this.Type">underlying</a>.<a href="#105403" title="=&gt; Types.this.Type">withoutAnnotations</a>

    <span class="comment">/** Set the self symbol */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.AnnotatedType" id="148997">withSelfsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="455460">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = 
      <a href="#148952" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#450596" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>, <a href="#450597" title="=&gt; Types.this.Type">underlying</a>, <a href="#455460" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>

    <span class="comment">/** Drop the annotations on the bounds, unless but the low and high
     *  bounds are exactly tp.
     */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="148998">bounds</a>: <a href="#148453" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#450597" title="=&gt; Types.this.Type">underlying</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a> <span title="Types.this.TypeBounds" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.TypeBounds">TypeBounds</span><span class="delimiter">(</span>_: <span class="keyword">this</span>.<span class="keyword">type</span>, _: <span class="keyword">this</span>.<span class="keyword">type</span><span class="delimiter">)</span> =&gt; <a href="#148437" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#148952" title="Types.this.AnnotatedType" class="keyword">this</a>, <a href="#148952" title="Types.this.AnnotatedType" class="keyword">this</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.TypeBounds" id="455465">oftp</a>                                   =&gt; <a href="#455465" title="Types.this.TypeBounds">oftp</a>
    <span class="delimiter">}</span>

    <span class="comment">// ** Replace formal type parameter symbols with actual type arguments. * /</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="148999">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="455466">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="455467">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="455470">annotations1</a> = <a href="#450596" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="(f: Types.this.AnnotationInfo =&gt; Types.this.AnnotationInfo)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.AnnotationInfo],Types.this.AnnotationInfo,List[Types.this.AnnotationInfo]])List[Types.this.AnnotationInfo]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.AnnotationInfo,List[Types.this.AnnotationInfo]]" class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="455488">info</a> =&gt; <a href="AnnotationInfos.scala.html#134132" title="(atp: Types.this.Type, args: List[Types.this.Tree], assocs: List[(Types.this.Name, Types.this.ClassfileAnnotArg)])Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">(</span><a href="#455488" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#133313" title="=&gt; Types.this.Type">atp</a>.<a href="#105339" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span>
          <a href="#455466" title="List[Types.this.Symbol]">formals</a>, <a href="#455467" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>, <a href="#455488" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#133315" title="=&gt; List[Types.this.Tree]">args</a>, <a href="#455488" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#133317" title="=&gt; List[(Types.this.Name, Types.this.ClassfileAnnotArg)]">assocs</a><span class="delimiter">)</span>.<a href="AnnotationInfos.scala.html#133324" title="(pos: scala.tools.nsc.util.Position)Types.this.AnnotationInfo">setPos</a><span class="delimiter">(</span><a href="#455488" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#133323" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="455471">underlying1</a> = <a href="#450597" title="=&gt; Types.this.Type">underlying</a>.<a href="#105339" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#455466" title="List[Types.this.Symbol]">formals</a>, <a href="#455467" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#455470" title="List[Types.this.AnnotationInfo]">annotations1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450596" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#455471" title="Types.this.Type">underlying1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450597" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#148952" title="Types.this.AnnotatedType" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#148952" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#455470" title="List[Types.this.AnnotationInfo]">annotations1</a>, <a href="#455471" title="Types.this.Type">underlying1</a>, <a href="#450598" title="=&gt; Types.this.Symbol">selfsym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Return the base type sequence of tp, dropping the annotations, unless the base type sequence of tp
      * is precisely tp itself. */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="149000">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#67693" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
       <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="455528">oftp</a> = <a href="#450597" title="=&gt; Types.this.Type">underlying</a>.<a href="#105383" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
       <span title="Types.this.BaseTypeSeq" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#455528" title="Types.this.BaseTypeSeq">oftp</a>.<a href="BaseTypeSeqs.scala.html#197505" title="=&gt; Int">length</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="BaseTypeSeqs.scala.html#197508" title="(i: Int)Types.this.Type">oftp</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450597" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span>
         <a href="BaseTypeSeqs.scala.html#67696" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">baseTypeSingletonSeq</a><span class="delimiter">(</span><a href="#148952" title="Types.this.AnnotatedType" class="keyword">this</a><span class="delimiter">)</span>
       <span class="keyword">else</span>
         <a href="#455528" title="Types.this.BaseTypeSeq">oftp</a>
     <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="149001">kind</a> = <span title="java.lang.String(&quot;AnnotatedType&quot;)" class="string">&quot;AnnotatedType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.AnnotatedType" id="67460">AnnotatedType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24048" title="Types.this.AnnotatedTypeExtractor">AnnotatedTypeExtractor</a>

  <span class="comment">/** A class representing types with a name. When an application uses
   *  named arguments, the named argument types for calling isApplicable
   *  are represented as NamedType.
   */</span>
  case <span class="keyword">class</span> <a title="class NamedType extends Types.this.Type with ScalaObject with Product with Serializable" id="455599">NamedType</a><a href="#455599" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Name" id="465525">name</a>: <a href="Names.scala.html#66914" title="Types.this.Name">Name</a>, <a title="Types.this.Type" id="465526">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67381" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="455574">safeToString</a>: <span title="String">String</span> = <a href="#465525" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#96583" title="()String">toString</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;: &quot;)" class="string">&quot;: &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#465526" title="=&gt; Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A class representing an as-yet unevaluated type.
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class LazyType extends Types.this.Type with Types.this.AbsLazyType with ScalaObject" id="67465">LazyType</a> <a href="#67465" title="ScalaObject" class="keyword">extends</a> <a href="#67381" title="Types.this.Type">Type</a> <span class="keyword">with</span> <span title="Types.this.AbsLazyType">AbsLazyType</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="105409">kind</a> = <span title="java.lang.String(&quot;LazyType&quot;)" class="string">&quot;LazyType&quot;</span>
  <span class="delimiter">}</span>

<span class="comment">// Creators ---------------------------------------------------------------</span>

  <span class="comment">/** Rebind symbol `sym' to an overriding member in type `pre'.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol" id="67466">rebind</a><span class="delimiter">(</span><a title="Types.this.Type" id="455646">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="455647">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Types.this.Symbol" id="455649">owner</a> = <a href="#455647" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>
    <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#455649" title="Types.this.Symbol">owner</a>.<span title="=&gt; Boolean">isClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#455649" title="Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#455646" title="Types.this.Type">pre</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#455647" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107388" title="=&gt; Boolean">isEffectivelyFinal</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#455647" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isClass</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">//Console.println(&quot;rebind &quot;+pre+&quot; &quot;+sym)//DEBUG</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="455654">rebind</a> = <a href="#455646" title="Types.this.Type">pre</a>.<a href="#105355" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#455647" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107452" title="(cond: Types.this.Symbol =&gt; Boolean)Types.this.Symbol">suchThat</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="455657">sym</a> =&gt; <a href="#455657" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isType</span> <span title="(x: Boolean)Boolean">||</span> <a href="#455657" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107373" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#455654" title="Types.this.Symbol">rebind</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#455647" title="Types.this.Symbol">sym</a> 
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="comment">// Console.println(&quot;rebound &quot;+pre+&quot; &quot;+sym+&quot; to &quot;+rebind)//DEBUG</span>
        <a href="#455654" title="Types.this.Symbol">rebind</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#455647" title="Types.this.Symbol">sym</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Convert a `super' prefix to a this-type if `sym'
   *  is abstract or final.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="67467">removeSuper</a><span class="delimiter">(</span><a title="Types.this.Type" id="455662">tp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="455663">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#455662" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">SuperType</span><span class="delimiter">(</span><a title="Types.this.Type" id="455665">thistp</a>, _<span class="delimiter">)</span> =&gt;
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#455663" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107388" title="=&gt; Boolean">isEffectivelyFinal</a> <span title="(x: Boolean)Boolean">||</span> <a href="#455663" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isDeferred</span><span class="delimiter">)</span> <a href="#455665" title="Types.this.Type">thistp</a>
      <span class="keyword">else</span> <a href="#455662" title="Types.this.Type">tp</a>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <a href="#455662" title="Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The canonical creator for single-types */</span>
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="67468">singleType</a><span class="delimiter">(</span><a title="Types.this.Type" id="132514">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="132515">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
      <a href="#132515" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>.<a href="#105327" title="=&gt; Types.this.Type">resultType</a>
    <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#132515" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isRootPackage</span><span class="delimiter">)</span>
      <a href="#148190" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="Definitions.scala.html#106036" title="=&gt; Types.this.ModuleClassSymbol">RootClass</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="455669">sym1</a> = <a href="#67466" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#132514" title="Types.this.Type">pre</a>, <a href="#132515" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="455670">pre1</a> = <a href="#67467" title="(tp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">removeSuper</a><span class="delimiter">(</span><a href="#132514" title="Types.this.Type">pre</a>, <a href="#455669" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#455670" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#132514" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#455669" title="Types.this.Symbol">sym1</a> = <a href="#67466" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#455670" title="Types.this.Type">pre1</a>, <a href="#455669" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      <a href="#148267" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">SingleType</a><span class="delimiter">(</span><a href="#455670" title="Types.this.Type">pre1</a>, <a href="#455669" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** the canonical creator for a refined type with a given scope */</span>
  <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type" id="67469">refinedType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="446072">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="446073">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Scope" id="446074">decls</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a>, <a title="Types.this.Position" id="446075">pos</a>: <a href="../util/Position.scala.html#30599" title="Types.this.Position">Position</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#446072" title="List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="Definitions.scala.html#106079" title="=&gt; Types.this.Symbol">ObjectClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#446072" title="List[Types.this.Type]">parents</a>.<span title="=&gt; Types.this.Type">head</span>
    <span class="keyword">else</span> <span class="delimiter">{</span> 
      <span class="keyword">val</span> <a title="Types.this.ClassSymbol" id="455673">clazz</a> = <a href="#446073" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#107314" title="(pos: Types.this.Position)Types.this.ClassSymbol">newRefinementClass</a><span class="delimiter">(</span><a href="Positions.scala.html#67891" title="=&gt; tools.nsc.util.NoPosition.type">NoPosition</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.RefinedType" id="455674">result</a> = <a href="#148511" title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#446072" title="List[Types.this.Type]">parents</a>, <a href="#446074" title="Types.this.Scope">decls</a>, <a href="#455673" title="Types.this.ClassSymbol">clazz</a><span class="delimiter">)</span>
      <a href="#455673" title="Types.this.ClassSymbol">clazz</a>.<a href="Symbols.scala.html#107425" title="(info: Types.this.Type)clazz.type">setInfo</a><span class="delimiter">(</span><a href="#455674" title="Types.this.RefinedType">result</a><span class="delimiter">)</span>
      <a href="#455674" title="Types.this.RefinedType">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The canonical creator for a refined type with an initially empty scope.
   *
   *  @param parents ...
   *  @param owner   ...
   *  @return        ...
   */</span>
  <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type" id="67470">refinedType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="446067">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="446068">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
    <a href="#67469" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#446067" title="List[Types.this.Type]">parents</a>, <a href="#446068" title="Types.this.Symbol">owner</a>, <a href="Scopes.scala.html#112939" title="()Types.this.Scope" class="keyword">new</a> <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a>, <a href="#446068" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#107263" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type" id="67471">copyRefinedType</a><span class="delimiter">(</span><a title="Types.this.RefinedType" id="451437">original</a>: <a href="#148512" title="Types.this.RefinedType">RefinedType</a>, <a title="List[Types.this.Type]" id="451438">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="451439">decls</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a><span class="delimiter">)</span> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#451438" title="List[Types.this.Type]">parents</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#451437" title="Types.this.RefinedType">original</a>.<a href="#236305" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#451439" title="Types.this.Scope">decls</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#451437" title="Types.this.RefinedType">original</a>.<a href="#236306" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#451437" title="Types.this.RefinedType">original</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="451442">owner</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#451437" title="Types.this.RefinedType">original</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a> <span class="keyword">else</span> <a href="#451437" title="Types.this.RefinedType">original</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="451443">result</a> = <a href="#67470" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#451438" title="List[Types.this.Type]">parents</a>, <a href="#451442" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="451444">syms1</a> = <a href="#451439" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112957" title="=&gt; List[Types.this.Symbol]">toList</a>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="451476">sym</a> &lt;- <a href="#451444" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)Unit">syms1</a><span class="delimiter">)</span>
        <a href="#451443" title="Types.this.Type">result</a>.<a href="#105346" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112946" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a><span class="delimiter">(</span><a href="#451476" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107454" title="(owner: Types.this.Symbol)Types.this.Symbol">cloneSymbol</a><span class="delimiter">(</span><a href="#451443" title="Types.this.Type">result</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="451445">syms2</a> = <a href="#451443" title="Types.this.Type">result</a>.<a href="#105346" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112957" title="=&gt; List[Types.this.Symbol]">toList</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="451446">resultThis</a> = <a href="#451443" title="Types.this.Type">result</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107459" title="=&gt; Types.this.Type">thisType</a>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="451511">sym</a> &lt;- <a href="#451445" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)Unit">syms2</a><span class="delimiter">)</span>
        <a href="#451511" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107425" title="(info: Types.this.Type)sym.type">setInfo</a><span class="delimiter">(</span><a href="#451511" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105365" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#451437" title="Types.this.RefinedType">original</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#451446" title="Types.this.Type">resultThis</a><span class="delimiter">)</span>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#451444" title="List[Types.this.Symbol]">syms1</a>, <a href="#451445" title="List[Types.this.Symbol]">syms2</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#451443" title="Types.this.Type">result</a>
    <span class="delimiter">}</span>

  <span class="comment">/** The canonical creator for typerefs 
   *  todo: see how we can clean this up a bit
   */</span>
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="67472">typeRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="133221">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="133222">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="133223">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span class="comment">// type alias selections are rebound in TypeMap (&quot;coevolved&quot;, actually -- see #3731)</span>
    <span class="comment">// e.g., when type parameters that are referenced by the alias are instantiated in</span>
    <span class="comment">// the prefix.  See pos/depmet_rebind_typealias.</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol" id="455689">rebindTR</a><span class="delimiter">(</span><a title="Types.this.Type" id="455691">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="455692">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#455692" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAbstractType</span><span class="delimiter">)</span> <a href="#67466" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#455691" title="Types.this.Type">pre</a>, <a href="#455692" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#455692" title="Types.this.Symbol">sym</a>
      
    <span class="keyword">val</span> <a title="Types.this.Symbol" id="455690">sym1</a> = <a href="#455689" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebindTR</a><span class="delimiter">(</span><a href="#133221" title="Types.this.Type">pre</a>, <a href="#133222" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>

    <span class="comment">// we require that object is initialized, thus info.typeParams instead of typeParams.</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#455690" title="Types.this.Symbol">sym1</a>.<span title="=&gt; Boolean">isAliasType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#455690" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105336" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#133223" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#455690" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107318" title="=&gt; Boolean">lockOK</a><span class="delimiter">)</span> <a href="#133347" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#133221" title="Types.this.Type">pre</a>, <a href="#455690" title="Types.this.Symbol">sym1</a>, <a href="#133223" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="comment">// don't expand type alias (cycles checked by lockOK)</span>
      <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <a href="#313894" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#67658" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="java.lang.String(&quot;illegal cyclic reference involving &quot;)" class="string">&quot;illegal cyclic reference involving &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#455690" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="455697">pre1</a> = <a href="#67467" title="(tp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">removeSuper</a><span class="delimiter">(</span><a href="#133221" title="Types.this.Type">pre</a>, <a href="#455690" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#455697" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#133221" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <a href="#67472" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#455697" title="Types.this.Type">pre1</a>, <a href="#455689" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebindTR</a><span class="delimiter">(</span><a href="#455697" title="Types.this.Type">pre1</a>, <a href="#455690" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>, <a href="#133223" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#133221" title="Types.this.Type">pre</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span>: <a href="#67415" title="Types.this.CompoundType">CompoundType</a> <span class="keyword">if</span> <a href="#455690" title="Types.this.Symbol">sym1</a>.<span title="=&gt; Boolean">isClass</span> =&gt;
          <span class="comment">// sharpen prefix so that it is maximal and still contains the class.</span>
          <a href="#133221" title="Types.this.Type">pre</a>.<a href="#105322" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; List[Types.this.Type]">reverse</span> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">dropWhile</span> <span class="delimiter">(</span><a href="#455705" title="Types.this.Type">_</a>.<a href="#105354" title="(name: Types.this.Name)Types.this.Symbol">member</a><span class="delimiter">(</span><a href="#455690" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#455690" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Types.this.Type">Nil</span>         =&gt; <a href="#133347" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#133221" title="Types.this.Type">pre</a>, <a href="#455690" title="Types.this.Symbol">sym1</a>, <a href="#133223" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
            <span class="keyword">case</span> <a title="Types.this.Type" id="455715">parent</a> :: _ =&gt; <a href="#67472" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#455715" title="Types.this.Type">parent</a>, <a href="#455690" title="Types.this.Symbol">sym1</a>, <a href="#133223" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#133347" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#133221" title="Types.this.Type">pre</a>, <a href="#455690" title="Types.this.Symbol">sym1</a>, <a href="#133223" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="67473">copyTypeRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="159865">tp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="159866">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="159867">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="159868">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#159865" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="455716">pre0</a>, <a title="Types.this.Symbol" id="455717">sym0</a>, <a title="List[Types.this.Type]" id="455718">args0</a><span class="delimiter">)</span> =&gt;
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#159866" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#455716" title="Types.this.Type">pre0</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#159867" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#455717" title="Types.this.Symbol">sym0</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>

        <span class="keyword">val</span> <a title="Types.this.Symbol" id="455728">sym1</a> = <a href="#159867" title="Types.this.Symbol">sym</a>
        <span class="comment">// we require that object is initialized, thus info.typeParams instead of typeParams.</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#455728" title="Types.this.Symbol">sym1</a>.<span title="=&gt; Boolean">isAliasType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#455728" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105336" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#159868" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#455728" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107318" title="=&gt; Boolean">lockOK</a><span class="delimiter">)</span> <a href="#133347" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#159866" title="Types.this.Type">pre</a>, <a href="#455728" title="Types.this.Symbol">sym1</a>, <a href="#159868" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="comment">// don't expand type alias (cycles checked by lockOK)</span>
          <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <a href="#313894" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#67658" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="java.lang.String(&quot;illegal cyclic reference involving &quot;)" class="string">&quot;illegal cyclic reference involving &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#455728" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <a href="#133347" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#159866" title="Types.this.Type">pre</a>, <a href="#455728" title="Types.this.Symbol">sym1</a>, <a href="#159868" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        
      <span class="delimiter">}</span> <span class="keyword">else</span>
        <a href="#67472" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#159866" title="Types.this.Type">pre</a>, <a href="#159867" title="Types.this.Symbol">sym</a>, <a href="#159868" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>




  <span class="comment">/** The canonical creator for implicit method types */</span>
  <span class="keyword">def</span> <a title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.JavaMethodType" id="67474">JavaMethodType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="455733">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="455734">resultType</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67440" title="Types.this.JavaMethodType">JavaMethodType</a> =
    <span title="Types.this.JavaMethodType" class="keyword">new</span> <a href="#67440" title="Types.this.JavaMethodType">JavaMethodType</a><span class="delimiter">(</span><a href="#455733" title="List[Types.this.Symbol]">params</a>, <a href="#455734" title="Types.this.Type">resultType</a><span class="delimiter">)</span> <span class="comment">// don't unique this!</span>

  <span class="comment">/** Create a new MethodType of the same class as tp, i.e. keep JavaMethodType */</span>
  <span class="keyword">def</span> <a title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type" id="67475">copyMethodType</a><span class="delimiter">(</span><a title="Types.this.Type" id="453697">tp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="453698">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="453699">restpe</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#453697" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.JavaMethodType">_</span>: <a href="#67440" title="Types.this.JavaMethodType">JavaMethodType</a> =&gt; <a href="#67474" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.JavaMethodType">JavaMethodType</a><span class="delimiter">(</span><a href="#453698" title="List[Types.this.Symbol]">params</a>, <a href="#453699" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.MethodType">_</span> =&gt; <a href="#148698" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#453698" title="List[Types.this.Symbol]">params</a>, <a href="#453699" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A creator for intersection type where intersections of a single type are
   *  replaced by the type itself, and repeated parent classes are merged.
   */</span>
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type" id="67476">intersectionType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="422129">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="422130">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#422129" title="List[Types.this.Type]">tps</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#455737" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="455748">tp</a><span class="delimiter">)</span> =&gt;
      <a href="#455748" title="Types.this.Type">tp</a>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
       <a href="#67470" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#422129" title="List[Types.this.Type]">tps</a>, <a href="#422130" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
<span class="comment">/*
      def merge(tps: List[Type]): List[Type] = tps match {
        case tp :: tps1 =&gt;
          val tps1a = tps1 filter (_.typeSymbol.==(tp.typeSymbol))
          val tps1b = tps1 filter (_.typeSymbol.!=(tp.typeSymbol))
          mergePrefixAndArgs(tps1a, -1) match {
            case Some(tp1) =&gt; tp1 :: merge(tps1b)
            case None =&gt; throw new MalformedType(
              &quot;malformed type: &quot;+refinedType(tps, owner)+&quot; has repeated parent class &quot;+
              tp.typeSymbol+&quot; with incompatible prefixes or type arguments&quot;)
          }
        case _ =&gt; tps
      } 
      refinedType(merge(tps), owner)
*/</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A creator for intersection type where intersections of a single type are
   *  replaced by the type itself. */</span>
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type])Types.this.Type" id="67477">intersectionType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="422126">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#422126" title="List[Types.this.Type]">tps</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#455754" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="455765">tp</a><span class="delimiter">)</span> =&gt; <a href="#455765" title="Types.this.Type">tp</a>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#67470" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#422126" title="List[Types.this.Type]">tps</a>, <a href="#67650" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#422126" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/** A creator for type applications */</span>
  <span class="keyword">def</span> <a title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type" id="67478">appliedType</a><span class="delimiter">(</span><a title="Types.this.Type" id="298941">tycon</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="List[Types.this.Type]" id="298942">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =  
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#298942" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#298941" title="Types.this.Type">tycon</a> <span class="comment">//@M! `if (args.isEmpty) tycon' is crucial (otherwise we create new types in phases after typer and then they don't get adapted (??))</span>
    <span class="keyword">else</span> <a href="#298941" title="Types.this.Type">tycon</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span> 
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="455776">pre</a>, <a title="Types.this.Symbol" id="455777">sym</a> @ <span class="delimiter">(</span><a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a>|<a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#67473" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#298941" title="Types.this.Type">tycon</a>, <a href="#455776" title="Types.this.Type">pre</a>, <a href="#455777" title="Types.this.Symbol">sym</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span>   <span class="comment">//@M drop type args to Any/Nothing</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="455778">pre</a>, <a title="Types.this.Symbol" id="455779">sym</a>, _<span class="delimiter">)</span>                           =&gt; <a href="#67473" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#298941" title="Types.this.Type">tycon</a>, <a href="#455778" title="Types.this.Type">pre</a>, <a href="#455779" title="Types.this.Symbol">sym</a>, <a href="#298942" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="455780">tparams</a>, <a title="Types.this.Type" id="455781">restpe</a><span class="delimiter">)</span>                      =&gt; <a href="#455781" title="Types.this.Type">restpe</a>.<a href="#105339" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#455780" title="List[Types.this.Symbol]">tparams</a>, <a href="#298942" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.ExistentialType">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="455782">tparams</a>, <a title="Types.this.Type" id="455783">restpe</a><span class="delimiter">)</span>               =&gt; <a href="#149074" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">ExistentialType</a><span class="delimiter">(</span><a href="#455782" title="List[Types.this.Symbol]">tparams</a>, <a href="#67478" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#455783" title="Types.this.Type">restpe</a>, <a href="#298942" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="455784">st</a>: <a href="#67387" title="Types.this.SingletonType">SingletonType</a>                              =&gt; <a href="#67478" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#455784" title="Types.this.SingletonType">st</a>.<a href="#148205" title="=&gt; Types.this.Type">widen</a>, <a href="#298942" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="comment">// @M TODO: what to do? see bug1</span>
      <span class="keyword">case</span> <span title="Types.this.RefinedType">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="455785">parents</a>, <a title="Types.this.Scope" id="455786">decls</a><span class="delimiter">)</span>                    =&gt; <a href="#148512" title="(parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#455785" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#67478" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#455809" title="Types.this.Type">_</a>, <a href="#298942" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#455786" title="Types.this.Scope">decls</a><span class="delimiter">)</span> <span class="comment">// MO to AM: please check</span>
      <span class="keyword">case</span> <span title="Types.this.TypeBounds">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="455837">lo</a>, <a title="Types.this.Type" id="455838">hi</a><span class="delimiter">)</span>                             =&gt; <a href="#148437" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#67478" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#455837" title="Types.this.Type">lo</a>, <a href="#298942" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, <a href="#67478" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#455838" title="Types.this.Type">hi</a>, <a href="#298942" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.TypeVar" id="455839">tv</a>@<a href="#448916" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span>                               =&gt; <a href="#455839" title="Types.this.TypeVar">tv</a>.<a href="#448943" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#298942" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.AnnotatedType">AnnotatedType</span><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="455841">annots</a>, <a title="Types.this.Type" id="455842">underlying</a>, <a title="Types.this.Symbol" id="455843">self</a><span class="delimiter">)</span>        =&gt; <a href="#148952" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#455841" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#67478" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#455842" title="Types.this.Type">underlying</a>, <a href="#298942" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, <a href="#455843" title="Types.this.Symbol">self</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="#450783" title="Types.this.Type">ErrorType</a>                                      =&gt; <a href="#298941" title="Types.this.Type">tycon</a>
      <span class="keyword">case</span> <a href="#450801" title="Types.this.Type">WildcardType</a>                                   =&gt; <a href="#298941" title="Types.this.Type">tycon</a> <span class="comment">// needed for neg/t0226</span>
      <span class="keyword">case</span> <span title="Nothing">_</span>                                              =&gt; <a href="SymbolTable.scala.html#64779" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><a href="TypeDebugging.scala.html#67939" title="(tp: Types.this.Type)String">debugString</a><span class="delimiter">(</span><a href="#298941" title="Types.this.Type">tycon</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/** A creator for type parameterizations that strips empty type parameter lists.
   * Use this factory method to indicate the type has kind * (it's a polymorphic value) 
   * until we start tracking explicit kinds equivalent to typeFun (except that the latter requires tparams nonEmpty)
   */</span>
  <span class="keyword">def</span> <a title="(tparams: List[Types.this.Symbol], tpe: Types.this.Type)Types.this.Type" id="67479">polyType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="399103">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="399104">tpe</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = 
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#399103" title="List[Types.this.Symbol]">tparams</a> <span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#67481" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#399103" title="List[Types.this.Symbol]">tparams</a>, <a href="#399104" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <a href="#399104" title="Types.this.Type">tpe</a> <span class="comment">// it's okay to be forgiving here</span>

  <span class="comment">/** A creator for anonymous type functions, where the symbol for the type function still needs to be created 
   *
   * TODO:
   * type params of anonymous type functions, which currently can only arise from normalising type aliases, are owned by the type alias of which they are the eta-expansion
   * higher-order subtyping expects eta-expansion of type constructors that arise from a class; here, the type params are owned by that class, but is that the right thing to do?
   */</span>
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type" id="67480">typeFunAnon</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="453173">tps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="453174">body</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#67481" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#453173" title="List[Types.this.Symbol]">tps</a>, <a href="#453174" title="Types.this.Type">body</a><span class="delimiter">)</span>
  
  <span class="comment">/** A creator for a type functions, assuming the type parameters tps already have the right owner 
   */</span>
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type" id="67481">typeFun</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="451860">tps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="451861">body</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#148857" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#451860" title="List[Types.this.Symbol]">tps</a>, <a href="#451861" title="Types.this.Type">body</a><span class="delimiter">)</span>

  <span class="comment">/** A creator for existential types. This generates:
   *  
   *  tpe1 where { tparams }
   *
   *  where `tpe1' is the result of extrapolating `tpe' wrt to `tparams'. Extrapolating means
   *  that type variables in `tparams' occurring in covariant positions are replaced by upper bounds,
   *  (minus any SingletonClass markers),
   *  type variables in `tparams' occurring in contravariant positions are replaced by upper bounds,
   *  provided the resulting type is legal wrt to stability, and does not contain any
   *  type variable in `tparams'.
   *  The abstraction drops all type parameters that are not directly or indirectly 
   *  referenced by type `tpe1'.
   *  If there are no remaining type parameters, simply returns result type `tpe'. 
   */</span>
  <span class="keyword">def</span> <a title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type" id="67482">existentialAbstraction</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="262082">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="262083">tpe0</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = 
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#262082" title="List[Types.this.Symbol]">tparams</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#262083" title="Types.this.Type">tpe0</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Int]" id="455849">occurCount</a> = <a href="#67511" title="=&gt; scala.collection.immutable.Map[Types.this.Symbol,Int]">emptySymCount</a> <span title="(xs: scala.collection.GenTraversableOnce[(Types.this.Symbol, Int)])scala.collection.immutable.Map[Types.this.Symbol,Int]">++</span> <span class="delimiter">(</span><a href="#262082" title="List[Types.this.Symbol]">tparams</a> <span title="(f: Types.this.Symbol =&gt; (Types.this.Symbol, Int))(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],(Types.this.Symbol, Int),List[(Types.this.Symbol, Int)]])List[(Types.this.Symbol, Int)]">map</span> <span class="delimiter">(</span><a href="#455910" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">_</a> <span title="(y: Int)(Types.this.Symbol, Int)">-&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="455850">tpe</a> = <a href="#455987" title="(tp: Types.this.Type)Types.this.Type">deAlias</a><span class="delimiter">(</span><a href="#262083" title="Types.this.Type">tpe0</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="455851">countOccs</a><span class="delimiter">(</span><a title="Types.this.Type" id="455992">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="455994">t</a> &lt;- <a href="#105369" title="(f: Types.this.Type =&gt; Unit)Unit">tp</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#455994" title="Types.this.Type">t</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="455995">sym</a>, _<span class="delimiter">)</span> =&gt;
              <a href="#455849" title="scala.collection.immutable.Map[Types.this.Symbol,Int]">occurCount</a> <span title="(key: Types.this.Symbol)Option[Int]">get</span> <a href="#455995" title="Types.this.Symbol">sym</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Unit">Some</span><span class="delimiter">(</span><a title="Int" id="456005">count</a><span class="delimiter">)</span> =&gt; <a href="#455849" title="scala.collection.immutable.Map[Types.this.Symbol,Int]">occurCount</a> <span title="(kv: (Types.this.Symbol, Int))scala.collection.immutable.Map[Types.this.Symbol,Int]">+=</span> <span class="delimiter">(</span><a href="#455995" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">sym</a> <span title="(y: Int)(Types.this.Symbol, Int)">-&gt;</span> <span class="delimiter">(</span><a href="#456005" title="Int">count</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">case</span> <a title="Unit" id="456092">none</a> =&gt;
              <span class="delimiter">}</span>
            <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <a href="#455851" title="(tp: Types.this.Type)Unit">countOccs</a><span class="delimiter">(</span><a href="#455850" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="456112">tparam</a> &lt;- <a href="#262082" title="(f: Types.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span> <a href="#455851" title="(tp: Types.this.Type)Unit">countOccs</a><span class="delimiter">(</span><a href="#456112" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span>
          
      <span class="keyword">val</span> <a title="Types.this.TypeMap" id="455852">extrapolate</a> = <a href="#456114" title="Types.this.TypeMap" class="keyword">new</a> <a href="#67503" title="anonymous class $anon extends Types.this.TypeMap" id="456114">TypeMap</a> <span class="delimiter">{</span>
        <a href="#133272" title="(x$1: Int)Unit">variance</a> = <span title="Int(1)" class="int">1</span>
        <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="456116">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="456119">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="456142">tp1</a> = <a href="#456117" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#456119" title="Types.this.Type">tp</a><span class="delimiter">)</span> 
          <a href="#456142" title="Types.this.Type">tp1</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="456149">pre</a>, <a title="Types.this.Symbol" id="456150">sym</a>, <a title="List[Types.this.Type]" id="456151">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#133272" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#455849" title="scala.collection.immutable.Map[Types.this.Symbol,Int]">occurCount</a> <span title="(key: Types.this.Symbol)Boolean">isDefinedAt</span> <a href="#456150" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> =&gt;
              <span class="keyword">val</span> <a title="Types.this.Type" id="456161">repl</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133272" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#447209" title="(tp: Types.this.Type)Types.this.Type">dropSingletonType</a><span class="delimiter">(</span><a href="#456142" title="Types.this.Type">tp1</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#456142" title="Types.this.Type">tp1</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148467" title="=&gt; Types.this.Type">lo</a>
              <span class="comment">//println(&quot;eliminate &quot;+sym+&quot;/&quot;+repl+&quot;/&quot;+occurCount(sym)+&quot;/&quot;+(tparams exists (repl.contains)))//DEBUG</span>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456161" title="Types.this.Type">repl</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#456161" title="Types.this.Type">repl</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#106085" title="=&gt; Types.this.Symbol">NullClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
                  <a href="#455849" title="(key: Types.this.Symbol)Int">occurCount</a><span class="delimiter">(</span><a href="#456150" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#262082" title="List[Types.this.Symbol]">tparams</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#456161" title="Types.this.Type">repl</a>.<a href="#105372" title="(sym: Types.this.Symbol)Boolean">contains</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#456161" title="Types.this.Type">repl</a>
              <span class="keyword">else</span> <a href="#456142" title="Types.this.Type">tp1</a>
            <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
              <a href="#456142" title="Types.this.Type">tp1</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="456117">mapOver</a><span class="delimiter">(</span><a title="Types.this.Type" id="456122">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#456122" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="456210">pre</a>, <a title="Types.this.Symbol" id="456211">sym</a><span class="delimiter">)</span> =&gt;
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456211" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span><span class="delimiter">)</span> <a href="#456122" title="Types.this.Type">tp</a> <span class="comment">// short path</span>
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="456212">pre1</a> = <a href="#456116" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456210" title="Types.this.Type">pre</a><span class="delimiter">)</span>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456212" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456210" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#456212" title="Types.this.Type">pre1</a>.<a href="#105305" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#456122" title="Types.this.Type">tp</a>
              <span class="keyword">else</span> <a href="#67468" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#456212" title="Types.this.Type">pre1</a>, <a href="#456211" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#456114" title="Types.this.TypeMap" class="keyword">super</a>.<a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#456122" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Option[Types.this.Tree]" id="456118">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="456125">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = 
          <a href="#456125" title="Types.this.Tree">tree</a> <span title="Option[Types.this.Tree]" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a title="Some[Types.this.Ident]" id="456128">tree</a>:<span title="Types.this.Ident">Ident</span> <span class="keyword">if</span> <a href="#456128" title="Types.this.Ident">tree</a>.<span title="=&gt; Types.this.Type">tpe</span>.<a href="#105305" title="=&gt; Boolean">isStable</a> =&gt;
              <span class="comment">// Do not discard the types of existential ident's.</span>
              <span class="comment">// The symbol of the Ident itself cannot be listed</span>
              <span class="comment">// in the existential's parameters, so the</span>
              <span class="comment">// resulting existential type would be ill-formed.</span>
              <span title="(x: Types.this.Ident)Some[Types.this.Ident]">Some</span><span class="delimiter">(</span><a href="#456128" title="Types.this.Ident">tree</a><span class="delimiter">)</span>

            <span class="keyword">case</span> <span title="Option[Types.this.Tree]">_</span> =&gt;
              <a href="#456114" title="Types.this.TypeMap" class="keyword">super</a>.<a href="#133287" title="(tree: Types.this.Tree)Option[Types.this.Tree]">mapOver</a><span class="delimiter">(</span><a href="#456125" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="455853">tpe1</a> = <a href="#455852" title="(v1: Types.this.Type)Types.this.Type">extrapolate</a><span class="delimiter">(</span><a href="#455850" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="455854">tparams0</a> = <a href="#262082" title="List[Types.this.Symbol]">tparams</a>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="455855">tparams1</a> = <a href="#455854" title="List[Types.this.Symbol]">tparams0</a> <span title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">filter</span> <a href="#455853" title="Types.this.Type">tpe1</a>.<a href="#105372" title="(sym: Types.this.Symbol)Boolean">contains</a>

      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#455855" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#455854" title="List[Types.this.Symbol]">tparams0</a><span class="delimiter">)</span> <a href="#455856" title="()Unit" class="delimiter">{</a>
        <a href="#455854" title="List[Types.this.Symbol]">tparams0</a> = <a href="#455855" title="List[Types.this.Symbol]">tparams1</a>
        <a href="#455855" title="List[Types.this.Symbol]">tparams1</a> = <a href="#262082" title="List[Types.this.Symbol]">tparams</a> <span title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">filter</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="456268">p</a> =&gt;
          <a href="#455855" title="List[Types.this.Symbol]">tparams1</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="456277">p1</a> =&gt; <a href="#456277" title="Types.this.Symbol">p1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#456268" title="Types.this.Symbol">p</a> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#456277" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a> <a href="#105372" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#456268" title="Types.this.Symbol">p</a><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#455855" title="List[Types.this.Symbol]">tparams1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#455853" title="Types.this.Type">tpe1</a> 
      <span class="keyword">else</span> <a href="#455853" title="Types.this.Type">tpe1</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.ExistentialType">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="456283">tparams2</a>, <a title="Types.this.Type" id="456284">tpe2</a><span class="delimiter">)</span> =&gt; <a href="#149074" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">ExistentialType</a><span class="delimiter">(</span><a href="#455855" title="List[Types.this.Symbol]">tparams1</a> <a href="#456285" title="(prefix: List[Types.this.Symbol])List[Types.this.Symbol]">:::</a> <a href="#456283" title="List[Types.this.Symbol]">tparams2</a>, <a href="#456284" title="Types.this.Type">tpe2</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.ExistentialType">_</span> =&gt; <a href="#149074" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">ExistentialType</a><span class="delimiter">(</span><a href="#455855" title="List[Types.this.Symbol]">tparams1</a>, <a href="#455853" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Remove any occurrences of type aliases from this type */</span>
  <span class="keyword">object</span> <a title="object Types.this.deAlias" id="67483">deAlias</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="455987">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="455988">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a> <span class="delimiter">{</span>
      <a href="#455988" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="456302">pre</a>, <a title="Types.this.Symbol" id="456303">sym</a>, <a title="List[Types.this.Type]" id="456304">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#456303" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span> =&gt; <a href="#455988" title="Types.this.Type">tp</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#455988" title="Types.this.Type">tp</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Remove any occurrence of type &lt;singleton&gt; from this type and its parents */</span>
  <span class="keyword">object</span> <a title="object Types.this.dropSingletonType" id="67485">dropSingletonType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="447209">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="447210">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#447210" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span>_, <a href="Definitions.scala.html#106203" title="=&gt; Types.this.Symbol">SingletonClass</a>, _<span class="delimiter">)</span> =&gt;
          <a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
        <span class="keyword">case</span> <a title="Types.this.Type" id="456306">tp1</a> @ RefinedType<span class="delimiter">(</span><a title="List[Types.this.Type]" id="456307">parents</a>, <a title="Types.this.Scope" id="456308">decls</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">var</span> <a title="List[Types.this.Type]" id="456309">parents1</a> = <a href="#456307" title="List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a href="#456313" title="Types.this.Type">_</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#106203" title="=&gt; Types.this.Symbol">SingletonClass</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#456309" title="List[Types.this.Type]">parents1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#456309" title="List[Types.this.Type]">parents1</a> = <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456309" title="List[Types.this.Type]">parents1</a>.<span title="=&gt; List[Types.this.Type]">tail</span>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#456308" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112943" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#456309" title="List[Types.this.Type]">parents1</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#67471" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#456306" title="Types.this.RefinedType">tp1</a>, <a href="#456309" title="List[Types.this.Type]">parents1</a>, <a href="#456308" title="Types.this.Scope">decls</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <a title="Types.this.Type" id="456349">tp1</a> =&gt; 
          <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#456349" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
<span class="comment">// Hash consing --------------------------------------------------------------</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="Int" id="67487">initialUniquesCapacity</a> = <span title="Int(4096)" class="int">4096</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="scala.tools.nsc.util.HashSet[Types.this.Type]" id="67490">uniques</a>: util.<a href="../util/HashSet.scala.html#30368" title="scala.tools.nsc.util.HashSet[Types.this.Type]">HashSet</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = _
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="67493">uniqueRunId</a> = <span title="Int(0)">NoRunId</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T &lt;: Types.this.Type](tp: T)T" id="67495">unique</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Types.this.Type" id="67497">T</a> &lt;: Type<span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="450931">tp</a>: <a href="#67497" title="T">T</a><span class="delimiter">)</span>: <a href="#67497" title="T">T</a> = <span class="delimiter">{</span>
    <a href="../util/Statistics.scala.html#67151" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67206" title="=&gt; scala.tools.nsc.util.Statistics.Counter">rawTypeCount</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#67493" title="=&gt; Int">uniqueRunId</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#64797" title="=&gt; Types.this.RunId">currentRunId</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#67490" title="(x$1: scala.tools.nsc.util.HashSet[Types.this.Type])Unit">uniques</a> = util.<a href="../util/HashSet.scala.html#167889" title="[T &gt;: Null &lt;: AnyRef](label: String, initialCapacity: Int)scala.tools.nsc.util.HashSet[T]">HashSet</a><span title="(label: String, initialCapacity: Int)scala.tools.nsc.util.HashSet[Types.this.Type]" class="delimiter">[</span><a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="java.lang.String(&quot;uniques&quot;)" class="string">&quot;uniques&quot;</span>, <a href="#67487" title="=&gt; Int">initialUniquesCapacity</a><span class="delimiter">)</span>
      <a href="#67493" title="(x$1: Int)Unit">uniqueRunId</a> = <a href="SymbolTable.scala.html#64797" title="=&gt; Types.this.RunId">currentRunId</a>
    <span class="delimiter">}</span>
    <span class="delimiter">(</span><a href="#67490" title="=&gt; scala.tools.nsc.util.HashSet[Types.this.Type]">uniques</a> <a href="../util/HashSet.scala.html#120183" title="(x: Types.this.Type)Types.this.Type">findEntryOrUpdate</a> <a href="#450931" title="T">tp</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#67497" title="T">T</a><span class="delimiter">]</span>
  <span class="delimiter">}</span>

<span class="comment">// Helper Classes ---------------------------------------------------------</span>

  <span class="comment">/** @PP: Unable to see why these apparently constant types should need vals
   *  in every TypeConstraint, I lifted them out.
   */</span>
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.Type" id="67499">numericLoBound</a> = <a href="Definitions.scala.html#106585" title="=&gt; Types.this.Symbol">IntClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.Type" id="67501">numericHiBound</a> = <a href="#67476" title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">intersectionType</a><span class="delimiter">(</span><span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="Definitions.scala.html#106579" title="=&gt; Types.this.Symbol">ByteClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>, <a href="Definitions.scala.html#106583" title="=&gt; Types.this.Symbol">CharClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>, <a href="Definitions.scala.html#106046" title="=&gt; Types.this.Symbol">ScalaPackageClass</a><span class="delimiter">)</span>

  <span class="comment">/** A class expressing upper and lower bounds constraints of type variables, 
   * as well as their instantiations.
   */</span>
  <span class="keyword">class</span> <a title="class TypeConstraint extends java.lang.Object with ScalaObject" id="67502">TypeConstraint</a><a href="#67502" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Type]" id="449356">lo0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="449357">hi0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Type" id="449358">numlo0</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="449359">numhi0</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span> 
    <span class="keyword">def</span> <a title="(lo0: List[Types.this.Type], hi0: List[Types.this.Type])Types.this.TypeConstraint" id="449306" class="keyword">this</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="449354">lo0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="449355">hi0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#67502" title="TypeConstraint.this.type" class="keyword">this</a><span class="delimiter">(</span><a href="#449354" title="List[Types.this.Type]">lo0</a>, <a href="#449355" title="List[Types.this.Type]">hi0</a>, <a href="#450850" title="object Types.this.NoType">NoType</a>, <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="()Types.this.TypeConstraint" id="449307" class="keyword">this</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="#449306" title="(lo0: List[Types.this.Type], hi0: List[Types.this.Type])Types.this.TypeConstraint" class="keyword">this</a><span class="delimiter">(</span>List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[Types.this.Type]" id="449309">lobounds</a> = <a href="#449356" title="List[Types.this.Type]">lo0</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[Types.this.Type]" id="449312">hibounds</a> = <a href="#449357" title="List[Types.this.Type]">hi0</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="449315">numlo</a> = <a href="#449358" title="Types.this.Type">numlo0</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="449318">numhi</a> = <a href="#449359" title="Types.this.Type">numhi0</a>

    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="449320">loBounds</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#449315" title="=&gt; Types.this.Type">numlo</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <a href="#449309" title="=&gt; List[Types.this.Type]">lobounds</a> <span class="keyword">else</span> <a href="#449315" title="=&gt; Types.this.Type">numlo</a> <a href="#456423" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#449309" title="=&gt; List[Types.this.Type]">lobounds</a>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="449321">hiBounds</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#449318" title="=&gt; Types.this.Type">numhi</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <a href="#449312" title="=&gt; List[Types.this.Type]">hibounds</a> <span class="keyword">else</span> <a href="#449318" title="=&gt; Types.this.Type">numhi</a> <a href="#456436" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#449312" title="=&gt; List[Types.this.Type]">hibounds</a>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="449322">addLoBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="455184">tp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Boolean" id="455187">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#455187" title="Boolean">isNumericBound</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#106525" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#455184" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#449315" title="=&gt; Types.this.Type">numlo</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450850" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">||</span> <a href="#67633" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#449315" title="=&gt; Types.this.Type">numlo</a>, <a href="#455184" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#449315" title="(x$1: Types.this.Type)Unit">numlo</a> = <a href="#455184" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#67633" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#455184" title="Types.this.Type">tp</a>, <a href="#449315" title="=&gt; Types.this.Type">numlo</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#449315" title="(x$1: Types.this.Type)Unit">numlo</a> = <a href="#67498" title="=&gt; Types.this.Type">numericLoBound</a>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#449309" title="(x$1: List[Types.this.Type])Unit">lobounds</a> <span title="(x: Types.this.Type)List[Types.this.Type]">::=</span> <a href="#455184" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="449323">addHiBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="455192">tp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Boolean" id="455195">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#455195" title="Boolean">isNumericBound</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#106525" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#455192" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#449318" title="=&gt; Types.this.Type">numhi</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450850" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">||</span> <a href="#67633" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#455192" title="Types.this.Type">tp</a>, <a href="#449318" title="=&gt; Types.this.Type">numhi</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#449318" title="(x$1: Types.this.Type)Unit">numhi</a> = <a href="#455192" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#67633" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#449318" title="=&gt; Types.this.Type">numhi</a>, <a href="#455192" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#449318" title="(x$1: Types.this.Type)Unit">numhi</a> = <a href="#67500" title="=&gt; Types.this.Type">numericHiBound</a>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#449312" title="(x$1: List[Types.this.Type])Unit">hibounds</a> <span title="(x: Types.this.Type)List[Types.this.Type]">::=</span> <a href="#455192" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="449324">isWithinBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="455262">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <a href="#449309" title="=&gt; List[Types.this.Type]">lobounds</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#456473" title="Types.this.Type">_</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#455262" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
      <a href="#449312" title="=&gt; List[Types.this.Type]">hibounds</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#455262" title="Types.this.Type">tp</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#456482" title="Types.this.Type">_</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span class="delimiter">(</span><a href="#449315" title="=&gt; Types.this.Type">numlo</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450850" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#449315" title="=&gt; Types.this.Type">numlo</a> <a href="#105378" title="(that: Types.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#455262" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span class="delimiter">(</span><a href="#449318" title="=&gt; Types.this.Type">numhi</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450850" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#455262" title="Types.this.Type">tp</a> <a href="#105378" title="(that: Types.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#449318" title="=&gt; Types.this.Type">numhi</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">var</span> <a title="Types.this.Type" id="449326">inst</a>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#450850" title="object Types.this.NoType">NoType</a> <span class="comment">// @M reduce visibility?</span>

    <span class="keyword">def</span> <a title="=&gt; Boolean" id="449328">instValid</a> = <span class="delimiter">(</span><a href="#449326" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#449326" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeConstraint" id="449329">cloneInternal</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.TypeConstraint" id="449351">tc</a> = <span title="Types.this.TypeConstraint" class="keyword">new</span> <a href="#67502" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">(</span><a href="#449309" title="=&gt; List[Types.this.Type]">lobounds</a>, <a href="#449312" title="=&gt; List[Types.this.Type]">hibounds</a>, <a href="#449315" title="=&gt; Types.this.Type">numlo</a>, <a href="#449318" title="=&gt; Types.this.Type">numhi</a><span class="delimiter">)</span>
      <a href="#449351" title="Types.this.TypeConstraint">tc</a>.<a href="#449326" title="(x$1: Types.this.Type)Unit">inst</a> = <a href="#449326" title="=&gt; Types.this.Type">inst</a>
      <a href="#449351" title="Types.this.TypeConstraint">tc</a>
    <span class="delimiter">}</span>
    
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="449330">toString</a> =
      <span class="delimiter">(</span><a href="#449320" title="=&gt; List[Types.this.Type]">loBounds</a> <span title="(f: Types.this.Type =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],String,List[String]])List[String]">map</span> <span class="delimiter">(</span><a href="#456515" title="Types.this.Type">_</a>.<span title="=&gt; String">safeToString</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;[ _&gt;:(&quot;)" class="string">&quot;[ _&gt;:(&quot;</span>, <span title="java.lang.String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="java.lang.String(&quot;) &quot;)" class="string">&quot;) &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)java.lang.String">+</span>
      <span class="delimiter">(</span><a href="#449321" title="=&gt; List[Types.this.Type]">hiBounds</a> <span title="(f: Types.this.Type =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],String,List[String]])List[String]">map</span> <span class="delimiter">(</span><a href="#456565" title="Types.this.Type">_</a>.<span title="=&gt; String">safeToString</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;| _&lt;:(&quot;)" class="string">&quot;| _&lt;:(&quot;</span>, <span title="java.lang.String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="java.lang.String(&quot;) ] _= &quot;)" class="string">&quot;) ] _= &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)java.lang.String">+</span> 
      <a href="#449326" title="=&gt; Types.this.Type">inst</a>.<span title="=&gt; String">safeToString</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A prototype for mapping a function over all possible types
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeMap extends java.lang.Object with Types.this.Type =&gt; Types.this.Type with ScalaObject" id="67503">TypeMap</a> <a href="#67503" title="ScalaObject" class="keyword">extends</a> <span title="Types.this.Type =&gt; Types.this.Type">Function1</span><span class="delimiter">[</span>Type, Type<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="comment">// deferred inherited: def apply(tp: Type): Type</span>

    <span class="comment">/** The variance relative to start. If you want variances to be significant, set
     *  variance = 1
     *  at the top of the typemap.
     */</span>
    <span class="keyword">var</span> <a title="Int" id="133272">variance</a> = <span title="Int(0)" class="int">0</span>

    <span class="comment">/** Should this map drop annotations that are not
     *  type-constraint annotations?
     */</span>
    <span class="keyword">val</span> <a title="Boolean" id="133274">dropNonConstraintAnnotations</a> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">/** Check whether two lists have elements that are eq-equal */</span>
    <span class="keyword">def</span> <a title="[T &lt;: AnyRef](l1: List[T], l2: List[T])Boolean" id="133276">allEq</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef" id="133278">T</a> &lt;: AnyRef<span class="delimiter">]</span><span class="delimiter">(</span><a title="List[T]" id="456601">l1</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="List[T]" id="456602">l2</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> =
      <span class="delimiter">(</span><a href="#456601" title="List[T]">l1</a> <span title="(that: scala.collection.GenSeq[T])(p: (T, T) =&gt; Boolean)Boolean">corresponds</span> <a href="#456602" title="List[T]">l2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#456633" title="T">_</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456634" title="T">_</a><span class="delimiter">)</span>

    <span class="comment">// #3731: return sym1 for which holds: pre bound sym.name to sym and pre1 now binds sym.name to sym1, conceptually exactly the same symbol as sym</span>
    <span class="comment">// the selection of sym on pre must be updated to the selection of sym1 on pre1,</span>
    <span class="comment">// since sym's info was probably updated by the TypeMap to yield a new symbol sym1 with transformed info</span>
    <span class="comment">// @returns sym1</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(pre: Types.this.Type, pre1: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol" id="133279">coevolveSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="456637">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="456638">pre1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="456639">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> =
      <span title="Types.this.Symbol" class="keyword">if</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#456637" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#456638" title="Types.this.Type">pre1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#456639" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <span class="comment">// only need to rebind type aliases here, as typeRef already handles abstract types (they are allowed to be rebound more liberally)</span>
        <span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#456637" title="Types.this.Type">pre</a>, <a href="#456638" title="Types.this.Type">pre1</a><span class="delimiter">)</span> <span title="Types.this.Symbol" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Types.this.Symbol" class="delimiter">(</span>RefinedType<span class="delimiter">(</span>_, <a title="Types.this.Scope" id="456649">decls</a><span class="delimiter">)</span>, RefinedType<span class="delimiter">(</span>_, <a title="Types.this.Scope" id="456650">decls1</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span class="comment">// don't look at parents -- it would be an error to override alias types anyway</span>
            <span class="comment">//val sym1 =</span>
            <a href="#456650" title="Types.this.Scope">decls1</a>.<a href="Scopes.scala.html#112953" title="(name: Types.this.Name)Types.this.Symbol">lookup</a><span class="delimiter">(</span><a href="#456639" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
<span class="comment">//            assert(decls.lookupAll(sym.name).toList.length == 1)</span>
<span class="comment">//            assert(decls1.lookupAll(sym.name).toList.length == 1)</span>
<span class="comment">//            assert(sym1.isAliasType)</span>
<span class="comment">//            println(&quot;coevolved &quot;+ sym +&quot; : &quot;+ sym.info +&quot; to &quot;+ sym1 +&quot; : &quot;+ sym1.info +&quot; with &quot;+ pre +&quot; -&gt; &quot;+ pre1)</span>
<span class="comment">//            sym1</span>
          <span class="keyword">case</span> <span title="Types.this.Symbol">_</span> =&gt; <span class="comment">// TODO: is there another way a typeref's symbol can refer to a symbol defined in its pre?</span>
<span class="comment">//            val sym1 = pre1.nonPrivateMember(sym.name).suchThat(sym =&gt; sym.isAliasType)</span>
<span class="comment">//            println(&quot;??coevolve &quot;+ sym +&quot; : &quot;+ sym.info +&quot; to &quot;+ sym1 +&quot; : &quot;+ sym1.info +&quot; with &quot;+ pre +&quot; -&gt; &quot;+ pre1)</span>
            <a href="#456639" title="Types.this.Symbol">sym</a>
        <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#456639" title="Types.this.Symbol">sym</a>

    <span class="comment">/** Map this function over given type */</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="133280">mapOver</a><span class="delimiter">(</span><a title="Types.this.Type" id="133340">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#133340" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="456652">pre</a>, <a title="Types.this.Symbol" id="456653">sym</a>, <a title="List[Types.this.Type]" id="456654">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="456655">pre1</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456652" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span class="comment">//val args1 = args mapConserve this(_)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="456656">args1</a> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#456654" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#456654" title="List[Types.this.Type]">args</a>
                    <span class="keyword">else</span> <span class="delimiter">{</span>
                      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="456658">tparams</a> = <a href="#456653" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>
                      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#456658" title="List[Types.this.Symbol]">tparams</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#456654" title="List[Types.this.Type]">args</a>
                      <span class="keyword">else</span> <a href="#133281" title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">mapOverArgs</a><span class="delimiter">(</span><a href="#456654" title="List[Types.this.Type]">args</a>, <a href="#456658" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
                    <span class="delimiter">}</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456655" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456652" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#456656" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456654" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133340" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#67473" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#133340" title="Types.this.Type">tp</a>, <a href="#456655" title="Types.this.Type">pre1</a>, <a href="#133279" title="(pre: Types.this.Type, pre1: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">coevolveSym</a><span class="delimiter">(</span><a href="#456652" title="Types.this.Type">pre</a>, <a href="#456655" title="Types.this.Type">pre1</a>, <a href="#456653" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>, <a href="#456656" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span> 
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#133340" title="Types.this.Type">tp</a>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="456662">pre</a>, <a title="Types.this.Symbol" id="456663">sym</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456663" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span><span class="delimiter">)</span> <a href="#133340" title="Types.this.Type">tp</a> <span class="comment">// short path</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="456664">pre1</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456662" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456664" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456662" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#133340" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#67468" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#456664" title="Types.this.Type">pre1</a>, <a href="#456663" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="456665">params</a>, <a title="Types.this.Type" id="456666">result</a><span class="delimiter">)</span> =&gt;
        <a href="#133272" title="(x$1: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#133272" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="456667">params1</a> = <a href="#133283" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#456665" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
        <a href="#133272" title="(x$1: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#133272" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="456668">result1</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456666" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456667" title="List[Types.this.Symbol]">params1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456665" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#456668" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456666" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133340" title="Types.this.Type">tp</a>
        <span class="comment">// for new dependent types: result1.substSym(params, params1)?</span>
        <span class="keyword">else</span> <a href="#67475" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#133340" title="Types.this.Type">tp</a>, <a href="#456667" title="List[Types.this.Symbol]">params1</a>, <a href="#456668" title="Types.this.Type">result1</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#456665" title="List[Types.this.Symbol]">params</a>, <a href="#456667" title="List[Types.this.Symbol]">params1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="456675">tparams</a>, <a title="Types.this.Type" id="456676">result</a><span class="delimiter">)</span> =&gt;
        <a href="#133272" title="(x$1: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#133272" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="456677">tparams1</a> = <a href="#133283" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#456675" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
        <a href="#133272" title="(x$1: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#133272" title="=&gt; Int">variance</a>
        <span class="keyword">var</span> <a title="Types.this.Type" id="456678">result1</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456676" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456677" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456675" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#456678" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456676" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133340" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#148857" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#456677" title="List[Types.this.Symbol]">tparams1</a>, <a href="#456678" title="Types.this.Type">result1</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#456675" title="List[Types.this.Symbol]">tparams</a>, <a href="#456677" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="456685">result</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="456686">result1</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456685" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456686" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456685" title="Types.this.Type">result</a><span class="delimiter">)</span> <a href="#133340" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#148801" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#456686" title="Types.this.Type">result1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ConstantType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#133340" title="Types.this.Type">tp</a>
      <span class="keyword">case</span> <span title="Types.this.Type">SuperType</span><span class="delimiter">(</span><a title="Types.this.Type" id="456688">thistp</a>, <a title="Types.this.Type" id="456689">supertp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="456690">thistp1</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456688" title="Types.this.Type">thistp</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="456691">supertp1</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456689" title="Types.this.Type">supertp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456690" title="Types.this.Type">thistp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456688" title="Types.this.Type">thistp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#456691" title="Types.this.Type">supertp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456689" title="Types.this.Type">supertp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133340" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#149198" title="(thistp: Types.this.Type, supertp: Types.this.Type)Types.this.Type">SuperType</a><span class="delimiter">(</span><a href="#456690" title="Types.this.Type">thistp1</a>, <a href="#456691" title="Types.this.Type">supertp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="456694">lo</a>, <a title="Types.this.Type" id="456695">hi</a><span class="delimiter">)</span> =&gt;
        <a href="#133272" title="(x$1: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#133272" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="456696">lo1</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456694" title="Types.this.Type">lo</a><span class="delimiter">)</span>
        <a href="#133272" title="(x$1: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#133272" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="456697">hi1</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456695" title="Types.this.Type">hi</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456696" title="Types.this.Type">lo1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456694" title="Types.this.Type">lo</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#456697" title="Types.this.Type">hi1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456695" title="Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133340" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#148437" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#456696" title="Types.this.Type">lo1</a>, <a href="#456697" title="Types.this.Type">hi1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="456698">bounds</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="456699">bounds1</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456698" title="Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456699" title="Types.this.Type">bounds1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456698" title="Types.this.TypeBounds">bounds</a><span class="delimiter">)</span> <a href="#133340" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#258421" title="(bounds: Types.this.TypeBounds)Types.this.BoundedWildcardType">BoundedWildcardType</a><span class="delimiter">(</span><a href="#456699" title="Types.this.Type">bounds1</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.TypeBounds" class="delimiter">[</span><a href="#148453" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">]</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="456704">rtp</a> @ RefinedType<span class="delimiter">(</span><a title="List[Types.this.Type]" id="456705">parents</a>, <a title="Types.this.Scope" id="456706">decls</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="456707">parents1</a> = <a href="#456705" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a href="#67503" title="Types.this.TypeMap" class="keyword">this</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Scope" id="456708">decls1</a> = <a href="#133282" title="(scope: Types.this.Scope)Types.this.Scope">mapOver</a><span class="delimiter">(</span><a href="#456706" title="Types.this.Scope">decls</a><span class="delimiter">)</span>
        <span class="comment">//if ((parents1 eq parents) &amp;&amp; (decls1 eq decls)) tp</span>
        <span class="comment">//else refinementOfClass(tp.typeSymbol, parents1, decls1)</span>
        <a href="#67471" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#456704" title="Types.this.RefinedType">rtp</a>, <a href="#456707" title="List[Types.this.Type]">parents1</a>, <a href="#456708" title="Types.this.Scope">decls1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="456721">tparams</a>, <a title="Types.this.Type" id="456722">result</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="456723">tparams1</a> = <a href="#133283" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#456721" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
        <span class="keyword">var</span> <a title="Types.this.Type" id="456724">result1</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456722" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456723" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456721" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#456724" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456722" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133340" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#149074" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">ExistentialType</a><span class="delimiter">(</span><a href="#456723" title="List[Types.this.Symbol]">tparams1</a>, <a href="#456724" title="Types.this.Type">result1</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#456721" title="List[Types.this.Symbol]">tparams</a>, <a href="#456723" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">OverloadedType</span><span class="delimiter">(</span><a title="Types.this.Type" id="456732">pre</a>, <a title="List[Types.this.Symbol]" id="456733">alts</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="456734">pre1</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456732" title="Types.this.Type">pre</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#148601" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#456732" title="Types.this.Type">pre</a> <span class="keyword">else</span> <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456732" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456734" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456732" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#133340" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#251432" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.OverloadedType">OverloadedType</a><span class="delimiter">(</span><a href="#456734" title="Types.this.Type">pre1</a>, <a href="#456733" title="List[Types.this.Symbol]">alts</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">AntiPolyType</span><span class="delimiter">(</span><a title="Types.this.Type" id="456735">pre</a>, <a title="List[Types.this.Type]" id="456736">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="456737">pre1</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456735" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="456738">args1</a> = <a href="#456736" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a href="#67503" title="Types.this.TypeMap" class="keyword">this</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456737" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456735" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#456738" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456736" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133340" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#455099" title="(pre: Types.this.Type, targs: List[Types.this.Type])Types.this.AntiPolyType">AntiPolyType</a><span class="delimiter">(</span><a href="#456737" title="Types.this.Type">pre1</a>, <a href="#456738" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="456752">tv</a>@<a href="#448916" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="456754">constr</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456754" title="Types.this.TypeConstraint">constr</a>.<a href="#449328" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456754" title="Types.this.TypeConstraint">constr</a>.<a href="#449326" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#456752" title="Types.this.TypeVar">tv</a>.<a href="#448943" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#133281" title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">mapOverArgs</a><span class="delimiter">(</span><a href="#456752" title="Types.this.TypeVar">tv</a>.<a href="#454756" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#456752" title="Types.this.TypeVar">tv</a>.<a href="#454757" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span>  <span class="comment">//@M !args.isEmpty implies !typeParams.isEmpty </span>
      <span class="keyword">case</span> <span title="Types.this.Type">NotNullType</span><span class="delimiter">(</span><a title="Types.this.Type" id="456755">tp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="456756">tp1</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456755" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456756" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456755" title="Types.this.Type">tp</a><span class="delimiter">)</span> <a href="#456755" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#449751" title="(underlying: Types.this.Type)Types.this.NotNullType">NotNullType</a><span class="delimiter">(</span><a href="#456756" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">AnnotatedType</span><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="456758">annots</a>, <a title="Types.this.Type" id="456759">atp</a>, <a title="Types.this.Symbol" id="456760">selfsym</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="456761">annots1</a> = <a href="#133284" title="(annots: List[Types.this.AnnotationInfo])List[Types.this.AnnotationInfo]">mapOverAnnotations</a><span class="delimiter">(</span><a href="#456758" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="456762">atp1</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456759" title="Types.this.Type">atp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#456761" title="List[Types.this.AnnotationInfo]">annots1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456758" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#456762" title="Types.this.Type">atp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456759" title="Types.this.Type">atp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#133340" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#456761" title="List[Types.this.AnnotationInfo]">annots1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#456762" title="Types.this.Type">atp1</a>
        <span class="keyword">else</span> <a href="#148952" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#456761" title="List[Types.this.AnnotationInfo]">annots1</a>, <a href="#456762" title="Types.this.Type">atp1</a>, <a href="#456760" title="Types.this.Symbol">selfsym</a><span class="delimiter">)</span>
<span class="comment">/*
      case ErrorType =&gt; tp
      case WildcardType =&gt; tp
      case NoType =&gt; tp
      case NoPrefix =&gt; tp
*/</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#133340" title="Types.this.Type">tp</a>
        <span class="comment">// throw new Error(&quot;mapOver inapplicable for &quot; + tp);</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]" id="133281">mapOverArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="456659">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="456660">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = 
      <a href="#67607" title="(xs: List[Types.this.Type], ys: List[Types.this.Symbol])(f: (Types.this.Type, Types.this.Symbol) =&gt; Types.this.Type)List[Types.this.Type]">map2Conserve</a><span class="delimiter">(</span><a href="#456659" title="List[Types.this.Type]">args</a>, <a href="#456660" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Type" id="456806">arg</a>, <a title="Types.this.Symbol" id="456807">tparam</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Int" id="456808">v</a> = <a href="#133272" title="=&gt; Int">variance</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#456807" title="Types.this.Symbol">tparam</a>.<span title="=&gt; Boolean">isContravariant</span><span class="delimiter">)</span> <a href="#133272" title="(x$1: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#133272" title="=&gt; Int">variance</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#456807" title="Types.this.Symbol">tparam</a>.<span title="=&gt; Boolean">isCovariant</span><span class="delimiter">)</span> <a href="#133272" title="(x$1: Int)Unit">variance</a> = <span title="Int(0)" class="int">0</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="456809">arg1</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456806" title="Types.this.Type">arg</a><span class="delimiter">)</span>
        <a href="#133272" title="(x$1: Int)Unit">variance</a> = <a href="#456808" title="Int">v</a>
        <a href="#456809" title="Types.this.Type">arg1</a>
      <span class="delimiter">}</span>

    <span class="comment">/** Map this function over given scope */</span>
    <span class="keyword">def</span> <a title="(scope: Types.this.Scope)Types.this.Scope" id="133282">mapOver</a><span class="delimiter">(</span><a title="Types.this.Scope" id="133337">scope</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a><span class="delimiter">)</span>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="456810">elems</a> = <a href="#133337" title="Types.this.Scope">scope</a>.<a href="Scopes.scala.html#112957" title="=&gt; List[Types.this.Symbol]">toList</a>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="456811">elems1</a> = <a href="#133283" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#456810" title="List[Types.this.Symbol]">elems</a><span class="delimiter">)</span>
      <span title="Types.this.Scope" class="keyword">if</span> <span class="delimiter">(</span><a href="#456811" title="List[Types.this.Symbol]">elems1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456810" title="List[Types.this.Symbol]">elems</a><span class="delimiter">)</span> <a href="#133337" title="Types.this.Scope">scope</a>
      <span class="keyword">else</span> <a href="Scopes.scala.html#112941" title="(decls: List[Types.this.Symbol])Types.this.Scope" class="keyword">new</a> <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a><span class="delimiter">(</span><a href="#456811" title="List[Types.this.Symbol]">elems1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Map this function over given list of symbols */</span>
    <span class="keyword">def</span> <a title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]" id="133283">mapOver</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="133334">origSyms</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span> 
      <span class="keyword">val</span> <a title="Boolean" id="456822">change</a> = <a href="#133334" title="List[Types.this.Symbol]">origSyms</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="456829">sym</a> =&gt;
        <span class="keyword">val</span> <a title="Int" id="456830">v</a> = <a href="#133272" title="=&gt; Int">variance</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#456829" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <a href="#133272" title="(x$1: Int)Unit">variance</a> = <span title="Int(0)" class="int">0</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="456831">result</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#456829" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span>
        <a href="#133272" title="(x$1: Int)Unit">variance</a> = <a href="#456830" title="Int">v</a>
        <a href="#456831" title="Types.this.Type">result</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#456829" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>
      <span class="delimiter">}</span>
      <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#456822" title="Boolean">change</a><span class="delimiter">)</span> <a href="#133334" title="List[Types.this.Symbol]">origSyms</a> <span class="comment">// fast path in case nothing changes due to map</span>
      <span class="keyword">else</span> <span class="delimiter">{</span> <span class="comment">// map is not the identity --&gt; do cloning properly</span>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="456832">clonedSyms</a> = <a href="#133334" title="List[Types.this.Symbol]">origSyms</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <span class="delimiter">(</span><a href="#456851" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107453" title="=&gt; Types.this.Symbol">cloneSymbol</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="456833">clonedInfos</a> = <a href="#456832" title="List[Types.this.Symbol]">clonedSyms</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#456898" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#133334" title="List[Types.this.Symbol]">origSyms</a>, <a href="#456832" title="List[Types.this.Symbol]">clonedSyms</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="456834">transformedInfos</a> = <a href="#456833" title="List[Types.this.Type]">clonedInfos</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a href="#67503" title="Types.this.TypeMap" class="keyword">this</a><span class="delimiter">)</span>
        <span title="(_1: List[Types.this.Symbol], _2: List[Types.this.Type])(List[Types.this.Symbol], List[Types.this.Type])" class="delimiter">(</span><a href="#456832" title="List[Types.this.Symbol]">clonedSyms</a>, <a href="#456834" title="List[Types.this.Type]">transformedInfos</a><span class="delimiter">)</span>.<span title="(implicit w1: List[Types.this.Symbol] =&gt; scala.collection.TraversableLike[Types.this.Symbol,List[Types.this.Symbol]], implicit w2: List[Types.this.Type] =&gt; scala.collection.IterableLike[Types.this.Type,List[Types.this.Type]])(List[Types.this.Symbol], List[Types.this.Type])#Zipped[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Type],Types.this.Type]">zipped</span> <span title="(f: (Types.this.Symbol, Types.this.Type) =&gt; Types.this.Symbol)(implicit cbf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <span class="delimiter">(</span><a href="#456986" title="Types.this.Symbol">_</a> <a href="Symbols.scala.html#107425" title="(info: Types.this.Type)x$66.type">setInfo</a> <a href="#456987" title="Types.this.Type">_</a><span class="delimiter">)</span>
        
        <a href="#456832" title="List[Types.this.Symbol]">clonedSyms</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>


    <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])List[Types.this.AnnotationInfo]" id="133284">mapOverAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="456763">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>
    : <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="457019">newAnnots</a> = <a href="#456763" title="List[Types.this.AnnotationInfo]">annots</a>.<span title="(f: Types.this.AnnotationInfo =&gt; scala.collection.GenTraversableOnce[Types.this.AnnotationInfo])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.AnnotationInfo],Types.this.AnnotationInfo,List[Types.this.AnnotationInfo]])List[Types.this.AnnotationInfo]">flatMap</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.AnnotationInfo,List[Types.this.AnnotationInfo]]" class="delimiter">(</span><a href="#133285" title="(annot: Types.this.AnnotationInfo)Option[Types.this.AnnotationInfo]">mapOver</a><span title="(xo: Option[Types.this.AnnotationInfo])Iterable[Types.this.AnnotationInfo]" class="delimiter">(</span><a href="#457036" title="Types.this.AnnotationInfo">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="List[Types.this.AnnotationInfo]" class="keyword">if</span> <span class="delimiter">(</span><a href="#133276" title="(l1: List[Types.this.AnnotationInfo], l2: List[Types.this.AnnotationInfo])Boolean">allEq</a><span class="delimiter">(</span><a href="#457019" title="List[Types.this.AnnotationInfo]">newAnnots</a>, <a href="#456763" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#456763" title="List[Types.this.AnnotationInfo]">annots</a>
      <span class="keyword">else</span>
        <a href="#457019" title="List[Types.this.AnnotationInfo]">newAnnots</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(annot: Types.this.AnnotationInfo)Option[Types.this.AnnotationInfo]" id="133285">mapOver</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="133306">annot</a>: <a href="AnnotationInfos.scala.html#67743" title="Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span>: <span title="Option[Types.this.AnnotationInfo]">Option</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> AnnotationInfo<a href="#457262" title="(Types.this.Type, List[Types.this.Tree], List[(Types.this.Name, Types.this.ClassfileAnnotArg)])" class="delimiter">(</a><a href="#457261" title="Types.this.Type" id="457262">atp</a>, <a href="#457261" title="List[Types.this.Tree]" id="457263">args</a>, <a href="#457261" title="List[(Types.this.Name, Types.this.ClassfileAnnotArg)]" id="457264">assocs</a><span class="delimiter">)</span> = <a href="#133306" title="Types.this.AnnotationInfo">annot</a>

      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133274" title="=&gt; Boolean">dropNonConstraintAnnotations</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
          <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#457262" title="Types.this.Type">atp</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#107447" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="Definitions.scala.html#106201" title="=&gt; Types.this.Symbol">TypeConstraintClass</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">return</span> <span title="object None">None</span>

      <span class="keyword">val</span> <a title="Types.this.Type" id="457265">atp1</a> = <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#457262" title="Types.this.Type">atp</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Tree]" id="457266">args1</a> = <a href="#133286" title="(args: List[Types.this.Tree])List[Types.this.Tree]">mapOverAnnotArgs</a><span class="delimiter">(</span><a href="#457263" title="List[Types.this.Tree]">args</a><span class="delimiter">)</span>
      <span class="comment">// there is no need to rewrite assocs, as they are constants</span>

      <span title="Option[Types.this.AnnotationInfo]" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#457263" title="List[Types.this.Tree]">args</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#457266" title="List[Types.this.Tree]">args1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#457262" title="Types.this.Type">atp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#457265" title="Types.this.Type">atp1</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="(x: Types.this.AnnotationInfo)Some[Types.this.AnnotationInfo]">Some</span><span class="delimiter">(</span><a href="#133306" title="Types.this.AnnotationInfo">annot</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Option[Types.this.AnnotationInfo]" class="keyword">if</span> <span class="delimiter">(</span><a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#457266" title="List[Types.this.Tree]">args1</a>, <a href="#457263" title="List[Types.this.Tree]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="(x: Types.this.AnnotationInfo)Some[Types.this.AnnotationInfo]">Some</span><span class="delimiter">(</span><a href="AnnotationInfos.scala.html#134132" title="(atp: Types.this.Type, args: List[Types.this.Tree], assocs: List[(Types.this.Name, Types.this.ClassfileAnnotArg)])Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">(</span><a href="#457265" title="Types.this.Type">atp1</a>, <a href="#457266" title="List[Types.this.Tree]">args1</a>, <a href="#457264" title="List[(Types.this.Name, Types.this.ClassfileAnnotArg)]">assocs</a><span class="delimiter">)</span>.<a href="AnnotationInfos.scala.html#133324" title="(pos: scala.tools.nsc.util.Position)Types.this.AnnotationInfo">setPos</a><span class="delimiter">(</span><a href="#133306" title="Types.this.AnnotationInfo">annot</a>.<a href="AnnotationInfos.scala.html#133323" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <span title="object None">None</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Map over a set of annotation arguments.  If any
     *  of the arguments cannot be mapped, then return Nil.  */</span>
    <span class="keyword">def</span> <a title="(args: List[Types.this.Tree])List[Types.this.Tree]" id="133286">mapOverAnnotArgs</a><span class="delimiter">(</span><a title="List[Types.this.Tree]" id="457311">args</a>: <span title="List[Types.this.Tree]">List</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Tree]">List</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Tree]" id="457321">args1</a> = <a href="#457311" title="List[Types.this.Tree]">args</a> <span title="(f: Types.this.Tree =&gt; scala.collection.GenTraversableOnce[Types.this.Tree])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Tree],Types.this.Tree,List[Types.this.Tree]])List[Types.this.Tree]">flatMap</span> <span class="delimiter">(</span><a title="Types.this.Tree" id="457338">x</a> =&gt; <a href="#133287" title="(tree: Types.this.Tree)Option[Types.this.Tree]">mapOver</a><span title="(xo: Option[Types.this.Tree])Iterable[Types.this.Tree]" class="delimiter">(</span><a href="#457338" title="Types.this.Tree">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="List[Types.this.Tree]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#457321" title="List[Types.this.Tree]">args1</a>, <a href="#457311" title="List[Types.this.Tree]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="object Nil">Nil</span>
      <span class="keyword">else</span> <span title="List[Types.this.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#133276" title="(l1: List[Types.this.Tree], l2: List[Types.this.Tree])Boolean">allEq</a><span class="delimiter">(</span><a href="#457311" title="List[Types.this.Tree]">args</a>, <a href="#457321" title="List[Types.this.Tree]">args1</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#457311" title="List[Types.this.Tree]">args</a>
      <span class="keyword">else</span>
        <a href="#457321" title="List[Types.this.Tree]">args1</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Option[Types.this.Tree]" id="133287">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="133303">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Option[Types.this.Tree]">Option</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span> =
      <span title="(x: Types.this.Tree)Some[Types.this.Tree]">Some</span><span class="delimiter">(</span><a href="#133288" title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree">mapOver</a><span class="delimiter">(</span><a href="#133303" title="Types.this.Tree">tree</a>, <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;<span title="Nothing" class="keyword">return</span> <span title="object None">None</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">/** Map a tree that is part of an annotation argument.
     *  If the tree cannot be mapped, then invoke giveup().
     *  The default is to transform the tree with
     *  TypeMapTransformer.
     */</span>
    <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="133288">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="133298">tree</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="133299">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = 
      <span class="delimiter">(</span><span title="TypeMap.this.TypeMapTransformer" class="keyword">new</span> <a href="#133289" title="TypeMap.this.TypeMapTransformer">TypeMapTransformer</a><span class="delimiter">)</span>.<a href="#457576" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#133298" title="Types.this.Tree">tree</a><span class="delimiter">)</span>

    <span class="comment">/** This transformer leaves the tree alone except to remap
     *  its types. */</span>
    <span class="keyword">class</span> <a title="class TypeMapTransformer extends Types.this.Transformer with ScalaObject" id="133289">TypeMapTransformer</a> <a href="#133289" title="ScalaObject" class="keyword">extends</a> <a href="../ast/Trees.scala.html#67825" title="Types.this.Transformer">Transformer</a> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="457576">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="457578">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Tree" id="457582">tree1</a> = <a href="#133289" title="TypeMap.this.TypeMapTransformer" class="keyword">super</a>.<a href="../ast/Trees.scala.html#162512" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#457578" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="457583">tpe1</a> = <a href="#67503" title="(v1: Types.this.Type)Types.this.Type">TypeMap</a>.<span class="keyword">this</span><span class="delimiter">(</span><a href="#457582" title="Types.this.Tree">tree1</a>.<span title="=&gt; Types.this.Type">tpe</span><span class="delimiter">)</span>
        <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#457578" title="Types.this.Tree">tree</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#457582" title="Types.this.Tree">tree1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#457578" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Type">tpe</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#457583" title="Types.this.Type">tpe1</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#457578" title="Types.this.Tree">tree</a>
        <span class="keyword">else</span>
          <a href="../ast/Trees.scala.html#67777" title="implicit scala.tools.nsc.ast.Trees.treeWrapper : (tree: Types.this.Tree)Types.this.TreeOps">tree1</a>.<a href="../ast/Trees.scala.html#109042" title="=&gt; Types.this.Tree">shallowDuplicate</a>.<span title="(tp: Types.this.Type)Types.this.Tree">setType</span><span class="delimiter">(</span><a href="#457583" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A type map that always returns the input type unchanged */</span>
  <span class="keyword">object</span> <a title="object Types.this.IdentityTypeMap" id="67504">IdentityTypeMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="457596">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="457598">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#457598" title="Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeTraverser extends Types.this.TypeMap with ScalaObject" id="67506">TypeTraverser</a> <a href="#67506" title="ScalaObject" class="keyword">extends</a> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449228">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="449606">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Unit">Unit</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="449229">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="457603">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span> <a href="#449228" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#457603" title="Types.this.Type">tp</a><span class="delimiter">)</span>; <a href="#457603" title="Types.this.Type">tp</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeCollector[T] extends Types.this.TypeTraverser with ScalaObject" id="67507">TypeCollector</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67508">T</a><span class="delimiter">]</span><a href="#67507" title="ScalaObject" class="delimiter">(</a><a title="T" id="449239">initial</a>: <a href="#67508" title="T">T</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67506" title="Types.this.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="T" id="449234">result</a>: <a href="#67508" title="T">T</a> = _
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)T" id="449236">collect</a><span class="delimiter">(</span><a title="Types.this.Type" id="449602">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#449234" title="(x$1: T)Unit">result</a> = <a href="#449239" title="T">initial</a>
      <a href="#449228" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#449602" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <a href="#449234" title="=&gt; T">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]" id="67509">emptySymMap</a>   = immutable.<span title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</span><span title="(elems: (Types.this.Symbol, Types.this.Symbol)*)scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span> 
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Int]" id="67511">emptySymCount</a> = immutable.<span title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</span><span title="(elems: (Types.this.Symbol, Int)*)scala.collection.immutable.Map[Types.this.Symbol,Int]" class="delimiter">[</span><a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <span title="Int">Int</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span> 

  <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol, tparams: List[Types.this.Symbol])List[Types.this.Symbol]" id="67513">typeParamsToExistentials</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="425368">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="425369">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="457608">eparams</a> = <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="457679">tparam</a>, <a title="Int" id="457680">i</a><span class="delimiter">)</span> &lt;- <a href="#425369" title="List[Types.this.Symbol]">tparams</a>.<a href="#457652" title="(f: (Types.this.Symbol, Int) =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Symbol, Int)],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">zipWithIndex</a><span class="delimiter">)</span> <span class="keyword">yield</span> <span class="delimiter">{</span>
      <a href="#425368" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107303" title="(pos: Types.this.Position, name: Types.this.TypeName)Types.this.Symbol">newExistential</a><span class="delimiter">(</span><a href="#425368" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107263" title="=&gt; Types.this.Position">pos</a>, <a href="Names.scala.html#66906" title="(s: String)Types.this.TypeName">newTypeName</a><span class="delimiter">(</span><span title="java.lang.String(&quot;?&quot;)" class="string">&quot;?&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#457680" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#107425" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a><span class="delimiter">(</span><a href="#457679" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="457736">tparam</a> &lt;- <a href="#457608" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)Unit">eparams</a><span class="delimiter">)</span> <a href="#457736" title="Types.this.Symbol">tparam</a> <a href="Symbols.scala.html#107425" title="(info: Types.this.Type)tparam.type">setInfo</a> <a href="#457736" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#425369" title="List[Types.this.Symbol]">tparams</a>, <a href="#457608" title="List[Types.this.Symbol]">eparams</a><span class="delimiter">)</span>
    <a href="#457608" title="List[Types.this.Symbol]">eparams</a>
  <span class="delimiter">}</span>
  
  <span class="comment">//  note: it's important to write the two tests in this order,</span>
  <span class="comment">//  as only typeParams forces the classfile to be read. See #400</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="67514">isRawIfWithoutArgs</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="258502">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
    <a href="#258502" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#258502" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#258502" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isJavaDefined</span>

  <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean" id="67515">isRaw</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="258498">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="258499">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = 
    <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67514" title="(sym: Types.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span><a href="#258498" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#258499" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span>
  
  <span class="comment">/** Is type tp a ``raw type''? */</span>
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="67516">isRawType</a><span class="delimiter">(</span><a title="Types.this.Type" id="258493">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#258493" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="258496">sym</a>, <a title="List[Types.this.Type]" id="258497">args</a><span class="delimiter">)</span> =&gt; <a href="#67515" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><span class="delimiter">(</span><a href="#258496" title="Types.this.Symbol">sym</a>, <a href="#258497" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>
      
  <span class="comment">/** The raw to existential map converts a ``raw type'' to an existential type.
   *  It is necessary because we might have read a raw type of a 
   *  parameterized Java class from a class file. At the time we read the type
   *  the corresponding class file might still not be read, so we do not
   *  know what the type parameters of the type are. Therefore
   *  the conversion of raw types to existential types might not have taken place
   *  in ClassFileparser.sigToType (where it is usually done)
   */</span>
  <span class="keyword">object</span> <a title="object Types.this.rawToExistential" id="67517">rawToExistential</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="258508">expanded</a> = immutable.<span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="scala.collection.immutable.Set[Types.this.Type]" id="258511">generated</a> = immutable.<span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.Type*)scala.collection.immutable.Set[Types.this.Type]" class="delimiter">[</span><a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="258513">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="258514">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#258514" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="457747">pre</a>, <a title="Types.this.Symbol" id="457748">sym</a>, <a href="#457750" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#67514" title="(sym: Types.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span><a href="#457748" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#258508" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">expanded</a> <span title="(elem: Types.this.Symbol)Boolean">contains</span> <a href="#457748" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="Definitions.scala.html#106077" title="=&gt; Types.this.Symbol">AnyRefClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
        <span class="keyword">else</span> <span class="keyword">try</span> <span class="delimiter">{</span>
          <a href="#258508" title="(x$1: scala.collection.immutable.Set[Types.this.Symbol])Unit">expanded</a> <span title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">+=</span> <a href="#457748" title="Types.this.Symbol">sym</a>
          <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="457765">eparams</a> = <a href="#133283" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#67513" title="(clazz: Types.this.Symbol, tparams: List[Types.this.Symbol])List[Types.this.Symbol]">typeParamsToExistentials</a><span class="delimiter">(</span><a href="#457748" title="Types.this.Symbol">sym</a>, <a href="#457748" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#67482" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#457765" title="List[Types.this.Symbol]">eparams</a>, <a href="#67472" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#258513" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#457747" title="Types.this.Type">pre</a><span class="delimiter">)</span>, <a href="#457748" title="Types.this.Symbol">sym</a>, <a href="#457765" title="List[Types.this.Symbol]">eparams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#457800" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> 
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
          <a href="#258508" title="(x$1: scala.collection.immutable.Set[Types.this.Symbol])Unit">expanded</a> <span title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">-=</span> <a href="#457748" title="Types.this.Symbol">sym</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#258511" title="=&gt; scala.collection.immutable.Set[Types.this.Type]">generated</a> <span title="(elem: Types.this.Type)Boolean">contains</span> <a href="#258514" title="Types.this.Type">tp</a><span class="delimiter">)</span> =&gt; <span class="comment">// to avoid infinite expansions. todo: not sure whether this is needed</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="457853">result</a> = <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#258514" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <a href="#258511" title="(x$1: scala.collection.immutable.Set[Types.this.Type])Unit">generated</a> <span title="(elem: Types.this.Type)scala.collection.immutable.Set[Types.this.Type]">+=</span> <a href="#457853" title="Types.this.Type">result</a>
        <a href="#457853" title="Types.this.Type">result</a>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#258514" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(hi: Types.this.Type)Types.this.TypeBounds" id="67519">singletonBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="449626">hi</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#67412" title="object Types.this.TypeBounds">TypeBounds</a>.<a href="#148435" title="(hi: Types.this.Type)Types.this.TypeBounds">upper</a><span class="delimiter">(</span><a href="#67477" title="(tps: List[Types.this.Type])Types.this.Type">intersectionType</a><span class="delimiter">(</span><span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#449626" title="Types.this.Type">hi</a>, <a href="Definitions.scala.html#106203" title="=&gt; Types.this.Symbol">SingletonClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to compute the asSeenFrom method  */</span>
  <span class="keyword">class</span> <a title="class AsSeenFromMap extends Types.this.TypeMap with ScalaObject" id="67520">AsSeenFromMap</a><a href="#67520" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="449853">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="449854">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="449841">dropNonConstraintAnnotations</a> = <span title="Boolean(true)" class="keyword">true</span>

    <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="449844">capturedParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span> 

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="449846">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="457891">tree</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="457892">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="object annotationArgRewriter" id="457895">annotationArgRewriter</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#133289" title="AsSeenFromMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>
        <span class="comment">/** Rewrite `This` trees in annotation argument trees */</span>
        <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="457898">rewriteThis</a><span class="delimiter">(</span><a title="Types.this.Tree" id="457901">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> =
          <a href="#457901" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Types.this.Tree">This</span><span class="delimiter">(</span>_<span class="delimiter">)</span>
            <span class="keyword">if</span> <span class="delimiter">(</span><a href="#457901" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span> <a href="Symbols.scala.html#107447" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#449854" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
               <span class="delimiter">(</span><a href="#449853" title="Types.this.Type">pre</a>.<a href="#105317" title="=&gt; Types.this.Type">widen</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#107447" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#457901" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span> =&gt;
              <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#449853" title="Types.this.Type">pre</a>.<a href="#105305" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// XXX why is this in this method? pull it out and guard the call `annotationArgRewriter.transform(tree)`?</span>
                <span class="keyword">val</span> <a title="Types.this.TermSymbol" id="457907">termSym</a> =
                  <a href="#449853" title="Types.this.Type">pre</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#107279" title="(pos: Types.this.Position, name: Types.this.TermName)Types.this.TermSymbol">newValue</a><span class="delimiter">(</span>
                    <a href="#449853" title="Types.this.Type">pre</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107263" title="=&gt; Types.this.Position">pos</a>,
                    <a href="#449853" title="Types.this.Type">pre</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#96577" title="=&gt; Types.this.TermName">toTermName</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107425" title="(info: Types.this.Type)Types.this.TermSymbol">setInfo</a><span class="delimiter">(</span><a href="#449853" title="Types.this.Type">pre</a><span class="delimiter">)</span>  <span class="comment">// what symbol should really be used?</span>
                <a href="../ast/TreeGen.scala.html#105424" title="(tpe: Types.this.gen.global.Type, termSym: Types.this.gen.global.Symbol)Types.this.gen.global.Tree">mkAttributedQualifier</a><span class="delimiter">(</span><a href="#449853" title="Types.this.Type">pre</a>, <a href="#457907" title="Types.this.TermSymbol">termSym</a><span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">else</span>
                <a href="#457892" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span>
            
            <span class="keyword">case</span> <a title="Types.this.Tree" id="457933">tree</a> =&gt; <a href="#457933" title="Types.this.Tree">tree</a>
          <span class="delimiter">}</span>

        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="457899">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="457934">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Tree" id="457937">tree1</a> = <a href="#457898" title="(tree: Types.this.Tree)Types.this.Tree">rewriteThis</a><span class="delimiter">(</span><span class="keyword">super</span>.<a href="#457576" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#457934" title="Types.this.Tree">tree</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#457937" title="Types.this.Tree">tree1</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#457895" title="object annotationArgRewriter">annotationArgRewriter</a>.<a href="#457899" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#457891" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">var</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]" id="449848">capturedPre</a> = <a href="#67509" title="=&gt; scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]">emptySymMap</a>

    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="449850">stabilize</a><span class="delimiter">(</span><a title="Types.this.Type" id="457941">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="457942">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
      <a href="#449848" title="=&gt; scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]">capturedPre</a>.<span title="(key: Types.this.Symbol, default: =&gt; Types.this.Symbol)Types.this.Symbol">getOrElse</span><span class="delimiter">(</span><a href="#457942" title="Types.this.Symbol">clazz</a>, <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="457952">qvar</a> = <a href="#457942" title="Types.this.Symbol">clazz</a> <a href="Symbols.scala.html#107304" title="(suffix: String)Types.this.Symbol">freshExistential</a> <span title="java.lang.String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span> <a href="Symbols.scala.html#107425" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a> <a href="#67519" title="(hi: Types.this.Type)Types.this.TypeBounds">singletonBounds</a><span class="delimiter">(</span><a href="#457941" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <a href="#449848" title="(x$1: scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol])Unit">capturedPre</a> <span title="(kv: (Types.this.Symbol, Types.this.Symbol))scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]">+=</span> <span class="delimiter">(</span><a href="#457942" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">clazz</a> <span title="(y: Types.this.Symbol)(Types.this.Symbol, Types.this.Symbol)">-&gt;</span> <a href="#457952" title="Types.this.Symbol">qvar</a><span class="delimiter">)</span>
          <a href="#449844" title="(x$1: List[Types.this.Symbol])Unit">capturedParams</a> = <a href="#457952" title="Types.this.Symbol">qvar</a> <a href="#458046" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#449844" title="=&gt; List[Types.this.Symbol]">capturedParams</a>
          <a href="#457952" title="Types.this.Symbol">qvar</a>
      <span class="delimiter">}</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>

    <span class="comment">/** Return pre.baseType(clazz), or if that's NoType and clazz is a refinement, pre itself.
     *  See bug397.scala for an example where the second alternative is needed.
     *  The problem is that when forming the base type sequence of an abstract type,
     *  any refinements in the base type list might be regenerated, and thus acquire
     *  new class symbols. However, since refinements always have non-interesting prefixes
     *  it looks OK to me to just take the prefix directly. */</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="449851">base</a><span class="delimiter">(</span><a title="Types.this.Type" id="458055">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="458056">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="458059">b</a> = <a href="#458055" title="Types.this.Type">pre</a>.<a href="#105358" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#458056" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458059" title="Types.this.Type">b</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450850" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#458056" title="Types.this.Symbol">clazz</a>.<span title="=&gt; Boolean">isRefinementClass</span><span class="delimiter">)</span> <a href="#458055" title="Types.this.Type">pre</a>
      <span class="keyword">else</span> <a href="#458059" title="Types.this.Type">b</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="449852">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="449855">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#449853" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#449853" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#449854" title="Types.this.Symbol">clazz</a>.<span title="=&gt; Boolean">isClass</span><span class="delimiter">)</span> <a href="#449855" title="Types.this.Type">tp</a>
      <span class="keyword">else</span> <a href="#449855" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="458064">sym</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="458065">toPrefix</a><span class="delimiter">(</span><a title="Types.this.Type" id="458066">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="458067">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#458066" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#458066" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#458067" title="Types.this.Symbol">clazz</a>.<span title="=&gt; Boolean">isClass</span><span class="delimiter">)</span> <a href="#449855" title="Types.this.Type">tp</a>
            <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#458064" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#107447" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#458067" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
                     <span class="delimiter">(</span><a href="#458066" title="Types.this.Type">pre</a>.<a href="#105317" title="=&gt; Types.this.Type">widen</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#107447" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#458064" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="458071">pre1</a> = <a href="#458066" title="Types.this.Type">pre</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Types.this.Type">SuperType</span><span class="delimiter">(</span><a title="Types.this.Type" id="458072">thistp</a>, _<span class="delimiter">)</span> =&gt; <a href="#458072" title="Types.this.Type">thistp</a>
                <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#458066" title="Types.this.Type">pre</a>
              <span class="delimiter">}</span>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#458071" title="Types.this.Type">pre1</a>.<a href="#105305" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">||</span> 
                    <a href="#458071" title="Types.this.Type">pre1</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isPackageClass</span> <span title="(x: Boolean)Boolean">||</span> 
                    <a href="#458071" title="Types.this.Type">pre1</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isModuleClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#458071" title="Types.this.Type">pre1</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107384" title="=&gt; Boolean">isStatic</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="#449850" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">stabilize</a><span class="delimiter">(</span><a href="#458071" title="Types.this.Type">pre1</a>, <a href="#458064" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                <a href="#458071" title="Types.this.Type">pre1</a>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <a href="#458065" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toPrefix</a><span class="delimiter">(</span><a href="#449851" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">base</a><span class="delimiter">(</span><a href="#458066" title="Types.this.Type">pre</a>, <a href="#458067" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>.<a href="#105323" title="=&gt; Types.this.Type">prefix</a>, <a href="#458067" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
          <a href="#458065" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toPrefix</a><span class="delimiter">(</span><a href="#449853" title="Types.this.Type">pre</a>, <a href="#449854" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="458073">pre</a>, <a title="Types.this.Symbol" id="458074">sym</a><span class="delimiter">)</span> =&gt;
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458074" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span><span class="delimiter">)</span> <a href="#449855" title="Types.this.Type">tp</a> <span class="comment">// short path</span>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="458075">pre1</a> = <a href="#449852" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#458073" title="Types.this.Type">pre</a><span class="delimiter">)</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458075" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#458073" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#449855" title="Types.this.Type">tp</a>
            <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458075" title="Types.this.Type">pre1</a>.<a href="#105305" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#67468" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#458075" title="Types.this.Type">pre1</a>, <a href="#458074" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> 
            <span class="keyword">else</span> <a href="#458075" title="Types.this.Type">pre1</a>.<a href="#105361" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#458074" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#105327" title="=&gt; Types.this.Type">resultType</a> <span class="comment">//todo: this should be rolled into existential abstraction</span>
          <span class="delimiter">}</span>
        <span class="comment">// AM: Martin, is this description accurate?</span>
        <span class="comment">// walk the owner chain of `clazz` (the original argument to asSeenFrom) until we find the type param's owner (while rewriting pre as we crawl up the owner chain)</span>
        <span class="comment">// once we're at the owner, extract the information that pre encodes about the type param,</span>
        <span class="comment">// by minimally subsuming pre to the type instance of the class that owns the type param,</span>
        <span class="comment">// the type we're looking for is the type instance's type argument at the position corresponding to the type parameter</span>
        <span class="comment">// optimisation: skip this type parameter if it's not owned by a class, as those params are not influenced by the prefix through which they are seen</span>
        <span class="comment">// (concretely: type params of anonymous type functions, which currently can only arise from normalising type aliases, are owned by the type alias of which they are the eta-expansion) </span>
        <span class="comment">// (skolems also aren't affected: they are ruled out by the isTypeParameter check)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="458086">prefix</a>, <a title="Types.this.Symbol" id="458087">sym</a>, <a title="List[Types.this.Type]" id="458088">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#458087" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isTypeParameter</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#458087" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>.<span title="=&gt; Boolean">isClass</span><span class="delimiter">)</span> =&gt;
          <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="458089">toInstance</a><span class="delimiter">(</span><a title="Types.this.Type" id="458090">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="458091">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#458090" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#458090" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#458091" title="Types.this.Symbol">clazz</a>.<span title="=&gt; Boolean">isClass</span><span class="delimiter">)</span> <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#449855" title="Types.this.Type">tp</a><span class="delimiter">)</span> 
            <span class="comment">//@M! see test pos/tcpoly_return_overriding.scala why mapOver is necessary</span>
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span class="keyword">def</span> <a title="=&gt; Nothing" id="458100">throwError</a> = <a href="SymbolTable.scala.html#64779" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#449855" title="Types.this.Type">tp</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="#458087" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107518" title="=&gt; java.lang.String">locationString</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; cannot be instantiated from &quot;)" class="string">&quot; cannot be instantiated from &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#458090" title="Types.this.Type">pre</a>.<a href="#105317" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
                                    
              <span class="keyword">def</span> <a title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type" id="458101">instParam</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="458107">ps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="458108">as</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = 
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458107" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#458100" title="=&gt; Nothing">throwError</a>
                <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458087" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#458107" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; Types.this.Symbol">head</span><span class="delimiter">)</span>  
                  <span class="comment">// @M! don't just replace the whole thing, might be followed by type application</span>
                  <a href="#67478" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#458108" title="List[Types.this.Type]">as</a>.<span title="=&gt; Types.this.Type">head</span>, <a href="#458088" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a href="#67520" title="Types.this.AsSeenFromMap" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// @M: was as.head   </span>
                <span class="keyword">else</span> <a href="#458101" title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type">instParam</a><span class="delimiter">(</span><a href="#458107" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>, <a href="#458108" title="List[Types.this.Type]">as</a>.<span title="=&gt; List[Types.this.Type]">tail</span><span class="delimiter">)</span>;
              <span class="keyword">val</span> <a title="Types.this.Symbol" id="458102">symclazz</a> = <a href="#458087" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458102" title="Types.this.Symbol">symclazz</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#458091" title="Types.this.Symbol">clazz</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#458090" title="Types.this.Type">pre</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#67458" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#458090" title="Types.this.Type">pre</a>.<a href="#105317" title="=&gt; Types.this.Type">widen</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#107447" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#458102" title="Types.this.Symbol">symclazz</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="comment">// have to deconst because it may be a Class[T].</span>
                <a href="#458090" title="Types.this.Type">pre</a>.<a href="#105358" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#458102" title="Types.this.Symbol">symclazz</a><span class="delimiter">)</span>.<a href="#105318" title="=&gt; Types.this.Type">deconst</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
                  <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="458120">basesym</a>, <a title="List[Types.this.Type]" id="458121">baseargs</a><span class="delimiter">)</span> =&gt;
                    <span class="comment">//Console.println(&quot;instantiating &quot; + sym + &quot; from &quot; + basesym + &quot; with &quot; + basesym.typeParams + &quot; and &quot; + baseargs+&quot;, pre = &quot;+pre+&quot;, symclazz = &quot;+symclazz);//DEBUG</span>
                    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#458120" title="Types.this.Symbol">basesym</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#458121" title="List[Types.this.Type]">baseargs</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                      <a href="#458101" title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type">instParam</a><span class="delimiter">(</span><a href="#458120" title="Types.this.Symbol">basesym</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#458121" title="List[Types.this.Type]">baseargs</a><span class="delimiter">)</span>
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                      <span title="Nothing" class="keyword">throw</span> <a href="#313894" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#67658" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span>
                        <span title="java.lang.String(&quot;something is wrong (wrong class file?): &quot;)" class="string">&quot;something is wrong (wrong class file?): &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#458120" title="Types.this.Symbol">basesym</a><span title="(x$1: Any)java.lang.String">+</span> 
                        <span title="java.lang.String(&quot; with type parameters &quot;)" class="string">&quot; with type parameters &quot;</span><span title="(x$1: Any)java.lang.String">+</span>
                        <a href="#458120" title="Types.this.Symbol">basesym</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="(f: Types.this.Symbol =&gt; Types.this.Name)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Name,List[Types.this.Name]])List[Types.this.Name]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.Name,List[Types.this.Name]]" class="delimiter">(</span><a href="#458145" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;[&quot;)" class="string">&quot;[&quot;</span>,<span title="java.lang.String(&quot;,&quot;)" class="string">&quot;,&quot;</span>,<span title="java.lang.String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span><span title="(x$1: Any)java.lang.String">+</span>
                        <span title="java.lang.String(&quot; gets applied to arguments &quot;)" class="string">&quot; gets applied to arguments &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#458121" title="List[Types.this.Type]">baseargs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;[&quot;)" class="string">&quot;[&quot;</span>,<span title="java.lang.String(&quot;,&quot;)" class="string">&quot;,&quot;</span>,<span title="java.lang.String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;, phase = &quot;)" class="string">&quot;, phase = &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a><span class="delimiter">)</span>
                    <span class="delimiter">}</span>
                  <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="458182">tparams</a>, <a title="Types.this.Type" id="458183">qtpe</a><span class="delimiter">)</span> =&gt;
                    <a href="#449844" title="(x$1: List[Types.this.Symbol])Unit">capturedParams</a> = <a href="#449844" title="=&gt; List[Types.this.Symbol]">capturedParams</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">union</span> <a href="#458182" title="List[Types.this.Symbol]">tparams</a>
                    <a href="#458089" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toInstance</a><span class="delimiter">(</span><a href="#458183" title="Types.this.Type">qtpe</a>, <a href="#458091" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
                  <span class="keyword">case</span> <span title="Nothing">_</span> =&gt;
                    <a href="#458100" title="=&gt; Nothing">throwError</a>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#458089" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toInstance</a><span class="delimiter">(</span><a href="#449851" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">base</a><span class="delimiter">(</span><a href="#458090" title="Types.this.Type">pre</a>, <a href="#458091" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>.<a href="#105323" title="=&gt; Types.this.Type">prefix</a>, <a href="#458091" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <a href="#458089" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toInstance</a><span class="delimiter">(</span><a href="#449853" title="Types.this.Type">pre</a>, <a href="#449854" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#449855" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A base class to compute all substitutions */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SubstMap[T] extends Types.this.TypeMap with ScalaObject" id="67521">SubstMap</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67522">T</a><span class="delimiter">]</span><a href="#67521" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="167387">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[T]" id="167388">to</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Types.this.Symbol =&gt; Boolean" id="167378">fromContains</a> = <span class="delimiter">(</span>x: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =&gt; <a href="#167387" title="List[Types.this.Symbol]">from</a>.<span title="(elem: Any)Boolean">contains</span><span class="delimiter">(</span><a href="#167417" title="Types.this.Symbol">x</a><span class="delimiter">)</span> <span class="comment">//from.toSet &lt;-- traversing short lists seems to be faster than allocating sets</span>
    <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#167387" title="List[Types.this.Symbol]">from</a>, <a href="#167388" title="List[T]">to</a><span class="delimiter">)</span>, <span title="java.lang.String(&quot;Unsound substitution from &quot;)" class="string">&quot;Unsound substitution from &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#167387" title="List[Types.this.Symbol]">from</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; to &quot;)" class="string">&quot; to &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#167388" title="List[T]">to</a><span class="delimiter">)</span>

    <span class="comment">/** Are `sym' and `sym1' the same.
     *  Can be tuned by subclasses.
     */</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, sym1: Types.this.Symbol)Boolean" id="167380">matches</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="458254">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="458255">sym1</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#458254" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#458255" title="Types.this.Symbol">sym1</a>

    <span class="comment">/** Map target to type, can be tuned by subclasses */</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(fromtp: Types.this.Type, tp: T)Types.this.Type" id="167381">toType</a><span class="delimiter">(</span><a title="Types.this.Type" id="458257">fromtp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="T" id="458258">tp</a>: <a href="#67522" title="T">T</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a>

    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="167382">renameBoundSyms</a><span class="delimiter">(</span><a title="Types.this.Type" id="458260">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#458260" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="458262">ps</a>, <a title="Types.this.Type" id="458263">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="458264">ps1</a> = <a href="Symbols.scala.html#67330" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#458262" title="List[Types.this.Symbol]">ps</a><span class="delimiter">)</span>
        <a href="#67475" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#458260" title="Types.this.Type">tp</a>, <a href="#458264" title="List[Types.this.Symbol]">ps1</a>, <a href="#167382" title="(tp: Types.this.Type)Types.this.Type">renameBoundSyms</a><span class="delimiter">(</span><a href="#458263" title="Types.this.Type">restp</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#458262" title="List[Types.this.Symbol]">ps</a>, <a href="#458264" title="List[Types.this.Symbol]">ps1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.PolyType">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="458299">bs</a>, <a title="Types.this.Type" id="458300">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="458301">bs1</a> = <a href="Symbols.scala.html#67330" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#458299" title="List[Types.this.Symbol]">bs</a><span class="delimiter">)</span>
        <a href="#148857" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#458301" title="List[Types.this.Symbol]">bs1</a>, <a href="#167382" title="(tp: Types.this.Type)Types.this.Type">renameBoundSyms</a><span class="delimiter">(</span><a href="#458300" title="Types.this.Type">restp</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#458299" title="List[Types.this.Symbol]">bs</a>, <a href="#458301" title="List[Types.this.Symbol]">bs1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.ExistentialType">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="458336">bs</a>, <a title="Types.this.Type" id="458337">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="458338">bs1</a> = <a href="Symbols.scala.html#67330" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#458336" title="List[Types.this.Symbol]">bs</a><span class="delimiter">)</span>
        <a href="#149074" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">ExistentialType</a><span class="delimiter">(</span><a href="#458338" title="List[Types.this.Symbol]">bs1</a>, <a href="#458337" title="Types.this.Type">restp</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#458336" title="List[Types.this.Symbol]">bs</a>, <a href="#458338" title="List[Types.this.Symbol]">bs1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#458260" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp0: Types.this.Type)Types.this.Type" id="167383">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="167426">tp0</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#167387" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#167426" title="Types.this.Type">tp0</a> <span class="keyword">else</span> <span class="delimiter">{</span>
      @tailrec <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type" id="458373">subst</a><span class="delimiter">(</span><a title="Types.this.Type" id="458377">tp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="458378">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="458379">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[T]" id="458380">to</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458379" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#458377" title="Types.this.Type">tp</a>
        <span class="comment">// else if (to.isEmpty) error(&quot;Unexpected substitution on '%s': from = %s but to == Nil&quot;.format(tp, from))</span>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#167380" title="(sym: Types.this.Symbol, sym1: Types.this.Symbol)Boolean">matches</a><span class="delimiter">(</span><a href="#458379" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Types.this.Symbol">head</span>, <a href="#458378" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#167381" title="(fromtp: Types.this.Type, tp: T)Types.this.Type">toType</a><span class="delimiter">(</span><a href="#458377" title="Types.this.Type">tp</a>, <a href="#458380" title="List[T]">to</a>.<span title="=&gt; T">head</span><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#458373" title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#458377" title="Types.this.Type">tp</a>, <a href="#458378" title="Types.this.Symbol">sym</a>, <a href="#458379" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>, <a href="#458380" title="List[T]">to</a>.<span title="=&gt; List[T]">tail</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="458374">boundSyms</a> = <a href="#167426" title="Types.this.Type">tp0</a>.<a href="#105337" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="458375">tp1</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#458374" title="scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <a href="#167378" title="=&gt; Types.this.Symbol =&gt; Boolean">fromContains</a><span class="delimiter">)</span> <a href="#167382" title="(tp: Types.this.Type)Types.this.Type">renameBoundSyms</a><span class="delimiter">(</span><a href="#167426" title="Types.this.Type">tp0</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#167426" title="Types.this.Type">tp0</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="458376">tp</a> = <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#458375" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
      
      <a href="#458376" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="comment">// @M </span>
        <span class="comment">// 1) arguments must also be substituted (even when the &quot;head&quot; of the </span>
        <span class="comment">// applied type has already been substituted)</span>
        <span class="comment">// example: (subst RBound[RT] from [type RT,type RBound] to </span>
        <span class="comment">// [type RT&amp;,type RBound&amp;]) = RBound&amp;[RT&amp;]</span>
        <span class="comment">// 2) avoid loops (which occur because alpha-conversion is </span>
        <span class="comment">// not performed properly imo)</span>
        <span class="comment">// e.g. if in class Iterable[a] there is a new Iterable[(a,b)], </span>
        <span class="comment">// we must replace the a in Iterable[a] by (a,b)</span>
        <span class="comment">// (must not recurse --&gt; loops)</span>
        <span class="comment">// 3) replacing m by List in m[Int] should yield List[Int], not just List</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="458391">sym</a>, <a title="List[Types.this.Type]" id="458392">args</a><span class="delimiter">)</span> =&gt;
          <a href="#67478" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#458373" title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#458376" title="Types.this.Type">tp</a>, <a href="#458391" title="Types.this.Symbol">sym</a>, <a href="#167387" title="List[Types.this.Symbol]">from</a>, <a href="#167388" title="List[T]">to</a><span class="delimiter">)</span>, <a href="#458392" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="comment">// if args.isEmpty, appliedType is the identity</span>
        <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="458393">sym</a><span class="delimiter">)</span> =&gt;
          <a href="#458373" title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#458376" title="Types.this.Type">tp</a>, <a href="#458393" title="Types.this.Symbol">sym</a>, <a href="#167387" title="List[Types.this.Symbol]">from</a>, <a href="#167388" title="List[T]">to</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#458376" title="Types.this.Type">tp</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `substSym' method. */</span>
  <span class="keyword">class</span> <a title="class SubstSymMap extends Types.this.SubstMap[Types.this.Symbol] with ScalaObject" id="67523">SubstSymMap</a><a href="#67523" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="167515">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="167516">to</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67521" title="Types.this.SubstMap[Types.this.Symbol]">SubstMap</a><span class="delimiter">(</span><a href="#167515" title="List[Types.this.Symbol]">from</a>, <a href="#167516" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(fromtp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="167512">toType</a><span class="delimiter">(</span><a title="Types.this.Type" id="458415">fromtp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="458416">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#458415" title="Types.this.Type">fromtp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="458421">pre</a>, _, <a title="List[Types.this.Type]" id="458422">args</a><span class="delimiter">)</span> =&gt; <a href="#67473" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#458415" title="Types.this.Type">fromtp</a>, <a href="#458421" title="Types.this.Type">pre</a>, <a href="#458416" title="Types.this.Symbol">sym</a>, <a href="#458422" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="458423">pre</a>, _<span class="delimiter">)</span> =&gt; <a href="#67468" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#458423" title="Types.this.Type">pre</a>, <a href="#458416" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="167513">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="167526">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#167515" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#167526" title="Types.this.Type">tp</a> <span class="keyword">else</span> <span class="delimiter">{</span>
      @tailrec <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol" id="458424">subst</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="458425">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="458426">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="458427">to</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> =
        <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#458426" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#458425" title="Types.this.Symbol">sym</a>
        <span class="comment">// else if (to.isEmpty) error(&quot;Unexpected substitution on '%s': from = %s but to == Nil&quot;.format(sym, from))</span>
        <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#167380" title="(sym: Types.this.Symbol, sym1: Types.this.Symbol)Boolean">matches</a><span class="delimiter">(</span><a href="#458426" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Types.this.Symbol">head</span>, <a href="#458425" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#458427" title="List[Types.this.Symbol]">to</a>.<span title="=&gt; Types.this.Symbol">head</span>
        <span class="keyword">else</span> <a href="#458424" title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol">subst</a><span class="delimiter">(</span><a href="#458425" title="Types.this.Symbol">sym</a>, <a href="#458426" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>, <a href="#458427" title="List[Types.this.Symbol]">to</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span><span class="delimiter">)</span>
      <a href="#167526" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="458428">pre</a>, <a title="Types.this.Symbol" id="458429">sym</a>, <a title="List[Types.this.Type]" id="458430">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#458428" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="458431">newSym</a> = <a href="#458424" title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol">subst</a><span class="delimiter">(</span><a href="#458429" title="Types.this.Symbol">sym</a>, <a href="#167515" title="List[Types.this.Symbol]">from</a>, <a href="#167516" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span>
          <span class="comment">// assert(newSym.typeParams.length == sym.typeParams.length, &quot;typars mismatch in SubstSymMap: &quot;+(sym, sym.typeParams, newSym, newSym.typeParams))</span>
          <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#67473" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#167526" title="Types.this.Type">tp</a>, <a href="#458428" title="Types.this.Type">pre</a>, <a href="#458431" title="Types.this.Symbol">newSym</a>, <a href="#458430" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// mapOver takes care of subst'ing in args</span>
        <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="458444">pre</a>, <a title="Types.this.Symbol" id="458445">sym</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#458444" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a> =&gt;
          <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#67468" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#458444" title="Types.this.Type">pre</a>, <a href="#458424" title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol">subst</a><span class="delimiter">(</span><a href="#458445" title="Types.this.Symbol">sym</a>, <a href="#167515" title="List[Types.this.Symbol]">from</a>, <a href="#167516" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#67523" title="Types.this.SubstSymMap" class="keyword">super</a>.<a href="#167383" title="(tp0: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#167526" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>


    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="167514">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="458432">tree</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="458433">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="object trans" id="458456">trans</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#133289" title="SubstSymMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>

        <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Option[Types.this.Symbol]" id="458459">termMapsTo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="458462">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
          <span title="Option[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#167378" title="(v1: Types.this.Symbol)Boolean">fromContains</a><span class="delimiter">(</span><a href="#458462" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</span><span class="delimiter">(</span><a href="#167516" title="(n: Int)Types.this.Symbol">to</a><span class="delimiter">(</span><a href="#167515" title="List[Types.this.Symbol]">from</a>.<span title="(elem: Types.this.Symbol)Int">indexOf</span><span class="delimiter">(</span><a href="#458462" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">else</span>
            <span title="object None">None</span>

        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="458460">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="458502">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = 
          <a href="#458502" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a title="Types.this.Tree" id="458507">tree</a>@Ident<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
              <a href="#458459" title="(sym: Types.this.Symbol)Option[Types.this.Symbol]">termMapsTo</a><span class="delimiter">(</span><a href="#458507" title="Types.this.Ident">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Types.this.Tree">Some</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="458512">tosym</a><span class="delimiter">)</span> =&gt;
                  <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#458512" title="Types.this.Symbol">tosym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#107448" title="(that: Types.this.Symbol)Boolean">isSubClass</a> <a href="Definitions.scala.html#106203" title="=&gt; Types.this.Symbol">SingletonClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#24048" title="(name: Types.this.Name)Types.this.Ident">Ident</a><span class="delimiter">(</span><a href="#458512" title="Types.this.Symbol">tosym</a>.<a href="#24048" title="implicit scala.reflect.generic.StdNames.stringToTermName : (s: String)Types.this.TermName">existentialToString</a><span class="delimiter">)</span>
                      .<span title="(sym: Types.this.Symbol)Types.this.Ident">setSymbol</span><span class="delimiter">(</span><a href="#458512" title="Types.this.Symbol">tosym</a><span class="delimiter">)</span>
                      .<span title="(pos: scala.tools.nsc.util.Position)Types.this.Ident">setPos</span><span class="delimiter">(</span><a href="#458512" title="Types.this.Symbol">tosym</a>.<a href="Symbols.scala.html#107263" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>
                      .<span title="(tp: Types.this.Type)Types.this.Ident">setType</span><span class="delimiter">(</span><a href="#447209" title="(tp: Types.this.Type)Types.this.Type">dropSingletonType</a><span class="delimiter">(</span><a href="#458512" title="Types.this.Symbol">tosym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                    <a href="#458433" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span>
                  <span class="delimiter">}</span>
                <span class="keyword">case</span> <a title="Types.this.Tree" id="458541">none</a> =&gt; <span class="keyword">super</span>.<a href="#457576" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#458507" title="Types.this.Ident">tree</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="keyword">case</span> <a title="Types.this.Tree" id="458544">tree</a> =&gt; <span class="keyword">super</span>.<a href="#457576" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#458544" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#458456" title="object trans">trans</a>.<a href="#458460" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#458432" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `subst' method. */</span>
  <span class="keyword">class</span> <a title="class SubstTypeMap extends Types.this.SubstMap[Types.this.Type] with ScalaObject" id="67524">SubstTypeMap</a><a href="#67524" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="167409">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="167410">to</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="#67521" title="Types.this.SubstMap[Types.this.Type]">SubstMap</a><span class="delimiter">(</span><a href="#167409" title="List[Types.this.Symbol]">from</a>, <a href="#167410" title="List[Types.this.Type]">to</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(fromtp: Types.this.Type, tp: Types.this.Type)Types.this.Type" id="167407">toType</a><span class="delimiter">(</span><a title="Types.this.Type" id="458568">fromtp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="458569">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#458569" title="Types.this.Type">tp</a> 

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="167408">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="454391">tree</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="454392">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="object trans" id="458574">trans</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#133289" title="SubstTypeMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="458577">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="458579">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = 
          <a href="#458579" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Types.this.Tree">Ident</span><span class="delimiter">(</span><a title="Types.this.Name" id="458586">name</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#167378" title="(v1: Types.this.Symbol)Boolean">fromContains</a><span class="delimiter">(</span><a href="#458579" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span> =&gt;
              <span class="keyword">val</span> <a title="Types.this.Type" id="458588">totpe</a> = <a href="#167410" title="(n: Int)Types.this.Type">to</a><span class="delimiter">(</span><a href="#167409" title="List[Types.this.Symbol]">from</a>.<span title="(elem: Types.this.Symbol)Int">indexOf</span><span class="delimiter">(</span><a href="#458579" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#458588" title="Types.this.Type">totpe</a>.<a href="#105305" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#454392" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <a href="#24048" title="(name: Types.this.Name)Types.this.Ident">Ident</a><span class="delimiter">(</span><a href="#458586" title="Types.this.Name">name</a><span class="delimiter">)</span>.<span title="(pos: scala.tools.nsc.util.Position)Types.this.Ident">setPos</span><span class="delimiter">(</span><a href="#458579" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Position">pos</span><span class="delimiter">)</span>.<span title="(sym: Types.this.Symbol)Types.this.Ident">setSymbol</span><span class="delimiter">(</span><a href="#458579" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span>.<span title="(tp: Types.this.Type)Types.this.Ident">setType</span><span class="delimiter">(</span><a href="#458588" title="Types.this.Type">totpe</a><span class="delimiter">)</span>

            <span class="keyword">case</span> <span title="Types.this.Tree">_</span> =&gt; <span class="keyword">super</span>.<a href="#457576" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#458579" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#458574" title="object trans">trans</a>.<a href="#458577" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#454391" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `substThis' method. */</span>
  <span class="keyword">class</span> <a title="class SubstThisMap extends Types.this.TypeMap with ScalaObject" id="67525">SubstThisMap</a><a href="#67525" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="449875">from</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="449876">to</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="449874">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="449878">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#449878" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="458630">sym</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#458630" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#449875" title="Types.this.Symbol">from</a><span class="delimiter">)</span> =&gt; <a href="#449876" title="Types.this.Type">to</a>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#449878" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class SubstSuperMap extends Types.this.TypeMap with ScalaObject" id="67526">SubstSuperMap</a><a href="#67526" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="449891">from</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="449892">to</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="449890">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="449894">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#449894" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#449891" title="Types.this.Type">from</a><span class="delimiter">)</span> <a href="#449892" title="Types.this.Type">to</a> <span class="keyword">else</span> <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#449894" title="Types.this.Type">tp</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class SubstWildcardMap extends Types.this.TypeMap with ScalaObject" id="67527">SubstWildcardMap</a><a href="#67527" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="458660">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span> 
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="458657">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="458661">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
      <a href="#458661" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.BoundedWildcardType">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="458664">sym</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#458660" title="List[Types.this.Symbol]">from</a> <span title="(elem: Any)Boolean">contains</span> <a href="#458664" title="Types.this.Symbol">sym</a> =&gt;
          <a href="#258421" title="(bounds: Types.this.TypeBounds)Types.this.BoundedWildcardType">BoundedWildcardType</a><span class="delimiter">(</span><a href="#458664" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; 
          <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#458661" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Types.this.WildcardType.type" id="458674">ex</a>: <a href="#67660" title="Types.this.MalformedType">MalformedType</a> =&gt;
        <a href="#450801" title="object Types.this.WildcardType">WildcardType</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="comment">// dependent method types</span>
  <span class="keyword">object</span> <a title="object Types.this.IsDependentCollector" id="67528">IsDependentCollector</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67507" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449601">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="458684">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#458684" title="Types.this.Type">tp</a> <a href="#105309" title="=&gt; Boolean">isImmediatelyDependent</a><span class="delimiter">)</span> <a href="#449234" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#449234" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#458684" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.ApproximateDependentMap" id="67530">ApproximateDependentMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="449701">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="449702">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = 
      <span title="Types.this.Type" class="keyword">if</span><span class="delimiter">(</span><a href="#449702" title="Types.this.Type">tp</a> <a href="#105309" title="=&gt; Boolean">isImmediatelyDependent</a><span class="delimiter">)</span> <a href="#450801" title="object Types.this.WildcardType">WildcardType</a>
      <span class="keyword">else</span> <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#449702" title="Types.this.Type">tp</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class InstantiateDependentMap extends Types.this.TypeMap with ScalaObject" id="67532">InstantiateDependentMap</a><a href="#67532" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="262066">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="262067">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.IndexedSeq[Types.this.Type]" id="262053">actualsIndexed</a> = <a href="#262067" title="List[Types.this.Type]">actuals</a>.<span title="scala.collection.immutable.IndexedSeq[Types.this.Type]">toIndexedSeq</span>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="262055">dropNonConstraintAnnotations</a> = <span title="Boolean(true)" class="keyword">true</span>

    <span class="keyword">object</span> <a title="object InstantiateDependentMap.this.ParamWithActual" id="262057">ParamWithActual</a> <span title="ScalaObject" class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Option[Types.this.Type]" id="458715">unapply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="458717">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Option[Types.this.Type]">Option</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Int" id="458719">pid</a> = <a href="#262066" title="List[Types.this.Symbol]">params</a> <span title="(elem: Types.this.Symbol)Int">indexOf</span> <a href="#458717" title="Types.this.Symbol">sym</a>
        <span title="Option[Types.this.Type]" class="keyword">if</span><span class="delimiter">(</span><a href="#458719" title="Int">pid</a> <span title="(x: Int)Boolean">!=</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#262053" title="(idx: Int)Types.this.Type">actualsIndexed</a><span class="delimiter">(</span><a href="#458719" title="Int">pid</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="object None">None</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="262059">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="262069">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
      <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#262069" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="#458715" title="(sym: Types.this.Symbol)Option[Types.this.Type]">ParamWithActual</a><span class="delimiter">(</span><a title="Types.this.Type" id="458772">arg</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#458772" title="Types.this.Type">arg</a>.<a href="#105305" title="=&gt; Boolean">isStable</a> =&gt; <a href="#458772" title="Types.this.Type">arg</a> <span class="comment">// unsound to replace args by unstable actual #3873</span>
        <span class="comment">// (soundly) expand type alias selections on implicit arguments, see depmet_implicit_oopsla* test cases -- typically, `param.isImplicit`</span>
        <span class="keyword">case</span> <a title="Types.this.Type" id="458773">tp1</a>@TypeRef<span class="delimiter">(</span>SingleType<span class="delimiter">(</span><a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="#458715" title="(sym: Types.this.Symbol)Option[Types.this.Type]">ParamWithActual</a><span class="delimiter">(</span><a title="Types.this.Type" id="458775">arg</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a title="Types.this.Symbol" id="458776">sym</a>, <a title="List[Types.this.Type]" id="458777">targs</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="458778">res</a> = <a href="#67472" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#458775" title="Types.this.Type">arg</a>, <a href="#458776" title="Types.this.Symbol">sym</a>, <a href="#458777" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span><span class="delimiter">(</span><a href="#458778" title="Types.this.Type">res</a>.<a href="#105315" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <a href="#458778" title="Types.this.Type">res</a>.<a href="#105343" title="=&gt; Types.this.Type">dealias</a>
          <span class="keyword">else</span> <a href="#458773" title="Types.this.TypeRef">tp1</a>
        <span class="keyword">case</span> <a title="Types.this.Type" id="458779">tp1</a> =&gt; <a href="#458779" title="Types.this.Type">tp1</a> <span class="comment">// don't return the original `tp`, which may be different from `tp1`, due to `dropNonConstraintAnnotations`</span>
      <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="262060">existentialsNeeded</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#262061" title="(xs: Array[Types.this.Symbol])scala.collection.mutable.ArrayOps[Types.this.Symbol]">existSyms</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Array[Types.this.Symbol]">filter</span><span title="(xs: Array[Types.this.Symbol])scala.collection.mutable.ArrayOps[Types.this.Symbol]" class="delimiter">(</span><a href="#458978" title="Types.this.Symbol">_</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>.<span title="=&gt; List[Types.this.Symbol]">toList</span>

    <span class="keyword">private</span> <span class="keyword">val</span> <a title="Array[Types.this.Symbol]" id="262061">existSyms</a>: <span title="Array[Types.this.Symbol]">Array</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span title="Array[Types.this.Symbol]" class="keyword">new</span> <span title="Array[Types.this.Symbol]">Array</span><span class="delimiter">(</span><a href="#262053" title="=&gt; scala.collection.immutable.IndexedSeq[Types.this.Type]">actualsIndexed</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(i: Int)Boolean" id="262063">haveExistential</a><span class="delimiter">(</span><a title="Int" id="459085">i</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span class="delimiter">{</span><span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#459085" title="Int">i</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#459085" title="Int">i</a> <span title="(x: Int)Boolean">&lt;=</span> <a href="#262053" title="=&gt; scala.collection.immutable.IndexedSeq[Types.this.Type]">actualsIndexed</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span><span class="delimiter">)</span>; <a href="#262061" title="(i: Int)Types.this.Symbol">existSyms</a><span class="delimiter">(</span><a href="#459085" title="Int">i</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">}</span>

    <span class="comment">/* Return the type symbol for referencing a parameter inside the existential quantifier. 
     * (Only needed if the actual is unstable.)
     */</span>
    <span class="keyword">def</span> <a title="(actualIdx: Int)Types.this.Symbol" id="262064">existSymFor</a><span class="delimiter">(</span><a title="Int" id="459098">actualIdx</a>: <span title="Int">Int</span><span class="delimiter">)</span> =
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#262063" title="(i: Int)Boolean">haveExistential</a><span class="delimiter">(</span><a href="#459098" title="Int">actualIdx</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#262061" title="(i: Int)Types.this.Symbol">existSyms</a><span class="delimiter">(</span><a href="#459098" title="Int">actualIdx</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="459101">oldSym</a> = <a href="#262066" title="(n: Int)Types.this.Symbol">params</a><span class="delimiter">(</span><a href="#459098" title="Int">actualIdx</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="459102">symowner</a> = <a href="#459101" title="Types.this.Symbol">oldSym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>
        <span class="keyword">val</span> <a title="Types.this.TypeBounds" id="459103">bound</a> = <a href="#67519" title="(hi: Types.this.Type)Types.this.TypeBounds">singletonBounds</a><span class="delimiter">(</span><a href="#262053" title="(idx: Int)Types.this.Type">actualsIndexed</a><span class="delimiter">(</span><a href="#459098" title="Int">actualIdx</a><span class="delimiter">)</span><span class="delimiter">)</span>

        <span class="keyword">val</span> <a title="Types.this.Symbol" id="459104">sym</a> = <a href="#459102" title="Types.this.Symbol">symowner</a>.<a href="Symbols.scala.html#107303" title="(pos: Types.this.Position, name: Types.this.TypeName)Types.this.Symbol">newExistential</a><span class="delimiter">(</span><a href="#459101" title="Types.this.Symbol">oldSym</a>.<a href="Symbols.scala.html#107263" title="=&gt; Types.this.Position">pos</a>, <a href="Names.scala.html#66906" title="(s: String)Types.this.TypeName">newTypeName</a><span class="delimiter">(</span><a href="#459101" title="Types.this.Symbol">oldSym</a>.<a href="Symbols.scala.html#107407" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">name</a> <span title="(other: String)java.lang.String">+</span> <span title="java.lang.String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#459104" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107425" title="(info: Types.this.Type)sym.type">setInfo</a><span class="delimiter">(</span><a href="#459103" title="Types.this.TypeBounds">bound</a><span class="delimiter">)</span>
        <a href="#459104" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107412" title="(mask: Long)sym.type">setFlag</a><span class="delimiter">(</span><a href="#459101" title="Types.this.Symbol">oldSym</a>.<a href="Symbols.scala.html#107410" title="=&gt; Long">flags</a><span class="delimiter">)</span>

        <a href="#262061" title="(i: Int, x: Types.this.Symbol)Unit">existSyms</a><span class="delimiter">(</span><a href="#459098" title="Int">actualIdx</a><span class="delimiter">)</span> = <a href="#459104" title="Types.this.Symbol">sym</a>
        <a href="#459104" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span>

    <span class="comment">//AM propagate more info to annotations -- this seems a bit ad-hoc... (based on code by spoon)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(arg: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="262065">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="458761">arg</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="458762">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="object treeTrans" id="459130">treeTrans</a> <span title="ScalaObject" class="keyword">extends</span> <a href="../ast/Trees.scala.html#67825" title="Types.this.Transformer">Transformer</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="459133">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="459137">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
          <a href="#459137" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a href="#459141" title="Types.this.Tree">RefParamAt</a><span class="delimiter">(</span><a title="Int" id="459145">pid</a><span class="delimiter">)</span> =&gt;
              <span class="comment">// TODO: this should be simplified; in the stable case, one can probably</span>
              <span class="comment">// just use an Ident to the tree.symbol. Why an existential in the non-stable case?</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="459146">actual</a> = <a href="#262053" title="(idx: Int)Types.this.Type">actualsIndexed</a><span class="delimiter">(</span><a href="#459145" title="Int">pid</a><span class="delimiter">)</span>
              <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#459146" title="Types.this.Type">actual</a>.<a href="#105305" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#459146" title="Types.this.Type">actual</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="../ast/TreeGen.scala.html#105424" title="(tpe: Types.this.gen.global.Type, termSym: Types.this.gen.global.Symbol)Types.this.gen.global.Tree">mkAttributedQualifier</a><span class="delimiter">(</span><a href="#262053" title="(idx: Int)Types.this.Type">actualsIndexed</a><span class="delimiter">(</span><a href="#459145" title="Int">pid</a><span class="delimiter">)</span>, <a href="#459137" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                <span class="keyword">val</span> <a title="Types.this.Symbol" id="459168">sym</a> = <a href="#262064" title="(actualIdx: Int)Types.this.Symbol">existSymFor</a><span class="delimiter">(</span><a href="#459145" title="Int">pid</a><span class="delimiter">)</span>
                <span class="delimiter">(</span><a href="#24048" title="(name: Types.this.Name)Types.this.Ident">Ident</a><span class="delimiter">(</span><a href="#459168" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
                 <span title="(tree: Types.this.Tree)Types.this.Ident">copyAttrs</span> <a href="#459137" title="Types.this.Tree">tree</a>
                 <span title="(tp: Types.this.Type)Types.this.Ident">setType</span> <a href="#67472" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="#459168" title="Types.this.Symbol">sym</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="keyword">case</span> <span title="Types.this.Tree">_</span> =&gt; <span class="keyword">super</span>.<a href="../ast/Trees.scala.html#162512" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#459137" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">object</span> <a title="object scala.tools.nsc.symtab.Types.InstantiateDependentMap.treeTrans.RefParamAt" id="459134">RefParamAt</a> <span title="ScalaObject" class="delimiter">{</span>
          <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Option[Int]" id="459141">unapply</a><span class="delimiter">(</span><a title="Types.this.Tree" id="459142">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Option[Int]">Option</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> = <a href="#459142" title="Types.this.Tree">tree</a> <span title="Option[Int]" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Option[Int]">Ident</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <span title="(x: Int)Some[Int]">Some</span><span class="delimiter">(</span><a href="#262066" title="List[Types.this.Symbol]">params</a> <span title="(elem: Types.this.Symbol)Int">indexOf</span> <a href="#459142" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span> <span title="(p: Int =&gt; Boolean)Option[Int]">filterNot</span> <span class="delimiter">(</span><a href="#459205" title="Int">_</a> <span title="(x: Int)Boolean">==</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="None.type">_</span>        =&gt; <span title="object None">None</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#459130" title="object treeTrans">treeTrans</a>.<a href="#459133" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#458761" title="Types.this.Tree">arg</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  <span class="keyword">object</span> <a title="object Types.this.StripAnnotationsMap" id="67533">StripAnnotationsMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="450610">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="450611">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#450611" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">AnnotatedType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="459212">atp</a>, _<span class="delimiter">)</span> =&gt;
        <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#459212" title="Types.this.Type">atp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="459221">tp</a> =&gt;
        <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#459221" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to convert every occurrence of a wildcard type to a fresh
   *  type variable */</span>
  <span class="keyword">object</span> <a title="object Types.this.wildcardToTypeVarMap" id="67535">wildcardToTypeVarMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="455257">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="455258">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#455258" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#450801" title="Types.this.TypeVar">WildcardType</a> =&gt;
        <a href="#448917" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint)Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#455258" title="Types.this.Type">tp</a>, <a href="#449307" title="()Types.this.TypeConstraint" class="keyword">new</a> <a href="#67502" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.TypeVar">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="459239">bounds</a><span class="delimiter">)</span> =&gt;
        <a href="#448917" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint)Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#455258" title="Types.this.Type">tp</a>, <a href="#449306" title="(lo0: List[Types.this.Type], hi0: List[Types.this.Type])Types.this.TypeConstraint" class="keyword">new</a> <a href="#67502" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">(</span><span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#459239" title="Types.this.TypeBounds">bounds</a>.<a href="#148467" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#459239" title="Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#455258" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to convert every occurrence of a type variable to a
      wildcard type */</span>
  <span class="keyword">object</span> <a title="object Types.this.typeVarToOriginMap" id="67537">typeVarToOriginMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="450288">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="450289">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#450289" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#448916" title="Types.this.Type">TypeVar</a><span class="delimiter">(</span><a title="Types.this.Type" id="459272">origin</a>, _<span class="delimiter">)</span> =&gt; <a href="#459272" title="Types.this.Type">origin</a>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#450289" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `contains' method */</span>
  <span class="keyword">class</span> <a title="class ContainsCollector extends Types.this.TypeCollector[Boolean] with ScalaObject" id="67539">ContainsCollector</a><a href="#67539" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="449970">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67507" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449968">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="459287">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#449234" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#459287" title="Types.this.Type">tp</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="459289">sym1</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#449970" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#459289" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> =&gt; <a href="#449234" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span title="Unit">SingleType</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="459295">sym1</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#449970" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#459295" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> =&gt; <a href="#449234" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt; <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#459287" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(arg: Types.this.Tree)Some[Types.this.Tree]" id="449969">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="459300">arg</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Tree" id="459391">t</a> &lt;- <a href="../ast/Trees.scala.html#109034" title="(f: Types.this.Tree =&gt; Unit)Unit">arg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#449968" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#459391" title="Types.this.Tree">t</a>.<span title="=&gt; Types.this.Type">tpe</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#459391" title="Types.this.Tree">t</a>.<span title="=&gt; Types.this.Symbol">symbol</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#449970" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <a href="#449234" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="delimiter">}</span>
      <span title="(x: Types.this.Tree)Some[Types.this.Tree]">Some</span><span class="delimiter">(</span><a href="#459300" title="Types.this.Tree">arg</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/** A map to implement the `contains' method */</span>
  <span class="keyword">class</span> <a title="class ContainsTypeCollector extends Types.this.TypeCollector[Boolean] with ScalaObject" id="67540">ContainsTypeCollector</a><a href="#67540" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="449981">t</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67507" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449979">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="459412">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#449234" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#459412" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#449981" title="Types.this.Type">t</a><span class="delimiter">)</span> <a href="#449234" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
        <span class="keyword">else</span> <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#459412" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(arg: Types.this.Tree)Some[Types.this.Tree]" id="449980">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="459415">arg</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Tree" id="459505">t</a> &lt;- <a href="../ast/Trees.scala.html#109034" title="(f: Types.this.Tree =&gt; Unit)Unit">arg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#449979" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#459505" title="Types.this.Tree">t</a>.<span title="=&gt; Types.this.Type">tpe</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span title="(x: Types.this.Tree)Some[Types.this.Tree]">Some</span><span class="delimiter">(</span><a href="#459415" title="Types.this.Tree">arg</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `filter' method */</span>
  <span class="keyword">class</span> <a title="class FilterTypeCollector extends Types.this.TypeCollector[scala.collection.mutable.ListBuffer[Types.this.Type]] with ScalaObject" id="67541">FilterTypeCollector</a><a href="#67541" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type =&gt; Boolean" id="449911">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67507" title="Types.this.TypeCollector[scala.collection.mutable.ListBuffer[Types.this.Type]]">TypeCollector</a><span class="delimiter">(</span><span title="scala.collection.mutable.ListBuffer[Types.this.Type]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[Types.this.Type]">ListBuffer</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449910">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="459521">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#449911" title="(v1: Types.this.Type)Boolean">p</a><span class="delimiter">(</span><a href="#459521" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#449234" title="=&gt; scala.collection.mutable.ListBuffer[Types.this.Type]">result</a> <span title="(x: Types.this.Type)scala.collection.mutable.ListBuffer[Types.this.Type]">+=</span> <a href="#459521" title="Types.this.Type">tp</a>
      <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#459521" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class ForEachTypeTraverser extends Types.this.TypeTraverser with ScalaObject" id="67542">ForEachTypeTraverser</a><a href="#67542" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type =&gt; Unit" id="449930">f</a>: Type =&gt; Unit<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67506" title="Types.this.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449929">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="449932">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#449930" title="(v1: Types.this.Type)Unit">f</a><span class="delimiter">(</span><a href="#449932" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#449932" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `filter' method */</span>
  <span class="keyword">class</span> <a title="class FindTypeCollector extends Types.this.TypeCollector[Option[Types.this.Type]] with ScalaObject" id="67543">FindTypeCollector</a><a href="#67543" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type =&gt; Boolean" id="449923">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67507" title="Types.this.TypeCollector[Option[Types.this.Type]]">TypeCollector</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="object None">None</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449922">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="459572">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#449234" title="=&gt; Option[Types.this.Type]">result</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#449923" title="(v1: Types.this.Type)Boolean">p</a><span class="delimiter">(</span><a href="#459572" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#449234" title="(x$1: Option[Types.this.Type])Unit">result</a> = <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#459572" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#459572" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `contains' method */</span>
  <span class="keyword">object</span> <a title="object Types.this.ErroneousCollector" id="67544">ErroneousCollector</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67507" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449782">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="459590">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#449234" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#449234" title="(x$1: Boolean)Unit">result</a> = <a href="#459590" title="Types.this.Type">tp</a>.<a href="#105344" title="=&gt; Boolean">isError</a>
        <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#459590" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to compute the most deeply nested owner that contains all the symbols
   *  of thistype or prefixless typerefs/singletype occurrences in given type.
   */</span>
  <span class="keyword">object</span> <a title="object Types.this.commonOwnerMap" id="67546">commonOwnerMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="Types.this.Symbol" id="459601">result</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = _
    <span class="keyword">def</span> <a title="()Unit" id="459603">init</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span class="delimiter">{</span> <a href="#459601" title="(x$1: Types.this.Symbol)Unit">result</a> = <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a> <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="459604">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="459610">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#459610" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
      <a href="#459610" title="Types.this.Type">tp</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a> <span title="Any" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Unit">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="459615">sym</a><span class="delimiter">)</span> =&gt;
          <a href="#459605" title="(sym: Types.this.Symbol)Unit">register</a><span class="delimiter">(</span><a href="#459615" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span><a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="459618">sym</a>, <a title="List[Types.this.Type]" id="459619">args</a><span class="delimiter">)</span> =&gt;
          <a href="#459605" title="(sym: Types.this.Symbol)Unit">register</a><span class="delimiter">(</span><a href="#459618" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>; <a href="#459619" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)Unit">foreach</span> <a href="#459604" title="(tp: Types.this.Type)Types.this.Type">apply</a>
        <span class="keyword">case</span> <span title="Unit">SingleType</span><span class="delimiter">(</span><a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="459641">sym</a><span class="delimiter">)</span> =&gt;
          <a href="#459605" title="(sym: Types.this.Symbol)Unit">register</a><span class="delimiter">(</span><a href="#459641" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#459610" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#459610" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="459605">register</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="459616">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#459601" title="=&gt; Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#459616" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#459601" title="=&gt; Types.this.Symbol">result</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#459616" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#107446" title="(that: Types.this.Symbol)Boolean">isNestedIn</a> <a href="#459601" title="=&gt; Types.this.Symbol">result</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#459601" title="(x$1: Types.this.Symbol)Unit">result</a> = <a href="#459601" title="=&gt; Types.this.Symbol">result</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>;
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class MissingAliasControl extends java.lang.Throwable with scala.util.control.ControlThrowable with ScalaObject" id="67548">MissingAliasControl</a> <a href="#67548" title="ScalaObject" class="keyword">extends</a> <span title="scala.util.control.ControlThrowable">ControlThrowable</span>
  <span class="keyword">val</span> <a title="Types.this.MissingAliasControl" id="67549">missingAliasException</a> = <span title="Types.this.MissingAliasControl" class="keyword">new</span> <a href="#67548" title="Types.this.MissingAliasControl">MissingAliasControl</a>
  <span class="keyword">class</span> <a title="class MissingTypeControl extends java.lang.Throwable with scala.util.control.ControlThrowable with ScalaObject" id="67551">MissingTypeControl</a> <a href="#67551" title="ScalaObject" class="keyword">extends</a> <span title="scala.util.control.ControlThrowable">ControlThrowable</span>

  <span class="keyword">object</span> <a title="object Types.this.adaptToNewRunMap" id="67552">adaptToNewRunMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#67503" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol" id="313861">adaptToNewRun</a><span class="delimiter">(</span><a title="Types.this.Type" id="459677">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="459678">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102842" title="=&gt; Boolean">flatClasses</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#459678" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#459678" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isModuleClass</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#313861" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#459677" title="Types.this.Type">pre</a>, <a href="#459678" title="Types.this.Symbol">sym</a>.<span title="=&gt; Types.this.Symbol">sourceModule</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#107486" title="=&gt; Types.this.Symbol">moduleClass</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#459677" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#459677" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#459678" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#459678" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">var</span> <a title="Types.this.Symbol" id="459681">rebind0</a> = <a href="#459677" title="Types.this.Type">pre</a>.<a href="#105397" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#459678" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a>, <span title="Long(67108864L)">BRIDGE</span>, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#459681" title="Types.this.Symbol">rebind0</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#459678" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isAliasType</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <a href="#67549" title="=&gt; Types.this.MissingAliasControl">missingAliasException</a>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#459677" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">pre</a><span title="(other: String)java.lang.String">+</span><span title="java.lang.String(&quot;.&quot;)" class="string">&quot;.&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459678" title="Types.this.Symbol">sym</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; does no longer exist, phase = &quot;)" class="string">&quot; does no longer exist, phase = &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <span title="Types.this.MissingTypeControl" class="keyword">new</span> <a href="#67551" title="Types.this.MissingTypeControl">MissingTypeControl</a> <span class="comment">// For build manager and presentation compiler purposes</span>
          <span class="comment">//assert(false, pre+&quot;.&quot;+sym+&quot; does no longer exist, phase = &quot;+phase)</span>
        <span class="delimiter">}</span>
        <span class="comment">/** The two symbols have the same fully qualified name */</span>
        <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean" id="459682">corresponds</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="459696">sym1</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="459697">sym2</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
          <a href="#459696" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#459697" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#459696" title="Types.this.Symbol">sym1</a>.<span title="=&gt; Boolean">isPackageClass</span> <span title="(x: Boolean)Boolean">||</span> <a href="#459682" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#459696" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>, <a href="#459697" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#459682" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#459678" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>, <a href="#459681" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span>
            <a href="SymbolTable.scala.html#64778" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;ADAPT1 pre = &quot;)" class="string">&quot;ADAPT1 pre = &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459677" title="Types.this.Type">pre</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;, sym = &quot;)" class="string">&quot;, sym = &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459678" title="Types.this.Symbol">sym</a><span title="(x$1: Any)java.lang.String">+</span><a href="#459678" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107518" title="=&gt; java.lang.String">locationString</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;, rebind = &quot;)" class="string">&quot;, rebind = &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459681" title="Types.this.Symbol">rebind0</a><span title="(x$1: Any)java.lang.String">+</span><a href="#459681" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#107518" title="=&gt; java.lang.String">locationString</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="459704">bcs</a> = <a href="#459677" title="Types.this.Type">pre</a>.<a href="#105385" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">dropWhile</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="459714">bc</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#459682" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#459714" title="Types.this.Symbol">bc</a>, <a href="#459678" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>;
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#459704" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
            <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#459677" title="Types.this.Type">pre</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isRefinementClass</span>, <a href="#459677" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span class="comment">// if pre is a refinementclass it might be a structural type =&gt; OK to leave it in.</span>
          <span class="keyword">else</span> 
            <a href="#459681" title="Types.this.Symbol">rebind0</a> = <a href="#459677" title="Types.this.Type">pre</a>.<a href="#105358" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#459704" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Types.this.Symbol">head</span><span class="delimiter">)</span>.<a href="#105354" title="(name: Types.this.Name)Types.this.Symbol">member</a><span class="delimiter">(</span><a href="#459678" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="SymbolTable.scala.html#64778" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span>
            <span title="java.lang.String(&quot;ADAPT2 pre = &quot;)" class="string">&quot;ADAPT2 pre = &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#459677" title="Types.this.Type">pre</a> <span title="(x$1: Any)java.lang.String">+</span>
            <span title="java.lang.String(&quot;, bcs.head = &quot;)" class="string">&quot;, bcs.head = &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#459704" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Types.this.Symbol">head</span> <span title="(x$1: Any)java.lang.String">+</span>
            <span title="java.lang.String(&quot;, sym = &quot;)" class="string">&quot;, sym = &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#459678" title="Types.this.Symbol">sym</a><span title="(x$1: Any)java.lang.String">+</span><a href="#459678" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107518" title="=&gt; java.lang.String">locationString</a> <span title="(x$1: Any)java.lang.String">+</span>
            <span title="java.lang.String(&quot;, rebind = &quot;)" class="string">&quot;, rebind = &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#459681" title="Types.this.Symbol">rebind0</a> <span title="(x$1: Any)java.lang.String">+</span> <span class="delimiter">(</span>
              <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#459681" title="Types.this.Symbol">rebind0</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
              <span class="keyword">else</span> <a href="#459681" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#107518" title="=&gt; java.lang.String">locationString</a>
            <span class="delimiter">)</span>
          <span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="459683">rebind</a> = <a href="#459681" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#107452" title="(cond: Types.this.Symbol =&gt; Boolean)Types.this.Symbol">suchThat</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="459726">sym</a> =&gt; <a href="#459726" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isType</span> <span title="(x: Boolean)Boolean">||</span> <a href="#459726" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107373" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#459683" title="Types.this.Symbol">rebind</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="SymbolTable.scala.html#64778" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102842" title="=&gt; Boolean">flatClasses</a><span title="(x$1: Any)java.lang.String">+</span><a href="#459678" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a><span title="(x$1: Any)java.lang.String">+</span><a href="#459678" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459678" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isType</span><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <a href="#458678" title="(pre: Types.this.Type, tp: String)Types.this.MalformedType" class="keyword">new</a> <a href="#67660" title="Types.this.MalformedType">MalformedType</a><span class="delimiter">(</span><a href="#459677" title="Types.this.Type">pre</a>, <a href="#459678" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107514" title="=&gt; java.lang.String">nameString</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#459683" title="Types.this.Symbol">rebind</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="313862">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="313863">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#313863" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="459739">sym</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">try</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="459740">sym1</a> = <a href="#313861" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#459739" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#107459" title="=&gt; Types.this.Type">thisType</a>, <a href="#459739" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459740" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#459739" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#313863" title="Types.this.Type">tp</a> <span class="keyword">else</span> <a href="#148190" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="#459740" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        	<span class="keyword">case</span> <a title="Types.this.Type" id="459745">ex</a>: <a href="#67551" title="Types.this.MissingTypeControl">MissingTypeControl</a> =&gt;
            <a href="#313863" title="Types.this.Type">tp</a> 
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="459746">pre</a>, <a title="Types.this.Symbol" id="459747">sym</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459747" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackage</span><span class="delimiter">)</span> <a href="#313863" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="459748">pre1</a> = <a href="#313862" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#459746" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="459749">sym1</a> = <a href="#313861" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#459748" title="Types.this.Type">pre1</a>, <a href="#459747" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#459748" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459746" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#459749" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459747" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#313863" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#67468" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#459748" title="Types.this.Type">pre1</a>, <a href="#459749" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="459751">pre</a>, <a title="Types.this.Symbol" id="459752">sym</a>, <a title="List[Types.this.Type]" id="459753">args</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459752" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isPackageClass</span><span class="delimiter">)</span> <a href="#313863" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="459754">pre1</a> = <a href="#313862" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#459751" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="459755">args1</a> = <a href="#459753" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>
          <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="459762">sym1</a> = <a href="#313861" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#459754" title="Types.this.Type">pre1</a>, <a href="#459752" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#459754" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459751" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#459762" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459752" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#459755" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459753" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="comment">/* &amp;&amp; sym.isExternal*/</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#313863" title="Types.this.Type">tp</a>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459762" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="java.lang.String(&quot;adapt fail: &quot;)" class="string">&quot;adapt fail: &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459751" title="Types.this.Type">pre</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459754" title="Types.this.Type">pre1</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459752" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
              <a href="#313863" title="Types.this.Type">tp</a>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <a href="#67473" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#313863" title="Types.this.Type">tp</a>, <a href="#459754" title="Types.this.Type">pre1</a>, <a href="#459762" title="Types.this.Symbol">sym1</a>, <a href="#459755" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a title="Types.this.Type" id="459772">ex</a>: <a href="#67548" title="Types.this.MissingAliasControl">MissingAliasControl</a> =&gt;
              <a href="#313862" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#313863" title="Types.this.Type">tp</a>.<a href="#105343" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="Types.this.Type">_</span>: <a href="#67551" title="Types.this.MissingTypeControl">MissingTypeControl</a> =&gt;
              <a href="#313863" title="Types.this.Type">tp</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="459774">params</a>, <a title="Types.this.Type" id="459775">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="459776">restp1</a> = <a href="#313862" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#459775" title="Types.this.Type">restp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459776" title="Types.this.Type">restp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459775" title="Types.this.Type">restp</a><span class="delimiter">)</span> <a href="#313863" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#67475" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#313863" title="Types.this.Type">tp</a>, <a href="#459774" title="List[Types.this.Symbol]">params</a>, <a href="#459776" title="Types.this.Type">restp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="459778">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="459779">restp1</a> = <a href="#313862" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#459778" title="Types.this.Type">restp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459779" title="Types.this.Type">restp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459778" title="Types.this.Type">restp</a><span class="delimiter">)</span> <a href="#313863" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#148801" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#459779" title="Types.this.Type">restp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="459780">tparams</a>, <a title="Types.this.Type" id="459781">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="459782">restp1</a> = <a href="#313862" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#459781" title="Types.this.Type">restp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459782" title="Types.this.Type">restp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459781" title="Types.this.Type">restp</a><span class="delimiter">)</span> <a href="#313863" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#148857" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#459780" title="List[Types.this.Symbol]">tparams</a>, <a href="#459782" title="Types.this.Type">restp1</a><span class="delimiter">)</span>

      <span class="comment">// Lukas: we need to check (together) whether we should also include parameter types</span>
      <span class="comment">// of PolyType and MethodType in adaptToNewRun</span>
      
      <span class="keyword">case</span> <span title="Types.this.Type">ClassInfoType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="459783">parents</a>, <a title="Types.this.Scope" id="459784">decls</a>, <a title="Types.this.Symbol" id="459785">clazz</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459785" title="Types.this.Symbol">clazz</a>.<span title="=&gt; Boolean">isPackageClass</span><span class="delimiter">)</span> <a href="#313863" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="459786">parents1</a> = <a href="#459783" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459786" title="List[Types.this.Type]">parents1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459783" title="List[Types.this.Type]">parents</a><span class="delimiter">)</span> <a href="#313863" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#148601" title="(parents: List[Types.this.Type], decls: Types.this.Scope, typeSymbol: Types.this.Symbol)Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">(</span><a href="#459786" title="List[Types.this.Type]">parents1</a>, <a href="#459784" title="Types.this.Scope">decls</a>, <a href="#459785" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="459796">parents</a>, <a title="Types.this.Scope" id="459797">decls</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="459798">parents1</a> = <a href="#459796" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#459798" title="List[Types.this.Type]">parents1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#459796" title="List[Types.this.Type]">parents</a><span class="delimiter">)</span> <a href="#313863" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#67469" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#459798" title="List[Types.this.Type]">parents1</a>, <a href="#313863" title="Types.this.Type">tp</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>, <a href="#459797" title="Types.this.Scope">decls</a>, <a href="#313863" title="Types.this.Type">tp</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#107263" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SuperType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#313863" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeBounds</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#313863" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="#448916" title="Types.this.Type">TypeVar</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#313863" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">AnnotatedType</span><span class="delimiter">(</span>_,_,_<span class="delimiter">)</span> =&gt; <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#313863" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">NotNullType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#313863" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#313863" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#313863" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class SubTypePair extends java.lang.Object with ScalaObject" id="67554">SubTypePair</a><a href="#67554" title="ScalaObject" class="delimiter">(</a><span class="keyword">val</span> <a title="Types.this.Type" id="459873">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <span class="keyword">val</span> <a title="Types.this.Type" id="459874">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()Int" id="459867">hashCode</a> = <a href="#459873" title="=&gt; Types.this.Type">tp1</a>.<span title="()Int">hashCode</span> <span title="(x: Int)Int">*</span> <span title="Int(41)" class="int">41</span> <span title="(x: Int)Int">+</span> <a href="#459874" title="=&gt; Types.this.Type">tp2</a>.<span title="()Int">hashCode</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(other: Any)Boolean" id="459868">equals</a><span class="delimiter">(</span><a title="Any" id="459886">other</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <a href="#459886" title="Any">other</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="459889">stp</a>: <a href="#67554" title="Types.this.SubTypePair">SubTypePair</a> =&gt; 
        <span class="delimiter">(</span><a href="#459873" title="=&gt; Types.this.Type">tp1</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#459889" title="Types.this.SubTypePair">stp</a>.<a href="#459873" title="=&gt; Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#459874" title="=&gt; Types.this.Type">tp2</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#459889" title="Types.this.SubTypePair">stp</a>.<a href="#459874" title="=&gt; Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
        <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="459869">toString</a> = <a href="#459873" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">tp1</a><span title="(other: String)java.lang.String">+</span><span title="java.lang.String(&quot; &lt;:&lt;? &quot;)" class="string">&quot; &lt;:&lt;? &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#459874" title="=&gt; Types.this.Type">tp2</a>
  <span class="delimiter">}</span>

<span class="comment">// Helper Methods  -------------------------------------------------------------</span>

  <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(0)" id="67555">LubGlbMargin</a> = <span title="Int(0)" class="int">0</span>

  <span class="comment">/** The maximum allowable depth of lubs or glbs over types `ts'
    * This is the maximum depth of all types in the base type sequences 
    * of each of the types `ts', plus LubGlbMargin
    */</span>
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Int" id="67557">lubDepth</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="419303">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="Int" id="419306">d</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="419326">tp</a> &lt;- <a href="#419303" title="(f: Types.this.Type =&gt; Unit)Unit">ts</a><span class="delimiter">)</span> <a href="#419306" title="Int">d</a> = math.<span title="(x: Int, y: Int)Int">max</span><span class="delimiter">(</span><a href="#419306" title="Int">d</a>, <a href="#419326" title="Types.this.Type">tp</a>.<a href="#105384" title="=&gt; Int">baseTypeSeqDepth</a><span class="delimiter">)</span>
    <a href="#419306" title="Int">d</a> <span title="(x: Int)Int">+</span> <span title="Int(0)">LubGlbMargin</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Is intersection of given types populated? That is,
   *  for all types tp1, tp2 in intersection
   *    for all common base classes bc of tp1 and tp2
   *      let bt1, bt2 be the base types of tp1, tp2 relative to class bc
   *      Then:
   *        bt1 and bt2 have the same prefix, and
   *        any corresponding non-variant type arguments of bt1 and bt2 are the same
   */</span>
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67558">isPopulated</a><span class="delimiter">(</span><a title="Types.this.Type" id="159862">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="159863">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="459895">isConsistent</a><span class="delimiter">(</span><a title="Types.this.Type" id="459897">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="459898">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#459897" title="Types.this.Type">tp1</a>, <a href="#459898" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="459907">pre1</a>, <a title="Types.this.Symbol" id="459908">sym1</a>, <a title="List[Types.this.Type]" id="459909">args1</a><span class="delimiter">)</span>, TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="459910">pre2</a>, <a title="Types.this.Symbol" id="459911">sym2</a>, <a title="List[Types.this.Type]" id="459912">args2</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#459908" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#459911" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>
        <a href="#459907" title="Types.this.Type">pre1</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#459910" title="Types.this.Type">pre2</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <span class="delimiter">(</span><span title="(_1: List[Types.this.Type], _2: List[Types.this.Type], _3: List[Types.this.Symbol])(List[Types.this.Type], List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</span><a href="#459909" title="List[Types.this.Type]">args1</a>, <a href="#459912" title="List[Types.this.Type]">args2</a>, <a href="#459908" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span>.<span title="(implicit w1: List[Types.this.Type] =&gt; scala.collection.TraversableLike[Types.this.Type,List[Types.this.Type]], implicit w2: List[Types.this.Type] =&gt; scala.collection.IterableLike[Types.this.Type,List[Types.this.Type]], implicit w3: List[Types.this.Symbol] =&gt; scala.collection.IterableLike[Types.this.Symbol,List[Types.this.Symbol]])(List[Types.this.Type], List[Types.this.Type], List[Types.this.Symbol])#Zipped[List[Types.this.Type],Types.this.Type,List[Types.this.Type],Types.this.Type,List[Types.this.Symbol],Types.this.Symbol]">zipped</span> <span title="(f: (Types.this.Type, Types.this.Type, Types.this.Symbol) =&gt; Boolean)Boolean">forall</span> <span class="delimiter">{</span>
          <span class="delimiter">(</span><a title="Types.this.Type" id="459984">arg1</a>, <a title="Types.this.Type" id="459985">arg2</a>, <a title="Types.this.Symbol" id="459986">tparam</a><span class="delimiter">)</span> =&gt; 
            <span class="comment">//if (tparam.variance == 0 &amp;&amp; !(arg1 =:= arg2)) Console.println(&quot;inconsistent: &quot;+arg1+&quot;!=&quot;+arg2)//DEBUG</span>
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#459986" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107399" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#459984" title="Types.this.Type">arg1</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#459985" title="Types.this.Type">arg2</a>
          <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#459984" title="Types.this.Type">arg1</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#67458" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span><span class="delimiter">)</span> 
            <span class="comment">// if left-hand argument is a typevar, make it compatible with variance</span>
            <span class="comment">// this is for more precise pattern matching</span>
            <span class="comment">// todo: work this in the spec of this method</span>
            <span class="comment">// also: think what happens if there are embedded typevars?</span>
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#459986" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107399" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#459984" title="Types.this.Type">arg1</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#459985" title="Types.this.Type">arg2</a> <span class="keyword">else</span> <a href="#459985" title="Types.this.Type">arg2</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#459984" title="Types.this.Type">arg1</a>
          <span class="keyword">else</span> <span title="Boolean(true)" class="keyword">true</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span><a title="Types.this.ExistentialType" id="459998">et</a>: <a href="#149074" title="Types.this.ExistentialType">ExistentialType</a>, _<span class="delimiter">)</span> =&gt;
        <a href="#459998" title="Types.this.ExistentialType">et</a>.<a href="#149102" title="(op: Types.this.Type =&gt; Boolean)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#459895" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#460002" title="Types.this.Type">_</a>, <a href="#459898" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>_, <a title="Types.this.ExistentialType" id="460005">et</a>: <a href="#149074" title="Types.this.ExistentialType">ExistentialType</a><span class="delimiter">)</span> =&gt;
        <a href="#460005" title="Types.this.ExistentialType">et</a>.<a href="#149102" title="(op: Types.this.Type =&gt; Boolean)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#459895" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#459897" title="Types.this.Type">tp1</a>, <a href="#460009" title="Types.this.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>    

    <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="459896">check</a><span class="delimiter">(</span><a title="Types.this.Type" id="460010">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460011">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = 
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460010" title="Types.this.Type">tp1</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460010" title="Types.this.Type">tp1</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="(mask: Long)Boolean">hasFlag</span><span class="delimiter">(</span><span title="Long(32L)">FINAL</span><span class="delimiter">)</span><span class="delimiter">)</span> 
        <a href="#460010" title="Types.this.Type">tp1</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460011" title="Types.this.Type">tp2</a> <span title="(x: Boolean)Boolean">||</span> <a href="Definitions.scala.html#106571" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#460010" title="Types.this.Type">tp1</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#106571" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#460011" title="Types.this.Type">tp2</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#460010" title="Types.this.Type">tp1</a>.<a href="#105385" title="=&gt; List[Types.this.Symbol]">baseClasses</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="460021">bc</a> =&gt; 
        <a href="#460011" title="Types.this.Type">tp2</a>.<a href="#105386" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#460021" title="Types.this.Symbol">bc</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#459895" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#460010" title="Types.this.Type">tp1</a>.<a href="#105358" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#460021" title="Types.this.Symbol">bc</a><span class="delimiter">)</span>, <a href="#460011" title="Types.this.Type">tp2</a>.<a href="#105358" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#460021" title="Types.this.Symbol">bc</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <a href="#459896" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">check</a><span class="delimiter">(</span><a href="#159862" title="Types.this.Type">tp1</a>, <a href="#159863" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="comment">/* &amp;&amp; check(tp2, tp1)*/</span> <span class="comment">// need to investgate why this can't be made symmetric -- neg/gadts1 fails, and run/existials also.</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Does a pattern of type `patType' need an outer test when executed against
   *  selector type `selType' in context defined by `currentOwner'?
   */</span>
  <span class="keyword">def</span> <a title="(patType: Types.this.Type, selType: Types.this.Type, currentOwner: Types.this.Symbol)Boolean" id="67559">needsOuterTest</a><span class="delimiter">(</span><a title="Types.this.Type" id="159800">patType</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="159801">selType</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="159802">currentOwner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type)Types.this.Type" id="159805">createDummyClone</a><span class="delimiter">(</span><a title="Types.this.Type" id="159807">pre</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.TermSymbol" id="159808">dummy</a> = <a href="#159802" title="Types.this.Symbol">currentOwner</a>.<span title="=&gt; Types.this.Symbol">enclClass</span>.<a href="Symbols.scala.html#107279" title="(pos: Types.this.Position, name: Types.this.TermName)Types.this.TermSymbol">newValue</a><span class="delimiter">(</span><a href="Positions.scala.html#67891" title="=&gt; tools.nsc.util.NoPosition.type">NoPosition</a>, <a href="StdNames.scala.html#67713" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#115274" title="=&gt; Types.this.nme.NameType">ANYNAME</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107425" title="(info: Types.this.Type)Types.this.TermSymbol">setInfo</a><span class="delimiter">(</span><a href="#159807" title="Types.this.Type">pre</a>.<a href="#105317" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
      <a href="#67468" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#148190" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="#159802" title="Types.this.Symbol">currentOwner</a>.<span title="=&gt; Types.this.Symbol">enclClass</span><span class="delimiter">)</span>, <a href="#159808" title="Types.this.TermSymbol">dummy</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="159806">maybeCreateDummyClone</a><span class="delimiter">(</span><a title="Types.this.Type" id="159831">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="159832">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#159831" title="Types.this.Type">pre</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="159833">pre1</a>, <a title="Types.this.Symbol" id="159834">sym1</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#159834" title="Types.this.Symbol">sym1</a>.<span title="=&gt; Boolean">isModule</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#159834" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107384" title="=&gt; Boolean">isStatic</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#450850" title="object Types.this.NoType">NoType</a>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#159834" title="Types.this.Symbol">sym1</a>.<span title="=&gt; Boolean">isModule</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#159832" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#159834" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107486" title="=&gt; Types.this.Symbol">moduleClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="159840">pre2</a> = <a href="#159806" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span><a href="#159833" title="Types.this.Type">pre1</a>, <a href="#159834" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#159840" title="Types.this.Type">pre2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <a href="#159840" title="Types.this.Type">pre2</a>
          <span class="keyword">else</span> <a href="#67468" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#159840" title="Types.this.Type">pre2</a>, <a href="#159834" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <a href="#159805" title="(pre: Types.this.Type)Types.this.Type">createDummyClone</a><span class="delimiter">(</span><a href="#159831" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="159841">clazz</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#159841" title="Types.this.Symbol">clazz</a>.<span title="=&gt; Boolean">isModuleClass</span><span class="delimiter">)</span>
          <a href="#159806" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span><a href="#159841" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107458" title="=&gt; Types.this.Type">typeOfThis</a>, <a href="#159832" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#159832" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#159841" title="Types.this.Symbol">clazz</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#159832" title="Types.this.Symbol">sym</a>.<span title="(mask: Long)Boolean">hasFlag</span><span class="delimiter">(</span><span title="Long(4L)">PRIVATE</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#159832" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107277" title="=&gt; Types.this.Symbol">privateWithin</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#159841" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#450850" title="object Types.this.NoType">NoType</a>
        <span class="keyword">else</span> 
          <a href="#159805" title="(pre: Types.this.Type)Types.this.Type">createDummyClone</a><span class="delimiter">(</span><a href="#159831" title="Types.this.Type">pre</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.NoType.type">_</span> =&gt;
        <a href="#450850" title="object Types.this.NoType">NoType</a>
    <span class="delimiter">}</span>
    <a href="#159800" title="Types.this.Type">patType</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="159858">pre</a>, <a title="Types.this.Symbol" id="159859">sym</a>, <a title="List[Types.this.Type]" id="159860">args</a><span class="delimiter">)</span> =&gt; 
        <span class="keyword">val</span> <a title="Types.this.Type" id="159861">pre1</a> = <a href="#159806" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span><a href="#159858" title="Types.this.Type">pre</a>, <a href="#159859" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="#159861" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67558" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isPopulated</a><span class="delimiter">(</span><a href="#67473" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#159800" title="Types.this.Type">patType</a>, <a href="#159861" title="Types.this.Type">pre1</a>, <a href="#159859" title="Types.this.Symbol">sym</a>, <a href="#159860" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, <a href="#159801" title="Types.this.Type">selType</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
        <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="67561">subsametypeRecursions</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(pre1: Types.this.Type, pre2: Types.this.Type)Boolean" id="67563">isUnifiable</a><span class="delimiter">(</span><a title="Types.this.Type" id="460026">pre1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460027">pre2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
    <span class="delimiter">(</span><a href="#67585" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#460026" title="Types.this.Type">pre1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#67585" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#460027" title="Types.this.Type">pre2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#460026" title="Types.this.Type">pre1</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460027" title="Types.this.Type">pre2</a><span class="delimiter">)</span>

  <span class="comment">/** Returns true iff we are past phase specialize,
   *  sym1 and sym2 are two existential skolems with equal names and bounds,
   *  and pre1 and pre2 are equal prefixes
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol, pre1: Types.this.Type, pre2: Types.this.Type)Boolean" id="67564">isSameSpecializedSkolem</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="460032">sym1</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="460033">sym2</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="460034">pre1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460035">pre2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#460032" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107343" title="=&gt; Boolean">isExistentialSkolem</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460033" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107343" title="=&gt; Boolean">isExistentialSkolem</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
    <a href="#460032" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#460033" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
    <a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102840" title="=&gt; Boolean">specialized</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
    <a href="#460032" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460033" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
    <a href="#460034" title="Types.this.Type">pre1</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460035" title="Types.this.Type">pre2</a>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean" id="67565">equalSymsAndPrefixes</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="460043">sym1</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="460044">pre1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="460045">sym2</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="460046">pre2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460043" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#460045" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> <a href="#460043" title="Types.this.Symbol">sym1</a>.<span title="=&gt; Boolean">hasPackageFlag</span> <span title="(x: Boolean)Boolean">||</span> <a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#460044" title="Types.this.Type">pre1</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460046" title="Types.this.Type">pre2</a>
    <span class="keyword">else</span> <span class="delimiter">(</span><a href="#460043" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#460045" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67563" title="(pre1: Types.this.Type, pre2: Types.this.Type)Boolean">isUnifiable</a><span class="delimiter">(</span><a href="#460044" title="Types.this.Type">pre1</a>, <a href="#460046" title="Types.this.Type">pre2</a><span class="delimiter">)</span>

  <span class="comment">/** Do `tp1' and `tp2' denote equivalent types?
   */</span>
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67566">isSameType</a><span class="delimiter">(</span><a title="Types.this.Type" id="261884">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="261885">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="../util/Statistics.scala.html#67151" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67204" title="=&gt; scala.tools.nsc.util.Statistics.Counter">sametypeCount</a><span class="delimiter">)</span>
    <a href="#67561" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <a href="#67372" title="object Types.this.undoLog">undoLog</a> <a href="#106745" title="(block: =&gt; Boolean)Boolean">undoUnless</a> <span class="delimiter">{</span>
      <a href="#67570" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType1</a><span class="delimiter">(</span><a href="#261884" title="Types.this.Type">tp1</a>, <a href="#261885" title="Types.this.Type">tp2</a><span class="delimiter">)</span> 
    <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#67561" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
    <span class="comment">// XXX AM TODO: figure out when it is safe and needed to clear the log -- the commented approach below is too eager (it breaks #3281, #3866)</span>
    <span class="comment">// it doesn't help to keep separate recursion counts for the three methods that now share it</span>
    <span class="comment">// if (subsametypeRecursions == 0) undoLog.clear()</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67567">isDifferentType</a><span class="delimiter">(</span><a title="Types.this.Type" id="460070">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460071">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="#67561" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <a href="#67372" title="object Types.this.undoLog">undoLog</a> <a href="#106742" title="(block: =&gt; Boolean)Boolean">undo</a> <span class="delimiter">{</span> <span class="comment">// undo type constraints that arise from operations in this block</span>
      <span title="=&gt; Boolean">!</span><a href="#67570" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType1</a><span class="delimiter">(</span><a href="#460070" title="Types.this.Type">tp1</a>, <a href="#460071" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#67561" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
    <span class="comment">// XXX AM TODO: figure out when it is safe and needed to clear the log -- the commented approach below is too eager (it breaks #3281, #3866)</span>
    <span class="comment">// it doesn't help to keep separate recursion counts for the three methods that now share it</span>
    <span class="comment">// if (subsametypeRecursions == 0) undoLog.clear()</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67568">isDifferentTypeConstructor</a><span class="delimiter">(</span><a title="Types.this.Type" id="460084">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460085">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#460084" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="460087">pre1</a>, <a title="Types.this.Symbol" id="460088">sym1</a>, _<span class="delimiter">)</span> =&gt; 
      <a href="#460085" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="460089">pre2</a>, <a title="Types.this.Symbol" id="460090">sym2</a>, _<span class="delimiter">)</span> =&gt; <a href="#460088" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#460090" title="Types.this.Symbol">sym2</a> <span title="(x: Boolean)Boolean">||</span> <a href="#67567" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isDifferentType</a><span class="delimiter">(</span><a href="#460087" title="Types.this.Type">pre1</a>, <a href="#460089" title="Types.this.Type">pre2</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Boolean(true)">_</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> <span title="Boolean(true)">_</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="67569">normalizePlus</a><span class="delimiter">(</span><a title="Types.this.Type" id="258490">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = 
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67516" title="(tp: Types.this.Type)Boolean">isRawType</a><span class="delimiter">(</span><a href="#258490" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#258513" title="(tp: Types.this.Type)Types.this.Type">rawToExistential</a><span class="delimiter">(</span><a href="#258490" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <a href="#258490" title="Types.this.Type">tp</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a>

  <span class="comment">/*
  todo: change to:
  def normalizePlus(tp: Type) = tp match {
    case TypeRef(pre, sym, List()) =&gt;
      if (!sym.isInitialized) sym.rawInfo.load(sym)
      if (sym.isJavaDefined &amp;&amp; !sym.typeParams.isEmpty) rawToExistential(tp)
      else tp.normalize
    case _ =&gt; tp.normalize
  }
  */</span>
<span class="comment">/*
  private def isSameType0(tp1: Type, tp2: Type): Boolean = {
    if (tp1 eq tp2) return true
    ((tp1, tp2) match {
      case (ErrorType, _) =&gt; true
      case (WildcardType, _) =&gt; true
      case (_, ErrorType) =&gt; true
      case (_, WildcardType) =&gt; true

      case (NoType, _) =&gt; false
      case (NoPrefix, _) =&gt; tp2.typeSymbol.isPackageClass
      case (_, NoType) =&gt; false
      case (_, NoPrefix) =&gt; tp1.typeSymbol.isPackageClass

      case (ThisType(sym1), ThisType(sym2))
      if (sym1 == sym2) =&gt;
        true
      case (SingleType(pre1, sym1), SingleType(pre2, sym2))
      if (equalSymsAndPrefixes(sym1, pre1, sym2, pre2)) =&gt;
        true
/*
      case (SingleType(pre1, sym1), ThisType(sym2))
      if (sym1.isModule &amp;&amp; 
          sym1.moduleClass == sym2 &amp;&amp;
          pre1 =:= sym2.owner.thisType) =&gt;
        true
      case (ThisType(sym1), SingleType(pre2, sym2))
      if (sym2.isModule &amp;&amp; 
          sym2.moduleClass == sym1 &amp;&amp;
          pre2 =:= sym1.owner.thisType) =&gt;
        true
*/
      case (ConstantType(value1), ConstantType(value2)) =&gt;
        value1 == value2
      case (TypeRef(pre1, sym1, args1), TypeRef(pre2, sym2, args2)) =&gt;
        equalSymsAndPrefixes(sym1, pre1, sym2, pre2) &amp;&amp;
        ((tp1.isHigherKinded &amp;&amp; tp2.isHigherKinded &amp;&amp; tp1.normalize =:= tp2.normalize) || 
         isSameTypes(args1, args2))
         // @M! normalize reduces higher-kinded case to PolyType's
      case (RefinedType(parents1, ref1), RefinedType(parents2, ref2)) =&gt;
        def isSubScope(s1: Scope, s2: Scope): Boolean = s2.toList.forall {
          sym2 =&gt;
            var e1 = s1.lookupEntry(sym2.name)
            (e1 ne null) &amp;&amp; {
              val substSym = sym2.info.substThis(sym2.owner, e1.sym.owner.thisType)
              var isEqual = false
              while (!isEqual &amp;&amp; (e1 ne null)) { 
                isEqual = e1.sym.info =:= substSym
                e1 = s1.lookupNextEntry(e1)
              }
              isEqual
            }
        }
        //Console.println(&quot;is same? &quot; + tp1 + &quot; &quot; + tp2 + &quot; &quot; + tp1.typeSymbol.owner + &quot; &quot; + tp2.typeSymbol.owner)//DEBUG
        isSameTypes(parents1, parents2) &amp;&amp; isSubScope(ref1, ref2) &amp;&amp; isSubScope(ref2, ref1)
      case (MethodType(params1, res1), MethodType(params2, res2)) =&gt;
        // new dependent types: probably fix this, use substSym as done for PolyType
        (isSameTypes(tp1.paramTypes, tp2.paramTypes) &amp;&amp;
         res1 =:= res2 &amp;&amp;
         tp1.isImplicit == tp2.isImplicit)
      case (PolyType(tparams1, res1), PolyType(tparams2, res2)) =&gt; 
        // assert((tparams1 map (_.typeParams.length)) == (tparams2 map (_.typeParams.length)))
        (tparams1.length == tparams2.length) &amp;&amp; (tparams1 corresponds tparams2)(_.info =:= _.info.substSym(tparams2, tparams1)) &amp;&amp; // @M looks like it might suffer from same problem as #2210 
          res1 =:= res2.substSym(tparams2, tparams1)
      case (ExistentialType(tparams1, res1), ExistentialType(tparams2, res2)) =&gt;
        (tparams1.length == tparams2.length) &amp;&amp; (tparams1 corresponds tparams2)(_.info =:= _.info.substSym(tparams2, tparams1)) &amp;&amp; // @M looks like it might suffer from same problem as #2210
          res1 =:= res2.substSym(tparams2, tparams1)
      case (TypeBounds(lo1, hi1), TypeBounds(lo2, hi2)) =&gt;
        lo1 =:= lo2 &amp;&amp; hi1 =:= hi2
      case (BoundedWildcardType(bounds), _) =&gt;
        bounds containsType tp2
      case (_, BoundedWildcardType(bounds)) =&gt;
        bounds containsType tp1
      case (tv @ TypeVar(_,_), tp) =&gt;
        tv.registerTypeEquality(tp, true)
      case (tp, tv @ TypeVar(_,_)) =&gt;
        tv.registerTypeEquality(tp, false)
      case (AnnotatedType(_,_,_), _) =&gt;
        annotationsConform(tp1, tp2) &amp;&amp; annotationsConform(tp2, tp1) &amp;&amp; tp1.withoutAnnotations =:= tp2.withoutAnnotations
      case (_, AnnotatedType(_,_,_)) =&gt;
        annotationsConform(tp1, tp2) &amp;&amp; annotationsConform(tp2, tp1) &amp;&amp; tp1.withoutAnnotations =:= tp2.withoutAnnotations
      case (_: SingletonType, _: SingletonType) =&gt;
        var origin1 = tp1
        while (origin1.underlying.isInstanceOf[SingletonType]) {
          assert(origin1 ne origin1.underlying, origin1)
          origin1 = origin1.underlying
        }
        var origin2 = tp2
        while (origin2.underlying.isInstanceOf[SingletonType]) {
          assert(origin2 ne origin2.underlying, origin2)
          origin2 = origin2.underlying
        }
        ((origin1 ne tp1) || (origin2 ne tp2)) &amp;&amp; (origin1 =:= origin2)
      case _ =&gt;
        false
    }) || {
      val tp1n = normalizePlus(tp1)
      val tp2n = normalizePlus(tp2)
      ((tp1n ne tp1) || (tp2n ne tp2)) &amp;&amp; isSameType(tp1n, tp2n)
    }
  }
*/</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67570">isSameType1</a><span class="delimiter">(</span><a title="Types.this.Type" id="460063">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460064">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#460063" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#460064" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> 
        <span class="delimiter">(</span><a href="#460063" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450783" title="object Types.this.ErrorType">ErrorType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#460063" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450801" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
        <span class="delimiter">(</span><a href="#460064" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450783" title="object Types.this.ErrorType">ErrorType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#460064" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450801" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#460063" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#460064" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460063" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> 
      <a href="#460064" title="Types.this.Type">tp2</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isPackageClass</span>
    <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460064" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span>
      <a href="#460063" title="Types.this.Type">tp1</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isPackageClass</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <a href="#67571" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType2</a><span class="delimiter">(</span><a href="#460063" title="Types.this.Type">tp1</a>, <a href="#460064" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="460098">tp1n</a> = <a href="#67569" title="(tp: Types.this.Type)Types.this.Type">normalizePlus</a><span class="delimiter">(</span><a href="#460063" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="460099">tp2n</a> = <a href="#67569" title="(tp: Types.this.Type)Types.this.Type">normalizePlus</a><span class="delimiter">(</span><a href="#460064" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><span class="delimiter">(</span><a href="#460098" title="Types.this.Type">tp1n</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#460063" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#460099" title="Types.this.Type">tp2n</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#460064" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67566" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a><span class="delimiter">(</span><a href="#460098" title="Types.this.Type">tp1n</a>, <a href="#460099" title="Types.this.Type">tp2n</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67571">isSameType2</a><span class="delimiter">(</span><a title="Types.this.Type" id="460095">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460096">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <a href="#460095" title="Types.this.Type">tp1</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Unit" id="460100">tr1</a>: <a href="#133425" title="Types.this.TypeRef">TypeRef</a> =&gt;
        <a href="#460096" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Nothing" id="460101">tr2</a>: <a href="#133425" title="Types.this.TypeRef">TypeRef</a> =&gt;
            <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span><a href="#67565" title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean">equalSymsAndPrefixes</a><span class="delimiter">(</span><a href="#460100" title="Types.this.TypeRef">tr1</a>.<a href="#133454" title="=&gt; Types.this.Symbol">sym</a>, <a href="#460100" title="Types.this.TypeRef">tr1</a>.<a href="#133453" title="=&gt; Types.this.Type">pre</a>, <a href="#460101" title="Types.this.TypeRef">tr2</a>.<a href="#133454" title="=&gt; Types.this.Symbol">sym</a>, <a href="#460101" title="Types.this.TypeRef">tr2</a>.<a href="#133453" title="=&gt; Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <span class="delimiter">(</span><span class="delimiter">(</span><a href="#460095" title="Types.this.Type">tp1</a>.<a href="#105304" title="=&gt; Boolean">isHigherKinded</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460096" title="Types.this.Type">tp2</a>.<a href="#105304" title="=&gt; Boolean">isHigherKinded</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460095" title="Types.this.Type">tp1</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460096" title="Types.this.Type">tp2</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> 
               <a href="#67572" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span><a href="#460100" title="Types.this.TypeRef">tr1</a>.<a href="#133455" title="=&gt; List[Types.this.Type]">args</a>, <a href="#460101" title="Types.this.TypeRef">tr2</a>.<a href="#133455" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
               <span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#460100" title="Types.this.TypeRef">tr1</a>.<a href="#133453" title="=&gt; Types.this.Type">pre</a>, <a href="#460101" title="Types.this.TypeRef">tr2</a>.<a href="#133453" title="=&gt; Types.this.Type">pre</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
                 <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span><a title="Types.this.TypeVar" id="460113">tv</a> @ <a href="#448916" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#460113" title="Types.this.TypeVar">tv</a>.<a href="#448952" title="(sym: Types.this.Symbol, tp: Types.this.Type)Boolean">registerTypeSelection</a><span class="delimiter">(</span><a href="#460100" title="Types.this.TypeRef">tr1</a>.<a href="#133454" title="=&gt; Types.this.Symbol">sym</a>, <a href="#460101" title="Types.this.TypeRef">tr2</a><span class="delimiter">)</span>
                 <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>_, <a title="Types.this.TypeVar" id="460117">tv</a> @ <a href="#448916" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#460117" title="Types.this.TypeVar">tv</a>.<a href="#448952" title="(sym: Types.this.Symbol, tp: Types.this.Type)Boolean">registerTypeSelection</a><span class="delimiter">(</span><a href="#460101" title="Types.this.TypeRef">tr2</a>.<a href="#133454" title="=&gt; Types.this.Symbol">sym</a>, <a href="#460100" title="Types.this.TypeRef">tr1</a><span class="delimiter">)</span>
                 <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
               <span class="delimiter">}</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="460119">tt1</a>: <a href="#148255" title="Types.this.ThisType">ThisType</a> =&gt;
        <a href="#460096" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Unit" id="460120">tt2</a>: <a href="#148255" title="Types.this.ThisType">ThisType</a> =&gt;
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#460119" title="Types.this.ThisType">tt1</a>.<a href="#148263" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#460120" title="Types.this.ThisType">tt2</a>.<a href="#148263" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="460125">st1</a>: <a href="#148293" title="Types.this.SingleType">SingleType</a> =&gt;
        <a href="#460096" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Unit" id="460126">st2</a>: <a href="#148293" title="Types.this.SingleType">SingleType</a> =&gt;
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#67565" title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean">equalSymsAndPrefixes</a><span class="delimiter">(</span><a href="#460125" title="Types.this.SingleType">st1</a>.<a href="#148308" title="=&gt; Types.this.Symbol">sym</a>, <a href="#460125" title="Types.this.SingleType">st1</a>.<a href="#148307" title="=&gt; Types.this.Type">pre</a>, <a href="#460126" title="Types.this.SingleType">st2</a>.<a href="#148308" title="=&gt; Types.this.Symbol">sym</a>, <a href="#460126" title="Types.this.SingleType">st2</a>.<a href="#148307" title="=&gt; Types.this.Type">pre</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="460127">ct1</a>: <a href="#148358" title="Types.this.ConstantType">ConstantType</a> =&gt;
        <a href="#460096" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Nothing" id="460128">ct2</a>: <a href="#148358" title="Types.this.ConstantType">ConstantType</a> =&gt;
            <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span><a href="#460127" title="Types.this.ConstantType">ct1</a>.<a href="#148366" title="=&gt; Types.this.Constant">value</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#460128" title="Types.this.ConstantType">ct2</a>.<a href="#148366" title="=&gt; Types.this.Constant">value</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="460133">rt1</a>: <a href="#148512" title="Types.this.RefinedType">RefinedType</a> =&gt;
        <a href="#460096" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Nothing" id="460134">rt2</a>: <a href="#148512" title="Types.this.RefinedType">RefinedType</a> =&gt; <span class="comment">// </span>
            <span class="keyword">def</span> <a title="(s1: Types.this.Scope, s2: Types.this.Scope)Boolean" id="460135">isSubScope</a><span class="delimiter">(</span><a title="Types.this.Scope" id="460136">s1</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a>, <a title="Types.this.Scope" id="460137">s2</a>: <a href="Scopes.scala.html#67680" title="Types.this.Scope">Scope</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#460137" title="Types.this.Scope">s2</a>.<a href="Scopes.scala.html#112957" title="=&gt; List[Types.this.Symbol]">toList</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">{</span>
              <a title="Types.this.Symbol" id="460146">sym2</a> =&gt;
                <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="460147">e1</a> = <a href="#460136" title="Types.this.Scope">s1</a>.<a href="Scopes.scala.html#112955" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#460146" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
                <span class="delimiter">(</span><a href="#460147" title="Types.this.ScopeEntry">e1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
                  <span class="keyword">val</span> <a title="Types.this.Type" id="460149">substSym</a> = <a href="#460146" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105365" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#460146" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>, <a href="#460147" title="Types.this.ScopeEntry">e1</a>.<a href="Scopes.scala.html#113135" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#107459" title="=&gt; Types.this.Type">thisType</a><span class="delimiter">)</span>
                  <span class="keyword">var</span> <a title="Boolean" id="460150">isEqual</a> = <span title="Boolean(false)" class="keyword">false</span>
                  <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#460150" title="Boolean">isEqual</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#460147" title="Types.this.ScopeEntry">e1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#460151" title="()Unit" class="delimiter">{</a> 
                    <a href="#460150" title="Boolean">isEqual</a> = <a href="#460147" title="Types.this.ScopeEntry">e1</a>.<a href="Scopes.scala.html#113135" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460149" title="Types.this.Type">substSym</a>
                    <a href="#460147" title="Types.this.ScopeEntry">e1</a> = <a href="#460136" title="Types.this.Scope">s1</a>.<a href="Scopes.scala.html#112956" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a><span class="delimiter">(</span><a href="#460147" title="Types.this.ScopeEntry">e1</a><span class="delimiter">)</span>
                  <span class="delimiter">}</span>
                  <a href="#460150" title="Boolean">isEqual</a>
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="comment">//Console.println(&quot;is same? &quot; + tp1 + &quot; &quot; + tp2 + &quot; &quot; + tp1.typeSymbol.owner + &quot; &quot; + tp2.typeSymbol.owner)//DEBUG</span>
            <span title="Nothing" class="keyword">return</span> <a href="#67572" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span><a href="#460133" title="Types.this.RefinedType">rt1</a>.<a href="#236305" title="=&gt; List[Types.this.Type]">parents</a>, <a href="#460134" title="Types.this.RefinedType">rt2</a>.<a href="#236305" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Scope" id="460155">decls1</a> = <a href="#460133" title="Types.this.RefinedType">rt1</a>.<a href="#236306" title="=&gt; Types.this.Scope">decls</a>
              <span class="keyword">val</span> <a title="Types.this.Scope" id="460156">decls2</a> = <a href="#460134" title="Types.this.RefinedType">rt2</a>.<a href="#236306" title="=&gt; Types.this.Scope">decls</a>
              <a href="#460135" title="(s1: Types.this.Scope, s2: Types.this.Scope)Boolean">isSubScope</a><span class="delimiter">(</span><a href="#460155" title="Types.this.Scope">decls1</a>, <a href="#460156" title="Types.this.Scope">decls2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460135" title="(s1: Types.this.Scope, s2: Types.this.Scope)Boolean">isSubScope</a><span class="delimiter">(</span><a href="#460156" title="Types.this.Scope">decls2</a>, <a href="#460155" title="Types.this.Scope">decls1</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="460157">mt1</a>: <a href="#148698" title="Types.this.MethodType">MethodType</a> =&gt;
        <a href="#460096" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Nothing" id="460158">mt2</a>: <a href="#148698" title="Types.this.MethodType">MethodType</a> =&gt;
            <span class="comment">// DEPMETTODO new dependent types: probably fix this, use substSym as done for PolyType</span>
            <span title="Nothing" class="keyword">return</span> <a href="#67572" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span><a href="#460157" title="Types.this.MethodType">mt1</a>.<a href="#148713" title="=&gt; List[Types.this.Type]">paramTypes</a>, <a href="#460158" title="Types.this.MethodType">mt2</a>.<a href="#148713" title="=&gt; List[Types.this.Type]">paramTypes</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <a href="#460157" title="Types.this.MethodType">mt1</a>.<a href="#151832" title="=&gt; Types.this.Type">resultType</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460158" title="Types.this.MethodType">mt2</a>.<a href="#151832" title="=&gt; Types.this.Type">resultType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <a href="#460157" title="Types.this.MethodType">mt1</a>.<a href="#148709" title="=&gt; Boolean">isImplicit</a> <span title="(x: Boolean)Boolean">==</span> <a href="#460158" title="Types.this.MethodType">mt2</a>.<a href="#148709" title="=&gt; Boolean">isImplicit</a>
          <span class="comment">// note: no case NullaryMethodType(restpe) =&gt; return mt1.params.isEmpty &amp;&amp; mt1.resultType =:= restpe</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Unit">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="460168">restpe1</a><span class="delimiter">)</span> =&gt;
        <a href="#460096" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="comment">// note: no case mt2: MethodType =&gt; return mt2.params.isEmpty &amp;&amp; restpe  =:= mt2.resultType</span>
          <span class="keyword">case</span> <span title="Nothing">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="460169">restpe2</a><span class="delimiter">)</span> =&gt;
            <span title="Nothing" class="keyword">return</span> <a href="#460168" title="Types.this.Type">restpe1</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460169" title="Types.this.Type">restpe2</a>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Unit">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460170">tparams1</a>, <a title="Types.this.Type" id="460171">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#460096" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Nothing">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460172">tparams2</a>, <a title="Types.this.Type" id="460173">res2</a><span class="delimiter">)</span> =&gt;
<span class="comment">//            assert((tparams1 map (_.typeParams.length)) == (tparams2 map (_.typeParams.length)))</span>
              <span class="comment">// @M looks like it might suffer from same problem as #2210</span>
              <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span>
                <span class="delimiter">(</span><a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#460170" title="List[Types.this.Symbol]">tparams1</a>, <a href="#460172" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="comment">// corresponds does not check length of two sequences before checking the predicate</span>
                <span class="delimiter">(</span><a href="#460170" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#460172" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#460193" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460194" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460172" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460170" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
                <a href="#460171" title="Types.this.Type">res1</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460173" title="Types.this.Type">res2</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460172" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460170" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>
              <span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Unit">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460195">tparams1</a>, <a title="Types.this.Type" id="460196">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#460096" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Nothing">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460197">tparams2</a>, <a title="Types.this.Type" id="460198">res2</a><span class="delimiter">)</span> =&gt;
            <span class="comment">// @M looks like it might suffer from same problem as #2210</span>
            <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span>
              <span class="comment">// corresponds does not check length of two sequences before checking the predicate -- faster &amp; needed to avoid crasher in #2956</span>
              <a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#460195" title="List[Types.this.Symbol]">tparams1</a>, <a href="#460197" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <span class="delimiter">(</span><a href="#460195" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#460197" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#460218" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460219" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460197" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460195" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <a href="#460196" title="Types.this.Type">res1</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460198" title="Types.this.Type">res2</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460197" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460195" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>
            <span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Unit">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="460220">lo1</a>, <a title="Types.this.Type" id="460221">hi1</a><span class="delimiter">)</span> =&gt;
        <a href="#460096" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Nothing">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="460222">lo2</a>, <a title="Types.this.Type" id="460223">hi2</a><span class="delimiter">)</span> =&gt;
            <span title="Nothing" class="keyword">return</span> <a href="#460220" title="Types.this.Type">lo1</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460222" title="Types.this.Type">lo2</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460221" title="Types.this.Type">hi1</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460223" title="Types.this.Type">hi2</a>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Nothing">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="460224">bounds</a><span class="delimiter">)</span> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="#460224" title="Types.this.TypeBounds">bounds</a> <a href="#148449" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#460096" title="Types.this.Type">tp2</a>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#460096" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Nothing">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="460225">bounds</a><span class="delimiter">)</span> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="#460225" title="Types.this.TypeBounds">bounds</a> <a href="#148449" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#460095" title="Types.this.Type">tp1</a>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#460095" title="Types.this.Type">tp1</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Nothing" id="460226">tv</a> @ <a href="#448916" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="#460226" title="Types.this.TypeVar">tv</a>.<a href="#448951" title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean">registerTypeEquality</a><span class="delimiter">(</span><a href="#460096" title="Types.this.Type">tp2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#460096" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Nothing" id="460228">tv</a> @ <a href="#448916" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="#460228" title="Types.this.TypeVar">tv</a>.<a href="#448951" title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean">registerTypeEquality</a><span class="delimiter">(</span><a href="#460095" title="Types.this.Type">tp1</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#460095" title="Types.this.Type">tp1</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Nothing">_</span>: <a href="#148952" title="Types.this.AnnotatedType">AnnotatedType</a> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="AnnotationCheckers.scala.html#67759" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#460095" title="Types.this.Type">tp1</a>, <a href="#460096" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#67759" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#460096" title="Types.this.Type">tp2</a>, <a href="#460095" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460095" title="Types.this.Type">tp1</a>.<a href="#105403" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460096" title="Types.this.Type">tp2</a>.<a href="#105403" title="=&gt; Types.this.Type">withoutAnnotations</a>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#460096" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Nothing">_</span>: <a href="#148952" title="Types.this.AnnotatedType">AnnotatedType</a> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="AnnotationCheckers.scala.html#67759" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#460095" title="Types.this.Type">tp1</a>, <a href="#460096" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#67759" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#460096" title="Types.this.Type">tp2</a>, <a href="#460095" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460095" title="Types.this.Type">tp1</a>.<a href="#105403" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460096" title="Types.this.Type">tp2</a>.<a href="#105403" title="=&gt; Types.this.Type">withoutAnnotations</a>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#460095" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="#67387" title="Types.this.SingletonType">SingletonType</a> =&gt;
        <a href="#460096" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="#67387" title="Types.this.SingletonType">SingletonType</a> =&gt;
            @inline <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="460232">chaseDealiasedUnderlying</a><span class="delimiter">(</span><a title="Types.this.Type" id="460235">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
              <span class="keyword">var</span> <a title="Types.this.Type" id="460236">origin</a> = <a href="#460235" title="Types.this.Type">tp</a>
              <span class="keyword">var</span> <a title="Types.this.Type" id="460237">next</a> = <a href="#460236" title="Types.this.Type">origin</a>.<a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105343" title="=&gt; Types.this.Type">dealias</a>
              <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#460237" title="Types.this.Type">next</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#67387" title="Types.this.SingletonType">SingletonType</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#460238" title="()Unit" class="delimiter">{</a>
                <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#460236" title="Types.this.Type">origin</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#460237" title="Types.this.Type">next</a>, <a href="#460236" title="Types.this.Type">origin</a><span class="delimiter">)</span>
                <a href="#460236" title="Types.this.Type">origin</a> = <a href="#460237" title="Types.this.Type">next</a>
                <a href="#460237" title="Types.this.Type">next</a> = <a href="#460236" title="Types.this.Type">origin</a>.<a href="#105316" title="=&gt; Types.this.Type">underlying</a>.<a href="#105343" title="=&gt; Types.this.Type">dealias</a>
              <span class="delimiter">}</span>
              <a href="#460236" title="Types.this.Type">origin</a>
            <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="460233">origin1</a> = <a href="#460232" title="(tp: Types.this.Type)Types.this.Type">chaseDealiasedUnderlying</a><span class="delimiter">(</span><a href="#460095" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="460234">origin2</a> = <a href="#460232" title="(tp: Types.this.Type)Types.this.Type">chaseDealiasedUnderlying</a><span class="delimiter">(</span><a href="#460096" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
            <span class="delimiter">(</span><span class="delimiter">(</span><a href="#460233" title="Types.this.Type">origin1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#460095" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#460234" title="Types.this.Type">origin2</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#460096" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#460233" title="Types.this.Type">origin1</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460234" title="Types.this.Type">origin2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
        <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Are `tps1' and `tps2' lists of pairwise equivalent
   *  types?
   */</span>
  <span class="keyword">def</span> <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean" id="67572">isSameTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="460102">tps1</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="460103">tps2</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#460102" title="List[Types.this.Type]">tps1</a> <span title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.Type, Types.this.Type) =&gt; Boolean)Boolean">corresponds</span> <a href="#460103" title="List[Types.this.Type]">tps2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#460258" title="Types.this.Type">_</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460259" title="Types.this.Type">_</a><span class="delimiter">)</span>

  <span class="comment">/** True if two lists have the same length.  Since calling length on linear sequences
   *  is O(n), it is an inadvisable way to test length equality.
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(xs1: List[_], xs2: List[_])Boolean" id="67573">sameLength</a><span class="delimiter">(</span><a title="List[_]" id="262020">xs1</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="List[_]" id="262021">xs2</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#67574" title="(xs1: List[_], xs2: List[_])Int">compareLengths</a><span class="delimiter">(</span><a href="#262020" title="List[_]">xs1</a>, <a href="#262021" title="List[_]">xs2</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span>
  @tailrec <span class="keyword">final</span> <span class="keyword">def</span> <a title="(xs1: List[_], xs2: List[_])Int" id="67574">compareLengths</a><span class="delimiter">(</span><a title="List[_]" id="262024">xs1</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="List[_]" id="262025">xs2</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> =
    <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#262024" title="List[_]">xs1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#262025" title="List[_]">xs2</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> <span class="keyword">else</span> -<span title="Int(-1)" class="int">1</span> <span class="delimiter">}</span>
    <span class="keyword">else</span> <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#262025" title="List[_]">xs2</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="Int(1)" class="int">1</span>
    <span class="keyword">else</span> <a href="#67574" title="(xs1: List[_], xs2: List[_])Int">compareLengths</a><span class="delimiter">(</span><a href="#262024" title="List[_]">xs1</a>.<span title="=&gt; List[Any]">tail</span>, <a href="#262025" title="List[_]">xs2</a>.<span title="=&gt; List[Any]">tail</span><span class="delimiter">)</span>
  
  <span class="comment">/** Again avoiding calling length, but the lengthCompare interface is clunky.
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(xs: List[_], len: Int)Boolean" id="67575">hasLength</a><span class="delimiter">(</span><a title="List[_]" id="453342">xs</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Int" id="453343">len</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#453342" title="List[_]">xs</a>.<span title="(len: Int)Int">lengthCompare</span><span class="delimiter">(</span><a href="#453343" title="Int">len</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span>
  
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.SubTypePair]" id="67576">pendingSubTypes</a> = <span title="()scala.collection.mutable.HashSet[Types.this.SubTypePair]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Types.this.SubTypePair]">HashSet</span><span class="delimiter">[</span>SubTypePair<span class="delimiter">]</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="67579">basetypeRecursions</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.Type]" id="67581">pendingBaseTypes</a> = <span title="()scala.collection.mutable.HashSet[Types.this.Type]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Types.this.Type]">HashSet</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67583">isSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="424656">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="424657">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#67584" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#424656" title="Types.this.Type">tp1</a>, <a href="#424657" title="Types.this.Type">tp2</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean" id="67584">isSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="424649">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="424650">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Int" id="424651">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="#67561" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>

    <a href="#67372" title="object Types.this.undoLog">undoLog</a> <a href="#106745" title="(block: =&gt; Boolean)Boolean">undoUnless</a> <span class="delimiter">{</span> <span class="comment">// if subtype test fails, it should not affect constraints on typevars</span>
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67561" title="=&gt; Int">subsametypeRecursions</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(50)">LogPendingSubTypesThreshold</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.SubTypePair" id="460279">p</a> = <span title="Types.this.SubTypePair" class="keyword">new</span> <a href="#67554" title="Types.this.SubTypePair">SubTypePair</a><span class="delimiter">(</span><a href="#424649" title="Types.this.Type">tp1</a>, <a href="#424650" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67576" title="(elem: Types.this.SubTypePair)Boolean">pendingSubTypes</a><span class="delimiter">(</span><a href="#460279" title="Types.this.SubTypePair">p</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">else</span> 
          <span class="keyword">try</span> <span class="delimiter">{</span>
            <a href="#67576" title="=&gt; scala.collection.mutable.HashSet[Types.this.SubTypePair]">pendingSubTypes</a> <span title="(elem: Types.this.SubTypePair)Types.this.pendingSubTypes.type">+=</span> <a href="#460279" title="Types.this.SubTypePair">p</a>
            <a href="#67601" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType2</a><span class="delimiter">(</span><a href="#424649" title="Types.this.Type">tp1</a>, <a href="#424650" title="Types.this.Type">tp2</a>, <a href="#424651" title="Int">depth</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            <a href="#67576" title="=&gt; scala.collection.mutable.HashSet[Types.this.SubTypePair]">pendingSubTypes</a> <span title="(elem: Types.this.SubTypePair)Types.this.pendingSubTypes.type">-=</span> <a href="#460279" title="Types.this.SubTypePair">p</a>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#67601" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType2</a><span class="delimiter">(</span><a href="#424649" title="Types.this.Type">tp1</a>, <a href="#424650" title="Types.this.Type">tp2</a>, <a href="#424651" title="Int">depth</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#67561" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
    <span class="comment">// XXX AM TODO: figure out when it is safe and needed to clear the log -- the commented approach below is too eager (it breaks #3281, #3866)</span>
    <span class="comment">// it doesn't help to keep separate recursion counts for the three methods that now share it</span>
    <span class="comment">// if (subsametypeRecursions == 0) undoLog.clear()</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Does this type have a prefix that begins with a type variable,
   *  or is it a refinement type? For type prefixes that fulfil this condition,
   *  type selections with the same name of equal (wrt) =:= prefixes are
   *  considered equal wrt =:=
   */</span>
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="67585">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a title="Types.this.Type" id="460030">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#460030" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="460324">pre</a>, <a title="Types.this.Symbol" id="460325">sym</a><span class="delimiter">)</span> =&gt;
      <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#460325" title="Types.this.Symbol">sym</a> <span title="(mask: Long)Boolean">hasFlag</span> <span title="Long(16384L)">PACKAGE</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67585" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#460324" title="Types.this.Type">pre</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="Boolean" id="460326">tv</a>@<a href="#448916" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="460328">constr</a><span class="delimiter">)</span> =&gt;
      <span title="=&gt; Boolean">!</span><a href="#460326" title="Types.this.TypeVar">tv</a>.<a href="#448940" title="=&gt; Boolean">instValid</a> <span title="(x: Boolean)Boolean">||</span> <a href="#67585" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#460328" title="Types.this.TypeConstraint">constr</a>.<a href="#449326" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Boolean(true)">RefinedType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; 
      <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
      <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="67586">instTypeVar</a><span class="delimiter">(</span><a title="Types.this.Type" id="460329">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#460329" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="460331">pre</a>, <a title="Types.this.Symbol" id="460332">sym</a>, <a title="List[Types.this.Type]" id="460333">args</a><span class="delimiter">)</span> =&gt;
      <a href="#67473" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#460329" title="Types.this.Type">tp</a>, <a href="#67586" title="(tp: Types.this.Type)Types.this.Type">instTypeVar</a><span class="delimiter">(</span><a href="#460331" title="Types.this.Type">pre</a><span class="delimiter">)</span>, <a href="#460332" title="Types.this.Symbol">sym</a>, <a href="#460333" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="460334">pre</a>, <a title="Types.this.Symbol" id="460335">sym</a><span class="delimiter">)</span> =&gt;
      <a href="#67468" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#67586" title="(tp: Types.this.Type)Types.this.Type">instTypeVar</a><span class="delimiter">(</span><a href="#460334" title="Types.this.Type">pre</a><span class="delimiter">)</span>, <a href="#460335" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a href="#448916" title="Types.this.Type">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="460337">constr</a><span class="delimiter">)</span> =&gt;
      <a href="#67586" title="(tp: Types.this.Type)Types.this.Type">instTypeVar</a><span class="delimiter">(</span><a href="#460337" title="Types.this.TypeConstraint">constr</a>.<a href="#449326" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <a href="#460329" title="Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="67587">isErrorOrWildcard</a><span class="delimiter">(</span><a title="Types.this.Type" id="460338">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#460338" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450783" title="object Types.this.ErrorType">ErrorType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#460338" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450801" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="67588">isSingleType</a><span class="delimiter">(</span><a title="Types.this.Type" id="460341">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#460341" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean(true)">ThisType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> | SuperType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> | SingleType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="67589">isConstantType</a><span class="delimiter">(</span><a title="Types.this.Type" id="402800">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#402800" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean(true)">ConstantType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>

  <span class="comment">// @assume tp1.isHigherKinded || tp2.isHigherKinded</span>
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean" id="67590">isHKSubType0</a><span class="delimiter">(</span><a title="Types.this.Type" id="460344">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460345">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Int" id="460346">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span>
    <a href="#460344" title="Types.this.Type">tp1</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a> 
    <span title="(x: Boolean)Boolean">||</span>
    <a href="#460345" title="Types.this.Type">tp2</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a> <span class="comment">// @M Any and Nothing are super-type resp. subtype of every well-kinded type</span>
    <span title="(x: Boolean)Boolean">||</span> <span class="comment">// @M! normalize reduces higher-kinded case to PolyType's</span>
    <span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#460344" title="Types.this.Type">tp1</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a>.<a href="#105403" title="=&gt; Types.this.Type">withoutAnnotations</a> , <a href="#460345" title="Types.this.Type">tp2</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a>.<a href="#105403" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460366">tparams1</a>, <a title="Types.this.Type" id="460367">res1</a><span class="delimiter">)</span>, PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460368">tparams2</a>, <a title="Types.this.Type" id="460369">res2</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span class="comment">// @assume tp1.isHigherKinded &amp;&amp; tp2.isHigherKinded (as they were both normalized to PolyType)</span>
        <a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#460366" title="List[Types.this.Symbol]">tparams1</a>, <a href="#460368" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460366" title="List[Types.this.Symbol]">tparams1</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>.<span title="=&gt; Boolean">isMethod</span><span class="delimiter">)</span> <span class="delimiter">{</span>  <span class="comment">// fast-path: polymorphic method type -- type params cannot be captured</span>
            <span class="delimiter">(</span><a href="#460366" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#460368" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="460390">p1</a>, <a title="Types.this.Symbol" id="460391">p2</a><span class="delimiter">)</span> =&gt; <a href="#460391" title="Types.this.Symbol">p2</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460368" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460366" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460390" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#460367" title="Types.this.Type">res1</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460369" title="Types.this.Type">res2</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460368" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460366" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span> <span class="comment">// normalized higher-kinded type</span>
            <span class="comment">//@M for an example of why we need to generate fresh symbols, see neg/tcpoly_ticket2101.scala</span>
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="460392">tpsFresh</a> = <a href="Symbols.scala.html#67330" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#460366" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>

            <span class="delimiter">(</span><a href="#460366" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#460368" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="460442">p1</a>, <a title="Types.this.Symbol" id="460443">p2</a><span class="delimiter">)</span> =&gt;
              <a href="#460443" title="Types.this.Symbol">p2</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460368" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460392" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460442" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460366" title="List[Types.this.Symbol]">tparams1</a>, <a href="#460392" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#460367" title="Types.this.Type">res1</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460366" title="List[Types.this.Symbol]">tparams1</a>, <a href="#460392" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460369" title="Types.this.Type">res2</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460368" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460392" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span>

            <span class="comment">//@M the forall in the previous test could be optimised to the following,</span>
            <span class="comment">// but not worth the extra complexity since it only shaves 1s from quick.comp</span>
            <span class="comment">//   (List.forall2(tpsFresh/*optimisation*/, tparams2)((p1, p2) =&gt;</span>
            <span class="comment">//   p2.info.substSym(tparams2, tpsFresh) &lt;:&lt; p1.info /*optimisation, == (p1 from tparams1).info.substSym(tparams1, tpsFresh)*/) &amp;&amp;</span>
            <span class="comment">// this optimisation holds because inlining cloneSymbols in `val tpsFresh = cloneSymbols(tparams1)` gives:</span>
            <span class="comment">// val tpsFresh = tparams1 map (_.cloneSymbol)</span>
            <span class="comment">// for (tpFresh &lt;- tpsFresh) tpFresh.setInfo(tpFresh.info.substSym(tparams1, tpsFresh))</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#67759" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#460344" title="Types.this.Type">tp1</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a>, <a href="#460345" title="Types.this.Type">tp2</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean(false)" class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <span title="Boolean(false)" class="keyword">false</span> <span class="comment">// @assume !tp1.isHigherKinded || !tp2.isHigherKinded </span>
      <span class="comment">// --&gt; thus, cannot be subtypes (Any/Nothing has already been checked)</span>
    <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** True if all three arguments have the same number of elements and
   *  the function is true for all the triples.
   */</span>
  @tailrec <span class="keyword">final</span> <span class="keyword">def</span> <a title="[A, B, C](xs1: List[A], xs2: List[B], xs3: List[C], f: (A, B, C) =&gt; Boolean)Boolean" id="67591">corresponds3</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67595">A</a>, <a title="&gt;: Nothing &lt;: Any" id="67596">B</a>, <a title="&gt;: Nothing &lt;: Any" id="67597">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[A]" id="460446">xs1</a>: <span title="List[A]">List</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="List[B]" id="460447">xs2</a>: <span title="List[B]">List</span><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a title="List[C]" id="460448">xs3</a>: <span title="List[C]">List</span><span class="delimiter">[</span>C<span class="delimiter">]</span>, <a title="(A, B, C) =&gt; Boolean" id="460449">f</a>: <span class="delimiter">(</span>A, B, C<span class="delimiter">)</span> =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460446" title="List[A]">xs1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#460447" title="List[B]">xs2</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460448" title="List[C]">xs3</a>.<span title="=&gt; Boolean">isEmpty</span>
    <span class="keyword">else</span> <span title="=&gt; Boolean">!</span><a href="#460447" title="List[B]">xs2</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#460448" title="List[C]">xs3</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460449" title="(v1: A, v2: B, v3: C)Boolean">f</a><span class="delimiter">(</span><a href="#460446" title="List[A]">xs1</a>.<span title="=&gt; A">head</span>, <a href="#460447" title="List[B]">xs2</a>.<span title="=&gt; B">head</span>, <a href="#460448" title="List[C]">xs3</a>.<span title="=&gt; C">head</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67591" title="(xs1: List[A], xs2: List[B], xs3: List[C], f: (A, B, C) =&gt; Boolean)Boolean">corresponds3</a><span class="delimiter">(</span><a href="#460446" title="List[A]">xs1</a>.<span title="=&gt; List[A]">tail</span>, <a href="#460447" title="List[B]">xs2</a>.<span title="=&gt; List[B]">tail</span>, <a href="#460448" title="List[C]">xs3</a>.<span title="=&gt; List[C]">tail</span>, <a href="#460449" title="(A, B, C) =&gt; Boolean">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">def</span> <a title="(t1: Types.this.Type, t2: Types.this.Type, variance: Int)Boolean" id="67598">isSubArg</a><span class="delimiter">(</span><a title="Types.this.Type" id="460508">t1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460509">t2</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Int" id="460510">variance</a>: <span title="Int">Int</span><span class="delimiter">)</span> =
    <span class="delimiter">(</span><a href="#460510" title="Int">variance</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#460509" title="Types.this.Type">t2</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460508" title="Types.this.Type">t1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#460510" title="Int">variance</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#460508" title="Types.this.Type">t1</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460509" title="Types.this.Type">t2</a><span class="delimiter">)</span>
    
  <span class="keyword">def</span> <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean" id="67599">isSubArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="455226">tps1</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="455227">tps2</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="455228">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#67591" title="(xs1: List[Types.this.Type], xs2: List[Types.this.Type], xs3: List[Int], f: (Types.this.Type, Types.this.Type, Int) =&gt; Boolean)Boolean">corresponds3</a><span class="delimiter">(</span><a href="#455226" title="List[Types.this.Type]">tps1</a>, <a href="#455227" title="List[Types.this.Type]">tps2</a>, <a href="#455228" title="List[Types.this.Symbol]">tparams</a> <span title="(f: Types.this.Symbol =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Int,List[Int]])List[Int]">map</span> <span class="delimiter">(</span><a href="#460555" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107399" title="=&gt; Int">variance</a><span class="delimiter">)</span>, <a href="#67598" title="(t1: Types.this.Type, t2: Types.this.Type, variance: Int)Boolean">isSubArg</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Types.this.Type" id="67600">differentOrNone</a><span class="delimiter">(</span><a title="Types.this.Type" id="460624">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460625">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#460624" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#460625" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <a href="#450850" title="object Types.this.NoType">NoType</a> <span class="keyword">else</span> <a href="#460624" title="Types.this.Type">tp1</a>

  <span class="comment">/** Does type `tp1' conform to `tp2'?
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean" id="67601">isSubType2</a><span class="delimiter">(</span><a title="Types.this.Type" id="460308">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460309">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Int" id="460310">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#460309" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#67587" title="(tp: Types.this.Type)Boolean">isErrorOrWildcard</a><span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#67587" title="(tp: Types.this.Type)Boolean">isErrorOrWildcard</a><span class="delimiter">(</span><a href="#460309" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(true)" class="keyword">true</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#460309" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(false)" class="keyword">false</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span><a href="#460309" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#460309" title="Types.this.Type">tp2</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isPackageClass</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#460309" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#450872" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#460308" title="Types.this.Type">tp1</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<span title="=&gt; Boolean">isPackageClass</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#67588" title="(tp: Types.this.Type)Boolean">isSingleType</a><span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67588" title="(tp: Types.this.Type)Boolean">isSingleType</a><span class="delimiter">(</span><a href="#460309" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#67589" title="(tp: Types.this.Type)Boolean">isConstantType</a><span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67589" title="(tp: Types.this.Type)Boolean">isConstantType</a><span class="delimiter">(</span><a href="#460309" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#460308" title="Types.this.Type">tp1</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460309" title="Types.this.Type">tp2</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a>.<a href="#105304" title="=&gt; Boolean">isHigherKinded</a> <span title="(x: Boolean)Boolean">||</span> <a href="#460309" title="Types.this.Type">tp2</a>.<a href="#105304" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#67590" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isHKSubType0</a><span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a>, <a href="#460309" title="Types.this.Type">tp2</a>, <a href="#460310" title="Int">depth</a><span class="delimiter">)</span>

    <span class="comment">/** First try, on the right:
     *   - unwrap Annotated types, BoundedWildcardTypes,
     *   - bind TypeVars  on the right, if lhs is not Annotated nor BoundedWildcard
     *   - handle common cases for first-kind TypeRefs on both sides as a fast path.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="460628">firstTry</a> = <span class="delimiter">{</span> <a href="../util/Statistics.scala.html#67151" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67286" title="=&gt; scala.tools.nsc.util.Statistics.Counter">ctr1</a><span class="delimiter">)</span>; <a href="#460309" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="comment">// fast path: two typerefs, none of them HK</span>
      <span class="keyword">case</span> <a title="Boolean" id="460635">tr2</a>: <a href="#133425" title="Types.this.TypeRef">TypeRef</a> =&gt;
        <a href="#460308" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="460636">tr1</a>: <a href="#133425" title="Types.this.TypeRef">TypeRef</a> =&gt;
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="460637">sym1</a> = <a href="#460636" title="Types.this.TypeRef">tr1</a>.<a href="#133454" title="=&gt; Types.this.Symbol">sym</a>
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="460638">sym2</a> = <a href="#460635" title="Types.this.TypeRef">tr2</a>.<a href="#133454" title="=&gt; Types.this.Symbol">sym</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="460639">pre1</a> = <a href="#460636" title="Types.this.TypeRef">tr1</a>.<a href="#133453" title="=&gt; Types.this.Type">pre</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="460640">pre2</a> = <a href="#460635" title="Types.this.TypeRef">tr2</a>.<a href="#133453" title="=&gt; Types.this.Type">pre</a>
            <span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460637" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#460638" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> <a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#460639" title="Types.this.Type">pre1</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460640" title="Types.this.Type">pre2</a>
               <span class="keyword">else</span> <span class="delimiter">(</span><a href="#460637" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#460638" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#460637" title="Types.this.Symbol">sym1</a>.<span title="=&gt; Boolean">isModuleClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#460638" title="Types.this.Symbol">sym2</a>.<span title="=&gt; Boolean">isModuleClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                     <span class="delimiter">(</span><a href="#67563" title="(pre1: Types.this.Type, pre2: Types.this.Type)Boolean">isUnifiable</a><span class="delimiter">(</span><a href="#460639" title="Types.this.Type">pre1</a>, <a href="#460640" title="Types.this.Type">pre2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#67564" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol, pre1: Types.this.Type, pre2: Types.this.Type)Boolean">isSameSpecializedSkolem</a><span class="delimiter">(</span><a href="#460637" title="Types.this.Symbol">sym1</a>, <a href="#460638" title="Types.this.Symbol">sym2</a>, <a href="#460639" title="Types.this.Type">pre1</a>, <a href="#460640" title="Types.this.Type">pre2</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                    <a href="#67599" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean">isSubArgs</a><span class="delimiter">(</span><a href="#460636" title="Types.this.TypeRef">tr1</a>.<a href="#133455" title="=&gt; List[Types.this.Type]">args</a>, <a href="#460635" title="Types.this.TypeRef">tr2</a>.<a href="#133455" title="=&gt; List[Types.this.Type]">args</a>, <a href="#460637" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span><span class="delimiter">)</span>
             <span title="(x: Boolean)Boolean">||</span>
             <a href="#460638" title="Types.this.Symbol">sym2</a>.<span title="=&gt; Boolean">isClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
               <span class="keyword">val</span> <a title="Types.this.Type" id="460650">base</a> = <a href="#460636" title="Types.this.TypeRef">tr1</a> <a href="#133417" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a> <a href="#460638" title="Types.this.Symbol">sym2</a>
               <span class="delimiter">(</span><a href="#460650" title="Types.this.Type">base</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#460636" title="Types.this.TypeRef">tr1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460650" title="Types.this.Type">base</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460635" title="Types.this.TypeRef">tr2</a>
             <span class="delimiter">}</span>
             <span title="(x: Boolean)Boolean">||</span>
             <a href="#460630" title="(tp1: Types.this.Type, tp2: Types.this.TypeRef)Boolean">thirdTryRef</a><span class="delimiter">(</span><a href="#460636" title="Types.this.TypeRef">tr1</a>, <a href="#460635" title="Types.this.TypeRef">tr2</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#460629" title="=&gt; Boolean">secondTry</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">AnnotatedType</span><span class="delimiter">(</span>_, _, _<span class="delimiter">)</span> =&gt;
        <a href="#460308" title="Types.this.Type">tp1</a>.<a href="#105403" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460309" title="Types.this.Type">tp2</a>.<a href="#105403" title="=&gt; Types.this.Type">withoutAnnotations</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#67759" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a>, <a href="#460309" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="460759">bounds</a><span class="delimiter">)</span> =&gt;
        <a href="#460308" title="Types.this.Type">tp1</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460759" title="Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a>
      <span class="keyword">case</span> <a title="Boolean" id="460760">tv2</a> @ <a href="#448916" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="460762">constr2</a><span class="delimiter">)</span> =&gt;
        <a href="#460308" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">AnnotatedType</span><span class="delimiter">(</span>_, _, _<span class="delimiter">)</span> | BoundedWildcardType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
            <a href="#460629" title="=&gt; Boolean">secondTry</a>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#460760" title="Types.this.TypeVar">tv2</a>.<a href="#448950" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#460629" title="=&gt; Boolean">secondTry</a>
    <span class="delimiter">}</span><span class="delimiter">}</span>

    <span class="comment">/** Second try, on the left:
     *   - unwrap AnnotatedTypes, BoundedWildcardTypes,
     *   - bind typevars,
     *   - handle existential types by skolemization.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="460629">secondTry</a> = <span class="delimiter">{</span> <a href="../util/Statistics.scala.html#67151" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67288" title="=&gt; scala.tools.nsc.util.Statistics.Counter">ctr2</a><span class="delimiter">)</span>; <a href="#460308" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">AnnotatedType</span><span class="delimiter">(</span>_, _, _<span class="delimiter">)</span> =&gt;
        <a href="#460308" title="Types.this.Type">tp1</a>.<a href="#105403" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460309" title="Types.this.Type">tp2</a>.<a href="#105403" title="=&gt; Types.this.Type">withoutAnnotations</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#67759" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a>, <a href="#460309" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="460655">bounds</a><span class="delimiter">)</span> =&gt;
        <a href="#460308" title="Types.this.Type">tp1</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148467" title="=&gt; Types.this.Type">lo</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460309" title="Types.this.Type">tp2</a>
      <span class="keyword">case</span> <a title="Boolean" id="460656">tv</a> @ <a href="#448916" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt;
        <a href="#460656" title="Types.this.TypeVar">tv</a>.<a href="#448950" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#460309" title="Types.this.Type">tp2</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
        <span class="keyword">try</span> <span class="delimiter">{</span> 
          <a href="#67370" title="(x$1: Int)Unit">skolemizationLevel</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
          <a href="#460308" title="Types.this.Type">tp1</a>.<a href="#105341" title="=&gt; Types.this.Type">skolemizeExistential</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460309" title="Types.this.Type">tp2</a>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
          <a href="#67370" title="(x$1: Int)Unit">skolemizationLevel</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#460631" title="=&gt; Boolean">thirdTry</a>
    <span class="delimiter">}</span><span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.TypeRef)Boolean" id="460630">thirdTryRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="460651">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.TypeRef" id="460652">tp2</a>: <a href="#133425" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span> 
      <a href="../util/Statistics.scala.html#67151" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67290" title="=&gt; scala.tools.nsc.util.Statistics.Counter">ctr3</a><span class="delimiter">)</span>; 
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="460763">sym2</a> = <a href="#460652" title="Types.this.TypeRef">tp2</a>.<a href="#133454" title="=&gt; Types.this.Symbol">sym</a>
      <a href="#460763" title="Types.this.Symbol">sym2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="Definitions.scala.html#106195" title="Boolean">NotNullClass</a> =&gt; <a href="#460651" title="Types.this.Type">tp1</a>.<a href="#105307" title="=&gt; Boolean">isNotNull</a>
        <span class="keyword">case</span> <a href="Definitions.scala.html#106203" title="Boolean">SingletonClass</a> =&gt; <a href="#460651" title="Types.this.Type">tp1</a>.<a href="#105305" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">||</span> <a href="#460632" title="=&gt; Boolean">fourthTry</a>
        <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="Symbols.scala.html#67326" title="Types.this.ClassSymbol">ClassSymbol</a> =&gt;
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67515" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><span class="delimiter">(</span><a href="#460763" title="Types.this.Symbol">sym2</a>, <a href="#460652" title="Types.this.TypeRef">tp2</a>.<a href="#133455" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#67584" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#460651" title="Types.this.Type">tp1</a>, <a href="#258513" title="(tp: Types.this.Type)Types.this.Type">rawToExistential</a><span class="delimiter">(</span><a href="#460652" title="Types.this.TypeRef">tp2</a><span class="delimiter">)</span>, <a href="#460310" title="Int">depth</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460763" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#67709" title="object Types.this.tpnme">tpnme</a>.<span title="=&gt; Types.this.tpnme.NameType">REFINE_CLASS_NAME</span><span class="delimiter">)</span>
            <a href="#67584" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#460651" title="Types.this.Type">tp1</a>, <a href="#460763" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>, <a href="#460310" title="Int">depth</a><span class="delimiter">)</span>
          <span class="keyword">else</span>
            <a href="#460632" title="=&gt; Boolean">fourthTry</a>
        <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="Symbols.scala.html#67324" title="Types.this.TypeSymbol">TypeSymbol</a> =&gt;
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460763" title="Types.this.Symbol">sym2</a> <span title="(mask: Long)Boolean">hasFlag</span> <span title="Long(16L)">DEFERRED</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="460779">tp2a</a> = <a href="#460652" title="Types.this.TypeRef">tp2</a>.<a href="#133398" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148467" title="=&gt; Types.this.Type">lo</a>
            <a href="#67568" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isDifferentTypeConstructor</a><span class="delimiter">(</span><a href="#460652" title="Types.this.TypeRef">tp2</a>, <a href="#460779" title="Types.this.Type">tp2a</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460651" title="Types.this.Type">tp1</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460779" title="Types.this.Type">tp2a</a> <span title="(x: Boolean)Boolean">||</span> <a href="#460632" title="=&gt; Boolean">fourthTry</a>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <a href="#67584" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#460651" title="Types.this.Type">tp1</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a>, <a href="#460652" title="Types.this.TypeRef">tp2</a>.<a href="#133415" title="=&gt; Types.this.Type">normalize</a>, <a href="#460310" title="Int">depth</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
          <a href="#460632" title="=&gt; Boolean">fourthTry</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    
    <span class="comment">/** Third try, on the right:
     *   - decompose refined types.
     *   - handle typerefs, existentials, and notnull types.
     *   - handle left+right method types, polytypes, typebounds
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="460631">thirdTry</a> = <span class="delimiter">{</span> <a href="../util/Statistics.scala.html#67151" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67290" title="=&gt; scala.tools.nsc.util.Statistics.Counter">ctr3</a><span class="delimiter">)</span>; <a href="#460309" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="460670">tr2</a>: <a href="#133425" title="Types.this.TypeRef">TypeRef</a> =&gt;
        <a href="#460630" title="(tp1: Types.this.Type, tp2: Types.this.TypeRef)Boolean">thirdTryRef</a><span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a>, <a href="#460670" title="Types.this.TypeRef">tr2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Boolean" id="460671">rt2</a>: <a href="#148512" title="Types.this.RefinedType">RefinedType</a> =&gt;
        <span class="delimiter">(</span><a href="#460671" title="Types.this.RefinedType">rt2</a>.<a href="#236305" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460678" title="Types.this.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <span class="delimiter">(</span><a href="#460671" title="Types.this.RefinedType">rt2</a>.<a href="#236306" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112957" title="=&gt; List[Types.this.Symbol]">toList</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <a href="#460308" title="Types.this.Type">tp1</a>.<a href="#105380" title="(sym: Types.this.Symbol)Boolean">specializes</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Boolean" id="460688">et2</a>: <a href="#149074" title="Types.this.ExistentialType">ExistentialType</a> =&gt;
        <a href="#460688" title="Types.this.ExistentialType">et2</a>.<a href="#149103" title="(op: Types.this.Type =&gt; Boolean, depth: Int)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460692" title="Types.this.Type">_</a>, <a href="#460310" title="Int">depth</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#460632" title="=&gt; Boolean">fourthTry</a>
      <span class="keyword">case</span> <a title="Boolean" id="460728">nn2</a>: <a href="#449751" title="Types.this.NotNullType">NotNullType</a> =&gt;
        <a href="#460308" title="Types.this.Type">tp1</a>.<a href="#105307" title="=&gt; Boolean">isNotNull</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460308" title="Types.this.Type">tp1</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460728" title="Types.this.NotNullType">nn2</a>.<a href="#449765" title="=&gt; Types.this.Type">underlying</a>
      <span class="keyword">case</span> <a title="Boolean" id="460729">mt2</a>: <a href="#148698" title="Types.this.MethodType">MethodType</a> =&gt;
        <a href="#460308" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="460730">mt1</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460731">params1</a>, <a title="Types.this.Type" id="460732">res1</a><span class="delimiter">)</span> =&gt;
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="460733">params2</a> = <a href="#460729" title="Types.this.MethodType">mt2</a>.<a href="#151831" title="=&gt; List[Types.this.Symbol]">params</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="460734">res2</a> = <a href="#460729" title="Types.this.MethodType">mt2</a>.<a href="#151832" title="=&gt; Types.this.Type">resultType</a>
            <span class="delimiter">(</span><a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#460731" title="List[Types.this.Symbol]">params1</a>, <a href="#460733" title="List[Types.this.Symbol]">params2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
             <a href="#67606" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span><a href="#460731" title="List[Types.this.Symbol]">params1</a>, <a href="#460733" title="List[Types.this.Symbol]">params2</a>, <a href="#460730" title="Types.this.MethodType">mt1</a>.<a href="#148710" title="=&gt; Boolean">isJava</a>, <a href="#460729" title="Types.this.MethodType">mt2</a>.<a href="#148710" title="=&gt; Boolean">isJava</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
             <span class="delimiter">(</span><a href="#460732" title="Types.this.Type">res1</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460734" title="Types.this.Type">res2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
             <a href="#460730" title="Types.this.MethodType">mt1</a>.<a href="#148709" title="=&gt; Boolean">isImplicit</a> <span title="(x: Boolean)Boolean">==</span> <a href="#460729" title="Types.this.MethodType">mt2</a>.<a href="#148709" title="=&gt; Boolean">isImplicit</a><span class="delimiter">)</span>
          <span class="comment">// TODO: if mt1.params.isEmpty, consider NullaryMethodType?</span>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Boolean" id="460749">pt2</a> @ NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
        <a href="#460308" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="comment">// TODO: consider MethodType mt for which mt.params.isEmpty??</span>
          <span class="keyword">case</span> <a title="Boolean" id="460750">pt1</a> @ NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
            <a href="#460750" title="Types.this.NullaryMethodType">pt1</a>.<a href="#423813" title="=&gt; Types.this.Type">resultType</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460749" title="Types.this.NullaryMethodType">pt2</a>.<a href="#423813" title="=&gt; Types.this.Type">resultType</a>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="460755">lo2</a>, <a title="Types.this.Type" id="460756">hi2</a><span class="delimiter">)</span> =&gt;
        <a href="#460308" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="460757">lo1</a>, <a title="Types.this.Type" id="460758">hi1</a><span class="delimiter">)</span> =&gt;
            <a href="#460755" title="Types.this.Type">lo2</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460757" title="Types.this.Type">lo1</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460758" title="Types.this.Type">hi1</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460756" title="Types.this.Type">hi2</a>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#460632" title="=&gt; Boolean">fourthTry</a>
    <span class="delimiter">}</span><span class="delimiter">}</span>

    <span class="comment">/** Fourth try, on the left:
     *   - handle typerefs, refined types, notnull and singleton types. 
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="460632">fourthTry</a> = <span class="delimiter">{</span> <a href="../util/Statistics.scala.html#67151" title="(c: scala.tools.nsc.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="../util/Statistics.scala.html#67292" title="=&gt; scala.tools.nsc.util.Statistics.Counter">ctr4</a><span class="delimiter">)</span>; <a href="#460308" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="460695">tr1</a> @ TypeRef<span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="460696">sym1</a>, _<span class="delimiter">)</span> =&gt;
        <a href="#460696" title="Types.this.Symbol">sym1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="Definitions.scala.html#106087" title="Boolean(true)">NothingClass</a> =&gt; <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <a href="Definitions.scala.html#106085" title="Boolean">NullClass</a> =&gt;
            <a href="#460309" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="460697">sym2</a>, _<span class="delimiter">)</span> =&gt;
                <a href="#460697" title="Types.this.Symbol">sym2</a>.<span title="=&gt; Boolean">isClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#460697" title="Types.this.Symbol">sym2</a> <a href="Symbols.scala.html#107447" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="Definitions.scala.html#106079" title="=&gt; Types.this.Symbol">ObjectClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#460309" title="Types.this.Type">tp2</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#107447" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="Definitions.scala.html#106195" title="=&gt; Types.this.Symbol">NotNullClass</a><span class="delimiter">)</span>
              <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
                <a href="#67588" title="(tp: Types.this.Type)Boolean">isSingleType</a><span class="delimiter">(</span><a href="#460309" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460308" title="Types.this.Type">tp1</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460309" title="Types.this.Type">tp2</a>.<a href="#105317" title="=&gt; Types.this.Type">widen</a>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="Symbols.scala.html#67326" title="Types.this.ClassSymbol">ClassSymbol</a> =&gt;
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#67515" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><span class="delimiter">(</span><a href="#460696" title="Types.this.Symbol">sym1</a>, <a href="#460695" title="Types.this.TypeRef">tr1</a>.<a href="#133455" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> 
              <a href="#67584" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#258513" title="(tp: Types.this.Type)Types.this.Type">rawToExistential</a><span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a><span class="delimiter">)</span>, <a href="#460309" title="Types.this.Type">tp2</a>, <a href="#460310" title="Int">depth</a><span class="delimiter">)</span>
            <span class="keyword">else</span> 
              <a href="#460696" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#67709" title="object Types.this.tpnme">tpnme</a>.<span title="=&gt; Types.this.tpnme.NameType">REFINE_CLASS_NAME</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <a href="#67584" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#460696" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>, <a href="#460309" title="Types.this.Type">tp2</a>, <a href="#460310" title="Int">depth</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="Symbols.scala.html#67324" title="Types.this.TypeSymbol">TypeSymbol</a> =&gt;
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460696" title="Types.this.Symbol">sym1</a> <span title="(mask: Long)Boolean">hasFlag</span> <span title="Long(16L)">DEFERRED</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="460715">tp1a</a> = <a href="#460308" title="Types.this.Type">tp1</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a>
              <a href="#67568" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isDifferentTypeConstructor</a><span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a>, <a href="#460715" title="Types.this.Type">tp1a</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460715" title="Types.this.Type">tp1a</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460309" title="Types.this.Type">tp2</a>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <a href="#67584" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#460308" title="Types.this.Type">tp1</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a>, <a href="#460309" title="Types.this.Type">tp2</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a>, <a href="#460310" title="Int">depth</a><span class="delimiter">)</span>
            <span class="delimiter">}</span> 
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="460720">parents1</a>, _<span class="delimiter">)</span> =&gt;
        <a href="#460720" title="List[Types.this.Type]">parents1</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#460727" title="Types.this.Type">_</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460309" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="#67387" title="Types.this.SingletonType">SingletonType</a> | _: <a href="#449751" title="Types.this.NotNullType">NotNullType</a> =&gt;
        <a href="#460308" title="Types.this.Type">tp1</a>.<a href="#105316" title="=&gt; Types.this.Type">underlying</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460309" title="Types.this.Type">tp2</a>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
        <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span><span class="delimiter">}</span>

    <a href="#460628" title="=&gt; Boolean">firstTry</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Are `tps1' and `tps2' lists of equal length such
   *  that all elements of `tps1' conform to corresponding elements
   *  of `tps2'?
   */</span>
  <span class="keyword">def</span> <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean" id="67602">isSubTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="460784">tps1</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="460785">tps2</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#460784" title="List[Types.this.Type]">tps1</a> <span title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.Type, Types.this.Type) =&gt; Boolean)Boolean">corresponds</span> <a href="#460785" title="List[Types.this.Type]">tps2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#460804" title="Types.this.Type">_</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460805" title="Types.this.Type">_</a><span class="delimiter">)</span>

  <span class="comment">/** Does type `tp' implement symbol `sym' with same or
   *  stronger type? Exact only if `sym' is a member of some
   *  refinement type, otherwise we might return false negatives.
   */</span>
  <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean" id="67603">specializesSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="450202">tp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="450203">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#450202" title="Types.this.Type">tp</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a> <span title="(x: Boolean)Boolean">||</span>
    <a href="#450202" title="Types.this.Type">tp</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106085" title="=&gt; Types.this.Symbol">NullClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#450203" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a> <a href="Symbols.scala.html#107448" title="(that: Types.this.Symbol)Boolean">isSubClass</a> <a href="Definitions.scala.html#106079" title="=&gt; Types.this.Symbol">ObjectClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
    <span class="delimiter">(</span><a href="#450202" title="Types.this.Type">tp</a>.<a href="#105355" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#450203" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107450" title="=&gt; List[Types.this.Symbol]">alternatives</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span>
      <span class="delimiter">(</span><a title="Types.this.Symbol" id="460824">alt</a> =&gt; <a href="#450203" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#460824" title="Types.this.Symbol">alt</a> <span title="(x: Boolean)Boolean">||</span> <a href="#67604" title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#450202" title="Types.this.Type">tp</a>.<a href="#105320" title="=&gt; Types.this.Type">narrow</a>, <a href="#460824" title="Types.this.Symbol">alt</a>, <a href="#450203" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#107459" title="=&gt; Types.this.Type">thisType</a>, <a href="#450203" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Does member `sym1' of `tp1' have a stronger type
   *  than member `sym2' of `tp2'?
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean" id="67604">specializesSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="450197">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="450198">sym1</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="450199">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="450200">sym2</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Types.this.Type" id="460833">info1</a> = <a href="#450197" title="Types.this.Type">tp1</a>.<a href="#105360" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#450198" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Types.this.Type" id="460834">info2</a> = <a href="#450199" title="Types.this.Type">tp2</a>.<a href="#105360" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#450200" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>.<a href="#105365" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#450199" title="Types.this.Type">tp2</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#450197" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
    <span class="comment">//System.out.println(&quot;specializes &quot;+tp1+&quot;.&quot;+sym1+&quot;:&quot;+info1+sym1.locationString+&quot; AND &quot;+tp2+&quot;.&quot;+sym2+&quot;:&quot;+info2)//DEBUG</span>
    <a href="#450200" title="Types.this.Symbol">sym2</a>.<span title="=&gt; Boolean">isTerm</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#460833" title="Types.this.Type">info1</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#460834" title="Types.this.Type">info2</a><span class="delimiter">)</span> <span class="comment">/*&amp;&amp; (!sym2.isStable || sym1.isStable) */</span> <span title="(x: Boolean)Boolean">||</span>
    <a href="#450200" title="Types.this.Symbol">sym2</a>.<span title="=&gt; Boolean">isAbstractType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="460835">memberTp1</a> = <a href="#450197" title="Types.this.Type">tp1</a>.<a href="#105361" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#450198" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      <span class="comment">// println(&quot;kinds conform? &quot;+(memberTp1, tp1, sym2, kindsConform(List(sym2), List(memberTp1), tp2, sym2.owner)))</span>
      <a href="#460834" title="Types.this.Type">info2</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148449" title="(that: Types.this.Type)Boolean">containsType</a><span class="delimiter">(</span><a href="#460835" title="Types.this.Type">memberTp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
      <a href="#67656" title="(tparams: List[Types.this.Symbol], targs: List[Types.this.Type], pre: Types.this.Type, owner: Types.this.Symbol)Boolean">kindsConform</a><span class="delimiter">(</span><span title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</span><span class="delimiter">(</span><a href="#450200" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>, <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#460835" title="Types.this.Type">memberTp1</a><span class="delimiter">)</span>, <a href="#450197" title="Types.this.Type">tp1</a>, <a href="#450198" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span> 
    <span class="delimiter">}</span> <span title="(x: Boolean)Boolean">||</span>
    <a href="#450200" title="Types.this.Symbol">sym2</a>.<span title="=&gt; Boolean">isAliasType</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#450199" title="Types.this.Type">tp2</a>.<a href="#105361" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#450200" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>.<a href="#105365" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#450199" title="Types.this.Type">tp2</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#450197" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#450197" title="Types.this.Type">tp1</a>.<a href="#105361" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#450198" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> <span class="comment">//@MAT ok</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A function implementing `tp1' matches `tp2' */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean" id="67605">matchesType</a><span class="delimiter">(</span><a title="Types.this.Type" id="313918">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="313919">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Boolean" id="313920">alwaysMatchSimple</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean" id="460855">matchesQuantified</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460857">tparams1</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="460858">tparams2</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="460859">res1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="460860">res2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span>
      <a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#460857" title="List[Types.this.Symbol]">tparams1</a>, <a href="#460858" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
      <a href="#67605" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#460859" title="Types.this.Type">res1</a>, <a href="#460860" title="Types.this.Type">res2</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#460858" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460857" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>, <a href="#313920" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="460856">lastTry</a> = 
      <a href="#313919" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="460863">res2</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#313920" title="Boolean">alwaysMatchSimple</a> =&gt;
          <a href="#67605" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#313918" title="Types.this.Type">tp1</a>, <a href="#460863" title="Types.this.Type">res2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Boolean(false)">MethodType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
          <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">case</span> <span title="Boolean">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460864">tparams2</a>, <a title="Types.this.Type" id="460865">res2</a><span class="delimiter">)</span> =&gt;
          <a href="#460864" title="List[Types.this.Symbol]">tparams2</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67605" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#313918" title="Types.this.Type">tp1</a>, <a href="#460865" title="Types.this.Type">res2</a>, <a href="#313920" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
          <a href="#313920" title="Boolean">alwaysMatchSimple</a> <span title="(x: Boolean)Boolean">||</span> <a href="#313918" title="Types.this.Type">tp1</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#313919" title="Types.this.Type">tp2</a>
      <span class="delimiter">}</span>
    <a href="#313918" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="460866">mt1</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460867">params1</a>, <a title="Types.this.Type" id="460868">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#313919" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="460869">mt2</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460870">params2</a>, <a title="Types.this.Type" id="460871">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#460867" title="List[Types.this.Symbol]">params1</a>, <a href="#460870" title="List[Types.this.Symbol]">params2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="comment">// useful pre-screening optimization</span>
            <a href="#67606" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span><a href="#460867" title="List[Types.this.Symbol]">params1</a>, <a href="#460870" title="List[Types.this.Symbol]">params2</a>, <a href="#460866" title="Types.this.MethodType">mt1</a>.<a href="#148710" title="=&gt; Boolean">isJava</a>, <a href="#460869" title="Types.this.MethodType">mt2</a>.<a href="#148710" title="=&gt; Boolean">isJava</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> 
            <a href="#67605" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#460868" title="Types.this.Type">res1</a>, <a href="#460871" title="Types.this.Type">res2</a>, <a href="#313920" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#460866" title="Types.this.MethodType">mt1</a>.<a href="#148709" title="=&gt; Boolean">isImplicit</a> <span title="(x: Boolean)Boolean">==</span> <a href="#460869" title="Types.this.MethodType">mt2</a>.<a href="#148709" title="=&gt; Boolean">isImplicit</a>
          <span class="keyword">case</span> <span title="Boolean">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="460879">res2</a><span class="delimiter">)</span> =&gt; 
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#460867" title="List[Types.this.Symbol]">params1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#67605" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#460868" title="Types.this.Type">res1</a>, <a href="#460879" title="Types.this.Type">res2</a>, <a href="#313920" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#67605" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#313918" title="Types.this.Type">tp1</a>, <a href="#460879" title="Types.this.Type">res2</a>, <a href="#313920" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="460880">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#313920" title="Boolean">alwaysMatchSimple</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67605" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#313918" title="Types.this.Type">tp1</a>, <a href="#460880" title="Types.this.Type">res2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Boolean" id="460881">mt1</a> @ NullaryMethodType<span class="delimiter">(</span><a title="Types.this.Type" id="460882">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#313919" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="460883">mt2</a> @ MethodType<span class="delimiter">(</span><span title="object Nil">Nil</span>, <a title="Types.this.Type" id="460884">res2</a><span class="delimiter">)</span>  =&gt; <span class="comment">// could never match if params nonEmpty, and !mt2.isImplicit is implied by empty param list</span>
            <a href="#67605" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#460882" title="Types.this.Type">res1</a>, <a href="#460884" title="Types.this.Type">res2</a>, <a href="#313920" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="460885">res2</a><span class="delimiter">)</span> =&gt; 
            <a href="#67605" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#460882" title="Types.this.Type">res1</a>, <a href="#460885" title="Types.this.Type">res2</a>, <a href="#313920" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="460886">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#313920" title="Boolean">alwaysMatchSimple</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67605" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#313918" title="Types.this.Type">tp1</a>, <a href="#460886" title="Types.this.Type">res2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#67605" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#460882" title="Types.this.Type">res1</a>, <a href="#313919" title="Types.this.Type">tp2</a>, <a href="#313920" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460887">tparams1</a>, <a title="Types.this.Type" id="460888">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#313919" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460889">tparams2</a>, <a title="Types.this.Type" id="460890">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#460855" title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean">matchesQuantified</a><span class="delimiter">(</span><a href="#460887" title="List[Types.this.Symbol]">tparams1</a>, <a href="#460889" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460888" title="Types.this.Type">res1</a>, <a href="#460890" title="Types.this.Type">res2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="460891">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#313920" title="Boolean">alwaysMatchSimple</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#67605" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#313918" title="Types.this.Type">tp1</a>, <a href="#460891" title="Types.this.Type">res2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span> <span class="comment">// remember that tparams1.nonEmpty is now an invariant of PolyType</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460892">tparams1</a>, <a title="Types.this.Type" id="460893">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#313919" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460894">tparams2</a>, <a title="Types.this.Type" id="460895">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#460855" title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean">matchesQuantified</a><span class="delimiter">(</span><a href="#460892" title="List[Types.this.Symbol]">tparams1</a>, <a href="#460894" title="List[Types.this.Symbol]">tparams2</a>, <a href="#460893" title="Types.this.Type">res1</a>, <a href="#460895" title="Types.this.Type">res2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#313920" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span> <a href="#67605" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#460893" title="Types.this.Type">res1</a>, <a href="#313919" title="Types.this.Type">tp2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#460856" title="=&gt; Boolean">lastTry</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#460856" title="=&gt; Boolean">lastTry</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="comment">/** matchesType above is an optimized version of the following implementation:

  def matchesType2(tp1: Type, tp2: Type, alwaysMatchSimple: Boolean): Boolean = {
    def matchesQuantified(tparams1: List[Symbol], tparams2: List[Symbol], res1: Type, res2: Type): Boolean = 
      tparams1.length == tparams2.length &amp;&amp;
      matchesType(res1, res2.substSym(tparams2, tparams1), alwaysMatchSimple)
    (tp1, tp2) match {
      case (MethodType(params1, res1), MethodType(params2, res2)) =&gt;
        params1.length == params2.length &amp;&amp; // useful pre-secreening optimization 
        matchingParams(params1, params2, tp1.isInstanceOf[JavaMethodType], tp2.isInstanceOf[JavaMethodType]) &amp;&amp; 
        matchesType(res1, res2, alwaysMatchSimple) &amp;&amp;
        tp1.isImplicit == tp2.isImplicit
      case (PolyType(tparams1, res1), PolyType(tparams2, res2)) =&gt;
        matchesQuantified(tparams1, tparams2, res1, res2)
      case (NullaryMethodType(rtp1), MethodType(List(), rtp2)) =&gt; 
        matchesType(rtp1, rtp2, alwaysMatchSimple)
      case (MethodType(List(), rtp1), NullaryMethodType(rtp2)) =&gt; 
        matchesType(rtp1, rtp2, alwaysMatchSimple)
      case (ExistentialType(tparams1, res1), ExistentialType(tparams2, res2)) =&gt;
        matchesQuantified(tparams1, tparams2, res1, res2)
      case (ExistentialType(_, res1), _) if alwaysMatchSimple =&gt;
        matchesType(res1, tp2, alwaysMatchSimple)
      case (_, ExistentialType(_, res2)) if alwaysMatchSimple =&gt;
        matchesType(tp1, res2, alwaysMatchSimple)
      case (NullaryMethodType(rtp1), _) =&gt; 
        matchesType(rtp1, tp2, alwaysMatchSimple)
      case (_, NullaryMethodType(rtp2)) =&gt; 
        matchesType(tp1, rtp2, alwaysMatchSimple)
      case (MethodType(_, _), _) =&gt; false
      case (PolyType(_, _), _)   =&gt; false
      case (_, MethodType(_, _)) =&gt; false
      case (_, PolyType(_, _))   =&gt; false
      case _ =&gt;
        alwaysMatchSimple || tp1 =:= tp2
    }
  }
*/</span>

  <span class="comment">/** Are `syms1' and `syms2' parameter lists with pairwise equivalent types? */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean" id="67606">matchingParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460739">syms1</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="460740">syms2</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Boolean" id="460741">syms1isJava</a>: <span title="Boolean">Boolean</span>, <a title="Boolean" id="460742">syms2isJava</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#460739" title="List[Types.this.Symbol]">syms1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean">Nil</span> =&gt;
      <a href="#460740" title="List[Types.this.Symbol]">syms2</a>.<span title="=&gt; Boolean">isEmpty</span>
    <span class="keyword">case</span> <a title="Boolean" id="460900">sym1</a> :: <a title="List[Types.this.Symbol]" id="460901">rest1</a> =&gt;
      <a href="#460740" title="List[Types.this.Symbol]">syms2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Boolean(false)">Nil</span> =&gt;
          <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">case</span> <a title="Boolean" id="460906">sym2</a> :: <a title="List[Types.this.Symbol]" id="460907">rest2</a> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="460908">tp1</a> = <a href="#460900" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
          <span class="keyword">val</span> <a title="Types.this.Type" id="460909">tp2</a> = <a href="#460906" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
          <span class="delimiter">(</span><a href="#460908" title="Types.this.Type">tp1</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#460909" title="Types.this.Type">tp2</a> <span title="(x: Boolean)Boolean">||</span> 
           <a href="#460741" title="Boolean">syms1isJava</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460909" title="Types.this.Type">tp2</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106079" title="=&gt; Types.this.Symbol">ObjectClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460908" title="Types.this.Type">tp1</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a> <span title="(x: Boolean)Boolean">||</span>
           <a href="#460742" title="Boolean">syms2isJava</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460908" title="Types.this.Type">tp1</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106079" title="=&gt; Types.this.Symbol">ObjectClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#460909" title="Types.this.Type">tp2</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
          <a href="#67606" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span><a href="#460901" title="List[Types.this.Symbol]">rest1</a>, <a href="#460907" title="List[Types.this.Symbol]">rest2</a>, <a href="#460741" title="Boolean">syms1isJava</a>, <a href="#460742" title="Boolean">syms2isJava</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** like map2, but returns list `xs' itself - instead of a copy - if function
   *  `f' maps all elements to themselves.
   */</span>
  <span class="keyword">def</span> <a title="[A &lt;: AnyRef, B](xs: List[A], ys: List[B])(f: (A, B) =&gt; A)List[A]" id="67607">map2Conserve</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef" id="67610">A</a> &lt;: AnyRef, <a title="&gt;: Nothing &lt;: Any" id="67611">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[A]" id="456766">xs</a>: <span title="List[A]">List</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="List[B]" id="456767">ys</a>: <span title="List[B]">List</span><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; A" id="456768">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span>: <span title="List[A]">List</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = 
    <span title="List[A]" class="keyword">if</span> <span class="delimiter">(</span><a href="#456766" title="List[A]">xs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#456766" title="List[A]">xs</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="A" id="460930">x1</a> = <a href="#456768" title="(v1: A, v2: B)A">f</a><span class="delimiter">(</span><a href="#456766" title="List[A]">xs</a>.<span title="=&gt; A">head</span>, <a href="#456767" title="List[B]">ys</a>.<span title="=&gt; B">head</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[A]" id="460931">xs1</a> = <a href="#67607" title="(xs: List[A], ys: List[B])(f: (A, B) =&gt; A)List[A]">map2Conserve</a><span class="delimiter">(</span><a href="#456766" title="List[A]">xs</a>.<span title="=&gt; List[A]">tail</span>, <a href="#456767" title="List[B]">ys</a>.<span title="=&gt; List[B]">tail</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#456768" title="(A, B) =&gt; A">f</a><span class="delimiter">)</span>
      <span title="List[A]" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#460930" title="A">x1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456766" title="List[A]">xs</a>.<span title="=&gt; A">head</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#460931" title="List[A]">xs1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#456766" title="List[A]">xs</a>.<span title="=&gt; List[A]">tail</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#456766" title="List[A]">xs</a>
      <span class="keyword">else</span> <a href="#460930" title="A">x1</a> <a href="#460970" title="(x: A)List[A]">::</a> <a href="#460931" title="List[A]">xs1</a>
    <span class="delimiter">}</span>    

  <span class="comment">/** Solve constraint collected in types `tvars'.
   *
   *  @param tvars      All type variables to be instantiated.
   *  @param tparams    The type parameters corresponding to `tvars'
   *  @param variances  The variances of type parameters; need to reverse
   *                    solution direction for all contravariant variables.
   *  @param upper      When `true' search for max solution else min.
   */</span>
  <span class="keyword">def</span> <a title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean)Boolean" id="67612">solve</a><span class="delimiter">(</span><a title="List[Types.this.TypeVar]" id="454830">tvars</a>: <span title="List[Types.this.TypeVar]">List</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="454831">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
            <a title="List[Int]" id="454832">variances</a>: <span title="List[Int]">List</span><span class="delimiter">[</span>Int<span class="delimiter">]</span>, <a title="Boolean" id="454833">upper</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
     <a href="#67613" title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean, depth: Int)Boolean">solve</a><span class="delimiter">(</span><a href="#454830" title="List[Types.this.TypeVar]">tvars</a>, <a href="#454831" title="List[Types.this.Symbol]">tparams</a>, <a href="#454832" title="List[Int]">variances</a>, <a href="#454833" title="Boolean">upper</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean, depth: Int)Boolean" id="67613">solve</a><span class="delimiter">(</span><a title="List[Types.this.TypeVar]" id="454824">tvars</a>: <span title="List[Types.this.TypeVar]">List</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="454825">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
            <a title="List[Int]" id="454826">variances</a>: <span title="List[Int]">List</span><span class="delimiter">[</span>Int<span class="delimiter">]</span>, <a title="Boolean" id="454827">upper</a>: <span title="Boolean">Boolean</span>, <a title="Int" id="454828">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="List[(Types.this.TypeVar, (Types.this.Symbol, Int))]" id="460980">config</a> = <a href="#454824" title="List[Types.this.TypeVar]">tvars</a> <span title="(that: scala.collection.GenIterable[(Types.this.Symbol, Int)])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeVar],(Types.this.TypeVar, (Types.this.Symbol, Int)),List[(Types.this.TypeVar, (Types.this.Symbol, Int))]])List[(Types.this.TypeVar, (Types.this.Symbol, Int))]">zip</span> <span class="delimiter">(</span><a href="#454825" title="List[Types.this.Symbol]">tparams</a> <span title="(that: scala.collection.GenIterable[Int])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],(Types.this.Symbol, Int),List[(Types.this.Symbol, Int)]])List[(Types.this.Symbol, Int)]">zip</span> <a href="#454826" title="List[Int]">variances</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="(tvar: Types.this.TypeVar, tparam: Types.this.Symbol, variance: Int)Unit" id="460981">solveOne</a><span class="delimiter">(</span><a title="Types.this.TypeVar" id="461082">tvar</a>: <a href="#67458" title="Types.this.TypeVar">TypeVar</a>, <a title="Types.this.Symbol" id="461083">tparam</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Int" id="461084">variance</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#461082" title="Types.this.TypeVar">tvar</a>.<a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449326" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Boolean" id="461090">up</a> = <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#461084" title="Int">variance</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(131072)">CONTRAVARIANT</span><span class="delimiter">)</span> <a href="#454827" title="Boolean">upper</a> <span class="keyword">else</span> <span title="=&gt; Boolean">!</span><a href="#454827" title="Boolean">upper</a>
        <a href="#461082" title="Types.this.TypeVar">tvar</a>.<a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449326" title="(x$1: Types.this.Type)Unit">inst</a> = <span title="Null(null)" class="keyword">null</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="461091">bound</a>: <a href="#67381" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461090" title="Boolean">up</a><span class="delimiter">)</span> <a href="#461083" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a> <span class="keyword">else</span> <a href="#461083" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148467" title="=&gt; Types.this.Type">lo</a>
        <span class="comment">//Console.println(&quot;solveOne0(tv, tp, v, b)=&quot;+(tvar, tparam, variance, bound))</span>
        <span class="keyword">var</span> <a title="Boolean" id="461092">cyclic</a> = <a href="#461091" title="Types.this.Type">bound</a> <a href="#105372" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#461083" title="Types.this.Symbol">tparam</a>
        <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.TypeVar" id="461136">tvar2</a>, <span class="delimiter">(</span><a title="Types.this.Symbol" id="461139">tparam2</a>, <a title="Int" id="461140">variance2</a><span class="delimiter">)</span><span class="delimiter">)</span> &lt;- <a href="#460980" title="(f: (Types.this.TypeVar, (Types.this.Symbol, Int)) =&gt; Unit)Unit">config</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#461139" title="Types.this.Symbol">tparam2</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#461083" title="Types.this.Symbol">tparam</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <span class="delimiter">(</span><span class="delimiter">(</span><a href="#461091" title="Types.this.Type">bound</a> <a href="#105372" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#461139" title="Types.this.Symbol">tparam2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
               <a href="#461090" title="Boolean">up</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#461139" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148467" title="=&gt; Types.this.Type">lo</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#461083" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
               <span title="=&gt; Boolean">!</span><a href="#461090" title="Boolean">up</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#461139" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#461083" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#461136" title="Types.this.TypeVar">tvar2</a>.<a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449326" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#461092" title="Boolean">cyclic</a> = <span title="Boolean(true)" class="keyword">true</span>
            <a href="#460981" title="(tvar: Types.this.TypeVar, tparam: Types.this.Symbol, variance: Int)Unit">solveOne</a><span class="delimiter">(</span><a href="#461136" title="Types.this.TypeVar">tvar2</a>, <a href="#461139" title="Types.this.Symbol">tparam2</a>, <a href="#461140" title="Int">variance2</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#461092" title="Boolean">cyclic</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#461090" title="Boolean">up</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#461091" title="Types.this.Type">bound</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span>
              <a href="#461082" title="Types.this.TypeVar">tvar</a> <a href="#448946" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a> <a href="#461091" title="Types.this.Type">bound</a>.<a href="#105339" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#454825" title="List[Types.this.Symbol]">tparams</a>, <a href="#454824" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
            <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="461170">tparam2</a> &lt;- <a href="#454825" title="(f: Types.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span>
              <a href="#461170" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148467" title="=&gt; Types.this.Type">lo</a>.<a href="#105343" title="=&gt; Types.this.Type">dealias</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a href="#461083" title="Types.this.Symbol">`tparam`</a>, _<span class="delimiter">)</span> =&gt;
                  <a href="#461082" title="Types.this.TypeVar">tvar</a> <a href="#448946" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a> <a href="#461170" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>.<a href="#105339" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#454825" title="List[Types.this.Symbol]">tparams</a>, <a href="#454824" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
                <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
              <span class="delimiter">}</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#461091" title="Types.this.Type">bound</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#461091" title="Types.this.Type">bound</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#461083" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#461082" title="Types.this.TypeVar">tvar</a> <a href="#448945" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a> <a href="#461091" title="Types.this.Type">bound</a>.<a href="#105339" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#454825" title="List[Types.this.Symbol]">tparams</a>, <a href="#454824" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="461193">tparam2</a> &lt;- <a href="#454825" title="(f: Types.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span>
              <a href="#461193" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a>.<a href="#105343" title="=&gt; Types.this.Type">dealias</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a href="#461083" title="Types.this.Symbol">`tparam`</a>, _<span class="delimiter">)</span> =&gt; 
                  <a href="#461082" title="Types.this.TypeVar">tvar</a> <a href="#448945" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a> <a href="#461193" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>.<a href="#105339" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#454825" title="List[Types.this.Symbol]">tparams</a>, <a href="#454824" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
                <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
              <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <a href="#461082" title="Types.this.TypeVar">tvar</a>.<a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449326" title="(x$1: Types.this.Type)Unit">inst</a> = <a href="#450850" title="object Types.this.NoType">NoType</a> <span class="comment">// necessary because hibounds/lobounds may contain tvar</span>

        <span class="comment">//println(&quot;solving &quot;+tvar+&quot; &quot;+up+&quot; &quot;+(if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds)+((if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds) map (_.widen)))</span>

        <a href="#461082" title="Types.this.TypeVar">tvar</a> <a href="#448944" title="(tp: Types.this.Type)Unit">setInst</a> <span class="delimiter">(</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461090" title="Boolean">up</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#454828" title="Int">depth</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span> <a href="#67648" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#461082" title="Types.this.TypeVar">tvar</a>.<a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449321" title="=&gt; List[Types.this.Type]">hiBounds</a>, <a href="#454828" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#67647" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#461082" title="Types.this.TypeVar">tvar</a>.<a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449321" title="=&gt; List[Types.this.Type]">hiBounds</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#454828" title="Int">depth</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span> <a href="#67639" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#461082" title="Types.this.TypeVar">tvar</a>.<a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449320" title="=&gt; List[Types.this.Type]">loBounds</a>, <a href="#454828" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#67638" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#461082" title="Types.this.TypeVar">tvar</a>.<a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449320" title="=&gt; List[Types.this.Type]">loBounds</a><span class="delimiter">)</span>
          <span class="delimiter">}</span><span class="delimiter">)</span>

        <span class="comment">//Console.println(&quot;solving &quot;+tvar+&quot; &quot;+up+&quot; &quot;+(if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds)+((if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds) map (_.widen))+&quot; = &quot;+tvar.constr.inst)//@MDEBUG</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>    
    
    <span class="comment">// println(&quot;solving &quot;+tvars+&quot;/&quot;+tparams+&quot;/&quot;+(tparams map (_.info)))</span>
    <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.TypeVar" id="461255">tvar</a>, <span class="delimiter">(</span><a title="Types.this.Symbol" id="461258">tparam</a>, <a title="Int" id="461259">variance</a><span class="delimiter">)</span><span class="delimiter">)</span> &lt;- <a href="#460980" title="(f: (Types.this.TypeVar, (Types.this.Symbol, Int)) =&gt; Unit)Unit">config</a><span class="delimiter">)</span>
      <a href="#460981" title="(tvar: Types.this.TypeVar, tparam: Types.this.Symbol, variance: Int)Unit">solveOne</a><span class="delimiter">(</span><a href="#461255" title="Types.this.TypeVar">tvar</a>, <a href="#461258" title="Types.this.Symbol">tparam</a>, <a href="#461259" title="Int">variance</a><span class="delimiter">)</span>

    <a href="#454824" title="List[Types.this.TypeVar]">tvars</a> <span title="(p: Types.this.TypeVar =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.TypeVar" id="461267">tvar</a> =&gt; <a href="#461267" title="Types.this.TypeVar">tvar</a>.<a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449324" title="(tp: Types.this.Type)Boolean">isWithinBounds</a><span class="delimiter">(</span><a href="#461267" title="Types.this.TypeVar">tvar</a>.<a href="#448938" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#449326" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Do type arguments `targs' conform to formal parameters
   *  `tparams'?
   *
   *  @param tparams ...
   *  @param targs   ...
   *  @return        ...
   */</span>
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])Boolean" id="67614">isWithinBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="454884">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="454885">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="454886">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="454887">targs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="List[Types.this.TypeBounds]" id="461268">bounds</a> = <a href="#67615" title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]">instantiatedBounds</a><span class="delimiter">(</span><a href="#454884" title="Types.this.Type">pre</a>, <a href="#454885" title="Types.this.Symbol">owner</a>, <a href="#454886" title="List[Types.this.Symbol]">tparams</a>, <a href="#454887" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#454887" title="List[Types.this.Type]">targs</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#461280" title="Types.this.Type">_</a>.<a href="#105399" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#461268" title="List[Types.this.TypeBounds]">bounds</a> = <a href="AnnotationCheckers.scala.html#67762" title="(bounds: List[Types.this.TypeBounds], tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]">adaptBoundsToAnnotations</a><span class="delimiter">(</span><a href="#461268" title="List[Types.this.TypeBounds]">bounds</a>, <a href="#454886" title="List[Types.this.Symbol]">tparams</a>, <a href="#454887" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>
    <span class="delimiter">(</span><a href="#461268" title="List[Types.this.TypeBounds]">bounds</a> <span title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.TypeBounds, Types.this.Type) =&gt; Boolean)Boolean">corresponds</span> <a href="#454887" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#461308" title="Types.this.TypeBounds">_</a> <a href="#148449" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#461309" title="Types.this.Type">_</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]" id="67615">instantiatedBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="461269">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="461270">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="461271">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="461272">targs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.TypeBounds]">List</span><span class="delimiter">[</span>TypeBounds<span class="delimiter">]</span> = 
    <a href="#461271" title="List[Types.this.Symbol]">tparams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.TypeBounds)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.TypeBounds,List[Types.this.TypeBounds]])List[Types.this.TypeBounds]">map</span> <span class="delimiter">(</span><a href="#461337" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105359" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#461269" title="Types.this.Type">pre</a>, <a href="#461270" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>.<a href="#105339" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#461271" title="List[Types.this.Symbol]">tparams</a>, <a href="#461272" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>

<span class="comment">// Lubs and Glbs ---------------------------------------------------------</span>

  <span class="comment">/** Given a matrix `tsBts` whose columns are basetype sequences (and the symbols `tsParams` that should be interpreted as type parameters in this matrix),
   * compute its least sorted upwards closed upper bound relative to the following ordering &lt;= between lists of types:
   *
   *    xs &lt;= ys   iff   forall y in ys exists x in xs such that x &lt;: y
   *
   *
   *  @arg tsParams for each type in the original list of types `ts0`, its list of type parameters (if that type is a type constructor)
   *                (these type parameters may be referred to by type arguments in the BTS column of those types,
   *                and must be interpreted as bound variables; i.e., under a type lambda that wraps the types that refer to these type params)
   *  @arg tsBts    a matrix whose columns are basetype sequences
   *                the first row is the original list of types for which we're computing the lub 
   *                  (except that type constructors have been applied to their dummyArgs)
   *  @See baseTypeSeq  for a definition of sorted and upwards closed.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tsParams: List[List[Types.this.Symbol]], tsBts: List[List[Types.this.Type]], depth: Int)List[Types.this.Type]" id="67616">lubList</a><span class="delimiter">(</span><a title="List[List[Types.this.Symbol]]" id="461365">tsParams</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="List[List[Types.this.Type]]" id="461366">tsBts</a>: <span title="List[List[Types.this.Type]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Int" id="461367">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="comment">// strip typerefs in ts from their arguments if those refer to type parameters that are meant to be bound</span>
    <span class="comment">// TODO: this only deals with the simplest of type constructors</span>
    <span class="comment">// a better fix would be to actually bind those type parameters that appear free in error, but that would require major changes to the BTS infrastructure</span>
    <span class="comment">// example that only kindasorta works now...</span>
      <span class="comment">// given: trait Container[+T]; trait Template[+CC[X] &lt;: Container[X]]; class C1[T] extends Template[Container] with Container[T]</span>
    <span class="comment">// C1's BTS contains Template[Container] with Container[T], but that should really be [T] =&gt; Template[Container] with Container[T]</span>
    <span class="comment">// instead of wrapping it in a polytype, the current approach uses elimHOTparams to patch up this type so that </span>
    <span class="comment">// it looks more like a type ctor: Template[Container] with Container, but this is ill-kinded as Template[Container] is a proper type, whereas Container is not</span>
    <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="461369">elimHOTparams</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461370">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#461370" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#461387" title="Types.this.Type" class="delimiter">{</a> 
      <span class="keyword">case</span> <a title="Types.this.Type" id="461388">tp</a>@TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="461389">pre</a>, <a title="Types.this.Symbol" id="461390">sym</a>, <a title="List[Types.this.Type]" id="461391">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#461391" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#461365" title="List[List[Types.this.Symbol]]">tsParams</a>.<span title="(elem: Any)Boolean">contains</span><span class="delimiter">(</span><a href="#461391" title="List[Types.this.Type]">args</a>.<span title="(f: Types.this.Type =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,Any])Any">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.Symbol,List[Types.this.Symbol]]" class="delimiter">(</span><a href="#461408" title="Types.this.Type">_</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#461388" title="Types.this.TypeRef">tp</a>.<a href="#133408" title="=&gt; Types.this.Type">typeConstructor</a>
      <span class="keyword">case</span> <a title="Types.this.Type" id="461436">tp</a> =&gt; <a href="#461436" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461366" title="List[List[Types.this.Type]]">tsBts</a>.<span title="=&gt; List[List[Types.this.Type]]">tail</span>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#461366" title="List[List[Types.this.Type]]">tsBts</a>.<span title="=&gt; List[Types.this.Type]">head</span>
    <span class="keyword">else</span> <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461366" title="List[List[Types.this.Type]]">tsBts</a> <span title="(p: List[Types.this.Type] =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#461475" title="List[Types.this.Type]">_</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span> List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="461483">ts0</a> = <a href="#461366" title="List[List[Types.this.Type]]">tsBts</a> <span title="(f: List[Types.this.Type] =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#461501" title="List[Types.this.Type]">_</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span> <span class="comment">// ts0 is the 1-dimensional frontier of symbols cutting through 2-dimensional tsBts, </span>
      <span class="comment">// invariant: all symbols &quot;under&quot; (closer to the first row) the frontier are smaller (according to _.isLess) than the ones &quot;on and beyond&quot; the frontier</span>

      <span class="comment">// is the frontier made up of types with the same symbol? </span>
      <span class="comment">// --&gt; produce a single type for this frontier by merging the prefixes and arguments of these typerefs that share the same symbol</span>
      <span class="comment">// due to the invariant, that symbol is the current maximal symbol for which this holds, i.e., the one that conveys most information wrt subtyping</span>
      <span class="comment">// before merging, strip type arguments that refer to bound type params (when we're computing the lub of type constructors)</span>
      <span class="comment">// furthermore, the number of types to merge is reduced without losing information by dropping types that are a subtype of some other type</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="461484">sym0</a> = <a href="#461483" title="List[Types.this.Type]">ts0</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>
      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461483" title="List[Types.this.Type]">ts0</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#461538" title="Types.this.Type">_</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#461484" title="Types.this.Symbol">sym0</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">{</span>
        <a href="#67651" title="(tps: List[Types.this.Type], variance: Int, depth: Int)Option[Types.this.Type]">mergePrefixAndArgs</a><span class="delimiter">(</span><a href="#67626" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">elimSub</a><span class="delimiter">(</span><a href="#461369" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimHOTparams</a><span class="delimiter">(</span><a href="#461483" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>, <a href="#461367" title="Int">depth</a><span class="delimiter">)</span>, <span title="Int(1)" class="int">1</span>, <a href="#461367" title="Int">depth</a><span class="delimiter">)</span>.<span title="=&gt; List[Types.this.Type]">toList</span> <a href="#461544" title="(prefix: List[Types.this.Type])List[Types.this.Type]">:::</a> <a href="#67616" title="(tsParams: List[List[Types.this.Symbol]], tsBts: List[List[Types.this.Type]], depth: Int)List[Types.this.Type]">lubList</a><span class="delimiter">(</span><a href="#461365" title="List[List[Types.this.Symbol]]">tsParams</a>, <a href="#461366" title="List[List[Types.this.Type]]">tsBts</a> <span title="(f: List[Types.this.Type] =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a href="#461569" title="List[Types.this.Type]">_</a>.<span title="=&gt; List[Types.this.Type]">tail</span><span class="delimiter">)</span>, <a href="#461367" title="Int">depth</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span> 
        <span class="comment">// frontier is not uniform yet, move it beyond the current minimal symbol; lather, rince, repeat</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="461615">sym</a> = <a href="#67617" title="(tps: List[Types.this.Type])Types.this.Symbol">minSym</a><span class="delimiter">(</span><a href="#461483" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
        <a href="#67616" title="(tsParams: List[List[Types.this.Symbol]], tsBts: List[List[Types.this.Type]], depth: Int)List[Types.this.Type]">lubList</a><span class="delimiter">(</span><a href="#461365" title="List[List[Types.this.Symbol]]">tsParams</a>, <a href="#461366" title="List[List[Types.this.Type]]">tsBts</a> <span title="(f: List[Types.this.Type] =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a title="List[Types.this.Type]" id="461628">ts</a> =&gt; <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461628" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#461615" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#461628" title="List[Types.this.Type]">ts</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span class="keyword">else</span> <a href="#461628" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <a href="#461367" title="Int">depth</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="comment">// @AM the following problem is solved by elimHOTparams in lublist</span>
  <span class="comment">// @PP lubLists gone bad: lubList(List(</span>
  <span class="comment">//   List(scala.collection.generic.GenericCompanion[scala.collection.immutable.Seq], ScalaObject, java.lang.Object, Any)</span>
  <span class="comment">//   List(scala.collection.generic.GenericCompanion[scala.collection.mutable.Seq], ScalaObject, java.lang.Object, Any)</span>
  <span class="comment">// )) == (</span>
  <span class="comment">//   List(scala.collection.generic.GenericCompanion[Seq**[Any]**], ScalaObject, java.lang.Object, Any)</span>
  <span class="comment">// )</span>

  <span class="comment">/** The minimal symbol (wrt Symbol.isLess) of a list of types */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type])Types.this.Symbol" id="67617">minSym</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461616">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> =
    <span class="delimiter">(</span><a href="#461616" title="List[Types.this.Type]">tps</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="#461662" title="(z: Types.this.Symbol)(op: (Types.this.Symbol, Types.this.Type) =&gt; Types.this.Symbol)Types.this.Symbol">/:</a> <a href="#461616" title="List[Types.this.Type]">tps</a>.<span title="=&gt; List[Types.this.Type]">tail</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="delimiter">(</span><a title="Types.this.Symbol" id="461678">sym1</a>, <a title="Types.this.Type" id="461679">tp2</a><span class="delimiter">)</span> =&gt; <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#461679" title="Types.this.Type">tp2</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#107445" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#461678" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> <a href="#461679" title="Types.this.Type">tp2</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span class="keyword">else</span> <a href="#461678" title="Types.this.Symbol">sym1</a>
    <span class="delimiter">}</span>

  <span class="comment">/** A minimal type list which has a given list of types as its base type sequence */</span> 
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="67618">spanningTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461681">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#461681" title="List[Types.this.Type]">ts</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#461684" title="List[Nothing]">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="List[Types.this.Type]" id="461706">first</a> :: <a title="List[Types.this.Type]" id="461707">rest</a> =&gt;
      <a href="#461706" title="Types.this.Type">first</a> <a href="#461708" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#67618" title="(ts: List[Types.this.Type])List[Types.this.Type]">spanningTypes</a><span class="delimiter">(</span>
        <a href="#461707" title="List[Types.this.Type]">rest</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a title="Types.this.Type" id="461712">t</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#461706" title="Types.this.Type">first</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107448" title="(that: Types.this.Symbol)Boolean">isSubClass</a><span class="delimiter">(</span><a href="#461712" title="Types.this.Type">t</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Eliminate from list of types all elements which are a supertype
   *  of some other element of the list. */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="67619">elimSuper</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461718">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#461718" title="List[Types.this.Type]">ts</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#461721" title="List[Nothing]">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="List[Types.this.Type]" id="461743">t</a> :: <a title="List[Types.this.Type]" id="461744">ts1</a> =&gt;
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="461745">rest</a> = <a href="#67619" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSuper</a><span class="delimiter">(</span><a href="#461744" title="List[Types.this.Type]">ts1</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a title="Types.this.Type" id="461749">t1</a> =&gt; <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#461743" title="Types.this.Type">t</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#461749" title="Types.this.Type">t1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461745" title="List[Types.this.Type]">rest</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a title="Types.this.Type" id="461756">t1</a> =&gt; <a href="#461756" title="Types.this.Type">t1</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#461743" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#461745" title="List[Types.this.Type]">rest</a> <span class="keyword">else</span> <a href="#461743" title="Types.this.Type">t</a> <a href="#461757" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#461745" title="List[Types.this.Type]">rest</a>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(t: Types.this.Type)Types.this.Type" id="67620">elimAnonymousClass</a><span class="delimiter">(</span><a title="Types.this.Type" id="461763">t</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#461763" title="Types.this.Type">t</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="461766">pre</a>, <a title="Types.this.Symbol" id="461767">clazz</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#461767" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107346" title="=&gt; Boolean">isAnonymousClass</a> =&gt;
      <a href="#461767" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107441" title="=&gt; Types.this.Type">classBound</a>.<a href="#105359" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#461766" title="Types.this.Type">pre</a>, <a href="#461767" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <a href="#461763" title="Types.this.Type">t</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A collector that tests for existential types appearing at given variance in a type */</span>
  <span class="keyword">class</span> <a title="class ContainsVariantExistentialCollector extends Types.this.TypeCollector[Boolean] with ScalaObject" id="67621">ContainsVariantExistentialCollector</a><a href="#67621" title="ScalaObject" class="delimiter">(</a><a title="Int" id="449246">v</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67507" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="449244">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="461774">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#461774" title="Types.this.Type">tp</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Unit">ExistentialType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#133272" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <a href="#449246" title="Int">v</a><span class="delimiter">)</span> =&gt; <a href="#449234" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt; <a href="#133280" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#461774" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="()Types.this.ContainsVariantExistentialCollector" id="449245">init</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#133272" title="(x$1: Int)Unit">variance</a> = <span title="Int(1)" class="int">1</span>
      <a href="#67621" title="Types.this.ContainsVariantExistentialCollector" class="keyword">this</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">val</span> <a title="Types.this.ContainsVariantExistentialCollector" id="67622">containsCovariantExistentialCollector</a> = <span title="Types.this.ContainsVariantExistentialCollector" class="keyword">new</span> <a href="#67621" title="Types.this.ContainsVariantExistentialCollector">ContainsVariantExistentialCollector</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="Types.this.ContainsVariantExistentialCollector" id="67624">containsContravariantExistentialCollector</a> = <span title="Types.this.ContainsVariantExistentialCollector" class="keyword">new</span> <a href="#67621" title="Types.this.ContainsVariantExistentialCollector">ContainsVariantExistentialCollector</a><span class="delimiter">(</span>-<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span>

  <span class="comment">/** Eliminate from list of types all elements which are a subtype
   *  of some other element of the list. */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]" id="67626">elimSub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461545">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="461546">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="461791">elimSub0</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461793">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#461793" title="List[Types.this.Type]">ts</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#461795" title="List[Nothing]">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="List[Types.this.Type]" id="461817">t</a> :: <a title="List[Types.this.Type]" id="461818">ts1</a> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="461819">rest</a> = <a href="#461791" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSub0</a><span class="delimiter">(</span><a href="#461818" title="List[Types.this.Type]">ts1</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a title="Types.this.Type" id="461823">t1</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#67584" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#461823" title="Types.this.Type">t1</a>, <a href="#461817" title="Types.this.Type">t</a>, <a href="#67364" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#461546" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461819" title="List[Types.this.Type]">rest</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a title="Types.this.Type" id="461834">t1</a> =&gt; <a href="#67584" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#461817" title="Types.this.Type">t</a>, <a href="#461834" title="Types.this.Type">t1</a>, <a href="#67364" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#461546" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#461819" title="List[Types.this.Type]">rest</a> <span class="keyword">else</span> <a href="#461817" title="Types.this.Type">t</a> <a href="#461839" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#461819" title="List[Types.this.Type]">rest</a>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="List[Types.this.Type]" id="461792">ts0</a> = <a href="#461791" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSub0</a><span class="delimiter">(</span><a href="#461545" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
    <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461792" title="List[Types.this.Type]">ts0</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#461792" title="List[Types.this.Type]">ts0</a>.<span title="=&gt; List[Types.this.Type]">tail</span>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#461792" title="List[Types.this.Type]">ts0</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="461846">ts1</a> = <a href="#461792" title="List[Types.this.Type]">ts0</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a title="Types.this.Type" id="461853">t</a> =&gt; <a href="#67620" title="(t: Types.this.Type)Types.this.Type">elimAnonymousClass</a><span class="delimiter">(</span><a href="#461853" title="Types.this.Type">t</a>.<a href="#105316" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#461846" title="List[Types.this.Type]">ts1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#461792" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span> <a href="#461792" title="List[Types.this.Type]">ts0</a>
      <span class="keyword">else</span> <a href="#67626" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">elimSub</a><span class="delimiter">(</span><a href="#461846" title="List[Types.this.Type]">ts1</a>, <a href="#461546" title="Int">depth</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])(List[Types.this.Type], List[Types.this.Symbol])" id="67627">stripExistentialsAndTypeVars</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461855">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span>, List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="461857">quantified</a> = <a href="#461855" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">flatMap</span> <a href="#461876" title="List[Types.this.Symbol]" class="delimiter">{</a>
      <span class="keyword">case</span> <span title="List[Types.this.Symbol]">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="461877">qs</a>, _<span class="delimiter">)</span> =&gt; <a href="#461877" title="List[Types.this.Symbol]">qs</a>
      <span class="keyword">case</span> <a title="List[Nothing]" id="461878">t</a> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="461858">stripType</a><span class="delimiter">(</span><a title="Types.this.Type" id="461913">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#461913" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="461914">res</a><span class="delimiter">)</span> =&gt; 
        <a href="#461914" title="Types.this.Type">res</a>
      <span class="keyword">case</span> <a href="#448916" title="Types.this.Type">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="461916">constr</a><span class="delimiter">)</span> =&gt; 
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461916" title="Types.this.TypeConstraint">constr</a>.<a href="#449328" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#461916" title="Types.this.TypeConstraint">constr</a>.<a href="#449326" title="=&gt; Types.this.Type">inst</a>
        <span class="keyword">else</span> <a href="SymbolTable.scala.html#64779" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><span title="java.lang.String(&quot;trying to do lub/glb of typevar &quot;)" class="string">&quot;trying to do lub/glb of typevar &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#461913" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="461921">t</a> =&gt; <a href="#461921" title="Types.this.Type">t</a>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="List[Types.this.Type]" id="461859">strippedTypes</a> = <a href="#461855" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <a href="#461858" title="(tp: Types.this.Type)Types.this.Type">stripType</a>
    <span title="(_1: List[Types.this.Type], _2: List[Types.this.Symbol])(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</span><a href="#461859" title="List[Types.this.Type]">strippedTypes</a>, <a href="#461857" title="List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])(Types.this.Type, Boolean)" id="67628">weakLub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461936">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = 
    <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#461936" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#461936" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <a href="Definitions.scala.html#106525" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#67630" title="(ts: List[Types.this.Type])Types.this.Type">numericLub</a><span class="delimiter">(</span><a href="#461936" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#461936" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#461936" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#461975" title="Types.this.Type">_</a>.<a href="#105399" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="AnnotationCheckers.scala.html#67760" title="(tpe: Types.this.Type, ts: List[Types.this.Type])Types.this.Type">annotationsLub</a><span class="delimiter">(</span><a href="#67638" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#461936" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#462003" title="Types.this.Type">_</a>.<a href="#105403" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#461936" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#67638" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#461936" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])(Types.this.Type, Boolean)" id="67629">weakGlb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="462043">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#462043" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#462043" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <a href="Definitions.scala.html#106525" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="462053">nglb</a> = <a href="#67631" title="(ts: List[Types.this.Type])Types.this.Type">numericGlb</a><span class="delimiter">(</span><a href="#462043" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
      <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#462053" title="Types.this.Type">nglb</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#462053" title="Types.this.Type">nglb</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#67647" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#462043" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#462043" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#462043" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#462097" title="Types.this.Type">_</a>.<a href="#105399" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="AnnotationCheckers.scala.html#67761" title="(tpe: Types.this.Type, ts: List[Types.this.Type])Types.this.Type">annotationsGlb</a><span class="delimiter">(</span><a href="#67647" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#462043" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#462125" title="Types.this.Type">_</a>.<a href="#105403" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#462043" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#67647" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#462043" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="67630">numericLub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461950">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#461950" title="List[Types.this.Type]">ts</a> <span title="(f: (Types.this.Type, Types.this.Type) =&gt; Types.this.Type)Types.this.Type">reduceLeft</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="461965">t1</a>, <a title="Types.this.Type" id="461966">t2</a><span class="delimiter">)</span> =&gt; 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67633" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#461965" title="Types.this.Type">t1</a>, <a href="#461966" title="Types.this.Type">t2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#461966" title="Types.this.Type">t2</a> 
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67633" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#461966" title="Types.this.Type">t2</a>, <a href="#461965" title="Types.this.Type">t1</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#461965" title="Types.this.Type">t1</a>
      <span class="keyword">else</span> <a href="Definitions.scala.html#106585" title="=&gt; Types.this.Symbol">IntClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="67631">numericGlb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="462054">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#462054" title="List[Types.this.Type]">ts</a> <span title="(f: (Types.this.Type, Types.this.Type) =&gt; Types.this.Type)Types.this.Type">reduceLeft</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="462069">t1</a>, <a title="Types.this.Type" id="462070">t2</a><span class="delimiter">)</span> =&gt; 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67633" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#462069" title="Types.this.Type">t1</a>, <a href="#462070" title="Types.this.Type">t2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462069" title="Types.this.Type">t1</a> 
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#67633" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#462070" title="Types.this.Type">t2</a>, <a href="#462069" title="Types.this.Type">t1</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462070" title="Types.this.Type">t2</a>
      <span class="keyword">else</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67632">isWeakSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="450135">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="450136">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = 
    <a href="#450135" title="Types.this.Type">tp1</a>.<a href="#105318" title="=&gt; Types.this.Type">deconst</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="450139">sym1</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="Definitions.scala.html#106571" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#450139" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> =&gt;
        <a href="#450136" title="Types.this.Type">tp2</a>.<a href="#105318" title="=&gt; Types.this.Type">deconst</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="450142">sym2</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="Definitions.scala.html#106571" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#450142" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> =&gt;
            <a href="Definitions.scala.html#106570" title="(sub: Types.this.Symbol, sup: Types.this.Symbol)Boolean">isNumericSubClass</a><span class="delimiter">(</span><a href="#450139" title="Types.this.Symbol">sym1</a>, <a href="#450142" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <a title="Boolean" id="450145">tv2</a> @ <a href="#448916" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
            <a href="#450145" title="Types.this.TypeVar">tv2</a>.<a href="#448950" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#450135" title="Types.this.Type">tp1</a>, isLowerBound = <span title="Boolean(true)" class="keyword">true</span>, isNumericBound = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#67583" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a><span class="delimiter">(</span><a href="#450135" title="Types.this.Type">tp1</a>, <a href="#450136" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Boolean" id="450156">tv1</a> @ <a href="#448916" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
        <a href="#450136" title="Types.this.Type">tp2</a>.<a href="#105318" title="=&gt; Types.this.Type">deconst</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="450158">sym2</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="Definitions.scala.html#106571" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#450158" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> =&gt;
            <a href="#450156" title="Types.this.TypeVar">tv1</a>.<a href="#448950" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#450136" title="Types.this.Type">tp2</a>, isLowerBound = <span title="Boolean(false)" class="keyword">false</span>, isNumericBound = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#67583" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a><span class="delimiter">(</span><a href="#450135" title="Types.this.Type">tp1</a>, <a href="#450136" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#67583" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a><span class="delimiter">(</span><a href="#450135" title="Types.this.Type">tp1</a>, <a href="#450136" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="67633">isNumericSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="456446">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="456447">tp2</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
    <a href="Definitions.scala.html#106525" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#456446" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#106525" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#456447" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>  
    <a href="Definitions.scala.html#106570" title="(sub: Types.this.Symbol, sup: Types.this.Symbol)Boolean">isNumericSubClass</a><span class="delimiter">(</span><a href="#456446" title="Types.this.Type">tp1</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#456447" title="Types.this.Type">tp2</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" id="67634">lubResults</a> = <span title="()scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">HashMap</span><span class="delimiter">[</span><span class="delimiter">(</span>Int, List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>, Type<span class="delimiter">]</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" id="67636">glbResults</a> = <span title="()scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">HashMap</span><span class="delimiter">[</span><span class="delimiter">(</span>Int, List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>, Type<span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="67638">lub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="222341">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="#67639" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#222341" title="List[Types.this.Type]">ts</a>, <a href="#67557" title="(ts: List[Types.this.Type])Int">lubDepth</a><span class="delimiter">(</span><a href="#222341" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#67634" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">lubResults</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#67636" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">glbResults</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
 
  <span class="comment">/** The least upper bound wrt &lt;:&lt; of a list of types */</span>
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)Types.this.Type" id="67639">lub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="222336">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="222337">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="462169">lub0</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="462172">ts0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#67626" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">elimSub</a><span class="delimiter">(</span><a href="#462172" title="List[Types.this.Type]">ts0</a>, <a href="#222337" title="Int">depth</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#462174" title="Types.this.Type">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
      <span class="keyword">case</span> <a href="#462186" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="462197">t</a><span class="delimiter">)</span> =&gt; <a href="#462197" title="Types.this.Type">t</a>
      <span class="keyword">case</span> <a title="Types.this.PolyType" id="462198">ts</a> @ PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="462203">tparams</a>, _<span class="delimiter">)</span> :: _ =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="462204">tparams1</a> = <span title="(_1: List[Types.this.Symbol], _2: List[List[Types.this.Type]])(List[Types.this.Symbol], List[List[Types.this.Type]])" class="delimiter">(</span><a href="#462203" title="List[Types.this.Symbol]">tparams</a>, <a href="#67653" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[List[Types.this.Type]]">matchingBounds</a><span class="delimiter">(</span><a href="#462198" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#462203" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>.<span title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.TraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</span><span class="delimiter">)</span>.<span title="(implicit w1: List[Types.this.Symbol] =&gt; scala.collection.TraversableLike[Types.this.Symbol,List[Types.this.Symbol]], implicit w2: List[List[Types.this.Type]] =&gt; scala.collection.IterableLike[List[Types.this.Type],List[List[Types.this.Type]]])(List[Types.this.Symbol], List[List[Types.this.Type]])#Zipped[List[Types.this.Symbol],Types.this.Symbol,List[List[Types.this.Type]],List[Types.this.Type]]">zipped</span> <span title="(f: (Types.this.Symbol, List[Types.this.Type]) =&gt; Types.this.Symbol)(implicit cbf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span>
          <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="462304">tparam</a>, <a title="List[Types.this.Type]" id="462305">bounds</a><span class="delimiter">)</span> =&gt; <a href="#462304" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107453" title="=&gt; Types.this.Symbol">cloneSymbol</a>.<a href="Symbols.scala.html#107425" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a><span class="delimiter">(</span><a href="#67648" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#462305" title="List[Types.this.Type]">bounds</a>, <a href="#222337" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#148857" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#462204" title="List[Types.this.Symbol]">tparams1</a>, <a href="#462169" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#67654" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">matchingInstTypes</a><span class="delimiter">(</span><a href="#462198" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#462204" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.MethodType" id="462346">ts</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="462351">params</a>, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="462352">rest</a> =&gt;
        <a href="#148698" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#462351" title="List[Types.this.Symbol]">params</a>, <a href="#462169" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#67655" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span><a href="#462346" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#462351" title="List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#462372" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.NullaryMethodType" id="462400">ts</a> @ NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="462405">rest</a> =&gt;
        <a href="#148801" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#462169" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#67655" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span><a href="#462400" title="collection.immutable.::[Types.this.Type]">ts</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.TypeBounds" id="462406">ts</a> @ TypeBounds<span class="delimiter">(</span>_, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="462411">rest</a> =&gt;
        <a href="#148437" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#67648" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#462406" title="collection.immutable.::[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#462432" title="Types.this.Type">_</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148467" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#222337" title="Int">depth</a><span class="delimiter">)</span>, <a href="#67639" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#462406" title="collection.immutable.::[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#462474" title="Types.this.Type">_</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#222337" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="462502">ts</a> =&gt;
        <a href="#67634" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">lubResults</a> <span title="(key: (Int, List[Types.this.Type]))Option[Types.this.Type]">get</span> <span class="delimiter">(</span><a href="#222337" title="Int">depth</a>, <a href="#462502" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Types.this.Type">Some</span><span class="delimiter">(</span><a title="Types.this.Type" id="462513">lubType</a><span class="delimiter">)</span> =&gt; 
            <a href="#462513" title="Types.this.Type">lubType</a>
          <span class="keyword">case</span> <span title="Types.this.Type">None</span> =&gt; 
            <a href="#67634" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">lubResults</a><span class="delimiter">(</span><span title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</span><a href="#222337" title="Int">depth</a>, <a href="#462502" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="462514">res</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#222337" title="Int">depth</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#462170" title="(ts0: List[Types.this.Type])Types.this.Type">lub1</a><span class="delimiter">(</span><a href="#462502" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
            <a href="#67634" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">lubResults</a><span class="delimiter">(</span><span title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</span><a href="#222337" title="Int">depth</a>, <a href="#462502" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="#462514" title="Types.this.Type">res</a>
            <a href="#462514" title="Types.this.Type">res</a>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="462170">lub1</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="462529">ts0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#462537" title="(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</a><a href="#462536" title="List[Types.this.Type]" id="462537">ts</a>, <a href="#462536" title="List[Types.this.Symbol]" id="462538">tparams</a><span class="delimiter">)</span> = <a href="#67627" title="(ts: List[Types.this.Type])(List[Types.this.Type], List[Types.this.Symbol])">stripExistentialsAndTypeVars</a><span title="(List[Types.this.Type], List[Types.this.Symbol]) @unchecked" class="delimiter">(</span><a href="#462529" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="462539">lubBaseTypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#67616" title="(tsParams: List[List[Types.this.Symbol]], tsBts: List[List[Types.this.Type]], depth: Int)List[Types.this.Type]">lubList</a><span class="delimiter">(</span><a href="#462537" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; List[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Symbol],List[List[Types.this.Symbol]]])List[List[Types.this.Symbol]]">map</span> <span class="delimiter">(</span><a href="#462581" title="Types.this.Type">_</a>.<a href="#105336" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span>, <a href="#462537" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a href="#462619" title="Types.this.Type">_</a>.<a href="#105383" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#197511" title="=&gt; List[Types.this.Type]">toList</a><span class="delimiter">)</span>, <a href="#222337" title="Int">depth</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="462540">lubParents</a> = <a href="#67618" title="(ts: List[Types.this.Type])List[Types.this.Type]">spanningTypes</a><span class="delimiter">(</span><a href="#462539" title="List[Types.this.Type]">lubBaseTypes</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="462541">lubOwner</a> = <a href="#67650" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#462537" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="462542">lubBase</a> = <a href="#67476" title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="#462540" title="List[Types.this.Type]">lubParents</a>, <a href="#462541" title="Types.this.Symbol">lubOwner</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="462543">lubType</a> =
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#222337" title="Int">depth</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#462542" title="Types.this.Type">lubBase</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="462661">lubRefined</a> = <a href="#67470" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#462540" title="List[Types.this.Type]">lubParents</a>, <a href="#462541" title="Types.this.Symbol">lubOwner</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="462662">lubThisType</a> = <a href="#462661" title="Types.this.Type">lubRefined</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107459" title="=&gt; Types.this.Type">thisType</a>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="462663">narrowts</a> = <a href="#462537" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#462680" title="Types.this.Type">_</a>.<a href="#105320" title="=&gt; Types.this.Type">narrow</a><span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(proto: Types.this.Symbol)Types.this.Symbol" id="462664">lubsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="462708">proto</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="462709">prototp</a> = <a href="#462662" title="Types.this.Type">lubThisType</a>.<a href="#105360" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#462708" title="Types.this.Symbol">proto</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="462710">syms</a> = <a href="#462663" title="List[Types.this.Type]">narrowts</a> <span title="(f: Types.this.Type =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <span class="delimiter">(</span><a title="Types.this.Type" id="462727">t</a> =&gt;
              <a href="#462727" title="Types.this.Type">t</a>.<a href="#105355" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#462708" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107452" title="(cond: Types.this.Symbol =&gt; Boolean)Types.this.Symbol">suchThat</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="462729">sym</a> =&gt;
                <a href="#462729" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a> <a href="#105381" title="(that: Types.this.Type)Boolean">matches</a> <a href="#462709" title="Types.this.Type">prototp</a>.<a href="#105365" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#462662" title="Types.this.Type">lubThisType</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#462727" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#462710" title="List[Types.this.Symbol]">syms</a> <span title="(elem: Any)Boolean">contains</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a>
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="List[Types.this.Type]" id="462757">symtypes</a> =
                <span title="(_1: List[Types.this.Type], _2: List[Types.this.Symbol])(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</span><a href="#462663" title="List[Types.this.Type]">narrowts</a>, <a href="#462710" title="List[Types.this.Symbol]">syms</a><span class="delimiter">)</span>.<span title="(implicit w1: List[Types.this.Type] =&gt; scala.collection.TraversableLike[Types.this.Type,List[Types.this.Type]], implicit w2: List[Types.this.Symbol] =&gt; scala.collection.IterableLike[Types.this.Symbol,List[Types.this.Symbol]])(List[Types.this.Type], List[Types.this.Symbol])#Zipped[List[Types.this.Type],Types.this.Type,List[Types.this.Symbol],Types.this.Symbol]">zipped</span> <span title="(f: (Types.this.Type, Types.this.Symbol) =&gt; Types.this.Type)(implicit cbf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="462812">t</a>, <a title="Types.this.Symbol" id="462813">sym</a><span class="delimiter">)</span> =&gt; <a href="#462812" title="Types.this.Type">t</a>.<a href="#105360" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#462813" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#105365" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#462812" title="Types.this.Type">t</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#462662" title="Types.this.Type">lubThisType</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#462708" title="Types.this.Symbol">proto</a>.<span title="=&gt; Boolean">isTerm</span><span class="delimiter">)</span> <span class="comment">// possible problem: owner of info is still the old one, instead of new refinement class</span>
                <a href="#462708" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#107454" title="(owner: Types.this.Symbol)Types.this.Symbol">cloneSymbol</a><span class="delimiter">(</span><a href="#462661" title="Types.this.Type">lubRefined</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107426" title="(info: Types.this.Type)Types.this.Symbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span><a href="#67639" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#462757" title="List[Types.this.Type]">symtypes</a>, <a href="#67364" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#222337" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#462757" title="List[Types.this.Type]">symtypes</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#462757" title="List[Types.this.Type]">symtypes</a>.<a href="#462858" title="=&gt; Types.this.Type">head</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#462708" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#107454" title="(owner: Types.this.Symbol)Types.this.Symbol">cloneSymbol</a><span class="delimiter">(</span><a href="#462661" title="Types.this.Type">lubRefined</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107426" title="(info: Types.this.Type)Types.this.Symbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span><a href="#462757" title="List[Types.this.Type]">symtypes</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span class="delimiter">{</span>
                <span class="keyword">def</span> <a title="(bnds: List[Types.this.TypeBounds])Types.this.TypeBounds" id="462863">lubBounds</a><span class="delimiter">(</span><a title="List[Types.this.TypeBounds]" id="462864">bnds</a>: <span title="List[Types.this.TypeBounds]">List</span><span class="delimiter">[</span>TypeBounds<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#148453" title="Types.this.TypeBounds">TypeBounds</a> =
                  <a href="#148437" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#67648" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#462864" title="List[Types.this.TypeBounds]">bnds</a> <span title="(f: Types.this.TypeBounds =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeBounds],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#462885" title="Types.this.TypeBounds">_</a>.<a href="#148467" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#67364" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#222337" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#67639" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#462864" title="List[Types.this.TypeBounds]">bnds</a> <span title="(f: Types.this.TypeBounds =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeBounds],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#462927" title="Types.this.TypeBounds">_</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#67364" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#222337" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#462661" title="Types.this.Type">lubRefined</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107299" title="(pos: Types.this.Position, name: Types.this.TypeName)Types.this.TypeSymbol">newAbstractType</a><span class="delimiter">(</span><a href="#462708" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#107263" title="=&gt; Types.this.Position">pos</a>, <a href="#462708" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#96578" title="=&gt; Types.this.TypeName">toTypeName</a><span class="delimiter">)</span>
                  .<a href="Symbols.scala.html#107426" title="(info: Types.this.Type)Types.this.TypeSymbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span><a href="#462863" title="(bnds: List[Types.this.TypeBounds])Types.this.TypeBounds">lubBounds</a><span class="delimiter">(</span><a href="#462757" title="List[Types.this.Type]">symtypes</a> <span title="(f: Types.this.Type =&gt; Types.this.TypeBounds)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.TypeBounds,List[Types.this.TypeBounds]])List[Types.this.TypeBounds]">map</span> <span class="delimiter">(</span><a href="#462989" title="Types.this.Type">_</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean" id="462665">refines</a><span class="delimiter">(</span><a title="Types.this.Type" id="463017">tp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="463018">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="463019">syms</a> = <a href="#463017" title="Types.this.Type">tp</a>.<a href="#105355" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#463018" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107450" title="=&gt; List[Types.this.Symbol]">alternatives</a>;
            <span title="=&gt; Boolean">!</span><a href="#463019" title="List[Types.this.Symbol]">syms</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#463019" title="List[Types.this.Symbol]">syms</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="463026">alt</a> =&gt;
              <span class="comment">// todo alt != sym is strictly speaking not correct, but without it we lose </span>
              <span class="comment">// efficiency.</span>
              <a href="#463026" title="Types.this.Symbol">alt</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#463018" title="Types.this.Symbol">sym</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#67604" title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#462662" title="Types.this.Type">lubThisType</a>, <a href="#463018" title="Types.this.Symbol">sym</a>, <a href="#463017" title="Types.this.Type">tp</a>, <a href="#463026" title="Types.this.Symbol">alt</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="463056">sym</a> &lt;- <a href="#462542" title="Types.this.Type">lubBase</a>.<a href="#105350" title="(f: Types.this.Symbol =&gt; Unit)Unit">nonPrivateMembers</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="comment">// add a refinement symbol for all non-class members of lubBase</span>
            <span class="comment">// which are refined by every type in ts.</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#463056" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isClass</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#463056" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107334" title="=&gt; Boolean">isConstructor</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#462663" title="List[Types.this.Type]">narrowts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.Type" id="463063">t</a> =&gt; <a href="#462665" title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean">refines</a><span class="delimiter">(</span><a href="#463063" title="Types.this.Type">t</a>, <a href="#463056" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">try</span> <span class="delimiter">{</span>
                <span class="keyword">val</span> <a title="Types.this.Symbol" id="463064">lsym</a> = <a href="#462664" title="(proto: Types.this.Symbol)Types.this.Symbol">lubsym</a><span class="delimiter">(</span><a href="#463056" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
                <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#463064" title="Types.this.Symbol">lsym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#67652" title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol)Unit">addMember</a><span class="delimiter">(</span><a href="#462662" title="Types.this.Type">lubThisType</a>, <a href="#462661" title="Types.this.Type">lubRefined</a>, <a href="#462664" title="(proto: Types.this.Symbol)Types.this.Symbol">lubsym</a><span class="delimiter">(</span><a href="#463056" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <a title="Unit" id="463069">ex</a>: <a href="#67659" title="Types.this.NoCommonType">NoCommonType</a> =&gt;
              <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#462661" title="Types.this.Type">lubRefined</a>.<a href="#105346" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112943" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#462542" title="Types.this.Type">lubBase</a>
          <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span title="Boolean(true)">verifyLubs</span><span class="delimiter">)</span> <a href="#462661" title="Types.this.Type">lubRefined</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="comment">// Verify that every given type conforms to the calculated lub.</span>
            <span class="comment">// In theory this should not be necessary, but higher-order type</span>
            <span class="comment">// parameters are not handled correctly.</span>
            <span class="keyword">val</span> <a title="Boolean" id="463075">ok</a> = <a href="#462537" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">{</span> <a title="Types.this.Type" id="463082">t</a> =&gt;
              <span class="delimiter">(</span><a href="#463082" title="Types.this.Type">t</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#462661" title="Types.this.Type">lubRefined</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">{</span>
                <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <span title="object Console">Console</span>.<span title="(x: Any)Unit">println</span><span class="delimiter">(</span>
                    <span title="java.lang.String(&quot;Malformed lub: &quot;)" class="string">&quot;Malformed lub: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#462661" title="Types.this.Type">lubRefined</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;\012&quot;)" class="string">&quot;\n&quot;</span> <span title="(x$1: Any)java.lang.String">+</span>
                    <span title="java.lang.String(&quot;Argument &quot;)" class="string">&quot;Argument &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#463082" title="Types.this.Type">t</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; does not conform.  Falling back to &quot;)" class="string">&quot; does not conform.  Falling back to &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#462542" title="Types.this.Type">lubBase</a>
                  <span class="delimiter">)</span>
                <span class="delimiter">}</span>
                <span title="Boolean(false)" class="keyword">false</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="comment">// If not, fall back on the more conservative calculation.</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#463075" title="Boolean">ok</a><span class="delimiter">)</span> <a href="#462661" title="Types.this.Type">lubRefined</a>
            <span class="keyword">else</span> <a href="#462542" title="Types.this.Type">lubBase</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <a href="#67482" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#462538" title="List[Types.this.Symbol]">tparams</a>, <a href="#462543" title="Types.this.Type">lubType</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="Boolean(false)">printLubs</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#67663" title="=&gt; String">indent</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;lub of &quot;)" class="string">&quot;lub of &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#222336" title="List[Types.this.Type]">ts</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; at depth &quot;)" class="string">&quot; at depth &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#222337" title="Int">depth</a><span class="delimiter">)</span><span class="comment">//debug</span>
      <a href="#67663" title="(x$1: String)Unit">indent</a> = <a href="#67663" title="=&gt; String">indent</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#67663" title="=&gt; String">indent</a>.<span title="()Int">length</span> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(100)" class="int">100</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="Types.this.Type" id="462171">res</a> = <a href="#462169" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#222336" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="Boolean(false)">printLubs</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#67663" title="(x$1: String)Unit">indent</a> = <a href="#67663" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">indent</a> <span title="(n: Int)String">dropRight</span> <span title="Int(2)" class="int">2</span>
      <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#67663" title="=&gt; String">indent</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;lub of &quot;)" class="string">&quot;lub of &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#222336" title="List[Types.this.Type]">ts</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; is &quot;)" class="string">&quot; is &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#462171" title="Types.this.Type">res</a><span class="delimiter">)</span><span class="comment">//debug</span>
    <span class="delimiter">}</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#222336" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#463114" title="Types.this.Type">_</a>.<a href="#105307" title="=&gt; Boolean">isNotNull</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#462171" title="Types.this.Type">res</a>.<a href="#105338" title="=&gt; Types.this.Type">notNull</a> <span class="keyword">else</span> <a href="#462171" title="Types.this.Type">res</a>
  <span class="delimiter">}</span>

  <span class="keyword">val</span> <a title="java.lang.Throwable" id="67640">GlbFailure</a> = <span title="java.lang.Throwable" class="keyword">new</span> <span title="java.lang.Throwable">Throwable</span>

  <span class="comment">/** A global counter for glb calls in the `specializes' query connected to the `addMembers'
   *  call in `glb'. There's a possible infinite recursion when `specializes' calls
   *  memberType, which calls baseTypeSeq, which calls mergePrefixAndArgs, which calls glb.
   *  The counter breaks this recursion after two calls.
   *  If the recursion is broken, no member is added to the glb.
   */</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="67643">globalGlbDepth</a> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(2)" id="67645">globalGlbLimit</a> = <span title="Int(2)" class="int">2</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="67647">glb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="372312">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="#67648" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#372312" title="List[Types.this.Type]">ts</a>, <a href="#67557" title="(ts: List[Types.this.Type])Int">lubDepth</a><span class="delimiter">(</span><a href="#372312" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#67634" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">lubResults</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#67636" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">glbResults</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The greatest lower bound wrt &lt;:&lt; of a list of types */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)Types.this.Type" id="67648">glb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="461203">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="461204">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="463119">glb0</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="463122">ts0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#67619" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSuper</a><span class="delimiter">(</span><a href="#463122" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#463124" title="Types.this.Type">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
      <span class="keyword">case</span> <a href="#463136" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="463147">t</a><span class="delimiter">)</span> =&gt; <a href="#463147" title="Types.this.Type">t</a>
      <span class="keyword">case</span> <a title="Types.this.PolyType" id="463148">ts</a> @ PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="463153">tparams</a>, _<span class="delimiter">)</span> :: _ =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="463154">tparams1</a> = <span title="(_1: List[Types.this.Symbol], _2: List[List[Types.this.Type]])(List[Types.this.Symbol], List[List[Types.this.Type]])" class="delimiter">(</span><a href="#463153" title="List[Types.this.Symbol]">tparams</a>, <a href="#67653" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[List[Types.this.Type]]">matchingBounds</a><span class="delimiter">(</span><a href="#463148" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#463153" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>.<span title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.TraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</span><span class="delimiter">)</span>.<span title="(implicit w1: List[Types.this.Symbol] =&gt; scala.collection.TraversableLike[Types.this.Symbol,List[Types.this.Symbol]], implicit w2: List[List[Types.this.Type]] =&gt; scala.collection.IterableLike[List[Types.this.Type],List[List[Types.this.Type]]])(List[Types.this.Symbol], List[List[Types.this.Type]])#Zipped[List[Types.this.Symbol],Types.this.Symbol,List[List[Types.this.Type]],List[Types.this.Type]]">zipped</span> <span title="(f: (Types.this.Symbol, List[Types.this.Type]) =&gt; Types.this.Symbol)(implicit cbf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span>
          <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="463248">tparam</a>, <a title="List[Types.this.Type]" id="463249">bounds</a><span class="delimiter">)</span> =&gt; <a href="#463248" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107453" title="=&gt; Types.this.Symbol">cloneSymbol</a>.<a href="Symbols.scala.html#107425" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a><span class="delimiter">(</span><a href="#67639" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#463249" title="List[Types.this.Type]">bounds</a>, <a href="#461204" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#148857" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#463154" title="List[Types.this.Symbol]">tparams1</a>, <a href="#463119" title="(ts0: List[Types.this.Type])Types.this.Type">glb0</a><span class="delimiter">(</span><a href="#67654" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">matchingInstTypes</a><span class="delimiter">(</span><a href="#463148" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#463154" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.MethodType" id="463284">ts</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="463289">params</a>, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="463290">rest</a> =&gt;
        <a href="#148698" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#463289" title="List[Types.this.Symbol]">params</a>, <a href="#463119" title="(ts0: List[Types.this.Type])Types.this.Type">glb0</a><span class="delimiter">(</span><a href="#67655" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span><a href="#463284" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#463289" title="List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#463307" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.NullaryMethodType" id="463335">ts</a> @ NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="463340">rest</a> =&gt;
        <a href="#148801" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#463119" title="(ts0: List[Types.this.Type])Types.this.Type">glb0</a><span class="delimiter">(</span><a href="#67655" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span><a href="#463335" title="collection.immutable.::[Types.this.Type]">ts</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.TypeBounds" id="463341">ts</a> @ TypeBounds<span class="delimiter">(</span>_, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="463346">rest</a> =&gt;
        <a href="#148437" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#67639" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#463341" title="collection.immutable.::[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#463367" title="Types.this.Type">_</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148467" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#461204" title="Int">depth</a><span class="delimiter">)</span>, <a href="#67648" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#463341" title="collection.immutable.::[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#463409" title="Types.this.Type">_</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#461204" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="463437">ts</a> =&gt;
        <a href="#67636" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">glbResults</a> <span title="(key: (Int, List[Types.this.Type]))Option[Types.this.Type]">get</span> <span class="delimiter">(</span><a href="#461204" title="Int">depth</a>, <a href="#463437" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Types.this.Type">Some</span><span class="delimiter">(</span><a title="Types.this.Type" id="463448">glbType</a><span class="delimiter">)</span> =&gt;
            <a href="#463448" title="Types.this.Type">glbType</a>
          <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
            <a href="#67636" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">glbResults</a><span class="delimiter">(</span><span title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</span><a href="#461204" title="Int">depth</a>, <a href="#463437" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="463449">res</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461204" title="Int">depth</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#463120" title="(ts0: List[Types.this.Type])Types.this.Type">glb1</a><span class="delimiter">(</span><a href="#463437" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
            <a href="#67636" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">glbResults</a><span class="delimiter">(</span><span title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</span><a href="#461204" title="Int">depth</a>, <a href="#463437" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="#463449" title="Types.this.Type">res</a>
            <a href="#463449" title="Types.this.Type">res</a>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="463120">glb1</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="463464">ts0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a href="#463472" title="(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</a><a href="#463471" title="List[Types.this.Type]" id="463472">ts</a>, <a href="#463471" title="List[Types.this.Symbol]" id="463473">tparams</a><span class="delimiter">)</span> = <a href="#67627" title="(ts: List[Types.this.Type])(List[Types.this.Type], List[Types.this.Symbol])">stripExistentialsAndTypeVars</a><span title="(List[Types.this.Type], List[Types.this.Symbol]) @unchecked" class="delimiter">(</span><a href="#463464" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="463474">glbOwner</a> = <a href="#67650" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#463472" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="(t: Types.this.Type)List[Types.this.Type]" id="463475">refinedToParents</a><span class="delimiter">(</span><a title="Types.this.Type" id="463496">t</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#463496" title="Types.this.Type">t</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="List[Types.this.Type]">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="463497">ps</a>, _<span class="delimiter">)</span> =&gt; <a href="#463497" title="List[Types.this.Type]">ps</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">flatMap</span> <a href="#463475" title="(t: Types.this.Type)List[Types.this.Type]">refinedToParents</a>
          <span class="keyword">case</span> <span title="List[Types.this.Type]">_</span> =&gt; <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#463496" title="Types.this.Type">t</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(t: Types.this.Type)List[Types.this.Scope]" id="463476">refinedToDecls</a><span class="delimiter">(</span><a title="Types.this.Type" id="463549">t</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="List[Types.this.Scope]">List</span><span class="delimiter">[</span>Scope<span class="delimiter">]</span> = <a href="#463549" title="Types.this.Type">t</a> <span title="List[Types.this.Scope]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="List[Types.this.Scope]">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="463550">ps</a>, <a title="Types.this.Scope" id="463551">decls</a><span class="delimiter">)</span> =&gt; 
            <span class="keyword">val</span> <a title="List[Types.this.Scope]" id="463552">dss</a> = <a href="#463550" title="List[Types.this.Type]">ps</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Scope])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Scope,List[Types.this.Scope]])List[Types.this.Scope]">flatMap</span> <a href="#463476" title="(t: Types.this.Type)List[Types.this.Scope]">refinedToDecls</a>
            <span title="List[Types.this.Scope]" class="keyword">if</span> <span class="delimiter">(</span><a href="#463551" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112943" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#463552" title="List[Types.this.Scope]">dss</a> <span class="keyword">else</span> <a href="#463551" title="Types.this.Scope">decls</a> <a href="#463597" title="(x: Types.this.Scope)List[Types.this.Scope]">::</a> <a href="#463552" title="List[Types.this.Scope]">dss</a>
          <span class="keyword">case</span> <span title="List[Nothing]">_</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="463477">ts1</a> = <a href="#463472" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">flatMap</span> <a href="#463475" title="(t: Types.this.Type)List[Types.this.Type]">refinedToParents</a> 
        <span class="keyword">val</span> <a title="Types.this.Type" id="463478">glbBase</a> = <a href="#67476" title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="#463477" title="List[Types.this.Type]">ts1</a>, <a href="#463474" title="Types.this.Symbol">glbOwner</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="463479">glbType</a> = 
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#461204" title="Int">depth</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#463478" title="Types.this.Type">glbBase</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="463662">glbRefined</a> = <a href="#67470" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#463477" title="List[Types.this.Type]">ts1</a>, <a href="#463474" title="Types.this.Symbol">glbOwner</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="463663">glbThisType</a> = <a href="#463662" title="Types.this.Type">glbRefined</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#107459" title="=&gt; Types.this.Type">thisType</a>
            <span class="keyword">def</span> <a title="(proto: Types.this.Symbol)Types.this.Symbol" id="463664">glbsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="463669">proto</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="463670">prototp</a> = <a href="#463663" title="Types.this.Type">glbThisType</a>.<a href="#105360" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#463669" title="Types.this.Symbol">proto</a><span class="delimiter">)</span>
              <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="463671">syms</a> = <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="463683">t</a> &lt;- <a href="#463472" title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">ts</a>;
                    <a title="Types.this.Symbol" id="463698">alt</a> &lt;- <span class="delimiter">(</span><a href="#463683" title="Types.this.Type">t</a>.<a href="#105355" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#463669" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107450" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">alternatives</a><span class="delimiter">)</span>;
                <span class="keyword">if</span> <a href="#463663" title="Types.this.Type">glbThisType</a>.<a href="#105360" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#463698" title="Types.this.Symbol">alt</a><span class="delimiter">)</span> <a href="#105381" title="(that: Types.this.Type)Boolean">matches</a> <a href="#463670" title="Types.this.Type">prototp</a>
              <span class="delimiter">)</span> <span class="keyword">yield</span> <a href="#463698" title="Types.this.Symbol">alt</a>
              <span class="keyword">val</span> <a title="List[Types.this.Type]" id="463672">symtypes</a> = <a href="#463671" title="List[Types.this.Symbol]">syms</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#463663" title="Types.this.Type">glbThisType</a>.<a href="#105360" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a>
              <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#463672" title="List[Types.this.Type]">symtypes</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
              <a href="#463669" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#107454" title="(owner: Types.this.Symbol)Types.this.Symbol">cloneSymbol</a><span class="delimiter">(</span><a href="#463662" title="Types.this.Type">glbRefined</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107426" title="(info: Types.this.Type)Types.this.Symbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span>
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#463669" title="Types.this.Symbol">proto</a>.<span title="=&gt; Boolean">isTerm</span><span class="delimiter">)</span> <a href="#67648" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#463672" title="List[Types.this.Type]">symtypes</a>, <a href="#67364" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#461204" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span class="delimiter">{</span>
                  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="463809">isTypeBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="463813">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#463813" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
                    <span class="keyword">case</span> <span title="Boolean(true)">TypeBounds</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
                    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span> 
                  <span class="delimiter">}</span>
                  <span class="keyword">def</span> <a title="(bnds: List[Types.this.Type])Types.this.TypeBounds" id="463810">glbBounds</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="463814">bnds</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#148453" title="Types.this.TypeBounds">TypeBounds</a> = <span class="delimiter">{</span>
                    <span class="keyword">val</span> <a title="Types.this.Type" id="463815">lo</a> = <a href="#67639" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#463814" title="List[Types.this.Type]">bnds</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#463837" title="Types.this.Type">_</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148467" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#67364" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#461204" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="keyword">val</span> <a title="Types.this.Type" id="463816">hi</a> = <a href="#67648" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#463814" title="List[Types.this.Type]">bnds</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#463879" title="Types.this.Type">_</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#148468" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#67364" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#461204" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span title="Types.this.TypeBounds" class="keyword">if</span> <span class="delimiter">(</span><a href="#463815" title="Types.this.Type">lo</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#463816" title="Types.this.Type">hi</a><span class="delimiter">)</span> <a href="#148437" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#463815" title="Types.this.Type">lo</a>, <a href="#463816" title="Types.this.Type">hi</a><span class="delimiter">)</span>
                    <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <a href="#67640" title="=&gt; java.lang.Throwable">GlbFailure</a>
                  <span class="delimiter">}</span>
                  <span class="keyword">val</span> <a title="List[Types.this.Type]" id="463811">symbounds</a> = <a href="#463672" title="List[Types.this.Type]">symtypes</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <a href="#463809" title="(tp: Types.this.Type)Boolean">isTypeBound</a>
                  <span class="keyword">var</span> <a title="Types.this.Type" id="463812">result</a>: <a href="#67381" title="Types.this.Type">Type</a> =
                    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#463811" title="List[Types.this.Type]">symbounds</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
                      <a href="#67412" title="object Types.this.TypeBounds">TypeBounds</a>.<a href="#148434" title="=&gt; Types.this.TypeBounds">empty</a>
                    <span class="keyword">else</span> <a href="#463810" title="(bnds: List[Types.this.Type])Types.this.TypeBounds">glbBounds</a><span class="delimiter">(</span><a href="#463811" title="List[Types.this.Type]">symbounds</a><span class="delimiter">)</span>
                  <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="463919">t</a> &lt;- <a href="#463672" title="(f: Types.this.Type =&gt; Unit)Unit">symtypes</a> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#463809" title="(tp: Types.this.Type)Boolean">isTypeBound</a><span class="delimiter">(</span><a href="#463919" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#463812" title="Types.this.Type">result</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a> <a href="#148449" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#463919" title="Types.this.Type">t</a><span class="delimiter">)</span> <a href="#463812" title="Types.this.Type">result</a> = <a href="#463919" title="Types.this.Type">t</a>
                    <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <a href="#67640" title="=&gt; java.lang.Throwable">GlbFailure</a>
                  <a href="#463812" title="Types.this.Type">result</a>
                <span class="delimiter">}</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#67643" title="=&gt; Int">globalGlbDepth</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(2)">globalGlbLimit</span><span class="delimiter">)</span>
              <span class="keyword">try</span> <span class="delimiter">{</span>
                <a href="#67643" title="(x$1: Int)Unit">globalGlbDepth</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
                <span class="keyword">val</span> <a title="List[Types.this.Scope]" id="463925">dss</a> = <a href="#463472" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Scope])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Scope,List[Types.this.Scope]])List[Types.this.Scope]">flatMap</span> <a href="#463476" title="(t: Types.this.Type)List[Types.this.Scope]">refinedToDecls</a>
                <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Scope" id="463987">ds</a> &lt;- <a href="#463925" title="(f: Types.this.Scope =&gt; Unit)Unit">dss</a>; <span class="keyword">val</span> <a title="Types.this.Symbol" id="463998">sym</a> &lt;- <a href="#463987" title="Types.this.Scope">ds</a>.<a href="Scopes.scala.html#112959" title="(f: Types.this.Symbol =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span> 
                  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#67643" title="=&gt; Int">globalGlbDepth</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(2)">globalGlbLimit</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#463663" title="Types.this.Type">glbThisType</a> <a href="#105380" title="(sym: Types.this.Symbol)Boolean">specializes</a> <a href="#463998" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="keyword">try</span> <span class="delimiter">{</span>
                      <a href="#67652" title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol)Unit">addMember</a><span class="delimiter">(</span><a href="#463663" title="Types.this.Type">glbThisType</a>, <a href="#463662" title="Types.this.Type">glbRefined</a>, <a href="#463664" title="(proto: Types.this.Symbol)Types.this.Symbol">glbsym</a><span class="delimiter">(</span><a href="#463998" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
                      <span class="keyword">case</span> <a title="Unit" id="464003">ex</a>: <a href="#67659" title="Types.this.NoCommonType">NoCommonType</a> =&gt;
                    <span class="delimiter">}</span> 
              <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                <a href="#67643" title="(x$1: Int)Unit">globalGlbDepth</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
              <span class="delimiter">}</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#463662" title="Types.this.Type">glbRefined</a>.<a href="#105346" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#112943" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#463478" title="Types.this.Type">glbBase</a> <span class="keyword">else</span> <a href="#463662" title="Types.this.Type">glbRefined</a>
          <span class="delimiter">}</span>
        <a href="#67482" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#463473" title="List[Types.this.Symbol]">tparams</a>, <a href="#463479" title="Types.this.Type">glbType</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="#67640" title="Types.this.Type">GlbFailure</a> =&gt;
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461203" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.Type" id="464017">t</a> =&gt; <a href="Definitions.scala.html#106085" title="=&gt; Types.this.Symbol">NullClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#464017" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Definitions.scala.html#106085" title="=&gt; Types.this.Symbol">NullClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
          <span class="keyword">else</span> <a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="comment">// if (settings.debug.value) { println(indent + &quot;glb of &quot; + ts + &quot; at depth &quot;+depth); indent = indent + &quot;  &quot; } //DEBUG</span>

    <span class="keyword">val</span> <a title="Types.this.Type" id="463121">res</a> = <a href="#463119" title="(ts0: List[Types.this.Type])Types.this.Type">glb0</a><span class="delimiter">(</span><a href="#461203" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>

    <span class="comment">// if (settings.debug.value) { indent = indent.substring(0, indent.length() - 2); log(indent + &quot;glb of &quot; + ts + &quot; is &quot; + res) }//DEBUG</span>

    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#461203" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#464024" title="Types.this.Type">_</a>.<a href="#105307" title="=&gt; Boolean">isNotNull</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#463121" title="Types.this.Type">res</a>.<a href="#105338" title="=&gt; Types.this.Type">notNull</a> <span class="keyword">else</span> <a href="#463121" title="Types.this.Type">res</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The most deeply nested owner that contains all the symbols
   *  of thistype or prefixless typerefs/singletype occurrences in given type.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(t: Types.this.Type)Types.this.Symbol" id="67649">commonOwner</a><span class="delimiter">(</span><a title="Types.this.Type" id="449619">t</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
    <a href="#67546" title="object Types.this.commonOwnerMap">commonOwnerMap</a>.<a href="#459603" title="()Unit">init</a>
    <a href="#67546" title="object Types.this.commonOwnerMap">commonOwnerMap</a>.<a href="#459604" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#449619" title="Types.this.Type">t</a><span class="delimiter">)</span>
    <a href="#67546" title="object Types.this.commonOwnerMap">commonOwnerMap</a>.<a href="#459601" title="=&gt; Types.this.Symbol">result</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The most deeply nested owner that contains all the symbols
   *  of thistype or prefixless typerefs/singletype occurrences in given list
   *  of types.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type])Types.this.Symbol" id="67650">commonOwner</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="449617">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
    <span class="comment">// if (settings.debug.value) log(&quot;computing common owner of types &quot; + tps)//DEBUG</span>
    <a href="#67546" title="object Types.this.commonOwnerMap">commonOwnerMap</a>.<a href="#459603" title="()Unit">init</a>
    <a href="#449617" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="Types.this.Type" id="464045">tp</a> =&gt; <a href="#67546" title="object Types.this.commonOwnerMap">commonOwnerMap</a>.<a href="#459604" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#464045" title="Types.this.Type">tp</a><span class="delimiter">)</span>; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#67546" title="object Types.this.commonOwnerMap">commonOwnerMap</a>.<a href="#459601" title="=&gt; Types.this.Symbol">result</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Compute lub (if variance == 1) or glb (if variance == -1) of given list
   *  of types `tps'. All types in `tps' are typerefs or singletypes
   *  with the same symbol.
   *  Return `Some(x)' if the computation succeeds with result `x'.
   *  Return `None' if the computation fails.
   */</span>
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], variance: Int, depth: Int)Option[Types.this.Type]" id="67651">mergePrefixAndArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="419296">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="419297">variance</a>: <span title="Int">Int</span>, <a title="Int" id="419298">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Option[Types.this.Type]">Option</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#419296" title="List[Types.this.Type]">tps</a> <span title="Option[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#464048" title="Some[Types.this.Type]">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="464059">tp</a><span class="delimiter">)</span> =&gt;
      <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#464059" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Option[Types.this.Type]">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="464067">sym</a>, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="464068">rest</a> =&gt;
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="464069">pres</a> = <a href="#419296" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#464089" title="Types.this.Type">_</a>.<a href="#105323" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span> <span class="comment">// prefix normalizes automatically</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="464070">pre</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#419297" title="Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#67639" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#464069" title="List[Types.this.Type]">pres</a>, <a href="#419298" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#67648" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#464069" title="List[Types.this.Type]">pres</a>, <a href="#419298" title="Int">depth</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="464071">argss</a> = <a href="#419296" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a href="#464139" title="Types.this.Type">_</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a>.<a href="#105326" title="=&gt; List[Types.this.Type]">typeArgs</a><span class="delimiter">)</span> <span class="comment">// symbol equality (of the tp in tps) was checked using typeSymbol, which normalizes, so should normalize before retrieving arguments</span>
      <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[Types.this.Symbol]" id="464072">capturedParams</a> = <span title="scala.collection.mutable.ListBuffer[Types.this.Symbol]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">ListBuffer</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464067" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106253" title="=&gt; Types.this.Symbol">ArrayClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="comment">// special treatment for lubs of array types after erasure:</span>
          <span class="comment">// if argss contain one value type and some other type, the lub is Object</span>
          <span class="comment">// if argss contain several reference types, the lub is an array over lub of argtypes</span>
          <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464071" title="List[List[Types.this.Type]]">argss</a> <span title="(p: List[Types.this.Type] =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#464177" title="List[Types.this.Type]">_</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="object None">None</span>  <span class="comment">// something is wrong: an array without a type arg.</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[Types.this.Type]" id="464178">args</a> = <a href="#464071" title="List[List[Types.this.Type]]">argss</a> <span title="(f: List[Types.this.Type] =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#464195" title="List[Types.this.Type]">_</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span>
            <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464178" title="List[Types.this.Type]">args</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#464231" title="Types.this.Type">_</a> <a href="#105379" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#464178" title="List[Types.this.Type]">args</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#67472" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#464070" title="Types.this.Type">pre</a>, <a href="#464067" title="Types.this.Symbol">sym</a>, <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#464178" title="List[Types.this.Type]">args</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword">else</span> <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464178" title="List[Types.this.Type]">args</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a title="Types.this.Type" id="464248">arg</a> =&gt; <a href="Definitions.scala.html#106520" title="(sym: Types.this.Symbol)Boolean">isValueClass</a><span class="delimiter">(</span><a href="#464248" title="Types.this.Type">arg</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="Definitions.scala.html#106079" title="=&gt; Types.this.Symbol">ObjectClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#67472" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#464070" title="Types.this.Type">pre</a>, <a href="#464067" title="Types.this.Symbol">sym</a>, <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#67638" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#464178" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="464266">args</a> = <span title="(_1: List[Types.this.Symbol], _2: List[List[Types.this.Type]])(List[Types.this.Symbol], List[List[Types.this.Type]])" class="delimiter">(</span><a href="#464067" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#464071" title="List[List[Types.this.Type]]">argss</a>.<span title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.TraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</span><span class="delimiter">)</span>.<span title="(implicit w1: List[Types.this.Symbol] =&gt; scala.collection.TraversableLike[Types.this.Symbol,List[Types.this.Symbol]], implicit w2: List[List[Types.this.Type]] =&gt; scala.collection.IterableLike[List[Types.this.Type],List[List[Types.this.Type]]])(List[Types.this.Symbol], List[List[Types.this.Type]])#Zipped[List[Types.this.Symbol],Types.this.Symbol,List[List[Types.this.Type]],List[Types.this.Type]]">zipped</span> <span title="(f: (Types.this.Symbol, List[Types.this.Type]) =&gt; Types.this.Type)(implicit cbf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="464353">tparam</a>, <a title="List[Types.this.Type]" id="464354">as</a><span class="delimiter">)</span> =&gt;
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#419298" title="Int">depth</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#464353" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107399" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <a href="#419297" title="Int">variance</a><span class="delimiter">)</span> <a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
                <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#464353" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107399" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="=&gt; Int">-</span><a href="#419297" title="Int">variance</a><span class="delimiter">)</span> <a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
                <span class="keyword">else</span> <a href="#450850" title="object Types.this.NoType">NoType</a>
              <span class="keyword">else</span> <span class="delimiter">{</span>
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#464353" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107399" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <a href="#419297" title="Int">variance</a><span class="delimiter">)</span> <a href="#67639" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#464354" title="List[Types.this.Type]">as</a>, <a href="#67364" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#419298" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#464353" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107399" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="=&gt; Int">-</span><a href="#419297" title="Int">variance</a><span class="delimiter">)</span> <a href="#67648" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#464354" title="List[Types.this.Type]">as</a>, <a href="#67364" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#419298" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span class="delimiter">{</span>
                  <span class="keyword">val</span> <a title="Types.this.Type" id="464387">l</a> = <a href="#67639" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#464354" title="List[Types.this.Type]">as</a>, <a href="#67364" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#419298" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  <span class="keyword">val</span> <a title="Types.this.Type" id="464388">g</a> = <a href="#67648" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#464354" title="List[Types.this.Type]">as</a>, <a href="#67364" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#419298" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#464387" title="Types.this.Type">l</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#464388" title="Types.this.Type">g</a><span class="delimiter">)</span> <a href="#464387" title="Types.this.Type">l</a>
                  <span class="keyword">else</span> <span class="delimiter">{</span> <span class="comment">// Martin: I removed this, because incomplete. Not sure there is a good way to fix it. For the moment we</span>
                         <span class="comment">// just err on the conservative side, i.e. with a bound that is too high.</span>
                         <span class="comment">// if(!(tparam.info.bounds contains tparam)){ //@M can't deal with f-bounds, see #2251</span>

                    <span class="keyword">val</span> <a title="Types.this.Symbol" id="464397">qvar</a> = <a href="#67650" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#464354" title="List[Types.this.Type]">as</a><span class="delimiter">)</span> <a href="Symbols.scala.html#107304" title="(suffix: String)Types.this.Symbol">freshExistential</a> <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span> <a href="Symbols.scala.html#107425" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a> <a href="#148437" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#464388" title="Types.this.Type">g</a>, <a href="#464387" title="Types.this.Type">l</a><span class="delimiter">)</span>
                    <a href="#464072" title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">capturedParams</a> <span title="(x: Types.this.Symbol)capturedParams.type">+=</span> <a href="#464397" title="Types.this.Symbol">qvar</a>
                    <a href="#464397" title="Types.this.Symbol">qvar</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
                  <span class="delimiter">}</span>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464266" title="List[Types.this.Type]">args</a> <span title="(elem: Any)Boolean">contains</span> <a href="#450850" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="object None">None</span>
          <span class="keyword">else</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#67482" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#464072" title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">capturedParams</a>.<span title="=&gt; List[Types.this.Symbol]">toList</span>, <a href="#67472" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#464070" title="Types.this.Type">pre</a>, <a href="#464067" title="Types.this.Symbol">sym</a>, <a href="#464266" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="None.type" id="464443">ex</a>: <a href="#67660" title="Types.this.MalformedType">MalformedType</a> =&gt; <span title="object None">None</span>
        <span class="keyword">case</span> <a title="None.type" id="464444">ex</a>: <span title="IndexOutOfBoundsException">IndexOutOfBoundsException</span> =&gt;  <span class="comment">// transpose freaked out because of irregular argss</span>
        <span class="comment">// catching just in case (shouldn't happen, but also doesn't cost us)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="SymbolTable.scala.html#64778" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;transposed irregular matrix!?&quot;)" class="string">&quot;transposed irregular matrix!?&quot;</span><span title="(x$1: Any)java.lang.String">+</span> <span class="delimiter">(</span><a href="#419296" title="List[Types.this.Type]">tps</a>, <a href="#464071" title="List[List[Types.this.Type]]">argss</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="object None">None</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> <span title="Option[Types.this.Type]">SingleType</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="464458">sym</a><span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="464459">rest</a> =&gt;
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="464460">pres</a> = <a href="#419296" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#464478" title="Types.this.Type">_</a>.<a href="#105323" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="464461">pre</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#419297" title="Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#67639" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#464460" title="List[Types.this.Type]">pres</a>, <a href="#419298" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#67648" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#464460" title="List[Types.this.Type]">pres</a>, <a href="#419298" title="Int">depth</a><span class="delimiter">)</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#67468" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#464461" title="Types.this.Type">pre</a>, <a href="#464458" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="None.type" id="464521">ex</a>: <a href="#67660" title="Types.this.MalformedType">MalformedType</a> =&gt; <span title="object None">None</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> <span title="Option[Types.this.Type]">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="464526">tparams</a>, <a title="Types.this.Type" id="464527">quantified</a><span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="464528">rest</a> =&gt;
      <a href="#67651" title="(tps: List[Types.this.Type], variance: Int, depth: Int)Option[Types.this.Type]">mergePrefixAndArgs</a><span class="delimiter">(</span><a href="#464527" title="Types.this.Type">quantified</a> <a href="#464529" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#464528" title="List[Types.this.Type]">rest</a>, <a href="#419297" title="Int">variance</a>, <a href="#419298" title="Int">depth</a><span class="delimiter">)</span> <span title="(f: Types.this.Type =&gt; Types.this.Type)Option[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#67482" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#464526" title="List[Types.this.Symbol]">tparams</a>, <a href="#464539" title="Types.this.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="None.type">_</span> =&gt;
      <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span>, <a href="#419296" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>; <span title="object None">None</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Make symbol `sym' a member of scope `tp.decls'
   *  where `thistp' is the narrowed owner type of the scope.
   */</span>
  <span class="keyword">def</span> <a title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol)Unit" id="67652">addMember</a><span class="delimiter">(</span><a title="Types.this.Type" id="446184">thistp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="446185">tp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="446186">sym</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#446186" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
    <span class="comment">// if (settings.debug.value) log(&quot;add member &quot; + sym+&quot;:&quot;+sym.info+&quot; to &quot;+thistp) //DEBUG</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#446184" title="Types.this.Type">thistp</a> <a href="#105380" title="(sym: Types.this.Symbol)Boolean">specializes</a> <a href="#446186" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#446186" title="Types.this.Symbol">sym</a>.<span title="=&gt; Boolean">isTerm</span><span class="delimiter">)</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="464570">alt</a> &lt;- <a href="#446185" title="Types.this.Type">tp</a>.<a href="#105348" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateDecl</a><span class="delimiter">(</span><a href="#446186" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#107407" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#107450" title="(f: Types.this.Symbol =&gt; Unit)Unit">alternatives</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#67604" title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#446184" title="Types.this.Type">thistp</a>, <a href="#446186" title="Types.this.Symbol">sym</a>, <a href="#446184" title="Types.this.Type">thistp</a>, <a href="#464570" title="Types.this.Symbol">alt</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#446185" title="Types.this.Type">tp</a>.<a href="#105346" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#112952" title="(sym: Types.this.Symbol)Unit">unlink</a> <a href="#464570" title="Types.this.Symbol">alt</a>;
      <a href="#446185" title="Types.this.Type">tp</a>.<a href="#105346" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#112946" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#446186" title="Types.this.Symbol">sym</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** All types in list must be polytypes with type parameter lists of
   *  same length as tparams.
   *  Returns list of list of bounds infos, where corresponding type
   *  parameters are renamed to tparams.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[List[Types.this.Type]]" id="67653">matchingBounds</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="462209">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="462210">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[List[Types.this.Type]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)List[Types.this.Type]" id="464592">getBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="464593">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#464593" title="Types.this.Type">tp</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="List[Types.this.Type]">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="464594">tparams1</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#464594" title="List[Types.this.Symbol]">tparams1</a>, <a href="#462210" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> =&gt;
        <a href="#464594" title="List[Types.this.Symbol]">tparams1</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="464613">tparam</a> =&gt; <a href="#464613" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#464594" title="List[Types.this.Symbol]">tparams1</a>, <a href="#462210" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="List[Types.this.Type]" id="464641">tp</a> =&gt;
        <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464641" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#464641" title="Types.this.Type">tp</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#464592" title="(tp: Types.this.Type)List[Types.this.Type]">getBounds</a><span class="delimiter">(</span><a href="#464641" title="Types.this.Type">tp</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <span title="Types.this.NoCommonType" class="keyword">new</span> <a href="#67659" title="Types.this.NoCommonType">NoCommonType</a><span class="delimiter">(</span><a href="#462209" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#462209" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <a href="#464592" title="(tp: Types.this.Type)List[Types.this.Type]">getBounds</a>
  <span class="delimiter">}</span>

  <span class="comment">/** All types in list must be polytypes with type parameter lists of
   *  same length as tparams.
   *  Returns list of instance types, where corresponding type
   *  parameters are renamed to tparams.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]" id="67654">matchingInstTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="462343">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="462344">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="464687">transformResultType</a><span class="delimiter">(</span><a title="Types.this.Type" id="464688">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#464688" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="464689">tparams1</a>, <a title="Types.this.Type" id="464690">restpe</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#464689" title="List[Types.this.Symbol]">tparams1</a>, <a href="#462344" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> =&gt;
        <a href="#464690" title="Types.this.Type">restpe</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#464689" title="List[Types.this.Symbol]">tparams1</a>, <a href="#462344" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="464693">tp</a> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#464693" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#464693" title="Types.this.Type">tp</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#464687" title="(tp: Types.this.Type)Types.this.Type">transformResultType</a><span class="delimiter">(</span><a href="#464693" title="Types.this.Type">tp</a>.<a href="#105342" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <span title="Types.this.NoCommonType" class="keyword">new</span> <a href="#67659" title="Types.this.NoCommonType">NoCommonType</a><span class="delimiter">(</span><a href="#462343" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#462343" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#464687" title="(tp: Types.this.Type)Types.this.Type">transformResultType</a>
  <span class="delimiter">}</span>

  <span class="comment">/** All types in list must be method types with equal parameter types.
   *  Returns list of their result types.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]" id="67655">matchingRestypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="462353">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="462354">pts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> =
    <a href="#462353" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#464754" title="Types.this.Type" class="delimiter">{</a>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="464755">params1</a>, <a title="Types.this.Type" id="464756">res</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#67572" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span><a href="#464755" title="List[Types.this.Symbol]">params1</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#464773" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>, <a href="#462354" title="List[Types.this.Type]">pts</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <a href="#464756" title="Types.this.Type">res</a>
      <span class="keyword">case</span> <span title="Types.this.Type">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="464801">res</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#462354" title="List[Types.this.Type]">pts</a> <span title="=&gt; Boolean">isEmpty</span> =&gt;
        <a href="#464801" title="Types.this.Type">res</a>
      <span class="keyword">case</span> <span title="Nothing">_</span> =&gt;
        <span title="Nothing" class="keyword">throw</span> <span title="Types.this.NoCommonType" class="keyword">new</span> <a href="#67659" title="Types.this.NoCommonType">NoCommonType</a><span class="delimiter">(</span><a href="#462353" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>


  <span class="comment">// TODO: this desperately needs to be cleaned up</span>
  <span class="comment">// plan: split into kind inference and subkinding</span>
  <span class="comment">// every Type has a (cached) Kind</span>
  <span class="keyword">def</span> <a title="(tparams: List[Types.this.Symbol], targs: List[Types.this.Type], pre: Types.this.Type, owner: Types.this.Symbol)Boolean" id="67656">kindsConform</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="460836">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="460837">targs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Type" id="460838">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="460839">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#67657" title="(tparams: List[Types.this.Symbol], targs: List[Types.this.Type], pre: Types.this.Type, owner: Types.this.Symbol, explainErrors: Boolean)List[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]">checkKindBounds0</a><span class="delimiter">(</span><a href="#460836" title="List[Types.this.Symbol]">tparams</a>, <a href="#460837" title="List[Types.this.Type]">targs</a>, <a href="#460838" title="Types.this.Type">pre</a>, <a href="#460839" title="Types.this.Symbol">owner</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>.<span title="=&gt; Boolean">isEmpty</span>

  <span class="comment">/** Check well-kindedness of type application (assumes arities are already checked) -- @M
   * 
   * This check is also performed when abstract type members become concrete (aka a &quot;type alias&quot;) -- then tparams.length==1
   * (checked one type member at a time -- in that case, prefix is the name of the type alias)
   *
   * Type application is just like value application: it's &quot;contravariant&quot; in the sense that 
   * the type parameters of the supplied type arguments must conform to the type parameters of 
   * the required type parameters:
   *   - their bounds must be less strict
   *   - variances must match (here, variances are absolute, the variance of a type parameter does not influence the variance of its higher-order parameters)     
   *   - @M TODO: are these conditions correct,sufficient&amp;necessary?
   *
   *  e.g. class Iterable[t, m[+x &lt;: t]] --&gt; the application Iterable[Int, List] is okay, since 
   *       List's type parameter is also covariant and its bounds are weaker than &lt;: Int
   */</span>
  <span class="keyword">def</span> <a title="(tparams: List[Types.this.Symbol], targs: List[Types.this.Type], pre: Types.this.Type, owner: Types.this.Symbol, explainErrors: Boolean)List[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]" id="67657">checkKindBounds0</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="464829">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="464830">targs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Type" id="464831">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="464832">owner</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Boolean" id="464833">explainErrors</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="List[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]">List</span><span class="delimiter">[</span><span class="delimiter">(</span>Type, Symbol, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="Boolean" id="464840">error</a> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="464841">transform</a><span class="delimiter">(</span><a title="Types.this.Type" id="464846">tp</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="464847">clazz</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> = <a href="#464846" title="Types.this.Type">tp</a>.<a href="#105359" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#464831" title="Types.this.Type">pre</a>, <a href="#464847" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <span class="comment">// instantiate type params that come from outside the abstract type we're currently checking</span>
    <span class="keyword">def</span> <a title="(p: Types.this.Symbol, o: Types.this.Symbol)Types.this.Type" id="464842">transformedBounds</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="464848">p</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="464849">o</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#464841" title="(tp: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#464848" title="Types.this.Symbol">p</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105339" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#464829" title="List[Types.this.Symbol]">tparams</a>, <a href="#464830" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>, <a href="#464849" title="Types.this.Symbol">o</a><span class="delimiter">)</span>

    <span class="comment">/** Check whether &lt;arg&gt;sym1&lt;/arg&gt;'s variance conforms to &lt;arg&gt;sym2&lt;/arg&gt;'s variance
     *
     * If &lt;arg&gt;sym2&lt;/arg&gt; is invariant, &lt;arg&gt;sym1&lt;/arg&gt;'s variance is irrelevant. Otherwise they must be equal.
     */</span>
    <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean" id="464843">variancesMatch</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="464850">sym1</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="464851">sym2</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#464851" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107399" title="=&gt; Int">variance</a><span title="(x: Int)Boolean">==</span><span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#464850" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#107399" title="=&gt; Int">variance</a><span title="(x: Int)Boolean">==</span><a href="#464851" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#107399" title="=&gt; Int">variance</a><span class="delimiter">)</span>

    <span class="comment">// check that the type parameters &lt;arg&gt;hkargs&lt;/arg&gt; to a higher-kinded type conform to the expected params &lt;arg&gt;hkparams&lt;/arg&gt;</span>
    <span class="keyword">def</span> <a title="(hkargs: List[Types.this.Symbol], arg: Types.this.Symbol, param: Types.this.Symbol, paramowner: Types.this.Symbol, underHKParams: List[Types.this.Symbol], withHKArgs: List[Types.this.Symbol])(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" id="464844">checkKindBoundsHK</a><span class="delimiter">(</span>
      <a title="List[Types.this.Symbol]" id="464862">hkargs</a>:        <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
      <a title="Types.this.Symbol" id="464863">arg</a>:           <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>,
      <a title="Types.this.Symbol" id="464864">param</a>:         <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>,
      <a title="Types.this.Symbol" id="464865">paramowner</a>:    <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>,
      <a title="List[Types.this.Symbol]" id="464866">underHKParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
      <a title="List[Types.this.Symbol]" id="464867">withHKArgs</a>:    <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
    <span class="delimiter">)</span>: <span title="(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" class="delimiter">(</span>List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      
      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="464868">bindHKParams</a><span class="delimiter">(</span><a title="Types.this.Type" id="464870">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#464870" title="Types.this.Type">tp</a>.<a href="#105364" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#464866" title="List[Types.this.Symbol]">underHKParams</a>, <a href="#464867" title="List[Types.this.Symbol]">withHKArgs</a><span class="delimiter">)</span>
      <span class="comment">// @M sometimes hkargs != arg.typeParams, the symbol and the type may have very different type parameters</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="464869">hkparams</a> = <a href="#464864" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>

      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="SymbolTable.scala.html#64778" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;checkKindBoundsHK expected: &quot;)" class="string">&quot;checkKindBoundsHK expected: &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#464864" title="Types.this.Symbol">param</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; with params &quot;)" class="string">&quot; with params &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#464869" title="List[Types.this.Symbol]">hkparams</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; by definition in &quot;)" class="string">&quot; by definition in &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#464865" title="Types.this.Symbol">paramowner</a><span class="delimiter">)</span>
        <a href="SymbolTable.scala.html#64778" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;checkKindBoundsHK supplied: &quot;)" class="string">&quot;checkKindBoundsHK supplied: &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#464863" title="Types.this.Symbol">arg</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; with params &quot;)" class="string">&quot; with params &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#464862" title="List[Types.this.Symbol]">hkargs</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; from &quot;)" class="string">&quot; from &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#464832" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
        <a href="SymbolTable.scala.html#64778" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;checkKindBoundsHK under params: &quot;)" class="string">&quot;checkKindBoundsHK under params: &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#464866" title="List[Types.this.Symbol]">underHKParams</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; with args &quot;)" class="string">&quot; with args &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#464867" title="List[Types.this.Symbol]">withHKArgs</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span title="(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#67573" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#464862" title="List[Types.this.Symbol]">hkargs</a>, <a href="#464869" title="List[Types.this.Symbol]">hkparams</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" class="keyword">if</span> <span class="delimiter">(</span><a href="#464863" title="Types.this.Symbol">arg</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="#464863" title="Types.this.Symbol">arg</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106087" title="=&gt; Types.this.Symbol">NothingClass</a><span class="delimiter">)</span> <span title="(_1: scala.collection.immutable.Nil.type, _2: scala.collection.immutable.Nil.type, _3: scala.collection.immutable.Nil.type)(scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type)" class="delimiter">(</span><span title="object Nil">Nil</span>, <span title="object Nil">Nil</span>, <span title="object Nil">Nil</span><span class="delimiter">)</span> <span class="comment">// Any and Nothing are kind-overloaded</span>
        <span class="keyword">else</span> <span class="delimiter">{</span><a href="#464840" title="Boolean">error</a> = <span title="Boolean(true)" class="keyword">true</span>; <span title="(_1: List[(Types.this.Symbol, Types.this.Symbol)], _2: scala.collection.immutable.Nil.type, _3: scala.collection.immutable.Nil.type)(List[(Types.this.Symbol, Types.this.Symbol)], scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type)" class="delimiter">(</span><span title="(xs: (Types.this.Symbol, Types.this.Symbol)*)List[(Types.this.Symbol, Types.this.Symbol)]">List</span><span class="delimiter">(</span><span title="(_1: Types.this.Symbol, _2: Types.this.Symbol)(Types.this.Symbol, Types.this.Symbol)" class="delimiter">(</span><a href="#464863" title="Types.this.Symbol">arg</a>, <a href="#464864" title="Types.this.Symbol">param</a><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="object Nil">Nil</span>, <span title="object Nil">Nil</span><span class="delimiter">)</span> <span class="delimiter">}</span> <span class="comment">// shortcut: always set error, whether explainTypesOrNot</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" id="464928">_arityMismatches</a>    = <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464833" title="Boolean">explainErrors</a><span class="delimiter">)</span> <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">ListBuffer</span><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span> <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>
        <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" id="464929">_varianceMismatches</a> = <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464833" title="Boolean">explainErrors</a><span class="delimiter">)</span> <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">ListBuffer</span><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span> <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>
        <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" id="464930">_stricterBounds</a>     = <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#464833" title="Boolean">explainErrors</a><span class="delimiter">)</span> <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">ListBuffer</span><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span> <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>
        
        <span class="keyword">def</span> <a title="(a: Types.this.Symbol, p: Types.this.Symbol)Unit" id="464931">varianceMismatch</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="464940">a</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="464941">p</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#464833" title="Boolean">explainErrors</a><span class="delimiter">)</span> <a href="#464929" title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">_varianceMismatches</a> <span title="(x: (Types.this.Symbol, Types.this.Symbol))_varianceMismatches.type">+=</span> <span class="delimiter">(</span><span title="(_1: Types.this.Symbol, _2: Types.this.Symbol)(Types.this.Symbol, Types.this.Symbol)" class="delimiter">(</span><a href="#464940" title="Types.this.Symbol">a</a>, <a href="#464941" title="Types.this.Symbol">p</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#464840" title="Boolean">error</a> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(a: Types.this.Symbol, p: Types.this.Symbol)Unit" id="464932">stricterBound</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="464957">a</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="464958">p</a>: <a href="Symbols.scala.html#67320" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#464833" title="Boolean">explainErrors</a><span class="delimiter">)</span> <a href="#464930" title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">_stricterBounds</a> <span title="(x: (Types.this.Symbol, Types.this.Symbol))_stricterBounds.type">+=</span> <span class="delimiter">(</span><span title="(_1: Types.this.Symbol, _2: Types.this.Symbol)(Types.this.Symbol, Types.this.Symbol)" class="delimiter">(</span><a href="#464957" title="Types.this.Symbol">a</a>, <a href="#464958" title="Types.this.Symbol">p</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#464840" title="Boolean">error</a> = <span title="Boolean(true)" class="keyword">true</span> <span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(as: Iterable[(Types.this.Symbol, Types.this.Symbol)])Unit" id="464933">arityMismatches</a><span class="delimiter">(</span><a title="Iterable[(Types.this.Symbol, Types.this.Symbol)]" id="464974">as</a>: <span title="Iterable[(Types.this.Symbol, Types.this.Symbol)]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#464833" title="Boolean">explainErrors</a><span class="delimiter">)</span> <a href="#464928" title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">_arityMismatches</a> <span title="(xs: scala.collection.TraversableOnce[(Types.this.Symbol, Types.this.Symbol)])_arityMismatches.type">++=</span> <a href="#464974" title="Iterable[(Types.this.Symbol, Types.this.Symbol)]">as</a> <span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(as: Iterable[(Types.this.Symbol, Types.this.Symbol)])Unit" id="464934">varianceMismatches</a><span class="delimiter">(</span><a title="Iterable[(Types.this.Symbol, Types.this.Symbol)]" id="464982">as</a>: <span title="Iterable[(Types.this.Symbol, Types.this.Symbol)]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#464833" title="Boolean">explainErrors</a><span class="delimiter">)</span> <a href="#464929" title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">_varianceMismatches</a> <span title="(xs: scala.collection.TraversableOnce[(Types.this.Symbol, Types.this.Symbol)])_varianceMismatches.type">++=</span> <a href="#464982" title="Iterable[(Types.this.Symbol, Types.this.Symbol)]">as</a> <span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(as: Iterable[(Types.this.Symbol, Types.this.Symbol)])Unit" id="464935">stricterBounds</a><span class="delimiter">(</span><a title="Iterable[(Types.this.Symbol, Types.this.Symbol)]" id="464990">as</a>: <span title="Iterable[(Types.this.Symbol, Types.this.Symbol)]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#464833" title="Boolean">explainErrors</a><span class="delimiter">)</span> <a href="#464930" title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">_stricterBounds</a> <span title="(xs: scala.collection.TraversableOnce[(Types.this.Symbol, Types.this.Symbol)])_stricterBounds.type">++=</span> <a href="#464990" title="Iterable[(Types.this.Symbol, Types.this.Symbol)]">as</a> <span class="delimiter">}</span>

        <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="465084">hkarg</a>, <a title="Types.this.Symbol" id="465085">hkparam</a><span class="delimiter">)</span> &lt;- <a href="#464862" title="List[Types.this.Symbol]">hkargs</a> <a href="#465055" title="(f: (Types.this.Symbol, Types.this.Symbol) =&gt; Unit)Unit">zip</a> <a href="#464869" title="List[Types.this.Symbol]">hkparams</a><span class="delimiter">)</span> <span class="delimiter">{</span> 
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#465085" title="Types.this.Symbol">hkparam</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#465084" title="Types.this.Symbol">hkarg</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// base-case: kind *</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#464843" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">variancesMatch</a><span class="delimiter">(</span><a href="#465084" title="Types.this.Symbol">hkarg</a>, <a href="#465085" title="Types.this.Symbol">hkparam</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#464931" title="(a: Types.this.Symbol, p: Types.this.Symbol)Unit">varianceMismatch</a><span class="delimiter">(</span><a href="#465084" title="Types.this.Symbol">hkarg</a>, <a href="#465085" title="Types.this.Symbol">hkparam</a><span class="delimiter">)</span>                                         

            <span class="comment">// instantiateTypeParams(tparams, targs) --&gt; higher-order bounds may contain references to type arguments</span>
            <span class="comment">// substSym(hkparams, hkargs) --&gt; these types are going to be compared as types of kind * </span>
            <span class="comment">//    --&gt; their arguments use different symbols, but are conceptually the same </span>
            <span class="comment">//        (could also replace the types by polytypes, but can't just strip the symbols, as ordering is lost then)</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="465088">declaredBounds</a>     = <a href="#464842" title="(p: Types.this.Symbol, o: Types.this.Symbol)Types.this.Type">transformedBounds</a><span class="delimiter">(</span><a href="#465085" title="Types.this.Symbol">hkparam</a>, <a href="#464865" title="Types.this.Symbol">paramowner</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="465089">declaredBoundsInst</a> = <a href="#464868" title="(tp: Types.this.Type)Types.this.Type">bindHKParams</a><span class="delimiter">(</span><a href="#465088" title="Types.this.Type">declaredBounds</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="465090">argumentBounds</a>     = <a href="#464841" title="(tp: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#465084" title="Types.this.Symbol">hkarg</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a>.<a href="#105321" title="=&gt; Types.this.TypeBounds">bounds</a>, <a href="#464832" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>            
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#465089" title="Types.this.Type">declaredBoundsInst</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#465090" title="Types.this.Type">argumentBounds</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#464932" title="(a: Types.this.Symbol, p: Types.this.Symbol)Unit">stricterBound</a><span class="delimiter">(</span><a href="#465084" title="Types.this.Symbol">hkarg</a>, <a href="#465085" title="Types.this.Symbol">hkparam</a><span class="delimiter">)</span>

            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="SymbolTable.scala.html#64778" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span>
              <span title="java.lang.String(&quot;checkKindBoundsHK base case: &quot;)" class="string">&quot;checkKindBoundsHK base case: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#465085" title="Types.this.Symbol">hkparam</a> <span title="(x$1: Any)java.lang.String">+</span>
              <span title="java.lang.String(&quot; declared bounds: &quot;)" class="string">&quot; declared bounds: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#465088" title="Types.this.Type">declaredBounds</a> <span title="(x$1: Any)java.lang.String">+</span>
              <span title="java.lang.String(&quot; after instantiating earlier hkparams: &quot;)" class="string">&quot; after instantiating earlier hkparams: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#465089" title="Types.this.Type">declaredBoundsInst</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;\012&quot;)" class="string">&quot;\n&quot;</span> <span title="(x$1: Any)java.lang.String">+</span>
              <span title="java.lang.String(&quot;checkKindBoundsHK base case: &quot;)" class="string">&quot;checkKindBoundsHK base case: &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#465084" title="Types.this.Symbol">hkarg</a> <span title="(x$1: Any)java.lang.String">+</span> 
              <span title="java.lang.String(&quot; has bounds: &quot;)" class="string">&quot; has bounds: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#465090" title="Types.this.Type">argumentBounds</a>
            <span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#36760" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">debug</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span>
              <a href="SymbolTable.scala.html#64778" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;checkKindBoundsHK recursing to compare params of &quot;)" class="string">&quot;checkKindBoundsHK recursing to compare params of &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#465085" title="Types.this.Symbol">hkparam</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; with &quot;)" class="string">&quot; with &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#465084" title="Types.this.Symbol">hkarg</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a href="#465095" title="(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" class="delimiter">(</a><a href="#465094" title="List[(Types.this.Symbol, Types.this.Symbol)]" id="465095">am</a>, <a href="#465094" title="List[(Types.this.Symbol, Types.this.Symbol)]" id="465096">vm</a>, <a href="#465094" title="List[(Types.this.Symbol, Types.this.Symbol)]" id="465097">sb</a><span class="delimiter">)</span> = <a href="#464844" title="(hkargs: List[Types.this.Symbol], arg: Types.this.Symbol, param: Types.this.Symbol, paramowner: Types.this.Symbol, underHKParams: List[Types.this.Symbol], withHKArgs: List[Types.this.Symbol])(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])">checkKindBoundsHK</a><span title="(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)]) @unchecked" class="delimiter">(</span>
              <a href="#465084" title="Types.this.Symbol">hkarg</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>,
              <a href="#465084" title="Types.this.Symbol">hkarg</a>,
              <a href="#465085" title="Types.this.Symbol">hkparam</a>,
              <a href="#464865" title="Types.this.Symbol">paramowner</a>, 
              <a href="#464866" title="List[Types.this.Symbol]">underHKParams</a> <span title="(that: scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">++</span> <a href="#465085" title="Types.this.Symbol">hkparam</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>,
              <a href="#464867" title="List[Types.this.Symbol]">withHKArgs</a> <span title="(that: scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">++</span> <a href="#465084" title="Types.this.Symbol">hkarg</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>
            <span class="delimiter">)</span>
            <a href="#464933" title="(as: Iterable[(Types.this.Symbol, Types.this.Symbol)])Unit">arityMismatches</a><span class="delimiter">(</span><a href="#465095" title="List[(Types.this.Symbol, Types.this.Symbol)]">am</a><span class="delimiter">)</span>
            <a href="#464934" title="(as: Iterable[(Types.this.Symbol, Types.this.Symbol)])Unit">varianceMismatches</a><span class="delimiter">(</span><a href="#465096" title="List[(Types.this.Symbol, Types.this.Symbol)]">vm</a><span class="delimiter">)</span>
            <a href="#464935" title="(as: Iterable[(Types.this.Symbol, Types.this.Symbol)])Unit">stricterBounds</a><span class="delimiter">(</span><a href="#465097" title="List[(Types.this.Symbol, Types.this.Symbol)]">sb</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#464833" title="Boolean">explainErrors</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#464840" title="Boolean">error</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="(_1: scala.collection.immutable.Nil.type, _2: scala.collection.immutable.Nil.type, _3: scala.collection.immutable.Nil.type)(scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type)" class="delimiter">(</span><span title="object Nil">Nil</span>, <span title="object Nil">Nil</span>, <span title="object Nil">Nil</span><span class="delimiter">)</span> <span class="comment">// stop as soon as we encountered an error</span>
        <span class="delimiter">}</span>
        <span title="(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#464833" title="Boolean">explainErrors</a><span class="delimiter">)</span> <span title="(_1: scala.collection.immutable.Nil.type, _2: scala.collection.immutable.Nil.type, _3: scala.collection.immutable.Nil.type)(scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type)" class="delimiter">(</span><span title="object Nil">Nil</span>, <span title="object Nil">Nil</span>, <span title="object Nil">Nil</span><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="(_1: List[(Types.this.Symbol, Types.this.Symbol)], _2: List[(Types.this.Symbol, Types.this.Symbol)], _3: List[(Types.this.Symbol, Types.this.Symbol)])(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" class="delimiter">(</span><a href="#464928" title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">_arityMismatches</a>.<span title="=&gt; List[(Types.this.Symbol, Types.this.Symbol)]">toList</span>, <a href="#464929" title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">_varianceMismatches</a>.<span title="=&gt; List[(Types.this.Symbol, Types.this.Symbol)]">toList</span>, <a href="#464930" title="scala.collection.mutable.ListBuffer[(Types.this.Symbol, Types.this.Symbol)]">_stricterBounds</a>.<span title="=&gt; List[(Types.this.Symbol, Types.this.Symbol)]">toList</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>    
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]" id="464845">errors</a> = <span title="scala.collection.mutable.ListBuffer[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]">ListBuffer</span><span class="delimiter">[</span><span class="delimiter">(</span>Type, Symbol, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#464829" title="List[Types.this.Symbol]">tparams</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#464830" title="List[Types.this.Type]">targs</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span>
      <a href="SymbolTable.scala.html#64778" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="java.lang.String(&quot;checkKindBounds0(&quot;)" class="string">&quot;checkKindBounds0(&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#464829" title="List[Types.this.Symbol]">tparams</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#464830" title="List[Types.this.Type]">targs</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#464831" title="Types.this.Type">pre</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#464832" title="Types.this.Symbol">owner</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#464833" title="Boolean">explainErrors</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>

    <span class="keyword">for</span> <span class="delimiter">{</span>
      <span class="delimiter">(</span><a title="Types.this.Symbol" id="465332">tparam</a>, <a title="Types.this.Type" id="465333">targ</a><span class="delimiter">)</span> &lt;- <a href="#464829" title="List[Types.this.Symbol]">tparams</a> <a href="#465305" title="(f: (Types.this.Symbol, Types.this.Type) =&gt; Any)Unit">zip</a> <a href="#464830" title="List[Types.this.Type]">targs</a>
      <span class="comment">// Prevent WildcardType from causing kind errors, as typevars may be higher-order</span>
      <span class="keyword">if</span> <span class="delimiter">(</span><a href="#465333" title="Types.this.Type">targ</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#450801" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#465333" title="Types.this.Type">targ</a>.<a href="#105304" title="=&gt; Boolean">isHigherKinded</a> <span title="(x: Boolean)Boolean">||</span> <a href="#465332" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="delimiter">{</span>
      <span class="comment">// @M must use the typeParams of the *type* targ, not of the *symbol* of targ!!</span>
      <a href="#465333" title="Types.this.Type">targ</a>.<a href="#105315" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>.<a href="Symbols.scala.html#107423" title="=&gt; Types.this.Type">info</a> <span class="comment">// force symbol load for #4205</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="465334">tparamsHO</a> = <a href="#465333" title="Types.this.Type">targ</a>.<a href="#105336" title="=&gt; List[Types.this.Symbol]">typeParams</a>

      <span class="keyword">val</span> <a href="#465336" title="(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" class="delimiter">(</a><a href="#465335" title="List[(Types.this.Symbol, Types.this.Symbol)]" id="465336">arityMismatches</a>, <a href="#465335" title="List[(Types.this.Symbol, Types.this.Symbol)]" id="465337">varianceMismatches</a>, <a href="#465335" title="List[(Types.this.Symbol, Types.this.Symbol)]" id="465338">stricterBounds</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
        <span class="comment">// NOTE: *not* targ.typeSymbol, which normalizes</span>
        <a href="#464844" title="(hkargs: List[Types.this.Symbol], arg: Types.this.Symbol, param: Types.this.Symbol, paramowner: Types.this.Symbol, underHKParams: List[Types.this.Symbol], withHKArgs: List[Types.this.Symbol])(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])">checkKindBoundsHK</a><span title="(List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)]) @unchecked" class="delimiter">(</span><a href="#465334" title="List[Types.this.Symbol]">tparamsHO</a>, <a href="#465333" title="Types.this.Type">targ</a>.<a href="#105315" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>, <a href="#465332" title="Types.this.Symbol">tparam</a>, <a href="#465332" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107400" title="=&gt; Types.this.Symbol">owner</a>, <a href="#465332" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#107438" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#465334" title="List[Types.this.Symbol]">tparamsHO</a><span class="delimiter">)</span>
      <span class="delimiter">)</span>
      <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#464833" title="Boolean">explainErrors</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#465336" title="List[(Types.this.Symbol, Types.this.Symbol)]">arityMismatches</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#465337" title="List[(Types.this.Symbol, Types.this.Symbol)]">varianceMismatches</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#465338" title="List[(Types.this.Symbol, Types.this.Symbol)]">stricterBounds</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#464845" title="scala.collection.mutable.ListBuffer[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]">errors</a> <span title="(x: (Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)]))errors.type">+=</span> <span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.Symbol, _3: List[(Types.this.Symbol, Types.this.Symbol)], _4: List[(Types.this.Symbol, Types.this.Symbol)], _5: List[(Types.this.Symbol, Types.this.Symbol)])(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])" class="delimiter">(</span><a href="#465333" title="Types.this.Type">targ</a>, <a href="#465332" title="Types.this.Symbol">tparam</a>, <a href="#465336" title="List[(Types.this.Symbol, Types.this.Symbol)]">arityMismatches</a>, <a href="#465337" title="List[(Types.this.Symbol, Types.this.Symbol)]">varianceMismatches</a>, <a href="#465338" title="List[(Types.this.Symbol, Types.this.Symbol)]">stricterBounds</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#464840" title="Boolean">error</a><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">return</span> <span title="(xs: (Types.this.NoType.type, Types.this.NoSymbol.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type)*)List[(Types.this.NoType.type, Types.this.NoSymbol.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type)]">List</span><span class="delimiter">(</span><span title="(_1: Types.this.NoType.type, _2: Types.this.NoSymbol.type, _3: scala.collection.immutable.Nil.type, _4: scala.collection.immutable.Nil.type, _5: scala.collection.immutable.Nil.type)(Types.this.NoType.type, Types.this.NoSymbol.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type)" class="delimiter">(</span><a href="#450850" title="object Types.this.NoType">NoType</a>, <a href="Symbols.scala.html#67328" title="object Types.this.NoSymbol">NoSymbol</a>, <span title="object Nil">Nil</span>, <span title="object Nil">Nil</span>, <span title="object Nil">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  
    <a href="#464845" title="scala.collection.mutable.ListBuffer[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]">errors</a>.<span title="=&gt; List[(Types.this.Type, Types.this.Symbol, List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)], List[(Types.this.Symbol, Types.this.Symbol)])]">toList</span>
  <span class="delimiter">}</span>

<span class="comment">// Errors and Diagnostics -----------------------------------------------------</span>

  <span class="comment">/** A throwable signalling a type error */</span>
  <span class="keyword">class</span> <a title="class TypeError extends java.lang.Throwable with ScalaObject" id="67658">TypeError</a><a href="#67658" title="ScalaObject" class="delimiter">(</a><span class="keyword">var</span> <a title="Types.this.Position" id="411454">pos</a>: <a href="../util/Position.scala.html#30599" title="Types.this.Position">Position</a>, <span class="keyword">val</span> <a title="String" id="411455">msg</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="java.lang.Throwable">Throwable</span><span class="delimiter">(</span><a href="#411455" title="String">msg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(msg: String)Types.this.TypeError" id="313894" class="keyword">this</a><span class="delimiter">(</span><a title="String" id="411453">msg</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#67658" title="TypeError.this.type" class="keyword">this</a><span class="delimiter">(</span><a href="Positions.scala.html#67891" title="=&gt; tools.nsc.util.NoPosition.type">NoPosition</a>, <a href="#411453" title="String">msg</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class NoCommonType extends java.lang.Throwable with scala.util.control.ControlThrowable with ScalaObject" id="67659">NoCommonType</a><a href="#67659" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Type]" id="464642">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="java.lang.Throwable">Throwable</span><span class="delimiter">(</span>
    <span title="java.lang.String(&quot;lub/glb of incompatible types: &quot;)" class="string">&quot;lub/glb of incompatible types: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#464642" title="List[Types.this.Type]">tps</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="java.lang.String(&quot; and &quot;)" class="string">&quot; and &quot;</span>, <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">with</span> <span title="scala.util.control.ControlThrowable">ControlThrowable</span>

  <span class="comment">/** A throwable signalling a malformed type */</span>
  <span class="keyword">class</span> <a title="class MalformedType extends Types.this.TypeError with ScalaObject" id="67660">MalformedType</a><a href="#313894" title="ScalaObject" class="delimiter">(</a><a title="String" id="459738">msg</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67658" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><a href="#459738" title="String">msg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, tp: String)Types.this.MalformedType" id="458678" class="keyword">this</a><span class="delimiter">(</span><a title="Types.this.Type" id="459736">pre</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="String" id="459737">tp</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#67660" title="MalformedType.this.type" class="keyword">this</a><span class="delimiter">(</span><span title="java.lang.String(&quot;malformed type: &quot;)" class="string">&quot;malformed type: &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#459736" title="Types.this.Type">pre</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;#&quot;)" class="string">&quot;#&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#459737" title="String">tp</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An exception signalling a variance annotation/usage conflict */</span>
  <span class="keyword">class</span> <a title="class VarianceError extends Types.this.TypeError with ScalaObject" id="67661">VarianceError</a><a href="#313894" title="ScalaObject" class="delimiter">(</a><a title="String" id="465470">msg</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#67658" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><a href="#465470" title="String">msg</a><span class="delimiter">)</span>

  <span class="comment">/** The current indentation string for traces */</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="String" id="67663">indent</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>

  <span class="comment">/** Perform operation `p' on arguments `tp1',
   *  `arg2' and print trace of computation.
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T](op: String, p: (Types.this.Type, T) =&gt; Boolean, tp1: Types.this.Type, arg2: T)Boolean" id="67665">explain</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67667">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="449984">op</a>: <span title="String">String</span>, <a title="(Types.this.Type, T) =&gt; Boolean" id="449985">p</a>: <span class="delimiter">(</span>Type, T<span class="delimiter">)</span> =&gt; Boolean, <a title="Types.this.Type" id="449986">tp1</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="T" id="449987">arg2</a>: <a href="#67667" title="T">T</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span title="object Console">Console</span>.<span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#67663" title="=&gt; String">indent</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="#449986" title="Types.this.Type">tp1</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#449984" title="String">op</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#449987" title="T">arg2</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;?&quot;)" class="string">&quot;?&quot;</span> <span class="comment">/* + &quot;(&quot;+tp1.getClass+&quot;,&quot;+arg2.asInstanceOf[AnyRef].getClass+&quot;)&quot;*/</span><span class="delimiter">)</span>
    <a href="#67663" title="(x$1: String)Unit">indent</a> = <a href="#67663" title="=&gt; String">indent</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
    <span class="keyword">val</span> <a title="Boolean" id="465474">result</a> = <a href="#449985" title="(v1: Types.this.Type, v2: T)Boolean">p</a><span class="delimiter">(</span><a href="#449986" title="Types.this.Type">tp1</a>, <a href="#449987" title="T">arg2</a><span class="delimiter">)</span>
    <a href="#67663" title="(x$1: String)Unit">indent</a> = <a href="#67663" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">indent</a> <span title="(n: Int)String">dropRight</span> <span title="Int(2)" class="int">2</span>
    <span title="object Console">Console</span>.<span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#67663" title="=&gt; String">indent</a> <span title="(x$1: Any)java.lang.String">+</span> <a href="#465474" title="Boolean">result</a><span class="delimiter">)</span>
    <a href="#465474" title="Boolean">result</a>
  <span class="delimiter">}</span>

  <span class="comment">/** If option `explaintypes' is set, print a subtype trace for
   *  `found &lt;:&lt; required'.
   */</span>
  <span class="keyword">def</span> <a title="(found: Types.this.Type, required: Types.this.Type)Unit" id="67668">explainTypes</a><span class="delimiter">(</span><a title="Types.this.Type" id="465490">found</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="465491">required</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/StandardScalaSettings.scala.html#36875" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">explaintypes</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#67670" title="(op: =&gt; Boolean)Boolean">withTypesExplained</a><span title="Unit" class="delimiter">(</span><a href="#465490" title="Types.this.Type">found</a> <a href="#105374" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#465491" title="Types.this.Type">required</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** If option `explaintypes' is set, print a subtype trace for
   *  `op(found, required)'.
   */</span>
  <span class="keyword">def</span> <a title="(op: (Types.this.Type, Types.this.Type) =&gt; Any, found: Types.this.Type, required: Types.this.Type)Unit" id="67669">explainTypes</a><span class="delimiter">(</span><a title="(Types.this.Type, Types.this.Type) =&gt; Any" id="465502">op</a>: <span class="delimiter">(</span>Type, Type<span class="delimiter">)</span> =&gt; Any, <a title="Types.this.Type" id="465503">found</a>: <a href="#67381" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="465504">required</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#64776" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/StandardScalaSettings.scala.html#36875" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">explaintypes</a>.<a href="../settings/MutableSettings.scala.html#42162" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#67670" title="(op: =&gt; Any)Any">withTypesExplained</a><span title="Unit" class="delimiter">(</span><a href="#465502" title="(v1: Types.this.Type, v2: Types.this.Type)Any">op</a><span class="delimiter">(</span><a href="#465503" title="Types.this.Type">found</a>, <a href="#465504" title="Types.this.Type">required</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Execute `op' while printing a trace of the operations on types executed.
   */</span>
  <span class="keyword">def</span> <a title="[A](op: =&gt; A)A" id="67670">withTypesExplained</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="67672">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="465496">op</a>: =&gt; A<span class="delimiter">)</span>: <a href="#67672" title="A">A</a> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Boolean" id="465514">s</a> = <a href="#67350" title="=&gt; Boolean">explainSwitch</a>
    <span class="keyword">try</span> <span class="delimiter">{</span> <a href="#67350" title="(x$1: Boolean)Unit">explainSwitch</a> = <span title="Boolean(true)" class="keyword">true</span>; <a href="#465496" title="=&gt; A">op</a> <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span> <a href="#67350" title="(x$1: Boolean)Unit">explainSwitch</a> = <a href="#465514" title="Boolean">s</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="67673">objToAny</a><span class="delimiter">(</span><a title="Types.this.Type" id="465515">tp</a>: <a href="#67381" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#67381" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#64795" title="=&gt; scala.tools.nsc.Phase">phase</a>.<a href="../Phase.scala.html#102841" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#465515" title="Types.this.Type">tp</a>.<a href="#105313" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#106079" title="=&gt; Types.this.Symbol">ObjectClass</a><span class="delimiter">)</span> <a href="Definitions.scala.html#106075" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#107421" title="=&gt; Types.this.Type">tpe</a>
    <span class="keyword">else</span> <a href="#465515" title="Types.this.Type">tp</a>

  <span class="keyword">val</span> <a title="scala.collection.immutable.Set[java.lang.String]" id="67674">shorthands</a> = <span title="(elems: java.lang.String*)scala.collection.immutable.Set[java.lang.String]">Set</span><span class="delimiter">(</span>
    <span title="java.lang.String(&quot;scala.collection.immutable.List&quot;)" class="string">&quot;scala.collection.immutable.List&quot;</span>, 
    <span title="java.lang.String(&quot;scala.collection.immutable.Nil&quot;)" class="string">&quot;scala.collection.immutable.Nil&quot;</span>,
    <span title="java.lang.String(&quot;scala.collection.Seq&quot;)" class="string">&quot;scala.collection.Seq&quot;</span>,
    <span title="java.lang.String(&quot;scala.collection.Traversable&quot;)" class="string">&quot;scala.collection.Traversable&quot;</span>,
    <span title="java.lang.String(&quot;scala.collection.Iterable&quot;)" class="string">&quot;scala.collection.Iterable&quot;</span>,
    <span title="java.lang.String(&quot;scala.collection.mutable.StringBuilder&quot;)" class="string">&quot;scala.collection.mutable.StringBuilder&quot;</span>,
    <span title="java.lang.String(&quot;scala.collection.IndexedSeq&quot;)" class="string">&quot;scala.collection.IndexedSeq&quot;</span>,
    <span title="java.lang.String(&quot;scala.collection.Iterator&quot;)" class="string">&quot;scala.collection.Iterator&quot;</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>