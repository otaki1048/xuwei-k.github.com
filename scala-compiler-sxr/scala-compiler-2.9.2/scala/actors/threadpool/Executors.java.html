<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/actors/threadpool/Executors.java</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/licenses/publicdomain
 */</span>

<span class="keyword">package</span> scala.actors.threadpool;
<span class="comment">//import edu.emory.mathcs.backport.java.util.*;</span>
<span class="keyword">import</span> java.security.AccessControlContext;
<span class="keyword">import</span> java.security.AccessController;
<span class="keyword">import</span> java.security.PrivilegedAction;
<span class="keyword">import</span> java.security.PrivilegedExceptionAction;
<span class="keyword">import</span> java.security.AccessControlException;
<span class="keyword">import</span> java.util.List;
<span class="keyword">import</span> java.util.Collection;

<span class="comment">/**
 * Factory and utility methods for {@link Executor}, {@link
 * ExecutorService}, {@link ScheduledExecutorService}, {@link
 * ThreadFactory}, and {@link Callable} classes defined in this
 * package. This class supports the following kinds of methods:
 *
 * &lt;ul&gt;
 *   &lt;li&gt; Methods that create and return an {@link ExecutorService}
 *        set up with commonly useful configuration settings.
 *   &lt;li&gt; Methods that create and return a {@link ScheduledExecutorService}
 *        set up with commonly useful configuration settings.
 *   &lt;li&gt; Methods that create and return a &quot;wrapped&quot; ExecutorService, that
 *        disables reconfiguration by making implementation-specific methods
 *        inaccessible.
 *   &lt;li&gt; Methods that create and return a {@link ThreadFactory}
 *        that sets newly created threads to a known state.
 *   &lt;li&gt; Methods that create and return a {@link Callable}
 *        out of other closure-like forms, so they can be used
 *        in execution methods requiring &lt;tt&gt;Callable&lt;/tt&gt;.
 * &lt;/ul&gt;
 *
 * @since 1.5
 * @author Doug Lea
 */</span>
public <span class="keyword">class</span> <a title="object scala.actors.threadpool.Executors" id="11725">Executors</a> <span class="delimiter">{</span>

    <span class="comment">/**
     * Creates a thread pool that reuses a fixed number of threads
     * operating off a shared unbounded queue.  At any point, at most
     * &lt;tt&gt;nThreads&lt;/tt&gt; threads will be active processing tasks.
     * If additional tasks are submitted when all threads are active,
     * they will wait in the queue until a thread is available.
     * If any thread terminates due to a failure during execution
     * prior to shutdown, a new one will take its place if needed to
     * execute subsequent tasks.  The threads in the pool will exist
     * until it is explicitly {@link ExecutorService#shutdown shutdown}.
     *
     * @param nThreads the number of threads in the pool
     * @return the newly created thread pool
     * @throws IllegalArgumentException if &lt;tt&gt;nThreads &amp;lt;= 0&lt;/tt&gt;
     */</span>
    public static <a href="ExecutorService.java.html#11800" title="scala.actors.threadpool.ExecutorService">ExecutorService</a> <a title="(nThreads: Int)scala.actors.threadpool.ExecutorService" id="3903721">newFixedThreadPool</a><span class="delimiter">(</span>int <a title="Int" id="3903757">nThreads</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor<span class="delimiter">(</span>nThreads, nThreads,
                                      <span class="long">0L</span>, TimeUnit.MILLISECONDS,
                                      <span class="keyword">new</span> LinkedBlockingQueue<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Creates a thread pool that reuses a fixed number of threads
     * operating off a shared unbounded queue, using the provided
     * ThreadFactory to create new threads when needed.  At any point,
     * at most &lt;tt&gt;nThreads&lt;/tt&gt; threads will be active processing
     * tasks.  If additional tasks are submitted when all threads are
     * active, they will wait in the queue until a thread is
     * available.  If any thread terminates due to a failure during
     * execution prior to shutdown, a new one will take its place if
     * needed to execute subsequent tasks.  The threads in the pool will
     * exist until it is explicitly {@link ExecutorService#shutdown
     * shutdown}.
     *
     * @param nThreads the number of threads in the pool
     * @param threadFactory the factory to use when creating new threads
     * @return the newly created thread pool
     * @throws NullPointerException if threadFactory is null
     * @throws IllegalArgumentException if &lt;tt&gt;nThreads &amp;lt;= 0&lt;/tt&gt;
     */</span>
    public static <a href="ExecutorService.java.html#11800" title="scala.actors.threadpool.ExecutorService">ExecutorService</a> <a title="(nThreads: Int, threadFactory: scala.actors.threadpool.ThreadFactory)scala.actors.threadpool.ExecutorService" id="3903722">newFixedThreadPool</a><span class="delimiter">(</span>int <a title="Int" id="3903759">nThreads</a>, <a href="ThreadFactory.java.html#11833" title="scala.actors.threadpool.ThreadFactory">ThreadFactory</a> <a title="scala.actors.threadpool.ThreadFactory" id="3903760">threadFactory</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor<span class="delimiter">(</span>nThreads, nThreads,
                                      <span class="long">0L</span>, TimeUnit.MILLISECONDS,
                                      <span class="keyword">new</span> LinkedBlockingQueue<span class="delimiter">(</span><span class="delimiter">)</span>,
                                      threadFactory<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Creates an Executor that uses a single worker thread operating
     * off an unbounded queue. (Note however that if this single
     * thread terminates due to a failure during execution prior to
     * shutdown, a new one will take its place if needed to execute
     * subsequent tasks.)  Tasks are guaranteed to execute
     * sequentially, and no more than one task will be active at any
     * given time. Unlike the otherwise equivalent
     * &lt;tt&gt;newFixedThreadPool(1)&lt;/tt&gt; the returned executor is
     * guaranteed not to be reconfigurable to use additional threads.
     *
     * @return the newly created single-threaded Executor
     */</span>
    public static <a href="ExecutorService.java.html#11800" title="scala.actors.threadpool.ExecutorService">ExecutorService</a> <a title="()scala.actors.threadpool.ExecutorService" id="3903723">newSingleThreadExecutor</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService
            <span class="delimiter">(</span><span class="keyword">new</span> ThreadPoolExecutor<span class="delimiter">(</span><span class="int">1</span>, <span class="int">1</span>,
                                    <span class="long">0L</span>, TimeUnit.MILLISECONDS,
                                    <span class="keyword">new</span> LinkedBlockingQueue<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Creates an Executor that uses a single worker thread operating
     * off an unbounded queue, and uses the provided ThreadFactory to
     * create a new thread when needed. Unlike the otherwise
     * equivalent &lt;tt&gt;newFixedThreadPool(1, threadFactory)&lt;/tt&gt; the
     * returned executor is guaranteed not to be reconfigurable to use
     * additional threads.
     *
     * @param threadFactory the factory to use when creating new
     * threads
     *
     * @return the newly created single-threaded Executor
     * @throws NullPointerException if threadFactory is null
     */</span>
    public static <a href="ExecutorService.java.html#11800" title="scala.actors.threadpool.ExecutorService">ExecutorService</a> <a title="(threadFactory: scala.actors.threadpool.ThreadFactory)scala.actors.threadpool.ExecutorService" id="3903724">newSingleThreadExecutor</a><span class="delimiter">(</span><a href="ThreadFactory.java.html#11833" title="scala.actors.threadpool.ThreadFactory">ThreadFactory</a> <a title="scala.actors.threadpool.ThreadFactory" id="3903763">threadFactory</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService
            <span class="delimiter">(</span><span class="keyword">new</span> ThreadPoolExecutor<span class="delimiter">(</span><span class="int">1</span>, <span class="int">1</span>,
                                    <span class="long">0L</span>, TimeUnit.MILLISECONDS,
                                    <span class="keyword">new</span> LinkedBlockingQueue<span class="delimiter">(</span><span class="delimiter">)</span>,
                                    threadFactory<span class="delimiter">)</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Creates a thread pool that creates new threads as needed, but
     * will reuse previously constructed threads when they are
     * available.  These pools will typically improve the performance
     * of programs that execute many short-lived asynchronous tasks.
     * Calls to &lt;tt&gt;execute&lt;/tt&gt; will reuse previously constructed
     * threads if available. If no existing thread is available, a new
     * thread will be created and added to the pool. Threads that have
     * not been used for sixty seconds are terminated and removed from
     * the cache. Thus, a pool that remains idle for long enough will
     * not consume any resources. Note that pools with similar
     * properties but different details (for example, timeout parameters)
     * may be created using {@link ThreadPoolExecutor} constructors.
     *
     * @return the newly created thread pool
     */</span>
    public static <a href="ExecutorService.java.html#11800" title="scala.actors.threadpool.ExecutorService">ExecutorService</a> <a title="()scala.actors.threadpool.ExecutorService" id="3903725">newCachedThreadPool</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor<span class="delimiter">(</span><span class="int">0</span>, Integer.MAX_VALUE,
                                      <span class="long">60L</span>, TimeUnit.SECONDS,
                                      <span class="keyword">new</span> SynchronousQueue<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Creates a thread pool that creates new threads as needed, but
     * will reuse previously constructed threads when they are
     * available, and uses the provided
     * ThreadFactory to create new threads when needed.
     * @param threadFactory the factory to use when creating new threads
     * @return the newly created thread pool
     * @throws NullPointerException if threadFactory is null
     */</span>
    public static <a href="ExecutorService.java.html#11800" title="scala.actors.threadpool.ExecutorService">ExecutorService</a> <a title="(threadFactory: scala.actors.threadpool.ThreadFactory)scala.actors.threadpool.ExecutorService" id="3903726">newCachedThreadPool</a><span class="delimiter">(</span><a href="ThreadFactory.java.html#11833" title="scala.actors.threadpool.ThreadFactory">ThreadFactory</a> <a title="scala.actors.threadpool.ThreadFactory" id="3903766">threadFactory</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor<span class="delimiter">(</span><span class="int">0</span>, Integer.MAX_VALUE,
                                      <span class="long">60L</span>, TimeUnit.SECONDS,
                                      <span class="keyword">new</span> SynchronousQueue<span class="delimiter">(</span><span class="delimiter">)</span>,
                                      threadFactory<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Creates a single-threaded executor that can schedule commands
     * to run after a given delay, or to execute periodically.
     * (Note however that if this single
     * thread terminates due to a failure during execution prior to
     * shutdown, a new one will take its place if needed to execute
     * subsequent tasks.)  Tasks are guaranteed to execute
     * sequentially, and no more than one task will be active at any
     * given time. Unlike the otherwise equivalent
     * &lt;tt&gt;newScheduledThreadPool(1)&lt;/tt&gt; the returned executor is
     * guaranteed not to be reconfigurable to use additional threads.
     * @return the newly created scheduled executor
     */</span>
    <span class="comment">/*    public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
        return new DelegatedScheduledExecutorService
            (new ScheduledThreadPoolExecutor(1));
    }
    */</span>
    <span class="comment">/**
     * Creates a single-threaded executor that can schedule commands
     * to run after a given delay, or to execute periodically.  (Note
     * however that if this single thread terminates due to a failure
     * during execution prior to shutdown, a new one will take its
     * place if needed to execute subsequent tasks.)  Tasks are
     * guaranteed to execute sequentially, and no more than one task
     * will be active at any given time. Unlike the otherwise
     * equivalent &lt;tt&gt;newScheduledThreadPool(1, threadFactory)&lt;/tt&gt;
     * the returned executor is guaranteed not to be reconfigurable to
     * use additional threads.
     * @param threadFactory the factory to use when creating new
     * threads
     * @return a newly created scheduled executor
     * @throws NullPointerException if threadFactory is null
     */</span>
    <span class="comment">/*    public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) {
        return new DelegatedScheduledExecutorService
            (new ScheduledThreadPoolExecutor(1, threadFactory));
    }
    */</span>
    <span class="comment">/**
     * Creates a thread pool that can schedule commands to run after a
     * given delay, or to execute periodically.
     * @param corePoolSize the number of threads to keep in the pool,
     * even if they are idle.
     * @return a newly created scheduled thread pool
     * @throws IllegalArgumentException if &lt;tt&gt;corePoolSize &amp;lt; 0&lt;/tt&gt;
     */</span>
    <span class="comment">/*    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }
    */</span>
    <span class="comment">/**
     * Creates a thread pool that can schedule commands to run after a
     * given delay, or to execute periodically.
     * @param corePoolSize the number of threads to keep in the pool,
     * even if they are idle.
     * @param threadFactory the factory to use when the executor
     * creates a new thread.
     * @return a newly created scheduled thread pool
     * @throws IllegalArgumentException if &lt;tt&gt;corePoolSize &amp;lt; 0&lt;/tt&gt;
     * @throws NullPointerException if threadFactory is null
     */</span>
    <span class="comment">/*    public static ScheduledExecutorService newScheduledThreadPool(
            int corePoolSize, ThreadFactory threadFactory) {
        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
    }
    */</span>

    <span class="comment">/**
     * Returns an object that delegates all defined {@link
     * ExecutorService} methods to the given executor, but not any
     * other methods that might otherwise be accessible using
     * casts. This provides a way to safely &quot;freeze&quot; configuration and
     * disallow tuning of a given concrete implementation.
     * @param executor the underlying implementation
     * @return an &lt;tt&gt;ExecutorService&lt;/tt&gt; instance
     * @throws NullPointerException if executor null
     */</span>
    public static <a href="ExecutorService.java.html#11800" title="scala.actors.threadpool.ExecutorService">ExecutorService</a> <a title="(executor: scala.actors.threadpool.ExecutorService)scala.actors.threadpool.ExecutorService" id="3903727">unconfigurableExecutorService</a><span class="delimiter">(</span><a href="ExecutorService.java.html#11800" title="scala.actors.threadpool.ExecutorService">ExecutorService</a> <a title="scala.actors.threadpool.ExecutorService" id="3903768">executor</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>executor == <span class="keyword">null</span><span class="delimiter">)</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedExecutorService<span class="delimiter">(</span>executor<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns an object that delegates all defined {@link
     * ScheduledExecutorService} methods to the given executor, but
     * not any other methods that might otherwise be accessible using
     * casts. This provides a way to safely &quot;freeze&quot; configuration and
     * disallow tuning of a given concrete implementation.
     * @param executor the underlying implementation
     * @return a &lt;tt&gt;ScheduledExecutorService&lt;/tt&gt; instance
     * @throws NullPointerException if executor null
     */</span>
    <span class="comment">/*    public static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor) {
        if (executor == null)
            throw new NullPointerException();
        return new DelegatedScheduledExecutorService(executor);
    }
    */</span>
    <span class="comment">/**
     * Returns a default thread factory used to create new threads.
     * This factory creates all new threads used by an Executor in the
     * same {@link ThreadGroup}. If there is a {@link
     * java.lang.SecurityManager}, it uses the group of {@link
     * System#getSecurityManager}, else the group of the thread
     * invoking this &lt;tt&gt;defaultThreadFactory&lt;/tt&gt; method. Each new
     * thread is created as a non-daemon thread with priority set to
     * the smaller of &lt;tt&gt;Thread.NORM_PRIORITY&lt;/tt&gt; and the maximum
     * priority permitted in the thread group.  New threads have names
     * accessible via {@link Thread#getName} of
     * &lt;em&gt;pool-N-thread-M&lt;/em&gt;, where &lt;em&gt;N&lt;/em&gt; is the sequence
     * number of this factory, and &lt;em&gt;M&lt;/em&gt; is the sequence number
     * of the thread created by this factory.
     * @return a thread factory
     */</span>
    public static <a href="ThreadFactory.java.html#11833" title="scala.actors.threadpool.ThreadFactory">ThreadFactory</a> <a title="()scala.actors.threadpool.ThreadFactory" id="3903728">defaultThreadFactory</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a thread factory used to create new threads that
     * have the same permissions as the current thread.
     * This factory creates threads with the same settings as {@link
     * Executors#defaultThreadFactory}, additionally setting the
     * AccessControlContext and contextClassLoader of new threads to
     * be the same as the thread invoking this
     * &lt;tt&gt;privilegedThreadFactory&lt;/tt&gt; method.  A new
     * &lt;tt&gt;privilegedThreadFactory&lt;/tt&gt; can be created within an
     * {@link AccessController#doPrivileged} action setting the
     * current thread's access control context to create threads with
     * the selected permission settings holding within that action.
     *
     * &lt;p&gt; Note that while tasks running within such threads will have
     * the same access control and class loader settings as the
     * current thread, they need not have the same {@link
     * java.lang.ThreadLocal} or {@link
     * java.lang.InheritableThreadLocal} values. If necessary,
     * particular values of thread locals can be set or reset before
     * any task runs in {@link ThreadPoolExecutor} subclasses using
     * {@link ThreadPoolExecutor#beforeExecute}. Also, if it is
     * necessary to initialize worker threads to have the same
     * InheritableThreadLocal settings as some other designated
     * thread, you can create a custom ThreadFactory in which that
     * thread waits for and services requests to create others that
     * will inherit its values.
     *
     * @return a thread factory
     * @throws AccessControlException if the current access control
     * context does not have permission to both get and set context
     * class loader.
     */</span>
    public static <a href="ThreadFactory.java.html#11833" title="scala.actors.threadpool.ThreadFactory">ThreadFactory</a> <a title="()scala.actors.threadpool.ThreadFactory" id="3903729">privilegedThreadFactory</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> PrivilegedThreadFactory<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a {@link Callable} object that, when
     * called, runs the given task and returns the given result.  This
     * can be useful when applying methods requiring a
     * &lt;tt&gt;Callable&lt;/tt&gt; to an otherwise resultless action.
     * @param task the task to run
     * @param result the result to return
     * @return a callable object
     * @throws NullPointerException if task null
     */</span>
    public static <a href="Callable.java.html#11722" title="scala.actors.threadpool.Callable">Callable</a> <a title="(task: java.lang.Runnable, result: Any)scala.actors.threadpool.Callable" id="3903730">callable</a><span class="delimiter">(</span>Runnable <a title="java.lang.Runnable" id="3903772">task</a>, Object <a title="Any" id="3903773">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>task == <span class="keyword">null</span><span class="delimiter">)</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter<span class="delimiter">(</span>task, result<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a {@link Callable} object that, when
     * called, runs the given task and returns &lt;tt&gt;null&lt;/tt&gt;.
     * @param task the task to run
     * @return a callable object
     * @throws NullPointerException if task null
     */</span>
    public static <a href="Callable.java.html#11722" title="scala.actors.threadpool.Callable">Callable</a> <a title="(task: java.lang.Runnable)scala.actors.threadpool.Callable" id="3903731">callable</a><span class="delimiter">(</span>Runnable <a title="java.lang.Runnable" id="3903775">task</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>task == <span class="keyword">null</span><span class="delimiter">)</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter<span class="delimiter">(</span>task, <span class="keyword">null</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a {@link Callable} object that, when
     * called, runs the given privileged action and returns its result.
     * @param action the privileged action to run
     * @return a callable object
     * @throws NullPointerException if action null
     */</span>
    public static <a href="Callable.java.html#11722" title="scala.actors.threadpool.Callable">Callable</a> <a title="(action: java.security.PrivilegedAction)scala.actors.threadpool.Callable" id="3903732">callable</a><span class="delimiter">(</span><span class="keyword">final</span> PrivilegedAction <a title="java.security.PrivilegedAction" id="3903777">action</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>action == <span class="keyword">null</span><span class="delimiter">)</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">return</span> <span class="keyword">new</span> Callable<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
	    public Object call<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">return</span> action.run<span class="delimiter">(</span><span class="delimiter">)</span>; <span class="delimiter">}</span><span class="delimiter">}</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a {@link Callable} object that, when
     * called, runs the given privileged exception action and returns
     * its result.
     * @param action the privileged exception action to run
     * @return a callable object
     * @throws NullPointerException if action null
     */</span>
    public static <a href="Callable.java.html#11722" title="scala.actors.threadpool.Callable">Callable</a> <a title="(action: java.security.PrivilegedExceptionAction)scala.actors.threadpool.Callable" id="3903733">callable</a><span class="delimiter">(</span><span class="keyword">final</span> PrivilegedExceptionAction <a title="java.security.PrivilegedExceptionAction" id="3903781">action</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>action == <span class="keyword">null</span><span class="delimiter">)</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
	<span class="keyword">return</span> <span class="keyword">new</span> Callable<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
	    public Object call<span class="delimiter">(</span><span class="delimiter">)</span> throws Exception <span class="delimiter">{</span> <span class="keyword">return</span> action.run<span class="delimiter">(</span><span class="delimiter">)</span>; <span class="delimiter">}</span><span class="delimiter">}</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a {@link Callable} object that will, when
     * called, execute the given &lt;tt&gt;callable&lt;/tt&gt; under the current
     * access control context. This method should normally be
     * invoked within an {@link AccessController#doPrivileged} action
     * to create callables that will, if possible, execute under the
     * selected permission settings holding within that action; or if
     * not possible, throw an associated {@link
     * AccessControlException}.
     * @param callable the underlying task
     * @return a callable object
     * @throws NullPointerException if callable null
     *
     */</span>
    public static <a href="Callable.java.html#11722" title="scala.actors.threadpool.Callable">Callable</a> <a title="(callable: scala.actors.threadpool.Callable)scala.actors.threadpool.Callable" id="3903734">privilegedCallable</a><span class="delimiter">(</span><a href="Callable.java.html#11722" title="scala.actors.threadpool.Callable">Callable</a> <a title="scala.actors.threadpool.Callable" id="3903785">callable</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>callable == <span class="keyword">null</span><span class="delimiter">)</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">return</span> <span class="keyword">new</span> PrivilegedCallable<span class="delimiter">(</span>callable<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a {@link Callable} object that will, when
     * called, execute the given &lt;tt&gt;callable&lt;/tt&gt; under the current
     * access control context, with the current context class loader
     * as the context class loader. This method should normally be
     * invoked within an {@link AccessController#doPrivileged} action
     * to create callables that will, if possible, execute under the
     * selected permission settings holding within that action; or if
     * not possible, throw an associated {@link
     * AccessControlException}.
     * @param callable the underlying task
     *
     * @return a callable object
     * @throws NullPointerException if callable null
     * @throws AccessControlException if the current access control
     * context does not have permission to both set and get context
     * class loader.
     */</span>
    public static <a href="Callable.java.html#11722" title="scala.actors.threadpool.Callable">Callable</a> <a title="(callable: scala.actors.threadpool.Callable)scala.actors.threadpool.Callable" id="3903735">privilegedCallableUsingCurrentClassLoader</a><span class="delimiter">(</span><a href="Callable.java.html#11722" title="scala.actors.threadpool.Callable">Callable</a> <a title="scala.actors.threadpool.Callable" id="3903787">callable</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>callable == <span class="keyword">null</span><span class="delimiter">)</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">return</span> <span class="keyword">new</span> PrivilegedCallableUsingCurrentClassLoader<span class="delimiter">(</span>callable<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">// Non-public classes supporting the public methods</span>

    <span class="comment">/**
     * A callable that runs given task and returns given result
     */</span>
    static <span class="keyword">final</span> <span class="keyword">class</span> <a title="object scala.actors.threadpool.Executors.RunnableAdapter" id="3903738">RunnableAdapter</a> implements Callable <span class="delimiter">{</span>
        <span class="keyword">final</span> Runnable task;
        <span class="keyword">final</span> Object result;
        RunnableAdapter<span class="delimiter">(</span>Runnable  task, Object result<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">this</span>.task = task;
            <span class="keyword">this</span>.result = result;
        <span class="delimiter">}</span>
        public Object call<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            task.run<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">return</span> result;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * A callable that runs under established access control settings
     */</span>
    static <span class="keyword">final</span> <span class="keyword">class</span> <a title="object scala.actors.threadpool.Executors.PrivilegedCallable" id="3903741">PrivilegedCallable</a> implements Callable <span class="delimiter">{</span>
        <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;
        <span class="keyword">private</span> <span class="keyword">final</span> Callable task;
        <span class="keyword">private</span> Object result;
        <span class="keyword">private</span> Exception exception;
        PrivilegedCallable<span class="delimiter">(</span>Callable task<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">this</span>.task = task;
            <span class="keyword">this</span>.acc = AccessController.getContext<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        public Object call<span class="delimiter">(</span><span class="delimiter">)</span> throws Exception <span class="delimiter">{</span>
            AccessController.doPrivileged<span class="delimiter">(</span><span class="keyword">new</span> PrivilegedAction<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    public Object run<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                        <span class="keyword">try</span> <span class="delimiter">{</span>
                            result = task.call<span class="delimiter">(</span><span class="delimiter">)</span>;
                        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>Exception ex<span class="delimiter">)</span> <span class="delimiter">{</span>
                            exception = ex;
                        <span class="delimiter">}</span>
                        <span class="keyword">return</span> <span class="keyword">null</span>;
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span>, acc<span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>exception != <span class="keyword">null</span><span class="delimiter">)</span>
                <span class="keyword">throw</span> exception;
            <span class="keyword">else</span>
                <span class="keyword">return</span> result;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * A callable that runs under established access control settings and
     * current ClassLoader
     */</span>
    static <span class="keyword">final</span> <span class="keyword">class</span> <a title="object scala.actors.threadpool.Executors.PrivilegedCallableUsingCurrentClassLoader" id="3903744">PrivilegedCallableUsingCurrentClassLoader</a> implements Callable <span class="delimiter">{</span>
        <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader ccl;
        <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;
        <span class="keyword">private</span> <span class="keyword">final</span> Callable task;
        <span class="keyword">private</span> Object result;
        <span class="keyword">private</span> Exception exception;
        PrivilegedCallableUsingCurrentClassLoader<span class="delimiter">(</span>Callable task<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">this</span>.task = task;
            <span class="keyword">this</span>.ccl = Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span>.getContextClassLoader<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">this</span>.acc = AccessController.getContext<span class="delimiter">(</span><span class="delimiter">)</span>;
            acc.checkPermission<span class="delimiter">(</span><span class="keyword">new</span> RuntimePermission<span class="delimiter">(</span><span class="string">&quot;getContextClassLoader&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>;
            acc.checkPermission<span class="delimiter">(</span><span class="keyword">new</span> RuntimePermission<span class="delimiter">(</span><span class="string">&quot;setContextClassLoader&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        public Object call<span class="delimiter">(</span><span class="delimiter">)</span> throws Exception <span class="delimiter">{</span>
            AccessController.doPrivileged<span class="delimiter">(</span><span class="keyword">new</span> PrivilegedAction<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    public Object run<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                        ClassLoader savedcl = <span class="keyword">null</span>;
                        Thread t = Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span>;
                        <span class="keyword">try</span> <span class="delimiter">{</span>
                            ClassLoader cl = t.getContextClassLoader<span class="delimiter">(</span><span class="delimiter">)</span>;
                            <span class="keyword">if</span> <span class="delimiter">(</span>ccl != cl<span class="delimiter">)</span> <span class="delimiter">{</span>
                                t.setContextClassLoader<span class="delimiter">(</span>ccl<span class="delimiter">)</span>;
                                savedcl = cl;
                            <span class="delimiter">}</span>
                            result = task.call<span class="delimiter">(</span><span class="delimiter">)</span>;
                        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>Exception ex<span class="delimiter">)</span> <span class="delimiter">{</span>
                            exception = ex;
                        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                            <span class="keyword">if</span> <span class="delimiter">(</span>savedcl != <span class="keyword">null</span><span class="delimiter">)</span>
                                t.setContextClassLoader<span class="delimiter">(</span>savedcl<span class="delimiter">)</span>;
                        <span class="delimiter">}</span>
                        <span class="keyword">return</span> <span class="keyword">null</span>;
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span>, acc<span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>exception != <span class="keyword">null</span><span class="delimiter">)</span>
                <span class="keyword">throw</span> exception;
            <span class="keyword">else</span>
                <span class="keyword">return</span> result;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * The default thread factory
     */</span>
    static <span class="keyword">class</span> <a title="object scala.actors.threadpool.Executors.DefaultThreadFactory" id="3903747">DefaultThreadFactory</a> implements ThreadFactory <span class="delimiter">{</span>
        static <span class="keyword">final</span> <a href="AtomicInteger.java.html#11839" title="scala.actors.threadpool.AtomicInteger">AtomicInteger</a> <a title="scala.actors.threadpool.AtomicInteger" id="3903793">poolNumber</a> = <span class="keyword">new</span> AtomicInteger<span class="delimiter">(</span><span class="int">1</span><span class="delimiter">)</span>;
        <span class="keyword">final</span> ThreadGroup group;
        <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger<span class="delimiter">(</span><span class="int">1</span><span class="delimiter">)</span>;
        <span class="keyword">final</span> String namePrefix;

        DefaultThreadFactory<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            SecurityManager s = System.getSecurityManager<span class="delimiter">(</span><span class="delimiter">)</span>;
            group = <span class="delimiter">(</span>s != <span class="keyword">null</span><span class="delimiter">)</span>? s.getThreadGroup<span class="delimiter">(</span><span class="delimiter">)</span> :
                                 Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span>.getThreadGroup<span class="delimiter">(</span><span class="delimiter">)</span>;
            namePrefix = <span class="string">&quot;pool-&quot;</span> +
                          poolNumber.getAndIncrement<span class="delimiter">(</span><span class="delimiter">)</span> +
                         <span class="string">&quot;-thread-&quot;</span>;
        <span class="delimiter">}</span>

        public Thread newThread<span class="delimiter">(</span>Runnable r<span class="delimiter">)</span> <span class="delimiter">{</span>
            Thread t = <span class="keyword">new</span> Thread<span class="delimiter">(</span>group, r,
                                  namePrefix + threadNumber.getAndIncrement<span class="delimiter">(</span><span class="delimiter">)</span>,
                                  <span class="int">0</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>t.isDaemon<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
                t.setDaemon<span class="delimiter">(</span><span class="keyword">false</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>t.getPriority<span class="delimiter">(</span><span class="delimiter">)</span> != Thread.NORM_PRIORITY<span class="delimiter">)</span>
                t.setPriority<span class="delimiter">(</span>Thread.NORM_PRIORITY<span class="delimiter">)</span>;
            <span class="keyword">return</span> t;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     *  Thread factory capturing access control and class loader
     */</span>
    static <span class="keyword">class</span> <a title="object scala.actors.threadpool.Executors.PrivilegedThreadFactory" id="3903750">PrivilegedThreadFactory</a> <span class="keyword">extends</span> DefaultThreadFactory <span class="delimiter">{</span>
        <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader ccl;
        <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;

        PrivilegedThreadFactory<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">super</span><span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">this</span>.ccl = Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span>.getContextClassLoader<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">this</span>.acc = AccessController.getContext<span class="delimiter">(</span><span class="delimiter">)</span>;
            acc.checkPermission<span class="delimiter">(</span><span class="keyword">new</span> RuntimePermission<span class="delimiter">(</span><span class="string">&quot;setContextClassLoader&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        public Thread newThread<span class="delimiter">(</span><span class="keyword">final</span> Runnable r<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> <span class="keyword">super</span>.newThread<span class="delimiter">(</span><span class="keyword">new</span> Runnable<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                public void run<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    AccessController.doPrivileged<span class="delimiter">(</span><span class="keyword">new</span> PrivilegedAction<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                        public Object run<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                            Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span>.setContextClassLoader<span class="delimiter">(</span>ccl<span class="delimiter">)</span>;
                            r.run<span class="delimiter">(</span><span class="delimiter">)</span>;
                            <span class="keyword">return</span> <span class="keyword">null</span>;
                        <span class="delimiter">}</span>
                    <span class="delimiter">}</span>, acc<span class="delimiter">)</span>;
                <span class="delimiter">}</span>
            <span class="delimiter">}</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

    <span class="delimiter">}</span>

    <span class="comment">/**
     * A wrapper class that exposes only the ExecutorService methods
     * of an ExecutorService implementation.
     */</span>
    static <span class="keyword">class</span> <a title="object scala.actors.threadpool.Executors.DelegatedExecutorService" id="3903753">DelegatedExecutorService</a> <span class="keyword">extends</span> AbstractExecutorService <span class="delimiter">{</span>
        <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService e;
        DelegatedExecutorService<span class="delimiter">(</span>ExecutorService executor<span class="delimiter">)</span> <span class="delimiter">{</span> e = executor; <span class="delimiter">}</span>
        public void execute<span class="delimiter">(</span>Runnable command<span class="delimiter">)</span> <span class="delimiter">{</span> e.execute<span class="delimiter">(</span>command<span class="delimiter">)</span>; <span class="delimiter">}</span>
        public void shutdown<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span> e.shutdown<span class="delimiter">(</span><span class="delimiter">)</span>; <span class="delimiter">}</span>
        public List shutdownNow<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">return</span> e.shutdownNow<span class="delimiter">(</span><span class="delimiter">)</span>; <span class="delimiter">}</span>
        public boolean isShutdown<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">return</span> e.isShutdown<span class="delimiter">(</span><span class="delimiter">)</span>; <span class="delimiter">}</span>
        public boolean isTerminated<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">return</span> e.isTerminated<span class="delimiter">(</span><span class="delimiter">)</span>; <span class="delimiter">}</span>
        public boolean awaitTermination<span class="delimiter">(</span>long timeout, TimeUnit unit<span class="delimiter">)</span>
            throws InterruptedException <span class="delimiter">{</span>
            <span class="keyword">return</span> e.awaitTermination<span class="delimiter">(</span>timeout, unit<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        public Future submit<span class="delimiter">(</span>Runnable task<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> e.submit<span class="delimiter">(</span>task<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        public Future submit<span class="delimiter">(</span>Callable task<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> e.submit<span class="delimiter">(</span>task<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        public Future submit<span class="delimiter">(</span>Runnable task, Object result<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> e.submit<span class="delimiter">(</span>task, result<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        public List&lt;Future&gt; invokeAll<span class="delimiter">(</span>Collection tasks<span class="delimiter">)</span>
            throws InterruptedException <span class="delimiter">{</span>
            <span class="keyword">return</span> e.invokeAll<span class="delimiter">(</span>tasks<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        public List&lt;Future&gt; invokeAll<span class="delimiter">(</span>Collection tasks,
                                      long timeout, TimeUnit unit<span class="delimiter">)</span>
            throws InterruptedException <span class="delimiter">{</span>
            <span class="keyword">return</span> e.invokeAll<span class="delimiter">(</span>tasks, timeout, unit<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        public Object invokeAny<span class="delimiter">(</span>Collection tasks<span class="delimiter">)</span>
            throws InterruptedException, ExecutionException <span class="delimiter">{</span>
            <span class="keyword">return</span> e.invokeAny<span class="delimiter">(</span>tasks<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        public Object invokeAny<span class="delimiter">(</span>Collection tasks,
                               long timeout, TimeUnit unit<span class="delimiter">)</span>
            throws InterruptedException, ExecutionException, TimeoutException <span class="delimiter">{</span>
            <span class="keyword">return</span> e.invokeAny<span class="delimiter">(</span>tasks, timeout, unit<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    static <span class="keyword">class</span> <a title="object scala.actors.threadpool.Executors.FinalizableDelegatedExecutorService" id="3903756">FinalizableDelegatedExecutorService</a>
	<span class="keyword">extends</span> DelegatedExecutorService <span class="delimiter">{</span>
	FinalizableDelegatedExecutorService<span class="delimiter">(</span>ExecutorService executor<span class="delimiter">)</span> <span class="delimiter">{</span>
	    <span class="keyword">super</span><span class="delimiter">(</span>executor<span class="delimiter">)</span>;
	<span class="delimiter">}</span>
	<span class="keyword">protected</span> void finalize<span class="delimiter">(</span><span class="delimiter">)</span>  <span class="delimiter">{</span>
	    <span class="keyword">super</span>.shutdown<span class="delimiter">(</span><span class="delimiter">)</span>;
	<span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * A wrapper class that exposes only the ScheduledExecutorService
     * methods of a ScheduledExecutorService implementation.
     */</span>
    <span class="comment">/*    static class DelegatedScheduledExecutorService
            extends DelegatedExecutorService
            implements ScheduledExecutorService {
        private final ScheduledExecutorService e;
        DelegatedScheduledExecutorService(ScheduledExecutorService executor) {
            super(executor);
            e = executor;
        }
        public ScheduledFuture schedule(Runnable command, long delay,  TimeUnit unit) {
            return e.schedule(command, delay, unit);
        }
        public ScheduledFuture schedule(Callable callable, long delay, TimeUnit unit) {
            return e.schedule(callable, delay, unit);
        }
        public ScheduledFuture scheduleAtFixedRate(Runnable command, long initialDelay,  long period, TimeUnit unit) {
            return e.scheduleAtFixedRate(command, initialDelay, period, unit);
        }
        public ScheduledFuture scheduleWithFixedDelay(Runnable command, long initialDelay,  long delay, TimeUnit unit) {
            return e.scheduleWithFixedDelay(command, initialDelay, delay, unit);
        }
    }
*/</span>

    <span class="comment">/** Cannot instantiate. */</span>
    <span class="keyword">private</span> Executors<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span><span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>