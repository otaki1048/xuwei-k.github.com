<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/actors/threadpool/SynchronousQueue.java</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/licenses/publicdomain
 */</span>

<span class="keyword">package</span> scala.actors.threadpool;
<span class="keyword">import</span> scala.actors.threadpool.locks.*;
<span class="comment">//import edu.emory.mathcs.backport.java.util.*;</span>
<span class="keyword">import</span> java.util.Collection;
<span class="keyword">import</span> java.util.Iterator;
<span class="keyword">import</span> scala.actors.threadpool.helpers.Utils;
<span class="keyword">import</span> java.util.NoSuchElementException;

<span class="comment">/**
 * A {@linkplain BlockingQueue blocking queue} in which each insert
 * operation must wait for a corresponding remove operation by another
 * thread, and vice versa.  A synchronous queue does not have any
 * internal capacity, not even a capacity of one.  You cannot
 * &lt;tt&gt;peek&lt;/tt&gt; at a synchronous queue because an element is only
 * present when you try to remove it; you cannot insert an element
 * (using any method) unless another thread is trying to remove it;
 * you cannot iterate as there is nothing to iterate.  The
 * &lt;em&gt;head&lt;/em&gt; of the queue is the element that the first queued
 * inserting thread is trying to add to the queue; if there is no such
 * queued thread then no element is available for removal and
 * &lt;tt&gt;poll()&lt;/tt&gt; will return &lt;tt&gt;null&lt;/tt&gt;.  For purposes of other
 * &lt;tt&gt;Collection&lt;/tt&gt; methods (for example &lt;tt&gt;contains&lt;/tt&gt;), a
 * &lt;tt&gt;SynchronousQueue&lt;/tt&gt; acts as an empty collection.  This queue
 * does not permit &lt;tt&gt;null&lt;/tt&gt; elements.
 *
 * &lt;p&gt;Synchronous queues are similar to rendezvous channels used in
 * CSP and Ada. They are well suited for handoff designs, in which an
 * object running in one thread must sync up with an object running
 * in another thread in order to hand it some information, event, or
 * task.
 *
 * &lt;p&gt; This class supports an optional fairness policy for ordering
 * waiting producer and consumer threads.  By default, this ordering
 * is not guaranteed. However, a queue constructed with fairness set
 * to &lt;tt&gt;true&lt;/tt&gt; grants threads access in FIFO order. Fairness
 * generally decreases throughput but reduces variability and avoids
 * starvation.
 *
 * &lt;p&gt;This class and its iterator implement all of the
 * &lt;em&gt;optional&lt;/em&gt; methods of the {@link Collection} and {@link
 * Iterator} interfaces.
 *
 * &lt;p&gt;This class is a member of the
 * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @since 1.5
 * @author Doug Lea
 */</span>
public <span class="keyword">class</span> <a title="object scala.actors.threadpool.SynchronousQueue" id="11740">SynchronousQueue</a> <span class="keyword">extends</span> AbstractQueue
        implements BlockingQueue, java.io.Serializable <span class="delimiter">{</span>
    <span class="keyword">private</span> static <span class="keyword">final</span> long <a title="Long" id="3903914">serialVersionUID</a> = -<span class="long">3223113410248163686L</span>;

    <span class="comment">/*
      This implementation divides actions into two cases for puts:

      * An arriving producer that does not already have a waiting consumer
        creates a node holding item, and then waits for a consumer to take it.
      * An arriving producer that does already have a waiting consumer fills
        the slot node created by the consumer, and notifies it to continue.

      And symmetrically, two for takes:

      * An arriving consumer that does not already have a waiting producer
        creates an empty slot node, and then waits for a producer to fill it.
      * An arriving consumer that does already have a waiting producer takes
        item from the node created by the producer, and notifies it to continue.

      When a put or take waiting for the actions of its counterpart
      aborts due to interruption or timeout, it marks the node
      it created as &quot;CANCELLED&quot;, which causes its counterpart to retry
      the entire put or take sequence.

      This requires keeping two simple queues, waitingProducers and
      waitingConsumers. Each of these can be FIFO (preserves fairness)
      or LIFO (improves throughput).
    */</span>

    <span class="comment">/** Lock protecting both wait queues */</span>
    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock qlock;
    <span class="comment">/** Queue holding waiting puts */</span>
    <span class="keyword">private</span> <span class="keyword">final</span> WaitQueue waitingProducers;
    <span class="comment">/** Queue holding waiting takes */</span>
    <span class="keyword">private</span> <span class="keyword">final</span> WaitQueue waitingConsumers;

    <span class="comment">/**
     * Creates a &lt;tt&gt;SynchronousQueue&lt;/tt&gt; with nonfair access policy.
     */</span>
    public SynchronousQueue<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">this</span><span class="delimiter">(</span><span class="keyword">false</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Creates a &lt;tt&gt;SynchronousQueue&lt;/tt&gt; with specified fairness policy.
     * @param fair if true, threads contend in FIFO order for access;
     * otherwise the order is unspecified.
     */</span>
    public SynchronousQueue<span class="delimiter">(</span>boolean fair<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>fair<span class="delimiter">)</span> <span class="delimiter">{</span>
            qlock = <span class="keyword">new</span> ReentrantLock<span class="delimiter">(</span><span class="keyword">true</span><span class="delimiter">)</span>;
            waitingProducers = <span class="keyword">new</span> FifoWaitQueue<span class="delimiter">(</span><span class="delimiter">)</span>;
            waitingConsumers = <span class="keyword">new</span> FifoWaitQueue<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
            qlock = <span class="keyword">new</span> ReentrantLock<span class="delimiter">(</span><span class="delimiter">)</span>;
            waitingProducers = <span class="keyword">new</span> LifoWaitQueue<span class="delimiter">(</span><span class="delimiter">)</span>;
            waitingConsumers = <span class="keyword">new</span> LifoWaitQueue<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Queue to hold waiting puts/takes; specialized to Fifo/Lifo below.
     * These queues have all transient fields, but are serializable
     * in order to recover fairness settings when deserialized.
     */</span>
    static <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="object scala.actors.threadpool.SynchronousQueue.WaitQueue" id="3903917">WaitQueue</a> implements java.io.Serializable <span class="delimiter">{</span>
        <span class="comment">/** Creates, adds, and returns node for x. */</span>
        <span class="keyword">abstract</span> Node enq<span class="delimiter">(</span>Object x<span class="delimiter">)</span>;
        <span class="comment">/** Removes and returns node, or null if empty. */</span>
        <span class="keyword">abstract</span> Node deq<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="comment">/** Removes a cancelled node to avoid garbage retention. */</span>
        <span class="keyword">abstract</span> void unlink<span class="delimiter">(</span>Node node<span class="delimiter">)</span>;
        <span class="comment">/** Returns true if a cancelled node might be on queue. */</span>
        <span class="keyword">abstract</span> boolean shouldUnlink<span class="delimiter">(</span>Node node<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * FIFO queue to hold waiting puts/takes.
     */</span>
    static <span class="keyword">final</span> <span class="keyword">class</span> <a title="object scala.actors.threadpool.SynchronousQueue.FifoWaitQueue" id="3903920">FifoWaitQueue</a> <span class="keyword">extends</span> WaitQueue implements java.io.Serializable <span class="delimiter">{</span>
        <span class="keyword">private</span> static <span class="keyword">final</span> long <a title="Long" id="3903932">serialVersionUID</a> = -<span class="long">3623113410248163686L</span>;
        <span class="keyword">private</span> transient Node <span title="">head</span>;
        <span class="keyword">private</span> transient Node <span title="">last</span>;

        Node enq<span class="delimiter">(</span>Object x<span class="delimiter">)</span> <span class="delimiter">{</span>
            Node p = <span class="keyword">new</span> Node<span class="delimiter">(</span>x<span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>last == <span class="keyword">null</span><span class="delimiter">)</span>
                last = head = p;
            <span class="keyword">else</span>
                last = last.next = p;
            <span class="keyword">return</span> p;
        <span class="delimiter">}</span>

        Node deq<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            Node p = head;
            <span class="keyword">if</span> <span class="delimiter">(</span>p != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span>head = p.next<span class="delimiter">)</span> == <span class="keyword">null</span><span class="delimiter">)</span>
                    last = <span class="keyword">null</span>;
                p.next = <span class="keyword">null</span>;
            <span class="delimiter">}</span>
            <span class="keyword">return</span> p;
        <span class="delimiter">}</span>

        boolean shouldUnlink<span class="delimiter">(</span>Node node<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> <span class="delimiter">(</span>node == last || node.next != <span class="keyword">null</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        void unlink<span class="delimiter">(</span>Node node<span class="delimiter">)</span> <span class="delimiter">{</span>
            Node p = head;
            Node trail = <span class="keyword">null</span>;
            <span class="keyword">while</span> <span class="delimiter">(</span>p != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>p == node<span class="delimiter">)</span> <span class="delimiter">{</span>
                    Node next = p.next;
                    <span class="keyword">if</span> <span class="delimiter">(</span>trail == <span class="keyword">null</span><span class="delimiter">)</span>
                        head = next;
                    <span class="keyword">else</span>
                        trail.next = next;
                    <span class="keyword">if</span> <span class="delimiter">(</span>last == node<span class="delimiter">)</span>
                        last = trail;
                    break;
                <span class="delimiter">}</span>
                trail = p;
                p = p.next;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * LIFO queue to hold waiting puts/takes.
     */</span>
    static <span class="keyword">final</span> <span class="keyword">class</span> <a title="object scala.actors.threadpool.SynchronousQueue.LifoWaitQueue" id="3903923">LifoWaitQueue</a> <span class="keyword">extends</span> WaitQueue implements java.io.Serializable <span class="delimiter">{</span>
        <span class="keyword">private</span> static <span class="keyword">final</span> long <a title="Long" id="3903934">serialVersionUID</a> = -<span class="long">3633113410248163686L</span>;
        <span class="keyword">private</span> transient Node <span title="">head</span>;

        Node enq<span class="delimiter">(</span>Object x<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> head = <span class="keyword">new</span> Node<span class="delimiter">(</span>x, head<span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        Node deq<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            Node p = head;
            <span class="keyword">if</span> <span class="delimiter">(</span>p != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                head = p.next;
                p.next = <span class="keyword">null</span>;
            <span class="delimiter">}</span>
            <span class="keyword">return</span> p;
        <span class="delimiter">}</span>

        boolean shouldUnlink<span class="delimiter">(</span>Node node<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="comment">// Return false if already dequeued or is bottom node (in which</span>
            <span class="comment">// case we might retain at most one garbage node)</span>
            <span class="keyword">return</span> <span class="delimiter">(</span>node == head || node.next != <span class="keyword">null</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        void unlink<span class="delimiter">(</span>Node node<span class="delimiter">)</span> <span class="delimiter">{</span>
            Node p = head;
            Node trail = <span class="keyword">null</span>;
            <span class="keyword">while</span> <span class="delimiter">(</span>p != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>p == node<span class="delimiter">)</span> <span class="delimiter">{</span>
                    Node next = p.next;
                    <span class="keyword">if</span> <span class="delimiter">(</span>trail == <span class="keyword">null</span><span class="delimiter">)</span>
                        head = next;
                    <span class="keyword">else</span>
                        trail.next = next;
                    break;
                <span class="delimiter">}</span>
                trail = p;
                p = p.next;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Unlinks the given node from consumer queue.  Called by cancelled
     * (timeout, interrupt) waiters to avoid garbage retention in the
     * absence of producers.
     */</span>
    <span class="keyword">private</span> void unlinkCancelledConsumer<span class="delimiter">(</span>Node node<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">// Use a form of double-check to avoid unnecessary locking and</span>
        <span class="comment">// traversal. The first check outside lock might</span>
        <span class="comment">// conservatively report true.</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>waitingConsumers.shouldUnlink<span class="delimiter">(</span>node<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            qlock.lock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">try</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>waitingConsumers.shouldUnlink<span class="delimiter">(</span>node<span class="delimiter">)</span><span class="delimiter">)</span>
                    waitingConsumers.unlink<span class="delimiter">(</span>node<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                qlock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Unlinks the given node from producer queue.  Symmetric
     * to unlinkCancelledConsumer.
     */</span>
    <span class="keyword">private</span> void unlinkCancelledProducer<span class="delimiter">(</span>Node node<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>waitingProducers.shouldUnlink<span class="delimiter">(</span>node<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            qlock.lock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">try</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>waitingProducers.shouldUnlink<span class="delimiter">(</span>node<span class="delimiter">)</span><span class="delimiter">)</span>
                    waitingProducers.unlink<span class="delimiter">(</span>node<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                qlock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Nodes each maintain an item and handle waits and signals for
     * getting and setting it. The class extends
     * AbstractQueuedSynchronizer to manage blocking, using AQS state
     *  0 for waiting, 1 for ack, -1 for cancelled.
     */</span>
    static <span class="keyword">final</span> <span class="keyword">class</span> <a title="object scala.actors.threadpool.SynchronousQueue.Node" id="3903926">Node</a> implements java.io.Serializable <span class="delimiter">{</span>
        <span class="keyword">private</span> static <span class="keyword">final</span> long <a title="Long" id="3903936">serialVersionUID</a> = -<span class="long">3223113410248163686L</span>;

        <span class="comment">/** Synchronization state value representing that node acked */</span>
        <span class="keyword">private</span> static <span class="keyword">final</span> int <a title="Int" id="3903937">ACK</a>    =  <span class="int">1</span>;
        <span class="comment">/** Synchronization state value representing that node cancelled */</span>
        <span class="keyword">private</span> static <span class="keyword">final</span> int <a title="Int" id="3903938">CANCEL</a> = -<span class="int">1</span>;

        int state = <span class="int">0</span>;

        <span class="comment">/** The item being transferred */</span>
        Object item;
        <span class="comment">/** Next node in wait queue */</span>
        Node next;

        <span class="comment">/** Creates a node with initial item */</span>
        Node<span class="delimiter">(</span>Object x<span class="delimiter">)</span> <span class="delimiter">{</span> item = x; <span class="delimiter">}</span>

        <span class="comment">/** Creates a node with initial item and next */</span>
        Node<span class="delimiter">(</span>Object x, Node n<span class="delimiter">)</span> <span class="delimiter">{</span> item = x; next = n; <span class="delimiter">}</span>

        <span class="comment">/**
         * Takes item and nulls out field (for sake of GC)
         *
         * PRE: lock owned
         */</span>
        <span class="keyword">private</span> Object extract<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            Object x = item;
            item = <span class="keyword">null</span>;
            <span class="keyword">return</span> x;
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Tries to cancel on interrupt; if so rethrowing,
         * else setting interrupt state
         *
         * PRE: lock owned
         */</span>
        <span class="keyword">private</span> void checkCancellationOnInterrupt<span class="delimiter">(</span>InterruptedException ie<span class="delimiter">)</span>
            throws InterruptedException
        <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>state == <span class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                state = CANCEL;
                notify<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">throw</span> ie;
            <span class="delimiter">}</span>
            Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span>.interrupt<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Fills in the slot created by the consumer and signal consumer to
         * continue.
         */</span>
        synchronized boolean setItem<span class="delimiter">(</span>Object x<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>state != <span class="int">0</span><span class="delimiter">)</span> <span class="keyword">return</span> <span class="keyword">false</span>;
            item = x;
            state = ACK;
            notify<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Removes item from slot created by producer and signal producer
         * to continue.
         */</span>
        synchronized Object getItem<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>state != <span class="int">0</span><span class="delimiter">)</span> <span class="keyword">return</span> <span class="keyword">null</span>;
            state = ACK;
            notify<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">return</span> extract<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Waits for a consumer to take item placed by producer.
         */</span>
        synchronized void waitForTake<span class="delimiter">(</span><span class="delimiter">)</span> throws InterruptedException <span class="delimiter">{</span>
            <span class="keyword">try</span> <span class="delimiter">{</span>
                <span class="keyword">while</span> <span class="delimiter">(</span>state == <span class="int">0</span><span class="delimiter">)</span> wait<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>InterruptedException ie<span class="delimiter">)</span> <span class="delimiter">{</span>
                checkCancellationOnInterrupt<span class="delimiter">(</span>ie<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Waits for a producer to put item placed by consumer.
         */</span>
        synchronized Object waitForPut<span class="delimiter">(</span><span class="delimiter">)</span> throws InterruptedException <span class="delimiter">{</span>
            <span class="keyword">try</span> <span class="delimiter">{</span>
                <span class="keyword">while</span> <span class="delimiter">(</span>state == <span class="int">0</span><span class="delimiter">)</span> wait<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>InterruptedException ie<span class="delimiter">)</span> <span class="delimiter">{</span>
                checkCancellationOnInterrupt<span class="delimiter">(</span>ie<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
            <span class="keyword">return</span> extract<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        <span class="keyword">private</span> boolean attempt<span class="delimiter">(</span>long nanos<span class="delimiter">)</span> throws InterruptedException <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>state != <span class="int">0</span><span class="delimiter">)</span> <span class="keyword">return</span> <span class="keyword">true</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>nanos &lt;= <span class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                state = CANCEL;
                notify<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">return</span> <span class="keyword">false</span>;
            <span class="delimiter">}</span>
            long deadline = Utils.nanoTime<span class="delimiter">(</span><span class="delimiter">)</span> + nanos;
            <span class="keyword">while</span> <span class="delimiter">(</span><span class="keyword">true</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                TimeUnit.NANOSECONDS.timedWait<span class="delimiter">(</span><span class="keyword">this</span>, nanos<span class="delimiter">)</span>;
                <span class="keyword">if</span> <span class="delimiter">(</span>state != <span class="int">0</span><span class="delimiter">)</span> <span class="keyword">return</span> <span class="keyword">true</span>;
                nanos = deadline - Utils.nanoTime<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">if</span> <span class="delimiter">(</span>nanos &lt;= <span class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    state = CANCEL;
                    notify<span class="delimiter">(</span><span class="delimiter">)</span>;
                    <span class="keyword">return</span> <span class="keyword">false</span>;
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Waits for a consumer to take item placed by producer or time out.
         */</span>
        synchronized boolean waitForTake<span class="delimiter">(</span>long nanos<span class="delimiter">)</span> throws InterruptedException <span class="delimiter">{</span>
            <span class="keyword">try</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>!attempt<span class="delimiter">(</span>nanos<span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">return</span> <span class="keyword">false</span>;
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>InterruptedException ie<span class="delimiter">)</span> <span class="delimiter">{</span>
                checkCancellationOnInterrupt<span class="delimiter">(</span>ie<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Waits for a producer to put item placed by consumer, or time out.
         */</span>
        synchronized Object waitForPut<span class="delimiter">(</span>long nanos<span class="delimiter">)</span> throws InterruptedException <span class="delimiter">{</span>
            <span class="keyword">try</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>!attempt<span class="delimiter">(</span>nanos<span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">return</span> <span class="keyword">null</span>;
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>InterruptedException ie<span class="delimiter">)</span> <span class="delimiter">{</span>
                checkCancellationOnInterrupt<span class="delimiter">(</span>ie<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
            <span class="keyword">return</span> extract<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Adds the specified element to this queue, waiting if necessary for
     * another thread to receive it.
     *
     * @throws InterruptedException {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     */</span>
    public void put<span class="delimiter">(</span>Object e<span class="delimiter">)</span> throws InterruptedException <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>e == <span class="keyword">null</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">final</span> ReentrantLock qlock = <span class="keyword">this</span>.qlock;

        <span class="keyword">for</span> <span class="delimiter">(</span>;;<span class="delimiter">)</span> <span class="delimiter">{</span>
            Node node;
            boolean mustWait;
            <span class="keyword">if</span> <span class="delimiter">(</span>Thread.interrupted<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException<span class="delimiter">(</span><span class="delimiter">)</span>;
            qlock.lock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">try</span> <span class="delimiter">{</span>
                node = waitingConsumers.deq<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">if</span> <span class="delimiter">(</span> <span class="delimiter">(</span>mustWait = <span class="delimiter">(</span>node == <span class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">)</span>
                    node = waitingProducers.enq<span class="delimiter">(</span>e<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                qlock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>

            <span class="keyword">if</span> <span class="delimiter">(</span>mustWait<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">try</span> <span class="delimiter">{</span>
                    node.waitForTake<span class="delimiter">(</span><span class="delimiter">)</span>;
                    <span class="keyword">return</span>;
                <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>InterruptedException ex<span class="delimiter">)</span> <span class="delimiter">{</span>
                    unlinkCancelledProducer<span class="delimiter">(</span>node<span class="delimiter">)</span>;
                    <span class="keyword">throw</span> ex;
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>

            <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>node.setItem<span class="delimiter">(</span>e<span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">return</span>;

            <span class="comment">// else consumer cancelled, so retry</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Inserts the specified element into this queue, waiting if necessary
     * up to the specified wait time for another thread to receive it.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; if successful, or &lt;tt&gt;false&lt;/tt&gt; if the
     *         specified waiting time elapses before a consumer appears.
     * @throws InterruptedException {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     */</span>
    public boolean offer<span class="delimiter">(</span>Object e, long timeout, TimeUnit unit<span class="delimiter">)</span> throws InterruptedException <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>e == <span class="keyword">null</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
        long nanos = unit.toNanos<span class="delimiter">(</span>timeout<span class="delimiter">)</span>;
        <span class="keyword">final</span> ReentrantLock qlock = <span class="keyword">this</span>.qlock;
        <span class="keyword">for</span> <span class="delimiter">(</span>;;<span class="delimiter">)</span> <span class="delimiter">{</span>
            Node node;
            boolean mustWait;
            <span class="keyword">if</span> <span class="delimiter">(</span>Thread.interrupted<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException<span class="delimiter">(</span><span class="delimiter">)</span>;
            qlock.lock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">try</span> <span class="delimiter">{</span>
                node = waitingConsumers.deq<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">if</span> <span class="delimiter">(</span> <span class="delimiter">(</span>mustWait = <span class="delimiter">(</span>node == <span class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">)</span>
                    node = waitingProducers.enq<span class="delimiter">(</span>e<span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                qlock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>

            <span class="keyword">if</span> <span class="delimiter">(</span>mustWait<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">try</span> <span class="delimiter">{</span>
                    boolean x = node.waitForTake<span class="delimiter">(</span>nanos<span class="delimiter">)</span>;
                    <span class="keyword">if</span> <span class="delimiter">(</span>!x<span class="delimiter">)</span>
                        unlinkCancelledProducer<span class="delimiter">(</span>node<span class="delimiter">)</span>;
                    <span class="keyword">return</span> x;
                <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>InterruptedException ex<span class="delimiter">)</span> <span class="delimiter">{</span>
                    unlinkCancelledProducer<span class="delimiter">(</span>node<span class="delimiter">)</span>;
                    <span class="keyword">throw</span> ex;
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>

            <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>node.setItem<span class="delimiter">(</span>e<span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">return</span> <span class="keyword">true</span>;

            <span class="comment">// else consumer cancelled, so retry</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Retrieves and removes the head of this queue, waiting if necessary
     * for another thread to insert it.
     *
     * @return the head of this queue
     * @throws InterruptedException {@inheritDoc}
     */</span>
    public Object take<span class="delimiter">(</span><span class="delimiter">)</span> throws InterruptedException <span class="delimiter">{</span>
        <span class="keyword">final</span> ReentrantLock qlock = <span class="keyword">this</span>.qlock;
        <span class="keyword">for</span> <span class="delimiter">(</span>;;<span class="delimiter">)</span> <span class="delimiter">{</span>
            Node node;
            boolean mustWait;

            <span class="keyword">if</span> <span class="delimiter">(</span>Thread.interrupted<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException<span class="delimiter">(</span><span class="delimiter">)</span>;
            qlock.lock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">try</span> <span class="delimiter">{</span>
                node = waitingProducers.deq<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">if</span> <span class="delimiter">(</span> <span class="delimiter">(</span>mustWait = <span class="delimiter">(</span>node == <span class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">)</span>
                    node = waitingConsumers.enq<span class="delimiter">(</span><span class="keyword">null</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                qlock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>

            <span class="keyword">if</span> <span class="delimiter">(</span>mustWait<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">try</span> <span class="delimiter">{</span>
                    Object x = node.waitForPut<span class="delimiter">(</span><span class="delimiter">)</span>;
                    <span class="keyword">return</span> <span class="delimiter">(</span>Object<span class="delimiter">)</span>x;
                <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>InterruptedException ex<span class="delimiter">)</span> <span class="delimiter">{</span>
                    unlinkCancelledConsumer<span class="delimiter">(</span>node<span class="delimiter">)</span>;
                    <span class="keyword">throw</span> ex;
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="keyword">else</span> <span class="delimiter">{</span>
                Object x = node.getItem<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">if</span> <span class="delimiter">(</span>x != <span class="keyword">null</span><span class="delimiter">)</span>
                    <span class="keyword">return</span> <span class="delimiter">(</span>Object<span class="delimiter">)</span>x;
                <span class="comment">// else cancelled, so retry</span>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Retrieves and removes the head of this queue, waiting
     * if necessary up to the specified wait time, for another thread
     * to insert it.
     *
     * @return the head of this queue, or &lt;tt&gt;null&lt;/tt&gt; if the
     *         specified waiting time elapses before an element is present.
     * @throws InterruptedException {@inheritDoc}
     */</span>
    public Object poll<span class="delimiter">(</span>long timeout, TimeUnit unit<span class="delimiter">)</span> throws InterruptedException <span class="delimiter">{</span>
        long nanos = unit.toNanos<span class="delimiter">(</span>timeout<span class="delimiter">)</span>;
        <span class="keyword">final</span> ReentrantLock qlock = <span class="keyword">this</span>.qlock;

        <span class="keyword">for</span> <span class="delimiter">(</span>;;<span class="delimiter">)</span> <span class="delimiter">{</span>
            Node node;
            boolean mustWait;

            <span class="keyword">if</span> <span class="delimiter">(</span>Thread.interrupted<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException<span class="delimiter">(</span><span class="delimiter">)</span>;
            qlock.lock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">try</span> <span class="delimiter">{</span>
                node = waitingProducers.deq<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">if</span> <span class="delimiter">(</span> <span class="delimiter">(</span>mustWait = <span class="delimiter">(</span>node == <span class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">)</span>
                    node = waitingConsumers.enq<span class="delimiter">(</span><span class="keyword">null</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                qlock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>

            <span class="keyword">if</span> <span class="delimiter">(</span>mustWait<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">try</span> <span class="delimiter">{</span>
                    Object x = node.waitForPut<span class="delimiter">(</span>nanos<span class="delimiter">)</span>;
                    <span class="keyword">if</span> <span class="delimiter">(</span>x == <span class="keyword">null</span><span class="delimiter">)</span>
                        unlinkCancelledConsumer<span class="delimiter">(</span>node<span class="delimiter">)</span>;
                    <span class="keyword">return</span> <span class="delimiter">(</span>Object<span class="delimiter">)</span>x;
                <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>InterruptedException ex<span class="delimiter">)</span> <span class="delimiter">{</span>
                    unlinkCancelledConsumer<span class="delimiter">(</span>node<span class="delimiter">)</span>;
                    <span class="keyword">throw</span> ex;
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="keyword">else</span> <span class="delimiter">{</span>
                Object x = node.getItem<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">if</span> <span class="delimiter">(</span>x != <span class="keyword">null</span><span class="delimiter">)</span>
                    <span class="keyword">return</span> <span class="delimiter">(</span>Object<span class="delimiter">)</span>x;
                <span class="comment">// else cancelled, so retry</span>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">// Untimed nonblocking versions</span>

    <span class="comment">/**
     * Inserts the specified element into this queue, if another thread is
     * waiting to receive it.
     *
     * @param e the element to add
     * @return &lt;tt&gt;true&lt;/tt&gt; if the element was added to this queue, else
     *         &lt;tt&gt;false&lt;/tt&gt;
     * @throws NullPointerException if the specified element is null
     */</span>
    public boolean offer<span class="delimiter">(</span>Object e<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>e == <span class="keyword">null</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">final</span> ReentrantLock qlock = <span class="keyword">this</span>.qlock;

        <span class="keyword">for</span> <span class="delimiter">(</span>;;<span class="delimiter">)</span> <span class="delimiter">{</span>
            Node node;
            qlock.lock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">try</span> <span class="delimiter">{</span>
                node = waitingConsumers.deq<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                qlock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>node == <span class="keyword">null</span><span class="delimiter">)</span>
                <span class="keyword">return</span> <span class="keyword">false</span>;

            <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>node.setItem<span class="delimiter">(</span>e<span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">return</span> <span class="keyword">true</span>;
            <span class="comment">// else retry</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Retrieves and removes the head of this queue, if another thread
     * is currently making an element available.
     *
     * @return the head of this queue, or &lt;tt&gt;null&lt;/tt&gt; if no
     *         element is available.
     */</span>
    public Object poll<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">final</span> ReentrantLock qlock = <span class="keyword">this</span>.qlock;
        <span class="keyword">for</span> <span class="delimiter">(</span>;;<span class="delimiter">)</span> <span class="delimiter">{</span>
            Node node;
            qlock.lock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">try</span> <span class="delimiter">{</span>
                node = waitingProducers.deq<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                qlock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>node == <span class="keyword">null</span><span class="delimiter">)</span>
                <span class="keyword">return</span> <span class="keyword">null</span>;

            <span class="keyword">else</span> <span class="delimiter">{</span>
                Object x = node.getItem<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">if</span> <span class="delimiter">(</span>x != <span class="keyword">null</span><span class="delimiter">)</span>
                    <span class="keyword">return</span> <span class="delimiter">(</span>Object<span class="delimiter">)</span>x;
                <span class="comment">// else retry</span>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Always returns &lt;tt&gt;true&lt;/tt&gt;.
     * A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt;
     */</span>
    public boolean isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Always returns zero.
     * A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.
     *
     * @return zero
     */</span>
    public int size<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="int">0</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Always returns zero.
     * A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.
     *
     * @return zero
     */</span>
    public int remainingCapacity<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="int">0</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Does nothing.
     * A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.
     */</span>
    public void clear<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span><span class="delimiter">}</span>

    <span class="comment">/**
     * Always returns &lt;tt&gt;false&lt;/tt&gt;.
     * A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.
     *
     * @param o object to be checked for containment in this queue
     * @return &lt;tt&gt;false&lt;/tt&gt;
     */</span>
    public boolean contains<span class="delimiter">(</span>Object o<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Always returns &lt;tt&gt;false&lt;/tt&gt;.
     * A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.
     *
     * @param o the element to remove
     * @return &lt;tt&gt;false&lt;/tt&gt;
     */</span>
    public boolean remove<span class="delimiter">(</span>Object o<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns &lt;tt&gt;false&lt;/tt&gt; unless the given collection is empty.
     * A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.
     *
     * @param c the collection
     * @return &lt;tt&gt;false&lt;/tt&gt; unless the given collection is empty
     * @throws NullPointerException if the specified collection is null
     */</span>
    public boolean containsAll<span class="delimiter">(</span>Collection c<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> c.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Always returns &lt;tt&gt;false&lt;/tt&gt;.
     * A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.
     *
     * @param c the collection
     * @return &lt;tt&gt;false&lt;/tt&gt;
     */</span>
    public boolean removeAll<span class="delimiter">(</span>Collection c<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Always returns &lt;tt&gt;false&lt;/tt&gt;.
     * A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; has no internal capacity.
     *
     * @param c the collection
     * @return &lt;tt&gt;false&lt;/tt&gt;
     */</span>
    public boolean retainAll<span class="delimiter">(</span>Collection c<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Always returns &lt;tt&gt;null&lt;/tt&gt;.
     * A &lt;tt&gt;SynchronousQueue&lt;/tt&gt; does not return elements
     * unless actively waited on.
     *
     * @return &lt;tt&gt;null&lt;/tt&gt;
     */</span>
    public Object peek<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">null</span>;
    <span class="delimiter">}</span>


    static <span class="keyword">class</span> <a title="object scala.actors.threadpool.SynchronousQueue.EmptyIterator" id="3903929">EmptyIterator</a> implements Iterator <span class="delimiter">{</span>
        public boolean hasNext<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="delimiter">}</span>
        public Object next<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        public void remove<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns an empty iterator in which &lt;tt&gt;hasNext&lt;/tt&gt; always returns
     * &lt;tt&gt;false&lt;/tt&gt;.
     *
     * @return an empty iterator
     */</span>
    public Iterator iterator<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> EmptyIterator<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>


    <span class="comment">/**
     * Returns a zero-length array.
     * @return a zero-length array
     */</span>
    public Object<span class="delimiter">[</span><span class="delimiter">]</span> toArray<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> Object<span class="delimiter">[</span><span class="int">0</span><span class="delimiter">]</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Sets the zeroeth element of the specified array to &lt;tt&gt;null&lt;/tt&gt;
     * (if the array has non-zero length) and returns it.
     *
     * @param a the array
     * @return the specified array
     * @throws NullPointerException if the specified array is null
     */</span>
    public Object<span class="delimiter">[</span><span class="delimiter">]</span> toArray<span class="delimiter">(</span>Object<span class="delimiter">[</span><span class="delimiter">]</span> a<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>a.length &gt; <span class="int">0</span><span class="delimiter">)</span>
            a<span class="delimiter">[</span><span class="int">0</span><span class="delimiter">]</span> = <span class="keyword">null</span>;
        <span class="keyword">return</span> a;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * @throws UnsupportedOperationException {@inheritDoc}
     * @throws ClassCastException            {@inheritDoc}
     * @throws NullPointerException          {@inheritDoc}
     * @throws IllegalArgumentException      {@inheritDoc}
     */</span>
    public int drainTo<span class="delimiter">(</span>Collection c<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>c == <span class="keyword">null</span><span class="delimiter">)</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">if</span> <span class="delimiter">(</span>c == <span class="keyword">this</span><span class="delimiter">)</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException<span class="delimiter">(</span><span class="delimiter">)</span>;
        int n = <span class="int">0</span>;
        Object e;
        <span class="keyword">while</span> <span class="delimiter">(</span> <span class="delimiter">(</span>e = poll<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            c.add<span class="delimiter">(</span>e<span class="delimiter">)</span>;
            ++n;
        <span class="delimiter">}</span>
        <span class="keyword">return</span> n;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * @throws UnsupportedOperationException {@inheritDoc}
     * @throws ClassCastException            {@inheritDoc}
     * @throws NullPointerException          {@inheritDoc}
     * @throws IllegalArgumentException      {@inheritDoc}
     */</span>
    public int drainTo<span class="delimiter">(</span>Collection c, int maxElements<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>c == <span class="keyword">null</span><span class="delimiter">)</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">if</span> <span class="delimiter">(</span>c == <span class="keyword">this</span><span class="delimiter">)</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException<span class="delimiter">(</span><span class="delimiter">)</span>;
        int n = <span class="int">0</span>;
        Object e;
        <span class="keyword">while</span> <span class="delimiter">(</span>n &lt; maxElements &amp;&amp; <span class="delimiter">(</span>e = poll<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> != <span class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            c.add<span class="delimiter">(</span>e<span class="delimiter">)</span>;
            ++n;
        <span class="delimiter">}</span>
        <span class="keyword">return</span> n;
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>