<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/reflect/internal/Types.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
/* NSC -- new Scala compiler
 * Copyright 2005-2011 LAMP/EPFL
 * @author  Martin Odersky
 */

<span class="keyword">package</span> scala.reflect
<span class="keyword">package</span> internal

<span class="keyword">import</span> scala.collection.<span class="delimiter">{</span> mutable, immutable <span class="delimiter">}</span>
<span class="keyword">import</span> scala.ref.WeakReference
<span class="keyword">import</span> mutable.ListBuffer
<span class="keyword">import</span> <a href="Flags.scala.html#8807" title="object scala.reflect.internal.Flags">Flags</a>._
<span class="keyword">import</span> scala.util.control.ControlThrowable
<span class="keyword">import</span> scala.annotation.tailrec
<span class="keyword">import</span> util.<a href="util/Statistics.scala.html#10815" title="object scala.reflect.internal.util.Statistics">Statistics</a>._

/* A standard type pattern match:
  case ErrorType =&gt;
    // internal: error
  case WildcardType =&gt;
    // internal: unknown
  case NoType =&gt;
  case NoPrefix =&gt;
  case ThisType(sym) =&gt;
    // sym.this.type
  case SuperType(thistpe, supertpe) =&gt;
    // super references
  case SingleType(pre, sym) =&gt;
    // pre.sym.type
  case ConstantType(value) =&gt;
    // Int(2)
  case TypeRef(pre, sym, args) =&gt;
    // pre.sym[targs]
    // Outer.this.C would be represented as TypeRef(ThisType(Outer), C, List())
  case RefinedType(parents, defs) =&gt;
    // parent1 with ... with parentn { defs }
  case ExistentialType(tparams, result) =&gt;
    // result forSome { tparams }
  case AnnotatedType(annots, tp, selfsym) =&gt;
    // tp @annots

  // the following are non-value types; you cannot write them down in Scala source.

  case TypeBounds(lo, hi) =&gt;
    // &gt;: lo &lt;: hi
  case ClassInfoType(parents, defs, clazz) =&gt;
    // same as RefinedType except as body of class
  case MethodType(paramtypes, result) =&gt;
    // (paramtypes)result
    // For instance def m(): T is represented as MethodType(List(), T)
  case NullaryMethodType(result) =&gt; // eliminated by uncurry
    // an eval-by-name type
    // For instance def m: T is represented as NullaryMethodType(T)
  case PolyType(tparams, result) =&gt;
    // [tparams]result where result is a (Nullary)MethodType or ClassInfoType

  // The remaining types are not used after phase `typer`.
  case OverloadedType(pre, tparams, alts) =&gt;
    // all alternatives of an overloaded ident
  case AntiPolyType(pre, targs) =&gt;
    // rarely used, disappears when combined with a PolyType
  case TypeVar(inst, constr) =&gt;
    // a type variable
    // Replace occurrences of type parameters with type vars, where
    // inst is the instantiation and constr is a list of bounds.
  case DeBruijnIndex(level, index)
    // for dependent method types: a type referring to a method parameter.
*/

<span class="keyword">trait</span> <a title="trait Types extends Object with scala.reflect.api.Types with ScalaObject" id="7741">Types</a> <span title="ScalaObject" class="keyword">extends</span> api.<span title="scala.reflect.api.Types">Types</span> <span class="delimiter">{</span> self: SymbolTable =&gt;
  <span class="keyword">import</span> <a href="Definitions.scala.html#39224" title="object Types.this.definitions">definitions</a>._

  //statistics
  <span class="keyword">def</span> <a title="=&gt; Int" id="38770">uniqueTypeCount</a> = <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#38962" title="=&gt; scala.reflect.internal.util.HashSet[Types.this.Type]">uniques</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> <span class="keyword">else</span> <a href="#38962" title="=&gt; scala.reflect.internal.util.HashSet[Types.this.Type]">uniques</a>.<a href="util/HashSet.scala.html#129827" title="=&gt; Int">size</a>

  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Boolean" id="38772">explainSwitch</a> = <span title="Boolean(false)" class="keyword">false</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="38774">emptySymbolSet</a> = immutable.<span title="object scala.collection.immutable.Set">Set</span>.<span title="[A]=&gt; scala.collection.immutable.Set[A]">empty</span><span title="scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span>

  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="38776">LogPendingSubTypesThreshold</a> = <span title="Int(50)" class="int">50</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="38778">LogPendingBaseTypesThreshold</a> = <span title="Int(50)" class="int">50</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="38780">LogVolatileThreshold</a> = <span title="Int(50)" class="int">50</span>

  /** A don't care value for the depth parameter in lubs/glbs and related operations. */
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(-3)" id="38782">AnyDepth</a> = -<span title="Int(-3)" class="int">3</span>

  /** Decrement depth unless it is a don't care. */
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="(depth: Int)Int" id="38784">decr</a><span class="delimiter">(</span><a title="Int" id="129872">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#129872" title="Int">depth</a> <span title="(x: Int)Boolean">==</span> <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span> <span title="Int(-3)">AnyDepth</span> <span class="keyword">else</span> <a href="#129872" title="Int">depth</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>

  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean" id="38785">printLubs</a> = sys.<span title="=&gt; scala.sys.SystemProperties">props</span> <span title="(key: String)Boolean">contains</span> <span title="String(&quot;scalac.debug.lub&quot;)" class="string">&quot;scalac.debug.lub&quot;</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean" id="38787">traceTypeVars</a> = sys.<span title="=&gt; scala.sys.SystemProperties">props</span> <span title="(key: String)Boolean">contains</span> <span title="String(&quot;scalac.debug.tvar&quot;)" class="string">&quot;scalac.debug.tvar&quot;</span>
  /** In case anyone wants to turn off lub verification without reverting anything. */
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean(true)" id="38789">verifyLubs</a> = <span title="Boolean(true)" class="keyword">true</span>
  /** In case anyone wants to turn off type parameter bounds being used
   *  to seed type constraints.
   */
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Boolean" id="38791">propagateParameterBoundsToTypeVars</a> = sys.<span title="=&gt; scala.sys.SystemProperties">props</span> <span title="(key: String)Boolean">contains</span> <span title="String(&quot;scalac.debug.prop-constraints&quot;)" class="string">&quot;scalac.debug.prop-constraints&quot;</span>

  <span class="keyword">protected</span> <span class="keyword">val</span> <a title="Boolean" id="38793">enableTypeVarExperimentals</a> = <a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74523" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">Xexperimental</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a>

  /** Empty immutable maps to avoid allocations. */
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]" id="38795">emptySymMap</a>   = immutable.<span title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</span><span title="(elems: (Types.this.Symbol, Types.this.Symbol)*)scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Int]" id="38797">emptySymCount</a> = immutable.<span title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</span><span title="(elems: (Types.this.Symbol, Int)*)scala.collection.immutable.Map[Types.this.Symbol,Int]" class="delimiter">[</span><a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <span title="Int">Int</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>

  /** The current skolemization level, needed for the algorithms
   *  in isSameType, isSubType that do constraint solving under a prefix.
   */
  <span class="keyword">var</span> <a title="Int" id="38800">skolemizationLevel</a> = <span title="Int(0)" class="int">0</span>

  /** A log of type variable with their original constraints. Used in order
   *  to undo constraints in the case of isSubType/isSameType failure.
   */
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.UndoLog" id="38803">undoLog</a> = <a href="#38804" title="=&gt; Types.this.UndoLog">newUndoLog</a>
  
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.UndoLog" id="38804">newUndoLog</a> = <span title="Types.this.UndoLog" class="keyword">new</span> <a href="#38805" title="Types.this.UndoLog">UndoLog</a>
  
  <span class="keyword">class</span> <a title="class UndoLog extends Object with ScalaObject" id="38805">UndoLog</a> <a href="#38805" title="ScalaObject" class="delimiter">{</a>
    <span class="keyword">private</span> <span class="keyword">type</span> <a title="List[(Types.this.TypeVar, Types.this.TypeConstraint)]" id="129887">UndoPairs</a> = <span title="List[(Types.this.TypeVar, Types.this.TypeConstraint)]">List</span><span class="delimiter">[</span><span class="delimiter">(</span>TypeVar, TypeConstraint<span class="delimiter">)</span><span class="delimiter">]</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="UndoLog.this.UndoPairs" id="129889">log</a>: <span title="UndoLog.this.UndoPairs">UndoPairs</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    
    // register with the auto-clearing cache manager
    <a href="SymbolTable.scala.html#35655" title="object Types.this.perRunCaches">perRunCaches</a>.<a href="SymbolTable.scala.html#110753" title="(cache: Types.this.UndoLog)Types.this.UndoLog">recordCache</a><span class="delimiter">(</span><a href="#38805" title="Types.this.UndoLog" class="keyword">this</a><span class="delimiter">)</span>

    /** Undo all changes to constraints to type variables upto `limit`. */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(limit: UndoLog.this.UndoPairs)Unit" id="129891">undoTo</a><span class="delimiter">(</span><a title="UndoLog.this.UndoPairs" id="129920">limit</a>: <span title="UndoLog.this.UndoPairs">UndoPairs</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#129889" title="=&gt; UndoLog.this.UndoPairs">log</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#129920" title="UndoLog.this.UndoPairs">limit</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#129889" title="=&gt; UndoLog.this.UndoPairs">log</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#129922" title="()Unit" class="delimiter">{</a>
        <span class="keyword">val</span> <a href="#129925" title="(Types.this.TypeVar, Types.this.TypeConstraint)" class="delimiter">(</a><a href="#129924" title="Types.this.TypeVar" id="129925">tv</a>, <a href="#129924" title="Types.this.TypeConstraint" id="129926">constr</a><span class="delimiter">)</span> = <a href="#129889" title="=&gt; UndoLog.this.UndoPairs">log</a>.<span title="=&gt; (Types.this.TypeVar, Types.this.TypeConstraint)">head</span>
        <a href="#129925" title="Types.this.TypeVar">tv</a>.<a href="#83969" title="(x$1: Types.this.TypeConstraint)Unit">constr</a> = <a href="#129926" title="Types.this.TypeConstraint">constr</a>
        <a href="#129889" title="(x$1: UndoLog.this.UndoPairs)Unit">log</a> = <a href="#129889" title="=&gt; UndoLog.this.UndoPairs">log</a>.<span title="=&gt; List[(Types.this.TypeVar, Types.this.TypeConstraint)]">tail</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** No sync necessary, because record should only
     *  be called from within a undo or undoUnless block,
     *  which is already synchronized.
     */
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(tv: Types.this.TypeVar)Unit" id="129892">record</a><span class="delimiter">(</span><a title="Types.this.TypeVar" id="129944">tv</a>: <a href="#38912" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#129889" title="(x$1: UndoLog.this.UndoPairs)Unit">log</a> <span title="(x: (Types.this.TypeVar, Types.this.TypeConstraint))List[(Types.this.TypeVar, Types.this.TypeConstraint)]">::=</span> <span class="delimiter">(</span><span title="(_1: Types.this.TypeVar, _2: Types.this.TypeConstraint)(Types.this.TypeVar, Types.this.TypeConstraint)" class="delimiter">(</span><a href="#129944" title="Types.this.TypeVar">tv</a>, <a href="#129944" title="Types.this.TypeVar">tv</a>.<a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84072" title="=&gt; Types.this.TypeConstraint">cloneInternal</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    
    <span class="keyword">private</span><span class="delimiter">[</span>scala<span class="delimiter">]</span> <span class="keyword">def</span> <a title="()Unit" id="129893">clear</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74514" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a><span class="delimiter">)</span>
        <a href="#7741" title="Types.this.type">self</a>.<a href="SymbolTable.scala.html#35602" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="String(&quot;Clearing &quot;)" class="string">&quot;Clearing &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#129889" title="=&gt; UndoLog.this.UndoPairs">log</a>.<span title="=&gt; Int">size</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; entries from the undoLog.&quot;)" class="string">&quot; entries from the undoLog.&quot;</span><span class="delimiter">)</span>

      <a href="#129889" title="(x$1: UndoLog.this.UndoPairs)Unit">log</a> = <span title="object Nil">Nil</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="=&gt; Int" id="129894">size</a> = <a href="#129889" title="=&gt; UndoLog.this.UndoPairs">log</a>.<span title="=&gt; Int">size</span>

    // `block` should not affect constraints on typevars
    <span class="keyword">def</span> <a title="[T](block: =&gt; T)T" id="129895">undo</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="129897">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; T" id="129982">block</a>: =&gt; T<span class="delimiter">)</span>: <a href="#129897" title="T">T</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="UndoLog.this.UndoPairs" id="129985">before</a> = <a href="#129889" title="=&gt; UndoLog.this.UndoPairs">log</a>

      <span class="keyword">try</span> <a href="#129982" title="=&gt; T">block</a>
      <span class="keyword">finally</span> <a href="#129891" title="(limit: UndoLog.this.UndoPairs)Unit">undoTo</a><span class="delimiter">(</span><a href="#129985" title="UndoLog.this.UndoPairs">before</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    // if `block` evaluates to false, it should not affect constraints on typevars
    <span class="keyword">def</span> <a title="(block: =&gt; Boolean)Boolean" id="129898">undoUnless</a><span class="delimiter">(</span><a title="=&gt; Boolean" id="129986">block</a>: =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="UndoLog.this.UndoPairs" id="129988">before</a> = <a href="#129889" title="=&gt; UndoLog.this.UndoPairs">log</a>
      <span class="keyword">var</span> <a title="Boolean" id="129989">result</a> = <span title="Boolean(false)" class="keyword">false</span>

      <span class="keyword">try</span> <a href="#129989" title="Boolean">result</a> = <a href="#129986" title="=&gt; Boolean">block</a>
      <span class="keyword">finally</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#129989" title="Boolean">result</a><span class="delimiter">)</span> <a href="#129891" title="(limit: UndoLog.this.UndoPairs)Unit">undoTo</a><span class="delimiter">(</span><a href="#129988" title="UndoLog.this.UndoPairs">before</a><span class="delimiter">)</span>

      <a href="#129989" title="Boolean">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map from lists to compound types that have the given list as parents.
   *  This is used to avoid duplication in the computation of base type sequences and baseClasses.
   *  It makes use of the fact that these two operations depend only on the parents,
   *  not on the refinement.
   */
  <span class="keyword">val</span> <a title="scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]" id="38806">intersectionWitness</a> = <a href="SymbolTable.scala.html#35655" title="object Types.this.perRunCaches">perRunCaches</a>.<a href="SymbolTable.scala.html#110757" title="[K, V]()scala.collection.mutable.WeakHashMap[K,V]">newWeakMap</a><span title="()scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]" class="delimiter">[</span><span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <span title="scala.ref.WeakReference[Types.this.Type]">WeakReference</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>

  /** A proxy for a type (identified by field `underlying`) that forwards most
   *  operations to it (for exceptions, see WrappingProxy, which forwards even more operations).
   *  every operation that is overridden for some kind of types should be forwarded.
   */
  <span class="keyword">trait</span> <a title="trait SimpleTypeProxy extends Types.this.Type with ScalaObject" id="38808">SimpleTypeProxy</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="58223">underlying</a>: <a href="#38813" title="Types.this.Type">Type</a>

    // the following operations + those in RewrappingTypeProxy are all operations
    // in class Type that are overridden in some subclass
    // Important to keep this up-to-date when new operations are added!
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="58224">isTrivial</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41489" title="=&gt; Boolean">isTrivial</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="58225">isHigherKinded</a>: <span title="Boolean">Boolean</span> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41490" title="=&gt; Boolean">isHigherKinded</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="58226">typeConstructor</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41516" title="=&gt; Types.this.Type">typeConstructor</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="58227">isNotNull</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41493" title="=&gt; Boolean">isNotNull</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="58228">isError</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41498" title="=&gt; Boolean">isError</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="58229">isErroneous</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41499" title="=&gt; Boolean">isErroneous</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="58230">isStable</a>: <span title="Boolean">Boolean</span> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41491" title="=&gt; Boolean">isStable</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="58231">isVolatile</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41492" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="58232">finalResultType</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41523" title="=&gt; Types.this.Type">finalResultType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="58233">paramSectionCount</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41524" title="=&gt; Int">paramSectionCount</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="58234">paramss</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41525" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="58235">params</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41526" title="=&gt; List[Types.this.Symbol]">params</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="58236">paramTypes</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41527" title="=&gt; List[Types.this.Type]">paramTypes</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="58237">termSymbol</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41503" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="58238">termSymbolDirect</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41505" title="=&gt; Types.this.Symbol">termSymbolDirect</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="58239">typeParams</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41528" title="=&gt; List[Types.this.Symbol]">typeParams</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="58240">boundSyms</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41529" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="58241">typeSymbol</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="58242">typeSymbolDirect</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41506" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="58243">widen</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41508" title="=&gt; Types.this.Type">widen</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="58244">typeOfThis</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41510" title="=&gt; Types.this.Type">typeOfThis</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="58245">bounds</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="58246">parents</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41513" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="58247">prefix</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41514" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="58248">decls</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41536" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="58249">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="130074">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41553" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#130074" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="58250">baseTypeSeq</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41579" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="58251">baseTypeSeqDepth</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41580" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="58252">baseClasses</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41581" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
  <span class="delimiter">}</span>

  /** A proxy for a type (identified by field `underlying`) that forwards most
   *  operations to it. Every operation that is overridden for some kind of types is
   *  forwarded here. Some operations are rewrapped again.
   */
  <span class="keyword">trait</span> <a title="trait RewrappingTypeProxy extends Types.this.Type with Types.this.SimpleTypeProxy with ScalaObject" id="38809">RewrappingTypeProxy</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38808" title="Types.this.SimpleTypeProxy">SimpleTypeProxy</a> <span class="delimiter">{</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="58254">maybeRewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="130093">newtp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#130093" title="Types.this.Type">newtp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#41507" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span> <a href="#38809" title="Types.this.RewrappingTypeProxy" class="keyword">this</a> <span class="keyword">else</span> <a href="#58255" title="(newtp: Types.this.Type)Types.this.Type">rewrap</a><span class="delimiter">(</span><a href="#130093" title="Types.this.Type">newtp</a><span class="delimiter">)</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="58255">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="130096">newtp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a>

    // the following are all operations in class Type that are overridden in some subclass
    // Important to keep this up-to-date when new operations are added!
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="58256">widen</a> = <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41508" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="58257">narrow</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41511" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="58258">deconst</a> = <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41509" title="=&gt; Types.this.Type">deconst</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="58259">resultType</a> = <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41519" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(actuals: List[Types.this.Type])Types.this.Type" id="58260">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="130118">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41520" title="(actuals: List[Types.this.Type])Types.this.Type">resultType</a><span class="delimiter">(</span><a href="#130118" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="58261">finalResultType</a> = <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41523" title="=&gt; Types.this.Type">finalResultType</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="58262">paramSectionCount</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="58263">paramss</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="58264">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="58265">paramTypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="58266">typeArgs</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41517" title="=&gt; List[Types.this.Type]">typeArgs</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="58267">notNull</a> = <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41530" title="=&gt; Types.this.Type">notNull</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="58268">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="130166">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="130167">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41531" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#130166" title="List[Types.this.Symbol]">formals</a>, <a href="#130167" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="58269">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="130170">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="130171">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41532" title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type">skolemizeExistential</a><span class="delimiter">(</span><a href="#130170" title="Types.this.Symbol">owner</a>, <a href="#130171" title="AnyRef">origin</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="58270">normalize</a> = <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="58271">dealias</a> = <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41535" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="58272">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="130188">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41583" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#130188" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="58273">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="130191">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41584" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#130191" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="58274">prefixString</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41588" title="=&gt; String">prefixString</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="58275">isComplete</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41501" title="=&gt; Boolean">isComplete</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="58276">complete</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="130220">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41502" title="(sym: Types.this.Symbol)Unit">complete</a><span class="delimiter">(</span><a href="#130220" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="58277">load</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="130223">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41593" title="(sym: Types.this.Symbol)Unit">load</a><span class="delimiter">(</span><a href="#130223" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="58278">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="130225">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41601" title="(annots: List[Types.this.AnnotationInfo])Types.this.Type">withAnnotations</a><span class="delimiter">(</span><a href="#130225" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="58279">withoutAnnotations</a> = <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41598" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  case <span class="keyword">object</span> <a href="#130260" title="object Types.this.UnmappableTree" id="130266">UnmappableTree</a> <span title="ScalaObject" class="keyword">extends</span> <span title="Types.this.TermTree">TermTree</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="130237">toString</a> = <span title="String(&quot;&lt;unmappable&gt;&quot;)" class="string">&quot;&lt;unmappable&gt;&quot;</span>
    <span class="keyword">super</span>.<span title="(t: Types.this.Type)Unit">tpe_=</span><span class="delimiter">(</span><a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(t: Types.this.Type)Unit" id="130238">tpe_=</a><span class="delimiter">(</span><a title="Types.this.Type" id="130245">t</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130245" title="Types.this.Type">t</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <span title="(x$1: String)UnsupportedOperationException" class="keyword">new</span> <span title="UnsupportedOperationException">UnsupportedOperationException</span><span class="delimiter">(</span><span title="String(&quot;tpe_=(&quot;)" class="string">&quot;tpe_=(&quot;</span><span title="(x$1: Any)String">+</span><a href="#130245" title="Types.this.Type">t</a><span title="(x$1: Any)String">+</span><span title="String(&quot;) inapplicable for &lt;empty&gt;&quot;)" class="string">&quot;) inapplicable for &lt;empty&gt;&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class AbsTypeImpl extends Types.this.AbsType with ScalaObject" id="38812">AbsTypeImpl</a> <a href="#38812" title="ScalaObject" class="keyword">extends</a> <a href="#7741" title="Types.this.AbsType">AbsType</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Type =&gt;
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="41482">declaration</a><span class="delimiter">(</span><a title="Types.this.Name" id="75233">name</a>: <a href="Names.scala.html#38403" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="#41537" title="(name: Types.this.Name)Types.this.Symbol">decl</a><span class="delimiter">(</span><a href="#75233" title="Types.this.Name">name</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="41483">nonPrivateDeclaration</a><span class="delimiter">(</span><a title="Types.this.Name" id="130268">name</a>: <a href="Names.scala.html#38403" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="#41539" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateDecl</a><span class="delimiter">(</span><a href="#130268" title="Types.this.Name">name</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="41484">declarations</a> = <a href="#41536" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="41485">typeArguments</a> = <a href="#41517" title="=&gt; List[Types.this.Type]">typeArgs</a>
    <span class="keyword">def</span> <a title="=&gt; _46.global.Type forSome { val _46: Object with scala.reflect.internal.transform.Erasure{val global: Types.this.type} }" id="41486">erasedType</a> = <a href="transform/Transforms.scala.html#39289" title="(tpe: Types.this.Type)_46.global.Type forSome { val _46: Object with scala.reflect.internal.transform.Erasure{val global: Types.this.type} }">transformedType</a><span class="delimiter">(</span><a href="#38812" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type" id="41487">substituteTypes</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="75216">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="75217">to</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#41558" title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#75216" title="List[Types.this.Symbol]">from</a>, <a href="#75217" title="List[Types.this.Type]">to</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** The base class for all types */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Type extends Types.this.AbsTypeImpl with Types.this.Annotatable[Types.this.Type] with ScalaObject" id="38813">Type</a> <a href="#38813" title="ScalaObject" class="keyword">extends</a> <a href="#38812" title="Types.this.AbsTypeImpl">AbsTypeImpl</a> <span class="keyword">with</span> <a href="AnnotationInfos.scala.html#39325" title="Types.this.Annotatable[Types.this.Type]">Annotatable</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> <span class="delimiter">{</span>
    /** Types for which asSeenFrom always is the identity, no matter what
     *  prefix or owner.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="41489">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is this type higher-kinded, i.e., is it a type constructor @M */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="41490">isHigherKinded</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    /** Does this type denote a stable reference (i.e. singleton type)? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="41491">isStable</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is this type dangerous (i.e. it might contain conflicting
     *  type information when empty, so that it can be constructed
     *  so that type unsoundness results.) A dangerous type has an underlying
     *  type of the form T_1 with T_n { decls }, where one of the
     *  T_i (i &gt; 1) is an abstract type.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="41492">isVolatile</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is this type guaranteed not to have `null` as a value? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="41493">isNotNull</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is this type a structural refinement type (it ''refines'' members that have not been inherited) */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="41494">isStructuralRefinement</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    /** Does this type depend immediately on an enclosing method parameter?
      * I.e., is it a singleton type whose termSymbol refers to an argument of the symbol's owner (which is a method)?
      */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="41495">isImmediatelyDependent</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

    /** Does this depend on an enclosing method parameter? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="41496">isDependent</a>: <span title="Boolean">Boolean</span> = <a href="#39002" title="object Types.this.IsDependentCollector">IsDependentCollector</a>.<a href="#130289" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** True for WildcardType or BoundedWildcardType. */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="41497">isWildcard</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Is this type produced as a repair for an error? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="41498">isError</a>: <span title="Boolean">Boolean</span> = <a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46495" title="=&gt; Boolean">isError</a> <span title="(x: Boolean)Boolean">||</span> <a href="#41503" title="=&gt; Types.this.Symbol">termSymbol</a>.<a href="Symbols.scala.html#46495" title="=&gt; Boolean">isError</a>

    /** Is this type produced as a repair for an error? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="41499">isErroneous</a>: <span title="Boolean">Boolean</span> = <a href="#39018" title="object Types.this.ErroneousCollector">ErroneousCollector</a>.<a href="#130289" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Does this type denote a reference type which can be null? */
    // def isNullable: Boolean = false

    /** Can this type only be subtyped by bottom types?
     *  This is assessed to be the case if the class is final,
     *  and all type parameters (if any) are invariant.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="41500">isFinalType</a> =
      <a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="HasFlags.scala.html#46777" title="=&gt; Boolean">isFinal</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#130325" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46562" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span>

    /** Is this type completed (i.e. not a lazy type)? */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="41501">isComplete</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>

    /** If this is a lazy type, assign a new type to `sym`. */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="41502">complete</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="77399">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>

    /** The term symbol associated with the type
      * Note that the symbol of the normalized type is returned (@see normalize)
      */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="41503">termSymbol</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a>

    /** The type symbol associated with the type
      * Note that the symbol of the normalized type is returned (@see normalize)
      * A type's typeSymbol should if possible not be inspected directly, due to
      * the likelihood that what is true for tp.typeSymbol is not true for
      * tp.sym, due to normalization.
      */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="41504">typeSymbol</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a>

    /** The term symbol ''directly'' associated with the type.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="41505">termSymbolDirect</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="#41503" title="=&gt; Types.this.Symbol">termSymbol</a>

    /** The type symbol ''directly'' associated with the type.
     *  In other words, no normalization is performed: if this is an alias type,
     *  the symbol returned is that of the alias, not the underlying type.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="41506">typeSymbolDirect</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>

    /** The base type underlying a type proxy, identity on all other types */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="41507">underlying</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#38813" title="Types.this.Type" class="keyword">this</a>

    /** Widen from singleton type to its underlying non-singleton
     *  base type by applying one or more `underlying` dereferences,
     *  identity for all other types.
     *
     *  class Outer { class C ; val x: C }
     *  val o: Outer
     *  &lt;o.x.type&gt;.widen = o.C
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="41508">widen</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#38813" title="Types.this.Type" class="keyword">this</a>

    /** Map a constant type or not-null-type to its underlying base type,
     *  identity for all other types.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="41509">deconst</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#38813" title="Types.this.Type" class="keyword">this</a>

    /** The type of `this` of a class type or reference type. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="41510">typeOfThis</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46666" title="=&gt; Types.this.Type">typeOfThis</a>

    /** Map to a singleton type which is a subtype of this type.
     *  The fallback implemented here gives
     *    T.narrow  = T' forSome { type T' &lt;: T with Singleton }
     *  Overridden where we know more about where types come from.
     */
    /*
    Note: this implementation of narrow is theoretically superior to the one
    in use below, but imposed a significant performance penalty.  It was in trunk
    from svn r24960 through r25080.
    */
    /*
    def narrow: Type =
      if (phase.erasedTypes) this
      else commonOwner(this) freshExistential &quot;.type&quot; setInfo singletonBounds(this) tpe
    */

    /** Map to a singleton type which is a subtype of this type.
     *  The fallback implemented here gives:
     *  {{{
     *    T.narrow  =  (T {}).this.type
     *  }}}
     *  Overridden where we know more about where types come from.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="41511">narrow</a>: <a href="#38813" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#38813" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="130331">cowner</a> = <a href="#39020" title="(t: Types.this.Type)Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#38931" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>, <a href="#130331" title="Types.this.Symbol">cowner</a>, <a href="Scopes.scala.html#39180" title="object Types.this.EmptyScope">EmptyScope</a>, <a href="#130331" title="Types.this.Symbol">cowner</a>.<a href="Symbols.scala.html#46379" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>.<a href="#41511" title="=&gt; Types.this.Type">narrow</a>
      <span class="delimiter">}</span>

    /** For a TypeBounds type, itself;
     *  for a reference denoting an abstract type, its bounds,
     *  for all other types, a TypeBounds type all of whose bounds are this type.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="41512">bounds</a>: <a href="#62311" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#62285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** For a class or intersection type, its parents.
     *  For a TypeBounds type, the parents of its hi bound.
     *  inherited by typerefs, singleton types, and refinement types,
     *  The empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="41513">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    /** For a typeref or single-type, the prefix of the normalized type (@see normalize).
     *  NoType for all other types. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="41514">prefix</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#131699" title="object Types.this.NoType">NoType</a>

    /** A chain of all typeref or singletype prefixes of this type, longest first.
     *  (Only used from safeToString.)
     */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="41515">prefixChain</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#38813" title="Types.this.Type" class="keyword">this</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="List[Types.this.Type]">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="130362">pre</a>, _, _<span class="delimiter">)</span> =&gt; <a href="#130362" title="Types.this.Type">pre</a> <a href="#130363" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#130362" title="Types.this.Type">pre</a>.<a href="#41515" title="=&gt; List[Types.this.Type]">prefixChain</a>
      <span class="keyword">case</span> <span title="List[Types.this.Type]">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="130369">pre</a>, _<span class="delimiter">)</span> =&gt; <a href="#130369" title="Types.this.Type">pre</a> <a href="#130370" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#130369" title="Types.this.Type">pre</a>.<a href="#41515" title="=&gt; List[Types.this.Type]">prefixChain</a>
      <span class="keyword">case</span> <span title="List[Nothing]">_</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** This type, without its type arguments @M */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="41516">typeConstructor</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#38813" title="Types.this.Type" class="keyword">this</a>

    /** For a typeref, its arguments. The empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="41517">typeArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    
    /** A list of placeholder types derived from the type parameters.
     *  Used by RefinedType and TypeRef.
     */
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="41518">dummyArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#41528" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#130409" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46625" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>

    /** For a (nullary) method or poly type, its direct result type,
     *  the type itself for all other types. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="41519">resultType</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#38813" title="Types.this.Type" class="keyword">this</a>

    <span class="keyword">def</span> <a title="(actuals: List[Types.this.Type])Types.this.Type" id="41520">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="74194">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#38813" title="Types.this.Type" class="keyword">this</a>

    /** Only used for dependent method types. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="41521">resultApprox</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#130445" title="(tp: Types.this.Type)Types.this.Type">ApproximateDependentMap</a><span class="delimiter">(</span><a href="#41519" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span> // if (!settings.YdepMethTpes.value) resultType else

    /** If this is a TypeRef `clazz`[`T`], return the argument `T`
     *  otherwise return this type
     */
    <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="41522">remove</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="130454">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#38813" title="Types.this.Type" class="keyword">this</a>

    /** For a curried/nullary method or poly type its non-method result type,
     *  the type itself for all other types */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="41523">finalResultType</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#38813" title="Types.this.Type" class="keyword">this</a>

    /** For a method type, the number of its value parameter sections,
     *  0 for all other types */
    <span class="keyword">def</span> <a title="=&gt; Int" id="41524">paramSectionCount</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>

    /** For a method or poly type, a list of its value parameter sections,
     *  the empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="41525">paramss</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    /** For a method or poly type, its first value parameter section,
     *  the empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="41526">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    /** For a method or poly type, the types of its first value parameter section,
     *  the empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="41527">paramTypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    /** For a (potentially wrapped) poly type, its type parameters,
     *  the empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="41528">typeParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    /** For a (potentially wrapped) poly or existential type, its bound symbols,
     *  the empty list for all other types */
    <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="41529">boundSyms</a>: immutable.<span title="scala.collection.immutable.Set[Types.this.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#38774" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">emptySymbolSet</a>

    /** Mixin a NotNull trait unless type already has one
     *  ...if the option is given, since it is causing typing bugs.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="41530">notNull</a>: <a href="#38813" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74515" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">Ynotnull</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">||</span> <a href="#41493" title="=&gt; Boolean">isNotNull</a> <span title="(x: Boolean)Boolean">||</span> <a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#38813" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#147895" title="(underlying: Types.this.Type)Types.this.NotNullType">NotNullType</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Replace formal type parameter symbols with actual type arguments.
     *
     * Amounts to substitution except for higher-kinded types. (See overridden method in TypeRef) -- @M
     */
    <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="41531">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="87888">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="87889">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#87888" title="List[Types.this.Symbol]">formals</a>, <a href="#87889" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#38813" title="Type.this.type" class="keyword">this</a>.<a href="#41558" title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#87888" title="List[Types.this.Symbol]">formals</a>, <a href="#87889" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#131624" title="object Types.this.ErrorType">ErrorType</a>

    /** If this type is an existential, turn all existentially bound variables to type skolems.
     *  @param  owner    The owner of the created type skolems
     *  @param  origin   The tree whose type was an existential for which the skolem was created.
     */
    <span class="keyword">def</span> <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="41532">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="75614">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="75615">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#38813" title="Types.this.Type" class="keyword">this</a>

    /** A simple version of skolemizeExistential for situations where
     *  owner or unpack location do not matter (typically used in subtype tests)
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="41533">skolemizeExistential</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#41532" title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type">skolemizeExistential</a><span class="delimiter">(</span><a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a>, <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>

    /** Reduce to beta eta-long normal form.
     *  Expands type aliases and converts higher-kinded TypeRefs to PolyTypes.
     *  Functions on types are also implemented as PolyTypes.
     *
     *  Example: (in the below, &lt;List&gt; is the type constructor of List)
     *    TypeRef(pre, &lt;List&gt;, List()) is replaced by
     *    PolyType(X, TypeRef(pre, &lt;List&gt;, List(X)))
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="41534">normalize</a> = <a href="#38813" title="Types.this.Type" class="keyword">this</a> // @MAT

    /** Expands type aliases. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="41535">dealias</a> = <a href="#38813" title="Types.this.Type" class="keyword">this</a>

    /** For a classtype or refined type, its defined or declared members;
     *  inherited by subtypes and typerefs.
     *  The empty scope for all other types.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="41536">decls</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a> = <a href="Scopes.scala.html#39180" title="object Types.this.EmptyScope">EmptyScope</a>

    /** The defined or declared members with name `name` in this type;
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Alternatives of overloaded symbol appear in the order they are declared.
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="41537">decl</a><span class="delimiter">(</span><a title="Types.this.Name" id="58620">name</a>: <a href="Names.scala.html#38403" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="#41594" title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol">findDecl</a><span class="delimiter">(</span><a href="#58620" title="Types.this.Name">name</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
    
    /** A list of all non-private members defined or declared in this type. */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="41538">nonPrivateDecls</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#41536" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#60516" title="(p: Types.this.Symbol =&gt; Boolean)Types.this.Scope">filter</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="130509">x</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#130509" title="Types.this.Symbol">x</a>.<a href="HasFlags.scala.html#46782" title="=&gt; Boolean">isPrivate</a><span class="delimiter">)</span> <a href="Scopes.scala.html#60510" title="=&gt; List[Types.this.Symbol]">toList</a>

    /** The non-private defined or declared members with name `name` in this type;
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Alternatives of overloaded symbol appear in the order they are declared.
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="41539">nonPrivateDecl</a><span class="delimiter">(</span><a title="Types.this.Name" id="116132">name</a>: <a href="Names.scala.html#38403" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="#41594" title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol">findDecl</a><span class="delimiter">(</span><a href="#116132" title="Types.this.Name">name</a>, <span title="Int(4)">PRIVATE</span><span class="delimiter">)</span>

    /** A list of all members of this type (defined or inherited)
     *  Members appear in linearization order of their owners.
     *  Members with the same owner appear in reverse order of their declarations.
     */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="41540">members</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#41551" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(0L)" class="int">0</span>, <span title="Long(0L)" class="int">0</span><span class="delimiter">)</span>

    /** A list of all non-private members of this type (defined or inherited) */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="41541">nonPrivateMembers</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#41551" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619972L)">BridgeAndPrivateFlags</span>, <span title="Long(0L)" class="int">0</span><span class="delimiter">)</span>

    /** A list of all non-private members of this type  (defined or inherited),
     *  admitting members with given flags `admit`
     */
    <span class="keyword">def</span> <a title="(admit: Long)List[Types.this.Symbol]" id="41542">nonPrivateMembersAdmitting</a><span class="delimiter">(</span><a title="Long" id="130514">admit</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#41551" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619972L)">BridgeAndPrivateFlags</span> <span title="(x: Long)Long">&amp;</span> <span title="=&gt; Long">~</span><a href="#130514" title="Long">admit</a>, <span title="Long(0L)" class="int">0</span><span class="delimiter">)</span>

    /** A list of all implicit symbols of this type  (defined or inherited) */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="41543">implicitMembers</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#41551" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619968L)">BridgeFlags</span>, <span title="Long(512L)">IMPLICIT</span><span class="delimiter">)</span>

    /** A list of all deferred symbols of this type  (defined or inherited) */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="41544">deferredMembers</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#41551" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619968L)">BridgeFlags</span>, <span title="Long(16L)">DEFERRED</span><span class="delimiter">)</span>

    /** The member with given name,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="41545">member</a><span class="delimiter">(</span><a title="Types.this.Name" id="69059">name</a>: <a href="Names.scala.html#38403" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> =
      <a href="#41552" title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol">memberBasedOnName</a><span class="delimiter">(</span><a href="#69059" title="Types.this.Name">name</a>, <span title="Long(4398113619968L)">BridgeFlags</span><span class="delimiter">)</span>

    /** The non-private member with given name,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Bridges are excluded from the result
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="41546">nonPrivateMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="74424">name</a>: <a href="Names.scala.html#38403" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> =
      <a href="#41552" title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol">memberBasedOnName</a><span class="delimiter">(</span><a href="#74424" title="Types.this.Name">name</a>, <span title="Long(4398113619972L)">BridgeAndPrivateFlags</span><span class="delimiter">)</span>
      
    /** All members with the given flags, excluding bridges.
     */
    <span class="keyword">def</span> <a title="(requiredFlags: Long)List[Types.this.Symbol]" id="41547">membersWithFlags</a><span class="delimiter">(</span><a title="Long" id="130525">requiredFlags</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#41551" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619968L)">BridgeFlags</span>, <a href="#130525" title="Long">requiredFlags</a><span class="delimiter">)</span>

    /** All non-private members with the given flags, excluding bridges.
     */
    <span class="keyword">def</span> <a title="(requiredFlags: Long)List[Types.this.Symbol]" id="41548">nonPrivateMembersWithFlags</a><span class="delimiter">(</span><a title="Long" id="130527">requiredFlags</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#41551" title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619972L)">BridgeAndPrivateFlags</span>, <a href="#130527" title="Long">requiredFlags</a><span class="delimiter">)</span>

    /** The non-private member with given name, admitting members with given flags `admit`.
     *  &quot;Admitting&quot; refers to the fact that members with a PRIVATE, BRIDGE, or VBRIDGE
     *  flag are usually excluded from findMember results, but supplying any of those flags
     *  to this method disables that exclusion.
     *
     *  An OverloadedSymbol if several exist, NoSymbol if none exists.
     */
    <span class="keyword">def</span> <a title="(name: Types.this.Name, admit: Long)Types.this.Symbol" id="41549">nonPrivateMemberAdmitting</a><span class="delimiter">(</span><a title="Types.this.Name" id="116139">name</a>: <a href="Names.scala.html#38403" title="Types.this.Name">Name</a>, <a title="Long" id="116140">admit</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> =
      <a href="#41552" title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol">memberBasedOnName</a><span class="delimiter">(</span><a href="#116139" title="Types.this.Name">name</a>, <span title="Long(4398113619972L)">BridgeAndPrivateFlags</span> <span title="(x: Long)Long">&amp;</span> <span title="=&gt; Long">~</span><a href="#116140" title="Long">admit</a><span class="delimiter">)</span>

    /** The non-local member with given name,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist */
    <span class="keyword">def</span> <a title="(name: Types.this.Name)Types.this.Symbol" id="41550">nonLocalMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="130533">name</a>: <a href="Names.scala.html#38403" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> =
      <a href="#41552" title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol">memberBasedOnName</a><span class="delimiter">(</span><a href="#130533" title="Types.this.Name">name</a>, BridgeFlags <span title="Long(4398114144256L)">|</span> LOCAL<span class="delimiter">)</span>
    
    /** Members excluding and requiring the given flags.
     *  Note: unfortunately it doesn't work to exclude DEFERRED this way.
     */
    <span class="keyword">def</span> <a title="(excludedFlags: Long, requiredFlags: Long)List[Types.this.Symbol]" id="41551">membersBasedOnFlags</a><span class="delimiter">(</span><a title="Long" id="130511">excludedFlags</a>: <span title="Long">Long</span>, <a title="Long" id="130512">requiredFlags</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <a href="#41595" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="StdNames.scala.html#39313" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#58913" title="=&gt; Types.this.nme.NameType">ANYNAME</a>, <a href="#130511" title="Long">excludedFlags</a>, <a href="#130512" title="Long">requiredFlags</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#46653" title="=&gt; List[Types.this.Symbol]">alternatives</a>

    <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol" id="41552">memberBasedOnName</a><span class="delimiter">(</span><a title="Types.this.Name" id="130522">name</a>: <a href="Names.scala.html#38403" title="Types.this.Name">Name</a>, <a title="Long" id="130523">excludedFlags</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> =
      <a href="#41595" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#130522" title="Types.this.Name">name</a>, <a href="#130523" title="Long">excludedFlags</a>, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

    /** The least type instance of given class which is a supertype
     *  of this type.  Example:
     *    class D[T]
     *    class C extends p.D[Int]
     *    ThisType(C).baseType(D) = p.D[Int]
     */
    <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="41553">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="73488">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#131699" title="object Types.this.NoType">NoType</a>

    /** This type as seen from prefix `pre` and class `clazz`. This means:
     *  Replace all thistypes of `clazz` or one of its subclasses
     *  by `pre` and instantiate all parameters by arguments of `pre`.
     *  Proceed analogously for thistypes referring to outer classes.
     *
     *  Example:
     *    class D[T] { def m: T }
     *    class C extends p.D[Int]
     *    T.asSeenFrom(ThisType(C), D)  (where D is owner of m)
     *      = Int
     */
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="41554">asSeenFrom</a><span class="delimiter">(</span><a title="Types.this.Type" id="75198">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="75199">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#41489" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">||</span> <a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#75198" title="Types.this.Type">pre</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#45152" title="=&gt; Types.this.Symbol">ArrayClass</a><span class="delimiter">)</span> <a href="#38813" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
//        scala.tools.nsc.util.trace.when(pre.isInstanceOf[ExistentialType])(&quot;X &quot;+this+&quot;.asSeenfrom(&quot;+pre+&quot;,&quot;+clazz+&quot; = &quot;) {
        <a href="util/StatBase.scala.html#38639" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38671" title="=&gt; scala.reflect.internal.util.Statistics.Counter">asSeenFromCount</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.LongPair" id="130549">start</a> = <a href="util/StatBase.scala.html#38643" title="(tm: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38673" title="=&gt; scala.reflect.internal.util.Statistics.Timer">asSeenFromNanos</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.AsSeenFromMap" id="130550">m</a> = <span title="Types.this.AsSeenFromMap" class="keyword">new</span> <a href="#38994" title="Types.this.AsSeenFromMap">AsSeenFromMap</a><span class="delimiter">(</span><a href="#75198" title="Types.this.Type">pre</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a>, <a href="#75199" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="130551">tp</a> = <a href="#130550" title="Types.this.AsSeenFromMap">m</a> <a href="#130594" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#38813" title="Types.this.Type" class="keyword">this</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="130552">tp1</a> = <a href="#38945" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#130550" title="Types.this.AsSeenFromMap">m</a>.<a href="#130586" title="=&gt; List[Types.this.Symbol]">capturedParams</a>, <a href="#130551" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="130553">result</a>: <a href="#38813" title="Types.this.Type">Type</a> =
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#130550" title="Types.this.AsSeenFromMap">m</a>.<a href="#130583" title="=&gt; List[Types.this.Symbol]">capturedSkolems</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#130552" title="Types.this.Type">tp1</a>
          <span class="keyword">else</span> <a href="Symbols.scala.html#38743" title="(syms: List[Types.this.Symbol], symFn: Types.this.Symbol =&gt; Types.this.Symbol)(tpe: Types.this.Type)Types.this.Type">deriveType</a><span class="delimiter">(</span><a href="#130550" title="Types.this.AsSeenFromMap">m</a>.<a href="#130583" title="=&gt; List[Types.this.Symbol]">capturedSkolems</a>, <a href="#130606" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46656" title="=&gt; Types.this.Symbol">cloneSymbol</a> <a href="Symbols.scala.html#46589" title="(mask: Long)Types.this.Symbol">setFlag</a> <span title="Long(65536L)">CAPTURED</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#130552" title="Types.this.Type">tp1</a><span class="delimiter">)</span>

        <a href="util/StatBase.scala.html#38644" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: scala.reflect.internal.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38673" title="=&gt; scala.reflect.internal.util.Statistics.Timer">asSeenFromNanos</a>, <a href="#130549" title="scala.reflect.internal.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
        <a href="#130553" title="Types.this.Type">result</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** The info of `sym`, seen as a member of this type.
     *
     *  Example:
     *  {{{
     *    class D[T] { def m: T }
     *    class C extends p.D[Int]
     *    ThisType(C).memberType(m) = Int
     *  }}}
     */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="41555">memberInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="112718">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#112718" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41554" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#112718" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** The type of `sym`, seen as a member of this type. */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="41556">memberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="112726">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#112726" title="Types.this.Symbol">sym</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="130625">meth</a>: <a href="Symbols.scala.html#38729" title="Types.this.MethodSymbol">MethodSymbol</a> =&gt;
        <a href="#130625" title="Types.this.MethodSymbol">meth</a>.<a href="Symbols.scala.html#70162" title="(pre: Types.this.Type)Types.this.Type">typeAsMemberOf</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#41557" title="(sym: Types.this.Symbol)Types.this.Type">computeMemberType</a><span class="delimiter">(</span><a href="#112726" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="41557">computeMemberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="117664">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#117664" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46607" title="=&gt; Types.this.Type">tpeHK</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span> //@M don't prematurely instantiate higher-kinded types, they will be instantiated by transform, typedTypeApply, etc. when really necessary
      <span class="keyword">case</span> <span title="Types.this.OverloadedType">OverloadedType</span><span class="delimiter">(</span>_, <a title="List[Types.this.Symbol]" id="130627">alts</a><span class="delimiter">)</span> =&gt;
        <a href="#147887" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.OverloadedType">OverloadedType</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#130627" title="List[Types.this.Symbol]">alts</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="130630">tp</a> =&gt;
        <a href="#130630" title="Types.this.Type">tp</a>.<a href="#41554" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#117664" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Substitute types `to` for occurrences of references to
     *  symbols `from` in this type.
     */
    <span class="keyword">def</span> <a title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type" id="41558">subst</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="130270">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="130271">to</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#130270" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#38813" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.SubstTypeMap" class="keyword">new</span> <a href="#38998" title="Types.this.SubstTypeMap">SubstTypeMap</a><span class="delimiter">(</span><a href="#130270" title="List[Types.this.Symbol]">from</a>, <a href="#130271" title="List[Types.this.Type]">to</a><span class="delimiter">)</span> <a href="#128692" title="(tp0: Types.this.Type)Types.this.Type">apply</a> <a href="#38813" title="Types.this.Type" class="keyword">this</a>

    /** Substitute symbols `to` for occurrences of symbols `from` in this type.
     *
     * !!! NOTE !!!: If you need to do a substThis and a substSym, the substThis has to come
     * first, as otherwise symbols will immediately get rebound in typeRef to the old
     * symbol.
     */
    <span class="keyword">def</span> <a title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type" id="41559">substSym</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="75565">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="75566">to</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#75565" title="List[Types.this.Symbol]">from</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#75566" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#75565" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#38813" title="Types.this.Type" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.SubstSymMap" class="keyword">new</span> <a href="#38997" title="Types.this.SubstSymMap">SubstSymMap</a><span class="delimiter">(</span><a href="#75565" title="List[Types.this.Symbol]">from</a>, <a href="#75566" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <a href="#128776" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#38813" title="Types.this.Type" class="keyword">this</a>

    /** Substitute all occurrences of `ThisType(from)` in this type by `to`.
     *
     * !!! NOTE !!!: If you need to do a substThis and a substSym, the substThis has to come
     * first, as otherwise symbols will immediately get rebound in typeRef to the old
     * symbol.
     */
    <span class="keyword">def</span> <a title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type" id="41560">substThis</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="75592">from</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="75593">to</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
      <span title="Types.this.SubstThisMap" class="keyword">new</span> <a href="#38999" title="Types.this.SubstThisMap">SubstThisMap</a><span class="delimiter">(</span><a href="#75592" title="Types.this.Symbol">from</a>, <a href="#75593" title="Types.this.Type">to</a><span class="delimiter">)</span> <a href="#130642" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#38813" title="Types.this.Type" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(from: Types.this.Symbol, to: Types.this.Symbol)Types.this.Type" id="41561">substThis</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="75597">from</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="75598">to</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
      <a href="#41560" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#75597" title="Types.this.Symbol">from</a>, <a href="#75598" title="Types.this.Symbol">to</a>.<a href="Symbols.scala.html#46667" title="=&gt; Types.this.Type">thisType</a><span class="delimiter">)</span>

    /** Performs both substThis and substSym in one traversal.
     */
    <span class="keyword">def</span> <a title="(from: Types.this.Symbol, to: Types.this.Type, symsFrom: List[Types.this.Symbol], symsTo: List[Types.this.Symbol])Types.this.Type" id="41562">substThisAndSym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="115591">from</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="115592">to</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="115593">symsFrom</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="115594">symsTo</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#115593" title="List[Types.this.Symbol]">symsFrom</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#115594" title="List[Types.this.Symbol]">symsTo</a><span class="delimiter">)</span> <a href="#41560" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#115591" title="Types.this.Symbol">from</a>, <a href="#115592" title="Types.this.Type">to</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Types.this.SubstThisAndSymMap" class="keyword">new</span> <a href="#39000" title="Types.this.SubstThisAndSymMap">SubstThisAndSymMap</a><span class="delimiter">(</span><a href="#115591" title="Types.this.Symbol">from</a>, <a href="#115592" title="Types.this.Type">to</a>, <a href="#115593" title="List[Types.this.Symbol]">symsFrom</a>, <a href="#115594" title="List[Types.this.Symbol]">symsTo</a><span class="delimiter">)</span> <a href="#130671" title="(tp: Types.this.Type)Types.this.Type">apply</a> <a href="#38813" title="Types.this.Type" class="keyword">this</a>
    <span class="delimiter">}</span>

    /** Returns all parts of this type which satisfy predicate `p` */
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]" id="41563">filter</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="130681">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="Types.this.FilterTypeCollector" class="keyword">new</span> <a href="#39015" title="Types.this.FilterTypeCollector">FilterTypeCollector</a><span class="delimiter">(</span><a href="#130681" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span> <a href="#130687" title="(tp: Types.this.Type)List[Types.this.Type]">collect</a> <a href="#38813" title="Types.this.Type" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Types.this.FilterTypeCollector{def foreach[U](f: Types.this.Type =&gt; U): Unit; def map[T](f: Types.this.Type =&gt; T): List[T]}" id="41564">withFilter</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="130700">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> = <a href="#130703" title="Types.this.FilterTypeCollector{def foreach[U](f: Types.this.Type =&gt; U): Unit; def map[T](f: Types.this.Type =&gt; T): List[T]}" class="keyword">new</a> <a href="#39015" title="anonymous class $anon extends Types.this.FilterTypeCollector" id="130703">FilterTypeCollector</a><span class="delimiter">(</span><a href="#130700" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="[U](f: Types.this.Type =&gt; U)Unit" id="130705">foreach</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="130707">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; U" id="130711">f</a>: Type =&gt; U<span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#130687" title="(tp: Types.this.Type)List[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type">Type</a>.<span class="keyword">this</span><span class="delimiter">)</span> <span title="(f: Types.this.Type =&gt; U)Unit">foreach</span> <a href="#130711" title="Types.this.Type =&gt; U">f</a>
      <span class="keyword">def</span> <a title="[T](f: Types.this.Type =&gt; T)List[T]" id="130708">map</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="130710">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; T" id="130713">f</a>: Type =&gt; T<span class="delimiter">)</span>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span>  = <a href="#130687" title="(tp: Types.this.Type)List[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type">Type</a>.<span class="keyword">this</span><span class="delimiter">)</span> <span title="(f: Types.this.Type =&gt; T)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],T,List[T]])List[T]">map</span> <a href="#130713" title="Types.this.Type =&gt; T">f</a>
    <span class="delimiter">}</span>

    /** Returns optionally first type (in a preorder traversal) which satisfies predicate `p`,
     *  or None if none exists.
     */
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Option[Types.this.Type]" id="41565">find</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="74693">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <span title="Option[Types.this.Type]">Option</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="Types.this.FindTypeCollector" class="keyword">new</span> <a href="#39017" title="Types.this.FindTypeCollector">FindTypeCollector</a><span class="delimiter">(</span><a href="#74693" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span>.<a href="#130289" title="(tp: Types.this.Type)Option[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Apply `f` to each part of this type */
    <span class="keyword">def</span> <a title="(f: Types.this.Type =&gt; Unit)Unit" id="41566">foreach</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Unit" id="74698">f</a>: Type =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Types.this.ForEachTypeTraverser" class="keyword">new</span> <a href="#39016" title="Types.this.ForEachTypeTraverser">ForEachTypeTraverser</a><span class="delimiter">(</span><a href="#74698" title="Types.this.Type =&gt; Unit">f</a><span class="delimiter">)</span>.<a href="#130857" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span> <span class="delimiter">}</span>

    /** Apply `f` to each part of this type; children get mapped before their parents */
    <span class="keyword">def</span> <a title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.Type" id="41567">map</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Types.this.Type" id="74703">f</a>: Type =&gt; Type<span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#130862" title="Types.this.TypeMap" class="keyword">new</a> <a href="#38980" title="anonymous class $anon extends Types.this.TypeMap" id="130862">TypeMap</a> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(x: Types.this.Type)Types.this.Type" id="130864">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="130865">x</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#74703" title="(v1: Types.this.Type)Types.this.Type">f</a><span class="delimiter">(</span><a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#130865" title="Types.this.Type">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <a href="#130864" title="(x: Types.this.Type)Types.this.Type">apply</a> <a href="#38813" title="Types.this.Type" class="keyword">this</a>

    /** Is there part of this type which satisfies predicate `p`? */
    <span class="keyword">def</span> <a title="(p: Types.this.Type =&gt; Boolean)Boolean" id="41568">exists</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="74688">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="=&gt; Boolean">!</span><a href="#41565" title="(p: Types.this.Type =&gt; Boolean)Option[Types.this.Type]">find</a><span class="delimiter">(</span><a href="#74688" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span>.<span title="=&gt; Boolean">isEmpty</span>

    /** Does this type contain a reference to this symbol? */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="41569">contains</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="74683">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="Types.this.ContainsCollector" class="keyword">new</span> <a href="#39013" title="Types.this.ContainsCollector">ContainsCollector</a><span class="delimiter">(</span><a href="#74683" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#130289" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Does this type contain a reference to this type */
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="41570">containsTp</a><span class="delimiter">(</span><a title="Types.this.Type" id="130892">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="Types.this.ContainsTypeCollector" class="keyword">new</span> <a href="#39014" title="Types.this.ContainsTypeCollector">ContainsTypeCollector</a><span class="delimiter">(</span><a href="#130892" title="Types.this.Type">tp</a><span class="delimiter">)</span>.<a href="#130289" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Is this type a subtype of that type? */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="41571">&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="73357">that</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span>util.<a href="util/Statistics.scala.html#10815" title="object scala.reflect.internal.util.Statistics">Statistics</a>.<a href="util/StatBase.scala.html#38635" title="=&gt; Boolean">enabled</a><span class="delimiter">)</span> <a href="#41573" title="(that: Types.this.Type)Boolean">stat_&lt;:&lt;</a><span class="delimiter">(</span><a href="#73357" title="Types.this.Type">that</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="delimiter">(</span><a href="#38813" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#73357" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
        <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#38772" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#39135" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;&lt;:&quot;)" class="string">&quot;&lt;:&quot;</span>, <a href="#39061" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a>, <a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#73357" title="Types.this.Type">that</a><span class="delimiter">)</span>
         <span class="keyword">else</span> <a href="#39062" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#73357" title="Types.this.Type">that</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** Is this type a subtype of that type in a pattern context?
     *  Any type arguments on the right hand side are replaced with
     *  fresh existentials, except for Arrays.
     *
     *  See bug1434.scala for an example of code which would fail
     *  if only a &lt;:&lt; test were applied.
     */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="41572">matchesPattern</a><span class="delimiter">(</span><a title="Types.this.Type" id="130939">that</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="delimiter">(</span><a href="#38813" title="Type.this.type" class="keyword">this</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#130939" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#130939" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>TypeRef<span class="delimiter">(</span>_, <a href="Definitions.scala.html#45152" title="=&gt; Types.this.Symbol">ArrayClass</a>, <a href="#130951" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="130962">arg1</a><span class="delimiter">)</span><span class="delimiter">)</span>, TypeRef<span class="delimiter">(</span>_, <a href="Definitions.scala.html#45152" title="=&gt; Types.this.Symbol">ArrayClass</a>, <a href="#130964" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="130975">arg2</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#130975" title="Types.this.Type">arg2</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">nonEmpty</span> =&gt;
          <a href="#130962" title="Types.this.Type">arg1</a> <a href="#41572" title="(that: Types.this.Type)Boolean">matchesPattern</a> <a href="#130975" title="Types.this.Type">arg2</a>
        <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>_, TypeRef<span class="delimiter">(</span>_, _, <a title="List[Types.this.Type]" id="130979">args</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="130980">newtp</a> = <a href="#38945" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#130979" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <span class="delimiter">(</span><a href="#130997" title="Types.this.Type">_</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>, <a href="#130939" title="Types.this.Type">that</a><span class="delimiter">)</span>
          <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#130939" title="Types.this.Type">that</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#130980" title="Types.this.Type">newtp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#38813" title="Type.this.type" class="keyword">this</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#130980" title="Types.this.Type">newtp</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
          <span title="Boolean(false)" class="keyword">false</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="41573">stat_&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="130906">that</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="util/StatBase.scala.html#38639" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38675" title="=&gt; scala.reflect.internal.util.Statistics.Counter">subtypeCount</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.LongPair" id="131026">start</a> = <a href="util/StatBase.scala.html#38643" title="(tm: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38677" title="=&gt; scala.reflect.internal.util.Statistics.Timer">subtypeNanos</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Boolean" id="131027">result</a> =
        <span class="delimiter">(</span><a href="#38813" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130906" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
        <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#38772" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#39135" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;&lt;:&quot;)" class="string">&quot;&lt;:&quot;</span>, <a href="#39061" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a>, <a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#130906" title="Types.this.Type">that</a><span class="delimiter">)</span>
         <span class="keyword">else</span> <a href="#39062" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#130906" title="Types.this.Type">that</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="util/StatBase.scala.html#38644" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: scala.reflect.internal.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38677" title="=&gt; scala.reflect.internal.util.Statistics.Timer">subtypeNanos</a>, <a href="#131026" title="scala.reflect.internal.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
      <a href="#131027" title="Boolean">result</a>
    <span class="delimiter">}</span>

    /** Is this type a weak subtype of that type? True also for numeric types, i.e. Int weak_&lt;:&lt; Long.
     */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="41574">weak_&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="131052">that</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="util/StatBase.scala.html#38639" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38675" title="=&gt; scala.reflect.internal.util.Statistics.Counter">subtypeCount</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.LongPair" id="131054">start</a> = <a href="util/StatBase.scala.html#38643" title="(tm: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38677" title="=&gt; scala.reflect.internal.util.Statistics.Timer">subtypeNanos</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Boolean" id="131055">result</a> =
        <span class="delimiter">(</span><span class="delimiter">(</span><a href="#38813" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131052" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
         <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#38772" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#39135" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;weak_&lt;:&quot;)" class="string">&quot;weak_&lt;:&quot;</span>, <a href="#39101" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isWeakSubType</a>, <a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#131052" title="Types.this.Type">that</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#39101" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isWeakSubType</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#131052" title="Types.this.Type">that</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="util/StatBase.scala.html#38644" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: scala.reflect.internal.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38677" title="=&gt; scala.reflect.internal.util.Statistics.Timer">subtypeNanos</a>, <a href="#131054" title="scala.reflect.internal.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
      <a href="#131055" title="Boolean">result</a>
    <span class="delimiter">}</span>

    /** Is this type equivalent to that type? */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="41575">=:=</a><span class="delimiter">(</span><a title="Types.this.Type" id="63861">that</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span>
      <span class="delimiter">(</span><a href="#38813" title="Type.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#63861" title="Types.this.Type">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
      <span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#38772" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#39135" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;=&quot;)" class="string">&quot;=&quot;</span>, <a href="#39044" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a>, <a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#63861" title="Types.this.Type">that</a><span class="delimiter">)</span>
       <span class="keyword">else</span> <a href="#39044" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#63861" title="Types.this.Type">that</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>;

    /** Does this type implement symbol `sym` with same or stronger type? */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="41576">specializes</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="131120">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#38772" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#39135" title="(op: String, p: (Types.this.Type, Types.this.Symbol) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Symbol)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;specializes&quot;)" class="string">&quot;specializes&quot;</span>, <a href="#39074" title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean">specializesSym</a>, <a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#131120" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#39074" title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#131120" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>

    /** Is this type close enough to that type so that members
     *  with the two type would override each other?
     *  This means:
     *    - Either both types are polytypes with the same number of
     *      type parameters and their result types match after renaming
     *      corresponding type parameters
     *    - Or both types are (nullary) method types with equivalent type parameter types
     *      and matching result types
     *    - Or both types are equivalent
     *    - Or phase.erasedTypes is false and both types are neither method nor
     *      poly types.
     */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="41577">matches</a><span class="delimiter">(</span><a title="Types.this.Type" id="82782">that</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#82782" title="Types.this.Type">that</a>, <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>

    /** Same as matches, except that non-method types are always assumed to match. */
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="41578">looselyMatches</a><span class="delimiter">(</span><a title="Types.this.Type" id="131156">that</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#131156" title="Types.this.Type">that</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

    /** The shortest sorted upwards closed array of types that contains
     *  this type as first element.
     *
     *  A list or array of types ts is upwards closed if
     *
     *    for all t in ts:
     *      for all typerefs p.s[args] such that t &lt;: p.s[args]
     *      there exists a typeref p'.s[args'] in ts such that
     *      t &lt;: p'.s['args] &lt;: p.s[args],
     *
     *      and
     *
     *      for all singleton types p.s such that t &lt;: p.s
     *      there exists a singleton type p'.s in ts such that
     *      t &lt;: p'.s &lt;: p.s
     *
     *  Sorting is with respect to Symbol.isLess() on type symbols.
     */
    <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="41579">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#39264" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="BaseTypeSeqs.scala.html#39267" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">baseTypeSingletonSeq</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** The maximum depth (@see maxDepth)
     *  of each type in the BaseTypeSeq of this type.
     */
    <span class="keyword">def</span> <a title="=&gt; Int" id="41580">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <span title="Int(1)" class="int">1</span>

    /** The list of all baseclasses of this type (including its own typeSymbol)
     *  in reverse linearization order, starting with the class itself and ending
     *  in class Any.
     */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="41581">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>

    /**
     *  @param sym the class symbol
     *  @return    the index of given class symbol in the BaseTypeSeq of this type,
     *             or -1 if no base type with given class symbol exists.
     */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Int" id="41582">baseTypeIndex</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="118019">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="131166">bts</a> = <a href="#41579" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
      <span class="keyword">var</span> <a title="Int" id="131167">lo</a> = <span title="Int(0)" class="int">0</span>
      <span class="keyword">var</span> <a title="Int" id="131168">hi</a> = <a href="#131166" title="Types.this.BaseTypeSeq">bts</a>.<a href="BaseTypeSeqs.scala.html#59592" title="=&gt; Int">length</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#131167" title="Int">lo</a> <span title="(x: Int)Boolean">&lt;=</span> <a href="#131168" title="Int">hi</a><span class="delimiter">)</span> <a href="#131169" title="()Unit" class="delimiter">{</a>
        <span class="keyword">val</span> <a title="Int" id="131178">mid</a> = <span class="delimiter">(</span><a href="#131167" title="Int">lo</a> <span title="(x: Int)Int">+</span> <a href="#131168" title="Int">hi</a><span class="delimiter">)</span> <span title="(x: Int)Int">/</span> <span title="Int(2)" class="int">2</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="131179">btssym</a> = <a href="#131166" title="Types.this.BaseTypeSeq">bts</a>.<a href="BaseTypeSeqs.scala.html#59597" title="(i: Int)Types.this.Symbol">typeSymbol</a><span class="delimiter">(</span><a href="#131178" title="Int">mid</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#118019" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#131179" title="Types.this.Symbol">btssym</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#131178" title="Int">mid</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#118019" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#46647" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#131179" title="Types.this.Symbol">btssym</a><span class="delimiter">)</span> <a href="#131168" title="Int">hi</a> = <a href="#131178" title="Int">mid</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#131179" title="Types.this.Symbol">btssym</a> <a href="Symbols.scala.html#46647" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#118019" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#131167" title="Int">lo</a> = <a href="#131178" title="Int">mid</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>
        <span class="keyword">else</span> <a href="SymbolTable.scala.html#35604" title="()Nothing">abort</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      -<span title="Int(-1)" class="int">1</span>
    <span class="delimiter">}</span>

    /** If this is a poly- or methodtype, a copy with cloned type / value parameters
     *  owned by `owner`. Identity for all other types.
     */
    <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="41583">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="75547">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#38813" title="Types.this.Type" class="keyword">this</a>

    /** Make sure this type is correct as the info of given owner; clone it if not. */
    <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="41584">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="75521">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#38813" title="Types.this.Type" class="keyword">this</a>

    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; String" id="41585">objectPrefix</a> = <span title="String(&quot;object &quot;)" class="string">&quot;object &quot;</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; String" id="41586">packagePrefix</a> = <span title="String(&quot;package &quot;)" class="string">&quot;package &quot;</span>
    <span class="keyword">def</span> <a title="(str: String)String" id="41587">trimPrefix</a><span class="delimiter">(</span><a title="String" id="130198">str</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#130198" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">str</a> <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">stripPrefix</span> <a href="#41585" title="=&gt; String">objectPrefix</a> <span title="(prefix: String)String">stripPrefix</span> <a href="#41586" title="=&gt; String">packagePrefix</a>

    /** The string representation of this type used as a prefix */
    <span class="keyword">def</span> <a title="=&gt; String" id="41588">prefixString</a> = <a href="#41587" title="(str: String)String">trimPrefix</a><span class="delimiter">(</span><a href="#41589" title="()String">toString</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span>

   /** Convert toString avoiding infinite recursions by cutting off
     *  after `maxTostringRecursions` recursion levels. Uses `safeToString`
     *  to produce a string on each level.
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="41589">toString</a>: <span title="String">String</span> = <a href="#39151" title="(tpe: Types.this.Type)String">typeToString</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Method to be implemented in subclasses.
     *  Converts this type to a string in calling toString for its parts.
     */
    <span class="keyword">def</span> <a title="=&gt; String" id="41590">safeToString</a>: <span title="String">String</span> = <a href="#38813" title="Types.this.Type" class="keyword">super</a>.<span title="()String">toString</span>

    /** The string representation of this type, with singletypes explained. */
    <span class="keyword">def</span> <a title="=&gt; String" id="41591">toLongString</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="129410">str</a> = <a href="#41589" title="()String">toString</a>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#129410" title="String">str</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="String(&quot;type&quot;)" class="string">&quot;type&quot;</span><span class="delimiter">)</span> <a href="#41508" title="=&gt; Types.this.Type">widen</a>.<a href="#41589" title="()String">toString</a>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#129410" title="String">str</a> <span title="(x$1: String)Boolean">endsWith</span> <span title="String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span><span class="delimiter">)</span> <a href="#129410" title="String">str</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; (with underlying type &quot;)" class="string">&quot; (with underlying type &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#41508" title="=&gt; Types.this.Type">widen</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
      <span class="keyword">else</span> <a href="#129410" title="String">str</a>
    <span class="delimiter">}</span>

    /** A test whether a type contains any unification type variables. */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="41592">isGround</a>: <span title="Boolean">Boolean</span> = <a href="#38813" title="Types.this.Type" class="keyword">this</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#84008" title="Boolean">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="131212">constr</a><span class="delimiter">)</span> =&gt;
        <a href="#131212" title="Types.this.TypeConstraint">constr</a>.<a href="#84071" title="=&gt; Boolean">instValid</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#131212" title="Types.this.TypeConstraint">constr</a>.<a href="#84069" title="=&gt; Types.this.Type">inst</a>.<a href="#41592" title="=&gt; Boolean">isGround</a>
      <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="131216">pre</a>, <a title="Types.this.Symbol" id="131217">sym</a>, <a title="List[Types.this.Type]" id="131218">args</a><span class="delimiter">)</span> =&gt;
        <a href="#131217" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="#131216" title="Types.this.Type">pre</a>.<a href="#41592" title="=&gt; Boolean">isGround</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#131218" title="List[Types.this.Type]">args</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#131225" title="Types.this.Type">_</a>.<a href="#41592" title="=&gt; Boolean">isGround</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="131226">pre</a>, <a title="Types.this.Symbol" id="131227">sym</a><span class="delimiter">)</span> =&gt;
        <a href="#131227" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="#131226" title="Types.this.Type">pre</a>.<a href="#41592" title="=&gt; Boolean">isGround</a>
      <span class="keyword">case</span> <span title="Boolean(true)">ThisType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> | <a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a> | <a href="#131644" title="object Types.this.WildcardType">WildcardType</a> | <a href="#131699" title="object Types.this.NoType">NoType</a> | <a href="#131624" title="object Types.this.ErrorType">ErrorType</a> | ConstantType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
        <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#131229" title="(tp: Types.this.Type)Types.this.Type">typeVarToOriginMap</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#38813" title="Types.this.Type" class="keyword">this</a>
    <span class="delimiter">}</span>

    /** If this is a symbol loader type, load and assign a new type to `sym`. */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="41593">load</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="114518">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol" id="41594">findDecl</a><span class="delimiter">(</span><a title="Types.this.Name" id="130498">name</a>: <a href="Names.scala.html#38403" title="Types.this.Name">Name</a>, <a title="Int" id="130499">excludedFlags</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="131234">alts</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="131235">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a>
      <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="131236">e</a>: <a href="Scopes.scala.html#39170" title="Types.this.ScopeEntry">ScopeEntry</a> = <a href="#41536" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60508" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#130498" title="Types.this.Name">name</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#131236" title="Types.this.ScopeEntry">e</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#131237" title="()Unit" class="delimiter">{</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#131236" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#92379" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46593" title="(mask: Long)Boolean">hasFlag</a><span class="delimiter">(</span><a href="#130499" title="=&gt; Long">excludedFlags</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#131235" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#131235" title="Types.this.Symbol">sym</a> = <a href="#131236" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#92379" title="=&gt; Types.this.Symbol">sym</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#131234" title="List[Types.this.Symbol]">alts</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#131234" title="List[Types.this.Symbol]">alts</a> = <span title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</span><span class="delimiter">(</span><a href="#131235" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <a href="#131234" title="List[Types.this.Symbol]">alts</a> = <a href="#131236" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#92379" title="=&gt; Types.this.Symbol">sym</a> <a href="#131260" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#131234" title="List[Types.this.Symbol]">alts</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <a href="#131236" title="Types.this.ScopeEntry">e</a> = <a href="#41536" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60509" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a><span class="delimiter">(</span><a href="#131236" title="Types.this.ScopeEntry">e</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#131234" title="List[Types.this.Symbol]">alts</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#131235" title="Types.this.Symbol">sym</a>
      <span class="keyword">else</span> <span class="delimiter">(</span><a href="#41581" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#46407" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.Symbol">newOverloaded</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#131234" title="List[Types.this.Symbol]">alts</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /**
     *  Find member(s) in this type. If several members matching criteria are found, they are
     *  returned in an OverloadedSymbol
     *
     *  @param name           The member's name, where nme.ANYNAME means `unspecified`
     *  @param excludedFlags  Returned members do not have these flags
     *  @param requiredFlags  Returned members do have these flags
     *  @param stableOnly     If set, return only members that are types or stable values
     */
    //TODO: use narrow only for modules? (correct? efficiency gain?)
    <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol" id="41595">findMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="130539">name</a>: <a href="Names.scala.html#38403" title="Types.this.Name">Name</a>, <a title="Long" id="130540">excludedFlags</a>: <span title="Long">Long</span>, <a title="Long" id="130541">requiredFlags</a>: <span title="Long">Long</span>, <a title="Boolean" id="130542">stableOnly</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      // if this type contains type variables, put them to sleep for a while -- don't just wipe them out by
      // replacing them by the corresponding type parameter, as that messes up (e.g.) type variables in type refinements
      // without this, the matchesType call would lead to type variables on both sides
      // of a subtyping/equality judgement, which can lead to recursive types being constructed.
      // See (t0851) for a situation where this happens.
      <span class="keyword">val</span> <a title="List[Types.this.TypeVar]" id="131271">suspension</a>: <span title="List[Types.this.TypeVar]">List</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> = <span title="List[Types.this.TypeVar]" class="keyword">if</span> <span class="delimiter">(</span><a href="#38813" title="Type.this.type" class="keyword">this</a>.<a href="#41592" title="=&gt; Boolean">isGround</a><span class="delimiter">)</span> <span title="Null(null)" class="keyword">null</span> <span class="keyword">else</span> <a href="#39120" title="(tp: Types.this.Type)List[Types.this.TypeVar]">suspendTypeVarsInType</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

      <a href="util/StatBase.scala.html#38639" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38663" title="=&gt; scala.reflect.internal.util.Statistics.Counter">findMemberCount</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.LongPair" id="131272">start</a> = <a href="util/StatBase.scala.html#38643" title="(tm: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.LongPair">startTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38669" title="=&gt; scala.reflect.internal.util.Statistics.Timer">findMemberNanos</a><span class="delimiter">)</span>

      //Console.println(&quot;find member &quot; + name.decode + &quot; in &quot; + this + &quot;:&quot; + this.baseClasses)//DEBUG
      <span class="keyword">var</span> <a title="Types.this.Scope" id="131273">members</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a> = <span title="Null(null)" class="keyword">null</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="131274">member</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a>
      <span class="keyword">var</span> <a title="Long" id="131275">excluded</a> = <a href="#130540" title="Long">excludedFlags</a> <span title="(x: Int)Long">|</span> <span title="Int(16)">DEFERRED</span>
      <span class="keyword">var</span> <a title="Boolean" id="131276">continue</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">var</span> <a title="Types.this.Type" id="131277">self</a>: <a href="#38813" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
      <span class="keyword">var</span> <a title="Types.this.Type" id="131278">membertpe</a>: <a href="#38813" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#131276" title="Boolean">continue</a><span class="delimiter">)</span> <a href="#131279" title="()Unit" class="delimiter">{</a>
        <a href="#131276" title="Boolean">continue</a> = <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="131288">bcs0</a> = <a href="#41581" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
        <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="131289">bcs</a> = <a href="#131288" title="List[Types.this.Symbol]">bcs0</a>
        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#131289" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#131290" title="()Unit" class="delimiter">{</a>
          <span class="keyword">val</span> <a title="Types.this.Scope" id="131292">decls</a> = <a href="#131289" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41536" title="=&gt; Types.this.Scope">decls</a>
          <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="131293">entry</a> =
            <span title="Types.this.ScopeEntry" class="keyword">if</span> <span class="delimiter">(</span><a href="#130539" title="Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#39313" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#58913" title="=&gt; Types.this.nme.NameType">ANYNAME</a><span class="delimiter">)</span> <a href="#131292" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60476" title="=&gt; Types.this.ScopeEntry">elems</a> <span class="keyword">else</span> <a href="#131292" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60508" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#130539" title="Types.this.Name">name</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#131293" title="Types.this.ScopeEntry">entry</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#131294" title="()Unit" class="delimiter">{</a>
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="131301">sym</a> = <a href="#131293" title="Types.this.ScopeEntry">entry</a>.<a href="Scopes.scala.html#92379" title="=&gt; Types.this.Symbol">sym</a>
            <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#131301" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#46594" title="(mask: Long)Boolean">hasAllFlags</a> <a href="#130541" title="Long">requiredFlags</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Long" id="131302">excl</a> = <a href="#131301" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46591" title="(mask: Long)Long">getFlag</a><span class="delimiter">(</span><a href="#131275" title="Long">excluded</a><span class="delimiter">)</span>
              <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#131302" title="Long">excl</a> <span title="(x: Long)Boolean">==</span> <span title="Long(0L)" class="long">0L</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                  <span class="delimiter">(</span>// omit PRIVATE LOCALS unless selector class is contained in class owning the def.
                   <span class="delimiter">(</span><a href="#131289" title="List[Types.this.Symbol]">bcs</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131288" title="List[Types.this.Symbol]">bcs0</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
                   <span title="=&gt; Boolean">!</span><a href="#131301" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#46786" title="=&gt; Boolean">isPrivateLocal</a> <span title="(x: Boolean)Boolean">||</span>
                   <span class="delimiter">(</span><a href="#131288" title="List[Types.this.Symbol]">bcs0</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#46570" title="(sym: Types.this.Symbol)Boolean">hasTransOwner</a><span class="delimiter">(</span><a href="#131289" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Types.this.Symbol">head</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#130539" title="Types.this.Name">name</a>.<a href="Names.scala.html#52125" title="=&gt; Boolean">isTypeName</a> <span title="(x: Boolean)Boolean">||</span> <a href="#130542" title="Boolean">stableOnly</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#131301" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46534" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <a href="util/StatBase.scala.html#38644" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: scala.reflect.internal.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38669" title="=&gt; scala.reflect.internal.util.Statistics.Timer">findMemberNanos</a>, <a href="#131272" title="scala.reflect.internal.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
                  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#131271" title="List[Types.this.TypeVar]">suspension</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#131271" title="List[Types.this.TypeVar]">suspension</a> <span title="(f: Types.this.TypeVar =&gt; Unit)Unit">foreach</span> <span class="delimiter">(</span><a href="#131328" title="Types.this.TypeVar">_</a>.<a href="#83983" title="(x$1: Boolean)Unit">suspended</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
                  <span title="Nothing" class="keyword">return</span> <a href="#131301" title="Types.this.Symbol">sym</a>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#131274" title="Types.this.Symbol">member</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <a href="#131274" title="Types.this.Symbol">member</a> = <a href="#131301" title="Types.this.Symbol">sym</a>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#131273" title="Types.this.Scope">members</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#131274" title="Types.this.Symbol">member</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#131301" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a> <span title="(x: Boolean)Boolean">||</span>
                      <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#131274" title="Types.this.Symbol">member</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#131301" title="Types.this.Symbol">sym</a> <span title="(x: Boolean)Boolean">||</span>
                        <a href="#131274" title="Types.this.Symbol">member</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#131301" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                        <span title="=&gt; Boolean">!</span><a href="#131301" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#46782" title="=&gt; Boolean">isPrivate</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
                          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#131277" title="Types.this.Type">self</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#131277" title="Types.this.Type">self</a> = <a href="#38813" title="Type.this.type" class="keyword">this</a>.<a href="#41511" title="=&gt; Types.this.Type">narrow</a>
                          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#131278" title="Types.this.Type">membertpe</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#131278" title="Types.this.Type">membertpe</a> = <a href="#131277" title="Types.this.Type">self</a>.<a href="#41556" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#131274" title="Types.this.Symbol">member</a><span class="delimiter">)</span>
                          <span class="delimiter">(</span><a href="#131278" title="Types.this.Type">membertpe</a> <a href="#41577" title="(that: Types.this.Type)Boolean">matches</a> <a href="#131277" title="Types.this.Type">self</a>.<a href="#41556" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#131301" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                        <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#131273" title="Types.this.Scope">members</a> = <a href="Scopes.scala.html#39175" title="()Types.this.Scope">newScope</a>
                    <a href="#131273" title="Types.this.Scope">members</a> <a href="Scopes.scala.html#60499" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#131274" title="Types.this.Symbol">member</a>
                    <a href="#131273" title="Types.this.Scope">members</a> <a href="Scopes.scala.html#60499" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#131301" title="Types.this.Symbol">sym</a>
                  <span class="delimiter">}</span>
                <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                  <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="131362">prevEntry</a> = <a href="#131273" title="Types.this.Scope">members</a>.<a href="Scopes.scala.html#60508" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#131301" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
                  <span class="keyword">var</span> <a title="Types.this.Type" id="131363">symtpe</a>: <a href="#38813" title="Types.this.Type">Type</a> = <span title="Null(null)" class="keyword">null</span>
                  <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#131362" title="Types.this.ScopeEntry">prevEntry</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                         <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#131362" title="Types.this.ScopeEntry">prevEntry</a>.<a href="Scopes.scala.html#92379" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#131301" title="Types.this.Symbol">sym</a> <span title="(x: Boolean)Boolean">||</span>
                           <a href="#131362" title="Types.this.ScopeEntry">prevEntry</a>.<a href="Scopes.scala.html#92379" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#131301" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                           <span title="=&gt; Boolean">!</span><a href="#131301" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46593" title="(mask: Long)Boolean">hasFlag</a><span class="delimiter">(</span><span title="Long(4L)">PRIVATE</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
                             <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#131277" title="Types.this.Type">self</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#131277" title="Types.this.Type">self</a> = <a href="#38813" title="Type.this.type" class="keyword">this</a>.<a href="#41511" title="=&gt; Types.this.Type">narrow</a>
                             <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#131363" title="Types.this.Type">symtpe</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#131363" title="Types.this.Type">symtpe</a> = <a href="#131277" title="Types.this.Type">self</a>.<a href="#41556" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#131301" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
                             <a href="#131277" title="Types.this.Type">self</a>.<a href="#41556" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#131362" title="Types.this.ScopeEntry">prevEntry</a>.<a href="Scopes.scala.html#92379" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#41577" title="(that: Types.this.Type)Boolean">matches</a> <a href="#131363" title="Types.this.Type">symtpe</a>
                           <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#131362" title="Types.this.ScopeEntry">prevEntry</a> = <a href="#131273" title="Types.this.Scope">members</a> <a href="Scopes.scala.html#60509" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a> <a href="#131362" title="Types.this.ScopeEntry">prevEntry</a>
                  <span class="delimiter">}</span>
                  <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#131362" title="Types.this.ScopeEntry">prevEntry</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#131273" title="Types.this.Scope">members</a> <a href="Scopes.scala.html#60499" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#131301" title="Types.this.Symbol">sym</a>
                  <span class="delimiter">}</span>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#131302" title="Long">excl</a> <span title="(x: Long)Boolean">==</span> <span title="Int(16)">DEFERRED</span>.<span title="=&gt; Long">toLong</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="#131276" title="Boolean">continue</a> = <span title="Boolean(true)" class="keyword">true</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <a href="#131293" title="Types.this.ScopeEntry">entry</a> = <span title="Types.this.ScopeEntry" class="keyword">if</span> <span class="delimiter">(</span><a href="#130539" title="Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#39313" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#58913" title="=&gt; Types.this.nme.NameType">ANYNAME</a><span class="delimiter">)</span> <a href="#131293" title="Types.this.ScopeEntry">entry</a>.<a href="Scopes.scala.html#92387" title="=&gt; Types.this.ScopeEntry">next</a> <span class="keyword">else</span> <a href="#131292" title="Types.this.Scope">decls</a> <a href="Scopes.scala.html#60509" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a> <a href="#131293" title="Types.this.ScopeEntry">entry</a>
          <span class="delimiter">}</span> // while (entry ne null)
          // excluded = excluded | LOCAL
          <a href="#131289" title="List[Types.this.Symbol]">bcs</a> = <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#130539" title="Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#39313" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#58915" title="=&gt; Types.this.nme.NameType">CONSTRUCTOR</a><span class="delimiter">)</span> <span title="object Nil">Nil</span> <span class="keyword">else</span> <a href="#131289" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>
        <span class="delimiter">}</span> // while (!bcs.isEmpty)
        <a href="#131275" title="Long">excluded</a> = <a href="#130540" title="Long">excludedFlags</a>
      <span class="delimiter">}</span> // while (continue)
      <a href="util/StatBase.scala.html#38644" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: scala.reflect.internal.util.Statistics.LongPair)Unit">stopTimer</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38669" title="=&gt; scala.reflect.internal.util.Statistics.Timer">findMemberNanos</a>, <a href="#131272" title="scala.reflect.internal.util.Statistics.LongPair">start</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#131271" title="List[Types.this.TypeVar]">suspension</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#131271" title="List[Types.this.TypeVar]">suspension</a> <span title="(f: Types.this.TypeVar =&gt; Unit)Unit">foreach</span> <span class="delimiter">(</span><a href="#131409" title="Types.this.TypeVar">_</a>.<a href="#83983" title="(x$1: Boolean)Unit">suspended</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#131273" title="Types.this.Scope">members</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#131274" title="Types.this.Symbol">member</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="util/StatBase.scala.html#38639" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38665" title="=&gt; scala.reflect.internal.util.Statistics.Counter">noMemberCount</a><span class="delimiter">)</span>
        <a href="#131274" title="Types.this.Symbol">member</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="util/StatBase.scala.html#38639" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38667" title="=&gt; scala.reflect.internal.util.Statistics.Counter">multMemberCount</a><span class="delimiter">)</span>
        <a href="#41581" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#46407" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.Symbol">newOverloaded</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a>, <a href="#131273" title="Types.this.Scope">members</a>.<a href="Scopes.scala.html#60510" title="=&gt; List[Types.this.Symbol]">toList</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    /** The existential skolems and existentially quantified variables which are free in this type */
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="41596">existentialSkolems</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="131424">boundSyms</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="131425">skolems</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="131442">t</a> &lt;- <a href="#41566" title="(f: Types.this.Type =&gt; Unit)Unit" class="keyword">this</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#131442" title="Types.this.Type">t</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Unit">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="131443">quantified</a>, <a title="Types.this.Type" id="131444">qtpe</a><span class="delimiter">)</span> =&gt;
            <a href="#131424" title="List[Types.this.Symbol]">boundSyms</a> = <a href="#131424" title="List[Types.this.Symbol]">boundSyms</a> <a href="#131445" title="(prefix: List[Types.this.Symbol])List[Types.this.Symbol]">:::</a> <a href="#131443" title="List[Types.this.Symbol]">quantified</a>
          <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="131453">sym</a>, _<span class="delimiter">)</span> =&gt;
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#131453" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#46593" title="(mask: Long)Boolean">hasFlag</a> <span title="Long(34359738368L)">EXISTENTIAL</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#131424" title="List[Types.this.Symbol]">boundSyms</a> <span title="(elem: Any)Boolean">contains</span> <a href="#131453" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#131425" title="List[Types.this.Symbol]">skolems</a> <span title="(elem: Any)Boolean">contains</span> <a href="#131453" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#131425" title="List[Types.this.Symbol]">skolems</a> = <a href="#131453" title="Types.this.Symbol">sym</a> <a href="#131454" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#131425" title="List[Types.this.Symbol]">skolems</a>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#131425" title="List[Types.this.Symbol]">skolems</a>
    <span class="delimiter">}</span>

    // Implementation of Annotatable for all types but AnnotatedType, which
    // overrides these.
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.AnnotationInfo]" id="41597">annotations</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span> = <span title="object Nil">Nil</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="41598">withoutAnnotations</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#38813" title="Types.this.Type" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(p: Types.this.AnnotationInfo =&gt; Boolean)Types.this.Type" id="41599">filterAnnotations</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo =&gt; Boolean" id="73833">p</a>: AnnotationInfo =&gt; Boolean<span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#38813" title="Types.this.Type" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="41600">setAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="73873">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a>  = <a href="#38916" title="(annots: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.Type">annotatedType</a><span class="delimiter">(</span><a href="#73873" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="41601">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="73853">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#38916" title="(annots: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.Type">annotatedType</a><span class="delimiter">(</span><a href="#73853" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Remove any annotations from this type and from any
     *  types embedded in this type. */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="41602">stripAnnotations</a> = <a href="#131469" title="(tp: Types.this.Type)Types.this.Type">StripAnnotationsMap</a><span class="delimiter">(</span><a href="#38813" title="Types.this.Type" class="keyword">this</a><span class="delimiter">)</span>

    /** Set the self symbol of an annotated type, or do nothing
     *  otherwise.  */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="41603">withSelfsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="131474">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#38813" title="Types.this.Type" class="keyword">this</a>

    /** The selfsym of an annotated type, or NoSymbol of anything else */
    <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="41604">selfsym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a>

    /** The kind of this type; used for debugging */
    <span class="keyword">def</span> <a title="=&gt; String" id="41605">kind</a>: <span title="String">String</span> = <span title="String(&quot;unknown type of class &quot;)" class="string">&quot;unknown type of class &quot;</span><span title="(x$1: Any)String">+</span><a href="#38813" title="()Class[_]">getClass</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

// Subclasses ------------------------------------------------------------

  <span class="keyword">trait</span> <a title="trait UniqueType extends Object with Product with ScalaObject" id="38814">UniqueType</a> <span title="ScalaObject" class="keyword">extends</span> <span title="Product">Product</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">val</span> <a title="Int" id="131481">hashCode</a> = scala.runtime.<span title="object scala.runtime.ScalaRunTime">ScalaRunTime</span>.<span title="(x: Product)Int">_hashCode</span><span class="delimiter">(</span><a href="#38814" title="Types.this.UniqueType" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

 /** A base class for types that defer some operations
   *  to their immediate supertype.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SubType extends Types.this.Type with ScalaObject" id="38815">SubType</a> <a href="#38815" title="ScalaObject" class="keyword">extends</a> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="62287">supertype</a>: <a href="#38813" title="Types.this.Type">Type</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="62288">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#62287" title="=&gt; Types.this.Type">supertype</a>.<a href="#41513" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="62289">decls</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a> = <a href="#62287" title="=&gt; Types.this.Type">supertype</a>.<a href="#41536" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="62290">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="131491">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#62287" title="=&gt; Types.this.Type">supertype</a>.<a href="#41553" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#131491" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="62291">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#39264" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#62287" title="=&gt; Types.this.Type">supertype</a>.<a href="#41579" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="62292">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#62287" title="=&gt; Types.this.Type">supertype</a>.<a href="#41580" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="62293">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#62287" title="=&gt; Types.this.Type">supertype</a>.<a href="#41581" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="62294">isNotNull</a> = <a href="#62287" title="=&gt; Types.this.Type">supertype</a>.<a href="#41493" title="=&gt; Boolean">isNotNull</a>
  <span class="delimiter">}</span>

  case <span class="keyword">class</span> <a title="class NotNullType extends Types.this.SubType with Types.this.RewrappingTypeProxy with ScalaObject with Product with Serializable" id="147895">NotNullType</a><a href="#147895" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="84219">underlying</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38815" title="Types.this.SubType">SubType</a> <span class="keyword">with</span> <a href="#38809" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="84190">supertype</a> = <a href="#84219" title="=&gt; Types.this.Type">underlying</a>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="84191">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="131511">newtp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#147895" title="(underlying: Types.this.Type)Types.this.NotNullType">NotNullType</a><span class="delimiter">(</span><a href="#131511" title="Types.this.Type">newtp</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="84192">isNotNull</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.NotNullType" id="84193">notNull</a> = <a href="#147895" title="Types.this.NotNullType" class="keyword">this</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="84194">deconst</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#84219" title="=&gt; Types.this.Type">underlying</a> //todo: needed?
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84195">safeToString</a>: <span title="String">String</span> = <a href="#84219" title="=&gt; Types.this.Type">underlying</a>.<a href="#41589" title="()String">toString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; with NotNull&quot;)" class="string">&quot; with NotNull&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84196">kind</a> = <span title="String(&quot;NotNullType&quot;)" class="string">&quot;NotNullType&quot;</span>
  <span class="delimiter">}</span>

  /** A base class for types that represent a single value
   *  (single-types and this-types).
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SingletonType extends Types.this.SubType with Types.this.SimpleTypeProxy with ScalaObject" id="38819">SingletonType</a> <a href="#38819" title="ScalaObject" class="keyword">extends</a> <a href="#38815" title="Types.this.SubType">SubType</a> <span class="keyword">with</span> <a href="#38808" title="Types.this.SimpleTypeProxy">SimpleTypeProxy</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83167">supertype</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83168">isTrivial</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83169">isStable</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83170">isVolatile</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41492" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83171">widen</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41508" title="=&gt; Types.this.Type">widen</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="83172">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#39264" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      <a href="util/StatBase.scala.html#38639" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38657" title="=&gt; scala.reflect.internal.util.Statistics.Counter">singletonBaseTypeSeqCount</a><span class="delimiter">)</span>
      <a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41579" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#59600" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">prepend</a> <a href="#38819" title="Types.this.SingletonType" class="keyword">this</a>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83173">isHigherKinded</a> = <span title="Boolean(false)" class="keyword">false</span> // singleton type classifies objects, thus must be kind *
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83174">safeToString</a>: <span title="String">String</span> = <a href="#41588" title="=&gt; String">prefixString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;type&quot;)" class="string">&quot;type&quot;</span>
/*
    override def typeOfThis: Type = typeSymbol.typeOfThis
    override def bounds: TypeBounds = TypeBounds(this, this)
    override def prefix: Type = NoType
    override def typeArgs: List[Type] = List()
    override def typeParams: List[Symbol] = List()
*/
  <span class="delimiter">}</span>

  /** An object representing an erroneous type */
  case <span class="keyword">object</span> <a href="#131617" title="object Types.this.ErrorType" id="131624">ErrorType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    // todo see whether we can do without
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="84299">isError</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="84300">decls</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a> = <span title="Types.this.ErrorScope" class="keyword">new</span> <a href="Scopes.scala.html#39182" title="Types.this.ErrorScope">ErrorScope</a><span class="delimiter">(</span><a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol" id="84301">findMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="131584">name</a>: <a href="Names.scala.html#38403" title="Types.this.Name">Name</a>, <a title="Long" id="131585">excludedFlags</a>: <span title="Long">Long</span>, <a title="Long" id="131586">requiredFlags</a>: <span title="Long">Long</span>, <a title="Boolean" id="131587">stableOnly</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="131589">sym</a> = <a href="#84300" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#60506" title="(name: Types.this.Name)Types.this.Symbol">lookup</a> <a href="#131584" title="Types.this.Name">name</a>
      <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#131589" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#131589" title="Types.this.Symbol">sym</a> = <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a>.<a href="Symbols.scala.html#46431" title="(name: Types.this.Name)Types.this.Symbol">newErrorSymbol</a><span class="delimiter">(</span><a href="#131584" title="Types.this.Name">name</a><span class="delimiter">)</span>
        <a href="#84300" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#60499" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#131589" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span>
      <a href="#131589" title="Types.this.Symbol">sym</a>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="84302">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="131604">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="keyword">this</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84303">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;&lt;error&gt;&quot;)" class="string">&quot;&lt;error&gt;&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="84304">narrow</a>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="keyword">this</span>
    // override def isNullable: Boolean = true
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84305">kind</a> = <span title="String(&quot;ErrorType&quot;)" class="string">&quot;ErrorType&quot;</span>
  <span class="delimiter">}</span>

  /** An object representing an unknown type, used during type inference.
   *  If you see WildcardType outside of inference it is almost certainly a bug.
   */
  case <span class="keyword">object</span> <a href="#131637" title="object Types.this.WildcardType" id="131644">WildcardType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="84307">isWildcard</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84308">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span>
    // override def isNullable: Boolean = true
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84309">kind</a> = <span title="String(&quot;WildcardType&quot;)" class="string">&quot;WildcardType&quot;</span>
  <span class="delimiter">}</span>
  /** BoundedWildcardTypes, used only during type inference, are created in
   *  two places that I can find:
   *
   *    1. If the expected type of an expression is an existential type,
   *       its hidden symbols are replaced with bounded wildcards.
   *    2. When an implicit conversion is being sought based in part on
   *       the name of a method in the converted type, a HasMethodMatching
   *       type is created: a MethodType with parameters typed as
   *       BoundedWildcardTypes.
   */
  case <span class="keyword">class</span> <a title="class BoundedWildcardType extends Types.this.Type with ScalaObject with Product with Serializable" id="147891">BoundedWildcardType</a><a href="#147891" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.TypeBounds" id="83499">bounds</a>: <a href="#62311" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83474">isWildcard</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83475">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#83499" title="=&gt; Types.this.TypeBounds">bounds</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83476">kind</a> = <span title="String(&quot;BoundedWildcardType&quot;)" class="string">&quot;BoundedWildcardType&quot;</span>
  <span class="delimiter">}</span>

  /** An object representing a non-existing type */
  case <span class="keyword">object</span> <a href="#131692" title="object Types.this.NoType" id="131699">NoType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="59534">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="59535">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;&lt;notype&gt;&quot;)" class="string">&quot;&lt;notype&gt;&quot;</span>
    // override def isNullable: Boolean = true
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="59536">kind</a> = <span title="String(&quot;NoType&quot;)" class="string">&quot;NoType&quot;</span>
  <span class="delimiter">}</span>

  /** An object representing a non-existing prefix */
  case <span class="keyword">object</span> <a href="#131716" title="object Types.this.NoPrefix" id="131723">NoPrefix</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="72760">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="72761">isStable</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="72762">prefixString</a> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="72763">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;&lt;noprefix&gt;&quot;)" class="string">&quot;&lt;noprefix&gt;&quot;</span>
    // override def isNullable: Boolean = true
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="72764">kind</a> = <span title="String(&quot;NoPrefixType&quot;)" class="string">&quot;NoPrefixType&quot;</span>
  <span class="delimiter">}</span>

  /** A class for this-types of the form &lt;sym&gt;.this.type
   */
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#131762" title="class ThisType extends Types.this.SingletonType with ScalaObject with Product with Serializable" id="83190">ThisType</a><a href="#83190" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="83198">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38819" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#83198" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46445" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span>
    //assert(sym.isClass &amp;&amp; !sym.isModuleClass || sym.isRoot, sym)
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83179">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#83198" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83180">isNotNull</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="83181">typeSymbol</a> = <a href="#83198" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83182">underlying</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#83198" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46666" title="=&gt; Types.this.Type">typeOfThis</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83183">isVolatile</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83184">isHigherKinded</a> = <a href="#83198" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46467" title="=&gt; Boolean">isRefinementClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#83182" title="=&gt; Types.this.Type">underlying</a>.<a href="#41490" title="=&gt; Boolean">isHigherKinded</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83185">prefixString</a> =
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74514" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#83198" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46739" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.this.&quot;)" class="string">&quot;.this.&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#83198" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46505" title="=&gt; Boolean">isAnonOrRefinementClass</a><span class="delimiter">)</span> <span title="String(&quot;this.&quot;)" class="string">&quot;this.&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#83198" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46516" title="=&gt; Boolean">isOmittablePrefix</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#83198" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46463" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <a href="#83198" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46740" title="=&gt; String">fullNameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      <span class="keyword">else</span> <a href="#83198" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46739" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.this.&quot;)" class="string">&quot;.this.&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83186">safeToString</a>: <span title="String">String</span> =
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#83198" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46476" title="=&gt; Boolean">isRoot</a><span class="delimiter">)</span> <span title="String(&quot;&lt;root&gt;&quot;)" class="string">&quot;&lt;root&gt;&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#83198" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46473" title="=&gt; Boolean">isEmptyPackageClass</a><span class="delimiter">)</span> <span title="String(&quot;&lt;empty&gt;&quot;)" class="string">&quot;&lt;empty&gt;&quot;</span>
      <span class="keyword">else</span> <a href="#83190" title="Types.this.ThisType" class="keyword">super</a>.<a href="#83174" title="=&gt; String">safeToString</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83187">narrow</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#83190" title="Types.this.ThisType" class="keyword">this</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83188">kind</a> = <span title="String(&quot;ThisType&quot;)" class="string">&quot;ThisType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueThisType extends Types.this.ThisType with Types.this.UniqueType with ScalaObject" id="38834">UniqueThisType</a><a href="#38834" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="131784">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#83190" title="Types.this.ThisType">ThisType</a><span class="delimiter">(</span><a href="#131784" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#38814" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.ThisType" id="131792">ThisType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#7741" title="Types.this.ThisTypeExtractor">ThisTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="83165">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="83201">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#38967" title="(tp: Types.this.UniqueThisType)Types.this.UniqueThisType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueThisType" class="keyword">new</span> <a href="#38834" title="Types.this.UniqueThisType">UniqueThisType</a><span class="delimiter">(</span><a href="#83201" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83201" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46459" title="=&gt; Boolean">isImplClass</a><span class="delimiter">)</span> <a href="#83201" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46666" title="=&gt; Types.this.Type">typeOfThis</a>
      <span class="keyword">else</span> <a href="#83201" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A class for singleton types of the form `&lt;prefix&gt;.&lt;sym.name&gt;.type`.
   *  Cannot be created directly; one should always use `singleType` for creation.
   */
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#131847" title="class SingleType extends Types.this.SingletonType with ScalaObject with Product with Serializable" id="83233">SingleType</a><a href="#83233" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="83247">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="83248">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38819" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="83215">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#83247" title="=&gt; Types.this.Type">pre</a>.<a href="#41489" title="=&gt; Boolean">isTrivial</a>
    // override def isNullable = underlying.isNullable
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83217">isNotNull</a> = <a href="#83224" title="=&gt; Types.this.Type">underlying</a>.<a href="#41493" title="=&gt; Boolean">isNotNull</a>
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Types.this.Type" id="83219">underlyingCache</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#131699" title="object Types.this.NoType">NoType</a>
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Int" id="83222">underlyingPeriod</a> = <span title="Int(0)">NoPeriod</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83224">underlying</a>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="131803">cache</a> = <a href="#83219" title="=&gt; Types.this.Type">underlyingCache</a>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83222" title="=&gt; Int">underlyingPeriod</a> <span title="(x: Int)Boolean">==</span> <a href="SymbolTable.scala.html#35634" title="=&gt; Types.this.Period">currentPeriod</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#131803" title="Types.this.Type">cache</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#131803" title="Types.this.Type">cache</a> 
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#38839" title="(tpe: Types.this.SingleType)Unit">defineUnderlyingOfSingleType</a><span class="delimiter">(</span><a href="#83233" title="Types.this.SingleType" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#83219" title="=&gt; Types.this.Type">underlyingCache</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    // more precise conceptually, but causes cyclic errors:    (paramss exists (_ contains sym))
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83225">isImmediatelyDependent</a> = <span class="delimiter">(</span><a href="#83248" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#83248" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#46461" title="=&gt; Boolean">isMethod</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#83248" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46487" title="=&gt; Boolean">isValueParameter</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83226">isVolatile</a> : <span title="Boolean">Boolean</span> = <a href="#83224" title="=&gt; Types.this.Type">underlying</a>.<a href="#41492" title="=&gt; Boolean">isVolatile</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#83248" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46534" title="=&gt; Boolean">isStable</a>
/*
    override def narrow: Type = {
      if (phase.erasedTypes) this
      else {
        val thissym = refinedType(List(this), sym.owner, EmptyScope).typeSymbol
        if (sym.owner != NoSymbol) {
          //Console.println(&quot;narrowing module &quot; + sym + thissym.owner);
          thissym.typeOfThis = this
        }
        thissym.thisType
      }
    }
*/
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83227">narrow</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#83233" title="Types.this.SingleType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="83228">termSymbol</a> = <a href="#83248" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83229">prefix</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#83247" title="=&gt; Types.this.Type">pre</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83230">prefixString</a> = <span class="delimiter">(</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#83248" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46514" title="=&gt; Types.this.Symbol">skipPackageObject</a>.<a href="Symbols.scala.html#46516" title="=&gt; Boolean">isOmittablePrefix</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#83248" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46506" title="=&gt; Boolean">isPackageObjectOrClass</a><span class="delimiter">)</span> <a href="#83247" title="=&gt; Types.this.Type">pre</a>.<a href="#41588" title="=&gt; String">prefixString</a>
      <span class="keyword">else</span> <a href="#83247" title="=&gt; Types.this.Type">pre</a>.<a href="#41588" title="=&gt; String">prefixString</a> <span title="(x$1: Any)String">+</span> <a href="#83248" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46739" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
    <span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83231">kind</a> = <span title="String(&quot;SingleType&quot;)" class="string">&quot;SingleType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueSingleType extends Types.this.SingleType with Types.this.UniqueType with ScalaObject" id="38838">UniqueSingleType</a><a href="#38838" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="131878">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="131879">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#83233" title="Types.this.SingleType">SingleType</a><span class="delimiter">(</span><a href="#131878" title="Types.this.Type">pre</a>, <a href="#131879" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#38814" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.SingleType" id="131884">SingleType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#7741" title="Types.this.SingleTypeExtractor">SingleTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="83207">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="83253">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="83254">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#38967" title="(tp: Types.this.UniqueSingleType)Types.this.UniqueSingleType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueSingleType" class="keyword">new</span> <a href="#38838" title="Types.this.UniqueSingleType">UniqueSingleType</a><span class="delimiter">(</span><a href="#83253" title="Types.this.Type">pre</a>, <a href="#83254" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tpe: Types.this.SingleType)Unit" id="38839">defineUnderlyingOfSingleType</a><span class="delimiter">(</span><a title="Types.this.SingleType" id="131813">tpe</a>: <a href="#83233" title="Types.this.SingleType">SingleType</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Int" id="131816">period</a> = <a href="#131813" title="Types.this.SingleType">tpe</a>.<a href="#83222" title="=&gt; Int">underlyingPeriod</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#131816" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#35634" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#131813" title="Types.this.SingleType">tpe</a>.<a href="#83222" title="(x$1: Int)Unit">underlyingPeriod</a> = <a href="SymbolTable.scala.html#35634" title="=&gt; Types.this.Period">currentPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#35649" title="(period: Types.this.Period)Boolean">isValid</a><span class="delimiter">(</span><a href="#131816" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#131813" title="Types.this.SingleType">tpe</a>.<a href="#83219" title="(x$1: Types.this.Type)Unit">underlyingCache</a> = <a href="#131813" title="Types.this.SingleType">tpe</a>.<a href="#83247" title="=&gt; Types.this.Type">pre</a>.<a href="#41556" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#131813" title="Types.this.SingleType">tpe</a>.<a href="#83248" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#41519" title="=&gt; Types.this.Type">resultType</a>;
        <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#131813" title="Types.this.SingleType">tpe</a>.<a href="#83219" title="=&gt; Types.this.Type">underlyingCache</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#131813" title="Types.this.SingleType">tpe</a>, <a href="#131813" title="Types.this.SingleType">tpe</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#131910" title="class SuperType extends Types.this.SingletonType with ScalaObject with Product with Serializable" id="83425">SuperType</a><a href="#83425" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="83439">thistpe</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="83440">supertpe</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38819" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="83415">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#83439" title="=&gt; Types.this.Type">thistpe</a>.<a href="#41489" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#83440" title="=&gt; Types.this.Type">supertpe</a>.<a href="#41489" title="=&gt; Boolean">isTrivial</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83417">isNotNull</a> = <span title="Boolean(true)" class="keyword">true</span>;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="83418">typeSymbol</a> = <a href="#83439" title="=&gt; Types.this.Type">thistpe</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83419">underlying</a> = <a href="#83440" title="=&gt; Types.this.Type">supertpe</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83420">prefix</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#83440" title="=&gt; Types.this.Type">supertpe</a>.<a href="#41514" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83421">prefixString</a> = <a href="#83439" title="=&gt; Types.this.Type">thistpe</a>.<a href="#41588" title="=&gt; String">prefixString</a>.<span title="(x$1: String, x$2: String)String">replaceAll</span><span class="delimiter">(</span><span title="String(&quot;\\bthis\\.$&quot;)" class="string">&quot;&quot;&quot;\bthis\.$&quot;&quot;&quot;</span>, <span title="String(&quot;super.&quot;)" class="string">&quot;super.&quot;</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83422">narrow</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#83439" title="=&gt; Types.this.Type">thistpe</a>.<a href="#41511" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83423">kind</a> = <span title="String(&quot;SuperType&quot;)" class="string">&quot;SuperType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueSuperType extends Types.this.SuperType with Types.this.UniqueType with ScalaObject" id="38843">UniqueSuperType</a><a href="#38843" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="131941">thistp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="131942">supertp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#83425" title="Types.this.SuperType">SuperType</a><span class="delimiter">(</span><a href="#131941" title="Types.this.Type">thistp</a>, <a href="#131942" title="Types.this.Type">supertp</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#38814" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.SuperType" id="131947">SuperType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#7741" title="Types.this.SuperTypeExtractor">SuperTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(thistp: Types.this.Type, supertp: Types.this.Type)Types.this.Type" id="83407">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="83445">thistp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="83446">supertp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#83446" title="Types.this.Type">supertp</a>
      <span class="keyword">else</span> <a href="#38967" title="(tp: Types.this.UniqueSuperType)Types.this.UniqueSuperType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueSuperType" class="keyword">new</span> <a href="#38843" title="Types.this.UniqueSuperType">UniqueSuperType</a><span class="delimiter">(</span><a href="#83445" title="Types.this.Type">thistp</a>, <a href="#83446" title="Types.this.Type">supertp</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A class for the bounds of abstract types and type parameters
   */
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#131974" title="class TypeBounds extends Types.this.SubType with ScalaObject with Product with Serializable" id="62311">TypeBounds</a><a href="#62311" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="62325">lo</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="62326">hi</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38815" title="Types.this.SubType">SubType</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="62302">supertype</a> = <a href="#62326" title="=&gt; Types.this.Type">hi</a>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="62303">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#62325" title="=&gt; Types.this.Type">lo</a>.<a href="#41489" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#62326" title="=&gt; Types.this.Type">hi</a>.<a href="#41489" title="=&gt; Boolean">isTrivial</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="62305">bounds</a>: <a href="#62311" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#62311" title="Types.this.TypeBounds" class="keyword">this</a>
    <span class="keyword">def</span> <a title="(that: Types.this.Type)Boolean" id="62306">containsType</a><span class="delimiter">(</span><a title="Types.this.Type" id="131956">that</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#131956" title="Types.this.Type">that</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">TypeBounds</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#131956" title="Types.this.Type">that</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#62311" title="Types.this.TypeBounds" class="keyword">this</a>
      <span class="keyword">case</span> <span title="Boolean">_</span>                =&gt; <a href="#62325" title="=&gt; Types.this.Type">lo</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#131956" title="Types.this.Type">that</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#131956" title="Types.this.Type">that</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#62326" title="=&gt; Types.this.Type">hi</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="62307">isEmptyBounds</a> = <span class="delimiter">(</span><a href="#62325" title="=&gt; Types.this.Type">lo</a>.<a href="#41506" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#62326" title="=&gt; Types.this.Type">hi</a>.<a href="#41506" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span>
    // override def isNullable: Boolean = NullClass.tpe &lt;:&lt; lo;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="62308">safeToString</a> = <span title="String(&quot;&gt;: &quot;)" class="string">&quot;&gt;: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#62325" title="=&gt; Types.this.Type">lo</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; &lt;: &quot;)" class="string">&quot; &lt;: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#62326" title="=&gt; Types.this.Type">hi</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="62309">kind</a> = <span title="String(&quot;TypeBoundsType&quot;)" class="string">&quot;TypeBoundsType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueTypeBounds extends Types.this.TypeBounds with Types.this.UniqueType with ScalaObject" id="38847">UniqueTypeBounds</a><a href="#38847" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="132005">lo</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="132006">hi</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#62311" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#132005" title="Types.this.Type">lo</a>, <a href="#132006" title="Types.this.Type">hi</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#38814" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span> <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.TypeBounds" id="132015">TypeBounds</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#7741" title="Types.this.TypeBoundsExtractor">TypeBoundsExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="62282">empty</a>: <a href="#62311" title="Types.this.TypeBounds">TypeBounds</a>           = <a href="#62285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a>.<a href="Symbols.scala.html#69227" title="=&gt; Types.this.Type">tpe</a>, <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(hi: Types.this.Type)Types.this.TypeBounds" id="62283">upper</a><span class="delimiter">(</span><a title="Types.this.Type" id="117304">hi</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#62311" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#62285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a>.<a href="Symbols.scala.html#69227" title="=&gt; Types.this.Type">tpe</a>, <a href="#117304" title="Types.this.Type">hi</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(lo: Types.this.Type)Types.this.TypeBounds" id="62284">lower</a><span class="delimiter">(</span><a title="Types.this.Type" id="132010">lo</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#62311" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#62285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="#132010" title="Types.this.Type">lo</a>, <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds" id="62285">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="83458">lo</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="83459">hi</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#62311" title="Types.this.TypeBounds">TypeBounds</a> = <span class="delimiter">{</span>
      <a href="#38967" title="(tp: Types.this.UniqueTypeBounds)Types.this.UniqueTypeBounds">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueTypeBounds" class="keyword">new</span> <a href="#38847" title="Types.this.UniqueTypeBounds">UniqueTypeBounds</a><span class="delimiter">(</span><a href="#83458" title="Types.this.Type">lo</a>, <a href="#83459" title="Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.TypeBounds" class="delimiter">[</span><a href="#62311" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">]</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A common base class for intersection types and class types
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class CompoundType extends Types.this.Type with ScalaObject" id="38848">CompoundType</a> <a href="#38848" title="ScalaObject" class="keyword">extends</a> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>

    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Types.this.BaseTypeSeq" id="60412">baseTypeSeqCache</a>: <a href="BaseTypeSeqs.scala.html#39264" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = _
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Int" id="60415">baseTypeSeqPeriod</a> = <span title="Int(0)">NoPeriod</span>
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="60418">baseClassesCache</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = _
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Int" id="60421">baseClassesPeriod</a> = <span title="Int(0)">NoPeriod</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="60423">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#39264" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="132023">cached</a> = <a href="#60412" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
      <span title="Types.this.BaseTypeSeq" class="keyword">if</span> <span class="delimiter">(</span><a href="#60415" title="=&gt; Int">baseTypeSeqPeriod</a> <span title="(x: Int)Boolean">==</span> <a href="SymbolTable.scala.html#35634" title="=&gt; Types.this.Period">currentPeriod</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#132023" title="Types.this.BaseTypeSeq">cached</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#132023" title="Types.this.BaseTypeSeq">cached</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="BaseTypeSeqs.scala.html#39265" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span> 
        <a href="#132023" title="Types.this.BaseTypeSeq">cached</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#38849" title="(tpe: Types.this.CompoundType)Unit">defineBaseTypeSeqOfCompoundType</a><span class="delimiter">(</span><a href="#38848" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#60412" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="BaseTypeSeqs.scala.html#39265" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <span title="Types.this.RecoverableCyclicReference" class="keyword">new</span> <a href="#147833" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
        
        <a href="#60412" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="60424">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#60423" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#59605" title="=&gt; Int">maxDepth</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="60425">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="132524">cached</a> = <a href="#60418" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a>
      <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#60421" title="=&gt; Int">baseClassesPeriod</a> <span title="(x: Int)Boolean">==</span> <a href="SymbolTable.scala.html#35634" title="=&gt; Types.this.Period">currentPeriod</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#132524" title="List[Types.this.Symbol]">cached</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#132524" title="List[Types.this.Symbol]">cached</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#38850" title="(tpe: Types.this.CompoundType)Unit">defineBaseClassesOfCompoundType</a><span class="delimiter">(</span><a href="#38848" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#60418" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <span title="Types.this.RecoverableCyclicReference" class="keyword">new</span> <a href="#147833" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
        
        <a href="#60418" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** The slightly less idiomatic use of Options is due to
     *  performance considerations. A version using for comprehensions
     *  might be too slow (this is deemed a hotspot of the type checker).
     *
     *  See with Martin before changing this method.
     */
    <span class="keyword">def</span> <a title="[A](op1: =&gt; A)(op2: Types.this.Type =&gt; A)A" id="60426">memo</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="60428">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="132496">op1</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; A" id="132497">op2</a>: Type =&gt; A<span class="delimiter">)</span>: <a href="#60428" title="A">A</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="()A" id="132605">updateCache</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#60428" title="A">A</a> = <span class="delimiter">{</span>
        <a href="#38806" title="(k: List[Types.this.Type], v: scala.ref.WeakReference[Types.this.Type])Unit">intersectionWitness</a><span class="delimiter">(</span><a href="#41513" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> = <span title="(value: Types.this.CompoundType)scala.ref.WeakReference[Types.this.CompoundType]" class="keyword">new</span> <span title="scala.ref.WeakReference[Types.this.CompoundType]">WeakReference</span><span class="delimiter">(</span><a href="#38848" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#132496" title="=&gt; A">op1</a>
      <span class="delimiter">}</span>

      <a href="#38806" title="=&gt; scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]">intersectionWitness</a> <span title="(k: List[Types.this.Type])Option[scala.ref.WeakReference[Types.this.Type]]">get</span> <a href="#41513" title="=&gt; List[Types.this.Type]">parents</a> <span title="A" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="A">Some</span><span class="delimiter">(</span><a title="scala.ref.WeakReference[Types.this.Type]" id="132621">ref</a><span class="delimiter">)</span> =&gt;
          <a href="#132621" title="scala.ref.WeakReference[Types.this.Type]">ref</a>.<span title="=&gt; Option[Types.this.Type]">get</span> <span title="A" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="A">Some</span><span class="delimiter">(</span><a title="Types.this.Type" id="132623">w</a><span class="delimiter">)</span> =&gt; <span title="A" class="keyword">if</span> <span class="delimiter">(</span><a href="#132623" title="Types.this.Type">w</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#38848" title="Types.this.CompoundType" class="keyword">this</a><span class="delimiter">)</span> <a href="#132496" title="=&gt; A">op1</a> <span class="keyword">else</span> <a href="#132497" title="(v1: Types.this.Type)A">op2</a><span class="delimiter">(</span><a href="#132623" title="Types.this.Type">w</a><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="A">None</span> =&gt; <a href="#132605" title="()A">updateCache</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="keyword">case</span> <span title="A">None</span> =&gt; <a href="#132605" title="()A">updateCache</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="60429">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="132625">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="132628">index</a> = <a href="#41582" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#132625" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#132628" title="Int">index</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="BaseTypeSeqs.scala.html#59595" title="(i: Int)Types.this.Type">baseTypeSeq</a><span class="delimiter">(</span><a href="#132628" title="Int">index</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#131699" title="object Types.this.NoType">NoType</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="60430">narrow</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46667" title="=&gt; Types.this.Type">thisType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="60431">isNotNull</a>: <span title="Boolean">Boolean</span> = <a href="#41513" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#132645" title="Types.this.Type">_</a>.<a href="#41493" title="=&gt; Boolean">isNotNull</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="60432">isStructuralRefinement</a>: <span title="Boolean">Boolean</span> =
      <a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46505" title="=&gt; Boolean">isAnonOrRefinementClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#41536" title="=&gt; Types.this.Scope">decls</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#132655" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46556" title="=&gt; Boolean">isPossibleInRefinement</a><span class="delimiter">)</span>

    // override def isNullable: Boolean =
    // parents forall (p =&gt; p.isNullable &amp;&amp; !p.typeSymbol.isAbstractType);
    
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="60433">safeToString</a>: <span title="String">String</span> =
      <a href="#41513" title="=&gt; List[Types.this.Type]">parents</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot; with &quot;)" class="string">&quot; with &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span>
      <span class="delimiter">(</span><span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74514" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">||</span> <a href="#41513" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#41536" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60476" title="=&gt; Types.this.ScopeEntry">elems</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#41536" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60517" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;{&quot;)" class="string">&quot;{&quot;</span>, <span title="String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="String(&quot;}&quot;)" class="string">&quot;}&quot;</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tpe: Types.this.CompoundType)Unit" id="38849">defineBaseTypeSeqOfCompoundType</a><span class="delimiter">(</span><a title="Types.this.CompoundType" id="132037">tpe</a>: <a href="#38848" title="Types.this.CompoundType">CompoundType</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Int" id="132040">period</a> = <a href="#132037" title="Types.this.CompoundType">tpe</a>.<a href="#60415" title="=&gt; Int">baseTypeSeqPeriod</a>;
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#132040" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#35634" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#132037" title="Types.this.CompoundType">tpe</a>.<a href="#60415" title="(x$1: Int)Unit">baseTypeSeqPeriod</a> = <a href="SymbolTable.scala.html#35634" title="=&gt; Types.this.Period">currentPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#35650" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#132040" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#132037" title="Types.this.CompoundType">tpe</a>.<a href="#41513" title="=&gt; List[Types.this.Type]">parents</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#132054" title="Types.this.Type">_</a>.<a href="#41568" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#132057" title="Types.this.Type">_</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#38912" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          // rename type vars to fresh type params, take base type sequence of
          // resulting type, and rename back all the entries in that sequence
          <span class="keyword">var</span> <a title="scala.collection.immutable.Set[Types.this.TypeVar]" id="132058">tvs</a> = <span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.TypeVar*)scala.collection.immutable.Set[Types.this.TypeVar]" class="delimiter">[</span><a href="#38912" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
          <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="132086">p</a> &lt;- <a href="#132037" title="Types.this.CompoundType">tpe</a>.<a href="#41513" title="(f: Types.this.Type =&gt; Unit)Unit">parents</a><span class="delimiter">)</span>
            <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="132089">t</a> &lt;- <a href="#41566" title="(f: Types.this.Type =&gt; Unit)Unit">p</a><span class="delimiter">)</span> <a href="#132089" title="Types.this.Type">t</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <a title="Unit" id="132090">tv</a>: <a href="#38912" title="Types.this.TypeVar">TypeVar</a> =&gt; <a href="#132058" title="scala.collection.immutable.Set[Types.this.TypeVar]">tvs</a> <span title="(elem: Types.this.TypeVar)scala.collection.immutable.Set[Types.this.TypeVar]">+=</span> <a href="#132090" title="Types.this.TypeVar">tv</a>
              <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
            <span class="delimiter">}</span>
          <span class="keyword">val</span> <a title="Map[Types.this.Type,Types.this.Symbol]" id="132059">varToParamMap</a>: <span title="Map[Types.this.Type,Types.this.Symbol]">Map</span><span class="delimiter">[</span>Type, Symbol<span class="delimiter">]</span> = <a href="#132058" title="scala.collection.immutable.Set[Types.this.TypeVar]">tvs</a> <span title="(f: Types.this.TypeVar =&gt; (Types.this.TypeVar, Types.this.Symbol))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[Types.this.TypeVar],(Types.this.TypeVar, Types.this.Symbol),scala.collection.immutable.Set[(Types.this.TypeVar, Types.this.Symbol)]])scala.collection.immutable.Set[(Types.this.TypeVar, Types.this.Symbol)]">map</span> <span class="delimiter">(</span><a title="Types.this.TypeVar" id="132140">tv</a> =&gt; <a href="#132140" title="(x: Types.this.TypeVar)ArrowAssoc[Types.this.TypeVar]">tv</a> <span title="(y: Types.this.Symbol)(Types.this.TypeVar, Types.this.Symbol)">-&gt;</span> <a href="#132140" title="Types.this.TypeVar">tv</a>.<a href="#136207" title="=&gt; Types.this.Type">origin</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46656" title="=&gt; Types.this.Symbol">cloneSymbol</a><span class="delimiter">)</span> <span title="(implicit ev: &lt;:&lt;[(Types.this.TypeVar, Types.this.Symbol),(Types.this.Type, Types.this.Symbol)])scala.collection.immutable.Map[Types.this.Type,Types.this.Symbol]">toMap</span>
          <span class="keyword">val</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]" id="132060">paramToVarMap</a> = <a href="#132059" title="Map[Types.this.Type,Types.this.Symbol]">varToParamMap</a> <span title="(f: ((Types.this.Type, Types.this.Symbol)) =&gt; (Types.this.Symbol, Types.this.Type))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[Types.this.Type,Types.this.Symbol],(Types.this.Symbol, Types.this.Type),scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]])scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#132237" title="(Types.this.Type, Types.this.Symbol)">_</a>.<span title="=&gt; (Types.this.Symbol, Types.this.Type)">swap</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Types.this.TypeMap" id="132061">varToParam</a> = <a href="#132272" title="Types.this.TypeMap" class="keyword">new</a> <a href="#38980" title="anonymous class $anon extends Types.this.TypeMap" id="132272">TypeMap</a> <span class="delimiter">{</span>
            <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="132274">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="132275">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#132059" title="Map[Types.this.Type,Types.this.Symbol]">varToParamMap</a> <span title="(key: Types.this.Type)Option[Types.this.Symbol]">get</span> <a href="#132275" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <span title="Types.this.Type">Some</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="132283">sym</a><span class="delimiter">)</span> =&gt; <a href="#132283" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>
              <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#132275" title="Types.this.Type">tp</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span class="keyword">val</span> <a title="Types.this.TypeMap" id="132062">paramToVar</a> = <a href="#132306" title="Types.this.TypeMap" class="keyword">new</a> <a href="#38980" title="anonymous class $anon extends Types.this.TypeMap" id="132306">TypeMap</a> <span class="delimiter">{</span>
            <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="132308">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="132309">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#132309" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="132314">tsym</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#132060" title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]">paramToVarMap</a>.<span title="(key: Types.this.Symbol)Boolean">isDefinedAt</span><span class="delimiter">(</span><a href="#132314" title="Types.this.Symbol">tsym</a><span class="delimiter">)</span> =&gt; <a href="#132060" title="(key: Types.this.Symbol)Types.this.Type">paramToVarMap</a><span class="delimiter">(</span><a href="#132314" title="Types.this.Symbol">tsym</a><span class="delimiter">)</span>
              <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#132309" title="Types.this.Type">tp</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="132063">bts</a> = <a href="#38933" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#132037" title="Types.this.CompoundType">tpe</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.RefinedType" class="delimiter">[</span><a href="#60409" title="Types.this.RefinedType">RefinedType</a><span class="delimiter">]</span>, <a href="#132037" title="Types.this.CompoundType">tpe</a>.<a href="#41513" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#132061" title="Types.this.TypeMap">varToParam</a>, <a href="#132061" title="Types.this.TypeMap">varToParam</a> <a href="#74775" title="(scope: Types.this.Scope)Types.this.Scope">mapOver</a> <a href="#132037" title="Types.this.CompoundType">tpe</a>.<a href="#41536" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span>.<a href="#41579" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
          <a href="#132037" title="Types.this.CompoundType">tpe</a>.<a href="#60412" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="#132063" title="Types.this.BaseTypeSeq">bts</a> <a href="BaseTypeSeqs.scala.html#59603" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">lateMap</a> <a href="#132062" title="Types.this.TypeMap">paramToVar</a>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <a href="util/StatBase.scala.html#38639" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38659" title="=&gt; scala.reflect.internal.util.Statistics.Counter">compoundBaseTypeSeqCount</a><span class="delimiter">)</span>
          <a href="#132037" title="Types.this.CompoundType">tpe</a>.<a href="#60412" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="BaseTypeSeqs.scala.html#39265" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a>
          <a href="#132037" title="Types.this.CompoundType">tpe</a>.<a href="#60412" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <span title="Types.this.BaseTypeSeq" class="keyword">if</span> <span class="delimiter">(</span><a href="#132037" title="Types.this.CompoundType">tpe</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46467" title="=&gt; Boolean">isRefinementClass</a><span class="delimiter">)</span>
            <a href="#132037" title="Types.this.CompoundType">tpe</a>.<a href="#60426" title="(op1: =&gt; Types.this.BaseTypeSeq)(op2: Types.this.Type =&gt; Types.this.BaseTypeSeq)Types.this.BaseTypeSeq">memo</a><span class="delimiter">(</span><a href="BaseTypeSeqs.scala.html#39268" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">compoundBaseTypeSeq</a><span class="delimiter">(</span><a href="#132037" title="Types.this.CompoundType">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#132510" title="Types.this.Type">_</a>.<a href="#41579" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#59601" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">updateHead</a> <a href="#132037" title="Types.this.CompoundType">tpe</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
          <span class="keyword">else</span>
            <a href="BaseTypeSeqs.scala.html#39268" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">compoundBaseTypeSeq</a><span class="delimiter">(</span><a href="#132037" title="Types.this.CompoundType">tpe</a><span class="delimiter">)</span>
          // [Martin] suppressing memo-ization solves the problem with &quot;same type after erasure&quot; errors
          // when compiling with
          // scalac scala.collection.IterableViewLike.scala scala.collection.IterableLike.scala
          // I have not yet figured out precisely why this is the case.
          // My current assumption is that taking memos forces baseTypeSeqs to be computed
          // at stale types (i.e. the underlying typeSymbol has already another type).
          // I do not yet see precisely why this would cause a problem, but it looks
          // fishy in any case.
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    //Console.println(&quot;baseTypeSeq(&quot; + typeSymbol + &quot;) = &quot; + baseTypeSeqCache.toList);//DEBUG
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#132037" title="Types.this.CompoundType">tpe</a>.<a href="#60412" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="BaseTypeSeqs.scala.html#39265" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <a href="#62866" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#39126" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic inheritance involving &quot;)" class="string">&quot;illegal cyclic inheritance involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#132037" title="Types.this.CompoundType">tpe</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tpe: Types.this.CompoundType)Unit" id="38850">defineBaseClassesOfCompoundType</a><span class="delimiter">(</span><a title="Types.this.CompoundType" id="132534">tpe</a>: <a href="#38848" title="Types.this.CompoundType">CompoundType</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="132537">computeBaseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
      <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#132534" title="Types.this.CompoundType">tpe</a>.<a href="#41513" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</span><span class="delimiter">(</span><a href="#132534" title="Types.this.CompoundType">tpe</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        //Console.println(&quot;computing base classes of &quot; + typeSymbol + &quot; at phase &quot; + phase);//DEBUG
        // optimized, since this seems to be performance critical
        <span class="keyword">val</span> <a title="Types.this.Type" id="132547">superclazz</a> = <a href="#132534" title="Types.this.CompoundType">tpe</a>.<a href="#41513" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Types.this.Type">head</span>
        <span class="keyword">var</span> <a title="List[Types.this.Type]" id="132548">mixins</a> = <a href="#132534" title="Types.this.CompoundType">tpe</a>.<a href="#41513" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; List[Types.this.Type]">tail</span>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="132549">sbcs</a> = <a href="#132547" title="Types.this.Type">superclazz</a>.<a href="#41581" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
        <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="132550">bcs</a> = <a href="#132549" title="List[Types.this.Symbol]">sbcs</a>
        <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Boolean" id="132551">isNew</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="132555">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
          <a href="#132547" title="Types.this.Type">superclazz</a>.<a href="#41582" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#132555" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
          <span class="delimiter">{</span> <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="132560">p</a> = <a href="#132550" title="List[Types.this.Symbol]">bcs</a>;
            <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#132560" title="List[Types.this.Symbol]">p</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#132549" title="List[Types.this.Symbol]">sbcs</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#132560" title="List[Types.this.Symbol]">p</a>.<span title="=&gt; Types.this.Symbol">head</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#132555" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#132560" title="List[Types.this.Symbol]">p</a> = <a href="#132560" title="List[Types.this.Symbol]">p</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>;
            <a href="#132560" title="List[Types.this.Symbol]">p</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#132549" title="List[Types.this.Symbol]">sbcs</a>
          <span class="delimiter">}</span>
        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#132548" title="List[Types.this.Type]">mixins</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#132552" title="()Unit" class="delimiter">{</a>
          <span class="keyword">def</span> <a title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]" id="132570">addMixinBaseClasses</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="132571">mbcs</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
            <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#132571" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#132550" title="List[Types.this.Symbol]">bcs</a>
            <span class="keyword">else</span> <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#132551" title="(clazz: Types.this.Symbol)Boolean">isNew</a><span class="delimiter">(</span><a href="#132571" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; Types.this.Symbol">head</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#132571" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; Types.this.Symbol">head</span> <a href="#132572" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#132570" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#132571" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#132570" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#132571" title="List[Types.this.Symbol]">mbcs</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span><span class="delimiter">)</span>
          <a href="#132550" title="List[Types.this.Symbol]">bcs</a> = <a href="#132570" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#132548" title="List[Types.this.Type]">mixins</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#41581" title="=&gt; List[Types.this.Symbol]">baseClasses</a><span class="delimiter">)</span>
          <a href="#132548" title="List[Types.this.Type]">mixins</a> = <a href="#132548" title="List[Types.this.Type]">mixins</a>.<span title="=&gt; List[Types.this.Type]">tail</span>
        <span class="delimiter">}</span>
        <a href="#132534" title="Types.this.CompoundType">tpe</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="#132579" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#132550" title="List[Types.this.Symbol]">bcs</a>
      <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="Int" id="132538">period</a> = <a href="#132534" title="Types.this.CompoundType">tpe</a>.<a href="#60421" title="=&gt; Int">baseClassesPeriod</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#132538" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#35634" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#132534" title="Types.this.CompoundType">tpe</a>.<a href="#60421" title="(x$1: Int)Unit">baseClassesPeriod</a> = <a href="SymbolTable.scala.html#35634" title="=&gt; Types.this.Period">currentPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#35650" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#132538" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#132534" title="Types.this.CompoundType">tpe</a>.<a href="#60418" title="(x$1: List[Types.this.Symbol])Unit">baseClassesCache</a> = <span title="Null(null)" class="keyword">null</span>
        <a href="#132534" title="Types.this.CompoundType">tpe</a>.<a href="#60418" title="(x$1: List[Types.this.Symbol])Unit">baseClassesCache</a> = <a href="#132534" title="Types.this.CompoundType">tpe</a>.<a href="#60426" title="(op1: =&gt; List[Types.this.Symbol])(op2: Types.this.Type =&gt; List[Types.this.Symbol])List[Types.this.Symbol]">memo</a><span class="delimiter">(</span><a href="#132537" title="=&gt; List[Types.this.Symbol]">computeBaseClasses</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#132534" title="Types.this.CompoundType">tpe</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="#132596" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#132595" title="Types.this.Type">_</a>.<a href="#41581" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#132534" title="Types.this.CompoundType">tpe</a>.<a href="#60418" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <a href="#62866" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#39126" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic reference involving &quot;)" class="string">&quot;illegal cyclic reference involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#132534" title="Types.this.CompoundType">tpe</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** A class representing intersection types with refinements of the form
   *    `&lt;parents_0&gt; with ... with &lt;parents_n&gt; { decls }`
   *  Cannot be created directly;
   *  one should always use `refinedType` for creation.
   */
  case <span class="keyword">class</span> <a title="class RefinedType extends Types.this.CompoundType with ScalaObject with Product with Serializable" id="60409">RefinedType</a><a href="#60409" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Type]" id="83648">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>,
                         <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Scope" id="83649">decls</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38848" title="Types.this.CompoundType">CompoundType</a> <span class="delimiter">{</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="60441">isHigherKinded</a> = <span class="delimiter">(</span>
      <a href="#83648" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span class="delimiter">(</span><a href="#83648" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#132680" title="Types.this.Type">_</a>.<a href="#41490" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a>
    <span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="60442">typeParams</a> =
      <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#60441" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#83648" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#41528" title="=&gt; List[Types.this.Symbol]">typeParams</a>
      <span class="keyword">else</span> <a href="#60409" title="Types.this.RefinedType" class="keyword">super</a>.<a href="#41528" title="=&gt; List[Types.this.Symbol]">typeParams</a>

    //@M may result in an invalid type (references to higher-order args become dangling )
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="60443">typeConstructor</a> =
      <a href="#38933" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#60409" title="Types.this.RefinedType" class="keyword">this</a>, <a href="#83648" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#132704" title="Types.this.Type">_</a>.<a href="#41516" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>, <a href="#83649" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span>

    /* MO to AM: This is probably not correct
     * If they are several higher-kinded parents with different bounds we need
     * to take the intersection of their bounds
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="60444">normalize</a> = <span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#60441" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#38944" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span>
          <a href="#60442" title="=&gt; List[Types.this.Symbol]">typeParams</a>,
          <a href="#60408" title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span>
            <a href="#83648" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#132759" title="Types.this.Type" class="delimiter">{</a>
              <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="132760">pre</a>, <a title="Types.this.Symbol" id="132761">sym</a>, <a href="#132763" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#62092" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#132760" title="Types.this.Type">pre</a>, <a href="#132761" title="Types.this.Symbol">sym</a>, <a href="#41518" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>
              <span class="keyword">case</span> <a title="Types.this.Type" id="132777">p</a> =&gt; <a href="#132777" title="Types.this.Type">p</a>
            <span class="delimiter">}</span>,
            <a href="#83649" title="=&gt; Types.this.Scope">decls</a>,
            <a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#60409" title="Types.this.RefinedType" class="keyword">super</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a>
    <span class="delimiter">}</span>

    /** A refined type P1 with ... with Pn { decls } is volatile if
     *  one of the parent types Pi is an abstract type, and
     *  either i &gt; 1, or decls or a following parent Pj, j &gt; 1, contributes
     *  an abstract member.
     *  A type contributes an abstract member if it has an abstract member which
     *  is also a member of the whole refined type. A scope `decls` contributes
     *  an abstract member if it has an abstract definition which is also
     *  a member of the whole type.
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="60445">isVolatile</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(m: Types.this.Symbol)Boolean" id="132809">isVisible</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="132811">m</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
        <a href="#60409" title="RefinedType.this.type" class="keyword">this</a>.<a href="#41546" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#132811" title="Types.this.Symbol">m</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#46653" title="=&gt; List[Types.this.Symbol]">alternatives</a> <span title="(elem: Any)Boolean">contains</span> <a href="#132811" title="Types.this.Symbol">m</a>
      <span class="keyword">def</span> <a title="(p: Types.this.Type)Boolean" id="132810">contributesAbstractMembers</a><span class="delimiter">(</span><a title="Types.this.Type" id="132813">p</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
        <a href="#132813" title="Types.this.Type">p</a>.<a href="#41544" title="=&gt; List[Types.this.Symbol]">deferredMembers</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <a href="#132809" title="(m: Types.this.Symbol)Boolean">isVisible</a>

      <span class="delimiter">(</span><span class="delimiter">(</span><a href="#83648" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#132829" title="Types.this.Type">_</a>.<a href="#41492" title="=&gt; Boolean">isVolatile</a><span class="delimiter">)</span><span class="delimiter">)</span>
       <span title="(x: Boolean)Boolean">||</span>
       <span class="delimiter">(</span><a href="#83648" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">dropWhile</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span> <a href="#132834" title="Types.this.Type">_</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46448" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
         <span class="keyword">case</span> <a title="Boolean" id="132836">ps</a> @ <span class="delimiter">(</span>_ :: <a title="List[Types.this.Type]" id="132841">ps1</a><span class="delimiter">)</span> =&gt;
           <span class="delimiter">(</span><a href="#132836" title="collection.immutable.::[Types.this.Type]">ps</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#83648" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
           <span class="delimiter">(</span><a href="#132841" title="List[Types.this.Type]">ps1</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <a href="#132810" title="(p: Types.this.Type)Boolean">contributesAbstractMembers</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
           <span class="delimiter">(</span><a href="#83649" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60512" title="=&gt; Iterator[Types.this.Symbol]">iterator</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="132855">m</a> =&gt; <a href="#132855" title="Types.this.Symbol">m</a>.<a href="HasFlags.scala.html#46795" title="=&gt; Boolean">isDeferred</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#132809" title="(m: Types.this.Symbol)Boolean">isVisible</a><span class="delimiter">(</span><a href="#132855" title="Types.this.Symbol">m</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
         <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
           <span title="Boolean(false)" class="keyword">false</span>
       <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="60446">kind</a> = <span title="String(&quot;RefinedType&quot;)" class="string">&quot;RefinedType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class RefinedType0 extends Types.this.RefinedType with ScalaObject" id="38854">RefinedType0</a><a href="#38854" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Type]" id="132908">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="132909">decls</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="132910">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#60409" title="Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#132908" title="List[Types.this.Type]">parents</a>, <a href="#132909" title="Types.this.Scope">decls</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="132903">typeSymbol</a> = <a href="#132910" title="Types.this.Symbol">clazz</a>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.RefinedType" id="132915">RefinedType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#7741" title="Types.this.RefinedTypeExtractor">RefinedTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType" id="60408">apply</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="83633">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="83634">decls</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="83635">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#60409" title="Types.this.RefinedType">RefinedType</a> =
      <span title="Types.this.RefinedType0" class="keyword">new</span> <a href="#38854" title="Types.this.RefinedType0">RefinedType0</a><span class="delimiter">(</span><a href="#83633" title="List[Types.this.Type]">parents</a>, <a href="#83634" title="Types.this.Scope">decls</a>, <a href="#83635" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Overridden in reflection compiler */
  <span class="keyword">def</span> <a title="(tp: Types.this.ClassInfoType)Unit" id="38855">validateClassInfo</a><span class="delimiter">(</span><a title="Types.this.ClassInfoType" id="132916">tp</a>: <a href="#70033" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>

  /** A class representing a class info
   */
  case <span class="keyword">class</span> <a title="class ClassInfoType extends Types.this.CompoundType with ScalaObject with Product with Serializable" id="70033">ClassInfoType</a><a href="#70033" title="ScalaObject" class="delimiter">(</a>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Type]" id="70075">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>,
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Scope" id="70076">decls</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a>,
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Symbol" id="70077">typeSymbol</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38848" title="Types.this.CompoundType">CompoundType</a>
  <span class="delimiter">{</span>
    <a href="#38855" title="(tp: Types.this.ClassInfoType)Unit">validateClassInfo</a><span class="delimiter">(</span><a href="#70033" title="Types.this.ClassInfoType" class="keyword">this</a><span class="delimiter">)</span>

    /** refs indices */
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(0)" id="70044">NonExpansive</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(1)" id="70046">Expansive</a> = <span title="Int(1)" class="int">1</span>

    /** initialization states */
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(0)" id="70048">UnInitialized</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(1)" id="70050">Initializing</a> = <span title="Int(1)" class="int">1</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(2)" id="70052">Initialized</a> = <span title="Int(2)" class="int">2</span>

    <span class="keyword">private</span> <span class="keyword">type</span> <a title="Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]" id="70054">RefMap</a> = <span title="Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">Map</span><span class="delimiter">[</span>Symbol, immutable.Set<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span>

    /** All type parameters reachable from given type parameter
     *  by a path which contains at least one expansive reference.
     *  @See Kennedy, Pierce: On Decidability of Nominal Subtyping with Variance
     */
    <span class="keyword">private</span><span class="delimiter">[</span>scala<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Set[Types.this.Symbol]" id="70055">expansiveRefs</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="132924">tparam</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#70060" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)">UnInitialized</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#70068" title="()Unit">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#70060" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(2)">Initialized</span><span class="delimiter">)</span> <a href="#70069" title="()Boolean">propagate</a><a href="#132933" title="()Unit" class="delimiter">(</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#70062" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#132924" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /* The rest of this class is auxiliary code for `expansiveRefs`
     */

    /** The type parameters which are referenced type parameters of this class.
     *  Two entries: refs(0): Non-expansive references
     *               refs(1): Expansive references
     *  Syncnote: This var need not be protected with synchronized, because
     *  it is accessed only from expansiveRefs, which is called only from
     *  Typer.
     */
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Array[ClassInfoType.this.RefMap]" id="70057">refs</a>: <span title="Array[ClassInfoType.this.RefMap]">Array</span><span class="delimiter">[</span>RefMap<span class="delimiter">]</span> = _

    /** The initialization state of the class: UnInialized --&gt; Initializing --&gt; Initialized
     *  Syncnote: This var need not be protected with synchronized, because
     *  it is accessed only from expansiveRefs, which is called only from
     *  Typer.
     */
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="70060">state</a> = <span title="Int(0)">UnInitialized</span>

    /** Get references for given type parameter
     *  @param  which in {NonExpansive, Expansive}
     *  @param  from  The type parameter from which references originate.
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]" id="70062">getRefs</a><span class="delimiter">(</span><a title="Int" id="132940">which</a>: <span title="Int">Int</span>, <a title="Types.this.Symbol" id="132941">from</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Set[Types.this.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#70057" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#132940" title="Int">which</a><span class="delimiter">)</span> <span title="(key: Types.this.Symbol)Option[scala.collection.immutable.Set[Types.this.Symbol]]">get</span> <a href="#132941" title="Types.this.Symbol">from</a> <span title="Set[Types.this.Symbol]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="scala.collection.immutable.Set[Types.this.Symbol]">Some</span><span class="delimiter">(</span><a title="scala.collection.immutable.Set[Types.this.Symbol]" id="132958">set</a><span class="delimiter">)</span> =&gt; <a href="#132958" title="scala.collection.immutable.Set[Types.this.Symbol]">set</a>
      <span class="keyword">case</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="132959">none</a> =&gt; <span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]">Set</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Augment existing refs map with reference &lt;pre&gt;from -&gt; to&lt;/pre&gt;
     *  @param  which &lt;- {NonExpansive, Expansive}
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit" id="70063">addRef</a><span class="delimiter">(</span><a title="Int" id="132963">which</a>: <span title="Int">Int</span>, <a title="Types.this.Symbol" id="132964">from</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="132965">to</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#70057" title="(i: Int, x: ClassInfoType.this.RefMap)Unit">refs</a><span class="delimiter">(</span><a href="#132963" title="Int">which</a><span class="delimiter">)</span> = <a href="#70057" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#132963" title="Int">which</a><span class="delimiter">)</span> <span title="(kv: (Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol]))scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">+</span> <span class="delimiter">(</span><a href="#132964" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">from</a> <span title="(y: scala.collection.immutable.Set[Types.this.Symbol])(Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])">-&gt;</span> <span class="delimiter">(</span><a href="#70062" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><a href="#132963" title="Int">which</a>, <a href="#132964" title="Types.this.Symbol">from</a><span class="delimiter">)</span> <span title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">+</span> <a href="#132965" title="Types.this.Symbol">to</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Augment existing refs map with references &lt;pre&gt;from -&gt; sym&lt;/pre&gt;, for
     *  all elements &lt;pre&gt;sym&lt;/pre&gt; of set `to`.
     *  @param  which &lt;- {NonExpansive, Expansive}
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit" id="70064">addRefs</a><span class="delimiter">(</span><a title="Int" id="133069">which</a>: <span title="Int">Int</span>, <a title="Types.this.Symbol" id="133070">from</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Set[Types.this.Symbol]" id="133071">to</a>: <span title="Set[Types.this.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#70057" title="(i: Int, x: ClassInfoType.this.RefMap)Unit">refs</a><span class="delimiter">(</span><a href="#133069" title="Int">which</a><span class="delimiter">)</span> = <a href="#70057" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#133069" title="Int">which</a><span class="delimiter">)</span> <span title="(kv: (Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol]))scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">+</span> <span class="delimiter">(</span><a href="#133070" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">from</a> <span title="(y: scala.collection.immutable.Set[Types.this.Symbol])(Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])">-&gt;</span> <span class="delimiter">(</span><a href="#70062" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><a href="#133069" title="Int">which</a>, <a href="#133070" title="Types.this.Symbol">from</a><span class="delimiter">)</span> <span title="(elems: scala.collection.GenTraversableOnce[Types.this.Symbol])scala.collection.immutable.Set[Types.this.Symbol]">++</span> <a href="#133071" title="Set[Types.this.Symbol]">to</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** The ClassInfoType which belongs to the class containing given type parameter
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Types.this.ClassInfoType" id="70065">classInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="133215">tparam</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#70033" title="Types.this.ClassInfoType">ClassInfoType</a> =
      <a href="#133215" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41519" title="=&gt; Types.this.Type">resultType</a> <span title="Types.this.ClassInfoType" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="Types.this.ClassInfoType" id="133219">ci</a>: <a href="#70033" title="Types.this.ClassInfoType">ClassInfoType</a> =&gt; <a href="#133219" title="Types.this.ClassInfoType">ci</a>
        <span class="keyword">case</span> <span title="Types.this.ClassInfoType">_</span> =&gt; <a href="#70065" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><a href="Definitions.scala.html#44986" title="=&gt; Types.this.Symbol">ObjectClass</a><span class="delimiter">)</span> // something's wrong; fall back to safe value
                                         // (this can happen only for erroneous programs).
      <span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">object</span> <a title="object ClassInfoType.this.enterRefs" id="70066">enterRefs</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
      <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Symbol" id="133222">tparam</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = _

      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="133224">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="133228">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
        <a href="#133228" title="Types.this.Type">tp</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Unit" id="133231">tr</a> @ TypeRef<span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="133232">sym</a>, <a title="List[Types.this.Type]" id="133233">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#133233" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">nonEmpty</span> =&gt;
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="133234">tparams</a> = <a href="#133231" title="Types.this.TypeRef">tr</a>.<a href="#62125" title="=&gt; List[Types.this.Symbol]">initializedTypeParams</a>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74514" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#133234" title="List[Types.this.Symbol]">tparams</a>, <a href="#133233" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="SymbolTable.scala.html#35606" title="(msg: =&gt; String)Unit">debugwarn</a><span class="delimiter">(</span><span title="String(&quot;Mismatched zip in computeRefs(): &quot;)" class="string">&quot;Mismatched zip in computeRefs(): &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#133232" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41528" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#133233" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>

            <a href="util/Collections.scala.html#38337" title="(xs1: List[Types.this.Symbol], xs2: List[Types.this.Type])(f: (Types.this.Symbol, Types.this.Type) =&gt; Unit)Unit">foreach2</a><span class="delimiter">(</span><a href="#133234" title="List[Types.this.Symbol]">tparams</a>, <a href="#133233" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="133276">tparam1</a>, <a title="Types.this.Type" id="133277">arg</a><span class="delimiter">)</span> =&gt;
              <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133277" title="Types.this.Type">arg</a> <a href="#41569" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#133222" title="=&gt; Types.this.Symbol">tparam</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="#70063" title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit">addRef</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#133222" title="=&gt; Types.this.Symbol">tparam</a>, <a href="#133276" title="Types.this.Symbol">tparam1</a><span class="delimiter">)</span>
                <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133277" title="Types.this.Type">arg</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#133222" title="=&gt; Types.this.Symbol">tparam</a><span class="delimiter">)</span>
                  <a href="#70063" title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit">addRef</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#133222" title="=&gt; Types.this.Symbol">tparam</a>, <a href="#133276" title="Types.this.Symbol">tparam1</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
        <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#133228" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="(tparam0: Types.this.Symbol, parent: Types.this.Type)Unit" id="133225">enter</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="133292">tparam0</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="133293">parent</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">this</span>.<a href="#133222" title="(x$1: Types.this.Symbol)Unit">tparam</a> = <a href="#133292" title="Types.this.Symbol">tparam0</a>
        <a href="#133224" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span title="Unit" class="delimiter">(</span><a href="#133293" title="Types.this.Type">parent</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** Compute initial (one-step) references and set state to `Initializing`.
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="()Unit" id="70068">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#70057" title="(x$1: Array[ClassInfoType.this.RefMap])Unit">refs</a> = <span title="(xs: ClassInfoType.this.RefMap*)(implicit evidence$2: scala.reflect.ClassManifest[ClassInfoType.this.RefMap])Array[ClassInfoType.this.RefMap]">Array</span><a href="#7741" title="(clazz: Class[_], arg1: scala.reflect.OptManifest[_], args: scala.reflect.OptManifest[_]*)scala.reflect.ClassManifest[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" class="delimiter">(</a><span title="(elems: (Types.this.Symbol, Nothing)*)scala.collection.immutable.Map[Types.this.Symbol,Nothing]">Map</span><span class="delimiter">(</span><span class="delimiter">)</span>, <span title="(elems: (Types.this.Symbol, Nothing)*)scala.collection.immutable.Map[Types.this.Symbol,Nothing]">Map</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#70077" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(f: Types.this.Symbol =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="133391">tparam</a> =&gt;
        <a href="#70075" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="Types.this.Type" id="133411">p</a> =&gt;
          <a href="#70066" title="object ClassInfoType.this.enterRefs">enterRefs</a>.<a href="#133225" title="(tparam0: Types.this.Symbol, parent: Types.this.Type)Unit">enter</a><span class="delimiter">(</span><a href="#133391" title="Types.this.Symbol">tparam</a>, <a href="#133411" title="Types.this.Type">p</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#70060" title="(x$1: Int)Unit">state</a> = <span title="Int(1)">Initializing</span>
    <span class="delimiter">}</span>

    /** Propagate to form transitive closure.
     *  Set state to Initialized if no change resulted from propagation.
     *  @return   true iff there as a change in last iteration
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="()Boolean" id="70069">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#70060" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)">UnInitialized</span><span class="delimiter">)</span> <a href="#70068" title="()Unit">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span>
      //Console.println(&quot;Propagate &quot;+symbol+&quot;, initial expansive = &quot;+refs(Expansive)+&quot;, nonexpansive = &quot;+refs(NonExpansive))//DEBUG
      <span class="keyword">val</span> <a title="Array[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" id="133414">lastRefs</a> = <span title="(xs: ClassInfoType.this.RefMap*)(implicit evidence$2: scala.reflect.ClassManifest[ClassInfoType.this.RefMap])Array[ClassInfoType.this.RefMap]">Array</span><a href="#7741" title="(clazz: Class[_], arg1: scala.reflect.OptManifest[_], args: scala.reflect.OptManifest[_]*)scala.reflect.ClassManifest[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" class="delimiter">(</a><a href="#70057" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>, <a href="#70057" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#70060" title="(x$1: Int)Unit">state</a> = <span title="Int(2)">Initialized</span>
      <span class="keyword">var</span> <a title="Boolean" id="133415">change</a> = <span title="Boolean(false)" class="keyword">false</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="133510">from</a>, <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="133511">targets</a><span class="delimiter">)</span> &lt;- <a href="#70057" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span><span class="delimiter">)</span>.<a href="#133492" title="(f: ((Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])) =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="133536">target</a> &lt;- <a href="#133511" title="(f: Types.this.Symbol =&gt; Unit)Unit">targets</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">var</span> <a title="Types.this.ClassInfoType" id="133537">thatInfo</a> = <a href="#70065" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><a href="#133536" title="Types.this.Symbol">target</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133537" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#70060" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(2)">Initialized</span><span class="delimiter">)</span>
            <a href="#133415" title="Boolean">change</a> = <a href="#133415" title="Boolean">change</a> <span title="(x: Boolean)Boolean">|</span> <a href="#133537" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#70069" title="()Boolean">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#70064" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#133510" title="Types.this.Symbol">from</a>, <a href="#133537" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#70062" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#133536" title="Types.this.Symbol">target</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#70064" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#133510" title="Types.this.Symbol">from</a>, <a href="#133537" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#70062" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#133536" title="Types.this.Symbol">target</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="133565">from</a>, <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="133566">targets</a><span class="delimiter">)</span> &lt;- <a href="#70057" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span><span class="delimiter">)</span>.<a href="#133547" title="(f: ((Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])) =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="133583">target</a> &lt;- <a href="#133566" title="(f: Types.this.Symbol =&gt; Unit)Unit">targets</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">var</span> <a title="Types.this.ClassInfoType" id="133584">thatInfo</a> = <a href="#70065" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><a href="#133583" title="Types.this.Symbol">target</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133584" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#70060" title="=&gt; Int">state</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(2)">Initialized</span><span class="delimiter">)</span>
            <a href="#133415" title="Boolean">change</a> = <a href="#133415" title="Boolean">change</a> <span title="(x: Boolean)Boolean">|</span> <a href="#133584" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#70069" title="()Boolean">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#70064" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#133565" title="Types.this.Symbol">from</a>, <a href="#133584" title="Types.this.ClassInfoType">thatInfo</a>.<a href="#70062" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#133583" title="Types.this.Symbol">target</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <a href="#133415" title="Boolean">change</a> = <a href="#133415" title="Boolean">change</a> <span title="(x: Boolean)Boolean">||</span> <a href="#70057" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#133414" title="(i: Int)scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">lastRefs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#70057" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#133414" title="(i: Int)scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">lastRefs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133415" title="Boolean">change</a><span class="delimiter">)</span> <a href="#70060" title="(x$1: Int)Unit">state</a> = <span title="Int(1)">Initializing</span>
      //else Console.println(&quot;Propagate &quot;+symbol+&quot;, final expansive = &quot;+refs(Expansive)+&quot;, nonexpansive = &quot;+refs(NonExpansive))//DEBUG
      <a href="#133415" title="Boolean">change</a>
    <span class="delimiter">}</span>

    // override def isNullable: Boolean =
    // symbol == AnyClass ||
    // symbol != NothingClass &amp;&amp; (symbol isSubClass ObjectClass) &amp;&amp; !(symbol isSubClass NonNullClass);

    // override def isNonNull: Boolean = symbol == NonNullClass || super.isNonNull;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="70070">kind</a> = <span title="String(&quot;ClassInfoType&quot;)" class="string">&quot;ClassInfoType&quot;</span>
    
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="70071">safeToString</a> =
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74514" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">||</span> <a href="#70076" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60496" title="=&gt; Int">size</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
        <a href="#70072" title="=&gt; String">formattedToString</a>
      <span class="keyword">else</span>
        <a href="#70033" title="Types.this.ClassInfoType" class="keyword">super</a>.<a href="#60433" title="=&gt; String">safeToString</a>

    /** A nicely formatted string with newlines and such.
     */
    <span class="keyword">def</span> <a title="=&gt; String" id="70072">formattedToString</a>: <span title="String">String</span> =
      <a href="#70075" title="=&gt; List[Types.this.Type]">parents</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;\n        with &quot;)" class="string">&quot;\n        with &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span>
      <span class="delimiter">(</span><span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74514" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">||</span> <a href="#70075" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#70076" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60476" title="=&gt; Types.this.ScopeEntry">elems</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#70076" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60517" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot; {\n  &quot;)" class="string">&quot; {\n  &quot;</span>, <span title="String(&quot;\n  &quot;)" class="string">&quot;\n  &quot;</span>, <span title="String(&quot;\n}&quot;)" class="string">&quot;\n}&quot;</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.ClassInfoType" id="133661">ClassInfoType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#7741" title="Types.this.ClassInfoTypeExtractor">ClassInfoTypeExtractor</a>

  <span class="keyword">class</span> <a title="class PackageClassInfoType extends Types.this.ClassInfoType with ScalaObject" id="38859">PackageClassInfoType</a><a href="#38859" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Scope" id="133670">decls</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="133671">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="#70033" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">(</span>List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#133670" title="Types.this.Scope">decls</a>, <a href="#133671" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>

  /** A class representing a constant type.
   *
   *  @param value ...
   */
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#133707" title="class ConstantType extends Types.this.SingletonType with ScalaObject with Product with Serializable" id="83388">ConstantType</a><a href="#83388" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Constant" id="83396">value</a>: <a href="Constants.scala.html#39257" title="Types.this.Constant">Constant</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38819" title="Types.this.SingletonType">SingletonType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83381">underlying</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#83396" title="=&gt; Types.this.Constant">value</a>.<a href="Constants.scala.html#46274" title="=&gt; Types.this.Type">tpe</a>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#83381" title="=&gt; Types.this.Type">underlying</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#45531" title="=&gt; Types.this.Symbol">UnitClass</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83382">isTrivial</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83383">isNotNull</a> = <a href="#83396" title="=&gt; Types.this.Constant">value</a>.<a href="Constants.scala.html#46260" title="=&gt; Any">value</a> <span title="(x$1: Any)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83384">deconst</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#83381" title="=&gt; Types.this.Type">underlying</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83385">safeToString</a>: <span title="String">String</span> =
      <a href="#83381" title="=&gt; Types.this.Type">underlying</a>.<a href="#41589" title="()String">toString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#83396" title="=&gt; Types.this.Constant">value</a>.<a href="Constants.scala.html#46288" title="=&gt; String">escapedStringValue</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
    // override def isNullable: Boolean = value.value eq null
    // override def isNonNull: Boolean = value.value ne null
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83386">kind</a> = <span title="String(&quot;ConstantType&quot;)" class="string">&quot;ConstantType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class UniqueConstantType extends Types.this.ConstantType with Types.this.UniqueType with ScalaObject" id="38863">UniqueConstantType</a><a href="#38863" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Constant" id="133732">value</a>: <a href="Constants.scala.html#39257" title="Types.this.Constant">Constant</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#83388" title="Types.this.ConstantType">ConstantType</a><span class="delimiter">(</span><a href="#133732" title="Types.this.Constant">value</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#38814" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span>
    /** Save the type of `value`. For Java enums, it depends on finding the linked class,
     *  which might not be found after `flatten`. */
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.Type" id="133728">_tpe</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#133732" title="Types.this.Constant">value</a>.<a href="Constants.scala.html#46274" title="=&gt; Types.this.Type">tpe</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133729">underlying</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#133727" title="=&gt; Types.this.Type">_tpe</a>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.ConstantType" id="133739">ConstantType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#7741" title="Types.this.ConstantTypeExtractor">ConstantTypeExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(value: Types.this.Constant)Types.this.ConstantType" id="83376">apply</a><span class="delimiter">(</span><a title="Types.this.Constant" id="83399">value</a>: <a href="Constants.scala.html#39257" title="Types.this.Constant">Constant</a><span class="delimiter">)</span>: <a href="#83388" title="Types.this.ConstantType">ConstantType</a> = <span class="delimiter">{</span>
      <a href="#38967" title="(tp: Types.this.UniqueConstantType)Types.this.UniqueConstantType">unique</a><span class="delimiter">(</span><span title="Types.this.UniqueConstantType" class="keyword">new</span> <a href="#38863" title="Types.this.UniqueConstantType">UniqueConstantType</a><span class="delimiter">(</span><a href="#83399" title="Types.this.Constant">value</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.ConstantType" class="delimiter">[</span><a href="#83388" title="Types.this.ConstantType">ConstantType</a><span class="delimiter">]</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /* Syncnote: The `volatile` var and `pendingVolatiles` mutable set need not be protected 
   * with synchronized, because they are accessed only from isVolatile, which is called only from
   * Typer.
   */
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="38865">volatileRecursions</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.Symbol]" id="38867">pendingVolatiles</a> = <span title="()scala.collection.mutable.HashSet[Types.this.Symbol]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Types.this.Symbol]">HashSet</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
  
  <span class="keyword">class</span> <a title="class ArgsTypeRef extends Types.this.TypeRef with Types.this.UniqueType with ScalaObject" id="38869">ArgsTypeRef</a><a href="#38869" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="133755">pre0</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="133756">sym0</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="133757">args0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#62154" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">(</span><a href="#133755" title="Types.this.Type">pre0</a>, <a href="#133756" title="Types.this.Symbol">sym0</a>, <a href="#133757" title="List[Types.this.Type]">args0</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#38814" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#133757" title="List[Types.this.Type]">args0</a>.<span title="=&gt; Boolean">nonEmpty</span>, <a href="#38869" title="Types.this.ArgsTypeRef" class="keyword">this</a><span class="delimiter">)</span>

    /** No unapplied type params size it has (should have) equally as many args. */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133747">isHigherKinded</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Nil.type" id="133748">typeParams</a> = <span title="object Nil">Nil</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="133749">transform</a><span class="delimiter">(</span><a title="Types.this.Type" id="133766">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      // This situation arises when a typevar is encountered for which
      // too little information is known to determine its kind, and
      // it later turns out not to have kind *. See SI-4070.  Only
      // logging it for now.
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">!=</span> <a href="#62173" title="=&gt; List[Types.this.Type]">args</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>
        <a href="SymbolTable.scala.html#35602" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;!!! %s.transform(%s), but tparams.isEmpty and args=&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#38869" title="Types.this.ArgsTypeRef" class="keyword">this</a>, <a href="#133766" title="Types.this.Type">tp</a>, <a href="#62173" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <a href="#62127" title="(tp: Types.this.Type)Types.this.Type">asSeenFromOwner</a><span class="delimiter">(</span><a href="#133766" title="Types.this.Type">tp</a><span class="delimiter">)</span>.<a href="#41531" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#62173" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    
    // note: does not go through typeRef. There's no need to because
    // neither `pre` nor `sym` changes.  And there's a performance
    // advantage to call TypeRef directly.
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133750">typeConstructor</a> = <a href="#62092" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#62171" title="=&gt; Types.this.Type">pre</a>, <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">class</span> <a title="class NoArgsTypeRef extends Types.this.TypeRef with Types.this.UniqueType with ScalaObject" id="38870">NoArgsTypeRef</a><a href="#38870" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="133804">pre0</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="133805">sym0</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#62154" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">(</span><a href="#133804" title="Types.this.Type">pre0</a>, <a href="#133805" title="Types.this.Symbol">sym0</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#38814" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span>
    // A reference (in a Scala program) to a type that has type parameters, but where the reference
    // does not include type arguments. Note that it doesn't matter whether the symbol refers
    // to a java or scala symbol, but it does matter whether it occurs in java or scala code.
    // TypeRefs w/o type params that occur in java signatures/code are considered raw types, and are
    // represented as existential types.
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133792">isHigherKinded</a> = <a href="#133793" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">nonEmpty</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="133793">typeParams</a>     = <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#44944" title="=&gt; Boolean">isDefinitionsInitialized</a><span class="delimiter">)</span> <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span class="keyword">else</span> <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46627" title="=&gt; List[Types.this.Symbol]">unsafeTypeParams</a>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133794">isRaw</a>           = <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#38988" title="(sym: Types.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
    
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="133795">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="133816">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="133817">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133792" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#133816" title="List[Types.this.Symbol]">formals</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])List[Types.this.Symbol]">intersect</span> <a href="#133793" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#133793" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#38935" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#38870" title="Types.this.NoArgsTypeRef" class="keyword">this</a>, <a href="#62171" title="=&gt; Types.this.Type">pre</a>, <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>, <a href="#133817" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
        // partial application (needed in infer when bunching type arguments from classes and methods together)
        <span class="keyword">else</span>
          <a href="#38935" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#38870" title="Types.this.NoArgsTypeRef" class="keyword">this</a>, <a href="#62171" title="=&gt; Types.this.Type">pre</a>, <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>, <a href="#41518" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>.<a href="#41531" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#133816" title="List[Types.this.Symbol]">formals</a>, <a href="#133817" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span>
        <a href="#38870" title="Types.this.NoArgsTypeRef" class="keyword">super</a>.<a href="#41531" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#133816" title="List[Types.this.Symbol]">formals</a>, <a href="#133817" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="133796">transform</a><span class="delimiter">(</span><a title="Types.this.Type" id="133837">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="133839">res</a> = <a href="#62127" title="(tp: Types.this.Type)Types.this.Type">asSeenFromOwner</a><span class="delimiter">(</span><a href="#133837" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133792" title="=&gt; Boolean">isHigherKinded</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#133794" title="=&gt; Boolean">isRaw</a><span class="delimiter">)</span>
        <a href="#133839" title="Types.this.Type">res</a>.<a href="#41531" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#133793" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#41518" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <a href="#133839" title="Types.this.Type">res</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="133797">transformInfo</a><span class="delimiter">(</span><a title="Types.this.Type" id="133840">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = 
      <a href="#38940" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#62127" title="(tp: Types.this.Type)Types.this.Type">asSeenFromOwner</a><span class="delimiter">(</span><a href="#133840" title="Types.this.Type">tp</a><span class="delimiter">)</span>, <a href="#41518" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>
      
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133798">narrow</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46463" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <a href="#38930" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#62171" title="=&gt; Types.this.Type">pre</a>, <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46672" title="=&gt; Types.this.Symbol">sourceModule</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#38870" title="Types.this.NoArgsTypeRef" class="keyword">super</a>.<a href="#41511" title="=&gt; Types.this.Type">narrow</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.NoArgsTypeRef" id="133799">typeConstructor</a> = <a href="#38870" title="Types.this.NoArgsTypeRef" class="keyword">this</a>
    // eta-expand, subtyping relies on eta-expansion of higher-kinded types

    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133800">normalizeImpl</a>: <a href="#38813" title="Types.this.Type">Type</a> = 
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133792" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#62121" title="=&gt; Types.this.Type">etaExpand</a> <span class="keyword">else</span> <a href="#38870" title="Types.this.NoArgsTypeRef" class="keyword">super</a>.<a href="#62119" title="=&gt; Types.this.Type">normalizeImpl</a>
  <span class="delimiter">}</span>
  
  <span class="keyword">trait</span> <a title="trait ClassTypeRef extends Types.this.TypeRef with ScalaObject" id="38871">ClassTypeRef</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#62154" title="Types.this.TypeRef">TypeRef</a> <span class="delimiter">{</span>
    // !!! There are scaladoc-created symbols arriving which violate this require.
    // require(sym.isClass, sym)
    
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133859">normalizeImpl</a>: <a href="#38813" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46467" title="=&gt; Boolean">isRefinementClass</a><span class="delimiter">)</span> <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a> // I think this is okay, but see #1241 (r12414), #2208, and typedTypeConstructor in Typers
      <span class="keyword">else</span> <a href="#38871" title="Types.this.ClassTypeRef" class="keyword">super</a>.<a href="#62119" title="=&gt; Types.this.Type">normalizeImpl</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="133860">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="133867">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#133867" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <a href="#38871" title="Types.this.ClassTypeRef" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#62118" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41553" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#133867" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">trait</span> <a title="trait NonClassTypeRef extends Types.this.TypeRef with ScalaObject" id="38872">NonClassTypeRef</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#62154" title="Types.this.TypeRef">TypeRef</a> <span class="delimiter">{</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46450" title="=&gt; Boolean">isNonClassType</a>, <a href="#62172" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

    /* Syncnote: These are pure caches for performance; no problem to evaluate these
     * several times. Hence, no need to protected with synchronzied in a mutli-threaded
     * usage scenario.
     */
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="133878">relativeInfoCache</a>: <a href="#38813" title="Types.this.Type">Type</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="133881">memberInfoCache</a>: <a href="#38813" title="Types.this.Type">Type</a> = _

    <span class="keyword">private</span><span class="delimiter">[</span>Types<span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133883">relativeInfo</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="133894">memberInfo</a> = <a href="#62171" title="=&gt; Types.this.Type">pre</a>.<a href="#41555" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#133878" title="=&gt; Types.this.Type">relativeInfoCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#133894" title="Types.this.Type">memberInfo</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#133881" title="=&gt; Types.this.Type">memberInfoCache</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#133881" title="(x$1: Types.this.Type)Unit">memberInfoCache</a> = <a href="#133894" title="Types.this.Type">memberInfo</a>
        <a href="#133878" title="(x$1: Types.this.Type)Unit">relativeInfoCache</a> = <a href="#62123" title="(tp: Types.this.Type)Types.this.Type">transformInfo</a><span class="delimiter">(</span><a href="#133894" title="Types.this.Type">memberInfo</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#133878" title="=&gt; Types.this.Type">relativeInfoCache</a>
    <span class="delimiter">}</span>
    
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="133884">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="133900">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#133900" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <a href="#38872" title="Types.this.NonClassTypeRef" class="keyword">this</a> <span class="keyword">else</span> <a href="#38873" title="(tpe: Types.this.NonClassTypeRef, clazz: Types.this.Symbol)Types.this.Type">baseTypeOfNonClassTypeRef</a><span class="delimiter">(</span><a href="#38872" title="Types.this.NonClassTypeRef" class="keyword">this</a>, <a href="#133900" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tpe: Types.this.NonClassTypeRef, clazz: Types.this.Symbol)Types.this.Type" id="38873">baseTypeOfNonClassTypeRef</a><span class="delimiter">(</span><a title="Types.this.NonClassTypeRef" id="133907">tpe</a>: <a href="#38872" title="Types.this.NonClassTypeRef">NonClassTypeRef</a>, <a title="Types.this.Symbol" id="133908">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="#39057" title="(x$1: Int)Unit">basetypeRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#39057" title="=&gt; Int">basetypeRecursions</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(50)">LogPendingBaseTypesThreshold</span><span class="delimiter">)</span>
      <a href="#133907" title="Types.this.NonClassTypeRef">tpe</a>.<a href="#133883" title="=&gt; Types.this.Type">relativeInfo</a>.<a href="#41553" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#133908" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#39059" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <span title="(elem: Types.this.Type)Boolean">contains</span> <a href="#133907" title="Types.this.NonClassTypeRef">tpe</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#133908" title="Types.this.Symbol">clazz</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span> <a href="#133908" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#131699" title="object Types.this.NoType">NoType</a>
    <span class="keyword">else</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#39059" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <span title="(elem: Types.this.Type)Types.this.pendingBaseTypes.type">+=</span> <a href="#133907" title="Types.this.NonClassTypeRef">tpe</a>
        <a href="#133907" title="Types.this.NonClassTypeRef">tpe</a>.<a href="#133883" title="=&gt; Types.this.Type">relativeInfo</a>.<a href="#41553" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#133908" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
        <a href="#39059" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <span title="(elem: Types.this.Type)Types.this.pendingBaseTypes.type">-=</span> <a href="#133907" title="Types.this.NonClassTypeRef">tpe</a>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#39057" title="(x$1: Int)Unit">basetypeRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">trait</span> <a title="trait AliasTypeRef extends Types.this.TypeRef with Types.this.NonClassTypeRef with ScalaObject" id="38874">AliasTypeRef</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38872" title="Types.this.NonClassTypeRef">NonClassTypeRef</a> <span class="delimiter">{</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46447" title="=&gt; Boolean">isAliasType</a>, <a href="#62172" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133956">dealias</a>    = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#62126" title="=&gt; Boolean">typeParamsMatchArgs</a><span class="delimiter">)</span> <a href="#133965" title="=&gt; Types.this.Type">betaReduce</a>.<a href="#41535" title="=&gt; Types.this.Type">dealias</a> <span class="keyword">else</span> <a href="#38874" title="Types.this.AliasTypeRef" class="keyword">super</a>.<a href="#41535" title="=&gt; Types.this.Type">dealias</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133957">isStable</a>   = <a href="#62120" title="=&gt; Types.this.Type">normalize</a>.<a href="#41491" title="=&gt; Boolean">isStable</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="133958">isVolatile</a> = <a href="#62120" title="=&gt; Types.this.Type">normalize</a>.<a href="#41492" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133959">narrow</a>     = <a href="#62120" title="=&gt; Types.this.Type">normalize</a>.<a href="#41511" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133960">thisInfo</a>   = <a href="#62120" title="=&gt; Types.this.Type">normalize</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133961">prefix</a>     = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#38874" title="AliasTypeRef.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#62120" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#62120" title="=&gt; Types.this.Type">normalize</a>.<a href="#41514" title="=&gt; Types.this.Type">prefix</a> <span class="keyword">else</span> <a href="#62171" title="=&gt; Types.this.Type">pre</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="133962">termSymbol</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#38874" title="AliasTypeRef.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#62120" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#62120" title="=&gt; Types.this.Type">normalize</a>.<a href="#41503" title="=&gt; Types.this.Symbol">termSymbol</a> <span class="keyword">else</span> <a href="#38874" title="Types.this.AliasTypeRef" class="keyword">super</a>.<a href="#62132" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="133963">typeSymbol</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#38874" title="AliasTypeRef.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#62120" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#62120" title="=&gt; Types.this.Type">normalize</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span class="keyword">else</span> <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>

    // beta-reduce, but don't do partial application -- cycles have been checked in typeRef
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133964">normalizeImpl</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#62126" title="=&gt; Boolean">typeParamsMatchArgs</a><span class="delimiter">)</span> <a href="#133965" title="=&gt; Types.this.Type">betaReduce</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#41490" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#38874" title="Types.this.AliasTypeRef" class="keyword">super</a>.<a href="#62119" title="=&gt; Types.this.Type">normalizeImpl</a>
      <span class="keyword">else</span> <a href="#131624" title="object Types.this.ErrorType">ErrorType</a>
    
    // isHKSubType0 introduces synthetic type params so that
    // betaReduce can first apply sym.info to typeArgs before calling
    // asSeenFrom.  asSeenFrom then skips synthetic type params, which
    // are used to reduce HO subtyping to first-order subtyping, but
    // which can't be instantiated from the given prefix and class.
    //
    // this crashes pos/depmet_implicit_tpbetareduce.scala
    // appliedType(sym.info, typeArgs).asSeenFrom(pre, sym.owner)
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="133965">betaReduce</a> = <a href="#62118" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41519" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
    
    // #3731: return sym1 for which holds: pre bound sym.name to sym and
    // pre1 now binds sym.name to sym1, conceptually exactly the same
    // symbol as sym.  The selection of sym on pre must be updated to the
    // selection of sym1 on pre1, since sym's info was probably updated
    // by the TypeMap to yield a new symbol, sym1 with transformed info.
    // @returns sym1
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(pre1: Types.this.Type)Types.this.Symbol" id="133966">coevolveSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="134031">pre1</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> =
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#62171" title="=&gt; Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#134031" title="Types.this.Type">pre1</a><span class="delimiter">)</span> <a href="#62172" title="=&gt; Types.this.Symbol">sym</a> <span class="keyword">else</span> <span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#62171" title="=&gt; Types.this.Type">pre</a>, <a href="#134031" title="Types.this.Type">pre1</a><span class="delimiter">)</span> <span title="Types.this.Symbol" class="keyword">match</span> <span class="delimiter">{</span>
        // don't look at parents -- it would be an error to override alias types anyway
        <span class="keyword">case</span> <span title="Types.this.Symbol" class="delimiter">(</span>RefinedType<span class="delimiter">(</span>_, _<span class="delimiter">)</span>, RefinedType<span class="delimiter">(</span>_, <a title="Types.this.Scope" id="134043">decls1</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#134043" title="Types.this.Scope">decls1</a> <a href="Scopes.scala.html#60506" title="(name: Types.this.Name)Types.this.Symbol">lookup</a> <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a>
        // TODO: is there another way a typeref's symbol can refer to a symbol defined in its pre?
        <span class="keyword">case</span> <span title="Types.this.Symbol">_</span>                                           =&gt; <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>
      <span class="delimiter">}</span>
    
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait AbstractTypeRef extends Types.this.TypeRef with Types.this.NonClassTypeRef with ScalaObject" id="38875">AbstractTypeRef</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38872" title="Types.this.NonClassTypeRef">NonClassTypeRef</a> <span class="delimiter">{</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46448" title="=&gt; Boolean">isAbstractType</a>, <a href="#62172" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
    
    /** Syncnote: Pure performance caches; no need to synchronize in multi-threaded environment
     */
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="134047">symInfoCache</a>: <a href="#38813" title="Types.this.Type">Type</a> = _
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="134050">thisInfoCache</a>: <a href="#38813" title="Types.this.Type">Type</a> = _

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="134052">isVolatile</a> = <span class="delimiter">{</span>
      // need to be careful not to fall into an infinite recursion here
      // because volatile checking is done before all cycles are detected.
      // the case to avoid is an abstract type directly or
      // indirectly upper-bounded by itself. See #2918
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#38865" title="(x$1: Int)Unit">volatileRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#38865" title="=&gt; Int">volatileRecursions</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(50)">LogVolatileThreshold</span><span class="delimiter">)</span>
          <a href="#134055" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a>.<a href="#41492" title="=&gt; Boolean">isVolatile</a>
        <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#38867" title="(elem: Types.this.Symbol)Boolean">pendingVolatiles</a><span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="Boolean(true)" class="keyword">true</span> // we can return true here, because a cycle will be detected
               // here afterwards and an error will result anyway.
        <span class="keyword">else</span>
          <span class="keyword">try</span> <span class="delimiter">{</span>
            <a href="#38867" title="=&gt; scala.collection.mutable.HashSet[Types.this.Symbol]">pendingVolatiles</a> <span title="(elem: Types.this.Symbol)Types.this.pendingVolatiles.type">+=</span> <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>
            <a href="#134055" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a>.<a href="#41492" title="=&gt; Boolean">isVolatile</a>
          <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            <a href="#38867" title="=&gt; scala.collection.mutable.HashSet[Types.this.Symbol]">pendingVolatiles</a> <span title="(elem: Types.this.Symbol)Types.this.pendingVolatiles.type">-=</span> <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
        <a href="#38865" title="(x$1: Int)Unit">volatileRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="134053">thisInfo</a>   = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="134082">symInfo</a> = <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#134050" title="=&gt; Types.this.Type">thisInfoCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#134082" title="Types.this.Type">symInfo</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#134047" title="=&gt; Types.this.Type">symInfoCache</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#134047" title="(x$1: Types.this.Type)Unit">symInfoCache</a> = <a href="#134082" title="Types.this.Type">symInfo</a>
        <a href="#134050" title="(x$1: Types.this.Type)Unit">thisInfoCache</a> = <a href="#62123" title="(tp: Types.this.Type)Types.this.Type">transformInfo</a><span class="delimiter">(</span><a href="#134082" title="Types.this.Type">symInfo</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
          // If a subtyping cycle is not detected here, we'll likely enter an infinite
          // loop before a sensible error can be issued.  SI-5093 is one example.
          <span class="keyword">case</span> <a title="Nothing" id="134088">x</a>: <a href="#38815" title="Types.this.SubType">SubType</a> <span class="keyword">if</span> <a href="#134088" title="Types.this.SubType">x</a>.<a href="#62287" title="=&gt; Types.this.Type">supertype</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#38875" title="Types.this.AbstractTypeRef" class="keyword">this</a> =&gt;
            <span title="Nothing" class="keyword">throw</span> <span title="Types.this.RecoverableCyclicReference" class="keyword">new</span> <a href="#147833" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <a title="Types.this.Type" id="134089">tp</a> =&gt; <a href="#134089" title="Types.this.Type">tp</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#134050" title="=&gt; Types.this.Type">thisInfoCache</a>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="134054">isStable</a> = <a href="#134055" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#46650" title="(that: Types.this.Symbol)Boolean">isSubClass</a> <a href="Definitions.scala.html#45085" title="=&gt; Types.this.Symbol">SingletonClass</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="134055">bounds</a>   = <a href="#134053" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>
    // def transformInfo(tp: Type): Type = appliedType(tp.asSeenFrom(pre, sym.owner), typeArgsOrDummies)
    <span class="keyword">override</span> <span class="keyword">protected</span><span class="delimiter">[</span>Types<span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="134056">baseTypeSeqImpl</a>: <a href="BaseTypeSeqs.scala.html#39264" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#62118" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#134055" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>.<a href="#41579" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#59600" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">prepend</a> <a href="#38875" title="Types.this.AbstractTypeRef" class="keyword">this</a>
  <span class="delimiter">}</span>

  /** A class for named types of the form
   *    `&lt;prefix&gt;.&lt;sym.name&gt;[args]`
   *  Cannot be created directly; one should always use `typeRef`
   *  for creation. (@M: Otherwise hashing breaks)
   *
   * @M: a higher-kinded type is represented as a TypeRef with sym.typeParams.nonEmpty, but args.isEmpty
   */
  <span class="keyword">abstract</span> case <span class="keyword">class</span> <a href="#134581" title="class TypeRef extends Types.this.Type with ScalaObject with Product with Serializable" id="62154">TypeRef</a><a href="#62154" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="62171">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="62172">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="62173">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="List[Types.this.Type]" id="62104">parentsCache</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>      = _
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Int" id="62107">parentsPeriod</a>                 = <span title="Int(0)">NoPeriod</span>
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Types.this.BaseTypeSeq" id="62110">baseTypeSeqCache</a>: <a href="BaseTypeSeqs.scala.html#39264" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = _
    <span class="keyword">private</span><span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Int" id="62113">baseTypeSeqPeriod</a>             = <span title="Int(0)">NoPeriod</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="62116">normalized</a>: <a href="#38813" title="Types.this.Type">Type</a>                       = _ 

    // @M: propagate actual type params (args) to `tp`, by replacing
    // formal type parameters with actual ones. If tp is higher kinded,
    // the &quot;actual&quot; type arguments are types that simply reference the
    // corresponding type parameters (unbound type variables)
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="62118">transform</a><span class="delimiter">(</span><a title="Types.this.Type" id="133768">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a>

    // eta-expand, subtyping relies on eta-expansion of higher-kinded types
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="62119">normalizeImpl</a>: <a href="#38813" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#41490" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#62121" title="=&gt; Types.this.Type">etaExpand</a> <span class="keyword">else</span> <a href="#62154" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a>

    // TODO: test case that is compiled in a specific order and in different runs
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="62120">normalize</a>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      // arises when argument-dependent types are approximated (see def depoly in implicits)
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#62171" title="=&gt; Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131644" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span> <a href="#131644" title="object Types.this.WildcardType">WildcardType</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#62119" title="=&gt; Types.this.Type">normalizeImpl</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#62116" title="=&gt; Types.this.Type">normalized</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
          <a href="#62116" title="(x$1: Types.this.Type)Unit">normalized</a> = <a href="#62119" title="=&gt; Types.this.Type">normalizeImpl</a>
        <a href="#62116" title="=&gt; Types.this.Type">normalized</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    
    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="62121">etaExpand</a>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      // must initialise symbol, see test/files/pos/ticket0137.scala
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="134151">tpars</a> = <a href="#62125" title="=&gt; List[Types.this.Symbol]">initializedTypeParams</a>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#134151" title="List[Types.this.Symbol]">tpars</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#62154" title="Types.this.TypeRef" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#38943" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFunAnon</a><span class="delimiter">(</span><a href="#134151" title="List[Types.this.Symbol]">tpars</a>, <a href="#38935" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#62154" title="Types.this.TypeRef" class="keyword">this</a>, <a href="#62171" title="=&gt; Types.this.Type">pre</a>, <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>, <a href="#134151" title="List[Types.this.Symbol]">tpars</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#134171" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46607" title="=&gt; Types.this.Type">tpeHK</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> // todo: also beta-reduce?
    <span class="delimiter">}</span>

    // only need to rebind type aliases, as typeRef already handles abstract types
    // (they are allowed to be rebound more liberally)
    <span class="keyword">def</span> <a title="(pre1: Types.this.Type)Types.this.Symbol" id="62122">coevolveSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="134033">pre1</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>

    //@M! use appliedType on the polytype that represents the bounds (or if aliastype, the rhs)
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="62123">transformInfo</a><span class="delimiter">(</span><a title="Types.this.Type" id="133842">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#38940" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#62127" title="(tp: Types.this.Type)Types.this.Type">asSeenFromOwner</a><span class="delimiter">(</span><a href="#133842" title="Types.this.Type">tp</a><span class="delimiter">)</span>, <a href="#62173" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="62124">thisInfo</a>                  = <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="62125">initializedTypeParams</a>     = <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41528" title="=&gt; List[Types.this.Symbol]">typeParams</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="62126">typeParamsMatchArgs</a>       = <a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#62125" title="=&gt; List[Types.this.Symbol]">initializedTypeParams</a>, <a href="#62173" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="62127">asSeenFromOwner</a><span class="delimiter">(</span><a title="Types.this.Type" id="133779">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#133779" title="Types.this.Type">tp</a>.<a href="#41554" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#62171" title="=&gt; Types.this.Type">pre</a>, <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="62128">baseClasses</a>      = <a href="#62124" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#41581" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="62129">baseTypeSeqDepth</a> = <a href="#62144" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#59605" title="=&gt; Int">maxDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="62130">isStable</a>         = <span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#45085" title="=&gt; Types.this.Symbol">SingletonClass</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="62131">prefix</a>           = <a href="#62171" title="=&gt; Types.this.Type">pre</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="62132">termSymbol</a>       = <a href="#62154" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#41503" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="62133">termSymbolDirect</a> = <a href="#62154" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#41503" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="62134">typeArgs</a>         = <a href="#62173" title="=&gt; List[Types.this.Type]">args</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="62135">typeOfThis</a>       = <a href="#62118" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46666" title="=&gt; Types.this.Type">typeOfThis</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="62136">typeSymbol</a>       = <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="62137">typeSymbolDirect</a> = <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>

    <span class="keyword">override</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="62139">isTrivial</a>: <span title="Boolean">Boolean</span> =
      <span title="=&gt; Boolean">!</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46469" title="=&gt; Boolean">isTypeParameter</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#62171" title="=&gt; Types.this.Type">pre</a>.<a href="#41489" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#62173" title="=&gt; List[Types.this.Type]">args</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#134227" title="Types.this.Type">_</a>.<a href="#41489" title="=&gt; Boolean">isTrivial</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="62140">isNotNull</a> =
      <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46463" title="=&gt; Boolean">isModuleClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="#62172" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="Definitions.scala.html#45476" title="(sym: Types.this.Symbol)Boolean">isValueClass</a><span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#62154" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#41493" title="=&gt; Boolean">isNotNull</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="62141">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="134240">cache</a> = <a href="#62104" title="=&gt; List[Types.this.Type]">parentsCache</a>
      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#62107" title="=&gt; Int">parentsPeriod</a> <span title="(x: Int)Boolean">==</span> <a href="SymbolTable.scala.html#35634" title="=&gt; Types.this.Period">currentPeriod</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#134240" title="List[Types.this.Type]">cache</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#134240" title="List[Types.this.Type]">cache</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#38879" title="(tpe: Types.this.TypeRef)Unit">defineParentsOfTypeRef</a><span class="delimiter">(</span><a href="#62154" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span>
        <a href="#62104" title="=&gt; List[Types.this.Type]">parentsCache</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="62142">decls</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a> = <span class="delimiter">{</span>
      <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="134320">sym1</a>, _<span class="delimiter">)</span> =&gt;
          <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#134320" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>, <a href="#62154" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span> // @MAT was != typeSymbol
        <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
      <span class="delimiter">}</span>
      <a href="#62124" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#41536" title="=&gt; Types.this.Scope">decls</a>
    <span class="delimiter">}</span>
  
    <span class="keyword">protected</span><span class="delimiter">[</span>Types<span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="62143">baseTypeSeqImpl</a>: <a href="BaseTypeSeqs.scala.html#39264" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41579" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#59602" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">map</a> <a href="#62118" title="(tp: Types.this.Type)Types.this.Type">transform</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="62144">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#39264" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="134330">cache</a> = <a href="#62110" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
      <span title="Types.this.BaseTypeSeq" class="keyword">if</span> <span class="delimiter">(</span><a href="#62113" title="=&gt; Int">baseTypeSeqPeriod</a> <span title="(x: Int)Boolean">==</span> <a href="SymbolTable.scala.html#35634" title="=&gt; Types.this.Period">currentPeriod</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#134330" title="Types.this.BaseTypeSeq">cache</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#134330" title="Types.this.BaseTypeSeq">cache</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="BaseTypeSeqs.scala.html#39265" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span> 
        <a href="#134330" title="Types.this.BaseTypeSeq">cache</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#38880" title="(tpe: Types.this.TypeRef)Unit">defineBaseTypeSeqOfTypeRef</a><span class="delimiter">(</span><a href="#62154" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#62110" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="BaseTypeSeqs.scala.html#39265" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <span title="Types.this.RecoverableCyclicReference" class="keyword">new</span> <a href="#147833" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

        <a href="#62110" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; String" id="62145">preString</a> = <span class="delimiter">(</span>
      // ensure that symbol is not a local copy with a name coincidence
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74514" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#39144" title="(elem: String)Boolean">shorthands</a><span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46585" title="=&gt; String">fullName</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46566" title="=&gt; List[Types.this.Symbol]">ownerChain</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#134401" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46445" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <a href="#62171" title="=&gt; Types.this.Type">pre</a>.<a href="#41588" title="=&gt; String">prefixString</a>
    <span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; String" id="62146">argsString</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#62173" title="=&gt; List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="#62173" title="=&gt; List[Types.this.Type]">args</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; String" id="62147">refinementString</a> = <span class="delimiter">(</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46554" title="=&gt; Boolean">isStructuralRefinement</a><span class="delimiter">)</span> <span class="delimiter">(</span>
        <a href="#62142" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#60516" title="(p: Types.this.Symbol =&gt; Boolean)Types.this.Scope">filter</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="134416">sym</a> =&gt; <a href="#134416" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46556" title="=&gt; Boolean">isPossibleInRefinement</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#134416" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#46792" title="=&gt; Boolean">isPublic</a><span class="delimiter">)</span>
          <span title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[Types.this.Symbol],String,Iterable[String]])Iterable[String]">map</span> <span class="delimiter">(</span><a href="#134436" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46757" title="=&gt; String">defString</a><span class="delimiter">)</span>
          <span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;{&quot;)" class="string">&quot;{&quot;</span>, <span title="String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="String(&quot;}&quot;)" class="string">&quot;}&quot;</span><span class="delimiter">)</span>
      <span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(rest: String)String" id="62148">finishPrefix</a><span class="delimiter">(</span><a title="String" id="134481">rest</a>: <span title="String">String</span><span class="delimiter">)</span> = <span class="delimiter">(</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#41586" title="=&gt; String">packagePrefix</a> <span title="(x$1: Any)String">+</span> <a href="#134481" title="String">rest</a>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46463" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <a href="#41585" title="=&gt; String">objectPrefix</a> <span title="(x$1: Any)String">+</span> <a href="#134481" title="String">rest</a>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46560" title="=&gt; Boolean">isInitialized</a><span class="delimiter">)</span> <a href="#134481" title="String">rest</a>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46503" title="=&gt; Boolean">isAnonymousClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
        <a href="#62124" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#41513" title="=&gt; List[Types.this.Type]">parents</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="String(&quot; with &quot;)" class="string">&quot; with &quot;</span>, <a href="#62147" title="=&gt; String">refinementString</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46467" title="=&gt; Boolean">isRefinementClass</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#62124" title="=&gt; Types.this.Type">thisInfo</a>
      <span class="keyword">else</span> <a href="#134481" title="String">rest</a>
    <span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; String" id="62149">customToString</a> = <a href="#62154" title="Types.this.TypeRef" class="keyword">this</a> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="String">TypeRef</span><span class="delimiter">(</span>_, <a href="Definitions.scala.html#45105" title="=&gt; Types.this.Symbol">RepeatedParamClass</a>, <a title="Types.this.Type" id="134495">arg</a> :: _<span class="delimiter">)</span> =&gt; <a href="#134495" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">arg</a> <span title="(other: String)String">+</span> <span title="String(&quot;*&quot;)" class="string">&quot;*&quot;</span>
      <span class="keyword">case</span> <span title="String">TypeRef</span><span class="delimiter">(</span>_, <a href="Definitions.scala.html#45099" title="=&gt; Types.this.Symbol">ByNameParamClass</a>, <a title="Types.this.Type" id="134502">arg</a> :: _<span class="delimiter">)</span>   =&gt; <span title="String(&quot;=&gt; &quot;)" class="string">&quot;=&gt; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#134502" title="Types.this.Type">arg</a>
      <span class="keyword">case</span> <span title="String">_</span> =&gt;
        <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#45264" title="(tp: Types.this.Type)Boolean">isFunctionType</a><span class="delimiter">(</span><a href="#62154" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="134504">targs</a> = <a href="#62120" title="=&gt; Types.this.Type">normalize</a>.<a href="#41517" title="=&gt; List[Types.this.Type]">typeArgs</a>
          // Aesthetics: printing Function1 as T =&gt; R rather than (T) =&gt; R
          // ...but only if it's not a tuple, so ((T1, T2)) =&gt; R is distinguishable
          // from (T1, T2) =&gt; R.
          <a href="#134504" title="List[Types.this.Type]">targs</a> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a title="String" id="134509">in</a> :: <a title="Types.this.Type" id="134517">out</a> :: <span title="object Nil">Nil</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="Definitions.scala.html#45245" title="(tp: Types.this.Type)Boolean">isTupleTypeOrSubtype</a><span class="delimiter">(</span><a href="#134509" title="Types.this.Type">in</a><span class="delimiter">)</span> =&gt;
              // A =&gt; B =&gt; C should be (A =&gt; B) =&gt; C or A =&gt; (B =&gt; C)
              <span class="keyword">val</span> <a title="String" id="134519">in_s</a>  = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#45264" title="(tp: Types.this.Type)Boolean">isFunctionType</a><span class="delimiter">(</span><a href="#134509" title="Types.this.Type">in</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#134509" title="Types.this.Type">in</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#134509" title="Types.this.Type">in</a>
              <span class="keyword">val</span> <a title="String" id="134520">out_s</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#45264" title="(tp: Types.this.Type)Boolean">isFunctionType</a><span class="delimiter">(</span><a href="#134517" title="Types.this.Type">out</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#134517" title="Types.this.Type">out</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#134517" title="Types.this.Type">out</a>
              <a href="#134519" title="String">in_s</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; =&gt; &quot;)" class="string">&quot; =&gt; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#134520" title="String">out_s</a>
            <span class="keyword">case</span> <a title="String" id="134521">xs</a> =&gt;
              <a href="#134521" title="List[Types.this.Type]">xs</a>.<span title="=&gt; List[Types.this.Type]">init</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; =&gt; &quot;)" class="string">&quot; =&gt; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#134521" title="List[Types.this.Type]">xs</a>.<span title="=&gt; Types.this.Type">last</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Definitions.scala.html#45245" title="(tp: Types.this.Type)Boolean">isTupleTypeOrSubtype</a><span class="delimiter">(</span><a href="#62154" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#62120" title="=&gt; Types.this.Type">normalize</a>.<a href="#41517" title="=&gt; List[Types.this.Type]">typeArgs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#39053" title="(xs: List[_], len: Int)Boolean">hasLength</a><span class="delimiter">(</span><a href="#62120" title="=&gt; Types.this.Type">normalize</a>.<a href="#41517" title="=&gt; List[Types.this.Type]">typeArgs</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;,)&quot;)" class="string">&quot;,)&quot;</span> <span class="keyword">else</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46447" title="=&gt; Boolean">isAliasType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#41515" title="=&gt; List[Types.this.Type]">prefixChain</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#134548" title="Types.this.Type">_</a>.<a href="#41503" title="=&gt; Types.this.Symbol">termSymbol</a>.<a href="HasFlags.scala.html#46784" title="=&gt; Boolean">isSynthetic</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#62120" title="=&gt; Types.this.Type">normalize</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#62154" title="Types.this.TypeRef" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#62120" title="=&gt; Types.this.Type">normalize</a>
        <span class="keyword">else</span>
          <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="62150">safeToString</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="134552">custom</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74514" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="#62149" title="=&gt; String">customToString</a>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#134552" title="String">custom</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span> <a href="#134552" title="String">custom</a>
      <span class="keyword">else</span> <a href="#62148" title="(rest: String)String">finishPrefix</a><span class="delimiter">(</span><a href="#62145" title="=&gt; String">preString</a> <span title="(x$1: Any)String">+</span> <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46739" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <a href="#62146" title="=&gt; String">argsString</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="62151">prefixString</a> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span>
      <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74514" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a><span class="delimiter">)</span>
        <a href="#62154" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#41588" title="=&gt; String">prefixString</a>
      <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46516" title="=&gt; Boolean">isOmittablePrefix</a><span class="delimiter">)</span>
        <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46506" title="=&gt; Boolean">isPackageObjectOrClass</a><span class="delimiter">)</span>
        <a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46514" title="=&gt; Types.this.Symbol">skipPackageObject</a>.<a href="Symbols.scala.html#46585" title="=&gt; String">fullName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#62130" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="StdNames.scala.html#39313" title="object Types.this.nme">nme</a>.<a href="NameManglers.scala.html#59424" title="(name: Types.this.Name)Boolean">isSingletonName</a><span class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="StdNames.scala.html#39313" title="object Types.this.nme">nme</a>.<a href="NameManglers.scala.html#59441" title="(name: Types.this.Name)Types.this.TypeName">dropSingletonName</a><span title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd" class="delimiter">(</span><a href="#62172" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span> <span title="(other: String)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      <span class="keyword">else</span>
        <a href="#62154" title="Types.this.TypeRef" class="keyword">super</a>.<a href="#41588" title="=&gt; String">prefixString</a>
    <span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="62152">kind</a> = <span title="String(&quot;TypeRef&quot;)" class="string">&quot;TypeRef&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.TypeRef" id="134758">TypeRef</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#7741" title="Types.this.TypeRefExtractor">TypeRefExtractor</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="62092">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="83096">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="83097">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="83098">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#38967" title="(tp: Types.this.Type)Types.this.Type">unique</a><span class="delimiter">(</span><span class="delimiter">{</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83098" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83097" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46447" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span>              <a href="#134613" title="Types.this.ArgsTypeRef with Types.this.AliasTypeRef" class="keyword">new</a> <a href="#38869" title="anonymous class $anon extends Types.this.ArgsTypeRef with Types.this.AliasTypeRef" id="134613">ArgsTypeRef</a><span class="delimiter">(</span><a href="#83096" title="Types.this.Type">pre</a>, <a href="#83097" title="Types.this.Symbol">sym</a>, <a href="#83098" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#38874" title="Types.this.AliasTypeRef">AliasTypeRef</a>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83097" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46448" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span>      <a href="#134637" title="Types.this.ArgsTypeRef with Types.this.AbstractTypeRef" class="keyword">new</a> <a href="#38869" title="anonymous class $anon extends Types.this.ArgsTypeRef with Types.this.AbstractTypeRef" id="134637">ArgsTypeRef</a><span class="delimiter">(</span><a href="#83096" title="Types.this.Type">pre</a>, <a href="#83097" title="Types.this.Symbol">sym</a>, <a href="#83098" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#38875" title="Types.this.AbstractTypeRef">AbstractTypeRef</a>
        <span class="keyword">else</span>                              <a href="#134661" title="Types.this.ArgsTypeRef with Types.this.ClassTypeRef" class="keyword">new</a> <a href="#38869" title="anonymous class $anon extends Types.this.ArgsTypeRef with Types.this.ClassTypeRef" id="134661">ArgsTypeRef</a><span class="delimiter">(</span><a href="#83096" title="Types.this.Type">pre</a>, <a href="#83097" title="Types.this.Symbol">sym</a>, <a href="#83098" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#38871" title="Types.this.ClassTypeRef">ClassTypeRef</a>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83097" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46447" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span>              <a href="#134685" title="Types.this.NoArgsTypeRef with Types.this.AliasTypeRef" class="keyword">new</a> <a href="#38870" title="anonymous class $anon extends Types.this.NoArgsTypeRef with Types.this.AliasTypeRef" id="134685">NoArgsTypeRef</a><span class="delimiter">(</span><a href="#83096" title="Types.this.Type">pre</a>, <a href="#83097" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#38874" title="Types.this.AliasTypeRef">AliasTypeRef</a>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83097" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46448" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span>      <a href="#134709" title="Types.this.NoArgsTypeRef with Types.this.AbstractTypeRef" class="keyword">new</a> <a href="#38870" title="anonymous class $anon extends Types.this.NoArgsTypeRef with Types.this.AbstractTypeRef" id="134709">NoArgsTypeRef</a><span class="delimiter">(</span><a href="#83096" title="Types.this.Type">pre</a>, <a href="#83097" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#38875" title="Types.this.AbstractTypeRef">AbstractTypeRef</a>
        <span class="keyword">else</span>                              <a href="#134733" title="Types.this.NoArgsTypeRef with Types.this.ClassTypeRef" class="keyword">new</a> <a href="#38870" title="anonymous class $anon extends Types.this.NoArgsTypeRef with Types.this.ClassTypeRef" id="134733">NoArgsTypeRef</a><span class="delimiter">(</span><a href="#83096" title="Types.this.Type">pre</a>, <a href="#83097" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">with</span> <a href="#38871" title="Types.this.ClassTypeRef">ClassTypeRef</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tpe: Types.this.TypeRef)Unit" id="38879">defineParentsOfTypeRef</a><span class="delimiter">(</span><a title="Types.this.TypeRef" id="134250">tpe</a>: <a href="#62154" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Int" id="134253">period</a> = <a href="#134250" title="Types.this.TypeRef">tpe</a>.<a href="#62107" title="=&gt; Int">parentsPeriod</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#134253" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#35634" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#134250" title="Types.this.TypeRef">tpe</a>.<a href="#62107" title="(x$1: Int)Unit">parentsPeriod</a> = <a href="SymbolTable.scala.html#35634" title="=&gt; Types.this.Period">currentPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#35650" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#134253" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#134250" title="Types.this.TypeRef">tpe</a>.<a href="#62104" title="(x$1: List[Types.this.Type])Unit">parentsCache</a> = <a href="#134250" title="Types.this.TypeRef">tpe</a>.<a href="#62124" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#41513" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#134250" title="Types.this.TypeRef">tpe</a>.<a href="#62118" title="(tp: Types.this.Type)Types.this.Type">transform</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#134250" title="Types.this.TypeRef">tpe</a>.<a href="#62104" title="=&gt; List[Types.this.Type]">parentsCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span> // seems this can happen if things are corrupted enough, see #2641
        <a href="#134250" title="Types.this.TypeRef">tpe</a>.<a href="#62104" title="(x$1: List[Types.this.Type])Unit">parentsCache</a> = <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tpe: Types.this.TypeRef)Unit" id="38880">defineBaseTypeSeqOfTypeRef</a><span class="delimiter">(</span><a title="Types.this.TypeRef" id="134344">tpe</a>: <a href="#62154" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Int" id="134347">period</a> = <a href="#134344" title="Types.this.TypeRef">tpe</a>.<a href="#62113" title="=&gt; Int">baseTypeSeqPeriod</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#134347" title="Int">period</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#35634" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#134344" title="Types.this.TypeRef">tpe</a>.<a href="#62113" title="(x$1: Int)Unit">baseTypeSeqPeriod</a> = <a href="SymbolTable.scala.html#35634" title="=&gt; Types.this.Period">currentPeriod</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#35650" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#134347" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="util/StatBase.scala.html#38639" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38661" title="=&gt; scala.reflect.internal.util.Statistics.Counter">typerefBaseTypeSeqCount</a><span class="delimiter">)</span>
        <a href="#134344" title="Types.this.TypeRef">tpe</a>.<a href="#62110" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="BaseTypeSeqs.scala.html#39265" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a>
        <a href="#134344" title="Types.this.TypeRef">tpe</a>.<a href="#62110" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="#134344" title="Types.this.TypeRef">tpe</a>.<a href="#62143" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqImpl</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#134344" title="Types.this.TypeRef">tpe</a>.<a href="#62110" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="BaseTypeSeqs.scala.html#39265" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <a href="#62866" title="(msg: String)Types.this.TypeError" class="keyword">new</a> <a href="#39126" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic inheritance involving &quot;)" class="string">&quot;illegal cyclic inheritance involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#134344" title="Types.this.TypeRef">tpe</a>.<a href="#62172" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** A class representing a method type with parameters.
   *  Note that a parameterless method is represented by a NullaryMethodType:
   *
   *    def m(): Int        MethodType(Nil, Int)
   *    def m: Int          NullaryMethodType(Int)
   */
  case <span class="keyword">class</span> <a title="class MethodType extends Types.this.Type with ScalaObject with Product with Serializable" id="62346">MethodType</a><a href="#62346" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="70167">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
                        <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="70168">resultType</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="62354">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#62355" title="=&gt; Boolean">isTrivial0</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#70168" title="=&gt; Types.this.Type">resultType</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#70168" title="=&gt; Types.this.Type">resultType</a>.<a href="#41598" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="62356">isTrivial0</a> =
      <a href="#70168" title="=&gt; Types.this.Type">resultType</a>.<a href="#41489" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span><span class="delimiter">{</span><a title="Types.this.Symbol" id="134781">p</a> =&gt; <a href="#134781" title="Types.this.Symbol">p</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>.<a href="#41489" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>  <span class="delimiter">(</span>
        /*!settings.YdepMethTpes.value ||*/ <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#134788" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>.<a href="#41569" title="(sym: Types.this.Symbol)Boolean">contains</a><span class="delimiter">(</span><a href="#134781" title="Types.this.Symbol">p</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#70168" title="=&gt; Types.this.Type">resultType</a>.<a href="#41569" title="(sym: Types.this.Symbol)Boolean">contains</a><span class="delimiter">(</span><a href="#134781" title="Types.this.Symbol">p</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="=&gt; Boolean" id="62357">isImplicit</a> = <a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="HasFlags.scala.html#46778" title="=&gt; Boolean">isImplicit</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="62358">isJava</a> = <span title="Boolean(false)" class="keyword">false</span> // can we do something like for implicits? I.e. do Java methods without parameters need to be recognized?

    //assert(paramTypes forall (pt =&gt; !pt.typeSymbol.isImplClass))//DEBUG
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="62359">paramSectionCount</a>: <span title="Int">Int</span> = <a href="#70168" title="=&gt; Types.this.Type">resultType</a>.<a href="#41524" title="=&gt; Int">paramSectionCount</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="62360">paramss</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a> <a href="#134815" title="(x: List[Types.this.Symbol])List[List[Types.this.Symbol]]">::</a> <a href="#70168" title="=&gt; Types.this.Type">resultType</a>.<a href="#41525" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="62361">paramTypes</a> = <a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#75721" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="62362">boundSyms</a> = <a href="#70168" title="=&gt; Types.this.Type">resultType</a>.<a href="#41529" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a> <span title="(elems: scala.collection.GenTraversableOnce[Types.this.Symbol])scala.collection.immutable.Set[Types.this.Symbol]">++</span> <a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(actuals: List[Types.this.Type])Types.this.Type" id="62363">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="75430">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#62354" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">||</span> <a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#70168" title="=&gt; Types.this.Type">resultType</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#75430" title="List[Types.this.Type]">actuals</a>, <a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.InstantiateDependentMap" id="75467">idm</a> = <span title="Types.this.InstantiateDependentMap" class="keyword">new</span> <a href="#39006" title="Types.this.InstantiateDependentMap">InstantiateDependentMap</a><span class="delimiter">(</span><a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#75430" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="75468">res</a> = <a href="#75478" title="(tp: Types.this.Type)Types.this.Type">idm</a><span class="delimiter">(</span><a href="#70168" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
        <a href="#38945" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#75467" title="Types.this.InstantiateDependentMap">idm</a>.<a href="#75479" title="=&gt; List[Types.this.Symbol]">existentialsNeeded</a>, <a href="#75468" title="Types.this.Type">res</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#38945" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#70168" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>

    // implicit args can only be depended on in result type: TODO this may be generalised so that the only constraint is dependencies are acyclic
    <span class="keyword">def</span> <a title="=&gt; Types.this.MethodType" id="62364">approximate</a>: <a href="#62346" title="Types.this.MethodType">MethodType</a> = <a href="#62346" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#41521" title="=&gt; Types.this.Type">resultApprox</a><span class="delimiter">)</span> // if (!settings.YdepMethTpes.value) this else

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="62365">finalResultType</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#70168" title="=&gt; Types.this.Type">resultType</a>.<a href="#41523" title="=&gt; Types.this.Type">finalResultType</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="62366">safeToString</a> = <a href="TypeDebugging.scala.html#39431" title="(tp: Types.this.Type)String">paramString</a><span class="delimiter">(</span><a href="#62346" title="Types.this.MethodType" class="keyword">this</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#70168" title="=&gt; Types.this.Type">resultType</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="62367">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="75545">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="75551">vparams</a> = <a href="Symbols.scala.html#38746" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)List[Types.this.Symbol]">cloneSymbolsAtOwner</a><span class="delimiter">(</span><a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#75545" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#38937" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#62346" title="Types.this.MethodType" class="keyword">this</a>, <a href="#75551" title="List[Types.this.Symbol]">vparams</a>, <a href="#70168" title="=&gt; Types.this.Type">resultType</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#75551" title="List[Types.this.Symbol]">vparams</a><span class="delimiter">)</span>.<a href="#41583" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#75545" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="62368">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="75519">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#75531" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#75519" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#70168" title="=&gt; Types.this.Type">resultType</a>.<a href="#41584" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#75519" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#70168" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#62367" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#75519" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <a href="#62346" title="Types.this.MethodType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="62369">kind</a> = <span title="String(&quot;MethodType&quot;)" class="string">&quot;MethodType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.MethodType" id="134875">MethodType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#7741" title="Types.this.MethodTypeExtractor">MethodTypeExtractor</a>

  <span class="keyword">class</span> <a title="class JavaMethodType extends Types.this.MethodType with ScalaObject" id="38884">JavaMethodType</a><a href="#38884" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="134885">ps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="134886">rt</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#62346" title="Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#134885" title="List[Types.this.Symbol]">ps</a>, <a href="#134886" title="Types.this.Type">rt</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="134881">isJava</a> = <span title="Boolean(true)" class="keyword">true</span>
  <span class="delimiter">}</span>

  case <span class="keyword">class</span> <a title="class NullaryMethodType extends Types.this.Type with ScalaObject with Product with Serializable" id="62410">NullaryMethodType</a><a href="#62410" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="71585">resultType</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="62415">isTrivial</a> = <a href="#71585" title="=&gt; Types.this.Type">resultType</a>.<a href="#41489" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#71585" title="=&gt; Types.this.Type">resultType</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#71585" title="=&gt; Types.this.Type">resultType</a>.<a href="#41598" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="62416">prefix</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#71585" title="=&gt; Types.this.Type">resultType</a>.<a href="#41514" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="62417">narrow</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#71585" title="=&gt; Types.this.Type">resultType</a>.<a href="#41511" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="62418">finalResultType</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#71585" title="=&gt; Types.this.Type">resultType</a>.<a href="#41523" title="=&gt; Types.this.Type">finalResultType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="62419">termSymbol</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="#71585" title="=&gt; Types.this.Type">resultType</a>.<a href="#41503" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="62420">typeSymbol</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="#71585" title="=&gt; Types.this.Type">resultType</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="62421">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#71585" title="=&gt; Types.this.Type">resultType</a>.<a href="#41513" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="62422">decls</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a> = <a href="#71585" title="=&gt; Types.this.Type">resultType</a>.<a href="#41536" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="62423">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#39264" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#71585" title="=&gt; Types.this.Type">resultType</a>.<a href="#41579" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="62424">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#71585" title="=&gt; Types.this.Type">resultType</a>.<a href="#41580" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="62425">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#71585" title="=&gt; Types.this.Type">resultType</a>.<a href="#41581" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="62426">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="134969">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#71585" title="=&gt; Types.this.Type">resultType</a>.<a href="#41553" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#134969" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="62427">boundSyms</a> = <a href="#71585" title="=&gt; Types.this.Type">resultType</a>.<a href="#41529" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="62428">isVolatile</a> = <a href="#71585" title="=&gt; Types.this.Type">resultType</a>.<a href="#41492" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="62429">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;=&gt; &quot;)" class="string">&quot;=&gt; &quot;</span><span title="(x$1: Any)String">+</span> <a href="#71585" title="=&gt; Types.this.Type">resultType</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="62430">kind</a> = <span title="String(&quot;NullaryMethodType&quot;)" class="string">&quot;NullaryMethodType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.NullaryMethodType" id="135031">NullaryMethodType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#7741" title="Types.this.NullaryMethodTypeExtractor">NullaryMethodTypeExtractor</a>

  /** A type function or the type of a polymorphic value (and thus of kind *).
   *
   * Before the introduction of NullaryMethodType, a polymorphic nullary method (e.g, def isInstanceOf[T]: Boolean)
   * used to be typed as PolyType(tps, restpe), and a monomorphic one as PolyType(Nil, restpe)
   * This is now: PolyType(tps, NullaryMethodType(restpe)) and NullaryMethodType(restpe)
   * by symmetry to MethodTypes: PolyType(tps, MethodType(params, restpe)) and MethodType(params, restpe)
   *
   * Thus, a PolyType(tps, TypeRef(...)) unambiguously indicates a type function (which results from eta-expanding a type constructor alias).
   * Similarly, PolyType(tps, ClassInfoType(...)) is a type constructor.
   *
   * A polytype is of kind * iff its resultType is a (nullary) method type.
   */
  case <span class="keyword">class</span> <a title="class PolyType extends Types.this.Type with ScalaObject with Product with Serializable" id="62451">PolyType</a><a href="#62451" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="83318">typeParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="83319">resultType</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>
       <span class="keyword">extends</span> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    //assert(!(typeParams contains NoSymbol), this)
    <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#83318" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="=&gt; Boolean">nonEmpty</span>, <a href="#62451" title="Types.this.PolyType" class="keyword">this</a><span class="delimiter">)</span> // used to be a marker for nullary method type, illegal now (see @NullaryMethodType)

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="62459">paramSectionCount</a>: <span title="Int">Int</span> = <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41524" title="=&gt; Int">paramSectionCount</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[List[Types.this.Symbol]]" id="62460">paramss</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41525" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="62461">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41526" title="=&gt; List[Types.this.Symbol]">params</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="62462">paramTypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41527" title="=&gt; List[Types.this.Type]">paramTypes</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="62463">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41513" title="=&gt; List[Types.this.Type]">parents</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Scope" id="62464">decls</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a> = <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41536" title="=&gt; Types.this.Scope">decls</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="62465">termSymbol</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41503" title="=&gt; Types.this.Symbol">termSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="62466">typeSymbol</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="62467">boundSyms</a> = immutable.<span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#83318" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(that: scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">++</span> <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41529" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>: _*<span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="62468">prefix</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41514" title="=&gt; Types.this.Type">prefix</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="62469">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#39264" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41579" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="62470">baseTypeSeqDepth</a>: <span title="Int">Int</span> = <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41580" title="=&gt; Int">baseTypeSeqDepth</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="62471">baseClasses</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41581" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="62472">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="135170">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41553" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#135170" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="62473">narrow</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41511" title="=&gt; Types.this.Type">narrow</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="62474">isVolatile</a> = <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41492" title="=&gt; Boolean">isVolatile</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="62475">finalResultType</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41523" title="=&gt; Types.this.Type">finalResultType</a>

    /** @M: typeDefSig wraps a TypeBounds in a PolyType
     *  to represent a higher-kinded type parameter
     *  wrap lo&amp;hi in polytypes to bind variables
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="62476">bounds</a>: <a href="#62311" title="Types.this.TypeBounds">TypeBounds</a> =
      <a href="#62285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#38944" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#83318" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62325" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>,
                 <a href="#38944" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#83318" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="62477">isHigherKinded</a> = <span title="=&gt; Boolean">!</span><a href="#83318" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">isEmpty</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="62478">safeToString</a> = <a href="TypeDebugging.scala.html#39432" title="(tp: Types.this.Type)String">typeParamsString</a><span class="delimiter">(</span><a href="#62451" title="Types.this.PolyType" class="keyword">this</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#83319" title="=&gt; Types.this.Type">resultType</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.PolyType" id="62479">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="135220">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="135223">tparams</a> = <a href="Symbols.scala.html#38746" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)List[Types.this.Symbol]">cloneSymbolsAtOwner</a><span class="delimiter">(</span><a href="#83318" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#135220" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#62451" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#135223" title="List[Types.this.Symbol]">tparams</a>, <a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#83318" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#135223" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>.<a href="#41583" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#135220" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="62480">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="135232">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#83318" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#135241" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#135232" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#83319" title="=&gt; Types.this.Type">resultType</a>.<a href="#41584" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#135232" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#83319" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#62479" title="(owner: Types.this.Symbol)Types.this.PolyType">cloneInfo</a><span class="delimiter">(</span><a href="#135232" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <a href="#62451" title="Types.this.PolyType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="62481">kind</a> = <span title="String(&quot;PolyType&quot;)" class="string">&quot;PolyType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.PolyType" id="135300">PolyType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#7741" title="Types.this.PolyTypeExtractor">PolyTypeExtractor</a>
  
  /** A creator for existential types which flattens nested existentials.
   */
  <span class="keyword">def</span> <a title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type" id="38891">newExistentialType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="73648">quantified</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="73649">underlying</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#73648" title="List[Types.this.Symbol]">quantified</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#73649" title="Types.this.Type">underlying</a>
    <span class="keyword">else</span> <a href="#73649" title="Types.this.Type">underlying</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="135301">qs</a>, <a title="Types.this.Type" id="135302">restpe</a><span class="delimiter">)</span> =&gt; <a href="#38891" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">(</span><a href="#73648" title="List[Types.this.Symbol]">quantified</a> <a href="#135303" title="(prefix: List[Types.this.Symbol])List[Types.this.Symbol]">:::</a> <a href="#135301" title="List[Types.this.Symbol]">qs</a>, <a href="#135302" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.ExistentialType">_</span>                           =&gt; <a href="#62567" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">ExistentialType</a><span class="delimiter">(</span><a href="#73648" title="List[Types.this.Symbol]">quantified</a>, <a href="#73649" title="Types.this.Type">underlying</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  case <span class="keyword">class</span> <a title="class ExistentialType extends Types.this.Type with Types.this.RewrappingTypeProxy with ScalaObject with Product with Serializable" id="62567">ExistentialType</a><a href="#62567" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="135311">quantified</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
                             <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="135312">underlying</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38809" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a>
  <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(newtp: Types.this.Type)Types.this.Type" id="62575">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="135321">newtp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#38945" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#135311" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#135321" title="Types.this.Type">newtp</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="62576">isTrivial</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="62577">isStable</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="62578">bounds</a> = <a href="#62285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#135312" title="=&gt; Types.this.Type">underlying</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62325" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#135312" title="=&gt; Types.this.Type">underlying</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="62579">parents</a> = <a href="#135312" title="=&gt; Types.this.Type">underlying</a>.<a href="#41513" title="=&gt; List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="62580">boundSyms</a> = <a href="#135311" title="=&gt; List[Types.this.Symbol]">quantified</a>.<span title="scala.collection.immutable.Set[Types.this.Symbol]">toSet</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="62581">prefix</a> = <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#135312" title="=&gt; Types.this.Type">underlying</a>.<a href="#41514" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="62582">typeArgs</a> = <a href="#135312" title="=&gt; Types.this.Type">underlying</a>.<a href="#41517" title="=&gt; List[Types.this.Type]">typeArgs</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="62583">params</a> = <a href="#135312" title="=&gt; Types.this.Type">underlying</a>.<a href="#41526" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Symbol)List[Types.this.Symbol]">mapConserve</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="135454">param</a> =&gt;
      <span class="keyword">val</span> <a title="Types.this.Type" id="135455">tpe1</a> = <a href="#62575" title="(newtp: Types.this.Type)Types.this.Type">rewrap</a><span class="delimiter">(</span><a href="#135454" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#135455" title="Types.this.Type">tpe1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#135454" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span> <a href="#135454" title="Types.this.Symbol">param</a> <span class="keyword">else</span> <a href="#135454" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#46656" title="=&gt; Types.this.Symbol">cloneSymbol</a>.<a href="Symbols.scala.html#46610" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a><span class="delimiter">(</span><a href="#135455" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="62584">paramTypes</a> = <a href="#135312" title="=&gt; Types.this.Type">underlying</a>.<a href="#41527" title="=&gt; List[Types.this.Type]">paramTypes</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="62585">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="135518">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="135519">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
//      maybeRewrap(underlying.instantiateTypeParams(formals, actuals))

      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="135522">quantified1</a> = <span title="Types.this.SubstTypeMap" class="keyword">new</span> <a href="#38998" title="Types.this.SubstTypeMap">SubstTypeMap</a><span class="delimiter">(</span><a href="#135518" title="List[Types.this.Symbol]">formals</a>, <a href="#135519" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span> <a href="#74776" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a> <a href="#135311" title="=&gt; List[Types.this.Symbol]">quantified</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="135523">underlying1</a> = <a href="#135312" title="=&gt; Types.this.Type">underlying</a>.<a href="#41531" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#135518" title="List[Types.this.Symbol]">formals</a>, <a href="#135519" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#135522" title="List[Types.this.Symbol]">quantified1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#135311" title="=&gt; List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#135523" title="Types.this.Type">underlying1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#135312" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#62567" title="Types.this.ExistentialType" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#38945" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#135522" title="List[Types.this.Symbol]">quantified1</a>, <a href="#135523" title="Types.this.Type">underlying1</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#135311" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#135522" title="List[Types.this.Symbol]">quantified1</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)Types.this.Type" id="62586">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="135533">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#135312" title="=&gt; Types.this.Type">underlying</a>.<a href="#41553" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#135533" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="62587">baseTypeSeq</a> = <a href="#135312" title="=&gt; Types.this.Type">underlying</a>.<a href="#41579" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#59602" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">map</a> <a href="#58254" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="62588">isHigherKinded</a> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="62589">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="135547">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="135548">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span> =
      <a href="Symbols.scala.html#38743" title="(syms: List[Types.this.Symbol], symFn: Types.this.Symbol =&gt; Types.this.Symbol)(tpe: Types.this.Type)Types.this.Type">deriveType</a><span class="delimiter">(</span><a href="#135311" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a title="Types.this.Symbol" id="135554">tparam</a> =&gt; <span class="delimiter">(</span><a href="#135547" title="Types.this.Symbol">owner</a> <a href="Symbols.scala.html#46723" title="(alt: =&gt; Types.this.Symbol)Types.this.Symbol">orElse</a> <a href="#135554" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#46416" title="(basis: Types.this.Symbol, origin: AnyRef)Types.this.TypeSkolem">newExistentialSkolem</a><span class="delimiter">(</span><a href="#135554" title="Types.this.Symbol">tparam</a>, <a href="#135548" title="AnyRef">origin</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#135312" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(available: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]" id="62590">wildcardArgsString</a><span class="delimiter">(</span><a title="Set[Types.this.Symbol]" id="135559">available</a>: <span title="Set[Types.this.Symbol]">Set</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="135560">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[String]">List</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="#135560" title="List[Types.this.Type]">args</a> <span title="List[String]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="List[String]">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="135566">sym</a>, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="135567">args1</a> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#135559" title="Set[Types.this.Symbol]">available</a> <span title="(elem: Types.this.Symbol)Boolean">contains</span> <a href="#135566" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> =&gt;
        <span class="delimiter">(</span><span title="String(&quot;_&quot;)" class="string">&quot;_&quot;</span><span title="(x$1: Any)String">+</span><a href="#135566" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46747" title="(tp: Types.this.Type)String">infoString</a><span class="delimiter">(</span><a href="#135566" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#135570" title="(x: String)List[String]">::</a> <a href="#62590" title="(available: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]">wildcardArgsString</a><span class="delimiter">(</span><a href="#135559" title="Set[Types.this.Symbol]">available</a> <span title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">-</span> <a href="#135566" title="Types.this.Symbol">sym</a>, <a href="#135567" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="List[String]" id="135589">arg</a> :: <a title="List[Types.this.Type]" id="135590">args1</a> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#135311" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#135589" title="Types.this.Type">arg</a> <a href="#41569" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#135597" title="Types.this.Symbol">_</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <a href="#135589" title="Types.this.Type">arg</a>.<a href="#41589" title="()String">toString</a> <a href="#135599" title="(x: String)List[String]">::</a> <a href="#62590" title="(available: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]">wildcardArgsString</a><span class="delimiter">(</span><a href="#135559" title="Set[Types.this.Symbol]">available</a>, <a href="#135590" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="List[Nothing]">_</span> =&gt;
        List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    /** An existential can only be printed with wildcards if:
     *   - the underlying type is a typeref
     *   - where there is a 1-to-1 correspondence between underlying's typeargs and quantified
     *   - and none of the existential parameters is referenced from anywhere else in the type 
     *   - and none of the existential parameters are singleton types
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="62591">isRepresentableWithWildcards</a> = <span title="=&gt; Boolean">!</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74514" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="135616">qset</a> = <a href="#135311" title="=&gt; List[Types.this.Symbol]">quantified</a>.<span title="scala.collection.immutable.Set[Types.this.Symbol]">toSet</span>
      <span title="=&gt; Boolean">!</span><a href="#135616" title="scala.collection.immutable.Set[Types.this.Symbol]">qset</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#135627" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46760" title="=&gt; Boolean">isSingletonExistential</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#135312" title="=&gt; Types.this.Type">underlying</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="135628">sym</a>, <a title="List[Types.this.Type]" id="135629">args</a><span class="delimiter">)</span> =&gt;
          <a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#135629" title="List[Types.this.Type]">args</a>, <a href="#135311" title="=&gt; List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
            <a href="#135629" title="List[Types.this.Type]">args</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">{</span> <a title="Types.this.Type" id="135638">arg</a> =&gt;
              <a href="#135616" title="(elem: Types.this.Symbol)Boolean">qset</a><span class="delimiter">(</span><a href="#135638" title="Types.this.Type">arg</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#135616" title="scala.collection.immutable.Set[Types.this.Symbol]">qset</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#135638" title="Types.this.Type">arg</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a> <a href="#41569" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#135651" title="Types.this.Symbol">_</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="62592">safeToString</a>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="=&gt; String" id="135656">clauses</a> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="String" id="135657">str</a> = <a href="#135311" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],String,List[String]])List[String]">map</span> <span class="delimiter">(</span><a href="#135674" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46761" title="=&gt; String">existentialToString</a><span class="delimiter">)</span> <span title="(start: String, sep: String, end: String)String">mkString</span> <span class="delimiter">(</span><span title="String(&quot; forSome { &quot;)" class="string">&quot; forSome { &quot;</span>, <span title="String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="String(&quot; }&quot;)" class="string">&quot; }&quot;</span><span class="delimiter">)</span>
        <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74516" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">explaintypes</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#135657" title="String">str</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <span class="keyword">else</span> <a href="#135657" title="String">str</a>
      <span class="delimiter">}</span>
      <a href="#135312" title="=&gt; Types.this.Type">underlying</a> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="String">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="135712">pre</a>, <a title="Types.this.Symbol" id="135713">sym</a>, <a title="List[Types.this.Type]" id="135714">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#62591" title="=&gt; Boolean">isRepresentableWithWildcards</a> =&gt;
          <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#62092" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#135712" title="Types.this.Type">pre</a>, <a href="#135713" title="Types.this.Symbol">sym</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#62590" title="(available: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]">wildcardArgsString</a><span class="delimiter">(</span><a href="#135311" title="=&gt; List[Types.this.Symbol]">quantified</a>.<span title="scala.collection.immutable.Set[Types.this.Symbol]">toSet</span>, <a href="#135714" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="String">MethodType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> | NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> | PolyType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
          <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#135312" title="=&gt; Types.this.Type">underlying</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#135656" title="=&gt; String">clauses</a>
        <span class="keyword">case</span> <span title="String">_</span> =&gt;
          <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#135312" title="=&gt; Types.this.Type">underlying</a> <span title="(x$1: Any)String">+</span> <a href="#135656" title="=&gt; String">clauses</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="62593">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="135723">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      <a href="Symbols.scala.html#38752" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol, tpe: Types.this.Type)(creator: (List[Types.this.Symbol], Types.this.Type) =&gt; Types.this.Type)Types.this.Type">createFromClonedSymbolsAtOwner</a><span class="delimiter">(</span><a href="#135311" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#135723" title="Types.this.Symbol">owner</a>, <a href="#135312" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#38891" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.Type" id="62594">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="135739">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#135311" title="=&gt; List[Types.this.Symbol]">quantified</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#135747" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#135739" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#62593" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#135739" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#62567" title="Types.this.ExistentialType" class="keyword">this</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="62595">kind</a> = <span title="String(&quot;ExistentialType&quot;)" class="string">&quot;ExistentialType&quot;</span>

    <span class="keyword">def</span> <a title="(op: Types.this.Type =&gt; Boolean)Boolean" id="62596">withTypeVars</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="135756">op</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#62597" title="(op: Types.this.Type =&gt; Boolean, depth: Int)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#135756" title="Types.this.Type =&gt; Boolean">op</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="(op: Types.this.Type =&gt; Boolean, depth: Int)Boolean" id="62597">withTypeVars</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="135762">op</a>: Type =&gt; Boolean, <a title="Int" id="135763">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="135765">quantifiedFresh</a> = <a href="Symbols.scala.html#38745" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#135311" title="=&gt; List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.TypeVar]" id="135766">tvars</a> = <a href="#135765" title="List[Types.this.Symbol]">quantifiedFresh</a> <span title="(f: Types.this.Symbol =&gt; Types.this.TypeVar)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.TypeVar,List[Types.this.TypeVar]])List[Types.this.TypeVar]">map</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="135785">tparam</a> =&gt; <a href="#84010" title="(tparam: Types.this.Symbol)Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#135785" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="135767">underlying1</a> = <a href="#135312" title="=&gt; Types.this.Type">underlying</a>.<a href="#41531" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#135311" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#135766" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span> // fuse subst quantified -&gt; quantifiedFresh -&gt; tvars
      <a href="#135762" title="(v1: Types.this.Type)Boolean">op</a><span class="delimiter">(</span><a href="#135767" title="Types.this.Type">underlying1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
        <a href="#39084" title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean, depth: Int)Boolean">solve</a><span class="delimiter">(</span><a href="#135766" title="List[Types.this.TypeVar]">tvars</a>, <a href="#135765" title="List[Types.this.Symbol]">quantifiedFresh</a>, <a href="#135765" title="List[Types.this.Symbol]">quantifiedFresh</a> <span title="(f: Types.this.Symbol =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Int,List[Int]])List[Int]">map</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="135845">x</a> =&gt; <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span>, <a href="#135763" title="Int">depth</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <a href="#39085" title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])Boolean">isWithinBounds</a><span class="delimiter">(</span><a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a>, <a href="#135765" title="List[Types.this.Symbol]">quantifiedFresh</a>, <a href="#135766" title="List[Types.this.TypeVar]">tvars</a> <span title="(f: Types.this.TypeVar =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeVar],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#135905" title="Types.this.TypeVar">_</a>.<a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84069" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.ExistentialType" id="135971">ExistentialType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#7741" title="Types.this.ExistentialTypeExtractor">ExistentialTypeExtractor</a>

  /** A class containing the alternatives and type prefix of an overloaded symbol.
   *  Not used after phase `typer`.
   */
  case <span class="keyword">class</span> <a title="class OverloadedType extends Types.this.Type with ScalaObject with Product with Serializable" id="147887">OverloadedType</a><a href="#147887" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="83807">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="83808">alternatives</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83773">prefix</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#83807" title="=&gt; Types.this.Type">pre</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83774">safeToString</a> =
      <span class="delimiter">(</span><a href="#83808" title="=&gt; List[Types.this.Symbol]">alternatives</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#83807" title="=&gt; Types.this.Type">pre</a>.<a href="#41556" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="String(&quot; &lt;and&gt; &quot;)" class="string">&quot; &lt;and&gt; &quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83775">kind</a> = <span title="String(&quot;OverloadedType&quot;)" class="string">&quot;OverloadedType&quot;</span>
  <span class="delimiter">}</span>

  /** A class remembering a type instantiation for some a set of overloaded
   *  polymorphic symbols.
   *  Not used after phase `typer`.
   */
  case <span class="keyword">class</span> <a title="class AntiPolyType extends Types.this.Type with ScalaObject with Product with Serializable" id="147883">AntiPolyType</a><a href="#147883" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="83904">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="List[Types.this.Type]" id="83905">targs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83870">safeToString</a> =
      <a href="#83904" title="=&gt; Types.this.Type">pre</a>.<a href="#41589" title="()String">toString</a> <span title="(x$1: Any)String">+</span> <a href="#83905" title="=&gt; List[Types.this.Type]">targs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;(with type arguments &quot;)" class="string">&quot;(with type arguments &quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.Type" id="83871">memberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="136075">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#38940" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#83904" title="=&gt; Types.this.Type">pre</a>.<a href="#41556" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#136075" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>, <a href="#83905" title="=&gt; List[Types.this.Type]">targs</a><span class="delimiter">)</span>
//     override def memberType(sym: Symbol) = pre.memberType(sym) match {
//       case PolyType(tparams, restp) =&gt;
//         restp.subst(tparams, targs)
// /* I don't think this is needed, as existential types close only over value types
//       case ExistentialType(tparams, qtpe) =&gt;
//         existentialAbstraction(tparams, qtpe.memberType(sym))
// */
//       case ErrorType =&gt;
//         ErrorType
//     }
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="83872">kind</a> = <span title="String(&quot;AntiPolyType&quot;)" class="string">&quot;AntiPolyType&quot;</span>
  <span class="delimiter">}</span>

  //private var tidCount = 0  //DEBUG

  <span class="keyword">object</span> <a title="object Types.this.HasTypeMember" id="38901">HasTypeMember</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(name: Types.this.TypeName, tp: Types.this.Type)Types.this.Type" id="136119">apply</a><span class="delimiter">(</span><a title="Types.this.TypeName" id="136122">name</a>: <a href="Names.scala.html#38410" title="Types.this.TypeName">TypeName</a>, <a title="Types.this.Type" id="136123">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="136125">bound</a> = <a href="#38932" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><span title="(xs: Types.this.WildcardType.type*)List[Types.this.WildcardType.type]">List</span><span class="delimiter">(</span><a href="#131644" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span>, <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="136126">bsym</a> = <a href="#136125" title="Types.this.Type">bound</a>.<a href="#41504" title="Types.this.Symbol" id="136145">typeSymbol</a>.<a href="Symbols.scala.html#74600" title="Types.this.Position" id="136148">newAliasType</a><span class="delimiter">(</span><a href="#136122" title="Types.this.TypeName" id="136146">name</a><span class="delimiter">)</span>
      <a href="#136126" title="Types.this.Symbol">bsym</a> <a href="Symbols.scala.html#46610" title="(info: Types.this.Type)bsym.type">setInfo</a> <a href="#136123" title="Types.this.Type">tp</a>
      <a href="#136125" title="Types.this.Type">bound</a>.<a href="#41536" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#60499" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#136126" title="Types.this.Symbol">bsym</a>
      <a href="#136125" title="Types.this.Type">bound</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Option[(Types.this.TypeName, Types.this.Type)]" id="136120">unapply</a><span class="delimiter">(</span><a title="Types.this.Type" id="136151">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Option[(Types.this.TypeName, Types.this.Type)]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>TypeName, Type<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#136151" title="Types.this.Type">tp</a> <span title="Option[(Types.this.TypeName, Types.this.Type)]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Some[(Types.this.TypeName, Types.this.Type)]">RefinedType</span><span class="delimiter">(</span><a href="#136154" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><a href="#131644" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span>, <a href="Scopes.scala.html#77478" title="(decls: Types.this.Scope)Some[Seq[Types.this.Symbol]]">Scope</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="136168">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span title="(x: (Types.this.TypeName, Types.this.Type))Some[(Types.this.TypeName, Types.this.Type)]">Some</span><span class="delimiter">(</span><span title="(_1: Types.this.TypeName, _2: Types.this.Type)(Types.this.TypeName, Types.this.Type)" class="delimiter">(</span><a href="#136168" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#52127" title="=&gt; Types.this.TypeName">toTypeName</a>, <a href="#136168" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="None.type">_</span> =&gt; <span title="object None">None</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  // Not used yet.
  <span class="keyword">object</span> <a title="object Types.this.HasTypeParams" id="38903">HasTypeParams</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Option[(List[Types.this.Symbol], Types.this.Type)]" id="136180">unapply</a><span class="delimiter">(</span><a title="Types.this.Type" id="136182">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Option[(List[Types.this.Symbol], Types.this.Type)]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, Type<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#136182" title="Types.this.Type">tp</a> <span title="Option[(List[Types.this.Symbol], Types.this.Type)]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Option[(List[Types.this.Symbol], Types.this.Type)]">AnnotatedType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="136184">tp</a>, _<span class="delimiter">)</span>        =&gt; <a href="#136180" title="(tp: Types.this.Type)Option[(List[Types.this.Symbol], Types.this.Type)]">unapply</a><span class="delimiter">(</span><a href="#136184" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Some[(List[Types.this.Symbol], Types.this.Type)]">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="136185">tparams</a>, <a title="Types.this.Type" id="136186">qtpe</a><span class="delimiter">)</span> =&gt; <span title="(x: (List[Types.this.Symbol], Types.this.Type))Some[(List[Types.this.Symbol], Types.this.Type)]">Some</span><span class="delimiter">(</span><span title="(_1: List[Types.this.Symbol], _2: Types.this.Type)(List[Types.this.Symbol], Types.this.Type)" class="delimiter">(</span><a href="#136185" title="List[Types.this.Symbol]">tparams</a>, <a href="#136186" title="Types.this.Type">qtpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Some[(List[Types.this.Symbol], Types.this.Type)]">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="136196">tparams</a>, <a title="Types.this.Type" id="136197">restpe</a><span class="delimiter">)</span>      =&gt; <span title="(x: (List[Types.this.Symbol], Types.this.Type))Some[(List[Types.this.Symbol], Types.this.Type)]">Some</span><span class="delimiter">(</span><span title="(_1: List[Types.this.Symbol], _2: Types.this.Type)(List[Types.this.Symbol], Types.this.Type)" class="delimiter">(</span><a href="#136196" title="List[Types.this.Symbol]">tparams</a>, <a href="#136197" title="Types.this.Type">restpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="None.type">_</span>                              =&gt; <span title="object None">None</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  //@M
  // a TypeVar used to be a case class with only an origin and a constr
  // then, constr became mutable (to support UndoLog, I guess),
  // but pattern-matching returned the original constr0 (a bug)
  // now, pattern-matching returns the most recent constr
  <span class="keyword">object</span> <a title="object Types.this.TypeVar" id="38905">TypeVar</a> <span title="ScalaObject" class="delimiter">{</span>
    @inline <span class="keyword">final</span> <span class="keyword">def</span> <a title="[T](action: String, msg: =&gt; String)(value: T)T" id="84004">trace</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="84006">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="136210">action</a>: <span title="String">String</span>, <a title="=&gt; String" id="136211">msg</a>: =&gt; String<span class="delimiter">)</span><span class="delimiter">(</span><a title="T" id="136212">value</a>: <a href="#84006" title="T">T</a><span class="delimiter">)</span>: <a href="#84006" title="T">T</a> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#38787" title="=&gt; Boolean">traceTypeVars</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="String" id="136215">s</a> = <a href="#136211" title="=&gt; String">msg</a> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>   =&gt; <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
          <span class="keyword">case</span> <a title="String" id="136216">str</a>  =&gt; <span title="String(&quot;( &quot;)" class="string">&quot;( &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#136216" title="String">str</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; )&quot;)" class="string">&quot; )&quot;</span>
        <span class="delimiter">}</span>
        <span title="object Console">Console</span>.<span title="=&gt; java.io.PrintStream">err</span>.<span title="(x$1: String)Unit">println</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;[%10s] %-25s%s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#136210" title="String">action</a>, <a href="#136212" title="T">value</a>, <a href="#136215" title="String">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#136212" title="T">value</a>
    <span class="delimiter">}</span>

    /** Create a new TypeConstraint based on the given symbol.
     */
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Types.this.TypeConstraint" id="84007">deriveConstraint</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="136224">tparam</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38975" title="Types.this.TypeConstraint">TypeConstraint</a> = <span class="delimiter">{</span>
      /** Must force the type parameter's info at this point
       *  or things don't end well for higher-order type params.
       *  See SI-5359.
       */
      <span class="keyword">val</span> <a title="Types.this.TypeBounds" id="136226">bounds</a>  = <a href="#136224" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>
      /** We can seed the type constraint with the type parameter
       *  bounds as long as the types are concrete.  This should lower
       *  the complexity of the search even if it doesn't improve
       *  any results.
       */
      <span title="Types.this.TypeConstraint" class="keyword">if</span> <span class="delimiter">(</span><a href="#38791" title="=&gt; Boolean">propagateParameterBoundsToTypeVars</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Boolean" id="136227">exclude</a> = <a href="#136226" title="Types.this.TypeBounds">bounds</a>.<a href="#62307" title="=&gt; Boolean">isEmptyBounds</a> <span title="(x: Boolean)Boolean">||</span> <a href="#136226" title="Types.this.TypeBounds">bounds</a>.<a href="#41568" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#136230" title="Types.this.Type">_</a>.<a href="#41506" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>.<a href="Symbols.scala.html#46450" title="=&gt; Boolean">isNonClassType</a><span class="delimiter">)</span>

        <span title="Types.this.TypeConstraint" class="keyword">if</span> <span class="delimiter">(</span><a href="#136227" title="Boolean">exclude</a><span class="delimiter">)</span> <a href="#84045" title="()Types.this.TypeConstraint" class="keyword">new</a> <a href="#38975" title="Types.this.TypeConstraint">TypeConstraint</a>
        <span class="keyword">else</span> <a href="#38905" title="object Types.this.TypeVar">TypeVar</a>.<a href="#84004" title="(action: String, msg: =&gt; String)(value: Types.this.TypeConstraint)Types.this.TypeConstraint">trace</a><span class="delimiter">(</span><span title="String(&quot;constraint&quot;)" class="string">&quot;constraint&quot;</span>, <span title="String(&quot;For &quot;)" class="string">&quot;For &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#136224" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46745" title="=&gt; String">fullLocationString</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#84044" title="(bounds: Types.this.TypeBounds)Types.this.TypeConstraint" class="keyword">new</a> <a href="#38975" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">(</span><a href="#136226" title="Types.this.TypeBounds">bounds</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#84045" title="()Types.this.TypeConstraint" class="keyword">new</a> <a href="#38975" title="Types.this.TypeConstraint">TypeConstraint</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]" id="84008">unapply</a><span class="delimiter">(</span><a title="Types.this.TypeVar" id="129448">tv</a>: <a href="#38912" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">)</span>: <span title="Some[(Types.this.Type, Types.this.TypeConstraint)]">Some</span><span class="delimiter">[</span><span class="delimiter">(</span>Type, TypeConstraint<span class="delimiter">)</span><span class="delimiter">]</span>   = <span title="(x: (Types.this.Type, Types.this.TypeConstraint))Some[(Types.this.Type, Types.this.TypeConstraint)]">Some</span><span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.TypeConstraint)(Types.this.Type, Types.this.TypeConstraint)" class="delimiter">(</span><a href="#129448" title="Types.this.TypeVar">tv</a>.<a href="#136207" title="=&gt; Types.this.Type">origin</a>, <a href="#129448" title="Types.this.TypeVar">tv</a>.<a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(origin: Types.this.Type, constr: Types.this.TypeConstraint)Types.this.TypeVar" id="84009">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="84021">origin</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.TypeConstraint" id="84022">constr</a>: <a href="#38975" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">)</span>: <a href="#38912" title="Types.this.TypeVar">TypeVar</a> = <a href="#84011" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">apply</a><span class="delimiter">(</span><a href="#84021" title="Types.this.Type">origin</a>, <a href="#84022" title="Types.this.TypeConstraint">constr</a>, <span title="object Nil">Nil</span>, <span title="object Nil">Nil</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(tparam: Types.this.Symbol)Types.this.TypeVar" id="84010">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="84019">tparam</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38912" title="Types.this.TypeVar">TypeVar</a>                       = <a href="#84011" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">apply</a><span class="delimiter">(</span><a href="#84019" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46607" title="=&gt; Types.this.Type">tpeHK</a>, <a href="#84007" title="(tparam: Types.this.Symbol)Types.this.TypeConstraint">deriveConstraint</a><span class="delimiter">(</span><a href="#84019" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span>, <span title="object Nil">Nil</span>, <a href="#84019" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span>

    /** This is the only place TypeVars should be instantiated.
     */
    <span class="keyword">def</span> <a title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar" id="84011">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="84014">origin</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.TypeConstraint" id="84015">constr</a>: <a href="#38975" title="Types.this.TypeConstraint">TypeConstraint</a>, <a title="List[Types.this.Type]" id="84016">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="84017">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38912" title="Types.this.TypeVar">TypeVar</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.TypeVar" id="136260">tv</a> = <span class="delimiter">(</span>
        <span title="Types.this.TypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#84016" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#84017" title="List[Types.this.Symbol]">params</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>   <span title="Types.this.TypeVar" class="keyword">new</span> <a href="#38912" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#84014" title="Types.this.Type">origin</a>, <a href="#84015" title="Types.this.TypeConstraint">constr</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Types.this.TypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#84016" title="List[Types.this.Type]">args</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">==</span> <a href="#84017" title="List[Types.this.Symbol]">params</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>    <span title="Types.this.AppliedTypeVar" class="keyword">new</span> <a href="#38911" title="Types.this.AppliedTypeVar">AppliedTypeVar</a><span class="delimiter">(</span><a href="#84014" title="Types.this.Type">origin</a>, <a href="#84015" title="Types.this.TypeConstraint">constr</a>, <a href="#84017" title="List[Types.this.Symbol]">params</a> <span title="(that: scala.collection.GenIterable[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],(Types.this.Symbol, Types.this.Type),List[(Types.this.Symbol, Types.this.Type)]])List[(Types.this.Symbol, Types.this.Type)]">zip</span> <a href="#84016" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Types.this.HKTypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#84016" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>                <span title="Types.this.HKTypeVar" class="keyword">new</span> <a href="#38910" title="Types.this.HKTypeVar">HKTypeVar</a><span class="delimiter">(</span><a href="#84014" title="Types.this.Type">origin</a>, <a href="#84015" title="Types.this.TypeConstraint">constr</a>, <a href="#84017" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <span title="(x$1: String)Error" class="keyword">new</span> <span title="Error">Error</span><span class="delimiter">(</span><span title="String(&quot;Invalid TypeVar construction: &quot;)" class="string">&quot;Invalid TypeVar construction: &quot;</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.TypeConstraint, _3: List[Types.this.Type], _4: List[Types.this.Symbol])(Types.this.Type, Types.this.TypeConstraint, List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</span><a href="#84014" title="Types.this.Type">origin</a>, <a href="#84015" title="Types.this.TypeConstraint">constr</a>, <a href="#84016" title="List[Types.this.Type]">args</a>, <a href="#84017" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">)</span>
      
      <a href="#84004" title="(action: String, msg: =&gt; String)(value: Types.this.TypeVar)Types.this.TypeVar">trace</a><span class="delimiter">(</span><span title="String(&quot;create&quot;)" class="string">&quot;create&quot;</span>, <span title="String(&quot;In &quot;)" class="string">&quot;In &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#136260" title="Types.this.TypeVar">tv</a>.<a href="#83997" title="=&gt; String">originLocation</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#136260" title="Types.this.TypeVar">tv</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  // TODO: I don't really know why this happens -- maybe because
  // the owner hierarchy changes? the other workaround (besides
  // repackExistential) is to explicitly pass expectedTp as the type
  // argument for the call to guard, but repacking the existential
  // somehow feels more robust
  //
  // TODO: check if optimization makes a difference, try something else
  // if necessary (cache?)

  /** Repack existential types, otherwise they sometimes get unpacked in the
   *  wrong location (type inference comes up with an unexpected skolem)
   */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="38907">repackExistential</a><span class="delimiter">(</span><a title="Types.this.Type" id="136655">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">(</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#136655" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <a href="#136655" title="Types.this.Type">tp</a>
    <span class="keyword">else</span> <a href="#38945" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#38909" title="(tpe: Types.this.Type)List[Types.this.Symbol]">existentialsInType</a><span class="delimiter">(</span><a href="#136655" title="Types.this.Type">tp</a><span class="delimiter">)</span>, <a href="#136655" title="Types.this.Type">tp</a><span class="delimiter">)</span>
  <span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="(tpe: Types.this.Type)Boolean" id="38908">containsExistential</a><span class="delimiter">(</span><a title="Types.this.Type" id="136671">tpe</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
    <a href="#136671" title="Types.this.Type">tpe</a> <a href="#41568" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#136676" title="Types.this.Type">_</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46458" title="=&gt; Boolean">isExistentiallyBound</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tpe: Types.this.Type)List[Types.this.Symbol]" id="38909">existentialsInType</a><span class="delimiter">(</span><a title="Types.this.Type" id="136661">tpe</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
    <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="136669">tp</a> &lt;- <a href="#130845" title="(f: Types.this.Type =&gt; Types.this.Symbol)List[Types.this.Symbol]">tpe</a> ; <span class="keyword">if</span> <a href="#136669" title="Types.this.Type">tp</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46458" title="=&gt; Boolean">isExistentiallyBound</a><span class="delimiter">)</span> <span class="keyword">yield</span>
      <a href="#136669" title="Types.this.Type">tp</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>
  <span class="delimiter">)</span>

  /** Precondition: params.nonEmpty.  (args.nonEmpty enforced structurally.)
   */
  <span class="keyword">class</span> <a title="class HKTypeVar extends Types.this.TypeVar with ScalaObject" id="38910">HKTypeVar</a><a href="#38910" title="ScalaObject" class="delimiter">(</a>
    <a title="Types.this.Type" id="136350">_origin</a>: <a href="#38813" title="Types.this.Type">Type</a>,
    <a title="Types.this.TypeConstraint" id="136351">_constr</a>: <a href="#38975" title="Types.this.TypeConstraint">TypeConstraint</a>,
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="136352">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
  <span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38912" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#136350" title="Types.this.Type">_origin</a>, <a href="#136351" title="Types.this.TypeConstraint">_constr</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#136352" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Boolean">nonEmpty</span>, <a href="#38910" title="Types.this.HKTypeVar" class="keyword">this</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="136348">isHigherKinded</a>          = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; String" id="136349">typeVarString</a> = <a href="#136352" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="(f: Types.this.Symbol =&gt; Types.this.Name)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Name,List[Types.this.Name]])List[Types.this.Name]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.Name,List[Types.this.Name]]" class="delimiter">(</span><a href="#136708" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;]=&gt;&quot;)" class="string">&quot;]=&gt;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#83996" title="=&gt; String">originName</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  /** Precondition: zipped params/args nonEmpty.  (Size equivalence enforced structurally.)
   */
  <span class="keyword">class</span> <a title="class AppliedTypeVar extends Types.this.TypeVar with ScalaObject" id="38911">AppliedTypeVar</a><a href="#38911" title="ScalaObject" class="delimiter">(</a>
    <a title="Types.this.Type" id="136276">_origin</a>: <a href="#38813" title="Types.this.Type">Type</a>,
    <a title="Types.this.TypeConstraint" id="136277">_constr</a>: <a href="#38975" title="Types.this.TypeConstraint">TypeConstraint</a>,
    <a title="List[(Types.this.Symbol, Types.this.Type)]" id="136278">zippedArgs</a>: <span title="List[(Types.this.Symbol, Types.this.Type)]">List</span><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Type<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38912" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#136276" title="Types.this.Type">_origin</a>, <a href="#136277" title="Types.this.TypeConstraint">_constr</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#136278" title="List[(Types.this.Symbol, Types.this.Type)]">zippedArgs</a>.<span title="=&gt; Boolean">nonEmpty</span>, <a href="#38911" title="Types.this.AppliedTypeVar" class="keyword">this</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="136273">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#136278" title="List[(Types.this.Symbol, Types.this.Type)]">zippedArgs</a> <span title="(f: ((Types.this.Symbol, Types.this.Type)) =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Symbol, Types.this.Type)],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <span class="delimiter">(</span><a href="#136761" title="(Types.this.Symbol, Types.this.Type)">_</a>.<span title="=&gt; Types.this.Symbol">_1</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="136274">typeArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#136278" title="List[(Types.this.Symbol, Types.this.Type)]">zippedArgs</a> <span title="(f: ((Types.this.Symbol, Types.this.Type)) =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Symbol, Types.this.Type)],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#136799" title="(Types.this.Symbol, Types.this.Type)">_</a>.<span title="=&gt; Types.this.Type">_2</span><span class="delimiter">)</span>
    
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; String" id="136275">typeVarString</a> = <span class="delimiter">(</span>
      <a href="#136278" title="List[(Types.this.Symbol, Types.this.Type)]">zippedArgs</a> <span title="(f: ((Types.this.Symbol, Types.this.Type)) =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Symbol, Types.this.Type)],String,List[String]])List[String]">map</span> <a href="#136840" title="String" class="delimiter">{</a> <span class="keyword">case</span> <span title="String" class="delimiter">(</span><a title="Types.this.Symbol" id="136843">p</a>, <a title="Types.this.Type" id="136844">a</a><span class="delimiter">)</span> =&gt; <a href="#136843" title="Types.this.Symbol">p</a>.<a href="Symbols.scala.html#46571" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">name</a> <span title="(other: String)String">+</span> <span title="String(&quot;=&quot;)" class="string">&quot;=&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#136844" title="Types.this.Type">a</a> <span class="delimiter">}</span> <span title="(start: String, sep: String, end: String)String">mkString</span> <span class="delimiter">(</span><a href="#136207" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">origin</a> <span title="(other: String)String">+</span> <span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  /** A class representing a type variable: not used after phase `typer`.
   *
   *  A higher-kinded TypeVar has params (Symbols) and typeArgs (Types).
   *  A TypeVar with nonEmpty typeArgs can only be instantiated by a higher-kinded
   *  type that can be applied to those args.  A TypeVar is much like a TypeRef,
   *  except it has special logic for equality and subtyping.
   *
   *  Precondition for this class, enforced structurally: args.isEmpty &amp;&amp; params.isEmpty.
   */
  <span class="keyword">class</span> <a title="class TypeVar extends Types.this.Type with ScalaObject" id="38912">TypeVar</a><a href="#38912" title="ScalaObject" class="delimiter">(</a>
    <span class="keyword">val</span> <a title="Types.this.Type" id="136207">origin</a>: <a href="#38813" title="Types.this.Type">Type</a>,
    <span class="keyword">val</span> <a title="Types.this.TypeConstraint" id="136208">constr0</a>: <a href="#38975" title="Types.this.TypeConstraint">TypeConstraint</a>
  <span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="83965">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span title="object Nil">Nil</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="83966">typeArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="object Nil">Nil</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83967">isHigherKinded</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** The constraint associated with the variable 
     *  Syncnote: Type variables are assumed to be used from only one
     *  thread. They are not exposed in api.Types and are used only locally
     *  in operations that are exposed from types. Hence, no syncing of `constr`
     *  or `encounteredHigherLevel` or `suspended` accesses should be necessary.
     */
    <span class="keyword">var</span> <a title="Types.this.TypeConstraint" id="83969">constr</a> = <a href="#136208" title="=&gt; Types.this.TypeConstraint">constr0</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="83971">instValid</a> = <a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84071" title="=&gt; Boolean">instValid</a>

    /** The variable's skolemization level */
    <span class="keyword">val</span> <a title="Int" id="83972">level</a> = <a href="#38800" title="=&gt; Int">skolemizationLevel</a>
    
    /** Two occurrences of a higher-kinded typevar, e.g. `?CC[Int]` and `?CC[String]`, correspond to
     *  ''two instances'' of `TypeVar` that share the ''same'' `TypeConstraint`.
     *
     *  `constr` for `?CC` only tracks type constructors anyway,
     *   so when `?CC[Int] &lt;:&lt; List[Int]` and `?CC[String] &lt;:&lt; Iterable[String]`
     *  `?CC's` hibounds contains List and Iterable.
     */
    <span class="keyword">def</span> <a title="(newArgs: List[Types.this.Type])Types.this.TypeVar" id="83974">applyArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="136886">newArgs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38912" title="Types.this.TypeVar">TypeVar</a> = <span class="delimiter">(</span>
      <span title="Types.this.TypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#136886" title="List[Types.this.Type]">newArgs</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#83966" title="=&gt; List[Types.this.Type]">typeArgs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
        <a href="#38912" title="Types.this.TypeVar" class="keyword">this</a>
      <span class="keyword">else</span> <span title="Types.this.TypeVar" class="keyword">if</span> <span class="delimiter">(</span><a href="#136886" title="List[Types.this.Type]">newArgs</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">==</span> <a href="#83965" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.TypeVar" id="136895">tv</a> = <a href="#84011" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#136207" title="=&gt; Types.this.Type">origin</a>, <a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>, <a href="#136886" title="List[Types.this.Type]">newArgs</a>, <a href="#83965" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
        <a href="#38905" title="object Types.this.TypeVar">TypeVar</a>.<a href="#84004" title="(action: String, msg: =&gt; String)(value: Types.this.TypeVar)Types.this.TypeVar">trace</a><span class="delimiter">(</span><span title="String(&quot;applyArgs&quot;)" class="string">&quot;applyArgs&quot;</span>, <span title="String(&quot;In &quot;)" class="string">&quot;In &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#83997" title="=&gt; String">originLocation</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, apply args &quot;)" class="string">&quot;, apply args &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#136886" title="List[Types.this.Type]">newArgs</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; to &quot;)" class="string">&quot; to &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#83996" title="=&gt; String">originName</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#136895" title="Types.this.TypeVar">tv</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">else</span>
        <span title="Nothing" class="keyword">throw</span> <span title="(x$1: String)Error" class="keyword">new</span> <span title="Error">Error</span><span class="delimiter">(</span><span title="String(&quot;Invalid type application in TypeVar: &quot;)" class="string">&quot;Invalid type application in TypeVar: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#83965" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#136886" title="List[Types.this.Type]">newArgs</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    // newArgs.length may differ from args.length (could've been empty before)
    //
    // !!! @PP - I need an example of this, since this exception never triggers
    // even though I am requiring the size match.
    //
    // example: when making new typevars, you start out with C[A], then you replace C by ?C, which should yield ?C[A], then A by ?A, ?C[?A]
    // we need to track a TypeVar's arguments, and map over them (see TypeMap::mapOver)
    // TypeVars get applied to different arguments over time (in asSeenFrom)
     // -- see pos/tcpoly_infer_implicit_tuplewrapper.scala
    // thus: make new TypeVar's for every application of a TV to args,
    // inference may generate several TypeVar's for a single type parameter that must be inferred,
    // only one of them is in the set of tvars that need to be solved, but
    // they share the same TypeConstraint instance
    
    // When comparing to types containing skolems, remember the highest level
    // of skolemization. If that highest level is higher than our initial
    // skolemizationLevel, we can't re-use those skolems as the solution of this
    // typevar, which means we'll need to repack our constr.inst into a fresh
    // existential.
    // were we compared to skolems at a higher skolemizationLevel?
    // EXPERIMENTAL: value will not be considered unless enableTypeVarExperimentals is true
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Boolean" id="83976">encounteredHigherLevel</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83978">shouldRepackType</a> = <a href="#38793" title="=&gt; Boolean">enableTypeVarExperimentals</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#83976" title="=&gt; Boolean">encounteredHigherLevel</a>

    // &lt;region name=&quot;constraint mutators + undoLog&quot;&gt;
    // invariant: before mutating constr, save old state in undoLog
    // (undoLog is used to reset constraints to avoid piling up unrelated ones)
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="83979">setInst</a><span class="delimiter">(</span><a title="Types.this.Type" id="136917">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
//      assert(!(tp containsTp this), this)
      <a href="#38802" title="=&gt; Types.this.UndoLog">undoLog</a> <a href="#129892" title="(tv: Types.this.TypeVar)Unit">record</a> <a href="#38912" title="Types.this.TypeVar" class="keyword">this</a>
      // if we were compared against later typeskolems, repack the existential,
      // because skolems are only compatible if they were created at the same level
      <span class="keyword">val</span> <a title="Types.this.Type" id="136919">res</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83978" title="=&gt; Boolean">shouldRepackType</a><span class="delimiter">)</span> <a href="#38907" title="(tp: Types.this.Type)Types.this.Type">repackExistential</a><span class="delimiter">(</span><a href="#136917" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#136917" title="Types.this.Type">tp</a>
      <a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84069" title="(x$1: Types.this.Type)Unit">inst</a> = <a href="#38905" title="object Types.this.TypeVar">TypeVar</a>.<a href="#84004" title="(action: String, msg: =&gt; String)(value: Types.this.Type)Types.this.Type">trace</a><span class="delimiter">(</span><span title="String(&quot;setInst&quot;)" class="string">&quot;setInst&quot;</span>, <span title="String(&quot;In &quot;)" class="string">&quot;In &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#83997" title="=&gt; String">originLocation</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#83996" title="=&gt; String">originName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;=&quot;)" class="string">&quot;=&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#136919" title="Types.this.Type">res</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#136919" title="Types.this.Type">res</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="83980">addLoBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="136926">tp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Boolean" id="136929">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#136926" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#38912" title="Types.this.TypeVar" class="keyword">this</a>, <a href="#136926" title="Types.this.Type">tp</a><span class="delimiter">)</span> // implies there is a cycle somewhere (?)
      //println(&quot;addLoBound: &quot;+(safeToString, debugString(tp))) //DEBUG
      <a href="#38802" title="=&gt; Types.this.UndoLog">undoLog</a> <a href="#129892" title="(tv: Types.this.TypeVar)Unit">record</a> <a href="#38912" title="Types.this.TypeVar" class="keyword">this</a>
      <a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84064" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a><span class="delimiter">(</span><a href="#136926" title="Types.this.Type">tp</a>, <a href="#136929" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="83981">addHiBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="136940">tp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Boolean" id="136943">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      // assert(tp != this)
      //println(&quot;addHiBound: &quot;+(safeToString, debugString(tp))) //DEBUG
      <a href="#38802" title="=&gt; Types.this.UndoLog">undoLog</a> <a href="#129892" title="(tv: Types.this.TypeVar)Unit">record</a> <a href="#38912" title="Types.this.TypeVar" class="keyword">this</a>
      <a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84066" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a><span class="delimiter">(</span><a href="#136940" title="Types.this.Type">tp</a>, <a href="#136943" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    // &lt;/region&gt;

    // ignore subtyping&amp;equality checks while true -- see findMember
    <span class="keyword">private</span><span class="delimiter">[</span>Types<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Boolean" id="83983">suspended</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Called when a TypeVar is involved in a subtyping check.  Result is whether
     *  this TypeVar could plausibly be a [super/sub]type of argument `tp` and if so,
     *  tracks tp as a [lower/upper] bound of this TypeVar.
     *
     *  if (isLowerBound)   this typevar could be a subtype, track tp as a lower bound
     *  if (!isLowerBound)  this typevar could be a supertype, track tp as an upper bound
     *
     *  If isNumericBound is true, the subtype check is performed with weak_&lt;:&lt; instead of &lt;:&lt;.
     */
    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean" id="83985">registerBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="131077">tp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Boolean" id="131078">isLowerBound</a>: <span title="Boolean">Boolean</span>, <a title="Boolean" id="131081">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      // println(&quot;regBound: &quot;+(safeToString, debugString(tp), isLowerBound)) //@MDEBUG
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#131078" title="Boolean">isLowerBound</a><span class="delimiter">)</span>
        <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#131077" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#38912" title="Types.this.TypeVar" class="keyword">this</a><span class="delimiter">)</span>

      // side effect: adds the type to upper or lower bounds
      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="136948">addBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="136958">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#131078" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#83980" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a><span class="delimiter">(</span><a href="#136958" title="Types.this.Type">tp</a>, <a href="#131081" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#83981" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a><span class="delimiter">(</span><a href="#136958" title="Types.this.Type">tp</a>, <a href="#131081" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      // swaps the arguments if it's an upper bound
      <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="136949">checkSubtype</a><span class="delimiter">(</span><a title="Types.this.Type" id="136959">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="136960">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="136961">lhs</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#131078" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#136959" title="Types.this.Type">tp1</a> <span class="keyword">else</span> <a href="#136960" title="Types.this.Type">tp2</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="136962">rhs</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#131078" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#136960" title="Types.this.Type">tp2</a> <span class="keyword">else</span> <a href="#136959" title="Types.this.Type">tp1</a>

        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#131081" title="Boolean">isNumericBound</a><span class="delimiter">)</span> <a href="#136961" title="Types.this.Type">lhs</a> <a href="#41574" title="(that: Types.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#136962" title="Types.this.Type">rhs</a>
        <span class="keyword">else</span> <a href="#136961" title="Types.this.Type">lhs</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#136962" title="Types.this.Type">rhs</a>
      <span class="delimiter">}</span>

      /** Simple case: type arguments can be ignored, because either this typevar has
       *  no type parameters, or we are comparing to Any/Nothing.
       *
       *  The latter condition is needed because HK unification is limited to constraints of the shape
       *  {{{
       *    TC1[T1,..., TN] &lt;: TC2[T'1,...,T'N]
       *  }}}
       *  which would preclude the following important constraints:
       *  {{{
       *    Nothing &lt;: ?TC[?T]
       *    ?TC[?T] &lt;: Any
       *  }}}
       */
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="136950">unifySimple</a> = <span class="delimiter">(</span>
        <span class="delimiter">(</span><a href="#83965" title="=&gt; List[Types.this.Symbol]">params</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#131077" title="Types.this.Type">tp</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="#131077" title="Types.this.Type">tp</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
          <a href="#136948" title="(tp: Types.this.Type)Unit">addBound</a><span class="delimiter">(</span><a href="#131077" title="Types.this.Type">tp</a><span class="delimiter">)</span>
          <span title="Boolean(true)" class="keyword">true</span>
        <span class="delimiter">}</span>
      <span class="delimiter">)</span>

      /** Full case: involving a check of the form
       *  {{{
       *    TC1[T1,..., TN] &lt;: TC2[T'1,...,T'N]
       *  }}}
       *  Checks subtyping of higher-order type vars, and uses variances as defined in the
       *  type parameter we're trying to infer (the result will be sanity-checked later).
       */
      <span class="keyword">def</span> <a title="(tpe: Types.this.Type)Boolean" id="136951">unifyFull</a><span class="delimiter">(</span><a title="Types.this.Type" id="136975">tpe</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        // The alias/widen variations are often no-ops.
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="136976">tpes</a> = <span class="delimiter">(</span>
          <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#131078" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#136975" title="Types.this.Type">tpe</a>, <a href="#136975" title="Types.this.Type">tpe</a>.<a href="#41508" title="=&gt; Types.this.Type">widen</a>, <a href="#136975" title="Types.this.Type">tpe</a>.<a href="#41535" title="=&gt; Types.this.Type">dealias</a>, <a href="#136975" title="Types.this.Type">tpe</a>.<a href="#41508" title="=&gt; Types.this.Type">widen</a>.<a href="#41535" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span>.<span title="=&gt; List[Types.this.Type]">distinct</span>
          <span class="keyword">else</span> <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#136975" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
        <span class="delimiter">)</span>
        <a href="#136976" title="List[Types.this.Type]">tpes</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <a title="Types.this.Type" id="136998">tp</a> =&gt;
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="136999">lhs</a> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#131078" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#136998" title="Types.this.Type">tp</a>.<a href="#41517" title="=&gt; List[Types.this.Type]">typeArgs</a> <span class="keyword">else</span> <a href="#83966" title="=&gt; List[Types.this.Type]">typeArgs</a>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="137000">rhs</a> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#131078" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#83966" title="=&gt; List[Types.this.Type]">typeArgs</a> <span class="keyword">else</span> <a href="#136998" title="Types.this.Type">tp</a>.<a href="#41517" title="=&gt; List[Types.this.Type]">typeArgs</a>

          <a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#136999" title="List[Types.this.Type]">lhs</a>, <a href="#137000" title="List[Types.this.Type]">rhs</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
            // this is a higher-kinded type var with same arity as tp.
            // side effect: adds the type constructor itself as a bound
            <a href="#136948" title="(tp: Types.this.Type)Unit">addBound</a><span class="delimiter">(</span><a href="#136998" title="Types.this.Type">tp</a>.<a href="#41516" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>
            <a href="#39070" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean">isSubArgs</a><span class="delimiter">(</span><a href="#136999" title="List[Types.this.Type]">lhs</a>, <a href="#137000" title="List[Types.this.Type]">rhs</a>, <a href="#83965" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      // There's a &lt;: test taking place right now, where tp is a concrete type and this is a typevar
      // attempting to satisfy that test. Either the test will be unsatisfiable, in which case
      // registerBound will return false; or the upper or lower bounds of this type var will be
      // supplemented with the type being tested against.
      //
      // Eventually the types which have accumulated in the upper and lower bounds will be lubbed
      // (resp. glbbed) to instantiate the typevar.
      //
      // The only types which are eligible for unification are those with the same number of
      // typeArgs as this typevar, or Any/Nothing, which are kind-polymorphic. For the upper bound,
      // any parent or base type of `tp` may be tested here (leading to a corresponding relaxation
      // in the upper bound.) The universe of possible glbs, being somewhat more infinite, is not
      // addressed here: all lower bounds are retained and their intersection calculated when the
      // bounds are solved.
      //
      // In a side-effect free universe, checking tp and tp.parents beofre checking tp.baseTypeSeq
      // would be pointless. In this case, each check we perform causes us to lose specificity: in
      // the end the best we'll do is the least specific type we tested against, since the typevar
      // does not see these checks as &quot;probes&quot; but as requirements to fulfill.
      // TODO: the `suspended` flag can be used to poke around with leaving a trace
      //
      // So the strategy used here is to test first the type, then the direct parents, and finally
      // to fall back on the individual base types. This warrants eventual re-examination.

      // AM: I think we could use the `suspended` flag to avoid side-effecting during unification

      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#83983" title="=&gt; Boolean">suspended</a><span class="delimiter">)</span>              // constraint accumulation is disabled
        <a href="#136949" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">checkSubtype</a><span class="delimiter">(</span><a href="#131077" title="Types.this.Type">tp</a>, <a href="#136207" title="=&gt; Types.this.Type">origin</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84071" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span>  // type var is already set
        <a href="#136949" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">checkSubtype</a><span class="delimiter">(</span><a href="#131077" title="Types.this.Type">tp</a>, <a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84069" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#83990" title="(tp: Types.this.Type)Boolean">isRelatable</a><span class="delimiter">(</span><a href="#131077" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
        <a href="#136950" title="=&gt; Boolean">unifySimple</a> <span title="(x: Boolean)Boolean">||</span> <a href="#136951" title="(tpe: Types.this.Type)Boolean">unifyFull</a><span class="delimiter">(</span><a href="#131077" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span>
          // only look harder if our gaze is oriented toward Any
          <a href="#131078" title="Boolean">isLowerBound</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span>
            <span class="delimiter">(</span><a href="#131077" title="Types.this.Type">tp</a>.<a href="#41513" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <a href="#136951" title="(tpe: Types.this.Type)Boolean">unifyFull</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span>
              // @PP: Is it going to be faster to filter out the parents we just checked?
              // That's what's done here but I'm not sure it matters.
              <a href="#131077" title="Types.this.Type">tp</a>.<a href="#41579" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#59598" title="=&gt; List[Types.this.Type]">toList</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</span> <span class="delimiter">(</span><a href="#131077" title="Types.this.Type">tp</a>.<a href="#41513" title="=&gt; List[Types.this.Type]">parents</a> <span title="(elem: Any)Boolean">contains</span> <a href="#137039" title="Types.this.Type">_</a><span class="delimiter">)</span> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <a href="#136951" title="(tpe: Types.this.Type)Boolean">unifyFull</a>
            <span class="delimiter">)</span>
          <span class="delimiter">)</span>
        <span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean" id="83986">registerTypeEquality</a><span class="delimiter">(</span><a title="Types.this.Type" id="137049">tp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Boolean" id="137050">typeVarLHS</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      //println(&quot;regTypeEq: &quot;+(safeToString, debugString(tp), typeVarLHS)) //@MDEBUG
      <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="137052">checkIsSameType</a><span class="delimiter">(</span><a title="Types.this.Type" id="137053">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
        <span title="Boolean" class="keyword">if</span><span class="delimiter">(</span><a href="#137050" title="Boolean">typeVarLHS</a><span class="delimiter">)</span> <a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84069" title="=&gt; Types.this.Type">inst</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#137053" title="Types.this.Type">tp</a>
        <span class="keyword">else</span>           <a href="#137053" title="Types.this.Type">tp</a>          <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84069" title="=&gt; Types.this.Type">inst</a>

      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#83983" title="=&gt; Boolean">suspended</a><span class="delimiter">)</span> <a href="#137049" title="Types.this.Type">tp</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#136207" title="=&gt; Types.this.Type">origin</a>
      <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84071" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#137052" title="(tp: Types.this.Type)Boolean">checkIsSameType</a><span class="delimiter">(</span><a href="#137049" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#83990" title="(tp: Types.this.Type)Boolean">isRelatable</a><span class="delimiter">(</span><a href="#137049" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="137058">newInst</a> = <a href="#137060" title="(tp: Types.this.Type)Types.this.Type">wildcardToTypeVarMap</a><span class="delimiter">(</span><a href="#137049" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a> <a href="#84067" title="(tp: Types.this.Type)Boolean">isWithinBounds</a> <a href="#137058" title="Types.this.Type">newInst</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span> <a href="#83979" title="(tp: Types.this.Type)Unit">setInst</a><span class="delimiter">(</span><a href="#137049" title="Types.this.Type">tp</a><span class="delimiter">)</span>; <span title="Boolean(true)" class="keyword">true</span> <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /**
     * `?A.T =:= tp` is rewritten as the constraint `?A &lt;: {type T = tp}`
     *
     * TODO: make these constraints count (incorporate them into implicit search in `applyImplicitArgs`)
     * (`T` corresponds to @param sym)
     */
    <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, tp: Types.this.Type)Boolean" id="83987">registerTypeSelection</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="137067">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="137068">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="#83985" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#136119" title="(name: Types.this.TypeName, tp: Types.this.Type)Types.this.Type">HasTypeMember</a><span class="delimiter">(</span><a href="#137067" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#52127" title="=&gt; Types.this.TypeName">toTypeName</a>, <a href="#137068" title="Types.this.Type">tp</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="83988">isSkolemAboveLevel</a><span class="delimiter">(</span><a title="Types.this.Type" id="137014">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#137014" title="Types.this.Type">tp</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="137017">ts</a>: <a href="Symbols.scala.html#38734" title="Types.this.TypeSkolem">TypeSkolem</a> =&gt; <a href="#137017" title="Types.this.TypeSkolem">ts</a>.<a href="Symbols.scala.html#82441" title="=&gt; Int">level</a> <span title="(x: Int)Boolean">&gt;</span> <a href="#83972" title="=&gt; Int">level</a>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span>              =&gt; <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>
    // side-effects encounteredHigherLevel
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="83989">containsSkolemAboveLevel</a><span class="delimiter">(</span><a title="Types.this.Type" id="137010">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
      <span class="delimiter">(</span><a href="#137010" title="Types.this.Type">tp</a> <a href="#41568" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#83988" title="(tp: Types.this.Type)Boolean">isSkolemAboveLevel</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span> <a href="#83976" title="(x$1: Boolean)Unit">encounteredHigherLevel</a> = <span title="Boolean(true)" class="keyword">true</span> ; <span title="Boolean(true)" class="keyword">true</span> <span class="delimiter">}</span>

     /** Can this variable be related in a constraint to type `tp`?
      *  This is not the case if `tp` contains type skolems whose
      *  skolemization level is higher than the level of this variable.
      */
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="83990">isRelatable</a><span class="delimiter">(</span><a title="Types.this.Type" id="137007">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
         <a href="#83978" title="=&gt; Boolean">shouldRepackType</a>               // short circuit if we already know we've seen higher levels
      <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#83989" title="(tp: Types.this.Type)Boolean">containsSkolemAboveLevel</a><span class="delimiter">(</span><a href="#137007" title="Types.this.Type">tp</a><span class="delimiter">)</span>  // side-effects tracking boolean
      <span title="(x: Boolean)Boolean">||</span> <a href="#38793" title="=&gt; Boolean">enableTypeVarExperimentals</a>     // -Xexperimental: always say we're relatable, track consequences
    <span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="83991">normalize</a>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">(</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84071" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84069" title="=&gt; Types.this.Type">inst</a>
      // get here when checking higher-order subtyping of the typevar by itself
      // TODO: check whether this ever happens?
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#83967" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#38944" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#83965" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#83974" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#83965" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#137092" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46625" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#38912" title="Types.this.TypeVar" class="keyword">super</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a>
    <span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Symbol" id="83992">typeSymbol</a> = <a href="#136207" title="=&gt; Types.this.Type">origin</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83993">isStable</a> = <a href="#136207" title="=&gt; Types.this.Type">origin</a>.<a href="#41491" title="=&gt; Boolean">isStable</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="83994">isVolatile</a> = <a href="#136207" title="=&gt; Types.this.Type">origin</a>.<a href="#41492" title="=&gt; Boolean">isVolatile</a>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)String" id="83995">tparamsOfSym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="136571">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#136571" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="String">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="136574">tparams</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#136574" title="List[Types.this.Symbol]">tparams</a>.<span title="=&gt; Boolean">nonEmpty</span> =&gt;
        <a href="#136574" title="List[Types.this.Symbol]">tparams</a> <span title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],String,List[String]])List[String]">map</span> <span class="delimiter">(</span><a href="#136591" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46757" title="=&gt; String">defString</a><span class="delimiter">)</span> <span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="String(&quot;&quot;)">_</span> =&gt; <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="=&gt; String" id="83996">originName</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="136382">name</a> = <a href="#136207" title="=&gt; Types.this.Type">origin</a>.<a href="#41506" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>.<a href="Symbols.scala.html#46575" title="=&gt; String">decodedName</a>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#136382" title="String">name</a> <span title="(x$1: CharSequence)Boolean">contains</span> <span title="String(&quot;_$&quot;)" class="string">&quot;_$&quot;</span><span class="delimiter">)</span> <a href="#136207" title="=&gt; Types.this.Type">origin</a>.<a href="#41506" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>.<a href="Symbols.scala.html#46575" title="=&gt; String">decodedName</a> <span class="keyword">else</span> <a href="#136382" title="String">name</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="=&gt; String" id="83997">originLocation</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="136469">sym</a>  = <a href="#136207" title="=&gt; Types.this.Type">origin</a>.<a href="#41506" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="136470">encl</a> = <a href="#136469" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#46687" title="=&gt; Types.this.Symbol">logicallyEnclosingMember</a>
      
      // This should display somewhere between one and three
      // things which enclose the origin: at most, a class, a
      // a method, and a term.  At least, a class.
      <span title="(xs: Option[Types.this.Symbol]*)List[Option[Types.this.Symbol]]">List</span><span class="delimiter">(</span>
        <span title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</span><span class="delimiter">(</span><a href="#136470" title="Types.this.Symbol">encl</a>.<a href="Symbols.scala.html#46662" title="=&gt; Types.this.Symbol">enclClass</a><span class="delimiter">)</span>,
        <span title="Option[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#136470" title="Types.this.Symbol">encl</a>.<a href="Symbols.scala.html#46461" title="=&gt; Boolean">isMethod</a><span class="delimiter">)</span> <span title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</span><span class="delimiter">(</span><a href="#136470" title="Types.this.Symbol">encl</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="object None">None</span>,
        <span title="Option[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#136469" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#46443" title="=&gt; Boolean">isTerm</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#136469" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#136470" title="Types.this.Symbol">encl</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</span><span class="delimiter">(</span><a href="#136469" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="object None">None</span>
      <span class="delimiter">)</span>.<a href="#136548" title="(implicit asTraversable: Option[Types.this.Symbol] =&gt; scala.collection.GenTraversableOnce[Types.this.Symbol])List[Types.this.Symbol]">flatten</a> <span title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],String,List[String]])List[String]">map</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="136570">s</a> =&gt; <a href="#136570" title="Types.this.Symbol">s</a>.<a href="Symbols.scala.html#46575" title="=&gt; String">decodedName</a> <span title="(x$1: Any)String">+</span> <a href="#83995" title="(sym: Types.this.Symbol)String">tparamsOfSym</a><span class="delimiter">(</span><a href="#136570" title="Types.this.Symbol">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(sep: String)String">mkString</span> <span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span>
    <span class="delimiter">}</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Any" id="83998">levelString</a> = <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74516" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">explaintypes</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#83972" title="=&gt; Int">level</a> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; String" id="83999">typeVarString</a> = <a href="#83996" title="=&gt; String">originName</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84000">safeToString</a> = <span class="delimiter">(</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84069" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;TVar&lt;&quot;)" class="string">&quot;TVar&lt;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#83996" title="=&gt; String">originName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;=null&gt;&quot;)" class="string">&quot;=null&gt;&quot;</span>
      <span class="keyword">else</span> <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84069" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84069" title="=&gt; Types.this.Type">inst</a>
      <span class="keyword">else</span> <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#83998" title="=&gt; Any">levelString</a> <span title="(x$1: Any)String">+</span> <a href="#83996" title="=&gt; String">originName</a>
    <span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="84001">kind</a> = <span title="String(&quot;TypeVar&quot;)" class="string">&quot;TypeVar&quot;</span>

    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeVar" id="84002">cloneInternal</a> = <span class="delimiter">{</span>
      // cloning a suspended type variable when it's suspended will cause the clone
      // to never be resumed with the current implementation
      <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#83983" title="=&gt; Boolean">suspended</a>, <a href="#38912" title="Types.this.TypeVar" class="keyword">this</a><span class="delimiter">)</span>
      <a href="#38905" title="object Types.this.TypeVar">TypeVar</a>.<a href="#84004" title="(action: String, msg: =&gt; String)(value: Types.this.TypeVar)Types.this.TypeVar">trace</a><span class="delimiter">(</span><span title="String(&quot;clone&quot;)" class="string">&quot;clone&quot;</span>, <a href="#83997" title="=&gt; String">originLocation</a><span class="delimiter">)</span><span class="delimiter">(</span>
        <a href="#84011" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#136207" title="=&gt; Types.this.Type">origin</a>, <a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a> <a href="#84072" title="=&gt; Types.this.TypeConstraint">cloneInternal</a>, <a href="#83966" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#83965" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span> // @M TODO: clone args/params?
      <span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A type carrying some annotations. Created by the typechecker
   *  when eliminating ''Annotated'' trees (see typedAnnotated).
   *
   *  @param annotations the list of annotations on the type
   *  @param underlying the type without the annotation
   *  @param selfsym a &quot;self&quot; symbol with type `underlying`;
   *    only available if -Yself-in-annots is turned on. Can be `NoSymbol`
   *    if it is not used.
   */
  case <span class="keyword">class</span> <a title="class AnnotatedType extends Types.this.Type with Types.this.RewrappingTypeProxy with ScalaObject with Product with Serializable" id="58221">AnnotatedType</a><a href="#58221" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="84230">annotations</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span>,
                           <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Type" id="84231">underlying</a>: <a href="#38813" title="Types.this.Type">Type</a>,
                           <span class="keyword">override</span> <span class="keyword">val</span> <a title="Types.this.Symbol" id="84232">selfsym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="#38809" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a> <span class="delimiter">{</span>

    <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#84230" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">isEmpty</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#84231" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.AnnotatedType" id="58290">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="137148">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#84230" title="List[Types.this.AnnotationInfo]" id="137166">copy</a><span class="delimiter">(</span>underlying = <a href="#137148" title="Types.this.Type" id="137164">tp</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="58291">isTrivial</a>: <span title="Boolean">Boolean</span> = <a href="#58292" title="=&gt; Boolean">isTrivial0</a>
    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="58293">isTrivial0</a> = <a href="#84231" title="=&gt; Types.this.Type">underlying</a>.<a href="#41489" title="=&gt; Boolean">isTrivial</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#84230" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="(p: Types.this.AnnotationInfo =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#137175" title="Types.this.AnnotationInfo">_</a>.<a href="AnnotationInfos.scala.html#45924" title="=&gt; Boolean">isTrivial</a><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="58294">safeToString</a> = <a href="#84230" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><a href="#84231" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">underlying</a> <span title="(other: String)String">+</span> <span title="String(&quot; @&quot;)" class="string">&quot; @&quot;</span>, <span title="String(&quot; @&quot;)" class="string">&quot; @&quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(p: Types.this.AnnotationInfo =&gt; Boolean)Types.this.Type" id="58295">filterAnnotations</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo =&gt; Boolean" id="137183">p</a>: AnnotationInfo =&gt; Boolean<span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#137187" title="(List[Types.this.AnnotationInfo], List[Types.this.AnnotationInfo])" class="delimiter">(</a><a href="#137186" title="List[Types.this.AnnotationInfo]" id="137187">yes</a>, <a href="#137186" title="List[Types.this.AnnotationInfo]" id="137188">no</a><span class="delimiter">)</span> = <a href="#84230" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a> <span title="(p: Types.this.AnnotationInfo =&gt; Boolean)(List[Types.this.AnnotationInfo], List[Types.this.AnnotationInfo])">partition</span> <a href="#137183" title="Types.this.AnnotationInfo =&gt; Boolean">p</a>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#137187" title="List[Types.this.AnnotationInfo]">yes</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#84231" title="=&gt; Types.this.Type">underlying</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#137188" title="List[Types.this.AnnotationInfo]">no</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#58221" title="Types.this.AnnotatedType" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#58221" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">copy</a><span class="delimiter">(</span>annotations = <a href="#137187" title="List[Types.this.AnnotationInfo]">yes</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="58296">setAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="137206">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#137206" title="List[Types.this.AnnotationInfo]">annots</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#84231" title="=&gt; Types.this.Type">underlying</a>
      <span class="keyword">else</span> <a href="#58221" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">copy</a><span class="delimiter">(</span>annotations = <a href="#137206" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span>

    /** Add a number of annotations to this type */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="58297">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="137209">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#137209" title="List[Types.this.AnnotationInfo]">annots</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#58221" title="Types.this.AnnotatedType" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#58221" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">copy</a><span class="delimiter">(</span><a href="#137209" title="List[Types.this.AnnotationInfo]">annots</a> <a href="#137212" title="(prefix: List[Types.this.AnnotationInfo])List[Types.this.AnnotationInfo]">:::</a> <a href="#58221" title="AnnotatedType.this.type" class="keyword">this</a>.<a href="#84230" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a><span class="delimiter">)</span>

    /** Remove any annotations from this type.
     *  TODO - is it allowed to nest AnnotatedTypes? If not then let's enforce
     *  that at creation.  At the moment if they do ever turn up nested this
     *  recursively calls withoutAnnotations.
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.Type" id="58298">withoutAnnotations</a> = <a href="#84231" title="=&gt; Types.this.Type">underlying</a>.<a href="#41598" title="=&gt; Types.this.Type">withoutAnnotations</a>

    /** Set the self symbol */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Types.this.AnnotatedType" id="58299">withSelfsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="137223">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#84230" title="List[Types.this.AnnotationInfo]" id="137228">copy</a><span class="delimiter">(</span>selfsym = <a href="#137223" title="Types.this.Symbol" id="137226">sym</a><span class="delimiter">)</span>

    /** Drop the annotations on the bounds, unless the low and high
     *  bounds are exactly tp.
     */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.TypeBounds" id="58300">bounds</a>: <a href="#62311" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#84231" title="=&gt; Types.this.Type">underlying</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a> <span title="Types.this.TypeBounds" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.TypeBounds">TypeBounds</span><span class="delimiter">(</span>_: <span class="keyword">this</span>.<span class="keyword">type</span>, _: <span class="keyword">this</span>.<span class="keyword">type</span><span class="delimiter">)</span> =&gt; <a href="#62285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#58221" title="Types.this.AnnotatedType" class="keyword">this</a>, <a href="#58221" title="Types.this.AnnotatedType" class="keyword">this</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.TypeBounds" id="137231">oftp</a>                                   =&gt; <a href="#137231" title="Types.this.TypeBounds">oftp</a>
    <span class="delimiter">}</span>

    // ** Replace formal type parameter symbols with actual type arguments. * /
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="58301">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="137232">formals</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="137233">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="137236">annotations1</a> = <a href="#84230" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="(f: Types.this.AnnotationInfo =&gt; Types.this.AnnotationInfo)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.AnnotationInfo],Types.this.AnnotationInfo,List[Types.this.AnnotationInfo]])List[Types.this.AnnotationInfo]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.AnnotationInfo,List[Types.this.AnnotationInfo]]" class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="137254">info</a> =&gt; <a href="AnnotationInfos.scala.html#45950" title="(atp: Types.this.Type, args: List[Types.this.Tree], assocs: List[(Types.this.Name, Types.this.ClassfileAnnotArg)])Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">(</span><a href="#137254" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#45914" title="=&gt; Types.this.Type">atp</a>.<a href="#41531" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span>
          <a href="#137232" title="List[Types.this.Symbol]">formals</a>, <a href="#137233" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>, <a href="#137254" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#45915" title="=&gt; List[Types.this.Tree]">args</a>, <a href="#137254" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#45916" title="=&gt; List[(Types.this.Name, Types.this.ClassfileAnnotArg)]">assocs</a><span class="delimiter">)</span>.<a href="AnnotationInfos.scala.html#45930" title="(pos: Types.this.Position)Types.this.AnnotationInfo">setPos</a><span class="delimiter">(</span><a href="#137254" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#45929" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="137237">underlying1</a> = <a href="#84231" title="=&gt; Types.this.Type">underlying</a>.<a href="#41531" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#137232" title="List[Types.this.Symbol]">formals</a>, <a href="#137233" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#137236" title="List[Types.this.AnnotationInfo]">annotations1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#84230" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#137237" title="Types.this.Type">underlying1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#84231" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#58221" title="Types.this.AnnotatedType" class="keyword">this</a>
      <span class="keyword">else</span> <a href="#58221" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#137236" title="List[Types.this.AnnotationInfo]">annotations1</a>, <a href="#137237" title="Types.this.Type">underlying1</a>, <a href="#84232" title="=&gt; Types.this.Symbol">selfsym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Return the base type sequence of tp, dropping the annotations, unless the base type sequence of tp
      * is precisely tp itself. */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Types.this.BaseTypeSeq" id="58302">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#39264" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
       <span class="keyword">val</span> <a title="Types.this.BaseTypeSeq" id="137296">oftp</a> = <a href="#84231" title="=&gt; Types.this.Type">underlying</a>.<a href="#41579" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
       <span title="Types.this.BaseTypeSeq" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#137296" title="Types.this.BaseTypeSeq">oftp</a>.<a href="BaseTypeSeqs.scala.html#59592" title="=&gt; Int">length</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="BaseTypeSeqs.scala.html#59595" title="(i: Int)Types.this.Type">oftp</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#84231" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span>
         <a href="BaseTypeSeqs.scala.html#39267" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">baseTypeSingletonSeq</a><span class="delimiter">(</span><a href="#58221" title="Types.this.AnnotatedType" class="keyword">this</a><span class="delimiter">)</span>
       <span class="keyword">else</span>
         <a href="#137296" title="Types.this.BaseTypeSeq">oftp</a>
     <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="58303">kind</a> = <span title="String(&quot;AnnotatedType&quot;)" class="string">&quot;AnnotatedType&quot;</span>
  <span class="delimiter">}</span>

  /** Creator for AnnotatedTypes.  It returns the underlying type if annotations.isEmpty
   *  rather than walking into the assertion.
   */
  <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.Type" id="38916">annotatedType</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="131458">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span>, <a title="Types.this.Type" id="131459">underlying</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="131462">selfsym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#131458" title="List[Types.this.AnnotationInfo]">annots</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#131459" title="Types.this.Type">underlying</a>
    <span class="keyword">else</span> <a href="#58221" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#131458" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#131459" title="Types.this.Type">underlying</a>, <a href="#131462" title="Types.this.Symbol">selfsym</a><span class="delimiter">)</span>

  <span class="keyword">object</span> <a title="object Types.this.AnnotatedType" id="137338">AnnotatedType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#7741" title="Types.this.AnnotatedTypeExtractor">AnnotatedTypeExtractor</a> <span class="delimiter">{</span> <span class="delimiter">}</span>

  /** A class representing types with a name. When an application uses
   *  named arguments, the named argument types for calling isApplicable
   *  are represented as NamedType.
   */
  case <span class="keyword">class</span> <a title="class NamedType extends Types.this.Type with ScalaObject with Product with Serializable" id="147879">NamedType</a><a href="#147879" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Name" id="147874">name</a>: <a href="Names.scala.html#38403" title="Types.this.Name">Name</a>, <a title="Types.this.Type" id="147875">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="137346">safeToString</a>: <span title="String">String</span> = <a href="#147874" title="=&gt; Types.this.Name">name</a>.<span title="()String">toString</span> <span title="(x$1: Any)String">+</span><span title="String(&quot;: &quot;)" class="string">&quot;: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#147875" title="=&gt; Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  /** A De Bruijn index referring to a previous type argument. Only used
   *  as a serialization format.
   */
  case <span class="keyword">class</span> <a title="class DeBruijnIndex extends Types.this.Type with ScalaObject with Product with Serializable" id="147843">DeBruijnIndex</a><a href="#147843" title="ScalaObject" class="delimiter">(</a><a title="Int" id="138282">level</a>: <span title="Int">Int</span>, <a title="Int" id="138283">idx</a>: <span title="Int">Int</span>, <a title="List[Types.this.Type]" id="138284">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="137402">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;De Bruijn index(&quot;)" class="string">&quot;De Bruijn index(&quot;</span><span title="(x$1: Any)String">+</span><a href="#138282" title="=&gt; Int">level</a><span title="(x$1: Any)String">+</span><span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span title="(x$1: Any)String">+</span><a href="#138283" title="=&gt; Int">idx</a><span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
  <span class="delimiter">}</span>

  /** A binder defining data associated with De Bruijn indices. Only used
   *  as a serialization format.
   */
  case <span class="keyword">class</span> <a title="class DeBruijnBinder extends Types.this.Type with ScalaObject with Product with Serializable" id="147839">DeBruijnBinder</a><a href="#147839" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Name]" id="138132">pnames</a>: <span title="List[Types.this.Name]">List</span><span class="delimiter">[</span>Name<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="138133">ptypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Type" id="138134">restpe</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="137471">safeToString</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="137483">kind</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#138132" title="=&gt; List[Types.this.Name]">pnames</a>.<span title="=&gt; Types.this.Name">head</span>.<a href="Names.scala.html#52125" title="=&gt; Boolean">isTypeName</a><span class="delimiter">)</span> <span title="String(&quot;poly&quot;)" class="string">&quot;poly&quot;</span> <span class="keyword">else</span> <span title="String(&quot;method&quot;)" class="string">&quot;method&quot;</span>
      <span title="String(&quot;De Bruijn &quot;)" class="string">&quot;De Bruijn &quot;</span><span title="(x$1: Any)String">+</span><a href="#137483" title="String">kind</a><span title="(x$1: Any)String">+</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span><span title="(x$1: Any)String">+</span><span class="delimiter">(</span><a href="#138132" title="=&gt; List[Types.this.Name]">pnames</a> <span title="(sep: String)String">mkString</span> <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span title="(x$1: Any)String">+</span><span title="String(&quot;;&quot;)" class="string">&quot;;&quot;</span><span title="(x$1: Any)String">+</span><span class="delimiter">(</span><a href="#138133" title="=&gt; List[Types.this.Type]">ptypes</a> <span title="(sep: String)String">mkString</span> <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span><span title="(x$1: Any)String">+</span><span title="String(&quot;;&quot;)" class="string">&quot;;&quot;</span><span title="(x$1: Any)String">+</span><a href="#138134" title="=&gt; Types.this.Type">restpe</a><span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A class representing an as-yet unevaluated type.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class LazyType extends Types.this.Type with ScalaObject" id="38926">LazyType</a> <a href="#38926" title="ScalaObject" class="keyword">extends</a> <a href="#38813" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="71661">isComplete</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="71662">complete</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="77402">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="71663">safeToString</a> = <span title="String(&quot;&lt;?&gt;&quot;)" class="string">&quot;&lt;?&gt;&quot;</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="71664">kind</a> = <span title="String(&quot;LazyType&quot;)" class="string">&quot;LazyType&quot;</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class LazyPolyType extends Types.this.LazyType with ScalaObject" id="38927">LazyPolyType</a><a href="#38927" title="ScalaObject" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="82657">typeParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38926" title="Types.this.LazyType">LazyType</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="82598">safeToString</a> =
      <span class="delimiter">(</span><span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#82657" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="TypeDebugging.scala.html#39432" title="(tp: Types.this.Type)String">typeParamsString</a><span class="delimiter">(</span><a href="#38927" title="Types.this.LazyPolyType" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#38927" title="Types.this.LazyPolyType" class="keyword">super</a>.<a href="#71663" title="=&gt; String">safeToString</a>
  <span class="delimiter">}</span>

  // def mkLazyType(tparams: Symbol*)(f: Symbol =&gt; Unit): LazyType = (
  //   if (tparams.isEmpty) new LazyType { override def complete(sym: Symbol) = f(sym) }
  //   else new LazyPolyType(tparams.toList) { override def complete(sym: Symbol) = f(sym) }
  // )

// Creators ---------------------------------------------------------------

  /** Rebind symbol `sym` to an overriding member in type `pre`. */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol" id="38928">rebind</a><span class="delimiter">(</span><a title="Types.this.Type" id="137552">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="137553">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
    <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#137553" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46466" title="=&gt; Boolean">isOverridableMember</a> <span title="(x: Boolean)Boolean">||</span> <a href="#137553" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#137552" title="Types.this.Type">pre</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span> <a href="#137553" title="Types.this.Symbol">sym</a>
    <span class="keyword">else</span> <a href="#137552" title="Types.this.Type">pre</a>.<a href="#41546" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#137553" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#46655" title="(cond: Types.this.Symbol =&gt; Boolean)Types.this.Symbol">suchThat</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="137563">sym</a> =&gt; <a href="#137563" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46444" title="=&gt; Boolean">isType</a> <span title="(x: Boolean)Boolean">||</span> <a href="#137563" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46534" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="Symbols.scala.html#46723" title="(alt: =&gt; Types.this.Symbol)Types.this.Symbol">orElse</a> <a href="#137553" title="Types.this.Symbol">sym</a>
  <span class="delimiter">}</span>

  /** Convert a `super` prefix to a this-type if `sym` is abstract or final. */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="38929">removeSuper</a><span class="delimiter">(</span><a title="Types.this.Type" id="137566">tp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="137567">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#137566" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">SuperType</span><span class="delimiter">(</span><a title="Types.this.Type" id="137569">thistp</a>, _<span class="delimiter">)</span> =&gt;
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#137567" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46549" title="=&gt; Boolean">isEffectivelyFinal</a> <span title="(x: Boolean)Boolean">||</span> <a href="#137567" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#46795" title="=&gt; Boolean">isDeferred</a><span class="delimiter">)</span> <a href="#137569" title="Types.this.Type">thistp</a>
      <span class="keyword">else</span> <a href="#137566" title="Types.this.Type">tp</a>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <a href="#137566" title="Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  /** The canonical creator for single-types */
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="38930">singleType</a><span class="delimiter">(</span><a title="Types.this.Type" id="118143">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="118144">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
      <a href="#118144" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>.<a href="#41519" title="=&gt; Types.this.Type">resultType</a>
    <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#118144" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46477" title="=&gt; Boolean">isRootPackage</a><span class="delimiter">)</span>
      <a href="#83165" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="Definitions.scala.html#44950" title="=&gt; Types.this.ModuleClassSymbol">RootClass</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="Types.this.Symbol" id="137572">sym1</a> = <a href="#38928" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#118143" title="Types.this.Type">pre</a>, <a href="#118144" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="137573">pre1</a> = <a href="#38929" title="(tp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">removeSuper</a><span class="delimiter">(</span><a href="#118143" title="Types.this.Type">pre</a>, <a href="#137572" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#137573" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#118143" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#137572" title="Types.this.Symbol">sym1</a> = <a href="#38928" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#137573" title="Types.this.Type">pre1</a>, <a href="#137572" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      <a href="#83207" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">SingleType</a><span class="delimiter">(</span><a href="#137573" title="Types.this.Type">pre1</a>, <a href="#137572" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** the canonical creator for a refined type with a given scope */
  <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type" id="38931">refinedType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="115418">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="115419">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Scope" id="115420">decls</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a>, <a title="Types.this.Position" id="115421">pos</a>: <span title="Types.this.Position">Position</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#115418" title="List[Types.this.Type]">parents</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="Definitions.scala.html#44986" title="=&gt; Types.this.Symbol">ObjectClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#115418" title="List[Types.this.Type]">parents</a>.<span title="=&gt; Types.this.Type">head</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.ClassSymbol" id="137576">clazz</a> = <a href="#115419" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#46429" title="(pos: Types.this.Position)Types.this.ClassSymbol">newRefinementClass</a><span class="delimiter">(</span><a href="#7741" title="=&gt; Types.this.Position">NoPosition</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.RefinedType" id="137577">result</a> = <a href="#60408" title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#115418" title="List[Types.this.Type]">parents</a>, <a href="#115420" title="Types.this.Scope">decls</a>, <a href="#137576" title="Types.this.ClassSymbol">clazz</a><span class="delimiter">)</span>
      <a href="#137576" title="Types.this.ClassSymbol">clazz</a>.<a href="Symbols.scala.html#46610" title="(info: Types.this.Type)clazz.type">setInfo</a><span class="delimiter">(</span><a href="#137577" title="Types.this.RefinedType">result</a><span class="delimiter">)</span>
      <a href="#137577" title="Types.this.RefinedType">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** The canonical creator for a refined type with an initially empty scope.
   *
   *  @param parents ...
   *  @param owner   ...
   *  @return        ...
   */
  <span class="keyword">def</span> <a title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type" id="38932">refinedType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="115413">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="115414">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
    <a href="#38931" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#115413" title="List[Types.this.Type]">parents</a>, <a href="#115414" title="Types.this.Symbol">owner</a>, <a href="Scopes.scala.html#39175" title="()Types.this.Scope">newScope</a>, <a href="#115414" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#46379" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type" id="38933">copyRefinedType</a><span class="delimiter">(</span><a title="Types.this.RefinedType" id="132365">original</a>: <a href="#60409" title="Types.this.RefinedType">RefinedType</a>, <a title="List[Types.this.Type]" id="132366">parents</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="132367">decls</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a><span class="delimiter">)</span> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#132366" title="List[Types.this.Type]">parents</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#132365" title="Types.this.RefinedType">original</a>.<a href="#83648" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#132367" title="Types.this.Scope">decls</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#132365" title="Types.this.RefinedType">original</a>.<a href="#83649" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#132365" title="Types.this.RefinedType">original</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="132370">owner</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#132365" title="Types.this.RefinedType">original</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a> <span class="keyword">else</span> <a href="#132365" title="Types.this.RefinedType">original</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="132371">result</a> = <a href="#38932" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#132366" title="List[Types.this.Type]">parents</a>, <a href="#132370" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="132372">syms1</a> = <a href="#132367" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60510" title="=&gt; List[Types.this.Symbol]">toList</a>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="132404">sym</a> &lt;- <a href="#132372" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)Unit">syms1</a><span class="delimiter">)</span>
        <a href="#132371" title="Types.this.Type">result</a>.<a href="#41536" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60499" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a><span class="delimiter">(</span><a href="#132404" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46657" title="(newOwner: Types.this.Symbol)Types.this.Symbol">cloneSymbol</a><span class="delimiter">(</span><a href="#132371" title="Types.this.Type">result</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="132373">syms2</a> = <a href="#132371" title="Types.this.Type">result</a>.<a href="#41536" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60510" title="=&gt; List[Types.this.Symbol]">toList</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="132374">resultThis</a> = <a href="#132371" title="Types.this.Type">result</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46667" title="=&gt; Types.this.Type">thisType</a>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="132435">sym</a> &lt;- <a href="#132373" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)Unit">syms2</a><span class="delimiter">)</span>
        <a href="#132435" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#46611" title="(f: Types.this.Type =&gt; Types.this.Type)sym.type">modifyInfo</a> <span class="delimiter">(</span><a href="#132438" title="Types.this.Type">_</a> <a href="#41562" title="(from: Types.this.Symbol, to: Types.this.Type, symsFrom: List[Types.this.Symbol], symsTo: List[Types.this.Symbol])Types.this.Type">substThisAndSym</a><span class="delimiter">(</span><a href="#132365" title="Types.this.RefinedType">original</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#132374" title="Types.this.Type">resultThis</a>, <a href="#132372" title="List[Types.this.Symbol]">syms1</a>, <a href="#132373" title="List[Types.this.Symbol]">syms2</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <a href="#132371" title="Types.this.Type">result</a>
    <span class="delimiter">}</span>

  /** The canonical creator for typerefs
   *  todo: see how we can clean this up a bit
   */
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="38934">typeRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="72752">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="72753">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="72754">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    // type alias selections are rebound in TypeMap (&quot;coevolved&quot;,
    // actually -- see #3731) e.g., when type parameters that are
    // referenced by the alias are instantiated in the prefix. See
    // pos/depmet_rebind_typealias.

    <span class="keyword">val</span> <a title="Types.this.Symbol" id="137590">sym1</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#72753" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46448" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span> <a href="#38928" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#72752" title="Types.this.Type">pre</a>, <a href="#72753" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#72753" title="Types.this.Symbol">sym</a>
    // don't expand cyclical type alias
    // we require that object is initialized, thus info.typeParams instead of typeParams.
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#137590" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46447" title="=&gt; Boolean">isAliasType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#137590" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41528" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#72754" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#137590" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46440" title="=&gt; Boolean">lockOK</a><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <span title="Types.this.RecoverableCyclicReference" class="keyword">new</span> <a href="#147833" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#137590" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="Types.this.Type" id="137591">pre1</a> = <a href="#72752" title="Types.this.Type">pre</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="137594">x</a>: <a href="#83425" title="Types.this.SuperType">SuperType</a> <span class="keyword">if</span> <a href="#137590" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46549" title="=&gt; Boolean">isEffectivelyFinal</a> <span title="(x: Boolean)Boolean">||</span> <a href="#137590" title="Types.this.Symbol">sym1</a>.<a href="HasFlags.scala.html#46795" title="=&gt; Boolean">isDeferred</a> =&gt;
        <a href="#137594" title="Types.this.SuperType">x</a>.<a href="#83439" title="=&gt; Types.this.Type">thistpe</a>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span>: <a href="#38848" title="Types.this.CompoundType">CompoundType</a> <span class="keyword">if</span> <a href="#137590" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46445" title="=&gt; Boolean">isClass</a> =&gt;
        // sharpen prefix so that it is maximal and still contains the class.
        <a href="#72752" title="Types.this.Type">pre</a>.<a href="#41513" title="=&gt; List[Types.this.Type]">parents</a>.<span title="=&gt; List[Types.this.Type]">reverse</span> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">dropWhile</span> <span class="delimiter">(</span><a href="#137602" title="Types.this.Type">_</a>.<a href="#41545" title="(name: Types.this.Name)Types.this.Symbol">member</a><span class="delimiter">(</span><a href="#137590" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#137590" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Types.this.Type">Nil</span>         =&gt; <a href="#72752" title="Types.this.Type">pre</a>
          <span class="keyword">case</span> <a title="Types.this.Type" id="137613">parent</a> :: _ =&gt; <a href="#137613" title="Types.this.Type">parent</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#72752" title="Types.this.Type">pre</a>
    <span class="delimiter">}</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#72752" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#137591" title="Types.this.Type">pre1</a><span class="delimiter">)</span>                                <a href="#62092" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#72752" title="Types.this.Type">pre</a>, <a href="#137590" title="Types.this.Symbol">sym1</a>, <a href="#72754" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#137590" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46448" title="=&gt; Boolean">isAbstractType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#137590" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46445" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span>  <a href="#38934" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#137591" title="Types.this.Type">pre1</a>, <a href="#38928" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#137591" title="Types.this.Type">pre1</a>, <a href="#137590" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>, <a href="#72754" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">else</span>                                            <a href="#38934" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#137591" title="Types.this.Type">pre1</a>, <a href="#137590" title="Types.this.Symbol">sym1</a>, <a href="#72754" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  // Optimization to avoid creating unnecessary new typerefs.
  <span class="keyword">def</span> <a title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="38935">copyTypeRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="126239">tp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="126240">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="126241">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="126242">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#126239" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="137614">pre0</a>, <a title="Types.this.Symbol" id="137615">sym0</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#126240" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#137614" title="Types.this.Type">pre0</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#137615" title="Types.this.Symbol">sym0</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#126241" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a> =&gt;
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#126241" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46447" title="=&gt; Boolean">isAliasType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#126241" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41528" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#126242" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#126241" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46440" title="=&gt; Boolean">lockOK</a><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">throw</span> <span title="Types.this.RecoverableCyclicReference" class="keyword">new</span> <a href="#147833" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#126241" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>

      <a href="#62092" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#126240" title="Types.this.Type">pre</a>, <a href="#126241" title="Types.this.Symbol">sym</a>, <a href="#126242" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <a href="#38934" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#126240" title="Types.this.Type">pre</a>, <a href="#126241" title="Types.this.Symbol">sym</a>, <a href="#126242" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** The canonical creator for implicit method types */
  <span class="keyword">def</span> <a title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.JavaMethodType" id="38936">JavaMethodType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="137627">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="137628">resultType</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38884" title="Types.this.JavaMethodType">JavaMethodType</a> =
    <span title="Types.this.JavaMethodType" class="keyword">new</span> <a href="#38884" title="Types.this.JavaMethodType">JavaMethodType</a><span class="delimiter">(</span><a href="#137627" title="List[Types.this.Symbol]">params</a>, <a href="#137628" title="Types.this.Type">resultType</a><span class="delimiter">)</span> // don't unique this!

  /** Create a new MethodType of the same class as tp, i.e. keep JavaMethodType */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type" id="38937">copyMethodType</a><span class="delimiter">(</span><a title="Types.this.Type" id="75557">tp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="75558">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="75559">restpe</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#75557" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.JavaMethodType">_</span>: <a href="#38884" title="Types.this.JavaMethodType">JavaMethodType</a> =&gt; <a href="#38936" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.JavaMethodType">JavaMethodType</a><span class="delimiter">(</span><a href="#75558" title="List[Types.this.Symbol]">params</a>, <a href="#75559" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.MethodType">_</span>                 =&gt; <a href="#62346" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#75558" title="List[Types.this.Symbol]">params</a>, <a href="#75559" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** A creator for intersection type where intersections of a single type are
   *  replaced by the type itself, and repeated parent classes are merged.
   *
   *  !!! Repeated parent classes are not merged - is this a bug in the
   *  comment or in the code?
   */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type" id="38938">intersectionType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="63910">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="63911">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#63910" title="List[Types.this.Type]">tps</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#137631" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="137642">tp</a><span class="delimiter">)</span> =&gt;
      <a href="#137642" title="Types.this.Type">tp</a>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
       <a href="#38932" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#63910" title="List[Types.this.Type]">tps</a>, <a href="#63911" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
/*
      def merge(tps: List[Type]): List[Type] = tps match {
        case tp :: tps1 =&gt;
          val tps1a = tps1 filter (_.typeSymbol.==(tp.typeSymbol))
          val tps1b = tps1 filter (_.typeSymbol.!=(tp.typeSymbol))
          mergePrefixAndArgs(tps1a, -1) match {
            case Some(tp1) =&gt; tp1 :: merge(tps1b)
            case None =&gt; throw new MalformedType(
              &quot;malformed type: &quot;+refinedType(tps, owner)+&quot; has repeated parent class &quot;+
              tp.typeSymbol+&quot; with incompatible prefixes or type arguments&quot;)
          }
        case _ =&gt; tps
      }
      refinedType(merge(tps), owner)
*/
  <span class="delimiter">}</span>

  /** A creator for intersection type where intersections of a single type are
   *  replaced by the type itself. */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type])Types.this.Type" id="38939">intersectionType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="63907">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#63907" title="List[Types.this.Type]">tps</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#137648" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="137659">tp</a><span class="delimiter">)</span> =&gt; <a href="#137659" title="Types.this.Type">tp</a>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#38932" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#63907" title="List[Types.this.Type]">tps</a>, <a href="#39021" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#63907" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** A creator for type applications */
  <span class="keyword">def</span> <a title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type" id="38940">appliedType</a><span class="delimiter">(</span><a title="Types.this.Type" id="69328">tycon</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="List[Types.this.Type]" id="69329">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#69329" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#69328" title="Types.this.Type">tycon</a> //@M! `if (args.isEmpty) tycon' is crucial (otherwise we create new types in phases after typer and then they don't get adapted (??))
    <span class="keyword">else</span> <a href="#69328" title="Types.this.Type">tycon</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="137670">pre</a>, <a title="Types.this.Symbol" id="137671">sym</a> @ <span class="delimiter">(</span><a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a>|<a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#38935" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#69328" title="Types.this.Type">tycon</a>, <a href="#137670" title="Types.this.Type">pre</a>, <a href="#137671" title="Types.this.Symbol">sym</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span>   //@M drop type args to Any/Nothing
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="137672">pre</a>, <a title="Types.this.Symbol" id="137673">sym</a>, _<span class="delimiter">)</span>                           =&gt; <a href="#38935" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#69328" title="Types.this.Type">tycon</a>, <a href="#137672" title="Types.this.Type">pre</a>, <a href="#137673" title="Types.this.Symbol">sym</a>, <a href="#69329" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="137674">tparams</a>, <a title="Types.this.Type" id="137675">restpe</a><span class="delimiter">)</span>                      =&gt; <a href="#137675" title="Types.this.Type">restpe</a>.<a href="#41531" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#137674" title="List[Types.this.Symbol]">tparams</a>, <a href="#69329" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="137676">tparams</a>, <a title="Types.this.Type" id="137677">restpe</a><span class="delimiter">)</span>               =&gt; <a href="#38891" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">(</span><a href="#137676" title="List[Types.this.Symbol]">tparams</a>, <a href="#38940" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#137677" title="Types.this.Type">restpe</a>, <a href="#69329" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="137678">st</a>: <a href="#38819" title="Types.this.SingletonType">SingletonType</a>                              =&gt; <a href="#38940" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#137678" title="Types.this.SingletonType">st</a>.<a href="#83171" title="=&gt; Types.this.Type">widen</a>, <a href="#69329" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> // @M TODO: what to do? see bug1
      <span class="keyword">case</span> <span title="Types.this.RefinedType">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="137679">parents</a>, <a title="Types.this.Scope" id="137680">decls</a><span class="delimiter">)</span>                    =&gt; <a href="#60409" title="(parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#137679" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#38940" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#137703" title="Types.this.Type">_</a>, <a href="#69329" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#137680" title="Types.this.Scope">decls</a><span class="delimiter">)</span> // MO to AM: please check
      <span class="keyword">case</span> <span title="Types.this.TypeBounds">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="137731">lo</a>, <a title="Types.this.Type" id="137732">hi</a><span class="delimiter">)</span>                             =&gt; <a href="#62285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#38940" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#137731" title="Types.this.Type">lo</a>, <a href="#69329" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, <a href="#38940" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#137732" title="Types.this.Type">hi</a>, <a href="#69329" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.TypeVar" id="137733">tv</a>@<a href="#84008" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span>                               =&gt; <a href="#137733" title="Types.this.TypeVar">tv</a>.<a href="#83974" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#69329" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.AnnotatedType">AnnotatedType</span><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="137735">annots</a>, <a title="Types.this.Type" id="137736">underlying</a>, <a title="Types.this.Symbol" id="137737">self</a><span class="delimiter">)</span>        =&gt; <a href="#58221" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#137735" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#38940" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#137736" title="Types.this.Type">underlying</a>, <a href="#69329" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, <a href="#137737" title="Types.this.Symbol">self</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="#131624" title="Types.this.Type">ErrorType</a>                                      =&gt; <a href="#69328" title="Types.this.Type">tycon</a>
      <span class="keyword">case</span> <a href="#131644" title="Types.this.Type">WildcardType</a>                                   =&gt; <a href="#69328" title="Types.this.Type">tycon</a> // needed for neg/t0226
      <span class="keyword">case</span> <span title="Nothing">_</span>                                              =&gt; <a href="SymbolTable.scala.html#35603" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><a href="TypeDebugging.scala.html#39434" title="(tp: Types.this.Type)String">debugString</a><span class="delimiter">(</span><a href="#69328" title="Types.this.Type">tycon</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  
  /** A creator for existential types where the type arguments,
   *  rather than being applied directly, are interpreted as the
   *  upper bounds of unknown types.  For instance if the type argument
   *  list given is List(AnyRefClass), the resulting type would be
   *  e.g. Set[_ &lt;: AnyRef] rather than Set[AnyRef] .
   */
  <span class="keyword">def</span> <a title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type" id="38941">appliedTypeAsUpperBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="73658">tycon</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="List[Types.this.Type]" id="73659">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <a href="#73658" title="Types.this.Type">tycon</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="137743">pre</a>, <a title="Types.this.Symbol" id="137744">sym</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#137744" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#73659" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="137747">eparams</a>  = <a href="#38987" title="(clazz: Types.this.Symbol)List[Types.this.Symbol]">typeParamsToExistentials</a><span class="delimiter">(</span><a href="#137744" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.TypeBounds]" id="137748">bounds</a>   = <a href="#73659" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.TypeBounds)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.TypeBounds,List[Types.this.TypeBounds]])List[Types.this.TypeBounds]">map</span> <span class="delimiter">(</span><a href="#132015" title="object Types.this.TypeBounds">TypeBounds</a> <a href="#62283" title="(hi: Types.this.Type)Types.this.TypeBounds">upper</a> <a href="#137769" title="Types.this.Type">_</a><span class="delimiter">)</span> 
        <span title="(_1: List[Types.this.Symbol], _2: List[Types.this.TypeBounds])(List[Types.this.Symbol], List[Types.this.TypeBounds])" class="delimiter">(</span><a href="#137747" title="List[Types.this.Symbol]">eparams</a>, <a href="#137748" title="List[Types.this.TypeBounds]">bounds</a><span class="delimiter">)</span>.<span title="(implicit w1: List[Types.this.Symbol] =&gt; scala.collection.TraversableLike[Types.this.Symbol,List[Types.this.Symbol]], implicit w2: List[Types.this.TypeBounds] =&gt; scala.collection.IterableLike[Types.this.TypeBounds,List[Types.this.TypeBounds]])(List[Types.this.Symbol], List[Types.this.TypeBounds])#Zipped[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.TypeBounds],Types.this.TypeBounds]">zipped</span> <span title="(f: (Types.this.Symbol, Types.this.TypeBounds) =&gt; Types.this.Symbol)Unit">foreach</span> <span class="delimiter">(</span><a href="#137851" title="Types.this.Symbol">_</a> <a href="Symbols.scala.html#46610" title="(info: Types.this.Type)x$64.type">setInfo</a> <a href="#137852" title="Types.this.TypeBounds">_</a><span class="delimiter">)</span>

        <a href="#38891" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">(</span><a href="#137747" title="List[Types.this.Symbol]">eparams</a>, <a href="#38934" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#137743" title="Types.this.Type">pre</a>, <a href="#137744" title="Types.this.Symbol">sym</a>, <a href="#137747" title="List[Types.this.Symbol]">eparams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#137875" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#38940" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#73658" title="Types.this.Type">tycon</a>, <a href="#73659" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A creator for type parameterizations that strips empty type parameter lists.
   *  Use this factory method to indicate the type has kind * (it's a polymorphic value)
   *  until we start tracking explicit kinds equivalent to typeFun (except that the latter requires tparams nonEmpty).
   *
   *  PP to AM: I've co-opted this for where I know tparams may well be empty, and
   *  expecting to get back `tpe` in such cases.  Re being &quot;forgiving&quot; below,
   *  can we instead say this is the canonical creator for polyTypes which
   *  may or may not be poly? (It filched the standard &quot;canonical creator&quot; name.)
   */
  <span class="keyword">def</span> <a title="(tparams: List[Types.this.Symbol], tpe: Types.this.Type)Types.this.Type" id="38942">polyType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="74630">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="74631">tpe</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#74630" title="List[Types.this.Symbol]">tparams</a> <span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#38944" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#74630" title="List[Types.this.Symbol]">tparams</a>, <a href="#74631" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <a href="#74631" title="Types.this.Type">tpe</a> // it's okay to be forgiving here

  /** A creator for anonymous type functions, where the symbol for the type function still needs to be created.
   *
   * TODO:
   * type params of anonymous type functions, which currently can only arise from normalising type aliases, are owned by the type alias of which they are the eta-expansion
   * higher-order subtyping expects eta-expansion of type constructors that arise from a class; here, the type params are owned by that class, but is that the right thing to do?
   */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type" id="38943">typeFunAnon</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="134152">tps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="134153">body</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#38944" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#134152" title="List[Types.this.Symbol]">tps</a>, <a href="#134153" title="Types.this.Type">body</a><span class="delimiter">)</span>

  /** A creator for a type functions, assuming the type parameters tps already have the right owner. */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type" id="38944">typeFun</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="132735">tps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="132736">body</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#62451" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#132735" title="List[Types.this.Symbol]">tps</a>, <a href="#132736" title="Types.this.Type">body</a><span class="delimiter">)</span>

  /** A creator for existential types. This generates:
   *
   *  tpe1 where { tparams }
   *
   *  where `tpe1` is the result of extrapolating `tpe` wrt to `tparams`.
   *  Extrapolating means that type variables in `tparams` occurring
   *  in covariant positions are replaced by upper bounds, (minus any
   *  SingletonClass markers), type variables in `tparams` occurring in
   *  contravariant positions are replaced by upper bounds, provided the
   *  resulting type is legal wrt to stability, and does not contain any type
   *  variable in `tparams`.
   *
   *  The abstraction drops all type parameters that are not directly or
   *  indirectly referenced by type `tpe1`. If there are no remaining type
   *  parameters, simply returns result type `tpe`.
   */
  <span class="keyword">def</span> <a title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type" id="38945">existentialAbstraction</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="75506">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="75507">tpe0</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#75506" title="List[Types.this.Symbol]">tparams</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#75507" title="Types.this.Type">tpe0</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="137903">tpe</a>      = <a href="#137909" title="(tp: Types.this.Type)Types.this.Type">deAlias</a><span class="delimiter">(</span><a href="#75507" title="Types.this.Type">tpe0</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="137904">tpe1</a>     = <span title="Types.this.ExistentialExtrapolation" class="keyword">new</span> <a href="#38992" title="Types.this.ExistentialExtrapolation">ExistentialExtrapolation</a><span class="delimiter">(</span><a href="#75506" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <a href="#137927" title="(tpe: Types.this.Type)Types.this.Type">extrapolate</a> <a href="#137903" title="Types.this.Type">tpe</a>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="137905">tparams0</a> = <a href="#75506" title="List[Types.this.Symbol]">tparams</a>
      <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="137906">tparams1</a> = <a href="#137905" title="List[Types.this.Symbol]">tparams0</a> <span title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">filter</span> <a href="#137904" title="Types.this.Type">tpe1</a>.<a href="#41569" title="(sym: Types.this.Symbol)Boolean">contains</a>

      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#137906" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#137905" title="List[Types.this.Symbol]">tparams0</a><span class="delimiter">)</span> <a href="#137907" title="()Unit" class="delimiter">{</a>
        <a href="#137905" title="List[Types.this.Symbol]">tparams0</a> = <a href="#137906" title="List[Types.this.Symbol]">tparams1</a>
        <a href="#137906" title="List[Types.this.Symbol]">tparams1</a> = <a href="#75506" title="List[Types.this.Symbol]">tparams</a> <span title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">filter</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="137949">p</a> =&gt;
          <a href="#137906" title="List[Types.this.Symbol]">tparams1</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="137958">p1</a> =&gt; <a href="#137958" title="Types.this.Symbol">p1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#137949" title="Types.this.Symbol">p</a> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#137958" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a> <a href="#41569" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#137949" title="Types.this.Symbol">p</a><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#38891" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">(</span><a href="#137906" title="List[Types.this.Symbol]">tparams1</a>, <a href="#137904" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  /** Remove any occurrences of type aliases from this type */
  <span class="keyword">object</span> <a title="object Types.this.deAlias" id="38946">deAlias</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="137909">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="137910">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a> <span class="delimiter">{</span>
      <a href="#137910" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="137974">pre</a>, <a title="Types.this.Symbol" id="137975">sym</a>, <a title="List[Types.this.Type]" id="137976">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#137975" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46447" title="=&gt; Boolean">isAliasType</a> =&gt; <a href="#137910" title="Types.this.Type">tp</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#137910" title="Types.this.Type">tp</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Remove any occurrence of type &lt;singleton&gt; from this type and its parents */
  <span class="keyword">object</span> <a title="object Types.this.dropSingletonType" id="38948">dropSingletonType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="117163">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="117164">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#117164" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span>_, <a href="Definitions.scala.html#45085" title="=&gt; Types.this.Symbol">SingletonClass</a>, _<span class="delimiter">)</span> =&gt;
          <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>
        <span class="keyword">case</span> <a title="Types.this.Type" id="137978">tp1</a> @ RefinedType<span class="delimiter">(</span><a title="List[Types.this.Type]" id="137979">parents</a>, <a title="Types.this.Scope" id="137980">decls</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">var</span> <a title="List[Types.this.Type]" id="137981">parents1</a> = <a href="#137979" title="List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a href="#137985" title="Types.this.Type">_</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#45085" title="=&gt; Types.this.Symbol">SingletonClass</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#137981" title="List[Types.this.Type]">parents1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#137981" title="List[Types.this.Type]">parents1</a> = <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#137981" title="List[Types.this.Type]">parents1</a>.<span title="=&gt; List[Types.this.Type]">tail</span>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#137980" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60495" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#137981" title="List[Types.this.Type]">parents1</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#38933" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#137978" title="Types.this.RefinedType">tp1</a>, <a href="#137981" title="List[Types.this.Type]">parents1</a>, <a href="#137980" title="Types.this.Scope">decls</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <a title="Types.this.Type" id="138018">tp1</a> =&gt;
          <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#138018" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Substitutes the empty scope for any non-empty decls in the type. */
  <span class="keyword">object</span> <a title="object Types.this.dropAllRefinements" id="38950">dropAllRefinements</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="138028">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="138030">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#138030" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="138033">rt</a> @ RefinedType<span class="delimiter">(</span><a title="List[Types.this.Type]" id="138034">parents</a>, <a title="Types.this.Scope" id="138035">decls</a><span class="delimiter">)</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#138035" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60495" title="=&gt; Boolean">isEmpty</a> =&gt;
        <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#38933" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#138033" title="Types.this.RefinedType">rt</a>, <a href="#138034" title="List[Types.this.Type]">parents</a>, <a href="Scopes.scala.html#39180" title="object Types.this.EmptyScope">EmptyScope</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ClassInfoType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="138044">parents</a>, <a title="Types.this.Scope" id="138045">decls</a>, <a title="Types.this.Symbol" id="138046">clazz</a><span class="delimiter">)</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#138045" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60495" title="=&gt; Boolean">isEmpty</a> =&gt;
        <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#70033" title="(parents: List[Types.this.Type], decls: Types.this.Scope, typeSymbol: Types.this.Symbol)Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">(</span><a href="#138044" title="List[Types.this.Type]">parents</a>, <a href="Scopes.scala.html#39180" title="object Types.this.EmptyScope">EmptyScope</a>, <a href="#138046" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#138030" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  /** Type with all top-level occurrences of abstract types replaced by their bounds */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="38952">abstractTypesToBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="138066">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#138066" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span> // @M don't normalize here (compiler loops on pos/bug1090.scala )
    <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="138068">sym</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#138068" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46448" title="=&gt; Boolean">isAbstractType</a> =&gt;
      <a href="#38952" title="(tp: Types.this.Type)Types.this.Type">abstractTypesToBounds</a><span class="delimiter">(</span><a href="#138066" title="Types.this.Type">tp</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="138069">sym</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#138069" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46447" title="=&gt; Boolean">isAliasType</a> =&gt;
      <a href="#38952" title="(tp: Types.this.Type)Types.this.Type">abstractTypesToBounds</a><span class="delimiter">(</span><a href="#138066" title="Types.this.Type">tp</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="Types.this.Type" id="138070">rtp</a> @ RefinedType<span class="delimiter">(</span><a title="List[Types.this.Type]" id="138071">parents</a>, <a title="Types.this.Scope" id="138072">decls</a><span class="delimiter">)</span> =&gt;
      <a href="#38933" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#138070" title="Types.this.RefinedType">rtp</a>, <a href="#138071" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <a href="#38952" title="(tp: Types.this.Type)Types.this.Type">abstractTypesToBounds</a>, <a href="#138072" title="Types.this.Scope">decls</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">AnnotatedType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="138081">underlying</a>, _<span class="delimiter">)</span> =&gt;
      <a href="#38952" title="(tp: Types.this.Type)Types.this.Type">abstractTypesToBounds</a><span class="delimiter">(</span><a href="#138081" title="Types.this.Type">underlying</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <a href="#138066" title="Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  // Set to true for A* =&gt; Seq[A]
  //   (And it will only rewrite A* in method result types.)
  //   This is the pre-existing behavior.
  // Or false for Seq[A] =&gt; Seq[A]
  //   (It will rewrite A* everywhere but method parameters.)
  //   This is the specified behavior.
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="38953">etaExpandKeepsStar</a> = <span title="Boolean(false)" class="keyword">false</span>

  <span class="keyword">object</span> <a title="object Types.this.dropRepeatedParamType" id="38954">dropRepeatedParamType</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="138086">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="138088">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#138088" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.MethodType">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="138091">params</a>, <a title="Types.this.Type" id="138092">restpe</a><span class="delimiter">)</span> =&gt;
        <a href="#62346" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#138091" title="List[Types.this.Symbol]">params</a>, <a href="#138086" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#138092" title="Types.this.Type">restpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.PolyType">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="138094">tparams</a>, <a title="Types.this.Type" id="138095">restpe</a><span class="delimiter">)</span> =&gt;
        <a href="#62451" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#138094" title="List[Types.this.Symbol]">tparams</a>, <a href="#138086" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#138095" title="Types.this.Type">restpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span>_, <a href="Definitions.scala.html#45105" title="=&gt; Types.this.Symbol">RepeatedParamClass</a>, <a title="Types.this.Type" id="138100">arg</a> :: <span title="object Nil">Nil</span><span class="delimiter">)</span> =&gt;
        <a href="Definitions.scala.html#45267" title="(arg: Types.this.Type)Types.this.Type">seqType</a><span class="delimiter">(</span><a href="#138100" title="Types.this.Type">arg</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#38953" title="=&gt; Boolean">etaExpandKeepsStar</a><span class="delimiter">)</span> <a href="#138088" title="Types.this.Type">tp</a> <span class="keyword">else</span> <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#138088" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.toDeBruijn" id="38956">toDeBruijn</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[List[Types.this.Symbol]]" id="138112">paramStack</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="object Nil">Nil</span>
    <span class="keyword">def</span> <a title="(params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.DeBruijnBinder" id="138114">mkDebruijnBinder</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="138118">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="138119">restpe</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#138112" title="(x$1: List[List[Types.this.Symbol]])Unit">paramStack</a> = <a href="#138118" title="List[Types.this.Symbol]">params</a> <a href="#138122" title="(x: List[Types.this.Symbol])List[List[Types.this.Symbol]]">::</a> <a href="#138112" title="=&gt; List[List[Types.this.Symbol]]">paramStack</a>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#147839" title="(pnames: List[Types.this.Name], ptypes: List[Types.this.Type], restpe: Types.this.Type)Types.this.DeBruijnBinder">DeBruijnBinder</a><span class="delimiter">(</span><a href="#138118" title="List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Name)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Name,List[Types.this.Name]])List[Types.this.Name]">map</span> <span class="delimiter">(</span><a href="#138158" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>, <a href="#138118" title="List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="138207">p</a> =&gt; <a href="#138115" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138207" title="Types.this.Symbol">p</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#138115" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138119" title="Types.this.Type">restpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <a href="#138112" title="(x$1: List[List[Types.this.Symbol]])Unit">paramStack</a> = <a href="#138112" title="=&gt; List[List[Types.this.Symbol]]">paramStack</a>.<span title="=&gt; List[List[Types.this.Symbol]]">tail</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="138115">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="138208">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#138208" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.DeBruijnBinder">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="138244">tparams</a>, <a title="Types.this.Type" id="138245">restpe</a><span class="delimiter">)</span> =&gt;
        <a href="#138114" title="(params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.DeBruijnBinder">mkDebruijnBinder</a><span class="delimiter">(</span><a href="#138244" title="List[Types.this.Symbol]">tparams</a>, <a href="#138245" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.DeBruijnBinder">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="138246">params</a>, <a title="Types.this.Type" id="138247">restpe</a><span class="delimiter">)</span> =&gt;
        <a href="#138114" title="(params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.DeBruijnBinder">mkDebruijnBinder</a><span class="delimiter">(</span><a href="#138246" title="List[Types.this.Symbol]">params</a>, <a href="#138247" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="138248">sym</a>, <a title="List[Types.this.Type]" id="138249">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Int" id="138250">level</a> = <a href="#138112" title="=&gt; List[List[Types.this.Symbol]]">paramStack</a> <span title="(p: List[Types.this.Symbol] =&gt; Boolean)Int">indexWhere</span> <span class="delimiter">(</span><a href="#138265" title="List[Types.this.Symbol]">_</a> <span title="(elem: Any)Boolean">contains</span> <a href="#138248" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#138250" title="Int">level</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#138208" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#147843" title="(level: Int, idx: Int, args: List[Types.this.Type])Types.this.DeBruijnIndex">DeBruijnIndex</a><span class="delimiter">(</span><a href="#138250" title="Int">level</a>, <a href="#138112" title="(n: Int)List[Types.this.Symbol]">paramStack</a><span class="delimiter">(</span><a href="#138250" title="Int">level</a><span class="delimiter">)</span> <span title="(elem: Types.this.Symbol)Int">indexOf</span> <a href="#138248" title="Types.this.Symbol">sym</a>, <a href="#138249" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="keyword">this</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#138208" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(owner: Types.this.Symbol)Types.this.TypeMap" id="38958">fromDeBruijn</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="138329">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#138332" title="Types.this.TypeMap{}" class="keyword">new</a> <a href="#38980" title="anonymous class $anon extends Types.this.TypeMap" id="138332">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[List[Types.this.Symbol]]" id="138335">paramStack</a>: <span title="List[List[Types.this.Symbol]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="object Nil">Nil</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="138337">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="138338">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#138338" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">DeBruijnBinder</span><span class="delimiter">(</span><a title="List[Types.this.Name]" id="138369">pnames</a>, <a title="List[Types.this.Type]" id="138370">ptypes</a>, <a title="Types.this.Type" id="138371">restpe</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Boolean" id="138372">isType</a> = <a href="#138369" title="List[Types.this.Name]">pnames</a>.<span title="=&gt; Types.this.Name">head</span>.<a href="Names.scala.html#52125" title="=&gt; Boolean">isTypeName</a>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="138373">newParams</a> = <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Name" id="138391">name</a> &lt;- <a href="#138369" title="(f: Types.this.Name =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Name],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">pnames</a><span class="delimiter">)</span> <span class="keyword">yield</span>
          <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#138372" title="Boolean">isType</a><span class="delimiter">)</span> <a href="#138329" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#46411" title="(name: Types.this.TypeName, pos: Types.this.Position, newFlags: Long)Types.this.Symbol">newTypeParameter</a><span class="delimiter">(</span><a href="#138391" title="Types.this.Name">name</a>.<a href="Names.scala.html#52127" title="=&gt; Types.this.TypeName">toTypeName</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#138329" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#46385" title="(name: Types.this.TermName, pos: Types.this.Position, newFlags: Long)Types.this.TermSymbol">newValueParameter</a><span class="delimiter">(</span><a href="#138391" title="Types.this.Name">name</a>.<a href="Names.scala.html#52126" title="=&gt; Types.this.TermName">toTermName</a><span class="delimiter">)</span>
        <a href="#138335" title="(x$1: List[List[Types.this.Symbol]])Unit">paramStack</a> = <a href="#138373" title="List[Types.this.Symbol]">newParams</a> <a href="#138425" title="(x: List[Types.this.Symbol])List[List[Types.this.Symbol]]">::</a> <a href="#138335" title="=&gt; List[List[Types.this.Symbol]]">paramStack</a>
        <span class="keyword">try</span> <span class="delimiter">{</span>
          <span title="(_1: List[Types.this.Symbol], _2: List[Types.this.Type])(List[Types.this.Symbol], List[Types.this.Type])" class="delimiter">(</span><a href="#138373" title="List[Types.this.Symbol]">newParams</a>, <a href="#138370" title="List[Types.this.Type]">ptypes</a><span class="delimiter">)</span>.<span title="(implicit w1: List[Types.this.Symbol] =&gt; scala.collection.TraversableLike[Types.this.Symbol,List[Types.this.Symbol]], implicit w2: List[Types.this.Type] =&gt; scala.collection.IterableLike[Types.this.Type,List[Types.this.Type]])(List[Types.this.Symbol], List[Types.this.Type])#Zipped[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Type],Types.this.Type]">zipped</span> <span title="(f: (Types.this.Symbol, Types.this.Type) =&gt; Types.this.Symbol)Unit">foreach</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="138482">p</a>, <a title="Types.this.Type" id="138483">t</a><span class="delimiter">)</span> =&gt; <a href="#138482" title="Types.this.Symbol">p</a> <a href="Symbols.scala.html#46610" title="(info: Types.this.Type)p.type">setInfo</a> <a href="#138337" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138483" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="138429">restpe1</a> = <a href="#138337" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138371" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#138372" title="Boolean">isType</a><span class="delimiter">)</span> <a href="#62451" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#138373" title="List[Types.this.Symbol]">newParams</a>, <a href="#138429" title="Types.this.Type">restpe1</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#62346" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#138373" title="List[Types.this.Symbol]">newParams</a>, <a href="#138429" title="Types.this.Type">restpe1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <a href="#138335" title="(x$1: List[List[Types.this.Symbol]])Unit">paramStack</a> = <a href="#138335" title="=&gt; List[List[Types.this.Symbol]]">paramStack</a>.<span title="=&gt; List[List[Types.this.Symbol]]">tail</span>
      <span class="keyword">case</span> <span title="Types.this.Type">DeBruijnIndex</span><span class="delimiter">(</span><a title="Int" id="138533">level</a>, <a title="Int" id="138534">idx</a>, <a title="List[Types.this.Type]" id="138535">args</a><span class="delimiter">)</span> =&gt;
        <a href="#62092" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="#138335" title="(n: Int)List[Types.this.Symbol]">paramStack</a><span title="(n: Int)Types.this.Symbol" class="delimiter">(</span><a href="#138533" title="Int">level</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#138534" title="Int">idx</a><span class="delimiter">)</span>, <a href="#138535" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#138332" title="Types.this.TypeMap{}" class="keyword">this</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#138338" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

// Hash consing --------------------------------------------------------------

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="Int" id="38959">initialUniquesCapacity</a> = <span title="Int(4096)" class="int">4096</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="scala.reflect.internal.util.HashSet[Types.this.Type]" id="38962">uniques</a>: util.<a href="util/HashSet.scala.html#10865" title="scala.reflect.internal.util.HashSet[Types.this.Type]">HashSet</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = _
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="38965">uniqueRunId</a> = <span title="Int(0)">NoRunId</span>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="[T &lt;: Types.this.Type](tp: T)T" id="38967">unique</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Types.this.Type" id="38969">T</a> &lt;: Type<span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="131786">tp</a>: <a href="#38969" title="T">T</a><span class="delimiter">)</span>: <a href="#38969" title="T">T</a> = <span class="delimiter">{</span>
    <a href="util/StatBase.scala.html#38639" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38681" title="=&gt; scala.reflect.internal.util.Statistics.Counter">rawTypeCount</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#38965" title="=&gt; Int">uniqueRunId</a> <span title="(x: Int)Boolean">!=</span> <a href="SymbolTable.scala.html#35630" title="=&gt; Types.this.RunId">currentRunId</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#38962" title="(x$1: scala.reflect.internal.util.HashSet[Types.this.Type])Unit">uniques</a> = util.<a href="util/HashSet.scala.html#138636" title="[T &gt;: Null &lt;: AnyRef](label: String, initialCapacity: Int)scala.reflect.internal.util.HashSet[T]">HashSet</a><span title="(label: String, initialCapacity: Int)scala.reflect.internal.util.HashSet[Types.this.Type]" class="delimiter">[</span><a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="String(&quot;uniques&quot;)" class="string">&quot;uniques&quot;</span>, <a href="#38959" title="=&gt; Int">initialUniquesCapacity</a><span class="delimiter">)</span>
      <a href="#38965" title="(x$1: Int)Unit">uniqueRunId</a> = <a href="SymbolTable.scala.html#35630" title="=&gt; Types.this.RunId">currentRunId</a>
    <span class="delimiter">}</span>
    <span class="delimiter">(</span><a href="#38962" title="=&gt; scala.reflect.internal.util.HashSet[Types.this.Type]">uniques</a> <a href="util/HashSet.scala.html#129829" title="(x: Types.this.Type)Types.this.Type">findEntryOrUpdate</a> <a href="#131786" title="T">tp</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#38969" title="T">T</a><span class="delimiter">]</span>
  <span class="delimiter">}</span>

// Helper Classes ---------------------------------------------------------

  /** @PP: Unable to see why these apparently constant types should need vals
   *  in every TypeConstraint, I lifted them out.
   */
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.Type" id="38971">numericLoBound</a> = <a href="Definitions.scala.html#45539" title="=&gt; Types.this.Symbol">IntClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.Type" id="38973">numericHiBound</a> = <a href="#38938" title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">intersectionType</a><span class="delimiter">(</span><span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="Definitions.scala.html#45533" title="=&gt; Types.this.Symbol">ByteClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>, <a href="Definitions.scala.html#45537" title="=&gt; Types.this.Symbol">CharClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>, <a href="Definitions.scala.html#44962" title="=&gt; Types.this.Symbol">ScalaPackageClass</a><span class="delimiter">)</span>

  /** A class expressing upper and lower bounds constraints of type variables,
   * as well as their instantiations.
   */
  <span class="keyword">class</span> <a title="class TypeConstraint extends Object with ScalaObject" id="38975">TypeConstraint</a><a href="#38975" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Type]" id="85003">lo0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="85004">hi0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Type" id="85005">numlo0</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="85006">numhi0</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Boolean" id="85009">avoidWidening0</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(lo0: List[Types.this.Type], hi0: List[Types.this.Type])Types.this.TypeConstraint" id="84043" class="keyword">this</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="84999">lo0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="85000">hi0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#38975" title="TypeConstraint.this.type" class="keyword">this</a><span class="delimiter">(</span><a href="#84999" title="List[Types.this.Type]">lo0</a>, <a href="#85000" title="List[Types.this.Type]">hi0</a>, <a href="#131699" title="object Types.this.NoType">NoType</a>, <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(bounds: Types.this.TypeBounds)Types.this.TypeConstraint" id="84044" class="keyword">this</a><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="84997">bounds</a>: <a href="#62311" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">)</span> = <a href="#84043" title="(lo0: List[Types.this.Type], hi0: List[Types.this.Type])Types.this.TypeConstraint" class="keyword">this</a><span class="delimiter">(</span><span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#84997" title="Types.this.TypeBounds">bounds</a>.<a href="#62325" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#84997" title="Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="()Types.this.TypeConstraint" id="84045" class="keyword">this</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="#84043" title="(lo0: List[Types.this.Type], hi0: List[Types.this.Type])Types.this.TypeConstraint" class="keyword">this</a><span class="delimiter">(</span>List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
    
    /*  Syncnote: Type constraints are assumed to be used from only one
     *  thread. They are not exposed in api.Types and are used only locally
     *  in operations that are exposed from types. Hence, no syncing of any
     *  variables should be ncessesary.
     */

    /** Guard these lists against AnyClass and NothingClass appearing,
     *  else loBounds.isEmpty will have different results for an empty
     *  constraint and one with Nothing as a lower bound.  [Actually
     *  guarding addLoBound/addHiBound somehow broke raw types so it
     *  only guards against being created with them.]
     */
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[Types.this.Type]" id="84047">lobounds</a> = <a href="#85003" title="List[Types.this.Type]">lo0</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</span> <span class="delimiter">(</span><a href="#129970" title="Types.this.Type">_</a>.<a href="#41506" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[Types.this.Type]" id="84050">hibounds</a> = <a href="#85004" title="List[Types.this.Type]">hi0</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</span> <span class="delimiter">(</span><a href="#129974" title="Types.this.Type">_</a>.<a href="#41506" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="84053">numlo</a> = <a href="#85005" title="Types.this.Type">numlo0</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Types.this.Type" id="84056">numhi</a> = <a href="#85006" title="Types.this.Type">numhi0</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Boolean" id="84059">avoidWidening</a> = <a href="#85009" title="Boolean">avoidWidening0</a>

    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="84061">loBounds</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#84053" title="=&gt; Types.this.Type">numlo</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <a href="#84047" title="=&gt; List[Types.this.Type]">lobounds</a> <span class="keyword">else</span> <a href="#84053" title="=&gt; Types.this.Type">numlo</a> <a href="#138740" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#84047" title="=&gt; List[Types.this.Type]">lobounds</a>
    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Type]" id="84062">hiBounds</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#84056" title="=&gt; Types.this.Type">numhi</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <a href="#84050" title="=&gt; List[Types.this.Type]">hibounds</a> <span class="keyword">else</span> <a href="#84056" title="=&gt; Types.this.Type">numhi</a> <a href="#138751" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#84050" title="=&gt; List[Types.this.Type]">hibounds</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="84063">avoidWiden</a>: <span title="Boolean">Boolean</span> = <a href="#84059" title="=&gt; Boolean">avoidWidening</a>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="84064">addLoBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="136936">tp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Boolean" id="136939">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#136939" title="Boolean">isNumericBound</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#45482" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#136936" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#84053" title="=&gt; Types.this.Type">numlo</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#131699" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">||</span> <a href="#39102" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#84053" title="=&gt; Types.this.Type">numlo</a>, <a href="#136936" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#84053" title="(x$1: Types.this.Type)Unit">numlo</a> = <a href="#136936" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#39102" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#136936" title="Types.this.Type">tp</a>, <a href="#84053" title="=&gt; Types.this.Type">numlo</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#84053" title="(x$1: Types.this.Type)Unit">numlo</a> = <a href="#38970" title="=&gt; Types.this.Type">numericLoBound</a>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#84047" title="(x$1: List[Types.this.Type])Unit">lobounds</a> <span title="(x: Types.this.Type)List[Types.this.Type]">::=</span> <a href="#136936" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="84065">checkWidening</a><span class="delimiter">(</span><a title="Types.this.Type" id="138774">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#138774" title="Types.this.Type">tp</a>.<a href="#41491" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#84059" title="(x$1: Boolean)Unit">avoidWidening</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">else</span> <a href="#138774" title="Types.this.Type">tp</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="#136120" title="Unit">HasTypeMember</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#84059" title="(x$1: Boolean)Unit">avoidWidening</a> = <span title="Boolean(true)" class="keyword">true</span>
        <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="84066">addHiBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="136944">tp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Boolean" id="136947">isNumericBound</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#84065" title="(tp: Types.this.Type)Unit">checkWidening</a><span class="delimiter">(</span><a href="#136944" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#136947" title="Boolean">isNumericBound</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#45482" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#136944" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#84056" title="=&gt; Types.this.Type">numhi</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#131699" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">||</span> <a href="#39102" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#136944" title="Types.this.Type">tp</a>, <a href="#84056" title="=&gt; Types.this.Type">numhi</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#84056" title="(x$1: Types.this.Type)Unit">numhi</a> = <a href="#136944" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#39102" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#84056" title="=&gt; Types.this.Type">numhi</a>, <a href="#136944" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#84056" title="(x$1: Types.this.Type)Unit">numhi</a> = <a href="#38972" title="=&gt; Types.this.Type">numericHiBound</a>
      <span class="delimiter">}</span>
      <span class="keyword">else</span> <a href="#84050" title="(x$1: List[Types.this.Type])Unit">hibounds</a> <span title="(x: Types.this.Type)List[Types.this.Type]">::=</span> <a href="#136944" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="84067">isWithinBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="137065">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <a href="#84047" title="=&gt; List[Types.this.Type]">lobounds</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#138797" title="Types.this.Type">_</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#137065" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <a href="#84050" title="=&gt; List[Types.this.Type]">hibounds</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#137065" title="Types.this.Type">tp</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#138807" title="Types.this.Type">_</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span class="delimiter">(</span><a href="#84053" title="=&gt; Types.this.Type">numlo</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#131699" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#84053" title="=&gt; Types.this.Type">numlo</a> <a href="#41574" title="(that: Types.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#137065" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span class="delimiter">(</span><a href="#84056" title="=&gt; Types.this.Type">numhi</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#131699" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#137065" title="Types.this.Type">tp</a> <a href="#41574" title="(that: Types.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#84056" title="=&gt; Types.this.Type">numhi</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">var</span> <a title="Types.this.Type" id="84069">inst</a>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#131699" title="object Types.this.NoType">NoType</a> // @M reduce visibility?

    <span class="keyword">def</span> <a title="=&gt; Boolean" id="84071">instValid</a> = <span class="delimiter">(</span><a href="#84069" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#84069" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="=&gt; Types.this.TypeConstraint" id="84072">cloneInternal</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.TypeConstraint" id="129964">tc</a> = <span title="Types.this.TypeConstraint" class="keyword">new</span> <a href="#38975" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">(</span><a href="#84047" title="=&gt; List[Types.this.Type]">lobounds</a>, <a href="#84050" title="=&gt; List[Types.this.Type]">hibounds</a>, <a href="#84053" title="=&gt; Types.this.Type">numlo</a>, <a href="#84056" title="=&gt; Types.this.Type">numhi</a>, <a href="#84059" title="=&gt; Boolean">avoidWidening</a><span class="delimiter">)</span>
      <a href="#129964" title="Types.this.TypeConstraint">tc</a>.<a href="#84069" title="(x$1: Types.this.Type)Unit">inst</a> = <a href="#84069" title="=&gt; Types.this.Type">inst</a>
      <a href="#129964" title="Types.this.TypeConstraint">tc</a>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="84073">toString</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="138822">boundsStr</a> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="138823">lo</a>    = <a href="#84061" title="=&gt; List[Types.this.Type]">loBounds</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</span> <span class="delimiter">(</span><a href="#138832" title="Types.this.Type">_</a>.<a href="#41506" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="138824">hi</a>    = <a href="#84062" title="=&gt; List[Types.this.Type]">hiBounds</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</span> <span class="delimiter">(</span><a href="#138838" title="Types.this.Type">_</a>.<a href="#41506" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[String]" id="138825">lostr</a> = <span title="List[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#138823" title="List[Types.this.Type]">lo</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="object Nil">Nil</span> <span class="keyword">else</span> <span title="(xs: String*)List[String]">List</span><span class="delimiter">(</span><a href="#138823" title="List[Types.this.Type]">lo</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot; &gt;: (&quot;)" class="string">&quot; &gt;: (&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[String]" id="138826">histr</a> = <span title="List[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#138824" title="List[Types.this.Type]">hi</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="object Nil">Nil</span> <span class="keyword">else</span> <span title="(xs: String*)List[String]">List</span><span class="delimiter">(</span><a href="#138824" title="List[Types.this.Type]">hi</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot; &lt;: (&quot;)" class="string">&quot; &lt;: (&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
      
        <a href="#138825" title="List[String]">lostr</a> <span title="(that: scala.collection.GenTraversableOnce[String])(implicit bf: scala.collection.generic.CanBuildFrom[List[String],String,List[String]])List[String]">++</span> <a href="#138826" title="List[String]">histr</a> <span title="(start: String, sep: String, end: String)String">mkString</span> <span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot; | &quot;)" class="string">&quot; | &quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#84069" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <a href="#138822" title="String">boundsStr</a>
      <span class="keyword">else</span> <a href="#138822" title="String">boundsStr</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; _= &quot;)" class="string">&quot; _= &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#84069" title="=&gt; Types.this.Type">inst</a>.<a href="#41590" title="=&gt; String">safeToString</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait AnnotationFilter extends Types.this.TypeMap with ScalaObject" id="38977">AnnotationFilter</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(annot: Types.this.AnnotationInfo)Boolean" id="75486">keepAnnotation</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="138921">annot</a>: <a href="AnnotationInfos.scala.html#39344" title="Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(annot: Types.this.AnnotationInfo)Types.this.AnnotationInfo" id="75487">mapOver</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="138923">annot</a>: <a href="AnnotationInfos.scala.html#39344" title="Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span> =
      <span title="Types.this.AnnotationInfo" class="keyword">if</span> <span class="delimiter">(</span><a href="#75486" title="(annot: Types.this.AnnotationInfo)Boolean">keepAnnotation</a><span class="delimiter">(</span><a href="#138923" title="Types.this.AnnotationInfo">annot</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#38977" title="Types.this.AnnotationFilter" class="keyword">super</a>.<a href="#74777" title="(annot: Types.this.AnnotationInfo)Types.this.AnnotationInfo">mapOver</a><span class="delimiter">(</span><a href="#138923" title="Types.this.AnnotationInfo">annot</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="AnnotationInfos.scala.html#39347" title="object Types.this.UnmappableAnnotation">UnmappableAnnotation</a>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait KeepOnlyTypeConstraints extends Types.this.TypeMap with Types.this.AnnotationFilter with ScalaObject" id="38978">KeepOnlyTypeConstraints</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38977" title="Types.this.AnnotationFilter">AnnotationFilter</a> <span class="delimiter">{</span>
    // filter keeps only type constraint annotations
    <span class="keyword">def</span> <a title="(annot: Types.this.AnnotationInfo)Boolean" id="75489">keepAnnotation</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="138937">annot</a>: <a href="AnnotationInfos.scala.html#39344" title="Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span> = <a href="#138937" title="Types.this.AnnotationInfo">annot</a> <a href="AnnotationInfos.scala.html#45934" title="(clazz: Types.this.Symbol)Boolean">matches</a> <a href="Definitions.scala.html#45083" title="=&gt; Types.this.Symbol">TypeConstraintClass</a>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait VariantTypeMap extends Types.this.TypeMap with ScalaObject" id="38979">VariantTypeMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">var</span> <a title="Int" id="137915">_variance</a> = <span title="Int(1)" class="int">1</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="137916">variance</a> = <a href="#137915" title="Int">_variance</a>
    <span class="keyword">def</span> <a title="(x: Int)Unit" id="137917">variance_=</a><span class="delimiter">(</span><a title="Int" id="138949">x</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#137915" title="Int">_variance</a> = <a href="#138949" title="Int">x</a>
    
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(origSyms: List[Types.this.Symbol])Boolean" id="137918">noChangeToSymbols</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="138952">origSyms</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#138952" title="List[Types.this.Symbol]">origSyms</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="138979">sym</a> =&gt;
        <span class="keyword">val</span> <a title="Int" id="138980">v</a> = <a href="#137916" title="=&gt; Int">variance</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#138979" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46447" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span> <a href="#137917" title="(x: Int)Unit">variance</a> = <span title="Int(0)" class="int">0</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="138981">result</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138979" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span>
        <a href="#137917" title="(x: Int)Unit">variance</a> = <a href="#138980" title="Int">v</a>
        <a href="#138981" title="Types.this.Type">result</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138979" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]" id="137919">mapOverArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="138990">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="138991">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> =
      <a href="#39078" title="(xs: List[Types.this.Type], ys: List[Types.this.Symbol])(f: (Types.this.Type, Types.this.Symbol) =&gt; Types.this.Type)List[Types.this.Type]">map2Conserve</a><span class="delimiter">(</span><a href="#138990" title="List[Types.this.Type]">args</a>, <a href="#138991" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Type" id="139036">arg</a>, <a title="Types.this.Symbol" id="139037">tparam</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Int" id="139038">v</a> = <a href="#137916" title="=&gt; Int">variance</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#139037" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46454" title="=&gt; Boolean">isContravariant</a><span class="delimiter">)</span> <a href="#137917" title="(x: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#137916" title="=&gt; Int">variance</a>
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#139037" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46456" title="=&gt; Boolean">isCovariant</a><span class="delimiter">)</span> <a href="#137917" title="(x: Int)Unit">variance</a> = <span title="Int(0)" class="int">0</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="139039">arg1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139036" title="Types.this.Type">arg</a><span class="delimiter">)</span>
        <a href="#137917" title="(x: Int)Unit">variance</a> = <a href="#139038" title="Int">v</a>
        <a href="#139039" title="Types.this.Type">arg1</a>
      <span class="delimiter">}</span>

    /** Map this function over given type */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="137920">mapOver</a><span class="delimiter">(</span><a title="Types.this.Type" id="139048">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#139048" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="139051">params</a>, <a title="Types.this.Type" id="139052">result</a><span class="delimiter">)</span> =&gt;
        <a href="#137917" title="(x: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#137916" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="139053">params1</a> = <a href="#74776" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#139051" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
        <a href="#137917" title="(x: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#137916" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="139054">result1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139052" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139053" title="List[Types.this.Symbol]">params1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139051" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#139054" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139052" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#139048" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#38937" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#139048" title="Types.this.Type">tp</a>, <a href="#139053" title="List[Types.this.Symbol]">params1</a>, <a href="#139054" title="Types.this.Type">result1</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#139051" title="List[Types.this.Symbol]">params</a>, <a href="#139053" title="List[Types.this.Symbol]">params1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="139069">tparams</a>, <a title="Types.this.Type" id="139070">result</a><span class="delimiter">)</span> =&gt;
        <a href="#137917" title="(x: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#137916" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="139071">tparams1</a> = <a href="#74776" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#139069" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
        <a href="#137917" title="(x: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#137916" title="=&gt; Int">variance</a>
        <span class="keyword">var</span> <a title="Types.this.Type" id="139072">result1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139070" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139071" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139069" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#139072" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139070" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#139048" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#62451" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#139071" title="List[Types.this.Symbol]">tparams1</a>, <a href="#139072" title="Types.this.Type">result1</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#139069" title="List[Types.this.Symbol]">tparams</a>, <a href="#139071" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="139087">lo</a>, <a title="Types.this.Type" id="139088">hi</a><span class="delimiter">)</span> =&gt;
        <a href="#137917" title="(x: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#137916" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="139089">lo1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139087" title="Types.this.Type">lo</a><span class="delimiter">)</span>
        <a href="#137917" title="(x: Int)Unit">variance</a> = <span title="=&gt; Int">-</span><a href="#137916" title="=&gt; Int">variance</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="139090">hi1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139088" title="Types.this.Type">hi</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139089" title="Types.this.Type">lo1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139087" title="Types.this.Type">lo</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#139090" title="Types.this.Type">hi1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139088" title="Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#139048" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#62285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#139089" title="Types.this.Type">lo1</a>, <a href="#139090" title="Types.this.Type">hi1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="139107">tr</a> @ TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="139108">pre</a>, <a title="Types.this.Symbol" id="139109">sym</a>, <a title="List[Types.this.Type]" id="139110">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="139111">pre1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139108" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="139112">args1</a> =
          <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#139110" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
            <a href="#139110" title="List[Types.this.Type]">args</a>
          <span class="keyword">else</span> <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#137916" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> // fast &amp; safe path: don't need to look at typeparams
            <a href="#139110" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <a href="#38979" title="Types.this.VariantTypeMap" class="keyword">this</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="139132">tparams</a> = <a href="#139109" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a>
            <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#139132" title="List[Types.this.Symbol]">tparams</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#139110" title="List[Types.this.Type]">args</a>
            <span class="keyword">else</span> <a href="#137919" title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">mapOverArgs</a><span class="delimiter">(</span><a href="#139110" title="List[Types.this.Type]">args</a>, <a href="#139132" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139111" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139108" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#139112" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139110" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#139048" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#38935" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#139048" title="Types.this.Type">tp</a>, <a href="#139111" title="Types.this.Type">pre1</a>, <a href="#139107" title="Types.this.TypeRef">tr</a>.<a href="#62122" title="(pre1: Types.this.Type)Types.this.Symbol">coevolveSym</a><span class="delimiter">(</span><a href="#139111" title="Types.this.Type">pre1</a><span class="delimiter">)</span>, <a href="#139112" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#38979" title="Types.this.VariantTypeMap" class="keyword">super</a>.<a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#139048" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A prototype for mapping a function over all possible types
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeMap extends Object with Types.this.Type =&gt; Types.this.Type with ScalaObject" id="38980">TypeMap</a> <a href="#38980" title="ScalaObject" class="keyword">extends</a> <span class="delimiter">(</span>Type =&gt; Type<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="74770">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="74792">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a>

    /** Mix in VariantTypeMap if you want variances to be significant.
     */
    <span class="keyword">def</span> <a title="=&gt; Int" id="74771">variance</a> = <span title="Int(0)" class="int">0</span>

    /** Map this function over given type */
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="74772">mapOver</a><span class="delimiter">(</span><a title="Types.this.Type" id="77493">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#77493" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="139141">tr</a> @ TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="139142">pre</a>, <a title="Types.this.Symbol" id="139143">sym</a>, <a title="List[Types.this.Type]" id="139144">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="139145">pre1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139142" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="139146">args1</a> = <a href="#139144" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <a href="#38980" title="Types.this.TypeMap" class="keyword">this</a>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139145" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139142" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#139146" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139144" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#77493" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#38935" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#77493" title="Types.this.Type">tp</a>, <a href="#139145" title="Types.this.Type">pre1</a>, <a href="#139141" title="Types.this.TypeRef">tr</a>.<a href="#62122" title="(pre1: Types.this.Type)Types.this.Symbol">coevolveSym</a><span class="delimiter">(</span><a href="#139145" title="Types.this.Type">pre1</a><span class="delimiter">)</span>, <a href="#139146" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#77493" title="Types.this.Type">tp</a>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="139161">pre</a>, <a title="Types.this.Symbol" id="139162">sym</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139162" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#77493" title="Types.this.Type">tp</a> // short path
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="139163">pre1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139161" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139163" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139161" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#77493" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#38930" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#139163" title="Types.this.Type">pre1</a>, <a href="#139162" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="139172">params</a>, <a title="Types.this.Type" id="139173">result</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="139174">params1</a> = <a href="#74776" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#139172" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="139175">result1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139173" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139174" title="List[Types.this.Symbol]">params1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139172" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#139175" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139173" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#77493" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#38937" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#77493" title="Types.this.Type">tp</a>, <a href="#139174" title="List[Types.this.Symbol]">params1</a>, <a href="#139175" title="Types.this.Type">result1</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#139172" title="List[Types.this.Symbol]">params</a>, <a href="#139174" title="List[Types.this.Symbol]">params1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="139190">tparams</a>, <a title="Types.this.Type" id="139191">result</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="139192">tparams1</a> = <a href="#74776" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#139190" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
        <span class="keyword">var</span> <a title="Types.this.Type" id="139193">result1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139191" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139192" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139190" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#139193" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139191" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#77493" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#62451" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#139192" title="List[Types.this.Symbol]">tparams1</a>, <a href="#139193" title="Types.this.Type">result1</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#139190" title="List[Types.this.Symbol]">tparams</a>, <a href="#139192" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="139208">result</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="139209">result1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139208" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139209" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139208" title="Types.this.Type">result</a><span class="delimiter">)</span> <a href="#77493" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#62410" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#139209" title="Types.this.Type">result1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ConstantType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#77493" title="Types.this.Type">tp</a>
      <span class="keyword">case</span> <span title="Types.this.Type">SuperType</span><span class="delimiter">(</span><a title="Types.this.Type" id="139219">thistp</a>, <a title="Types.this.Type" id="139220">supertp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="139221">thistp1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139219" title="Types.this.Type">thistp</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="139222">supertp1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139220" title="Types.this.Type">supertp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139221" title="Types.this.Type">thistp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139219" title="Types.this.Type">thistp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#139222" title="Types.this.Type">supertp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139220" title="Types.this.Type">supertp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#77493" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#83407" title="(thistp: Types.this.Type, supertp: Types.this.Type)Types.this.Type">SuperType</a><span class="delimiter">(</span><a href="#139221" title="Types.this.Type">thistp1</a>, <a href="#139222" title="Types.this.Type">supertp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="139241">lo</a>, <a title="Types.this.Type" id="139242">hi</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="139243">lo1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139241" title="Types.this.Type">lo</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="139244">hi1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139242" title="Types.this.Type">hi</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139243" title="Types.this.Type">lo1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139241" title="Types.this.Type">lo</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#139244" title="Types.this.Type">hi1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139242" title="Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#77493" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#62285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#139243" title="Types.this.Type">lo1</a>, <a href="#139244" title="Types.this.Type">hi1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="139261">bounds</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="139262">bounds1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139261" title="Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139262" title="Types.this.Type">bounds1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139261" title="Types.this.TypeBounds">bounds</a><span class="delimiter">)</span> <a href="#77493" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#147891" title="(bounds: Types.this.TypeBounds)Types.this.BoundedWildcardType">BoundedWildcardType</a><span class="delimiter">(</span><a href="#139262" title="Types.this.Type">bounds1</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.TypeBounds" class="delimiter">[</span><a href="#62311" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">]</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="139272">rtp</a> @ RefinedType<span class="delimiter">(</span><a title="List[Types.this.Type]" id="139273">parents</a>, <a title="Types.this.Scope" id="139274">decls</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="139275">parents1</a> = <a href="#139273" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <a href="#38980" title="Types.this.TypeMap" class="keyword">this</a>
        <span class="keyword">val</span> <a title="Types.this.Scope" id="139276">decls1</a> = <a href="#74775" title="(scope: Types.this.Scope)Types.this.Scope">mapOver</a><span class="delimiter">(</span><a href="#139274" title="Types.this.Scope">decls</a><span class="delimiter">)</span>
        //if ((parents1 eq parents) &amp;&amp; (decls1 eq decls)) tp
        //else refinementOfClass(tp.typeSymbol, parents1, decls1)
        <a href="#38933" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#139272" title="Types.this.RefinedType">rtp</a>, <a href="#139275" title="List[Types.this.Type]">parents1</a>, <a href="#139276" title="Types.this.Scope">decls1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="139289">tparams</a>, <a title="Types.this.Type" id="139290">result</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="139291">tparams1</a> = <a href="#74776" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#139289" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
        <span class="keyword">var</span> <a title="Types.this.Type" id="139292">result1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139290" title="Types.this.Type">result</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139291" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139289" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#139292" title="Types.this.Type">result1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139290" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#77493" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#38891" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">(</span><a href="#139291" title="List[Types.this.Symbol]">tparams1</a>, <a href="#139292" title="Types.this.Type">result1</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#139289" title="List[Types.this.Symbol]">tparams</a>, <a href="#139291" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">OverloadedType</span><span class="delimiter">(</span><a title="Types.this.Type" id="139307">pre</a>, <a title="List[Types.this.Symbol]" id="139308">alts</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="139309">pre1</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139307" title="Types.this.Type">pre</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#70033" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#139307" title="Types.this.Type">pre</a> <span class="keyword">else</span> <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139307" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139309" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139307" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#77493" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#147887" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.OverloadedType">OverloadedType</a><span class="delimiter">(</span><a href="#139309" title="Types.this.Type">pre1</a>, <a href="#139308" title="List[Types.this.Symbol]">alts</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">AntiPolyType</span><span class="delimiter">(</span><a title="Types.this.Type" id="139318">pre</a>, <a title="List[Types.this.Type]" id="139319">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="139320">pre1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139318" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="139321">args1</a> = <a href="#139319" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a href="#38980" title="Types.this.TypeMap" class="keyword">this</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139320" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139318" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#139321" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139319" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#77493" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#147883" title="(pre: Types.this.Type, targs: List[Types.this.Type])Types.this.AntiPolyType">AntiPolyType</a><span class="delimiter">(</span><a href="#139320" title="Types.this.Type">pre1</a>, <a href="#139321" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="139338">tv</a>@<a href="#84008" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="139340">constr</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139340" title="Types.this.TypeConstraint">constr</a>.<a href="#84071" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139340" title="Types.this.TypeConstraint">constr</a>.<a href="#84069" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#139338" title="Types.this.TypeVar">tv</a>.<a href="#83974" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#74773" title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">mapOverArgs</a><span class="delimiter">(</span><a href="#139338" title="Types.this.TypeVar">tv</a>.<a href="#83966" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#139338" title="Types.this.TypeVar">tv</a>.<a href="#83965" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span>  //@M !args.isEmpty implies !typeParams.isEmpty
      <span class="keyword">case</span> <span title="Types.this.Type">NotNullType</span><span class="delimiter">(</span><a title="Types.this.Type" id="139349">tp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="139350">tp1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139349" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139350" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139349" title="Types.this.Type">tp</a><span class="delimiter">)</span> <a href="#139349" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#147895" title="(underlying: Types.this.Type)Types.this.NotNullType">NotNullType</a><span class="delimiter">(</span><a href="#139350" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">AnnotatedType</span><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="139360">annots</a>, <a title="Types.this.Type" id="139361">atp</a>, <a title="Types.this.Symbol" id="139362">selfsym</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="139363">annots1</a> = <a href="#74778" title="(annots: List[Types.this.AnnotationInfo])List[Types.this.AnnotationInfo]">mapOverAnnotations</a><span class="delimiter">(</span><a href="#139360" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="139364">atp1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139361" title="Types.this.Type">atp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139363" title="List[Types.this.AnnotationInfo]">annots1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139360" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#139364" title="Types.this.Type">atp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139361" title="Types.this.Type">atp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#77493" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139363" title="List[Types.this.AnnotationInfo]">annots1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#139364" title="Types.this.Type">atp1</a>
        <span class="keyword">else</span> <a href="#58221" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type, selfsym: Types.this.Symbol)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#139363" title="List[Types.this.AnnotationInfo]">annots1</a>, <a href="#139364" title="Types.this.Type">atp1</a>, <a href="#139362" title="Types.this.Symbol">selfsym</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">DeBruijnIndex</span><span class="delimiter">(</span><a title="Int" id="139375">shift</a>, <a title="Int" id="139376">idx</a>, <a title="List[Types.this.Type]" id="139377">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="139378">args1</a> = <a href="#139377" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <a href="#38980" title="Types.this.TypeMap" class="keyword">this</a>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139378" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139377" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <a href="#77493" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#147843" title="(level: Int, idx: Int, args: List[Types.this.Type])Types.this.DeBruijnIndex">DeBruijnIndex</a><span class="delimiter">(</span><a href="#139375" title="Int">shift</a>, <a href="#139376" title="Int">idx</a>, <a href="#139378" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
/*
      case ErrorType =&gt; tp
      case WildcardType =&gt; tp
      case NoType =&gt; tp
      case NoPrefix =&gt; tp
*/
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#77493" title="Types.this.Type">tp</a>
        // throw new Error(&quot;mapOver inapplicable for &quot; + tp);
    <span class="delimiter">}</span>

    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(args: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]" id="74773">mapOverArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="138993">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="138994">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> =
      <a href="#138993" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <a href="#38980" title="Types.this.TypeMap" class="keyword">this</a>
    
    /** Called by mapOver to determine whether the original symbols can
     *  be returned, or whether they must be cloned.  Overridden in VariantTypeMap.
     */
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(origSyms: List[Types.this.Symbol])Boolean" id="74774">noChangeToSymbols</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="138954">origSyms</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#138954" title="List[Types.this.Symbol]">origSyms</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="138963">sym</a> =&gt; <a href="#138963" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#74770" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#138963" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span>

    /** Map this function over given scope */
    <span class="keyword">def</span> <a title="(scope: Types.this.Scope)Types.this.Scope" id="74775">mapOver</a><span class="delimiter">(</span><a title="Types.this.Scope" id="77474">scope</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a><span class="delimiter">)</span>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="139391">elems</a> = <a href="#77474" title="Types.this.Scope">scope</a>.<a href="Scopes.scala.html#60510" title="=&gt; List[Types.this.Symbol]">toList</a>
      <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="139392">elems1</a> = <a href="#74776" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#139391" title="List[Types.this.Symbol]">elems</a><span class="delimiter">)</span>
      <span title="Types.this.Scope" class="keyword">if</span> <span class="delimiter">(</span><a href="#139392" title="List[Types.this.Symbol]">elems1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139391" title="List[Types.this.Symbol]">elems</a><span class="delimiter">)</span> <a href="#77474" title="Types.this.Scope">scope</a>
      <span class="keyword">else</span> <a href="Scopes.scala.html#39177" title="(elems: Types.this.Symbol*)Types.this.Scope">newScopeWith</a><span class="delimiter">(</span><a href="#139392" title="List[Types.this.Symbol]">elems1</a>: _*<span class="delimiter">)</span>
    <span class="delimiter">}</span>
    
    /** Map this function over given list of symbols */
    <span class="keyword">def</span> <a title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]" id="74776">mapOver</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="77454">origSyms</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      // fast path in case nothing changes due to map
      <span title="List[Types.this.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#74774" title="(origSyms: List[Types.this.Symbol])Boolean">noChangeToSymbols</a><span class="delimiter">(</span><a href="#77454" title="List[Types.this.Symbol]">origSyms</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#77454" title="List[Types.this.Symbol]">origSyms</a>
      // map is not the identity --&gt; do cloning properly
      <span class="keyword">else</span> <a href="Symbols.scala.html#38747" title="(syms: List[Types.this.Symbol], infoFn: Types.this.Type =&gt; Types.this.Type)List[Types.this.Symbol]">cloneSymbolsAndModify</a><span class="delimiter">(</span><a href="#77454" title="List[Types.this.Symbol]">origSyms</a>, <a href="#38980" title="Types.this.TypeMap">TypeMap</a>.<span class="keyword">this</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(annot: Types.this.AnnotationInfo)Types.this.AnnotationInfo" id="74777">mapOver</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo" id="77451">annot</a>: <a href="AnnotationInfos.scala.html#39344" title="Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span>: <a href="AnnotationInfos.scala.html#39344" title="Types.this.AnnotationInfo">AnnotationInfo</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="AnnotationInfos.scala.html#45951" title="(info: Types.this.AnnotationInfo)Option[(Types.this.Type, List[Types.this.Tree], List[(Types.this.Name, Types.this.ClassfileAnnotArg)])]">AnnotationInfo</a><a href="#139403" title="(Types.this.Type, List[Types.this.Tree], List[(Types.this.Name, Types.this.ClassfileAnnotArg)])" class="delimiter">(</a><a href="#139402" title="Types.this.Type" id="139403">atp</a>, <a href="#139402" title="List[Types.this.Tree]" id="139404">args</a>, <a href="#139402" title="List[(Types.this.Name, Types.this.ClassfileAnnotArg)]" id="139405">assocs</a><span class="delimiter">)</span> = <a href="#77451" title="Types.this.AnnotationInfo">annot</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="139406">atp1</a>  = <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#139403" title="Types.this.Type">atp</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Tree]" id="139407">args1</a> = <a href="#74779" title="(args: List[Types.this.Tree])List[Types.this.Tree]">mapOverAnnotArgs</a><span class="delimiter">(</span><a href="#139404" title="List[Types.this.Tree]">args</a><span class="delimiter">)</span>
      // there is no need to rewrite assocs, as they are constants

      <span title="Types.this.AnnotationInfo" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139404" title="List[Types.this.Tree]">args</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139407" title="List[Types.this.Tree]">args1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#139403" title="Types.this.Type">atp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139406" title="Types.this.Type">atp1</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#77451" title="Types.this.AnnotationInfo">annot</a>
      <span class="keyword">else</span> <span title="Types.this.AnnotationInfo" class="keyword">if</span> <span class="delimiter">(</span><a href="#139407" title="List[Types.this.Tree]">args1</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#139404" title="List[Types.this.Tree]">args</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="AnnotationInfos.scala.html#39347" title="object Types.this.UnmappableAnnotation">UnmappableAnnotation</a>  // some annotation arg was unmappable
      <span class="keyword">else</span> <a href="AnnotationInfos.scala.html#45950" title="(atp: Types.this.Type, args: List[Types.this.Tree], assocs: List[(Types.this.Name, Types.this.ClassfileAnnotArg)])Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">(</span><a href="#139406" title="Types.this.Type">atp1</a>, <a href="#139407" title="List[Types.this.Tree]">args1</a>, <a href="#139405" title="List[(Types.this.Name, Types.this.ClassfileAnnotArg)]">assocs</a><span class="delimiter">)</span> <a href="AnnotationInfos.scala.html#45930" title="(pos: Types.this.Position)Types.this.AnnotationInfo">setPos</a> <a href="#77451" title="Types.this.AnnotationInfo">annot</a>.<a href="AnnotationInfos.scala.html#45929" title="=&gt; Types.this.Position">pos</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(annots: List[Types.this.AnnotationInfo])List[Types.this.AnnotationInfo]" id="74778">mapOverAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="139365">annots</a>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.AnnotationInfo]">List</span><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.AnnotationInfo]" id="139455">annots1</a> = <a href="#139365" title="List[Types.this.AnnotationInfo]">annots</a> <span title="(f: Types.this.AnnotationInfo =&gt; Types.this.AnnotationInfo)List[Types.this.AnnotationInfo]">mapConserve</span> <a href="#74777" title="(annot: Types.this.AnnotationInfo)Types.this.AnnotationInfo">mapOver</a>
      <span title="List[Types.this.AnnotationInfo]" class="keyword">if</span> <span class="delimiter">(</span><a href="#139455" title="List[Types.this.AnnotationInfo]">annots1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139365" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span> <a href="#139365" title="List[Types.this.AnnotationInfo]">annots</a>
      <span class="keyword">else</span> <a href="#139455" title="List[Types.this.AnnotationInfo]">annots1</a> <span title="(p: Types.this.AnnotationInfo =&gt; Boolean)List[Types.this.AnnotationInfo]">filterNot</span> <span class="delimiter">(</span><a href="#139475" title="Types.this.AnnotationInfo">_</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="AnnotationInfos.scala.html#39347" title="object Types.this.UnmappableAnnotation">UnmappableAnnotation</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Map over a set of annotation arguments.  If any
     *  of the arguments cannot be mapped, then return Nil.  */
    <span class="keyword">def</span> <a title="(args: List[Types.this.Tree])List[Types.this.Tree]" id="74779">mapOverAnnotArgs</a><span class="delimiter">(</span><a title="List[Types.this.Tree]" id="139453">args</a>: <span title="List[Types.this.Tree]">List</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Tree]">List</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Tree]" id="139476">args1</a> = <a href="#139453" title="List[Types.this.Tree]">args</a> <span title="(f: Types.this.Tree =&gt; Types.this.Tree)List[Types.this.Tree]">mapConserve</span> <a href="#74780" title="(tree: Types.this.Tree)Types.this.Tree">mapOver</a>
      <span title="List[Types.this.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#139476" title="List[Types.this.Tree]">args1</a> <span title="(elem: Any)Boolean">contains</span> <a href="#130266" title="object Types.this.UnmappableTree">UnmappableTree</a><span class="delimiter">)</span> <span title="object Nil">Nil</span>
      <span class="keyword">else</span> <a href="#139476" title="List[Types.this.Tree]">args1</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="74780">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="77448">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> =
      <a href="#74781" title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree">mapOver</a><span class="delimiter">(</span><a href="#77448" title="Types.this.Tree">tree</a>, <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <span title="Nothing" class="keyword">return</span> <a href="#130266" title="object Types.this.UnmappableTree">UnmappableTree</a><span class="delimiter">)</span>

    /** Map a tree that is part of an annotation argument.
     *  If the tree cannot be mapped, then invoke giveup().
     *  The default is to transform the tree with
     *  TypeMapTransformer.
     */
    <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="74781">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="77439">tree</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="77440">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> =
      <span class="delimiter">(</span><span title="TypeMap.this.TypeMapTransformer" class="keyword">new</span> <a href="#74782" title="TypeMap.this.TypeMapTransformer">TypeMapTransformer</a><span class="delimiter">)</span>.<a href="#139499" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#77439" title="Types.this.Tree">tree</a><span class="delimiter">)</span>

    /** This transformer leaves the tree alone except to remap
     *  its types. */
    <span class="keyword">class</span> <a title="class TypeMapTransformer extends Types.this.Transformer with ScalaObject" id="74782">TypeMapTransformer</a> <a href="#74782" title="ScalaObject" class="keyword">extends</a> <a href="#7741" title="Types.this.Transformer">Transformer</a> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="139499">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="139501">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Tree" id="139505">tree1</a> = <a href="#74782" title="TypeMap.this.TypeMapTransformer" class="keyword">super</a>.<span title="(tree: Types.this.Tree)Types.this.Tree">transform</span><span class="delimiter">(</span><a href="#139501" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="139506">tpe1</a> = <a href="#74770" title="(tp: Types.this.Type)Types.this.Type">TypeMap</a>.<span class="keyword">this</span><span class="delimiter">(</span><a href="#139505" title="Types.this.Tree">tree1</a>.<span title="=&gt; Types.this.Type">tpe</span><span class="delimiter">)</span>
        <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139501" title="Types.this.Tree">tree</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139505" title="Types.this.Tree">tree1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#139501" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Type">tpe</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139506" title="Types.this.Type">tpe1</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#139501" title="Types.this.Tree">tree</a>
        <span class="keyword">else</span>
          <a href="Trees.scala.html#39359" title="implicit scala.reflect.internal.Trees.treeOps : (tree: Types.this.Tree)Types.this.TreeOps">tree1</a>.<a href="Trees.scala.html#58446" title="=&gt; Types.this.Tree">shallowDuplicate</a>.<span title="(tp: Types.this.Type)Types.this.Tree">setType</span><span class="delimiter">(</span><a href="#139506" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeTraverser extends Types.this.TypeMap with ScalaObject" id="38981">TypeTraverser</a> <a href="#38981" title="ScalaObject" class="keyword">extends</a> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="130281">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="130300">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Unit">Unit</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="130282">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="139525">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span> <a href="#130281" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#139525" title="Types.this.Type">tp</a><span class="delimiter">)</span>; <a href="#139525" title="Types.this.Type">tp</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeTraverserWithResult[T] extends Types.this.TypeTraverser with ScalaObject" id="38982">TypeTraverserWithResult</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38983">T</a><span class="delimiter">]</span> <a href="#38982" title="ScalaObject" class="keyword">extends</a> <a href="#38981" title="Types.this.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; T" id="139529">result</a>: <a href="#38983" title="T">T</a>
    <span class="keyword">def</span> <a title="()Unit" id="139530">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span>
  <span class="delimiter">}</span>

  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeCollector[T] extends Types.this.TypeTraverser with ScalaObject" id="38984">TypeCollector</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38985">T</a><span class="delimiter">]</span><a href="#38984" title="ScalaObject" class="delimiter">(</a><a title="T" id="130291">initial</a>: <a href="#38985" title="T">T</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38981" title="Types.this.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="T" id="130287">result</a>: <a href="#38985" title="T">T</a> = _
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)T" id="130289">collect</a><span class="delimiter">(</span><a title="Types.this.Type" id="130296">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#130287" title="(x$1: T)Unit">result</a> = <a href="#130291" title="T">initial</a>
      <a href="#130281" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#130296" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <a href="#130287" title="=&gt; T">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A collector that tests for existential types appearing at given variance in a type
   *  @PP: Commenting out due to not being used anywhere.
   */
  // class ContainsVariantExistentialCollector(v: Int) extends TypeCollector(false) with VariantTypeMap {
  //   variance = v
  // 
  //   def traverse(tp: Type) = tp match {
  //     case ExistentialType(_, _) if (variance == v) =&gt; result = true
  //     case _ =&gt; mapOver(tp)
  //   }
  // }
  // 
  // val containsCovariantExistentialCollector = new ContainsVariantExistentialCollector(1)
  // val containsContravariantExistentialCollector = new ContainsVariantExistentialCollector(-1)

  <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol, tparams: List[Types.this.Symbol])List[Types.this.Symbol]" id="38986">typeParamsToExistentials</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="117455">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="117456">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="139537">eparams</a> = <a href="util/Collections.scala.html#38325" title="(xs: List[Types.this.Symbol])(f: (Types.this.Symbol, Int) =&gt; Types.this.Symbol)List[Types.this.Symbol]">mapWithIndex</a><span class="delimiter">(</span><a href="#117456" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="139563">tparam</a>, <a title="Int" id="139564">i</a><span class="delimiter">)</span> =&gt;
      <a href="#117455" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#46417" title="(name: Types.this.TypeName, pos: Types.this.Position, newFlags: Long)Types.this.Symbol">newExistential</a><span class="delimiter">(</span><a href="Names.scala.html#38395" title="(s: String)Types.this.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span><span title="(x$1: Any)String">+</span><a href="#139564" title="Int">i</a><span class="delimiter">)</span>, <a href="#117455" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#46379" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span> <a href="Symbols.scala.html#46610" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a> <a href="#139563" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>

    <a href="#139537" title="List[Types.this.Symbol]">eparams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <span class="delimiter">(</span><a href="#139601" title="Types.this.Symbol">_</a> <a href="Symbols.scala.html#46612" title="(syms0: List[Types.this.Symbol], syms1: List[Types.this.Symbol])x$82.type">substInfo</a> <span class="delimiter">(</span><a href="#117456" title="List[Types.this.Symbol]">tparams</a>, <a href="#139537" title="List[Types.this.Symbol]">eparams</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(clazz: Types.this.Symbol)List[Types.this.Symbol]" id="38987">typeParamsToExistentials</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="117453">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
    <a href="#38986" title="(clazz: Types.this.Symbol, tparams: List[Types.this.Symbol])List[Types.this.Symbol]">typeParamsToExistentials</a><span class="delimiter">(</span><a href="#117453" title="Types.this.Symbol">clazz</a>, <a href="#117453" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span>

  //  note: it's important to write the two tests in this order,
  //  as only typeParams forces the classfile to be read. See #400
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="38988">isRawIfWithoutArgs</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="117421">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
    <a href="#117421" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46445" title="=&gt; Boolean">isClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#117421" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#117421" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#46815" title="=&gt; Boolean">isJavaDefined</a>

  <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean" id="38989">isRaw</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="139639">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="139640">args</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    <span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#38988" title="(sym: Types.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span><a href="#139639" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#139640" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">isEmpty</span>

  /** Is type tp a ''raw type''? */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="38990">isRawType</a><span class="delimiter">(</span><a title="Types.this.Type" id="139643">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#139643" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="139646">sym</a>, <a title="List[Types.this.Type]" id="139647">args</a><span class="delimiter">)</span> =&gt; <a href="#38989" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><span class="delimiter">(</span><a href="#139646" title="Types.this.Symbol">sym</a>, <a href="#139647" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>

  /** The raw to existential map converts a ''raw type'' to an existential type.
   *  It is necessary because we might have read a raw type of a
   *  parameterized Java class from a class file. At the time we read the type
   *  the corresponding class file might still not be read, so we do not
   *  know what the type parameters of the type are. Therefore
   *  the conversion of raw types to existential types might not have taken place
   *  in ClassFileparser.sigToType (where it is usually done).
   */
  <span class="keyword">def</span> <a title="=&gt; Types.this.TypeMap" id="38991">rawToExistential</a> = <a href="#117390" title="Types.this.TypeMap{}" class="keyword">new</a> <a href="#38980" title="anonymous class $anon extends Types.this.TypeMap" id="117390">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="117393">expanded</a> = immutable.<span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="scala.collection.immutable.Set[Types.this.Type]" id="117396">generated</a> = immutable.<span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: Types.this.Type*)scala.collection.immutable.Set[Types.this.Type]" class="delimiter">[</span><a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="117398">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="117399">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#117399" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="117407">pre</a>, <a title="Types.this.Symbol" id="117408">sym</a>, <a href="#117410" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#38988" title="(sym: Types.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span><a href="#117408" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#117393" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">expanded</a> <span title="(elem: Types.this.Symbol)Boolean">contains</span> <a href="#117408" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="Definitions.scala.html#44984" title="=&gt; Types.this.Symbol">AnyRefClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>
        <span class="keyword">else</span> <span class="keyword">try</span> <span class="delimiter">{</span>
          <a href="#117393" title="(x$1: scala.collection.immutable.Set[Types.this.Symbol])Unit">expanded</a> <span title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">+=</span> <a href="#117408" title="Types.this.Symbol">sym</a>
          <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="117429">eparams</a> = <a href="#74776" title="(origSyms: List[Types.this.Symbol])List[Types.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#38987" title="(clazz: Types.this.Symbol)List[Types.this.Symbol]">typeParamsToExistentials</a><span class="delimiter">(</span><a href="#117408" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#38945" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#117429" title="List[Types.this.Symbol]">eparams</a>, <a href="#38934" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#117398" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#117407" title="Types.this.Type">pre</a><span class="delimiter">)</span>, <a href="#117408" title="Types.this.Symbol">sym</a>, <a href="#117429" title="List[Types.this.Symbol]">eparams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#117475" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
          <a href="#117393" title="(x$1: scala.collection.immutable.Set[Types.this.Symbol])Unit">expanded</a> <span title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">-=</span> <a href="#117408" title="Types.this.Symbol">sym</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#117396" title="=&gt; scala.collection.immutable.Set[Types.this.Type]">generated</a> <span title="(elem: Types.this.Type)Boolean">contains</span> <a href="#117399" title="Types.this.Type">tp</a><span class="delimiter">)</span> =&gt; // to avoid infinite expansions. todo: not sure whether this is needed
        <span class="keyword">val</span> <a title="Types.this.Type" id="117538">result</a> = <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#117399" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <a href="#117396" title="(x$1: scala.collection.immutable.Set[Types.this.Type])Unit">generated</a> <span title="(elem: Types.this.Type)scala.collection.immutable.Set[Types.this.Type]">+=</span> <a href="#117538" title="Types.this.Type">result</a>
        <a href="#117538" title="Types.this.Type">result</a>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#117399" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  /** Used by existentialAbstraction.
   */
  <span class="keyword">class</span> <a title="class ExistentialExtrapolation extends Types.this.TypeMap with Types.this.VariantTypeMap with ScalaObject" id="38992">ExistentialExtrapolation</a><a href="#38992" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="137931">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38979" title="Types.this.VariantTypeMap">VariantTypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[Types.this.Symbol,Int]" id="137924">occurCount</a> = mutable.<span title="[A, B](elems: (A, B)*)scala.collection.mutable.HashMap[A,B]">HashMap</span><span title="(elems: (Types.this.Symbol, Int)*)scala.collection.mutable.HashMap[Types.this.Symbol,Int]" class="delimiter">[</span><a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <span title="Int">Int</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="137926">countOccs</a><span class="delimiter">(</span><a title="Types.this.Type" id="139651">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#139651" title="Types.this.Type">tp</a> <a href="#41566" title="(f: Types.this.Type =&gt; Unit)Unit">foreach</a> <a href="#139656" title="Unit" class="delimiter">{</a>
        <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="139657">sym</a>, _<span class="delimiter">)</span> =&gt;
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#137931" title="List[Types.this.Symbol]">tparams</a> <span title="(elem: Any)Boolean">contains</span> <a href="#139657" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <a href="#137924" title="(key: Types.this.Symbol, value: Int)Unit">occurCount</a><span class="delimiter">(</span><a href="#139657" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
        <span class="keyword">case</span> <span title="Unit">_</span> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tpe: Types.this.Type)Types.this.Type" id="137927">extrapolate</a><span class="delimiter">(</span><a title="Types.this.Type" id="137932">tpe</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#137931" title="List[Types.this.Symbol]">tparams</a> <span title="(f: Types.this.Symbol =&gt; Unit)Unit">foreach</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="139745">t</a> =&gt; <a href="#137924" title="(key: Types.this.Symbol, value: Int)Unit">occurCount</a><span class="delimiter">(</span><a href="#139745" title="Types.this.Symbol">t</a><span class="delimiter">)</span> = <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      <a href="#137926" title="(tp: Types.this.Type)Unit">countOccs</a><span class="delimiter">(</span><a href="#137932" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="139758">tparam</a> &lt;- <a href="#137931" title="(f: Types.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span>
        <a href="#137926" title="(tp: Types.this.Type)Unit">countOccs</a><span class="delimiter">(</span><a href="#139758" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span>
      
      <a href="#137928" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#137932" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="137928">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="139760">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="139764">tp1</a> = <a href="#137929" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#139760" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#137916" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#139764" title="Types.this.Type">tp1</a>
      <span class="keyword">else</span> <a href="#139764" title="Types.this.Type">tp1</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="139793">pre</a>, <a title="Types.this.Symbol" id="139794">sym</a>, <a title="List[Types.this.Type]" id="139795">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#137931" title="List[Types.this.Symbol]">tparams</a> <span title="(elem: Any)Boolean">contains</span> <a href="#139794" title="Types.this.Symbol">sym</a> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="139796">repl</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#137916" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#117163" title="(tp: Types.this.Type)Types.this.Type">dropSingletonType</a><span class="delimiter">(</span><a href="#139764" title="Types.this.Type">tp1</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#139764" title="Types.this.Type">tp1</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62325" title="=&gt; Types.this.Type">lo</a>
          //println(&quot;eliminate &quot;+sym+&quot;/&quot;+repl+&quot;/&quot;+occurCount(sym)+&quot;/&quot;+(tparams exists (repl.contains)))//DEBUG
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#139796" title="Types.this.Type">repl</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46446" title="=&gt; Boolean">isBottomClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#137924" title="(key: Types.this.Symbol)Int">occurCount</a><span class="delimiter">(</span><a href="#139794" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#137931" title="List[Types.this.Symbol]">tparams</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#139796" title="Types.this.Type">repl</a>.<a href="#41569" title="(sym: Types.this.Symbol)Boolean">contains</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#139796" title="Types.this.Type">repl</a>
          <span class="keyword">else</span> <a href="#139764" title="Types.this.Type">tp1</a>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#139764" title="Types.this.Type">tp1</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="137929">mapOver</a><span class="delimiter">(</span><a title="Types.this.Type" id="139765">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#139765" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="139835">pre</a>, <a title="Types.this.Symbol" id="139836">sym</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#139836" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#139765" title="Types.this.Type">tp</a> // short path
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="139837">pre1</a> = <a href="#137928" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#139835" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#139837" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#139835" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#139837" title="Types.this.Type">pre1</a>.<a href="#41491" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#139765" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#38930" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#139837" title="Types.this.Type">pre1</a>, <a href="#139836" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#38992" title="Types.this.ExistentialExtrapolation" class="keyword">super</a>.<a href="#137920" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#139765" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    // Do not discard the types of existential ident's. The
    // symbol of the Ident itself cannot be listed in the
    // existential's parameters, so the resulting existential
    // type would be ill-formed.
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="137930">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="139768">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = <a href="#139768" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Tree">Ident</span><span class="delimiter">(</span>_<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#139768" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Type">tpe</span>.<a href="#41491" title="=&gt; Boolean">isStable</a> =&gt; <a href="#139768" title="Types.this.Tree">tree</a>
      <span class="keyword">case</span> <span title="Types.this.Tree">_</span>                             =&gt; <a href="#38992" title="Types.this.ExistentialExtrapolation" class="keyword">super</a>.<a href="#74780" title="(tree: Types.this.Tree)Types.this.Tree">mapOver</a><span class="delimiter">(</span><a href="#139768" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(hi: Types.this.Type)Types.this.TypeBounds" id="38993">singletonBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="117301">hi</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#132015" title="object Types.this.TypeBounds">TypeBounds</a>.<a href="#62283" title="(hi: Types.this.Type)Types.this.TypeBounds">upper</a><span class="delimiter">(</span><a href="#38939" title="(tps: List[Types.this.Type])Types.this.Type">intersectionType</a><span class="delimiter">(</span><span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#117301" title="Types.this.Type">hi</a>, <a href="Definitions.scala.html#45085" title="=&gt; Types.this.Symbol">SingletonClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  /** A map to compute the asSeenFrom method  */
  <span class="keyword">class</span> <a title="class AsSeenFromMap extends Types.this.TypeMap with Types.this.KeepOnlyTypeConstraints with ScalaObject" id="38994">AsSeenFromMap</a><a href="#38994" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="130595">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="130596">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="keyword">with</span> <a href="#38978" title="Types.this.KeepOnlyTypeConstraints">KeepOnlyTypeConstraints</a> <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="130583">capturedSkolems</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">var</span> <a title="List[Types.this.Symbol]" id="130586">capturedParams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">var</span> <a title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]" id="130589">capturedPre</a> = <a href="#38795" title="=&gt; scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]">emptySymMap</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="130591">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="139873">tree</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="139874">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="object annotationArgRewriter" id="139877">annotationArgRewriter</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#74782" title="AsSeenFromMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>
        /** Rewrite `This` trees in annotation argument trees */
        <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="139880">rewriteThis</a><span class="delimiter">(</span><a title="Types.this.Tree" id="139883">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> =
          <a href="#139883" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Types.this.Tree">This</span><span class="delimiter">(</span>_<span class="delimiter">)</span>
            <span class="keyword">if</span> <span class="delimiter">(</span><a href="#139883" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span> <a href="Symbols.scala.html#46649" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#130596" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
               <span class="delimiter">(</span><a href="#130595" title="Types.this.Type">pre</a>.<a href="#41508" title="=&gt; Types.this.Type">widen</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#46649" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#139883" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span> =&gt;
              <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#130595" title="Types.this.Type">pre</a>.<a href="#41491" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <span class="delimiter">{</span> // XXX why is this in this method? pull it out and guard the call `annotationArgRewriter.transform(tree)`?
                <span class="keyword">val</span> <a title="Types.this.TermSymbol" id="139889">termSym</a> = <span class="delimiter">(</span>
                  <a href="#130595" title="Types.this.Type">pre</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46564" title="Types.this.Symbol" id="139897">owner</a>.<a href="Symbols.scala.html#71564" title="Long" id="139900">newValue</a><span class="delimiter">(</span><a href="#130595" title="Types.this.Type">pre</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#52126" title="Types.this.TermName" id="139898">toTermName</a>, <a href="#130595" title="Types.this.Type">pre</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46379" title="Types.this.Position" id="139899">pos</a><span class="delimiter">)</span> // what symbol should really be used?
                    <a href="Symbols.scala.html#46610" title="(info: Types.this.Type)Types.this.TermSymbol">setInfo</a> <a href="#130595" title="Types.this.Type">pre</a>
                <span class="delimiter">)</span>
                <a href="Required.scala.html#39441" title="=&gt; scala.reflect.internal.TreeGen{val global: Types.this.type}">gen</a>.<a href="TreeGen.scala.html#92342" title="(tpe: Types.this.gen.global.Type, termSym: Types.this.gen.global.Symbol)Types.this.gen.global.Tree">mkAttributedQualifier</a><span class="delimiter">(</span><a href="#130595" title="Types.this.Type">pre</a>, <a href="#139889" title="Types.this.TermSymbol">termSym</a><span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">else</span>
                <a href="#139874" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span>

            <span class="keyword">case</span> <a title="Types.this.Tree" id="139912">tree</a> =&gt; <a href="#139912" title="Types.this.Tree">tree</a>
          <span class="delimiter">}</span>

        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="139881">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="139913">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Tree" id="139916">tree1</a> = <a href="#139880" title="(tree: Types.this.Tree)Types.this.Tree">rewriteThis</a><span class="delimiter">(</span><span class="keyword">super</span>.<a href="#139499" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#139913" title="Types.this.Tree">tree</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#139916" title="Types.this.Tree">tree1</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#139877" title="object annotationArgRewriter">annotationArgRewriter</a>.<a href="#139881" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#139873" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="130592">stabilize</a><span class="delimiter">(</span><a title="Types.this.Type" id="139920">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="139921">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
      <a href="#130589" title="=&gt; scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]">capturedPre</a>.<span title="(key: Types.this.Symbol, default: =&gt; Types.this.Symbol)Types.this.Symbol">getOrElse</span><span class="delimiter">(</span><a href="#139921" title="Types.this.Symbol">clazz</a>, <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="139954">qvar</a> = <a href="#139921" title="Types.this.Symbol">clazz</a> <a href="Symbols.scala.html#46418" title="(suffix: String)Types.this.Symbol">freshExistential</a> <span title="String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span> <a href="Symbols.scala.html#46610" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a> <a href="#38993" title="(hi: Types.this.Type)Types.this.TypeBounds">singletonBounds</a><span class="delimiter">(</span><a href="#139920" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <a href="#130589" title="(x$1: scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol])Unit">capturedPre</a> <span title="(kv: (Types.this.Symbol, Types.this.Symbol))scala.collection.immutable.Map[Types.this.Symbol,Types.this.Symbol]">+=</span> <span class="delimiter">(</span><a href="#139921" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">clazz</a> <span title="(y: Types.this.Symbol)(Types.this.Symbol, Types.this.Symbol)">-&gt;</span> <a href="#139954" title="Types.this.Symbol">qvar</a><span class="delimiter">)</span>
          <a href="#130586" title="(x$1: List[Types.this.Symbol])Unit">capturedParams</a> = <a href="#139954" title="Types.this.Symbol">qvar</a> <a href="#140042" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#130586" title="=&gt; List[Types.this.Symbol]">capturedParams</a>
          <a href="#139954" title="Types.this.Symbol">qvar</a>
      <span class="delimiter">}</span><span class="delimiter">)</span>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>

    /** Return `pre.baseType(clazz)`, or if that's `NoType` and `clazz` is a refinement, `pre` itself.
     *  See bug397.scala for an example where the second alternative is needed.
     *  The problem is that when forming the base type sequence of an abstract type,
     *  any refinements in the base type list might be regenerated, and thus acquire
     *  new class symbols. However, since refinements always have non-interesting prefixes
     *  it looks OK to me to just take the prefix directly. */
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="130593">base</a><span class="delimiter">(</span><a title="Types.this.Type" id="140050">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="140051">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="140054">b</a> = <a href="#140050" title="Types.this.Type">pre</a>.<a href="#41553" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#140051" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140054" title="Types.this.Type">b</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#131699" title="object Types.this.NoType">NoType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#140051" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#46467" title="=&gt; Boolean">isRefinementClass</a><span class="delimiter">)</span> <a href="#140050" title="Types.this.Type">pre</a>
      <span class="keyword">else</span> <a href="#140054" title="Types.this.Type">b</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="130594">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="130597">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#130595" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#130595" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#130596" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#46445" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span> <a href="#130597" title="Types.this.Type">tp</a>
      <span class="keyword">else</span> <a href="#130597" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="140060">sym</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="140061">toPrefix</a><span class="delimiter">(</span><a title="Types.this.Type" id="140062">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="140063">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#140062" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#140062" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#140063" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#46445" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span> <a href="#130597" title="Types.this.Type">tp</a>
            <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#140060" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#46649" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#140063" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                     <span class="delimiter">(</span><a href="#140062" title="Types.this.Type">pre</a>.<a href="#41508" title="=&gt; Types.this.Type">widen</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#46649" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#140060" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="140067">pre1</a> = <a href="#140062" title="Types.this.Type">pre</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Types.this.Type">SuperType</span><span class="delimiter">(</span><a title="Types.this.Type" id="140068">thistp</a>, _<span class="delimiter">)</span> =&gt; <a href="#140068" title="Types.this.Type">thistp</a>
                <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#140062" title="Types.this.Type">pre</a>
              <span class="delimiter">}</span>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#140067" title="Types.this.Type">pre1</a>.<a href="#41491" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">||</span>
                    <a href="#140067" title="Types.this.Type">pre1</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a> <span title="(x: Boolean)Boolean">||</span>
                    <a href="#140067" title="Types.this.Type">pre1</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46463" title="=&gt; Boolean">isModuleClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#140067" title="Types.this.Type">pre1</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46545" title="=&gt; Boolean">isStatic</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="#130592" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">stabilize</a><span class="delimiter">(</span><a href="#140067" title="Types.this.Type">pre1</a>, <a href="#140060" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                <a href="#140067" title="Types.this.Type">pre1</a>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <a href="#140061" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toPrefix</a><span class="delimiter">(</span><a href="#130593" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">base</a><span class="delimiter">(</span><a href="#140062" title="Types.this.Type">pre</a>, <a href="#140063" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>.<a href="#41514" title="=&gt; Types.this.Type">prefix</a>, <a href="#140063" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <a href="#140061" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toPrefix</a><span class="delimiter">(</span><a href="#130595" title="Types.this.Type">pre</a>, <a href="#130596" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="140069">pre</a>, <a title="Types.this.Symbol" id="140070">sym</a><span class="delimiter">)</span> =&gt;
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140070" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#130597" title="Types.this.Type">tp</a> // short path
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="140071">pre1</a> = <a href="#130594" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#140069" title="Types.this.Type">pre</a><span class="delimiter">)</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140071" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#140069" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#130597" title="Types.this.Type">tp</a>
            <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140071" title="Types.this.Type">pre1</a>.<a href="#41491" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#38930" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#140071" title="Types.this.Type">pre1</a>, <a href="#140070" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#140071" title="Types.this.Type">pre1</a>.<a href="#41556" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#140070" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#41519" title="=&gt; Types.this.Type">resultType</a> //todo: this should be rolled into existential abstraction
          <span class="delimiter">}</span>
        // AM: Martin, is this description accurate?
        // walk the owner chain of `clazz` (the original argument to asSeenFrom) until we find the type param's owner (while rewriting pre as we crawl up the owner chain)
        // once we're at the owner, extract the information that pre encodes about the type param,
        // by minimally subsuming pre to the type instance of the class that owns the type param,
        // the type we're looking for is the type instance's type argument at the position corresponding to the type parameter
        // optimisation: skip this type parameter if it's not owned by a class, as those params are not influenced by the prefix through which they are seen
        // (concretely: type params of anonymous type functions, which currently can only arise from normalising type aliases, are owned by the type alias of which they are the eta-expansion)
        // (skolems also aren't affected: they are ruled out by the isTypeParameter check)
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="140082">prefix</a>, <a title="Types.this.Symbol" id="140083">sym</a>, <a title="List[Types.this.Type]" id="140084">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#140083" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46469" title="=&gt; Boolean">isTypeParameter</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#140083" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#46445" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">def</span> <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="140086">toInstance</a><span class="delimiter">(</span><a title="Types.this.Type" id="140087">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="140088">clazz</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#140087" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#140087" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#140088" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#46445" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span> <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#130597" title="Types.this.Type">tp</a><span class="delimiter">)</span>
            //@M! see test pos/tcpoly_return_overriding.scala why mapOver is necessary
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span class="keyword">def</span> <a title="=&gt; Nothing" id="140097">throwError</a> = <a href="SymbolTable.scala.html#35603" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#130597" title="Types.this.Type">tp</a> <span title="(x$1: Any)String">+</span> <a href="#140083" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46744" title="=&gt; String">locationString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; cannot be instantiated from &quot;)" class="string">&quot; cannot be instantiated from &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#140087" title="Types.this.Type">pre</a>.<a href="#41508" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>

              <span class="keyword">val</span> <a title="Types.this.Symbol" id="140098">symclazz</a> = <a href="#140083" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140098" title="Types.this.Symbol">symclazz</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#140088" title="Types.this.Symbol">clazz</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#140087" title="Types.this.Type">pre</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#38912" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#140087" title="Types.this.Type">pre</a>.<a href="#41508" title="=&gt; Types.this.Type">widen</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#46649" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#140098" title="Types.this.Symbol">symclazz</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                // have to deconst because it may be a Class[T].
                <a href="#140087" title="Types.this.Type">pre</a>.<a href="#41553" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#140098" title="Types.this.Symbol">symclazz</a><span class="delimiter">)</span>.<a href="#41509" title="=&gt; Types.this.Type">deconst</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
                  <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="140109">basesym</a>, <a title="List[Types.this.Type]" id="140110">baseargs</a><span class="delimiter">)</span> =&gt;

                   <span class="keyword">def</span> <a title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type" id="140111">instParam</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="140113">ps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="140114">as</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
                      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140113" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39443" title="=&gt; Boolean">forInteractive</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                          <span class="keyword">val</span> <a title="Boolean" id="140115">saved</a> = <a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74518" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">uniqid</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a>
                          <span class="keyword">try</span> <span class="delimiter">{</span>
                            <a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74518" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">uniqid</a>.<a href="settings/MutableSettings.scala.html#74543" title="(arg: Boolean)Unit">value</a> = <span title="Boolean(true)" class="keyword">true</span>
                            <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;*** stale type parameter: &quot;)" class="string">&quot;*** stale type parameter: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#130597" title="Types.this.Type">tp</a> <span title="(x$1: Any)String">+</span> <a href="#140083" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46744" title="=&gt; String">locationString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; cannot be instantiated from &quot;)" class="string">&quot; cannot be instantiated from &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#140087" title="Types.this.Type">pre</a>.<a href="#41508" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
                            <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;*** confused with params: &quot;)" class="string">&quot;*** confused with params: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#140083" title="Types.this.Symbol">sym</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; in &quot;)" class="string">&quot; in &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#140083" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; not in &quot;)" class="string">&quot; not in &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#140113" title="List[Types.this.Symbol]">ps</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; of &quot;)" class="string">&quot; of &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#140109" title="Types.this.Symbol">basesym</a><span class="delimiter">)</span>
                            <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;*** stacktrace = &quot;)" class="string">&quot;*** stacktrace = &quot;</span><span class="delimiter">)</span>
                            <span title="Error" class="keyword">new</span> <span title="Error">Error</span><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="()Unit">printStackTrace</span><span class="delimiter">(</span><span class="delimiter">)</span>
                          <span class="delimiter">}</span> <span class="keyword">finally</span> <a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74518" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">uniqid</a>.<a href="settings/MutableSettings.scala.html#74543" title="(arg: Boolean)Unit">value</a> = <a href="#140115" title="Boolean">saved</a>
                          <a href="#140112" title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type">instParamRelaxed</a><span class="delimiter">(</span><a href="#140109" title="Types.this.Symbol">basesym</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#140110" title="List[Types.this.Type]">baseargs</a><span class="delimiter">)</span>
                        <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#140097" title="=&gt; Nothing">throwError</a>
                      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140083" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#140113" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; Types.this.Symbol">head</span><span class="delimiter">)</span>
                        // @M! don't just replace the whole thing, might be followed by type application
                        <a href="#38940" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#140114" title="List[Types.this.Type]">as</a>.<span title="=&gt; Types.this.Type">head</span>, <a href="#140084" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a href="#38994" title="Types.this.AsSeenFromMap" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> // @M: was as.head
                      <span class="keyword">else</span> <a href="#140111" title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type">instParam</a><span class="delimiter">(</span><a href="#140113" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>, <a href="#140114" title="List[Types.this.Type]">as</a>.<span title="=&gt; List[Types.this.Type]">tail</span><span class="delimiter">)</span>

                    /** Relaxed version of instParams which matches on names not symbols.
                     *  This is a last fallback in interactive mode because races in calls
                     *  from the IDE to the compiler may in rare cases lead to symbols referring
                     *  to type parameters that are no longer current.
                     */
                    <span class="keyword">def</span> <a title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type" id="140112">instParamRelaxed</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="140151">ps</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="140152">as</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
                      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140151" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#140097" title="=&gt; Nothing">throwError</a>
                      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140083" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#140151" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
                        // @M! don't just replace the whole thing, might be followed by type application
                        <a href="#38940" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#140152" title="List[Types.this.Type]">as</a>.<span title="=&gt; Types.this.Type">head</span>, <a href="#140084" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a href="#38994" title="Types.this.AsSeenFromMap" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span> // @M: was as.head
                      <span class="keyword">else</span> <a href="#140112" title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type">instParamRelaxed</a><span class="delimiter">(</span><a href="#140151" title="List[Types.this.Symbol]">ps</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>, <a href="#140152" title="List[Types.this.Type]">as</a>.<span title="=&gt; List[Types.this.Type]">tail</span><span class="delimiter">)</span>

                    //Console.println(&quot;instantiating &quot; + sym + &quot; from &quot; + basesym + &quot; with &quot; + basesym.typeParams + &quot; and &quot; + baseargs+&quot;, pre = &quot;+pre+&quot;, symclazz = &quot;+symclazz);//DEBUG
                    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#140109" title="Types.this.Symbol">basesym</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#140110" title="List[Types.this.Type]">baseargs</a><span class="delimiter">)</span><span class="delimiter">)</span>
                      <a href="#140111" title="(ps: List[Types.this.Symbol], as: List[Types.this.Type])Types.this.Type">instParam</a><span class="delimiter">(</span><a href="#140109" title="Types.this.Symbol">basesym</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#140110" title="List[Types.this.Type]">baseargs</a><span class="delimiter">)</span>
                    <span class="keyword">else</span>
                      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140098" title="Types.this.Symbol">symclazz</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>.<a href="#41513" title="=&gt; List[Types.this.Type]">parents</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#140179" title="Types.this.Type">_</a>.<a href="#41499" title="=&gt; Boolean">isErroneous</a><span class="delimiter">)</span><span class="delimiter">)</span>
                        <a href="#131624" title="object Types.this.ErrorType">ErrorType</a> // don't be to overzealous with throwing exceptions, see #2641
                      <span class="keyword">else</span>
                        <span title="Nothing" class="keyword">throw</span> <span title="(x$1: String)Error" class="keyword">new</span> <span title="Error">Error</span><span class="delimiter">(</span>
                          <span title="String(&quot;something is wrong (wrong class file?): &quot;)" class="string">&quot;something is wrong (wrong class file?): &quot;</span><span title="(x$1: Any)String">+</span><a href="#140109" title="Types.this.Symbol">basesym</a><span title="(x$1: Any)String">+</span>
                          <span title="String(&quot; with type parameters &quot;)" class="string">&quot; with type parameters &quot;</span><span title="(x$1: Any)String">+</span>
                          <a href="#140109" title="Types.this.Symbol">basesym</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<span title="(f: Types.this.Symbol =&gt; Types.this.Name)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Name,List[Types.this.Name]])List[Types.this.Name]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.Name,List[Types.this.Name]]" class="delimiter">(</span><a href="#140203" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>,<span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>,<span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span><span title="(x$1: Any)String">+</span>
                          <span title="String(&quot; gets applied to arguments &quot;)" class="string">&quot; gets applied to arguments &quot;</span><span title="(x$1: Any)String">+</span><a href="#140110" title="List[Types.this.Type]">baseargs</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>,<span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>,<span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span><span title="(x$1: Any)String">+</span><span title="String(&quot;, phase = &quot;)" class="string">&quot;, phase = &quot;</span><span title="(x$1: Any)String">+</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a><span class="delimiter">)</span>
                  <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="140236">tparams</a>, <a title="Types.this.Type" id="140237">qtpe</a><span class="delimiter">)</span> =&gt;
                    <a href="#130583" title="(x$1: List[Types.this.Symbol])Unit">capturedSkolems</a> = <a href="#130583" title="=&gt; List[Types.this.Symbol]">capturedSkolems</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">union</span> <a href="#140236" title="List[Types.this.Symbol]">tparams</a>
                    <a href="#140086" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toInstance</a><span class="delimiter">(</span><a href="#140237" title="Types.this.Type">qtpe</a>, <a href="#140088" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
                  <span class="keyword">case</span> <a title="Nothing" id="140293">t</a> =&gt;
                    <a href="#140097" title="=&gt; Nothing">throwError</a>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#140086" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toInstance</a><span class="delimiter">(</span><a href="#130593" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">base</a><span class="delimiter">(</span><a href="#140087" title="Types.this.Type">pre</a>, <a href="#140088" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>.<a href="#41514" title="=&gt; Types.this.Type">prefix</a>, <a href="#140088" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <a href="#140086" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">toInstance</a><span class="delimiter">(</span><a href="#130595" title="Types.this.Type">pre</a>, <a href="#130596" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#130597" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A base class to compute all substitutions */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SubstMap[T] extends Types.this.TypeMap with ScalaObject" id="38995">SubstMap</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="38996">T</a><span class="delimiter">]</span><a href="#38995" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="128696">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[T]" id="128697">to</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#128696" title="List[Types.this.Symbol]">from</a>, <a href="#128697" title="List[T]">to</a><span class="delimiter">)</span>, <span title="String(&quot;Unsound substitution from &quot;)" class="string">&quot;Unsound substitution from &quot;</span><span title="(x$1: Any)String">+</span> <a href="#128696" title="List[Types.this.Symbol]">from</a> <span title="(x$1: Any)String">+</span><span title="String(&quot; to &quot;)" class="string">&quot; to &quot;</span><span title="(x$1: Any)String">+</span> <a href="#128697" title="List[T]">to</a><span class="delimiter">)</span>

    /** Are `sym` and `sym1` the same? Can be tuned by subclasses. */
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, sym1: Types.this.Symbol)Boolean" id="128689">matches</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="140309">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="140310">sym1</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#140309" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#140310" title="Types.this.Symbol">sym1</a>

    /** Map target to type, can be tuned by subclasses */
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(fromtp: Types.this.Type, tp: T)Types.this.Type" id="128690">toType</a><span class="delimiter">(</span><a title="Types.this.Type" id="140312">fromtp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="T" id="140313">tp</a>: <a href="#38996" title="T">T</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a>

    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="128691">renameBoundSyms</a><span class="delimiter">(</span><a title="Types.this.Type" id="140315">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#140315" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="140317">ps</a>, <a title="Types.this.Type" id="140318">restp</a><span class="delimiter">)</span> =&gt;
        <a href="Symbols.scala.html#38749" title="(syms: List[Types.this.Symbol], tpe: Types.this.Type)(creator: (List[Types.this.Symbol], Types.this.Type) =&gt; Types.this.Type)Types.this.Type">createFromClonedSymbols</a><span class="delimiter">(</span><a href="#140317" title="List[Types.this.Symbol]">ps</a>, <a href="#140318" title="Types.this.Type">restp</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="140327">ps1</a>, <a title="Types.this.Type" id="140328">tp1</a><span class="delimiter">)</span> =&gt; <a href="#38937" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#140315" title="Types.this.Type">tp</a>, <a href="#140327" title="List[Types.this.Symbol]">ps1</a>, <a href="#128691" title="(tp: Types.this.Type)Types.this.Type">renameBoundSyms</a><span class="delimiter">(</span><a href="#140328" title="Types.this.Type">tp1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.PolyType">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="140331">bs</a>, <a title="Types.this.Type" id="140332">restp</a><span class="delimiter">)</span> =&gt;
        <a href="Symbols.scala.html#38749" title="(syms: List[Types.this.Symbol], tpe: Types.this.Type)(creator: (List[Types.this.Symbol], Types.this.Type) =&gt; Types.this.PolyType)Types.this.PolyType">createFromClonedSymbols</a><span class="delimiter">(</span><a href="#140331" title="List[Types.this.Symbol]">bs</a>, <a href="#140332" title="Types.this.Type">restp</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="140338">ps1</a>, <a title="Types.this.Type" id="140339">tp1</a><span class="delimiter">)</span> =&gt; <a href="#62451" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#140338" title="List[Types.this.Symbol]">ps1</a>, <a href="#128691" title="(tp: Types.this.Type)Types.this.Type">renameBoundSyms</a><span class="delimiter">(</span><a href="#140339" title="Types.this.Type">tp1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="140342">bs</a>, <a title="Types.this.Type" id="140343">restp</a><span class="delimiter">)</span> =&gt;
        <a href="Symbols.scala.html#38749" title="(syms: List[Types.this.Symbol], tpe: Types.this.Type)(creator: (List[Types.this.Symbol], Types.this.Type) =&gt; Types.this.Type)Types.this.Type">createFromClonedSymbols</a><span class="delimiter">(</span><a href="#140342" title="List[Types.this.Symbol]">bs</a>, <a href="#140343" title="Types.this.Type">restp</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#38891" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#140315" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp0: Types.this.Type)Types.this.Type" id="128692">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="128803">tp0</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#128696" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#128803" title="Types.this.Type">tp0</a> <span class="keyword">else</span> <span class="delimiter">{</span>
      @tailrec <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type" id="140353">subst</a><span class="delimiter">(</span><a title="Types.this.Type" id="140357">tp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="140358">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="140359">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[T]" id="140360">to</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140359" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#140357" title="Types.this.Type">tp</a>
        // else if (to.isEmpty) error(&quot;Unexpected substitution on '%s': from = %s but to == Nil&quot;.format(tp, from))
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#128689" title="(sym: Types.this.Symbol, sym1: Types.this.Symbol)Boolean">matches</a><span class="delimiter">(</span><a href="#140359" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Types.this.Symbol">head</span>, <a href="#140358" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#128690" title="(fromtp: Types.this.Type, tp: T)Types.this.Type">toType</a><span class="delimiter">(</span><a href="#140357" title="Types.this.Type">tp</a>, <a href="#140360" title="List[T]">to</a>.<span title="=&gt; T">head</span><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#140353" title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#140357" title="Types.this.Type">tp</a>, <a href="#140358" title="Types.this.Symbol">sym</a>, <a href="#140359" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>, <a href="#140360" title="List[T]">to</a>.<span title="=&gt; List[T]">tail</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="140354">boundSyms</a> = <a href="#128803" title="Types.this.Type">tp0</a>.<a href="#41529" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="140355">tp1</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#140354" title="scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span> <a href="#128696" title="List[Types.this.Symbol]">from</a>.<a href="#140366" title="(elem: Any)Boolean">contains</a><span class="delimiter">)</span> <a href="#128691" title="(tp: Types.this.Type)Types.this.Type">renameBoundSyms</a><span class="delimiter">(</span><a href="#128803" title="Types.this.Type">tp0</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#128803" title="Types.this.Type">tp0</a>
      <span class="keyword">val</span> <a title="Types.this.Type" id="140356">tp</a> = <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#140355" title="Types.this.Type">tp1</a><span class="delimiter">)</span>

      <a href="#140356" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        // @M
        // 1) arguments must also be substituted (even when the &quot;head&quot; of the
        // applied type has already been substituted)
        // example: (subst RBound[RT] from [type RT,type RBound] to
        // [type RT&amp;,type RBound&amp;]) = RBound&amp;[RT&amp;]
        // 2) avoid loops (which occur because alpha-conversion is
        // not performed properly imo)
        // e.g. if in class Iterable[a] there is a new Iterable[(a,b)],
        // we must replace the a in Iterable[a] by (a,b)
        // (must not recurse --&gt; loops)
        // 3) replacing m by List in m[Int] should yield List[Int], not just List
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="140373">sym</a>, <a title="List[Types.this.Type]" id="140374">args</a><span class="delimiter">)</span> =&gt;
          <a href="#38940" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#140353" title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#140356" title="Types.this.Type">tp</a>, <a href="#140373" title="Types.this.Symbol">sym</a>, <a href="#128696" title="List[Types.this.Symbol]">from</a>, <a href="#128697" title="List[T]">to</a><span class="delimiter">)</span>, <a href="#140374" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> // if args.isEmpty, appliedType is the identity
        <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="140375">sym</a><span class="delimiter">)</span> =&gt;
          <a href="#140353" title="(tp: Types.this.Type, sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[T])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#140356" title="Types.this.Type">tp</a>, <a href="#140375" title="Types.this.Symbol">sym</a>, <a href="#128696" title="List[Types.this.Symbol]">from</a>, <a href="#128697" title="List[T]">to</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#140356" title="Types.this.Type">tp</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `substSym` method. */
  <span class="keyword">class</span> <a title="class SubstSymMap extends Types.this.SubstMap[Types.this.Symbol] with ScalaObject" id="38997">SubstSymMap</a><a href="#38997" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="128778">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="128779">to</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38995" title="Types.this.SubstMap[Types.this.Symbol]">SubstMap</a><span class="delimiter">(</span><a href="#128778" title="List[Types.this.Symbol]">from</a>, <a href="#128779" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(fromtp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="128775">toType</a><span class="delimiter">(</span><a title="Types.this.Type" id="140397">fromtp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="140398">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#140397" title="Types.this.Type">fromtp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="140403">pre</a>, _, <a title="List[Types.this.Type]" id="140404">args</a><span class="delimiter">)</span> =&gt; <a href="#38935" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#140397" title="Types.this.Type">fromtp</a>, <a href="#140403" title="Types.this.Type">pre</a>, <a href="#140398" title="Types.this.Symbol">sym</a>, <a href="#140404" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="140405">pre</a>, _<span class="delimiter">)</span> =&gt; <a href="#38930" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#140405" title="Types.this.Type">pre</a>, <a href="#140398" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="128776">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="128801">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#128778" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#128801" title="Types.this.Type">tp</a> <span class="keyword">else</span> <span class="delimiter">{</span>
      @tailrec <span class="keyword">def</span> <a title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol" id="140406">subst</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="140407">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="140408">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="140409">to</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> =
        <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#140408" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#140407" title="Types.this.Symbol">sym</a>
        // else if (to.isEmpty) error(&quot;Unexpected substitution on '%s': from = %s but to == Nil&quot;.format(sym, from))
        <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#128689" title="(sym: Types.this.Symbol, sym1: Types.this.Symbol)Boolean">matches</a><span class="delimiter">(</span><a href="#140408" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; Types.this.Symbol">head</span>, <a href="#140407" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#140409" title="List[Types.this.Symbol]">to</a>.<span title="=&gt; Types.this.Symbol">head</span>
        <span class="keyword">else</span> <a href="#140406" title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol">subst</a><span class="delimiter">(</span><a href="#140407" title="Types.this.Symbol">sym</a>, <a href="#140408" title="List[Types.this.Symbol]">from</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span>, <a href="#140409" title="List[Types.this.Symbol]">to</a>.<span title="=&gt; List[Types.this.Symbol]">tail</span><span class="delimiter">)</span>
      <a href="#128801" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="140410">pre</a>, <a title="Types.this.Symbol" id="140411">sym</a>, <a title="List[Types.this.Type]" id="140412">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#140410" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="140413">newSym</a> = <a href="#140406" title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol">subst</a><span class="delimiter">(</span><a href="#140411" title="Types.this.Symbol">sym</a>, <a href="#128778" title="List[Types.this.Symbol]">from</a>, <a href="#128779" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span>
          // assert(newSym.typeParams.length == sym.typeParams.length, &quot;typars mismatch in SubstSymMap: &quot;+(sym, sym.typeParams, newSym, newSym.typeParams))
          <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#38935" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#128801" title="Types.this.Type">tp</a>, <a href="#140410" title="Types.this.Type">pre</a>, <a href="#140413" title="Types.this.Symbol">newSym</a>, <a href="#140412" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> // mapOver takes care of subst'ing in args
        <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="140426">pre</a>, <a title="Types.this.Symbol" id="140427">sym</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#140426" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a> =&gt;
          <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#38930" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#140426" title="Types.this.Type">pre</a>, <a href="#140406" title="(sym: Types.this.Symbol, from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Symbol">subst</a><span class="delimiter">(</span><a href="#140427" title="Types.this.Symbol">sym</a>, <a href="#128778" title="List[Types.this.Symbol]">from</a>, <a href="#128779" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#38997" title="Types.this.SubstSymMap" class="keyword">super</a>.<a href="#128692" title="(tp0: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#128801" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="128777">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="140414">tree</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="140415">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="object trans" id="140438">trans</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#74782" title="SubstSymMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>

        <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Option[Types.this.Symbol]" id="140441">termMapsTo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="140444">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#128778" title="List[Types.this.Symbol]">from</a> <span title="(elem: Types.this.Symbol)Int">indexOf</span> <a href="#140444" title="Types.this.Symbol">sym</a> <span title="Option[Types.this.Symbol]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="None.type">-</span><span class="int">1</span>   =&gt; <span title="object None">None</span>
          <span class="keyword">case</span> <a title="Some[Types.this.Symbol]" id="140462">idx</a>  =&gt; <span title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</span><span class="delimiter">(</span><a href="#128779" title="(n: Int)Types.this.Symbol">to</a><span class="delimiter">(</span><a href="#140462" title="Int">idx</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="140442">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="140484">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> =
          <a href="#140484" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a title="Types.this.Tree" id="140489">tree</a>@Ident<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
              <a href="#140441" title="(sym: Types.this.Symbol)Option[Types.this.Symbol]">termMapsTo</a><span class="delimiter">(</span><a href="#140489" title="Types.this.Ident">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Types.this.Tree">Some</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="140493">tosym</a><span class="delimiter">)</span> =&gt;
                  <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#140493" title="Types.this.Symbol">tosym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#46650" title="(that: Types.this.Symbol)Boolean">isSubClass</a> <a href="Definitions.scala.html#45085" title="=&gt; Types.this.Symbol">SingletonClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <a href="#7741" title="(name: String)Types.this.Ident">Ident</a><span class="delimiter">(</span><a href="#140493" title="Types.this.Symbol">tosym</a>.<a href="Symbols.scala.html#46761" title="=&gt; String">existentialToString</a><span class="delimiter">)</span>
                      .<span title="(sym: Types.this.Symbol)Types.this.Ident">setSymbol</span><span class="delimiter">(</span><a href="#140493" title="Types.this.Symbol">tosym</a><span class="delimiter">)</span>
                      .<span title="(pos: Types.this.Position)Types.this.Ident">setPos</span><span class="delimiter">(</span><a href="#140493" title="Types.this.Symbol">tosym</a>.<a href="Symbols.scala.html#46379" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>
                      .<span title="(tp: Types.this.Type)Types.this.Ident">setType</span><span class="delimiter">(</span><a href="#117163" title="(tp: Types.this.Type)Types.this.Type">dropSingletonType</a><span class="delimiter">(</span><a href="#140493" title="Types.this.Symbol">tosym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                    <a href="#140415" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span>
                  <span class="delimiter">}</span>
                <span class="keyword">case</span> <a title="Types.this.Tree" id="140519">none</a> =&gt; <span class="keyword">super</span>.<a href="#139499" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#140489" title="Types.this.Ident">tree</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="keyword">case</span> <a title="Types.this.Tree" id="140522">tree</a> =&gt; <span class="keyword">super</span>.<a href="#139499" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#140522" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#140438" title="object trans">trans</a>.<a href="#140442" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#140414" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `subst` method. */
  <span class="keyword">class</span> <a title="class SubstTypeMap extends Types.this.SubstMap[Types.this.Type] with ScalaObject" id="38998">SubstTypeMap</a><a href="#38998" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="128718">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="128719">to</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="#38995" title="Types.this.SubstMap[Types.this.Type]">SubstMap</a><span class="delimiter">(</span><a href="#128718" title="List[Types.this.Symbol]">from</a>, <a href="#128719" title="List[Types.this.Type]">to</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(fromtp: Types.this.Type, tp: Types.this.Type)Types.this.Type" id="128716">toType</a><span class="delimiter">(</span><a title="Types.this.Type" id="140546">fromtp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="140547">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#140547" title="Types.this.Type">tp</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="128717">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="135525">tree</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="135526">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="object trans" id="140552">trans</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#74782" title="SubstTypeMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="140555">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="140557">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = <a href="#140557" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Types.this.Tree">Ident</span><span class="delimiter">(</span><a title="Types.this.Name" id="140564">name</a><span class="delimiter">)</span> =&gt;
            <a href="#128718" title="List[Types.this.Symbol]">from</a> <span title="(elem: Types.this.Symbol)Int">indexOf</span> <a href="#140557" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <span title="Types.this.Tree">-</span><span class="int">1</span>   =&gt; <span class="keyword">super</span>.<a href="#139499" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#140557" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
              <span class="keyword">case</span> <a title="Types.this.Tree" id="140582">idx</a>  =&gt;
                <span class="keyword">val</span> <a title="Types.this.Type" id="140583">totpe</a> = <a href="#128719" title="(n: Int)Types.this.Type">to</a><span class="delimiter">(</span><a href="#140582" title="Int">idx</a><span class="delimiter">)</span>
                <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#140583" title="Types.this.Type">totpe</a>.<a href="#41491" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#140557" title="Types.this.Tree">tree</a>.<span title="=&gt; tree.type">duplicate</span> <span title="(tp: Types.this.Type)tree.type">setType</span> <a href="#140583" title="Types.this.Type">totpe</a>
                <span class="keyword">else</span> <a href="#135526" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> <span title="Types.this.Tree">_</span> =&gt;
            <span class="keyword">super</span>.<a href="#139499" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#140557" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#140552" title="object trans">trans</a>.<a href="#140555" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#135525" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `substThis` method. */
  <span class="keyword">class</span> <a title="class SubstThisMap extends Types.this.TypeMap with ScalaObject" id="38999">SubstThisMap</a><a href="#38999" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="130643">from</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="130644">to</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="130642">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="130646">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#130646" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="140597">sym</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#140597" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#130643" title="Types.this.Symbol">from</a><span class="delimiter">)</span> =&gt; <a href="#130644" title="Types.this.Type">to</a>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#130646" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">class</span> <a title="class SubstThisAndSymMap extends Types.this.SubstSymMap with ScalaObject" id="39000">SubstThisAndSymMap</a><a href="#39000" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="130672">fromThis</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="130673">toThis</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="130674">fromSyms</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="130675">toSyms</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="#38997" title="Types.this.SubstSymMap">SubstSymMap</a><span class="delimiter">(</span><a href="#130674" title="List[Types.this.Symbol]">fromSyms</a>, <a href="#130675" title="List[Types.this.Symbol]">toSyms</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="130671">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="130677">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#130677" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="140615">sym</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#140615" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#130672" title="Types.this.Symbol">fromThis</a> =&gt; <a href="#130671" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#130673" title="Types.this.Type">toThis</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span>                                =&gt; <a href="#39000" title="Types.this.SubstThisAndSymMap" class="keyword">super</a>.<a href="#128776" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#130677" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class SubstWildcardMap extends Types.this.TypeMap with ScalaObject" id="39001">SubstWildcardMap</a><a href="#39001" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="140628">from</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="140625">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="140629">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
      <a href="#140629" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.BoundedWildcardType">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="140632">sym</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#140628" title="List[Types.this.Symbol]">from</a> <span title="(elem: Any)Boolean">contains</span> <a href="#140632" title="Types.this.Symbol">sym</a> =&gt;
          <a href="#147891" title="(bounds: Types.this.TypeBounds)Types.this.BoundedWildcardType">BoundedWildcardType</a><span class="delimiter">(</span><a href="#140632" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
          <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#140629" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Types.this.WildcardType.type" id="140642">ex</a>: <a href="#39131" title="Types.this.MalformedType">MalformedType</a> =&gt;
        <a href="#131644" title="object Types.this.WildcardType">WildcardType</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

// dependent method types
  <span class="keyword">object</span> <a title="object Types.this.IsDependentCollector" id="39002">IsDependentCollector</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38984" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="130295">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="140652">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#140652" title="Types.this.Type">tp</a> <a href="#41495" title="=&gt; Boolean">isImmediatelyDependent</a><span class="delimiter">)</span> <a href="#130287" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#130287" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#140652" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object Types.this.ApproximateDependentMap" id="39004">ApproximateDependentMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="130445">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="130446">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
      <span title="Types.this.Type" class="keyword">if</span><span class="delimiter">(</span><a href="#130446" title="Types.this.Type">tp</a> <a href="#41495" title="=&gt; Boolean">isImmediatelyDependent</a><span class="delimiter">)</span> <a href="#131644" title="object Types.this.WildcardType">WildcardType</a>
      <span class="keyword">else</span> <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#130446" title="Types.this.Type">tp</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class InstantiateDependentMap extends Types.this.TypeMap with Types.this.KeepOnlyTypeConstraints with ScalaObject" id="39006">InstantiateDependentMap</a><a href="#39006" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="75490">params</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="75491">actuals</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="keyword">with</span> <a href="#38978" title="Types.this.KeepOnlyTypeConstraints">KeepOnlyTypeConstraints</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.IndexedSeq[Types.this.Type]" id="75474">actualsIndexed</a> = <a href="#75491" title="List[Types.this.Type]">actuals</a>.<span title="=&gt; scala.collection.immutable.IndexedSeq[Types.this.Type]">toIndexedSeq</span>

    <span class="keyword">object</span> <a title="object InstantiateDependentMap.this.ParamWithActual" id="75476">ParamWithActual</a> <span title="ScalaObject" class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Option[Types.this.Type]" id="140674">unapply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="140676">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Option[Types.this.Type]">Option</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Int" id="140678">pid</a> = <a href="#75490" title="List[Types.this.Symbol]">params</a> <span title="(elem: Types.this.Symbol)Int">indexOf</span> <a href="#140676" title="Types.this.Symbol">sym</a>
        <span title="Option[Types.this.Type]" class="keyword">if</span><span class="delimiter">(</span><a href="#140678" title="Int">pid</a> <span title="(x: Int)Boolean">!=</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#75474" title="(idx: Int)Types.this.Type">actualsIndexed</a><span class="delimiter">(</span><a href="#140678" title="Int">pid</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="object None">None</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="75478">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="75493">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
      <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#75493" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="#140674" title="(sym: Types.this.Symbol)Option[Types.this.Type]">ParamWithActual</a><span class="delimiter">(</span><a title="Types.this.Type" id="140733">arg</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#140733" title="Types.this.Type">arg</a>.<a href="#41491" title="=&gt; Boolean">isStable</a> =&gt; <a href="#140733" title="Types.this.Type">arg</a> // unsound to replace args by unstable actual #3873
        // (soundly) expand type alias selections on implicit arguments, see depmet_implicit_oopsla* test cases -- typically, `param.isImplicit`
        <span class="keyword">case</span> <a title="Types.this.Type" id="140734">tp1</a>@TypeRef<span class="delimiter">(</span>SingleType<span class="delimiter">(</span><a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="#140674" title="(sym: Types.this.Symbol)Option[Types.this.Type]">ParamWithActual</a><span class="delimiter">(</span><a title="Types.this.Type" id="140736">arg</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a title="Types.this.Symbol" id="140737">sym</a>, <a title="List[Types.this.Type]" id="140738">targs</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="140739">res</a> = <a href="#38934" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#140736" title="Types.this.Type">arg</a>, <a href="#140737" title="Types.this.Symbol">sym</a>, <a href="#140738" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span><span class="delimiter">(</span><a href="#140739" title="Types.this.Type">res</a>.<a href="#41506" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <a href="Symbols.scala.html#46447" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span> <a href="#140739" title="Types.this.Type">res</a>.<a href="#41535" title="=&gt; Types.this.Type">dealias</a>
          <span class="keyword">else</span> <a href="#140734" title="Types.this.TypeRef">tp1</a>
        <span class="keyword">case</span> <a title="Types.this.Type" id="140741">tp1</a> =&gt; <a href="#140741" title="Types.this.Type">tp1</a> // don't return the original `tp`, which may be different from `tp1`, due to dropping annotations
      <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="=&gt; List[Types.this.Symbol]" id="75479">existentialsNeeded</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#75480" title="(xs: Array[Types.this.Symbol])scala.collection.mutable.ArrayOps[Types.this.Symbol]">existSyms</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Array[Types.this.Symbol]">filter</span><span title="(xs: Array[Types.this.Symbol])scala.collection.mutable.ArrayOps[Types.this.Symbol]" class="delimiter">(</span><a href="#140942" title="Types.this.Symbol">_</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>.<span title="=&gt; List[Types.this.Symbol]">toList</span>

    <span class="keyword">private</span> <span class="keyword">val</span> <a title="Array[Types.this.Symbol]" id="75480">existSyms</a>: <span title="Array[Types.this.Symbol]">Array</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span title="Array[Types.this.Symbol]" class="keyword">new</span> <span title="Array[Types.this.Symbol]">Array</span><span class="delimiter">(</span><a href="#75474" title="=&gt; scala.collection.immutable.IndexedSeq[Types.this.Type]">actualsIndexed</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(i: Int)Boolean" id="75482">haveExistential</a><span class="delimiter">(</span><a title="Int" id="141047">i</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <span class="delimiter">{</span><span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#141047" title="Int">i</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#141047" title="Int">i</a> <span title="(x: Int)Boolean">&lt;=</span> <a href="#75474" title="=&gt; scala.collection.immutable.IndexedSeq[Types.this.Type]">actualsIndexed</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span><span class="delimiter">)</span>; <a href="#75480" title="(i: Int)Types.this.Symbol">existSyms</a><span class="delimiter">(</span><a href="#141047" title="Int">i</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">}</span>

    /* Return the type symbol for referencing a parameter inside the existential quantifier.
     * (Only needed if the actual is unstable.)
     */
    <span class="keyword">def</span> <a title="(actualIdx: Int)Types.this.Symbol" id="75483">existSymFor</a><span class="delimiter">(</span><a title="Int" id="141060">actualIdx</a>: <span title="Int">Int</span><span class="delimiter">)</span> =
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#75482" title="(i: Int)Boolean">haveExistential</a><span class="delimiter">(</span><a href="#141060" title="Int">actualIdx</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#75480" title="(i: Int)Types.this.Symbol">existSyms</a><span class="delimiter">(</span><a href="#141060" title="Int">actualIdx</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="141063">oldSym</a> = <a href="#75490" title="(n: Int)Types.this.Symbol">params</a><span class="delimiter">(</span><a href="#141060" title="Int">actualIdx</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="141064">symowner</a> = <a href="#141063" title="Types.this.Symbol">oldSym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>
        <span class="keyword">val</span> <a title="Types.this.TypeBounds" id="141065">bound</a> = <a href="#38993" title="(hi: Types.this.Type)Types.this.TypeBounds">singletonBounds</a><span class="delimiter">(</span><a href="#75474" title="(idx: Int)Types.this.Type">actualsIndexed</a><span class="delimiter">(</span><a href="#141060" title="Int">actualIdx</a><span class="delimiter">)</span><span class="delimiter">)</span>

        <span class="keyword">val</span> <a title="Types.this.Symbol" id="141066">sym</a> = <a href="#141064" title="Types.this.Symbol">symowner</a>.<a href="Symbols.scala.html#46417" title="(name: Types.this.TypeName, pos: Types.this.Position, newFlags: Long)Types.this.Symbol">newExistential</a><span class="delimiter">(</span><a href="Names.scala.html#38395" title="(s: String)Types.this.TypeName">newTypeName</a><span class="delimiter">(</span><a href="#141063" title="Types.this.Symbol">oldSym</a>.<a href="Symbols.scala.html#46571" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">name</a> <span title="(other: String)String">+</span> <span title="String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span><span class="delimiter">)</span>, <a href="#141063" title="Types.this.Symbol">oldSym</a>.<a href="Symbols.scala.html#46379" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>
        <a href="#141066" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46610" title="(info: Types.this.Type)sym.type">setInfo</a><span class="delimiter">(</span><a href="#141065" title="Types.this.TypeBounds">bound</a><span class="delimiter">)</span>
        <a href="#141066" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46589" title="(mask: Long)sym.type">setFlag</a><span class="delimiter">(</span><a href="#141063" title="Types.this.Symbol">oldSym</a>.<a href="Symbols.scala.html#46586" title="=&gt; Long">flags</a><span class="delimiter">)</span>

        <a href="#75480" title="(i: Int, x: Types.this.Symbol)Unit">existSyms</a><span class="delimiter">(</span><a href="#141060" title="Int">actualIdx</a><span class="delimiter">)</span> = <a href="#141066" title="Types.this.Symbol">sym</a>
        <a href="#141066" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span>

    //AM propagate more info to annotations -- this seems a bit ad-hoc... (based on code by spoon)
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(arg: Types.this.Tree, giveup: () =&gt; Nothing)Types.this.Tree" id="75484">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="140722">arg</a>: <span title="Types.this.Tree">Tree</span>, <a title="() =&gt; Nothing" id="140723">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
      <span class="keyword">object</span> <a title="object treeTrans" id="141101">treeTrans</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#7741" title="Types.this.Transformer">Transformer</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Types.this.Tree" id="141104">transform</a><span class="delimiter">(</span><a title="Types.this.Tree" id="141108">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Types.this.Tree">Tree</span> = <span class="delimiter">{</span>
          <a href="#141108" title="Types.this.Tree">tree</a> <span title="Types.this.Tree" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a href="#141112" title="Types.this.Tree">RefParamAt</a><span class="delimiter">(</span><a title="Int" id="141116">pid</a><span class="delimiter">)</span> =&gt;
              // TODO: this should be simplified; in the stable case, one can probably
              // just use an Ident to the tree.symbol. Why an existential in the non-stable case?
              <span class="keyword">val</span> <a title="Types.this.Type" id="141117">actual</a> = <a href="#75474" title="(idx: Int)Types.this.Type">actualsIndexed</a><span class="delimiter">(</span><a href="#141116" title="Int">pid</a><span class="delimiter">)</span>
              <span title="Types.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#141117" title="Types.this.Type">actual</a>.<a href="#41491" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141117" title="Types.this.Type">actual</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="Required.scala.html#39441" title="=&gt; scala.reflect.internal.TreeGen{val global: Types.this.type}">gen</a>.<a href="TreeGen.scala.html#92342" title="(tpe: Types.this.gen.global.Type, termSym: Types.this.gen.global.Symbol)Types.this.gen.global.Tree">mkAttributedQualifier</a><span class="delimiter">(</span><a href="#75474" title="(idx: Int)Types.this.Type">actualsIndexed</a><span class="delimiter">(</span><a href="#141116" title="Int">pid</a><span class="delimiter">)</span>, <a href="#141108" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                <span class="keyword">val</span> <a title="Types.this.Symbol" id="141139">sym</a> = <a href="#75483" title="(actualIdx: Int)Types.this.Symbol">existSymFor</a><span class="delimiter">(</span><a href="#141116" title="Int">pid</a><span class="delimiter">)</span>
                <span class="delimiter">(</span><a href="#7741" title="(name: Types.this.Name)Types.this.Ident">Ident</a><span class="delimiter">(</span><a href="#141139" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
                 <span title="(tree: Types.this.Tree)Types.this.Ident">copyAttrs</span> <a href="#141108" title="Types.this.Tree">tree</a>
                 <span title="(tp: Types.this.Type)Types.this.Ident">setType</span> <a href="#38934" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a>, <a href="#141139" title="Types.this.Symbol">sym</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="keyword">case</span> <span title="Types.this.Tree">_</span> =&gt; <span class="keyword">super</span>.<span title="(tree: Types.this.Tree)Types.this.Tree">transform</span><span class="delimiter">(</span><a href="#141108" title="Types.this.Tree">tree</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">object</span> <a title="object scala.reflect.internal.Types.InstantiateDependentMap.treeTrans.RefParamAt" id="141105">RefParamAt</a> <span title="ScalaObject" class="delimiter">{</span>
          <span class="keyword">def</span> <a title="(tree: Types.this.Tree)Option[Int]" id="141112">unapply</a><span class="delimiter">(</span><a title="Types.this.Tree" id="141113">tree</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span>: <span title="Option[Int]">Option</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> = <a href="#141113" title="Types.this.Tree">tree</a> <span title="Option[Int]" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Option[Int]">Ident</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <span title="(x: Int)Some[Int]">Some</span><span class="delimiter">(</span><a href="#75490" title="List[Types.this.Symbol]">params</a> <span title="(elem: Types.this.Symbol)Int">indexOf</span> <a href="#141113" title="Types.this.Tree">tree</a>.<span title="=&gt; Types.this.Symbol">symbol</span><span class="delimiter">)</span> <span title="(p: Int =&gt; Boolean)Option[Int]">filterNot</span> <span class="delimiter">(</span><a href="#141180" title="Int">_</a> <span title="(x: Int)Boolean">==</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="None.type">_</span>        =&gt; <span title="object None">None</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#141101" title="object treeTrans">treeTrans</a>.<a href="#141104" title="(tree: Types.this.Tree)Types.this.Tree">transform</a><span class="delimiter">(</span><a href="#140722" title="Types.this.Tree">arg</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  <span class="keyword">object</span> <a title="object Types.this.StripAnnotationsMap" id="39007">StripAnnotationsMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="131469">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="131470">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#131470" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">AnnotatedType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="141187">atp</a>, _<span class="delimiter">)</span> =&gt;
        <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#141187" title="Types.this.Type">atp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="141196">tp</a> =&gt;
        <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#141196" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to convert every occurrence of a wildcard type to a fresh
   *  type variable */
  <span class="keyword">object</span> <a title="object Types.this.wildcardToTypeVarMap" id="39009">wildcardToTypeVarMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="137060">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="137061">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#137061" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#131644" title="Types.this.TypeVar">WildcardType</a> =&gt;
        <a href="#84009" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint)Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#137061" title="Types.this.Type">tp</a>, <a href="#84045" title="()Types.this.TypeConstraint" class="keyword">new</a> <a href="#38975" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.TypeVar">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="141214">bounds</a><span class="delimiter">)</span> =&gt;
        <a href="#84009" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint)Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#137061" title="Types.this.Type">tp</a>, <a href="#84044" title="(bounds: Types.this.TypeBounds)Types.this.TypeConstraint" class="keyword">new</a> <a href="#38975" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">(</span><a href="#141214" title="Types.this.TypeBounds">bounds</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
        <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#137061" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to convert every occurrence of a type variable to a wildcard type. */
  <span class="keyword">object</span> <a title="object Types.this.typeVarToOriginMap" id="39011">typeVarToOriginMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="131229">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="131230">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#131230" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#84008" title="Types.this.Type">TypeVar</a><span class="delimiter">(</span><a title="Types.this.Type" id="141233">origin</a>, _<span class="delimiter">)</span> =&gt; <a href="#141233" title="Types.this.Type">origin</a>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#131230" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `contains` method. */
  <span class="keyword">class</span> <a title="class ContainsCollector extends Types.this.TypeCollector[Boolean] with ScalaObject" id="39013">ContainsCollector</a><a href="#39013" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="130891">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38984" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="130889">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="141248">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#130287" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#141248" title="Types.this.Type">tp</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="141250">sym1</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#130891" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#141250" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> =&gt; <a href="#130287" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span title="Unit">SingleType</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="141256">sym1</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#130891" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#141256" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> =&gt; <a href="#130287" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt; <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#141248" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(arg: Types.this.Tree)Types.this.Tree" id="130890">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="141261">arg</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Tree" id="141268">t</a> &lt;- <a href="#141261" title="(f: Types.this.Tree =&gt; Unit)Unit">arg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#130889" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#141268" title="Types.this.Tree">t</a>.<span title="=&gt; Types.this.Type">tpe</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#141268" title="Types.this.Tree">t</a>.<span title="=&gt; Types.this.Symbol">symbol</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#130891" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <a href="#130287" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="delimiter">}</span>
      <a href="#141261" title="Types.this.Tree">arg</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `contains` method. */
  <span class="keyword">class</span> <a title="class ContainsTypeCollector extends Types.this.TypeCollector[Boolean] with ScalaObject" id="39014">ContainsTypeCollector</a><a href="#39014" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type" id="130902">t</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38984" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="130900">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="141286">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#130287" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#141286" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#130902" title="Types.this.Type">t</a><span class="delimiter">)</span> <a href="#130287" title="(x$1: Boolean)Unit">result</a> = <span title="Boolean(true)" class="keyword">true</span>
        <span class="keyword">else</span> <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#141286" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(arg: Types.this.Tree)Types.this.Tree" id="130901">mapOver</a><span class="delimiter">(</span><a title="Types.this.Tree" id="141289">arg</a>: <span title="Types.this.Tree">Tree</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Tree" id="141296">t</a> &lt;- <a href="#141289" title="(f: Types.this.Tree =&gt; Unit)Unit">arg</a><span class="delimiter">)</span>
        <a href="#130900" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#141296" title="Types.this.Tree">t</a>.<span title="=&gt; Types.this.Type">tpe</span><span class="delimiter">)</span>

      <a href="#141289" title="Types.this.Tree">arg</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `filter` method. */
  <span class="keyword">class</span> <a title="class FilterTypeCollector extends Types.this.TypeCollector[List[Types.this.Type]] with ScalaObject" id="39015">FilterTypeCollector</a><a href="#39015" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type =&gt; Boolean" id="130689">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38984" title="Types.this.TypeCollector[List[Types.this.Type]]">TypeCollector</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="object Nil">Nil</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(q: Types.this.Type =&gt; Boolean)Types.this.FilterTypeCollector" id="130686">withFilter</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="141306">q</a>: Type =&gt; Boolean<span class="delimiter">)</span> = <span title="Types.this.FilterTypeCollector" class="keyword">new</span> <a href="#39015" title="Types.this.FilterTypeCollector">FilterTypeCollector</a><span class="delimiter">(</span><a title="Types.this.Type" id="141310">tp</a> =&gt; <a href="#130689" title="(v1: Types.this.Type)Boolean">p</a><span class="delimiter">(</span><a href="#141310" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141306" title="(v1: Types.this.Type)Boolean">q</a><span class="delimiter">(</span><a href="#141310" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: Types.this.Type)List[Types.this.Type]" id="130687">collect</a><span class="delimiter">(</span><a title="Types.this.Type" id="130691">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#39015" title="Types.this.FilterTypeCollector" class="keyword">super</a>.<a href="#130289" title="(tp: Types.this.Type)List[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#130691" title="Types.this.Type">tp</a><span class="delimiter">)</span>.<span title="=&gt; List[Types.this.Type]">reverse</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="130688">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="141313">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130689" title="(v1: Types.this.Type)Boolean">p</a><span class="delimiter">(</span><a href="#141313" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#130287" title="(x$1: List[Types.this.Type])Unit">result</a> <span title="(x: Types.this.Type)List[Types.this.Type]">::=</span> <a href="#141313" title="Types.this.Type">tp</a>
      <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#141313" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class ForEachTypeTraverser extends Types.this.TypeTraverser with ScalaObject" id="39016">ForEachTypeTraverser</a><a href="#39016" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type =&gt; Unit" id="130858">f</a>: Type =&gt; Unit<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38981" title="Types.this.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="130857">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="130860">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#130858" title="(v1: Types.this.Type)Unit">f</a><span class="delimiter">(</span><a href="#130860" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#130860" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `filter` method. */
  <span class="keyword">class</span> <a title="class FindTypeCollector extends Types.this.TypeCollector[Option[Types.this.Type]] with ScalaObject" id="39017">FindTypeCollector</a><a href="#39017" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Type =&gt; Boolean" id="130853">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#38984" title="Types.this.TypeCollector[Option[Types.this.Type]]">TypeCollector</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="object None">None</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="130852">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="141344">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130287" title="=&gt; Option[Types.this.Type]">result</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#130853" title="(v1: Types.this.Type)Boolean">p</a><span class="delimiter">(</span><a href="#141344" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#130287" title="(x$1: Option[Types.this.Type])Unit">result</a> = <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#141344" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#141344" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** A map to implement the `contains` method. */
  <span class="keyword">object</span> <a title="object Types.this.ErroneousCollector" id="39018">ErroneousCollector</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38984" title="Types.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="130309">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="141362">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#130287" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#130287" title="(x$1: Boolean)Unit">result</a> = <a href="#141362" title="Types.this.Type">tp</a>.<a href="#41498" title="=&gt; Boolean">isError</a>
        <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#141362" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** The most deeply nested owner that contains all the symbols
   *  of thistype or prefixless typerefs/singletype occurrences in given type.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(t: Types.this.Type)Types.this.Symbol" id="39020">commonOwner</a><span class="delimiter">(</span><a title="Types.this.Type" id="130338">t</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <a href="#39021" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#130338" title="Types.this.Type">t</a> <a href="#141377" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <span title="object Nil">Nil</span><span class="delimiter">)</span>

  /** The most deeply nested owner that contains all the symbols
   *  of thistype or prefixless typerefs/singletype occurrences in given list
   *  of types.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type])Types.this.Symbol" id="39021">commonOwner</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="130336">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
    <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#130336" title="List[Types.this.Type]">tps</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <a href="#39022" title="=&gt; Types.this.CommonOwnerMap">commonOwnerMap</a>.<a href="#141391" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#130336" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Unit)Unit">foreach</span> <span class="delimiter">(</span><a href="#39022" title="=&gt; Types.this.CommonOwnerMap">commonOwnerMap</a> <a href="#141393" title="(tp: Types.this.Type)Unit">traverse</a> <a href="#141415" title="Types.this.Type">_</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="141384">result</a> = <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#39022" title="=&gt; Types.this.CommonOwnerMap">commonOwnerMap</a>.<a href="#141389" title="=&gt; Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#39022" title="=&gt; Types.this.CommonOwnerMap">commonOwnerMap</a>.<a href="#141389" title="=&gt; Types.this.Symbol">result</a> <span class="keyword">else</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a>
      <a href="SymbolTable.scala.html#35605" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="#130336" title="List[Types.this.Type]">tps</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;commonOwner(&quot;)" class="string">&quot;commonOwner(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;) == &quot;)" class="string">&quot;) == &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#141384" title="Types.this.Symbol">result</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#141384" title="Types.this.Symbol">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Types.this.CommonOwnerMap" id="39022">commonOwnerMap</a>: <a href="#39023" title="Types.this.CommonOwnerMap">CommonOwnerMap</a> = <a href="#39024" title="=&gt; Types.this.CommonOwnerMap">commonOwnerMapObj</a>
  
  <span class="keyword">protected</span> <span class="keyword">class</span> <a title="class CommonOwnerMap extends Types.this.TypeTraverserWithResult[Types.this.Symbol] with ScalaObject" id="39023">CommonOwnerMap</a> <a href="#39023" title="ScalaObject" class="keyword">extends</a> <a href="#38982" title="Types.this.TypeTraverserWithResult[Types.this.Symbol]">TypeTraverserWithResult</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="Types.this.Symbol" id="141389">result</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = _
    
    <span class="keyword">def</span> <a title="()Unit" id="141391">clear</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#141389" title="(x$1: Types.this.Symbol)Unit">result</a> = <span title="Null(null)" class="keyword">null</span> <span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Unit" id="141392">register</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="141421">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      // First considered type is the trivial result.
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141389" title="=&gt; Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#141421" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#141389" title="(x$1: Types.this.Symbol)Unit">result</a> = <a href="#141421" title="Types.this.Symbol">sym</a>
      <span class="keyword">else</span>
        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141389" title="=&gt; Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#141389" title="=&gt; Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#141421" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#141421" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#46648" title="(that: Types.this.Symbol)Boolean">isNestedIn</a> <a href="#141389" title="=&gt; Types.this.Symbol">result</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#141389" title="(x$1: Types.this.Symbol)Unit">result</a> = <a href="#141389" title="=&gt; Types.this.Symbol">result</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Unit" id="141393">traverse</a><span class="delimiter">(</span><a title="Types.this.Type" id="141417">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#141417" title="Types.this.Type">tp</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Unit">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="141420">sym</a><span class="delimiter">)</span>                =&gt; <a href="#141392" title="(sym: Types.this.Symbol)Unit">register</a><span class="delimiter">(</span><a href="#141420" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span><a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="141423">sym</a>, <a title="List[Types.this.Type]" id="141424">args</a><span class="delimiter">)</span> =&gt; <a href="#141392" title="(sym: Types.this.Symbol)Unit">register</a><span class="delimiter">(</span><a href="#141423" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span> ; <a href="#141424" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Unit)Unit">foreach</span> <a href="#141393" title="(tp: Types.this.Type)Unit">traverse</a>
      <span class="keyword">case</span> <span title="Unit">SingleType</span><span class="delimiter">(</span><a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a>, <a title="Types.this.Symbol" id="141446">sym</a><span class="delimiter">)</span>    =&gt; <a href="#141392" title="(sym: Types.this.Symbol)Unit">register</a><span class="delimiter">(</span><a href="#141446" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Unit">_</span>                            =&gt; <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#141417" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Types.this.CommonOwnerMap" id="39025">commonOwnerMapObj</a> = <span title="Types.this.CommonOwnerMap" class="keyword">new</span> <a href="#39023" title="Types.this.CommonOwnerMap">CommonOwnerMap</a>

  <span class="keyword">class</span> <a title="class MissingAliasControl extends Throwable with scala.util.control.ControlThrowable with ScalaObject" id="39026">MissingAliasControl</a> <a href="#39026" title="ScalaObject" class="keyword">extends</a> <span title="scala.util.control.ControlThrowable">ControlThrowable</span>
  <span class="keyword">val</span> <a title="Types.this.MissingAliasControl" id="39027">missingAliasException</a> = <span title="Types.this.MissingAliasControl" class="keyword">new</span> <a href="#39026" title="Types.this.MissingAliasControl">MissingAliasControl</a>
  <span class="keyword">class</span> <a title="class MissingTypeControl extends Throwable with scala.util.control.ControlThrowable with ScalaObject" id="39029">MissingTypeControl</a> <a href="#39029" title="ScalaObject" class="keyword">extends</a> <span title="scala.util.control.ControlThrowable">ControlThrowable</span>

  <span class="keyword">object</span> <a title="object Types.this.adaptToNewRunMap" id="39030">adaptToNewRunMap</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#38980" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
        
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol" id="115292">adaptToNewRun</a><span class="delimiter">(</span><a title="Types.this.Type" id="141474">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="141475">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69313" title="=&gt; Boolean">flatClasses</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#141475" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#141475" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#39224" title="object Types.this.definitions">definitions</a>.<a href="Definitions.scala.html#44950" title="=&gt; Types.this.ModuleClassSymbol">RootClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="Definitions.scala.html#39224" title="object Types.this.definitions">definitions</a>.<a href="Definitions.scala.html#44950" title="=&gt; Types.this.ModuleClassSymbol">RootClass</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#141475" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#39224" title="object Types.this.definitions">definitions</a>.<a href="Definitions.scala.html#44948" title="=&gt; Types.this.Symbol">RootPackage</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="Definitions.scala.html#39224" title="object Types.this.definitions">definitions</a>.<a href="Definitions.scala.html#44948" title="=&gt; Types.this.Symbol">RootPackage</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#141475" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46463" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="141485">sourceModule1</a> = <a href="#115292" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#141474" title="Types.this.Type">pre</a>, <a href="#141475" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46672" title="=&gt; Types.this.Symbol">sourceModule</a><span class="delimiter">)</span>
        <span class="keyword">var</span> <a title="Types.this.Symbol" id="141486">result</a> = <a href="#141485" title="Types.this.Symbol">sourceModule1</a>.<a href="Symbols.scala.html#46698" title="=&gt; Types.this.Symbol">moduleClass</a>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#141486" title="Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#141486" title="Types.this.Symbol">result</a> = <a href="#141485" title="Types.this.Symbol">sourceModule1</a>.<a href="Symbols.scala.html#46620" title="=&gt; sourceModule1.type">initialize</a>.<a href="Symbols.scala.html#46698" title="=&gt; Types.this.Symbol">moduleClass</a>
        <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#141486" title="Types.this.Symbol">result</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#141486" title="Types.this.Symbol">result</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="String" id="141497">msg</a> = <span title="String(&quot;Cannot adapt module class; sym = %s, sourceModule = %s, sourceModule.moduleClass = %s =&gt; sourceModule1 = %s, sourceModule1.moduleClass = %s&quot;)" class="string">&quot;Cannot adapt module class; sym = %s, sourceModule = %s, sourceModule.moduleClass = %s =&gt; sourceModule1 = %s, sourceModule1.moduleClass = %s&quot;</span>
          <a href="SymbolTable.scala.html#35605" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="#141497" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">msg</a>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#141475" title="Types.this.Symbol">sym</a>, <a href="#141475" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46672" title="=&gt; Types.this.Symbol">sourceModule</a>, <a href="#141475" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46672" title="=&gt; Types.this.Symbol">sourceModule</a>.<a href="Symbols.scala.html#46698" title="=&gt; Types.this.Symbol">moduleClass</a>, <a href="#141485" title="Types.this.Symbol">sourceModule1</a>, <a href="#141485" title="Types.this.Symbol">sourceModule1</a>.<a href="Symbols.scala.html#46698" title="=&gt; Types.this.Symbol">moduleClass</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#141475" title="Types.this.Symbol">sym</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141474" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#141474" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#141475" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#141475" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">var</span> <a title="Types.this.Symbol" id="141502">rebind0</a> = <a href="#141474" title="Types.this.Type">pre</a>.<a href="#41595" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#141475" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a>, <span title="Long(67108864L)">BRIDGE</span>, <span title="Long(0L)" class="int">0</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#141502" title="Types.this.Symbol">rebind0</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#141475" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46447" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <a href="#39027" title="=&gt; Types.this.MissingAliasControl">missingAliasException</a>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74514" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#141474" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">pre</a><span title="(other: String)String">+</span><span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span><span title="(x$1: Any)String">+</span><a href="#141475" title="Types.this.Symbol">sym</a><span title="(x$1: Any)String">+</span><span title="String(&quot; does no longer exist, phase = &quot;)" class="string">&quot; does no longer exist, phase = &quot;</span><span title="(x$1: Any)String">+</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <span title="Types.this.MissingTypeControl" class="keyword">new</span> <a href="#39029" title="Types.this.MissingTypeControl">MissingTypeControl</a> // For build manager and presentation compiler purposes
          //assert(false, pre+&quot;.&quot;+sym+&quot; does no longer exist, phase = &quot;+phase)
        <span class="delimiter">}</span>
        /** The two symbols have the same fully qualified name */
        <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean" id="141503">corresponds</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="141517">sym1</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="141518">sym2</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
          <a href="#141517" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#141518" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#141517" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a> <span title="(x: Boolean)Boolean">||</span> <a href="#141503" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#141517" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>, <a href="#141518" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#141503" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#141475" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>, <a href="#141502" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="SymbolTable.scala.html#35605" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><span title="String(&quot;ADAPT1 pre = &quot;)" class="string">&quot;ADAPT1 pre = &quot;</span><span title="(x$1: Any)String">+</span><a href="#141474" title="Types.this.Type">pre</a><span title="(x$1: Any)String">+</span><span title="String(&quot;, sym = &quot;)" class="string">&quot;, sym = &quot;</span><span title="(x$1: Any)String">+</span><a href="#141475" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46745" title="=&gt; String">fullLocationString</a><span title="(x$1: Any)String">+</span><span title="String(&quot;, rebind = &quot;)" class="string">&quot;, rebind = &quot;</span><span title="(x$1: Any)String">+</span><a href="#141502" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#46745" title="=&gt; String">fullLocationString</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="141525">bcs</a> = <a href="#141474" title="Types.this.Type">pre</a>.<a href="#41581" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">dropWhile</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="141532">bc</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#141503" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#141532" title="Types.this.Symbol">bc</a>, <a href="#141475" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>;
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#141525" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
            <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#141474" title="Types.this.Type">pre</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46467" title="=&gt; Boolean">isRefinementClass</a>, <a href="#141474" title="Types.this.Type">pre</a><span class="delimiter">)</span> // if pre is a refinementclass it might be a structural type =&gt; OK to leave it in.
          <span class="keyword">else</span>
            <a href="#141502" title="Types.this.Symbol">rebind0</a> = <a href="#141474" title="Types.this.Type">pre</a>.<a href="#41553" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#141525" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Types.this.Symbol">head</span><span class="delimiter">)</span>.<a href="#41545" title="(name: Types.this.Name)Types.this.Symbol">member</a><span class="delimiter">(</span><a href="#141475" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
          <a href="SymbolTable.scala.html#35605" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span>
            <span title="String(&quot;ADAPT2 pre = &quot;)" class="string">&quot;ADAPT2 pre = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#141474" title="Types.this.Type">pre</a> <span title="(x$1: Any)String">+</span>
            <span title="String(&quot;, bcs.head = &quot;)" class="string">&quot;, bcs.head = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#141525" title="List[Types.this.Symbol]">bcs</a>.<span title="=&gt; Types.this.Symbol">head</span> <span title="(x$1: Any)String">+</span>
            <span title="String(&quot;, sym = &quot;)" class="string">&quot;, sym = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#141475" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46745" title="=&gt; String">fullLocationString</a> <span title="(x$1: Any)String">+</span>
            <span title="String(&quot;, rebind = &quot;)" class="string">&quot;, rebind = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#141502" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#46745" title="=&gt; String">fullLocationString</a>
          <span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="141504">rebind</a> = <a href="#141502" title="Types.this.Symbol">rebind0</a>.<a href="Symbols.scala.html#46655" title="(cond: Types.this.Symbol =&gt; Boolean)Types.this.Symbol">suchThat</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="141539">sym</a> =&gt; <a href="#141539" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46444" title="=&gt; Boolean">isType</a> <span title="(x: Boolean)Boolean">||</span> <a href="#141539" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46534" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#141504" title="Types.this.Symbol">rebind</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="SymbolTable.scala.html#35605" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)String">+</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69313" title="=&gt; Boolean">flatClasses</a><span title="(x$1: Any)String">+</span><a href="#141475" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a><span title="(x$1: Any)String">+</span><a href="#141475" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span title="(x$1: Any)String">+</span><span title="String(&quot; &quot;)" class="string">&quot; &quot;</span><span title="(x$1: Any)String">+</span><a href="#141475" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46444" title="=&gt; Boolean">isType</a><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <a href="#140646" title="(pre: Types.this.Type, tp: String)Types.this.MalformedType" class="keyword">new</a> <a href="#39131" title="Types.this.MalformedType">MalformedType</a><span class="delimiter">(</span><a href="#141474" title="Types.this.Type">pre</a>, <a href="#141475" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46739" title="=&gt; String">nameString</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#141504" title="Types.this.Symbol">rebind</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="115293">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="115294">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#115294" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="141549">sym</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">try</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="141550">sym1</a> = <a href="#115292" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#141549" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#46667" title="=&gt; Types.this.Type">thisType</a>, <a href="#141549" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#141550" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#141549" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#115294" title="Types.this.Type">tp</a> <span class="keyword">else</span> <a href="#83165" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="#141550" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        	<span class="keyword">case</span> <a title="Types.this.Type" id="141555">ex</a>: <a href="#39029" title="Types.this.MissingTypeControl">MissingTypeControl</a> =&gt;
            <a href="#115294" title="Types.this.Type">tp</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="141556">pre</a>, <a title="Types.this.Symbol" id="141557">sym</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#141557" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46474" title="=&gt; Boolean">isPackage</a><span class="delimiter">)</span> <a href="#115294" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="141558">pre1</a> = <a href="#115293" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#141556" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="141559">sym1</a> = <a href="#115292" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#141558" title="Types.this.Type">pre1</a>, <a href="#141557" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141558" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#141556" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#141559" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#141557" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#115294" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#38930" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#141558" title="Types.this.Type">pre1</a>, <a href="#141559" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="141561">pre</a>, <a title="Types.this.Symbol" id="141562">sym</a>, <a title="List[Types.this.Type]" id="141563">args</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#141562" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#115294" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="141564">pre1</a> = <a href="#115293" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#141561" title="Types.this.Type">pre</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="141565">args1</a> = <a href="#141563" title="List[Types.this.Type]">args</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>
          <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="141572">sym1</a> = <a href="#115292" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#141564" title="Types.this.Type">pre1</a>, <a href="#141562" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141564" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#141561" title="Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#141572" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#141562" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#141565" title="List[Types.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#141563" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>/* &amp;&amp; sym.isExternal*/<span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#115294" title="Types.this.Type">tp</a>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#141572" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74514" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;adapt fail: &quot;)" class="string">&quot;adapt fail: &quot;</span><span title="(x$1: Any)String">+</span><a href="#141561" title="Types.this.Type">pre</a><span title="(x$1: Any)String">+</span><span title="String(&quot; &quot;)" class="string">&quot; &quot;</span><span title="(x$1: Any)String">+</span><a href="#141564" title="Types.this.Type">pre1</a><span title="(x$1: Any)String">+</span><span title="String(&quot; &quot;)" class="string">&quot; &quot;</span><span title="(x$1: Any)String">+</span><a href="#141562" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
              <a href="#115294" title="Types.this.Type">tp</a>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <a href="#38935" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#115294" title="Types.this.Type">tp</a>, <a href="#141564" title="Types.this.Type">pre1</a>, <a href="#141572" title="Types.this.Symbol">sym1</a>, <a href="#141565" title="List[Types.this.Type]">args1</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a title="Types.this.Type" id="141582">ex</a>: <a href="#39026" title="Types.this.MissingAliasControl">MissingAliasControl</a> =&gt;
              <a href="#115293" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#115294" title="Types.this.Type">tp</a>.<a href="#41535" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="Types.this.Type">_</span>: <a href="#39029" title="Types.this.MissingTypeControl">MissingTypeControl</a> =&gt;
              <a href="#115294" title="Types.this.Type">tp</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141584">params</a>, <a title="Types.this.Type" id="141585">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="141586">restp1</a> = <a href="#115293" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#141585" title="Types.this.Type">restp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#141586" title="Types.this.Type">restp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#141585" title="Types.this.Type">restp</a><span class="delimiter">)</span> <a href="#115294" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#38937" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#115294" title="Types.this.Type">tp</a>, <a href="#141584" title="List[Types.this.Symbol]">params</a>, <a href="#141586" title="Types.this.Type">restp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="141588">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="141589">restp1</a> = <a href="#115293" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#141588" title="Types.this.Type">restp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#141589" title="Types.this.Type">restp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#141588" title="Types.this.Type">restp</a><span class="delimiter">)</span> <a href="#115294" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#62410" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#141589" title="Types.this.Type">restp1</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="141590">tparams</a>, <a title="Types.this.Type" id="141591">restp</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="141592">restp1</a> = <a href="#115293" title="(tp: Types.this.Type)Types.this.Type" class="keyword">this</a><span class="delimiter">(</span><a href="#141591" title="Types.this.Type">restp</a><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#141592" title="Types.this.Type">restp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#141591" title="Types.this.Type">restp</a><span class="delimiter">)</span> <a href="#115294" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#62451" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#141590" title="List[Types.this.Symbol]">tparams</a>, <a href="#141592" title="Types.this.Type">restp1</a><span class="delimiter">)</span>

      // Lukas: we need to check (together) whether we should also include parameter types
      // of PolyType and MethodType in adaptToNewRun

      <span class="keyword">case</span> <span title="Types.this.Type">ClassInfoType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="141593">parents</a>, <a title="Types.this.Scope" id="141594">decls</a>, <a title="Types.this.Symbol" id="141595">clazz</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#141595" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#115294" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="141596">parents1</a> = <a href="#141593" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#141596" title="List[Types.this.Type]">parents1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#141593" title="List[Types.this.Type]">parents</a><span class="delimiter">)</span> <a href="#115294" title="Types.this.Type">tp</a>
          <span class="keyword">else</span> <a href="#70033" title="(parents: List[Types.this.Type], decls: Types.this.Scope, typeSymbol: Types.this.Symbol)Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">(</span><a href="#141596" title="List[Types.this.Type]">parents1</a>, <a href="#141594" title="Types.this.Scope">decls</a>, <a href="#141595" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="141603">parents</a>, <a title="Types.this.Scope" id="141604">decls</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="141605">parents1</a> = <a href="#141603" title="List[Types.this.Type]">parents</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#141605" title="List[Types.this.Type]">parents1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#141603" title="List[Types.this.Type]">parents</a><span class="delimiter">)</span> <a href="#115294" title="Types.this.Type">tp</a>
        <span class="keyword">else</span> <a href="#38931" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#141605" title="List[Types.this.Type]">parents1</a>, <a href="#115294" title="Types.this.Type">tp</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>, <a href="#141604" title="Types.this.Scope">decls</a>, <a href="#115294" title="Types.this.Type">tp</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#46379" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SuperType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#115294" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeBounds</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#115294" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="#84008" title="Types.this.Type">TypeVar</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#115294" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">AnnotatedType</span><span class="delimiter">(</span>_,_,_<span class="delimiter">)</span> =&gt; <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#115294" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">NotNullType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#115294" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#74772" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#115294" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt; <a href="#115294" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class SubTypePair extends Object with ScalaObject" id="39032">SubTypePair</a><a href="#39032" title="ScalaObject" class="delimiter">(</a><span class="keyword">val</span> <a title="Types.this.Type" id="141680">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <span class="keyword">val</span> <a title="Types.this.Type" id="141681">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()Int" id="141674">hashCode</a> = <a href="#141680" title="=&gt; Types.this.Type">tp1</a>.<span title="()Int">hashCode</span> <span title="(x: Int)Int">*</span> <span title="Int(41)" class="int">41</span> <span title="(x: Int)Int">+</span> <a href="#141681" title="=&gt; Types.this.Type">tp2</a>.<span title="()Int">hashCode</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(other: Any)Boolean" id="141675">equals</a><span class="delimiter">(</span><a title="Any" id="141693">other</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <a href="#141693" title="Any">other</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="141696">stp</a>: <a href="#39032" title="Types.this.SubTypePair">SubTypePair</a> =&gt;
        <span class="delimiter">(</span><a href="#141680" title="=&gt; Types.this.Type">tp1</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141696" title="Types.this.SubTypePair">stp</a>.<a href="#141680" title="=&gt; Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#141681" title="=&gt; Types.this.Type">tp2</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141696" title="Types.this.SubTypePair">stp</a>.<a href="#141681" title="=&gt; Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
        <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="141676">toString</a> = <a href="#141680" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">tp1</a><span title="(other: String)String">+</span><span title="String(&quot; &lt;:&lt;? &quot;)" class="string">&quot; &lt;:&lt;? &quot;</span><span title="(x$1: Any)String">+</span><a href="#141681" title="=&gt; Types.this.Type">tp2</a>
  <span class="delimiter">}</span>

// Helper Methods  -------------------------------------------------------------

  <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(0)" id="39033">LubGlbMargin</a> = <span title="Int(0)" class="int">0</span>

  /** The maximum allowable depth of lubs or glbs over types `ts`.
    * This is the maximum depth of all types in the base type sequences
    * of each of the types `ts`, plus LubGlbMargin.
    */
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Int" id="39035">lubDepth</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="60570">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="Int" id="60573">d</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="60604">tp</a> &lt;- <a href="#60570" title="(f: Types.this.Type =&gt; Unit)Unit">ts</a><span class="delimiter">)</span> <a href="#60573" title="Int">d</a> = math.<span title="(x: Int, y: Int)Int">max</span><span class="delimiter">(</span><a href="#60573" title="Int">d</a>, <a href="#60604" title="Types.this.Type">tp</a>.<a href="#41580" title="=&gt; Int">baseTypeSeqDepth</a><span class="delimiter">)</span>
    <a href="#60573" title="Int">d</a> <span title="(x: Int)Int">+</span> <span title="Int(0)">LubGlbMargin</span>
  <span class="delimiter">}</span>

  /** Is intersection of given types populated? That is,
   *  for all types tp1, tp2 in intersection
   *    for all common base classes bc of tp1 and tp2
   *      let bt1, bt2 be the base types of tp1, tp2 relative to class bc
   *      Then:
   *        bt1 and bt2 have the same prefix, and
   *        any corresponding non-variant type arguments of bt1 and bt2 are the same
   */
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="39036">isPopulated</a><span class="delimiter">(</span><a title="Types.this.Type" id="126236">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="126237">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="141704">isConsistent</a><span class="delimiter">(</span><a title="Types.this.Type" id="141706">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141707">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#141706" title="Types.this.Type">tp1</a>, <a href="#141707" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="141716">pre1</a>, <a title="Types.this.Symbol" id="141717">sym1</a>, <a title="List[Types.this.Type]" id="141718">args1</a><span class="delimiter">)</span>, TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="141719">pre2</a>, <a title="Types.this.Symbol" id="141720">sym2</a>, <a title="List[Types.this.Type]" id="141721">args2</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#141717" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#141720" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>
        <a href="#141716" title="Types.this.Type">pre1</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141719" title="Types.this.Type">pre2</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <a href="util/Collections.scala.html#38359" title="(xs1: List[Types.this.Type], xs2: List[Types.this.Type], xs3: List[Types.this.Symbol])(f: (Types.this.Type, Types.this.Type, Types.this.Symbol) =&gt; Boolean)Boolean">forall3</a><span class="delimiter">(</span><a href="#141718" title="List[Types.this.Type]">args1</a>, <a href="#141721" title="List[Types.this.Type]">args2</a>, <a href="#141717" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Type" id="141785">arg1</a>, <a title="Types.this.Type" id="141786">arg2</a>, <a title="Types.this.Symbol" id="141787">tparam</a><span class="delimiter">)</span> =&gt; 
            //if (tparam.variance == 0 &amp;&amp; !(arg1 =:= arg2)) Console.println(&quot;inconsistent: &quot;+arg1+&quot;!=&quot;+arg2)//DEBUG
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#141787" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46562" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#141785" title="Types.this.Type">arg1</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141786" title="Types.this.Type">arg2</a>
          <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#141785" title="Types.this.Type">arg1</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#38912" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span><span class="delimiter">)</span>
            // if left-hand argument is a typevar, make it compatible with variance
            // this is for more precise pattern matching
            // todo: work this in the spec of this method
            // also: think what happens if there are embedded typevars?
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#141787" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46562" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#141785" title="Types.this.Type">arg1</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141786" title="Types.this.Type">arg2</a> <span class="keyword">else</span> <a href="#141786" title="Types.this.Type">arg2</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141785" title="Types.this.Type">arg1</a>
          <span class="keyword">else</span> <span title="Boolean(true)" class="keyword">true</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span><a title="Types.this.ExistentialType" id="141802">et</a>: <a href="#62567" title="Types.this.ExistentialType">ExistentialType</a>, _<span class="delimiter">)</span> =&gt;
        <a href="#141802" title="Types.this.ExistentialType">et</a>.<a href="#62596" title="(op: Types.this.Type =&gt; Boolean)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#141704" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#141806" title="Types.this.Type">_</a>, <a href="#141707" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>_, <a title="Types.this.ExistentialType" id="141809">et</a>: <a href="#62567" title="Types.this.ExistentialType">ExistentialType</a><span class="delimiter">)</span> =&gt;
        <a href="#141809" title="Types.this.ExistentialType">et</a>.<a href="#62596" title="(op: Types.this.Type =&gt; Boolean)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#141704" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#141706" title="Types.this.Type">tp1</a>, <a href="#141813" title="Types.this.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="141705">check</a><span class="delimiter">(</span><a title="Types.this.Type" id="141814">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141815">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#141814" title="Types.this.Type">tp1</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46445" title="=&gt; Boolean">isClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141814" title="Types.this.Type">tp1</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46593" title="(mask: Long)Boolean">hasFlag</a><span class="delimiter">(</span><span title="Long(32L)">FINAL</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#141814" title="Types.this.Type">tp1</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#141815" title="Types.this.Type">tp2</a> <span title="(x: Boolean)Boolean">||</span> <a href="Definitions.scala.html#45527" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#141814" title="Types.this.Type">tp1</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#45527" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#141815" title="Types.this.Type">tp2</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#141814" title="Types.this.Type">tp1</a>.<a href="#41581" title="=&gt; List[Types.this.Symbol]">baseClasses</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="141827">bc</a> =&gt;
        <a href="#141815" title="Types.this.Type">tp2</a>.<a href="#41582" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#141827" title="Types.this.Symbol">bc</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#141704" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#141814" title="Types.this.Type">tp1</a>.<a href="#41553" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#141827" title="Types.this.Symbol">bc</a><span class="delimiter">)</span>, <a href="#141815" title="Types.this.Type">tp2</a>.<a href="#41553" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#141827" title="Types.this.Symbol">bc</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <a href="#141705" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">check</a><span class="delimiter">(</span><a href="#126236" title="Types.this.Type">tp1</a>, <a href="#126237" title="Types.this.Type">tp2</a><span class="delimiter">)</span>/* &amp;&amp; check(tp2, tp1)*/ // need to investgate why this can't be made symmetric -- neg/gadts1 fails, and run/existials also.
  <span class="delimiter">}</span>

  /** Does a pattern of type `patType` need an outer test when executed against
   *  selector type `selType` in context defined by `currentOwner`?
   */
  <span class="keyword">def</span> <a title="(patType: Types.this.Type, selType: Types.this.Type, currentOwner: Types.this.Symbol)Boolean" id="39037">needsOuterTest</a><span class="delimiter">(</span><a title="Types.this.Type" id="126187">patType</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="126188">selType</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="126189">currentOwner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type)Types.this.Type" id="126192">createDummyClone</a><span class="delimiter">(</span><a title="Types.this.Type" id="126194">pre</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.TermSymbol" id="126195">dummy</a> = <a href="#126189" title="Types.this.Symbol">currentOwner</a>.<a href="Symbols.scala.html#46662" title="Types.this.Symbol" id="126203">enclClass</a>.<a href="Symbols.scala.html#71563" title="Types.this.Position" id="126206">newValue</a><span class="delimiter">(</span><a href="StdNames.scala.html#39313" title="object Types.this.nme">nme</a>.<a href="StdNames.scala.html#58913" title="Types.this.nme.NameType" id="126204">ANYNAME</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#46610" title="(info: Types.this.Type)Types.this.TermSymbol">setInfo</a><span class="delimiter">(</span><a href="#126194" title="Types.this.Type">pre</a>.<a href="#41508" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
      <a href="#38930" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#83165" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="#126189" title="Types.this.Symbol">currentOwner</a>.<a href="Symbols.scala.html#46662" title="=&gt; Types.this.Symbol">enclClass</a><span class="delimiter">)</span>, <a href="#126195" title="Types.this.TermSymbol">dummy</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="126193">maybeCreateDummyClone</a><span class="delimiter">(</span><a title="Types.this.Type" id="126211">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="126212">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#126211" title="Types.this.Type">pre</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="126213">pre1</a>, <a title="Types.this.Symbol" id="126214">sym1</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#126214" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46462" title="=&gt; Boolean">isModule</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#126214" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46545" title="=&gt; Boolean">isStatic</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#131699" title="object Types.this.NoType">NoType</a>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#126214" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46462" title="=&gt; Boolean">isModule</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#126212" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#126214" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46698" title="=&gt; Types.this.Symbol">moduleClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="126220">pre2</a> = <a href="#126193" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span><a href="#126213" title="Types.this.Type">pre1</a>, <a href="#126214" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#126220" title="Types.this.Type">pre2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <a href="#126220" title="Types.this.Type">pre2</a>
          <span class="keyword">else</span> <a href="#38930" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#126220" title="Types.this.Type">pre2</a>, <a href="#126214" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <a href="#126192" title="(pre: Types.this.Type)Types.this.Type">createDummyClone</a><span class="delimiter">(</span><a href="#126211" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ThisType</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="126221">clazz</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#126221" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#46463" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span>
          <a href="#126193" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span><a href="#126221" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#46666" title="=&gt; Types.this.Type">typeOfThis</a>, <a href="#126212" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#126212" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#126221" title="Types.this.Symbol">clazz</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#126212" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46593" title="(mask: Long)Boolean">hasFlag</a><span class="delimiter">(</span><span title="Long(4L)">PRIVATE</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#126212" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46599" title="=&gt; Types.this.Symbol">privateWithin</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#126221" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#131699" title="object Types.this.NoType">NoType</a>
        <span class="keyword">else</span>
          <a href="#126192" title="(pre: Types.this.Type)Types.this.Type">createDummyClone</a><span class="delimiter">(</span><a href="#126211" title="Types.this.Type">pre</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Types.this.NoType.type">_</span> =&gt;
        <a href="#131699" title="object Types.this.NoType">NoType</a>
    <span class="delimiter">}</span>
    <a href="#126187" title="Types.this.Type">patType</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="126232">pre</a>, <a title="Types.this.Symbol" id="126233">sym</a>, <a title="List[Types.this.Type]" id="126234">args</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="Types.this.Type" id="126235">pre1</a> = <a href="#126193" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span><a href="#126232" title="Types.this.Type">pre</a>, <a href="#126233" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="#126235" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#39036" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isPopulated</a><span class="delimiter">(</span><a href="#38935" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#126187" title="Types.this.Type">patType</a>, <a href="#126235" title="Types.this.Type">pre1</a>, <a href="#126233" title="Types.this.Symbol">sym</a>, <a href="#126234" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, <a href="#126188" title="Types.this.Type">selType</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
        <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="39039">subsametypeRecursions</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(pre1: Types.this.Type, pre2: Types.this.Type)Boolean" id="39041">isUnifiable</a><span class="delimiter">(</span><a title="Types.this.Type" id="141834">pre1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141835">pre2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
    <span class="delimiter">(</span><a href="#39063" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#141834" title="Types.this.Type">pre1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#39063" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#141835" title="Types.this.Type">pre2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#141834" title="Types.this.Type">pre1</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141835" title="Types.this.Type">pre2</a><span class="delimiter">)</span>

  /** Returns true iff we are past phase specialize,
   *  sym1 and sym2 are two existential skolems with equal names and bounds,
   *  and pre1 and pre2 are equal prefixes
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol, pre1: Types.this.Type, pre2: Types.this.Type)Boolean" id="39042">isSameSpecializedSkolem</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="141841">sym1</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="141842">sym2</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="141843">pre1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141844">pre2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#141841" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46500" title="=&gt; Boolean">isExistentialSkolem</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141842" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46500" title="=&gt; Boolean">isExistentialSkolem</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
    <a href="#141841" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#141842" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
    <a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69311" title="=&gt; Boolean">specialized</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
    <a href="#141841" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141842" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
    <a href="#141843" title="Types.this.Type">pre1</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141844" title="Types.this.Type">pre2</a>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean" id="39043">equalSymsAndPrefixes</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="141855">sym1</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="141856">pre1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="141857">sym2</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="141858">pre2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#141855" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#141857" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> <a href="#141855" title="Types.this.Symbol">sym1</a>.<a href="HasFlags.scala.html#46807" title="=&gt; Boolean">hasPackageFlag</a> <span title="(x: Boolean)Boolean">||</span> <a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#141856" title="Types.this.Type">pre1</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141858" title="Types.this.Type">pre2</a>
    <span class="keyword">else</span> <span class="delimiter">(</span><a href="#141855" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#141857" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#39041" title="(pre1: Types.this.Type, pre2: Types.this.Type)Boolean">isUnifiable</a><span class="delimiter">(</span><a href="#141856" title="Types.this.Type">pre1</a>, <a href="#141858" title="Types.this.Type">pre2</a><span class="delimiter">)</span>

  /** Do `tp1` and `tp2` denote equivalent types? */
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="39044">isSameType</a><span class="delimiter">(</span><a title="Types.this.Type" id="131110">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="131111">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="util/StatBase.scala.html#38639" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="util/Statistics.scala.html#38679" title="=&gt; scala.reflect.internal.util.Statistics.Counter">sametypeCount</a><span class="delimiter">)</span>
    <a href="#39039" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <a href="#38802" title="=&gt; Types.this.UndoLog">undoLog</a> <a href="#129898" title="(block: =&gt; Boolean)Boolean">undoUnless</a> <span class="delimiter">{</span>
      <a href="#39048" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType1</a><span class="delimiter">(</span><a href="#131110" title="Types.this.Type">tp1</a>, <a href="#131111" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#39039" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
    // XXX AM TODO: figure out when it is safe and needed to clear the log -- the commented approach below is too eager (it breaks #3281, #3866)
    // it doesn't help to keep separate recursion counts for the three methods that now share it
    // if (subsametypeRecursions == 0) undoLog.clear()
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="39045">isDifferentType</a><span class="delimiter">(</span><a title="Types.this.Type" id="141887">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141888">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="#39039" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    <a href="#38802" title="=&gt; Types.this.UndoLog">undoLog</a> <a href="#129895" title="(block: =&gt; Boolean)Boolean">undo</a> <span class="delimiter">{</span> // undo type constraints that arise from operations in this block
      <span title="=&gt; Boolean">!</span><a href="#39048" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType1</a><span class="delimiter">(</span><a href="#141887" title="Types.this.Type">tp1</a>, <a href="#141888" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#39039" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
    // XXX AM TODO: figure out when it is safe and needed to clear the log -- the commented approach below is too eager (it breaks #3281, #3866)
    // it doesn't help to keep separate recursion counts for the three methods that now share it
    // if (subsametypeRecursions == 0) undoLog.clear()
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="39046">isDifferentTypeConstructor</a><span class="delimiter">(</span><a title="Types.this.Type" id="141905">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141906">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#141905" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="141908">pre1</a>, <a title="Types.this.Symbol" id="141909">sym1</a>, _<span class="delimiter">)</span> =&gt;
      <a href="#141906" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="141910">pre2</a>, <a title="Types.this.Symbol" id="141911">sym2</a>, _<span class="delimiter">)</span> =&gt; <a href="#141909" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#141911" title="Types.this.Symbol">sym2</a> <span title="(x: Boolean)Boolean">||</span> <a href="#39045" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isDifferentType</a><span class="delimiter">(</span><a href="#141908" title="Types.this.Type">pre1</a>, <a href="#141910" title="Types.this.Type">pre2</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Boolean(true)">_</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> <span title="Boolean(true)">_</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="39047">normalizePlus</a><span class="delimiter">(</span><a title="Types.this.Type" id="141916">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#38990" title="(tp: Types.this.Type)Boolean">isRawType</a><span class="delimiter">(</span><a href="#141916" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#74770" title="(tp: Types.this.Type)Types.this.Type">rawToExistential</a><span class="delimiter">(</span><a href="#141916" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <a href="#141916" title="Types.this.Type">tp</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a>

  /*
  todo: change to:
  def normalizePlus(tp: Type) = tp match {
    case TypeRef(pre, sym, List()) =&gt;
      if (!sym.isInitialized) sym.rawInfo.load(sym)
      if (sym.isJavaDefined &amp;&amp; !sym.typeParams.isEmpty) rawToExistential(tp)
      else tp.normalize
    case _ =&gt; tp.normalize
  }
  */
/*
  private def isSameType0(tp1: Type, tp2: Type): Boolean = {
    if (tp1 eq tp2) return true
    ((tp1, tp2) match {
      case (ErrorType, _) =&gt; true
      case (WildcardType, _) =&gt; true
      case (_, ErrorType) =&gt; true
      case (_, WildcardType) =&gt; true

      case (NoType, _) =&gt; false
      case (NoPrefix, _) =&gt; tp2.typeSymbol.isPackageClass
      case (_, NoType) =&gt; false
      case (_, NoPrefix) =&gt; tp1.typeSymbol.isPackageClass

      case (ThisType(sym1), ThisType(sym2))
      if (sym1 == sym2) =&gt;
        true
      case (SingleType(pre1, sym1), SingleType(pre2, sym2))
      if (equalSymsAndPrefixes(sym1, pre1, sym2, pre2)) =&gt;
        true
/*
      case (SingleType(pre1, sym1), ThisType(sym2))
      if (sym1.isModule &amp;&amp;
          sym1.moduleClass == sym2 &amp;&amp;
          pre1 =:= sym2.owner.thisType) =&gt;
        true
      case (ThisType(sym1), SingleType(pre2, sym2))
      if (sym2.isModule &amp;&amp;
          sym2.moduleClass == sym1 &amp;&amp;
          pre2 =:= sym1.owner.thisType) =&gt;
        true
*/
      case (ConstantType(value1), ConstantType(value2)) =&gt;
        value1 == value2
      case (TypeRef(pre1, sym1, args1), TypeRef(pre2, sym2, args2)) =&gt;
        equalSymsAndPrefixes(sym1, pre1, sym2, pre2) &amp;&amp;
        ((tp1.isHigherKinded &amp;&amp; tp2.isHigherKinded &amp;&amp; tp1.normalize =:= tp2.normalize) ||
         isSameTypes(args1, args2))
         // @M! normalize reduces higher-kinded case to PolyType's
      case (RefinedType(parents1, ref1), RefinedType(parents2, ref2)) =&gt;
        def isSubScope(s1: Scope, s2: Scope): Boolean = s2.toList.forall {
          sym2 =&gt;
            var e1 = s1.lookupEntry(sym2.name)
            (e1 ne null) &amp;&amp; {
              val substSym = sym2.info.substThis(sym2.owner, e1.sym.owner.thisType)
              var isEqual = false
              while (!isEqual &amp;&amp; (e1 ne null)) {
                isEqual = e1.sym.info =:= substSym
                e1 = s1.lookupNextEntry(e1)
              }
              isEqual
            }
        }
        //Console.println(&quot;is same? &quot; + tp1 + &quot; &quot; + tp2 + &quot; &quot; + tp1.typeSymbol.owner + &quot; &quot; + tp2.typeSymbol.owner)//DEBUG
        isSameTypes(parents1, parents2) &amp;&amp; isSubScope(ref1, ref2) &amp;&amp; isSubScope(ref2, ref1)
      case (MethodType(params1, res1), MethodType(params2, res2)) =&gt;
        // new dependent types: probably fix this, use substSym as done for PolyType
        (isSameTypes(tp1.paramTypes, tp2.paramTypes) &amp;&amp;
         res1 =:= res2 &amp;&amp;
         tp1.isImplicit == tp2.isImplicit)
      case (PolyType(tparams1, res1), PolyType(tparams2, res2)) =&gt;
        // assert((tparams1 map (_.typeParams.length)) == (tparams2 map (_.typeParams.length)))
        (tparams1.length == tparams2.length) &amp;&amp; (tparams1 corresponds tparams2)(_.info =:= _.info.substSym(tparams2, tparams1)) &amp;&amp; // @M looks like it might suffer from same problem as #2210
          res1 =:= res2.substSym(tparams2, tparams1)
      case (ExistentialType(tparams1, res1), ExistentialType(tparams2, res2)) =&gt;
        (tparams1.length == tparams2.length) &amp;&amp; (tparams1 corresponds tparams2)(_.info =:= _.info.substSym(tparams2, tparams1)) &amp;&amp; // @M looks like it might suffer from same problem as #2210
          res1 =:= res2.substSym(tparams2, tparams1)
      case (TypeBounds(lo1, hi1), TypeBounds(lo2, hi2)) =&gt;
        lo1 =:= lo2 &amp;&amp; hi1 =:= hi2
      case (BoundedWildcardType(bounds), _) =&gt;
        bounds containsType tp2
      case (_, BoundedWildcardType(bounds)) =&gt;
        bounds containsType tp1
      case (tv @ TypeVar(_,_), tp) =&gt;
        tv.registerTypeEquality(tp, true)
      case (tp, tv @ TypeVar(_,_)) =&gt;
        tv.registerTypeEquality(tp, false)
      case (AnnotatedType(_,_,_), _) =&gt;
        annotationsConform(tp1, tp2) &amp;&amp; annotationsConform(tp2, tp1) &amp;&amp; tp1.withoutAnnotations =:= tp2.withoutAnnotations
      case (_, AnnotatedType(_,_,_)) =&gt;
        annotationsConform(tp1, tp2) &amp;&amp; annotationsConform(tp2, tp1) &amp;&amp; tp1.withoutAnnotations =:= tp2.withoutAnnotations
      case (_: SingletonType, _: SingletonType) =&gt;
        var origin1 = tp1
        while (origin1.underlying.isInstanceOf[SingletonType]) {
          assert(origin1 ne origin1.underlying, origin1)
          origin1 = origin1.underlying
        }
        var origin2 = tp2
        while (origin2.underlying.isInstanceOf[SingletonType]) {
          assert(origin2 ne origin2.underlying, origin2)
          origin2 = origin2.underlying
        }
        ((origin1 ne tp1) || (origin2 ne tp2)) &amp;&amp; (origin1 =:= origin2)
      case _ =&gt;
        false
    }) || {
      val tp1n = normalizePlus(tp1)
      val tp2n = normalizePlus(tp2)
      ((tp1n ne tp1) || (tp2n ne tp2)) &amp;&amp; isSameType(tp1n, tp2n)
    }
  }
*/
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="39048">isSameType1</a><span class="delimiter">(</span><a title="Types.this.Type" id="141878">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141879">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141878" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#141879" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
        <span class="delimiter">(</span><a href="#141878" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131624" title="object Types.this.ErrorType">ErrorType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#141878" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131644" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
        <span class="delimiter">(</span><a href="#141879" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131624" title="object Types.this.ErrorType">ErrorType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#141879" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131644" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141878" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#141879" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#141878" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span>
      <a href="#141879" title="Types.this.Type">tp2</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a>
    <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#141879" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span>
      <a href="#141878" title="Types.this.Type">tp1</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <a href="#39049" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType2</a><span class="delimiter">(</span><a href="#141878" title="Types.this.Type">tp1</a>, <a href="#141879" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="141930">tp1n</a> = <a href="#39047" title="(tp: Types.this.Type)Types.this.Type">normalizePlus</a><span class="delimiter">(</span><a href="#141878" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="141931">tp2n</a> = <a href="#39047" title="(tp: Types.this.Type)Types.this.Type">normalizePlus</a><span class="delimiter">(</span><a href="#141879" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141930" title="Types.this.Type">tp1n</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#141878" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#141931" title="Types.this.Type">tp2n</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#141879" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#39044" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a><span class="delimiter">(</span><a href="#141930" title="Types.this.Type">tp1n</a>, <a href="#141931" title="Types.this.Type">tp2n</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="39049">isSameType2</a><span class="delimiter">(</span><a title="Types.this.Type" id="141927">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="141928">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <a href="#141927" title="Types.this.Type">tp1</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Unit" id="141932">tr1</a>: <a href="#62154" title="Types.this.TypeRef">TypeRef</a> =&gt;
        <a href="#141928" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Nothing" id="141933">tr2</a>: <a href="#62154" title="Types.this.TypeRef">TypeRef</a> =&gt;
            <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span><a href="#39043" title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean">equalSymsAndPrefixes</a><span class="delimiter">(</span><a href="#141932" title="Types.this.TypeRef">tr1</a>.<a href="#62172" title="=&gt; Types.this.Symbol">sym</a>, <a href="#141932" title="Types.this.TypeRef">tr1</a>.<a href="#62171" title="=&gt; Types.this.Type">pre</a>, <a href="#141933" title="Types.this.TypeRef">tr2</a>.<a href="#62172" title="=&gt; Types.this.Symbol">sym</a>, <a href="#141933" title="Types.this.TypeRef">tr2</a>.<a href="#62171" title="=&gt; Types.this.Type">pre</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <span class="delimiter">(</span><span class="delimiter">(</span><a href="#141927" title="Types.this.Type">tp1</a>.<a href="#41490" title="=&gt; Boolean">isHigherKinded</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141928" title="Types.this.Type">tp2</a>.<a href="#41490" title="=&gt; Boolean">isHigherKinded</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141927" title="Types.this.Type">tp1</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141928" title="Types.this.Type">tp2</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
               <a href="#39050" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span><a href="#141932" title="Types.this.TypeRef">tr1</a>.<a href="#62173" title="=&gt; List[Types.this.Type]">args</a>, <a href="#141933" title="Types.this.TypeRef">tr2</a>.<a href="#62173" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
               <span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#141932" title="Types.this.TypeRef">tr1</a>.<a href="#62171" title="=&gt; Types.this.Type">pre</a>, <a href="#141933" title="Types.this.TypeRef">tr2</a>.<a href="#62171" title="=&gt; Types.this.Type">pre</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
                 <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span><a title="Types.this.TypeVar" id="141947">tv</a> @ <a href="#84008" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#141947" title="Types.this.TypeVar">tv</a>.<a href="#83987" title="(sym: Types.this.Symbol, tp: Types.this.Type)Boolean">registerTypeSelection</a><span class="delimiter">(</span><a href="#141932" title="Types.this.TypeRef">tr1</a>.<a href="#62172" title="=&gt; Types.this.Symbol">sym</a>, <a href="#141933" title="Types.this.TypeRef">tr2</a><span class="delimiter">)</span>
                 <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>_, <a title="Types.this.TypeVar" id="141951">tv</a> @ <a href="#84008" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#141951" title="Types.this.TypeVar">tv</a>.<a href="#83987" title="(sym: Types.this.Symbol, tp: Types.this.Type)Boolean">registerTypeSelection</a><span class="delimiter">(</span><a href="#141933" title="Types.this.TypeRef">tr2</a>.<a href="#62172" title="=&gt; Types.this.Symbol">sym</a>, <a href="#141932" title="Types.this.TypeRef">tr1</a><span class="delimiter">)</span>
                 <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
               <span class="delimiter">}</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="141953">tt1</a>: <a href="#83190" title="Types.this.ThisType">ThisType</a> =&gt;
        <a href="#141928" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Unit" id="141954">tt2</a>: <a href="#83190" title="Types.this.ThisType">ThisType</a> =&gt;
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#141953" title="Types.this.ThisType">tt1</a>.<a href="#83198" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#141954" title="Types.this.ThisType">tt2</a>.<a href="#83198" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="141959">st1</a>: <a href="#83233" title="Types.this.SingleType">SingleType</a> =&gt;
        <a href="#141928" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Unit" id="141960">st2</a>: <a href="#83233" title="Types.this.SingleType">SingleType</a> =&gt;
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#39043" title="(sym1: Types.this.Symbol, pre1: Types.this.Type, sym2: Types.this.Symbol, pre2: Types.this.Type)Boolean">equalSymsAndPrefixes</a><span class="delimiter">(</span><a href="#141959" title="Types.this.SingleType">st1</a>.<a href="#83248" title="=&gt; Types.this.Symbol">sym</a>, <a href="#141959" title="Types.this.SingleType">st1</a>.<a href="#83247" title="=&gt; Types.this.Type">pre</a>, <a href="#141960" title="Types.this.SingleType">st2</a>.<a href="#83248" title="=&gt; Types.this.Symbol">sym</a>, <a href="#141960" title="Types.this.SingleType">st2</a>.<a href="#83247" title="=&gt; Types.this.Type">pre</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="141961">ct1</a>: <a href="#83388" title="Types.this.ConstantType">ConstantType</a> =&gt;
        <a href="#141928" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Nothing" id="141962">ct2</a>: <a href="#83388" title="Types.this.ConstantType">ConstantType</a> =&gt;
            <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span><a href="#141961" title="Types.this.ConstantType">ct1</a>.<a href="#83396" title="=&gt; Types.this.Constant">value</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#141962" title="Types.this.ConstantType">ct2</a>.<a href="#83396" title="=&gt; Types.this.Constant">value</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="141967">rt1</a>: <a href="#60409" title="Types.this.RefinedType">RefinedType</a> =&gt;
        <a href="#141928" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Nothing" id="141968">rt2</a>: <a href="#60409" title="Types.this.RefinedType">RefinedType</a> =&gt; //
            <span class="keyword">def</span> <a title="(s1: Types.this.Scope, s2: Types.this.Scope)Boolean" id="141969">isSubScope</a><span class="delimiter">(</span><a title="Types.this.Scope" id="141970">s1</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a>, <a title="Types.this.Scope" id="141971">s2</a>: <a href="Scopes.scala.html#39174" title="Types.this.Scope">Scope</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#141971" title="Types.this.Scope">s2</a>.<a href="Scopes.scala.html#60510" title="=&gt; List[Types.this.Symbol]">toList</a>.<span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">{</span>
              <a title="Types.this.Symbol" id="141980">sym2</a> =&gt;
                <span class="keyword">var</span> <a title="Types.this.ScopeEntry" id="141981">e1</a> = <a href="#141970" title="Types.this.Scope">s1</a>.<a href="Scopes.scala.html#60508" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#141980" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>
                <span class="delimiter">(</span><a href="#141981" title="Types.this.ScopeEntry">e1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
                  <span class="keyword">val</span> <a title="Types.this.Type" id="141983">substSym</a> = <a href="#141980" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41561" title="(from: Types.this.Symbol, to: Types.this.Symbol)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#141980" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>, <a href="#141981" title="Types.this.ScopeEntry">e1</a>.<a href="Scopes.scala.html#92379" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
                  <span class="keyword">var</span> <a title="Boolean" id="141984">isEqual</a> = <span title="Boolean(false)" class="keyword">false</span>
                  <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#141984" title="Boolean">isEqual</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#141981" title="Types.this.ScopeEntry">e1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#141985" title="()Unit" class="delimiter">{</a>
                    <a href="#141984" title="Boolean">isEqual</a> = <a href="#141981" title="Types.this.ScopeEntry">e1</a>.<a href="Scopes.scala.html#92379" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141983" title="Types.this.Type">substSym</a>
                    <a href="#141981" title="Types.this.ScopeEntry">e1</a> = <a href="#141970" title="Types.this.Scope">s1</a>.<a href="Scopes.scala.html#60509" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a><span class="delimiter">(</span><a href="#141981" title="Types.this.ScopeEntry">e1</a><span class="delimiter">)</span>
                  <span class="delimiter">}</span>
                  <a href="#141984" title="Boolean">isEqual</a>
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            //Console.println(&quot;is same? &quot; + tp1 + &quot; &quot; + tp2 + &quot; &quot; + tp1.typeSymbol.owner + &quot; &quot; + tp2.typeSymbol.owner)//DEBUG
            <span title="Nothing" class="keyword">return</span> <a href="#39050" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span><a href="#141967" title="Types.this.RefinedType">rt1</a>.<a href="#83648" title="=&gt; List[Types.this.Type]">parents</a>, <a href="#141968" title="Types.this.RefinedType">rt2</a>.<a href="#83648" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Scope" id="141994">decls1</a> = <a href="#141967" title="Types.this.RefinedType">rt1</a>.<a href="#83649" title="=&gt; Types.this.Scope">decls</a>
              <span class="keyword">val</span> <a title="Types.this.Scope" id="141995">decls2</a> = <a href="#141968" title="Types.this.RefinedType">rt2</a>.<a href="#83649" title="=&gt; Types.this.Scope">decls</a>
              <a href="#141969" title="(s1: Types.this.Scope, s2: Types.this.Scope)Boolean">isSubScope</a><span class="delimiter">(</span><a href="#141994" title="Types.this.Scope">decls1</a>, <a href="#141995" title="Types.this.Scope">decls2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141969" title="(s1: Types.this.Scope, s2: Types.this.Scope)Boolean">isSubScope</a><span class="delimiter">(</span><a href="#141995" title="Types.this.Scope">decls2</a>, <a href="#141994" title="Types.this.Scope">decls1</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Unit" id="141996">mt1</a>: <a href="#62346" title="Types.this.MethodType">MethodType</a> =&gt;
        <a href="#141928" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Nothing" id="141997">mt2</a>: <a href="#62346" title="Types.this.MethodType">MethodType</a> =&gt;
            <span title="Nothing" class="keyword">return</span> <a href="#39050" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span><a href="#141996" title="Types.this.MethodType">mt1</a>.<a href="#62361" title="=&gt; List[Types.this.Type]">paramTypes</a>, <a href="#141997" title="Types.this.MethodType">mt2</a>.<a href="#62361" title="=&gt; List[Types.this.Type]">paramTypes</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <a href="#141996" title="Types.this.MethodType">mt1</a>.<a href="#70168" title="=&gt; Types.this.Type">resultType</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141997" title="Types.this.MethodType">mt2</a>.<a href="#70168" title="=&gt; Types.this.Type">resultType</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#141997" title="Types.this.MethodType">mt2</a>.<a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#141996" title="Types.this.MethodType">mt1</a>.<a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <a href="#141996" title="Types.this.MethodType">mt1</a>.<a href="#62357" title="=&gt; Boolean">isImplicit</a> <span title="(x: Boolean)Boolean">==</span> <a href="#141997" title="Types.this.MethodType">mt2</a>.<a href="#62357" title="=&gt; Boolean">isImplicit</a>
          // note: no case NullaryMethodType(restpe) =&gt; return mt1.params.isEmpty &amp;&amp; mt1.resultType =:= restpe
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Unit">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="142008">restpe1</a><span class="delimiter">)</span> =&gt;
        <a href="#141928" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          // note: no case mt2: MethodType =&gt; return mt2.params.isEmpty &amp;&amp; restpe  =:= mt2.resultType
          <span class="keyword">case</span> <span title="Nothing">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="142009">restpe2</a><span class="delimiter">)</span> =&gt;
            <span title="Nothing" class="keyword">return</span> <a href="#142008" title="Types.this.Type">restpe1</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#142009" title="Types.this.Type">restpe2</a>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Unit">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="142011">tparams1</a>, <a title="Types.this.Type" id="142012">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#141928" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Nothing">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="142013">tparams2</a>, <a title="Types.this.Type" id="142014">res2</a><span class="delimiter">)</span> =&gt;
//            assert((tparams1 map (_.typeParams.length)) == (tparams2 map (_.typeParams.length)))
              // @M looks like it might suffer from same problem as #2210
              <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span>
                <span class="delimiter">(</span><a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#142011" title="List[Types.this.Symbol]">tparams1</a>, <a href="#142013" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> // corresponds does not check length of two sequences before checking the predicate
                <span class="delimiter">(</span><a href="#142011" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#142013" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#142039" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#142040" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#142013" title="List[Types.this.Symbol]">tparams2</a>, <a href="#142011" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                <a href="#142012" title="Types.this.Type">res1</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#142014" title="Types.this.Type">res2</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#142013" title="List[Types.this.Symbol]">tparams2</a>, <a href="#142011" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>
              <span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Unit">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="142044">tparams1</a>, <a title="Types.this.Type" id="142045">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#141928" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Nothing">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="142046">tparams2</a>, <a title="Types.this.Type" id="142047">res2</a><span class="delimiter">)</span> =&gt;
            // @M looks like it might suffer from same problem as #2210
            <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span>
              // corresponds does not check length of two sequences before checking the predicate -- faster &amp; needed to avoid crasher in #2956
              <a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#142044" title="List[Types.this.Symbol]">tparams1</a>, <a href="#142046" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <span class="delimiter">(</span><a href="#142044" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#142046" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#142072" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#142073" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#142046" title="List[Types.this.Symbol]">tparams2</a>, <a href="#142044" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <a href="#142045" title="Types.this.Type">res1</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#142047" title="Types.this.Type">res2</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#142046" title="List[Types.this.Symbol]">tparams2</a>, <a href="#142044" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>
            <span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Unit">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="142077">lo1</a>, <a title="Types.this.Type" id="142078">hi1</a><span class="delimiter">)</span> =&gt;
        <a href="#141928" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Nothing">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="142079">lo2</a>, <a title="Types.this.Type" id="142080">hi2</a><span class="delimiter">)</span> =&gt;
            <span title="Nothing" class="keyword">return</span> <a href="#142077" title="Types.this.Type">lo1</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#142079" title="Types.this.Type">lo2</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#142078" title="Types.this.Type">hi1</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#142080" title="Types.this.Type">hi2</a>
          <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Nothing">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="142083">bounds</a><span class="delimiter">)</span> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="#142083" title="Types.this.TypeBounds">bounds</a> <a href="#62306" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#141928" title="Types.this.Type">tp2</a>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#141928" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Nothing">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="142084">bounds</a><span class="delimiter">)</span> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="#142084" title="Types.this.TypeBounds">bounds</a> <a href="#62306" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#141927" title="Types.this.Type">tp1</a>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#141927" title="Types.this.Type">tp1</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Nothing" id="142085">tv</a> @ <a href="#84008" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="#142085" title="Types.this.TypeVar">tv</a>.<a href="#83986" title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean">registerTypeEquality</a><span class="delimiter">(</span><a href="#141928" title="Types.this.Type">tp2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#141928" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Nothing" id="142087">tv</a> @ <a href="#84008" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="#142087" title="Types.this.TypeVar">tv</a>.<a href="#83986" title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean">registerTypeEquality</a><span class="delimiter">(</span><a href="#141927" title="Types.this.Type">tp1</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#141927" title="Types.this.Type">tp1</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Nothing">_</span>: <a href="#58221" title="Types.this.AnnotatedType">AnnotatedType</a> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="AnnotationCheckers.scala.html#34938" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#141927" title="Types.this.Type">tp1</a>, <a href="#141928" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#34938" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#141928" title="Types.this.Type">tp2</a>, <a href="#141927" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141927" title="Types.this.Type">tp1</a>.<a href="#41598" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141928" title="Types.this.Type">tp2</a>.<a href="#41598" title="=&gt; Types.this.Type">withoutAnnotations</a>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#141928" title="Types.this.Type">tp2</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Nothing">_</span>: <a href="#58221" title="Types.this.AnnotatedType">AnnotatedType</a> =&gt;
        <span title="Nothing" class="keyword">return</span> <a href="AnnotationCheckers.scala.html#34938" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#141927" title="Types.this.Type">tp1</a>, <a href="#141928" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#34938" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#141928" title="Types.this.Type">tp2</a>, <a href="#141927" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#141927" title="Types.this.Type">tp1</a>.<a href="#41598" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#141928" title="Types.this.Type">tp2</a>.<a href="#41598" title="=&gt; Types.this.Type">withoutAnnotations</a>
      <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
    <span class="delimiter">}</span>
    <a href="#141927" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="#38819" title="Types.this.SingletonType">SingletonType</a> =&gt;
        <a href="#141928" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="#38819" title="Types.this.SingletonType">SingletonType</a> =&gt;
            @inline <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="142095">chaseDealiasedUnderlying</a><span class="delimiter">(</span><a title="Types.this.Type" id="142098">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
              <span class="keyword">var</span> <a title="Types.this.Type" id="142099">origin</a> = <a href="#142098" title="Types.this.Type">tp</a>
              <span class="keyword">var</span> <a title="Types.this.Type" id="142100">next</a> = <a href="#142099" title="Types.this.Type">origin</a>.<a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41535" title="=&gt; Types.this.Type">dealias</a>
              <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#142100" title="Types.this.Type">next</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#38819" title="Types.this.SingletonType">SingletonType</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#142101" title="()Unit" class="delimiter">{</a>
                <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><a href="#142099" title="Types.this.Type">origin</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#142100" title="Types.this.Type">next</a>, <a href="#142099" title="Types.this.Type">origin</a><span class="delimiter">)</span>
                <a href="#142099" title="Types.this.Type">origin</a> = <a href="#142100" title="Types.this.Type">next</a>
                <a href="#142100" title="Types.this.Type">next</a> = <a href="#142099" title="Types.this.Type">origin</a>.<a href="#41507" title="=&gt; Types.this.Type">underlying</a>.<a href="#41535" title="=&gt; Types.this.Type">dealias</a>
              <span class="delimiter">}</span>
              <a href="#142099" title="Types.this.Type">origin</a>
            <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="142096">origin1</a> = <a href="#142095" title="(tp: Types.this.Type)Types.this.Type">chaseDealiasedUnderlying</a><span class="delimiter">(</span><a href="#141927" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="142097">origin2</a> = <a href="#142095" title="(tp: Types.this.Type)Types.this.Type">chaseDealiasedUnderlying</a><span class="delimiter">(</span><a href="#141928" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
            <span class="delimiter">(</span><span class="delimiter">(</span><a href="#142096" title="Types.this.Type">origin1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#141927" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#142097" title="Types.this.Type">origin2</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#141928" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#142096" title="Types.this.Type">origin1</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#142097" title="Types.this.Type">origin2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
        <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Are `tps1` and `tps2` lists of pairwise equivalent types? */
  <span class="keyword">def</span> <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean" id="39050">isSameTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="141936">tps1</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="141937">tps2</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#141936" title="List[Types.this.Type]">tps1</a> <span title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.Type, Types.this.Type) =&gt; Boolean)Boolean">corresponds</span> <a href="#141937" title="List[Types.this.Type]">tps2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#142129" title="Types.this.Type">_</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#142130" title="Types.this.Type">_</a><span class="delimiter">)</span>

  /** True if two lists have the same length.  Since calling length on linear sequences
   *  is O(n), it is an inadvisable way to test length equality.
   */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(xs1: List[_], xs2: List[_])Boolean" id="39051">sameLength</a><span class="delimiter">(</span><a title="List[_]" id="75441">xs1</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="List[_]" id="75442">xs2</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#39052" title="(xs1: List[_], xs2: List[_])Int">compareLengths</a><span class="delimiter">(</span><a href="#75441" title="List[_]">xs1</a>, <a href="#75442" title="List[_]">xs2</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span>
  @tailrec <span class="keyword">final</span> <span class="keyword">def</span> <a title="(xs1: List[_], xs2: List[_])Int" id="39052">compareLengths</a><span class="delimiter">(</span><a title="List[_]" id="75445">xs1</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="List[_]" id="75446">xs2</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> =
    <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#75445" title="List[_]">xs1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#75446" title="List[_]">xs2</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> <span class="keyword">else</span> -<span title="Int(-1)" class="int">1</span> <span class="delimiter">}</span>
    <span class="keyword">else</span> <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#75446" title="List[_]">xs2</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="Int(1)" class="int">1</span>
    <span class="keyword">else</span> <a href="#39052" title="(xs1: List[_], xs2: List[_])Int">compareLengths</a><span class="delimiter">(</span><a href="#75445" title="List[_]">xs1</a>.<span title="=&gt; List[_$3]">tail</span>, <a href="#75446" title="List[_]">xs2</a>.<span title="=&gt; List[_$4]">tail</span><span class="delimiter">)</span>

  /** Again avoiding calling length, but the lengthCompare interface is clunky.
   */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(xs: List[_], len: Int)Boolean" id="39053">hasLength</a><span class="delimiter">(</span><a title="List[_]" id="134528">xs</a>: <span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Int" id="134529">len</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="#134528" title="List[_]">xs</a>.<span title="(len: Int)Int">lengthCompare</span><span class="delimiter">(</span><a href="#134529" title="Int">len</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.SubTypePair]" id="39054">pendingSubTypes</a> = <span title="()scala.collection.mutable.HashSet[Types.this.SubTypePair]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Types.this.SubTypePair]">HashSet</span><span class="delimiter">[</span>SubTypePair<span class="delimiter">]</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="39057">basetypeRecursions</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Types.this.Type]" id="39059">pendingBaseTypes</a> = <span title="()scala.collection.mutable.HashSet[Types.this.Type]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashSet[Types.this.Type]">HashSet</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="39061">isSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="73763">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="73764">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#39062" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#73763" title="Types.this.Type">tp1</a>, <a href="#73764" title="Types.this.Type">tp2</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean" id="39062">isSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="73756">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="73757">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Int" id="73758">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="keyword">try</span> <span class="delimiter">{</span>
    <a href="#39039" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>

    <a href="#38802" title="=&gt; Types.this.UndoLog">undoLog</a> <a href="#129898" title="(block: =&gt; Boolean)Boolean">undoUnless</a> <span class="delimiter">{</span> // if subtype test fails, it should not affect constraints on typevars
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#39039" title="=&gt; Int">subsametypeRecursions</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(50)">LogPendingSubTypesThreshold</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Types.this.SubTypePair" id="142159">p</a> = <span title="Types.this.SubTypePair" class="keyword">new</span> <a href="#39032" title="Types.this.SubTypePair">SubTypePair</a><span class="delimiter">(</span><a href="#73756" title="Types.this.Type">tp1</a>, <a href="#73757" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#39054" title="(elem: Types.this.SubTypePair)Boolean">pendingSubTypes</a><span class="delimiter">(</span><a href="#142159" title="Types.this.SubTypePair">p</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">else</span>
          <span class="keyword">try</span> <span class="delimiter">{</span>
            <a href="#39054" title="=&gt; scala.collection.mutable.HashSet[Types.this.SubTypePair]">pendingSubTypes</a> <span title="(elem: Types.this.SubTypePair)Types.this.pendingSubTypes.type">+=</span> <a href="#142159" title="Types.this.SubTypePair">p</a>
            <a href="#39072" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType2</a><span class="delimiter">(</span><a href="#73756" title="Types.this.Type">tp1</a>, <a href="#73757" title="Types.this.Type">tp2</a>, <a href="#73758" title="Int">depth</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            <a href="#39054" title="=&gt; scala.collection.mutable.HashSet[Types.this.SubTypePair]">pendingSubTypes</a> <span title="(elem: Types.this.SubTypePair)Types.this.pendingSubTypes.type">-=</span> <a href="#142159" title="Types.this.SubTypePair">p</a>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#39072" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType2</a><span class="delimiter">(</span><a href="#73756" title="Types.this.Type">tp1</a>, <a href="#73757" title="Types.this.Type">tp2</a>, <a href="#73758" title="Int">depth</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
    <a href="#39039" title="(x$1: Int)Unit">subsametypeRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
    // XXX AM TODO: figure out when it is safe and needed to clear the log -- the commented approach below is too eager (it breaks #3281, #3866)
    // it doesn't help to keep separate recursion counts for the three methods that now share it
    // if (subsametypeRecursions == 0) undoLog.clear()
  <span class="delimiter">}</span>

  /** Does this type have a prefix that begins with a type variable,
   *  or is it a refinement type? For type prefixes that fulfil this condition,
   *  type selections with the same name of equal (wrt) =:= prefixes are
   *  considered equal wrt =:=
   */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="39063">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a title="Types.this.Type" id="141838">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#141838" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="142206">pre</a>, <a title="Types.this.Symbol" id="142207">sym</a><span class="delimiter">)</span> =&gt;
      <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#142207" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#46593" title="(mask: Long)Boolean">hasFlag</a> <span title="Long(16384L)">PACKAGE</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#39063" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#142206" title="Types.this.Type">pre</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="Boolean" id="142208">tv</a>@<a href="#84008" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="142210">constr</a><span class="delimiter">)</span> =&gt;
      <span title="=&gt; Boolean">!</span><a href="#142208" title="Types.this.TypeVar">tv</a>.<a href="#83971" title="=&gt; Boolean">instValid</a> <span title="(x: Boolean)Boolean">||</span> <a href="#39063" title="(tp: Types.this.Type)Boolean">beginsWithTypeVarOrIsRefined</a><span class="delimiter">(</span><a href="#142210" title="Types.this.TypeConstraint">constr</a>.<a href="#84069" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Boolean(true)">RefinedType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
      <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
      <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="39064">instTypeVar</a><span class="delimiter">(</span><a title="Types.this.Type" id="142211">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#142211" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="142213">pre</a>, <a title="Types.this.Symbol" id="142214">sym</a>, <a title="List[Types.this.Type]" id="142215">args</a><span class="delimiter">)</span> =&gt;
      <a href="#38935" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#142211" title="Types.this.Type">tp</a>, <a href="#39064" title="(tp: Types.this.Type)Types.this.Type">instTypeVar</a><span class="delimiter">(</span><a href="#142213" title="Types.this.Type">pre</a><span class="delimiter">)</span>, <a href="#142214" title="Types.this.Symbol">sym</a>, <a href="#142215" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">SingleType</span><span class="delimiter">(</span><a title="Types.this.Type" id="142216">pre</a>, <a title="Types.this.Symbol" id="142217">sym</a><span class="delimiter">)</span> =&gt;
      <a href="#38930" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#39064" title="(tp: Types.this.Type)Types.this.Type">instTypeVar</a><span class="delimiter">(</span><a href="#142216" title="Types.this.Type">pre</a><span class="delimiter">)</span>, <a href="#142217" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a href="#84008" title="Types.this.Type">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="142219">constr</a><span class="delimiter">)</span> =&gt;
      <a href="#39064" title="(tp: Types.this.Type)Types.this.Type">instTypeVar</a><span class="delimiter">(</span><a href="#142219" title="Types.this.TypeConstraint">constr</a>.<a href="#84069" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <a href="#142211" title="Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="39065">isErrorOrWildcard</a><span class="delimiter">(</span><a title="Types.this.Type" id="142220">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#142220" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131624" title="object Types.this.ErrorType">ErrorType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#142220" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131644" title="object Types.this.WildcardType">WildcardType</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="39066">isSingleType</a><span class="delimiter">(</span><a title="Types.this.Type" id="142223">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#142223" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean(true)">ThisType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> | SuperType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> | SingleType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="39067">isConstantType</a><span class="delimiter">(</span><a title="Types.this.Type" id="114443">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#114443" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean(true)">ConstantType</span><span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>

  // @assume tp1.isHigherKinded || tp2.isHigherKinded
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean" id="39068">isHKSubType0</a><span class="delimiter">(</span><a title="Types.this.Type" id="142226">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="142227">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Int" id="142228">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span>
    <a href="#142226" title="Types.this.Type">tp1</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a>
    <span title="(x: Boolean)Boolean">||</span>
    <a href="#142227" title="Types.this.Type">tp2</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a> // @M Any and Nothing are super-type resp. subtype of every well-kinded type
    <span title="(x: Boolean)Boolean">||</span> // @M! normalize reduces higher-kinded case to PolyType's
    <span class="delimiter">(</span><span title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</span><a href="#142226" title="Types.this.Type">tp1</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a>.<a href="#41598" title="=&gt; Types.this.Type">withoutAnnotations</a> , <a href="#142227" title="Types.this.Type">tp2</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a>.<a href="#41598" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span>PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="142250">tparams1</a>, <a title="Types.this.Type" id="142251">res1</a><span class="delimiter">)</span>, PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="142252">tparams2</a>, <a title="Types.this.Type" id="142253">res2</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; // @assume tp1.isHigherKinded &amp;&amp; tp2.isHigherKinded (as they were both normalized to PolyType)
        <a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#142250" title="List[Types.this.Symbol]">tparams1</a>, <a href="#142252" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#142250" title="List[Types.this.Symbol]">tparams1</a>.<span title="=&gt; Types.this.Symbol">head</span>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#46461" title="=&gt; Boolean">isMethod</a><span class="delimiter">)</span> <span class="delimiter">{</span>  // fast-path: polymorphic method type -- type params cannot be captured
            <span class="delimiter">(</span><a href="#142250" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#142252" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="142279">p1</a>, <a title="Types.this.Symbol" id="142280">p2</a><span class="delimiter">)</span> =&gt; <a href="#142280" title="Types.this.Symbol">p2</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#142252" title="List[Types.this.Symbol]">tparams2</a>, <a href="#142250" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142279" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#142251" title="Types.this.Type">res1</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142253" title="Types.this.Type">res2</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#142252" title="List[Types.this.Symbol]">tparams2</a>, <a href="#142250" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span> // normalized higher-kinded type
            //@M for an example of why we need to generate fresh symbols, see neg/tcpoly_ticket2101.scala
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="142284">tpsFresh</a> = <a href="Symbols.scala.html#38745" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#142250" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>

            <span class="delimiter">(</span><a href="#142250" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#142252" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="142304">p1</a>, <a title="Types.this.Symbol" id="142305">p2</a><span class="delimiter">)</span> =&gt;
              <a href="#142305" title="Types.this.Symbol">p2</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#142252" title="List[Types.this.Symbol]">tparams2</a>, <a href="#142284" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142304" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#142250" title="List[Types.this.Symbol]">tparams1</a>, <a href="#142284" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#142251" title="Types.this.Type">res1</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#142250" title="List[Types.this.Symbol]">tparams1</a>, <a href="#142284" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142253" title="Types.this.Type">res2</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#142252" title="List[Types.this.Symbol]">tparams2</a>, <a href="#142284" title="List[Types.this.Symbol]">tpsFresh</a><span class="delimiter">)</span>

            //@M the forall in the previous test could be optimised to the following,
            // but not worth the extra complexity since it only shaves 1s from quick.comp
            //   (List.forall2(tpsFresh/*optimisation*/, tparams2)((p1, p2) =&gt;
            //   p2.info.substSym(tparams2, tpsFresh) &lt;:&lt; p1.info /*optimisation, == (p1 from tparams1).info.substSym(tparams1, tpsFresh)*/) &amp;&amp;
            // this optimisation holds because inlining cloneSymbols in `val tpsFresh = cloneSymbols(tparams1)` gives:
            // val tpsFresh = tparams1 map (_.cloneSymbol)
            // for (tpFresh &lt;- tpsFresh) tpFresh.setInfo(tpFresh.info.substSym(tparams1, tpsFresh))
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#34938" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#142226" title="Types.this.Type">tp1</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a>, <a href="#142227" title="Types.this.Type">tp2</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean(false)" class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <span title="Boolean(false)" class="keyword">false</span> // @assume !tp1.isHigherKinded || !tp2.isHigherKinded
      // --&gt; thus, cannot be subtypes (Any/Nothing has already been checked)
    <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(t1: Types.this.Type, t2: Types.this.Type, variance: Int)Boolean" id="39069">isSubArg</a><span class="delimiter">(</span><a title="Types.this.Type" id="142312">t1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="142313">t2</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Int" id="142314">variance</a>: <span title="Int">Int</span><span class="delimiter">)</span> =
    <span class="delimiter">(</span><a href="#142314" title="Int">variance</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#142313" title="Types.this.Type">t2</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142312" title="Types.this.Type">t1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#142314" title="Int">variance</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#142312" title="Types.this.Type">t1</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142313" title="Types.this.Type">t2</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean" id="39070">isSubArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="137003">tps1</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="137004">tps2</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="137005">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="util/Collections.scala.html#38278" title="(xs1: List[Types.this.Type], xs2: List[Types.this.Type], xs3: List[Int])(f: (Types.this.Type, Types.this.Type, Int) =&gt; Boolean)Boolean">corresponds3</a><span class="delimiter">(</span><a href="#137003" title="List[Types.this.Type]">tps1</a>, <a href="#137004" title="List[Types.this.Type]">tps2</a>, <a href="#137005" title="List[Types.this.Symbol]">tparams</a> <span title="(f: Types.this.Symbol =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Int,List[Int]])List[Int]">map</span> <span class="delimiter">(</span><a href="#142360" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46562" title="=&gt; Int">variance</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#39069" title="(t1: Types.this.Type, t2: Types.this.Type, variance: Int)Boolean">isSubArg</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Types.this.Type" id="39071">differentOrNone</a><span class="delimiter">(</span><a title="Types.this.Type" id="142441">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="142442">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#142441" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#142442" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <a href="#131699" title="object Types.this.NoType">NoType</a> <span class="keyword">else</span> <a href="#142441" title="Types.this.Type">tp1</a>

  /** Does type `tp1` conform to `tp2`? */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean" id="39072">isSubType2</a><span class="delimiter">(</span><a title="Types.this.Type" id="142188">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="142189">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Int" id="142190">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#142189" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#39065" title="(tp: Types.this.Type)Boolean">isErrorOrWildcard</a><span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#39065" title="(tp: Types.this.Type)Boolean">isErrorOrWildcard</a><span class="delimiter">(</span><a href="#142189" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(true)" class="keyword">true</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#142189" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span title="Boolean(false)" class="keyword">false</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <span class="delimiter">(</span><a href="#142189" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#142189" title="Types.this.Type">tp2</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#142189" title="Types.this.Type">tp2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#131723" title="object Types.this.NoPrefix">NoPrefix</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#142188" title="Types.this.Type">tp1</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46475" title="=&gt; Boolean">isPackageClass</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#39066" title="(tp: Types.this.Type)Boolean">isSingleType</a><span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#39066" title="(tp: Types.this.Type)Boolean">isSingleType</a><span class="delimiter">(</span><a href="#142189" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#39067" title="(tp: Types.this.Type)Boolean">isConstantType</a><span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#39067" title="(tp: Types.this.Type)Boolean">isConstantType</a><span class="delimiter">(</span><a href="#142189" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#142188" title="Types.this.Type">tp1</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#142189" title="Types.this.Type">tp2</a>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a>.<a href="#41490" title="=&gt; Boolean">isHigherKinded</a> <span title="(x: Boolean)Boolean">||</span> <a href="#142189" title="Types.this.Type">tp2</a>.<a href="#41490" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span title="Nothing" class="keyword">return</span> <a href="#39068" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isHKSubType0</a><span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a>, <a href="#142189" title="Types.this.Type">tp2</a>, <a href="#142190" title="Int">depth</a><span class="delimiter">)</span>

    /** First try, on the right:
     *   - unwrap Annotated types, BoundedWildcardTypes,
     *   - bind TypeVars  on the right, if lhs is not Annotated nor BoundedWildcard
     *   - handle common cases for first-kind TypeRefs on both sides as a fast path.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="142445">firstTry</a> = <a href="#142189" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      // fast path: two typerefs, none of them HK
      <span class="keyword">case</span> <a title="Boolean" id="142451">tr2</a>: <a href="#62154" title="Types.this.TypeRef">TypeRef</a> =&gt;
        <a href="#142188" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="142452">tr1</a>: <a href="#62154" title="Types.this.TypeRef">TypeRef</a> =&gt;
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="142453">sym1</a> = <a href="#142452" title="Types.this.TypeRef">tr1</a>.<a href="#62172" title="=&gt; Types.this.Symbol">sym</a>
            <span class="keyword">val</span> <a title="Types.this.Symbol" id="142454">sym2</a> = <a href="#142451" title="Types.this.TypeRef">tr2</a>.<a href="#62172" title="=&gt; Types.this.Symbol">sym</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="142455">pre1</a> = <a href="#142452" title="Types.this.TypeRef">tr1</a>.<a href="#62171" title="=&gt; Types.this.Type">pre</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="142456">pre2</a> = <a href="#142451" title="Types.this.TypeRef">tr2</a>.<a href="#62171" title="=&gt; Types.this.Type">pre</a>
            <span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">(</span><span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#142453" title="Types.this.Symbol">sym1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#142454" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> <a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#142455" title="Types.this.Type">pre1</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142456" title="Types.this.Type">pre2</a>
               <span class="keyword">else</span> <span class="delimiter">(</span><a href="#142453" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#142454" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#142453" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46463" title="=&gt; Boolean">isModuleClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#142454" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46463" title="=&gt; Boolean">isModuleClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                     <span class="delimiter">(</span><a href="#39041" title="(pre1: Types.this.Type, pre2: Types.this.Type)Boolean">isUnifiable</a><span class="delimiter">(</span><a href="#142455" title="Types.this.Type">pre1</a>, <a href="#142456" title="Types.this.Type">pre2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#39042" title="(sym1: Types.this.Symbol, sym2: Types.this.Symbol, pre1: Types.this.Type, pre2: Types.this.Type)Boolean">isSameSpecializedSkolem</a><span class="delimiter">(</span><a href="#142453" title="Types.this.Symbol">sym1</a>, <a href="#142454" title="Types.this.Symbol">sym2</a>, <a href="#142455" title="Types.this.Type">pre1</a>, <a href="#142456" title="Types.this.Type">pre2</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                    <a href="#39070" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol])Boolean">isSubArgs</a><span class="delimiter">(</span><a href="#142452" title="Types.this.TypeRef">tr1</a>.<a href="#62173" title="=&gt; List[Types.this.Type]">args</a>, <a href="#142451" title="Types.this.TypeRef">tr2</a>.<a href="#62173" title="=&gt; List[Types.this.Type]">args</a>, <a href="#142453" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span><span class="delimiter">)</span>
             <span title="(x: Boolean)Boolean">||</span>
             <a href="#142454" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46445" title="=&gt; Boolean">isClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
               <span class="keyword">val</span> <a title="Types.this.Type" id="142467">base</a> = <a href="#142452" title="Types.this.TypeRef">tr1</a> <a href="#41553" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a> <a href="#142454" title="Types.this.Symbol">sym2</a>
               <span class="delimiter">(</span><a href="#142467" title="Types.this.Type">base</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#142452" title="Types.this.TypeRef">tr1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#142467" title="Types.this.Type">base</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142451" title="Types.this.TypeRef">tr2</a>
             <span class="delimiter">}</span>
             <span title="(x: Boolean)Boolean">||</span>
             <a href="#142447" title="(tp1: Types.this.Type, tp2: Types.this.TypeRef)Boolean">thirdTryRef</a><span class="delimiter">(</span><a href="#142452" title="Types.this.TypeRef">tr1</a>, <a href="#142451" title="Types.this.TypeRef">tr2</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#142446" title="=&gt; Boolean">secondTry</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">AnnotatedType</span><span class="delimiter">(</span>_, _, _<span class="delimiter">)</span> =&gt;
        <a href="#142188" title="Types.this.Type">tp1</a>.<a href="#41598" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142189" title="Types.this.Type">tp2</a>.<a href="#41598" title="=&gt; Types.this.Type">withoutAnnotations</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#34938" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a>, <a href="#142189" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="142598">bounds</a><span class="delimiter">)</span> =&gt;
        <a href="#142188" title="Types.this.Type">tp1</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142598" title="Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a>
      <span class="keyword">case</span> <a title="Boolean" id="142600">tv2</a> @ <a href="#84008" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="142602">constr2</a><span class="delimiter">)</span> =&gt;
        <a href="#142188" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">AnnotatedType</span><span class="delimiter">(</span>_, _, _<span class="delimiter">)</span> | BoundedWildcardType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
            <a href="#142446" title="=&gt; Boolean">secondTry</a>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#142600" title="Types.this.TypeVar">tv2</a>.<a href="#83985" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#142446" title="=&gt; Boolean">secondTry</a>
    <span class="delimiter">}</span>

    /** Second try, on the left:
     *   - unwrap AnnotatedTypes, BoundedWildcardTypes,
     *   - bind typevars,
     *   - handle existential types by skolemization.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="142446">secondTry</a> = <a href="#142188" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">AnnotatedType</span><span class="delimiter">(</span>_, _, _<span class="delimiter">)</span> =&gt;
        <a href="#142188" title="Types.this.Type">tp1</a>.<a href="#41598" title="=&gt; Types.this.Type">withoutAnnotations</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142189" title="Types.this.Type">tp2</a>.<a href="#41598" title="=&gt; Types.this.Type">withoutAnnotations</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="AnnotationCheckers.scala.html#34938" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">annotationsConform</a><span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a>, <a href="#142189" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">BoundedWildcardType</span><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="142474">bounds</a><span class="delimiter">)</span> =&gt;
        <a href="#142188" title="Types.this.Type">tp1</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62325" title="=&gt; Types.this.Type">lo</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142189" title="Types.this.Type">tp2</a>
      <span class="keyword">case</span> <a title="Boolean" id="142477">tv</a> @ <a href="#84008" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_,_<span class="delimiter">)</span> =&gt;
        <a href="#142477" title="Types.this.TypeVar">tv</a>.<a href="#83985" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#142189" title="Types.this.Type">tp2</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
        <span class="keyword">try</span> <span class="delimiter">{</span>
          <a href="#38800" title="(x$1: Int)Unit">skolemizationLevel</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
          <a href="#142188" title="Types.this.Type">tp1</a>.<a href="#41533" title="=&gt; Types.this.Type">skolemizeExistential</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142189" title="Types.this.Type">tp2</a>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
          <a href="#38800" title="(x$1: Int)Unit">skolemizationLevel</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#142448" title="=&gt; Boolean">thirdTry</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.TypeRef)Boolean" id="142447">thirdTryRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="142470">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.TypeRef" id="142471">tp2</a>: <a href="#62154" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="142603">sym2</a> = <a href="#142471" title="Types.this.TypeRef">tp2</a>.<a href="#62172" title="=&gt; Types.this.Symbol">sym</a>
      <a href="#142603" title="Types.this.Symbol">sym2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="Definitions.scala.html#45074" title="Boolean">NotNullClass</a> =&gt; <a href="#142470" title="Types.this.Type">tp1</a>.<a href="#41493" title="=&gt; Boolean">isNotNull</a>
        <span class="keyword">case</span> <a href="Definitions.scala.html#45085" title="Boolean">SingletonClass</a> =&gt; <a href="#142470" title="Types.this.Type">tp1</a>.<a href="#41491" title="=&gt; Boolean">isStable</a> <span title="(x: Boolean)Boolean">||</span> <a href="#142449" title="=&gt; Boolean">fourthTry</a>
        <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="Symbols.scala.html#38735" title="Types.this.ClassSymbol">ClassSymbol</a> =&gt;
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#38989" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><span class="delimiter">(</span><a href="#142603" title="Types.this.Symbol">sym2</a>, <a href="#142471" title="Types.this.TypeRef">tp2</a>.<a href="#62173" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#39062" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#142470" title="Types.this.Type">tp1</a>, <a href="#74770" title="(tp: Types.this.Type)Types.this.Type">rawToExistential</a><span class="delimiter">(</span><a href="#142471" title="Types.this.TypeRef">tp2</a><span class="delimiter">)</span>, <a href="#142190" title="Int">depth</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#142603" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#39303" title="object Types.this.tpnme">tpnme</a>.<a href="StdNames.scala.html#63620" title="=&gt; Types.this.tpnme.NameType">REFINE_CLASS_NAME</a><span class="delimiter">)</span>
            <a href="#39062" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#142470" title="Types.this.Type">tp1</a>, <a href="#142603" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>, <a href="#142190" title="Int">depth</a><span class="delimiter">)</span>
          <span class="keyword">else</span>
            <a href="#142449" title="=&gt; Boolean">fourthTry</a>
        <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="Symbols.scala.html#38733" title="Types.this.TypeSymbol">TypeSymbol</a> =&gt;
          <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#142603" title="Types.this.Symbol">sym2</a> <a href="Symbols.scala.html#46593" title="(mask: Long)Boolean">hasFlag</a> <span title="Long(16L)">DEFERRED</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="142625">tp2a</a> = <a href="#142471" title="Types.this.TypeRef">tp2</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62325" title="=&gt; Types.this.Type">lo</a>
            <a href="#39046" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isDifferentTypeConstructor</a><span class="delimiter">(</span><a href="#142471" title="Types.this.TypeRef">tp2</a>, <a href="#142625" title="Types.this.Type">tp2a</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#142470" title="Types.this.Type">tp1</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142625" title="Types.this.Type">tp2a</a> <span title="(x: Boolean)Boolean">||</span> <a href="#142449" title="=&gt; Boolean">fourthTry</a>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <a href="#39062" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#142470" title="Types.this.Type">tp1</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a>, <a href="#142471" title="Types.this.TypeRef">tp2</a>.<a href="#62120" title="=&gt; Types.this.Type">normalize</a>, <a href="#142190" title="Int">depth</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
          <a href="#142449" title="=&gt; Boolean">fourthTry</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** Third try, on the right:
     *   - decompose refined types.
     *   - handle typerefs, existentials, and notnull types.
     *   - handle left+right method types, polytypes, typebounds
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="142448">thirdTry</a> = <a href="#142189" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="142495">tr2</a>: <a href="#62154" title="Types.this.TypeRef">TypeRef</a> =&gt;
        <a href="#142447" title="(tp1: Types.this.Type, tp2: Types.this.TypeRef)Boolean">thirdTryRef</a><span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a>, <a href="#142495" title="Types.this.TypeRef">tr2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Boolean" id="142496">rt2</a>: <a href="#60409" title="Types.this.RefinedType">RefinedType</a> =&gt;
        <span class="delimiter">(</span><a href="#142496" title="Types.this.RefinedType">rt2</a>.<a href="#83648" title="=&gt; List[Types.this.Type]">parents</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142503" title="Types.this.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <span class="delimiter">(</span><a href="#142496" title="Types.this.RefinedType">rt2</a>.<a href="#83649" title="=&gt; Types.this.Scope">decls</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <a href="#142188" title="Types.this.Type">tp1</a>.<a href="#41576" title="(sym: Types.this.Symbol)Boolean">specializes</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Boolean" id="142511">et2</a>: <a href="#62567" title="Types.this.ExistentialType">ExistentialType</a> =&gt;
        <a href="#142511" title="Types.this.ExistentialType">et2</a>.<a href="#62597" title="(op: Types.this.Type =&gt; Boolean, depth: Int)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142515" title="Types.this.Type">_</a>, <a href="#142190" title="Int">depth</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#142449" title="=&gt; Boolean">fourthTry</a>
      <span class="keyword">case</span> <a title="Boolean" id="142560">nn2</a>: <a href="#147895" title="Types.this.NotNullType">NotNullType</a> =&gt;
        <a href="#142188" title="Types.this.Type">tp1</a>.<a href="#41493" title="=&gt; Boolean">isNotNull</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#142188" title="Types.this.Type">tp1</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142560" title="Types.this.NotNullType">nn2</a>.<a href="#84219" title="=&gt; Types.this.Type">underlying</a>
      <span class="keyword">case</span> <a title="Boolean" id="142562">mt2</a>: <a href="#62346" title="Types.this.MethodType">MethodType</a> =&gt;
        <a href="#142188" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="142563">mt1</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="142564">params1</a>, <a title="Types.this.Type" id="142565">res1</a><span class="delimiter">)</span> =&gt;
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="142566">params2</a> = <a href="#142562" title="Types.this.MethodType">mt2</a>.<a href="#70167" title="=&gt; List[Types.this.Symbol]">params</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="142567">res2</a> = <a href="#142562" title="Types.this.MethodType">mt2</a>.<a href="#70168" title="=&gt; Types.this.Type">resultType</a>
            <span class="delimiter">(</span><a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#142564" title="List[Types.this.Symbol]">params1</a>, <a href="#142566" title="List[Types.this.Symbol]">params2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
             <a href="#142563" title="Types.this.MethodType">mt1</a>.<a href="#62357" title="=&gt; Boolean">isImplicit</a> <span title="(x: Boolean)Boolean">==</span> <a href="#142562" title="Types.this.MethodType">mt2</a>.<a href="#62357" title="=&gt; Boolean">isImplicit</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
             <a href="#39077" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span><a href="#142564" title="List[Types.this.Symbol]">params1</a>, <a href="#142566" title="List[Types.this.Symbol]">params2</a>, <a href="#142563" title="Types.this.MethodType">mt1</a>.<a href="#62358" title="=&gt; Boolean">isJava</a>, <a href="#142562" title="Types.this.MethodType">mt2</a>.<a href="#62358" title="=&gt; Boolean">isJava</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
             <span class="delimiter">(</span><a href="#142565" title="Types.this.Type">res1</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142567" title="Types.this.Type">res2</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#142566" title="List[Types.this.Symbol]">params2</a>, <a href="#142564" title="List[Types.this.Symbol]">params1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          // TODO: if mt1.params.isEmpty, consider NullaryMethodType?
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Boolean" id="142583">pt2</a> @ NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
        <a href="#142188" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          // TODO: consider MethodType mt for which mt.params.isEmpty??
          <span class="keyword">case</span> <a title="Boolean" id="142584">pt1</a> @ NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
            <a href="#142584" title="Types.this.NullaryMethodType">pt1</a>.<a href="#71585" title="=&gt; Types.this.Type">resultType</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142583" title="Types.this.NullaryMethodType">pt2</a>.<a href="#71585" title="=&gt; Types.this.Type">resultType</a>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="142590">lo2</a>, <a title="Types.this.Type" id="142591">hi2</a><span class="delimiter">)</span> =&gt;
        <a href="#142188" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">TypeBounds</span><span class="delimiter">(</span><a title="Types.this.Type" id="142592">lo1</a>, <a title="Types.this.Type" id="142593">hi1</a><span class="delimiter">)</span> =&gt;
            <a href="#142590" title="Types.this.Type">lo2</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142592" title="Types.this.Type">lo1</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#142593" title="Types.this.Type">hi1</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142591" title="Types.this.Type">hi2</a>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#142449" title="=&gt; Boolean">fourthTry</a>
    <span class="delimiter">}</span>

    /** Fourth try, on the left:
     *   - handle typerefs, refined types, notnull and singleton types.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="142449">fourthTry</a> = <a href="#142188" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="142516">tr1</a> @ TypeRef<span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="142517">sym1</a>, _<span class="delimiter">)</span> =&gt;
        <a href="#142517" title="Types.this.Symbol">sym1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="Definitions.scala.html#44996" title="Boolean(true)">NothingClass</a> =&gt; <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">case</span> <a href="Definitions.scala.html#44998" title="Boolean">NullClass</a> =&gt;
            <a href="#142189" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="142518">sym2</a>, _<span class="delimiter">)</span> =&gt;
                <a href="#142518" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46445" title="=&gt; Boolean">isClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#142518" title="Types.this.Symbol">sym2</a> <a href="Symbols.scala.html#46649" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="Definitions.scala.html#44986" title="=&gt; Types.this.Symbol">ObjectClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
                <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#142189" title="Types.this.Type">tp2</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#46649" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="Definitions.scala.html#45074" title="=&gt; Types.this.Symbol">NotNullClass</a><span class="delimiter">)</span>
              <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
                <a href="#39066" title="(tp: Types.this.Type)Boolean">isSingleType</a><span class="delimiter">(</span><a href="#142189" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#142188" title="Types.this.Type">tp1</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142189" title="Types.this.Type">tp2</a>.<a href="#41508" title="=&gt; Types.this.Type">widen</a>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="Symbols.scala.html#38735" title="Types.this.ClassSymbol">ClassSymbol</a> =&gt;
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#38989" title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean">isRaw</a><span class="delimiter">(</span><a href="#142517" title="Types.this.Symbol">sym1</a>, <a href="#142516" title="Types.this.TypeRef">tr1</a>.<a href="#62173" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#39062" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#74770" title="(tp: Types.this.Type)Types.this.Type">rawToExistential</a><span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a><span class="delimiter">)</span>, <a href="#142189" title="Types.this.Type">tp2</a>, <a href="#142190" title="Int">depth</a><span class="delimiter">)</span>
            <span class="keyword">else</span>
              <a href="#142517" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="StdNames.scala.html#39303" title="object Types.this.tpnme">tpnme</a>.<a href="StdNames.scala.html#63620" title="=&gt; Types.this.tpnme.NameType">REFINE_CLASS_NAME</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
              <a href="#39062" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#142517" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>, <a href="#142189" title="Types.this.Type">tp2</a>, <a href="#142190" title="Int">depth</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="Symbols.scala.html#38733" title="Types.this.TypeSymbol">TypeSymbol</a> =&gt;
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#142517" title="Types.this.Symbol">sym1</a> <a href="Symbols.scala.html#46593" title="(mask: Long)Boolean">hasFlag</a> <span title="Long(16L)">DEFERRED</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="142543">tp1a</a> = <a href="#142188" title="Types.this.Type">tp1</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a>
              <a href="#39046" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isDifferentTypeConstructor</a><span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a>, <a href="#142543" title="Types.this.Type">tp1a</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#142543" title="Types.this.Type">tp1a</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142189" title="Types.this.Type">tp2</a>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <a href="#39062" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#142188" title="Types.this.Type">tp1</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a>, <a href="#142189" title="Types.this.Type">tp2</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a>, <a href="#142190" title="Int">depth</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="142549">parents1</a>, _<span class="delimiter">)</span> =&gt;
        <a href="#142549" title="List[Types.this.Type]">parents1</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#142556" title="Types.this.Type">_</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142189" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Boolean">_</span>: <a href="#38819" title="Types.this.SingletonType">SingletonType</a> | _: <a href="#147895" title="Types.this.NotNullType">NotNullType</a> =&gt;
        <a href="#142188" title="Types.this.Type">tp1</a>.<a href="#41507" title="=&gt; Types.this.Type">underlying</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142189" title="Types.this.Type">tp2</a>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
        <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>

    <a href="#142445" title="=&gt; Boolean">firstTry</a>
  <span class="delimiter">}</span>

  /** Are `tps1` and `tps2` lists of equal length such that all elements
   *  of `tps1` conform to corresponding elements of `tps2`?
   */
  <span class="keyword">def</span> <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean" id="39073">isSubTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="142631">tps1</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="142632">tps2</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#142631" title="List[Types.this.Type]">tps1</a> <span title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.Type, Types.this.Type) =&gt; Boolean)Boolean">corresponds</span> <a href="#142632" title="List[Types.this.Type]">tps2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#142656" title="Types.this.Type">_</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142657" title="Types.this.Type">_</a><span class="delimiter">)</span>

  /** Does type `tp` implement symbol `sym` with same or
   *  stronger type? Exact only if `sym` is a member of some
   *  refinement type, otherwise we might return false negatives.
   */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean" id="39074">specializesSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="131136">tp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="131137">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#131136" title="Types.this.Type">tp</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a> <span title="(x: Boolean)Boolean">||</span>
    <a href="#131136" title="Types.this.Type">tp</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#44998" title="object Types.this.definitions.NullClass">NullClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#131137" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a> <a href="Symbols.scala.html#46650" title="(that: Types.this.Symbol)Boolean">isSubClass</a> <a href="Definitions.scala.html#44986" title="=&gt; Types.this.Symbol">ObjectClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span>
    <span class="delimiter">(</span><a href="#131136" title="Types.this.Type">tp</a>.<a href="#41546" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#131137" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#46653" title="=&gt; List[Types.this.Symbol]">alternatives</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</span>
      <span class="delimiter">(</span><a title="Types.this.Symbol" id="142678">alt</a> =&gt; <a href="#131137" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#142678" title="Types.this.Symbol">alt</a> <span title="(x: Boolean)Boolean">||</span> <a href="#39075" title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#131136" title="Types.this.Type">tp</a>.<a href="#41511" title="=&gt; Types.this.Type">narrow</a>, <a href="#142678" title="Types.this.Symbol">alt</a>, <a href="#131137" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#46667" title="=&gt; Types.this.Type">thisType</a>, <a href="#131137" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  /** Does member `sym1` of `tp1` have a stronger type
   *  than member `sym2` of `tp2`?
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean" id="39075">specializesSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="131131">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="131132">sym1</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="131133">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="131134">sym2</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Types.this.Type" id="142687">info1</a> = <a href="#131131" title="Types.this.Type">tp1</a>.<a href="#41555" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#131132" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Types.this.Type" id="142688">info2</a> = <a href="#131133" title="Types.this.Type">tp2</a>.<a href="#41555" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#131134" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>.<a href="#41560" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#131133" title="Types.this.Type">tp2</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#131131" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
    //System.out.println(&quot;specializes &quot;+tp1+&quot;.&quot;+sym1+&quot;:&quot;+info1+sym1.locationString+&quot; AND &quot;+tp2+&quot;.&quot;+sym2+&quot;:&quot;+info2)//DEBUG
    <a href="#131134" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46443" title="=&gt; Boolean">isTerm</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#142687" title="Types.this.Type">info1</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#142688" title="Types.this.Type">info2</a><span class="delimiter">)</span> /*&amp;&amp; (!sym2.isStable || sym1.isStable) */ <span title="(x: Boolean)Boolean">||</span>
    <a href="#131134" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46448" title="=&gt; Boolean">isAbstractType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="142696">memberTp1</a> = <a href="#131131" title="Types.this.Type">tp1</a>.<a href="#41556" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#131132" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      // println(&quot;kinds conform? &quot;+(memberTp1, tp1, sym2, kindsConform(List(sym2), List(memberTp1), tp2, sym2.owner)))
      <a href="#142688" title="Types.this.Type">info2</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62306" title="(that: Types.this.Type)Boolean">containsType</a><span class="delimiter">(</span><a href="#142696" title="Types.this.Type">memberTp1</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <a href="Kinds.scala.html#39161" title="(tparams: List[Types.this.Symbol], targs: List[Types.this.Type], pre: Types.this.Type, owner: Types.this.Symbol)Boolean">kindsConform</a><span class="delimiter">(</span><span title="(xs: Types.this.Symbol*)List[Types.this.Symbol]">List</span><span class="delimiter">(</span><a href="#131134" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>, <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#142696" title="Types.this.Type">memberTp1</a><span class="delimiter">)</span>, <a href="#131131" title="Types.this.Type">tp1</a>, <a href="#131132" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span title="(x: Boolean)Boolean">||</span>
    <a href="#131134" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46447" title="=&gt; Boolean">isAliasType</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#131133" title="Types.this.Type">tp2</a>.<a href="#41556" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#131134" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>.<a href="#41560" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#131133" title="Types.this.Type">tp2</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#131131" title="Types.this.Type">tp1</a><span class="delimiter">)</span> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#131131" title="Types.this.Type">tp1</a>.<a href="#41556" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#131132" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> //@MAT ok
  <span class="delimiter">}</span>

  /** A function implementing `tp1` matches `tp2`. */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean" id="39076">matchesType</a><span class="delimiter">(</span><a title="Types.this.Type" id="131152">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="131153">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Boolean" id="131154">alwaysMatchSimple</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean" id="142722">matchesQuantified</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="142724">tparams1</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="142725">tparams2</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="142726">res1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="142727">res2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span>
      <a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#142724" title="List[Types.this.Symbol]">tparams1</a>, <a href="#142725" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#142726" title="Types.this.Type">res1</a>, <a href="#142727" title="Types.this.Type">res2</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#142725" title="List[Types.this.Symbol]">tparams2</a>, <a href="#142724" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>, <a href="#131154" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="142723">lastTry</a> =
      <a href="#131153" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="142730">res2</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#131154" title="Boolean">alwaysMatchSimple</a> =&gt;
          <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#131152" title="Types.this.Type">tp1</a>, <a href="#142730" title="Types.this.Type">res2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Boolean(false)">MethodType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
          <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">case</span> <span title="Boolean(false)">PolyType</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
          <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
          <a href="#131154" title="Boolean">alwaysMatchSimple</a> <span title="(x: Boolean)Boolean">||</span> <a href="#131152" title="Types.this.Type">tp1</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#131153" title="Types.this.Type">tp2</a>
      <span class="delimiter">}</span>
    <a href="#131152" title="Types.this.Type">tp1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="142732">mt1</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="142733">params1</a>, <a title="Types.this.Type" id="142734">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#131153" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="142735">mt2</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="142736">params2</a>, <a title="Types.this.Type" id="142737">res2</a><span class="delimiter">)</span> =&gt;
            // sameLength(params1, params2) was used directly as pre-screening optimization (now done by matchesQuantified -- is that ok, performancewise?)
            <a href="#142732" title="Types.this.MethodType">mt1</a>.<a href="#62357" title="=&gt; Boolean">isImplicit</a> <span title="(x: Boolean)Boolean">==</span> <a href="#142735" title="Types.this.MethodType">mt2</a>.<a href="#62357" title="=&gt; Boolean">isImplicit</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#39077" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span><a href="#142733" title="List[Types.this.Symbol]">params1</a>, <a href="#142736" title="List[Types.this.Symbol]">params2</a>, <a href="#142732" title="Types.this.MethodType">mt1</a>.<a href="#62358" title="=&gt; Boolean">isJava</a>, <a href="#142735" title="Types.this.MethodType">mt2</a>.<a href="#62358" title="=&gt; Boolean">isJava</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
            <a href="#142722" title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean">matchesQuantified</a><span class="delimiter">(</span><a href="#142733" title="List[Types.this.Symbol]">params1</a>, <a href="#142736" title="List[Types.this.Symbol]">params2</a>, <a href="#142734" title="Types.this.Type">res1</a>, <a href="#142737" title="Types.this.Type">res2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="142743">res2</a><span class="delimiter">)</span> =&gt;
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#142733" title="List[Types.this.Symbol]">params1</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#142734" title="Types.this.Type">res1</a>, <a href="#142743" title="Types.this.Type">res2</a>, <a href="#131154" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#131152" title="Types.this.Type">tp1</a>, <a href="#142743" title="Types.this.Type">res2</a>, <a href="#131154" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="142744">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#131154" title="Boolean">alwaysMatchSimple</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#131152" title="Types.this.Type">tp1</a>, <a href="#142744" title="Types.this.Type">res2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="142745">sym</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span> =&gt;
            <a href="#142733" title="List[Types.this.Symbol]">params1</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#142745" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46463" title="=&gt; Boolean">isModuleClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#142734" title="Types.this.Type">res1</a>, <a href="#131153" title="Types.this.Type">tp2</a>, <a href="#131154" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Boolean" id="142746">mt1</a> @ NullaryMethodType<span class="delimiter">(</span><a title="Types.this.Type" id="142747">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#131153" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="142748">mt2</a> @ MethodType<span class="delimiter">(</span><span title="object Nil">Nil</span>, <a title="Types.this.Type" id="142749">res2</a><span class="delimiter">)</span>  =&gt; // could never match if params nonEmpty, and !mt2.isImplicit is implied by empty param list
            <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#142747" title="Types.this.Type">res1</a>, <a href="#142749" title="Types.this.Type">res2</a>, <a href="#131154" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="142750">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#142747" title="Types.this.Type">res1</a>, <a href="#142750" title="Types.this.Type">res2</a>, <a href="#131154" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="142751">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#131154" title="Boolean">alwaysMatchSimple</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#131152" title="Types.this.Type">tp1</a>, <a href="#142751" title="Types.this.Type">res2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="142752">sym</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#142752" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46463" title="=&gt; Boolean">isModuleClass</a> =&gt;
            <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#142747" title="Types.this.Type">res1</a>, <a href="#131153" title="Types.this.Type">tp2</a>, <a href="#131154" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#142747" title="Types.this.Type">res1</a>, <a href="#131153" title="Types.this.Type">tp2</a>, <a href="#131154" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="142753">tparams1</a>, <a title="Types.this.Type" id="142754">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#131153" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="142755">tparams2</a>, <a title="Types.this.Type" id="142756">res2</a><span class="delimiter">)</span> =&gt;
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#142753" title="List[Types.this.Symbol]">tparams1</a> <span title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</span> <a href="#142755" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#142779" title="Types.this.Symbol">_</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#142780" title="Types.this.Symbol">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#142754" title="Types.this.Type">res1</a>, <a href="#142756" title="Types.this.Type">res2</a>, <a href="#131154" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
            <span class="keyword">else</span>
              <a href="#142722" title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean">matchesQuantified</a><span class="delimiter">(</span><a href="#142753" title="List[Types.this.Symbol]">tparams1</a>, <a href="#142755" title="List[Types.this.Symbol]">tparams2</a>, <a href="#142754" title="Types.this.Type">res1</a>, <a href="#142756" title="Types.this.Type">res2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="142781">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#131154" title="Boolean">alwaysMatchSimple</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#131152" title="Types.this.Type">tp1</a>, <a href="#142781" title="Types.this.Type">res2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt;
            <span title="Boolean(false)" class="keyword">false</span> // remember that tparams1.nonEmpty is now an invariant of PolyType
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="142782">tparams1</a>, <a title="Types.this.Type" id="142783">res1</a><span class="delimiter">)</span> =&gt;
        <a href="#131153" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="142784">tparams2</a>, <a title="Types.this.Type" id="142785">res2</a><span class="delimiter">)</span> =&gt;
            <a href="#142722" title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean">matchesQuantified</a><span class="delimiter">(</span><a href="#142782" title="List[Types.this.Symbol]">tparams1</a>, <a href="#142784" title="List[Types.this.Symbol]">tparams2</a>, <a href="#142783" title="Types.this.Type">res1</a>, <a href="#142785" title="Types.this.Type">res2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#131154" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span> <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#142783" title="Types.this.Type">res1</a>, <a href="#131153" title="Types.this.Type">tp2</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#142723" title="=&gt; Boolean">lastTry</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="142786">sym</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#142786" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46463" title="=&gt; Boolean">isModuleClass</a> =&gt;
        <a href="#131153" title="Types.this.Type">tp2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">MethodType</span><span class="delimiter">(</span><span title="object Nil">Nil</span>, <a title="Types.this.Type" id="142787">res2</a><span class="delimiter">)</span>   =&gt; <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#131152" title="Types.this.Type">tp1</a>, <a href="#142787" title="Types.this.Type">res2</a>, <a href="#131154" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="142788">res2</a><span class="delimiter">)</span> =&gt; <a href="#39076" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#131152" title="Types.this.Type">tp1</a>, <a href="#142788" title="Types.this.Type">res2</a>, <a href="#131154" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span>                       =&gt; <a href="#142723" title="=&gt; Boolean">lastTry</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#142723" title="=&gt; Boolean">lastTry</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

/** matchesType above is an optimized version of the following implementation:

  def matchesType2(tp1: Type, tp2: Type, alwaysMatchSimple: Boolean): Boolean = {
    def matchesQuantified(tparams1: List[Symbol], tparams2: List[Symbol], res1: Type, res2: Type): Boolean =
      tparams1.length == tparams2.length &amp;&amp;
      matchesType(res1, res2.substSym(tparams2, tparams1), alwaysMatchSimple)
    (tp1, tp2) match {
      case (MethodType(params1, res1), MethodType(params2, res2)) =&gt;
        params1.length == params2.length &amp;&amp; // useful pre-secreening optimization
        matchingParams(params1, params2, tp1.isInstanceOf[JavaMethodType], tp2.isInstanceOf[JavaMethodType]) &amp;&amp;
        matchesType(res1, res2, alwaysMatchSimple) &amp;&amp;
        tp1.isImplicit == tp2.isImplicit
      case (PolyType(tparams1, res1), PolyType(tparams2, res2)) =&gt;
        matchesQuantified(tparams1, tparams2, res1, res2)
      case (NullaryMethodType(rtp1), MethodType(List(), rtp2)) =&gt;
        matchesType(rtp1, rtp2, alwaysMatchSimple)
      case (MethodType(List(), rtp1), NullaryMethodType(rtp2)) =&gt;
        matchesType(rtp1, rtp2, alwaysMatchSimple)
      case (ExistentialType(tparams1, res1), ExistentialType(tparams2, res2)) =&gt;
        matchesQuantified(tparams1, tparams2, res1, res2)
      case (ExistentialType(_, res1), _) if alwaysMatchSimple =&gt;
        matchesType(res1, tp2, alwaysMatchSimple)
      case (_, ExistentialType(_, res2)) if alwaysMatchSimple =&gt;
        matchesType(tp1, res2, alwaysMatchSimple)
      case (NullaryMethodType(rtp1), _) =&gt;
        matchesType(rtp1, tp2, alwaysMatchSimple)
      case (_, NullaryMethodType(rtp2)) =&gt;
        matchesType(tp1, rtp2, alwaysMatchSimple)
      case (MethodType(_, _), _) =&gt; false
      case (PolyType(_, _), _)   =&gt; false
      case (_, MethodType(_, _)) =&gt; false
      case (_, PolyType(_, _))   =&gt; false
      case _ =&gt;
        alwaysMatchSimple || tp1 =:= tp2
    }
  }
*/

  /** Are `syms1` and `syms2` parameter lists with pairwise equivalent types? */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean" id="39077">matchingParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="142577">syms1</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="142578">syms2</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Boolean" id="142579">syms1isJava</a>: <span title="Boolean">Boolean</span>, <a title="Boolean" id="142580">syms2isJava</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#142577" title="List[Types.this.Symbol]">syms1</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Boolean">Nil</span> =&gt;
      <a href="#142578" title="List[Types.this.Symbol]">syms2</a>.<span title="=&gt; Boolean">isEmpty</span>
    <span class="keyword">case</span> <a title="Boolean" id="142793">sym1</a> :: <a title="List[Types.this.Symbol]" id="142794">rest1</a> =&gt;
      <a href="#142578" title="List[Types.this.Symbol]">syms2</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Boolean(false)">Nil</span> =&gt;
          <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">case</span> <a title="Boolean" id="142799">sym2</a> :: <a title="List[Types.this.Symbol]" id="142800">rest2</a> =&gt;
          <span class="keyword">val</span> <a title="Types.this.Type" id="142801">tp1</a> = <a href="#142793" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>
          <span class="keyword">val</span> <a title="Types.this.Type" id="142802">tp2</a> = <a href="#142799" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>
          <span class="delimiter">(</span><a href="#142801" title="Types.this.Type">tp1</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#142802" title="Types.this.Type">tp2</a> <span title="(x: Boolean)Boolean">||</span>
           <a href="#142579" title="Boolean">syms1isJava</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#142802" title="Types.this.Type">tp2</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#44986" title="=&gt; Types.this.Symbol">ObjectClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#142801" title="Types.this.Type">tp1</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a> <span title="(x: Boolean)Boolean">||</span>
           <a href="#142580" title="Boolean">syms2isJava</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#142801" title="Types.this.Type">tp1</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#44986" title="=&gt; Types.this.Symbol">ObjectClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#142802" title="Types.this.Type">tp2</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
          <a href="#39077" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span><a href="#142794" title="List[Types.this.Symbol]">rest1</a>, <a href="#142800" title="List[Types.this.Symbol]">rest2</a>, <a href="#142579" title="Boolean">syms1isJava</a>, <a href="#142580" title="Boolean">syms2isJava</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** like map2, but returns list `xs` itself - instead of a copy - if function
   *  `f` maps all elements to themselves.
   */
  <span class="keyword">def</span> <a title="[A &lt;: AnyRef, B](xs: List[A], ys: List[B])(f: (A, B) =&gt; A)List[A]" id="39078">map2Conserve</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef" id="39081">A</a> &lt;: AnyRef, <a title="&gt;: Nothing &lt;: Any" id="39082">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[A]" id="138996">xs</a>: <span title="List[A]">List</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="List[B]" id="138997">ys</a>: <span title="List[B]">List</span><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; A" id="138998">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span>: <span title="List[A]">List</span><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <span title="List[A]" class="keyword">if</span> <span class="delimiter">(</span><a href="#138996" title="List[A]">xs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#138996" title="List[A]">xs</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="A" id="142824">x1</a> = <a href="#138998" title="(v1: A, v2: B)A">f</a><span class="delimiter">(</span><a href="#138996" title="List[A]">xs</a>.<span title="=&gt; A">head</span>, <a href="#138997" title="List[B]">ys</a>.<span title="=&gt; B">head</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[A]" id="142825">xs1</a> = <a href="#39078" title="(xs: List[A], ys: List[B])(f: (A, B) =&gt; A)List[A]">map2Conserve</a><span class="delimiter">(</span><a href="#138996" title="List[A]">xs</a>.<span title="=&gt; List[A]">tail</span>, <a href="#138997" title="List[B]">ys</a>.<span title="=&gt; List[B]">tail</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#138998" title="(A, B) =&gt; A">f</a><span class="delimiter">)</span>
      <span title="List[A]" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#142824" title="A">x1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138996" title="List[A]">xs</a>.<span title="=&gt; A">head</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#142825" title="List[A]">xs1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#138996" title="List[A]">xs</a>.<span title="=&gt; List[A]">tail</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#138996" title="List[A]">xs</a>
      <span class="keyword">else</span> <a href="#142824" title="A">x1</a> <a href="#142864" title="(x: A)List[A]">::</a> <a href="#142825" title="List[A]">xs1</a>
    <span class="delimiter">}</span>

  /** Solve constraint collected in types `tvars`.
   *
   *  @param tvars      All type variables to be instantiated.
   *  @param tparams    The type parameters corresponding to `tvars`
   *  @param variances  The variances of type parameters; need to reverse
   *                    solution direction for all contravariant variables.
   *  @param upper      When `true` search for max solution else min.
   */
  <span class="keyword">def</span> <a title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean)Boolean" id="39083">solve</a><span class="delimiter">(</span><a title="List[Types.this.TypeVar]" id="135830">tvars</a>: <span title="List[Types.this.TypeVar]">List</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="135831">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
            <a title="List[Int]" id="135832">variances</a>: <span title="List[Int]">List</span><span class="delimiter">[</span>Int<span class="delimiter">]</span>, <a title="Boolean" id="135833">upper</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
     <a href="#39084" title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean, depth: Int)Boolean">solve</a><span class="delimiter">(</span><a href="#135830" title="List[Types.this.TypeVar]">tvars</a>, <a href="#135831" title="List[Types.this.Symbol]">tparams</a>, <a href="#135832" title="List[Int]">variances</a>, <a href="#135833" title="Boolean">upper</a>, <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[Int], upper: Boolean, depth: Int)Boolean" id="39084">solve</a><span class="delimiter">(</span><a title="List[Types.this.TypeVar]" id="135824">tvars</a>: <span title="List[Types.this.TypeVar]">List</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="135825">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
            <a title="List[Int]" id="135826">variances</a>: <span title="List[Int]">List</span><span class="delimiter">[</span>Int<span class="delimiter">]</span>, <a title="Boolean" id="135827">upper</a>: <span title="Boolean">Boolean</span>, <a title="Int" id="135828">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>

    <span class="keyword">def</span> <a title="(tvar: Types.this.TypeVar, tparam: Types.this.Symbol, variance: Int)Unit" id="142874">solveOne</a><span class="delimiter">(</span><a title="Types.this.TypeVar" id="142875">tvar</a>: <a href="#38912" title="Types.this.TypeVar">TypeVar</a>, <a title="Types.this.Symbol" id="142876">tparam</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="Int" id="142877">variance</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#142875" title="Types.this.TypeVar">tvar</a>.<a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84069" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Boolean" id="142883">up</a> = <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#142877" title="Int">variance</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(131072)">CONTRAVARIANT</span><span class="delimiter">)</span> <a href="#135827" title="Boolean">upper</a> <span class="keyword">else</span> <span title="=&gt; Boolean">!</span><a href="#135827" title="Boolean">upper</a>
        <a href="#142875" title="Types.this.TypeVar">tvar</a>.<a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84069" title="(x$1: Types.this.Type)Unit">inst</a> = <span title="Null(null)" class="keyword">null</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="142884">bound</a>: <a href="#38813" title="Types.this.Type">Type</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#142883" title="Boolean">up</a><span class="delimiter">)</span> <a href="#142876" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a> <span class="keyword">else</span> <a href="#142876" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62325" title="=&gt; Types.this.Type">lo</a>
        //Console.println(&quot;solveOne0(tv, tp, v, b)=&quot;+(tvar, tparam, variance, bound))
        <span class="keyword">var</span> <a title="Boolean" id="142885">cyclic</a> = <a href="#142884" title="Types.this.Type">bound</a> <a href="#41569" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#142876" title="Types.this.Symbol">tparam</a>
        <a href="util/Collections.scala.html#38342" title="(xs1: List[Types.this.TypeVar], xs2: List[Types.this.Symbol], xs3: List[Int])(f: (Types.this.TypeVar, Types.this.Symbol, Int) =&gt; Unit)Unit">foreach3</a><span class="delimiter">(</span><a href="#135824" title="List[Types.this.TypeVar]">tvars</a>, <a href="#135825" title="List[Types.this.Symbol]">tparams</a>, <a href="#135826" title="List[Int]">variances</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.TypeVar" id="142958">tvar2</a>, <a title="Types.this.Symbol" id="142959">tparam2</a>, <a title="Int" id="142960">variance2</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Boolean" id="142961">ok</a> = <span class="delimiter">(</span><a href="#142959" title="Types.this.Symbol">tparam2</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#142876" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span>
               <span class="delimiter">(</span><a href="#142884" title="Types.this.Type">bound</a> <a href="#41569" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#142959" title="Types.this.Symbol">tparam2</a><span class="delimiter">)</span>
            <span title="(x: Boolean)Boolean">||</span>  <a href="#142883" title="Boolean">up</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#142959" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62325" title="=&gt; Types.this.Type">lo</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#142876" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
            <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#142883" title="Boolean">up</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#142959" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#142876" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
          <span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#142961" title="Boolean">ok</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#142958" title="Types.this.TypeVar">tvar2</a>.<a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84069" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#142885" title="Boolean">cyclic</a> = <span title="Boolean(true)" class="keyword">true</span>
            <a href="#142874" title="(tvar: Types.this.TypeVar, tparam: Types.this.Symbol, variance: Int)Unit">solveOne</a><span class="delimiter">(</span><a href="#142958" title="Types.this.TypeVar">tvar2</a>, <a href="#142959" title="Types.this.Symbol">tparam2</a>, <a href="#142960" title="Int">variance2</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#142885" title="Boolean">cyclic</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#142883" title="Boolean">up</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#142884" title="Types.this.Type">bound</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span>
              <a href="#142875" title="Types.this.TypeVar">tvar</a> <a href="#83981" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a> <a href="#142884" title="Types.this.Type">bound</a>.<a href="#41531" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#135825" title="List[Types.this.Symbol]">tparams</a>, <a href="#135824" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
            <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="142994">tparam2</a> &lt;- <a href="#135825" title="(f: Types.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span>
              <a href="#142994" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62325" title="=&gt; Types.this.Type">lo</a>.<a href="#41535" title="=&gt; Types.this.Type">dealias</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a href="#142876" title="Types.this.Symbol">`tparam`</a>, _<span class="delimiter">)</span> =&gt;
                  <a href="#142875" title="Types.this.TypeVar">tvar</a> <a href="#83981" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a> <a href="#142994" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>.<a href="#41531" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#135825" title="List[Types.this.Symbol]">tparams</a>, <a href="#135824" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
                <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
              <span class="delimiter">}</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#142884" title="Types.this.Type">bound</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#142884" title="Types.this.Type">bound</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#142876" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#142875" title="Types.this.TypeVar">tvar</a> <a href="#83980" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a> <a href="#142884" title="Types.this.Type">bound</a>.<a href="#41531" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#135825" title="List[Types.this.Symbol]">tparams</a>, <a href="#135824" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="143017">tparam2</a> &lt;- <a href="#135825" title="(f: Types.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span>
              <a href="#143017" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a>.<a href="#41535" title="=&gt; Types.this.Type">dealias</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> <span title="Unit">TypeRef</span><span class="delimiter">(</span>_, <a href="#142876" title="Types.this.Symbol">`tparam`</a>, _<span class="delimiter">)</span> =&gt;
                  <a href="#142875" title="Types.this.TypeVar">tvar</a> <a href="#83980" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a> <a href="#143017" title="Types.this.Symbol">tparam2</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>.<a href="#41531" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#135825" title="List[Types.this.Symbol]">tparams</a>, <a href="#135824" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span>
                <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
              <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <a href="#142875" title="Types.this.TypeVar">tvar</a>.<a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84069" title="(x$1: Types.this.Type)Unit">inst</a> = <a href="#131699" title="object Types.this.NoType">NoType</a> // necessary because hibounds/lobounds may contain tvar

        //println(&quot;solving &quot;+tvar+&quot; &quot;+up+&quot; &quot;+(if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds)+((if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds) map (_.widen)))

        <a href="#142875" title="Types.this.TypeVar">tvar</a> <a href="#83979" title="(tp: Types.this.Type)Unit">setInst</a> <span class="delimiter">(</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#142883" title="Boolean">up</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#135828" title="Int">depth</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span> <a href="#39117" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#142875" title="Types.this.TypeVar">tvar</a>.<a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84062" title="=&gt; List[Types.this.Type]">hiBounds</a>, <a href="#135828" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#39116" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#142875" title="Types.this.TypeVar">tvar</a>.<a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84062" title="=&gt; List[Types.this.Type]">hiBounds</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#135828" title="Int">depth</a> <span title="(x: Int)Boolean">!=</span> <span title="Int(-3)">AnyDepth</span><span class="delimiter">)</span> <a href="#39108" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#142875" title="Types.this.TypeVar">tvar</a>.<a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84061" title="=&gt; List[Types.this.Type]">loBounds</a>, <a href="#135828" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#39107" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#142875" title="Types.this.TypeVar">tvar</a>.<a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84061" title="=&gt; List[Types.this.Type]">loBounds</a><span class="delimiter">)</span>
          <span class="delimiter">}</span><span class="delimiter">)</span>

        //Console.println(&quot;solving &quot;+tvar+&quot; &quot;+up+&quot; &quot;+(if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds)+((if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds) map (_.widen))+&quot; = &quot;+tvar.constr.inst)//@MDEBUG
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    // println(&quot;solving &quot;+tvars+&quot;/&quot;+tparams+&quot;/&quot;+(tparams map (_.info)))
    <a href="util/Collections.scala.html#38342" title="(xs1: List[Types.this.TypeVar], xs2: List[Types.this.Symbol], xs3: List[Int])(f: (Types.this.TypeVar, Types.this.Symbol, Int) =&gt; Unit)Unit">foreach3</a><span class="delimiter">(</span><a href="#135824" title="List[Types.this.TypeVar]">tvars</a>, <a href="#135825" title="List[Types.this.Symbol]">tparams</a>, <a href="#135826" title="List[Int]">variances</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#142874" title="(tvar: Types.this.TypeVar, tparam: Types.this.Symbol, variance: Int)Unit">solveOne</a><span class="delimiter">)</span>
    <a href="#135824" title="List[Types.this.TypeVar]">tvars</a> <span title="(p: Types.this.TypeVar =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.TypeVar" id="143111">tvar</a> =&gt; <a href="#143111" title="Types.this.TypeVar">tvar</a>.<a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84067" title="(tp: Types.this.Type)Boolean">isWithinBounds</a><span class="delimiter">(</span><a href="#143111" title="Types.this.TypeVar">tvar</a>.<a href="#83969" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="#84069" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Do type arguments `targs` conform to formal parameters `tparams`?
   */
  <span class="keyword">def</span> <a title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])Boolean" id="39085">isWithinBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="135884">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="135885">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="135886">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="135887">targs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="List[Types.this.TypeBounds]" id="143112">bounds</a> = <a href="#39086" title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]">instantiatedBounds</a><span class="delimiter">(</span><a href="#135884" title="Types.this.Type">pre</a>, <a href="#135885" title="Types.this.Symbol">owner</a>, <a href="#135886" title="List[Types.this.Symbol]">tparams</a>, <a href="#135887" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#135887" title="List[Types.this.Type]">targs</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#143124" title="Types.this.Type">_</a>.<a href="#41597" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#143112" title="List[Types.this.TypeBounds]">bounds</a> = <a href="AnnotationCheckers.scala.html#34941" title="(bounds: List[Types.this.TypeBounds], tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]">adaptBoundsToAnnotations</a><span class="delimiter">(</span><a href="#143112" title="List[Types.this.TypeBounds]">bounds</a>, <a href="#135886" title="List[Types.this.Symbol]">tparams</a>, <a href="#135887" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>
    <span class="delimiter">(</span><a href="#143112" title="List[Types.this.TypeBounds]">bounds</a> <span title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.TypeBounds, Types.this.Type) =&gt; Boolean)Boolean">corresponds</span> <a href="#135887" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#143155" title="Types.this.TypeBounds">_</a> <a href="#62306" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#143156" title="Types.this.Type">_</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]" id="39086">instantiatedBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="143113">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="143114">owner</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="143115">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="143116">targs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.TypeBounds]">List</span><span class="delimiter">[</span>TypeBounds<span class="delimiter">]</span> =
    <a href="#143115" title="List[Types.this.Symbol]">tparams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.TypeBounds)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.TypeBounds,List[Types.this.TypeBounds]])List[Types.this.TypeBounds]">map</span> <span class="delimiter">(</span><a href="#143173" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41554" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#143113" title="Types.this.Type">pre</a>, <a href="#143114" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>.<a href="#41531" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#143115" title="List[Types.this.Symbol]">tparams</a>, <a href="#143116" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>

// Lubs and Glbs ---------------------------------------------------------

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(btsMap: Map[Types.this.Type,List[Types.this.Type]], depth: Int)Unit" id="39087">printLubMatrix</a><span class="delimiter">(</span><a title="Map[Types.this.Type,List[Types.this.Type]]" id="143215">btsMap</a>: <span title="Map[Types.this.Type,List[Types.this.Type]]">Map</span><span class="delimiter">[</span>Type, List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Int" id="143216">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">import</span> scala.tools.nsc.util.TableDef
    <span class="keyword">import</span> <a href="../../tools/nsc/util/TableDef.scala.html#33644" title="object scala.tools.nsc.util.TableDef">TableDef</a>.Column
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)String" id="143220">str</a><span class="delimiter">(</span><a title="Types.this.Type" id="143236">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#143236" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="String" id="143241">s</a> = <span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#143236" title="Types.this.Type">tp</a><span class="delimiter">)</span>.<span title="(x$1: String, x$2: String)String">replaceAll</span><span class="delimiter">(</span><span title="String(&quot;[\\w.]+\\.(\\w+)&quot;)" class="string">&quot;&quot;&quot;[\w.]+\.(\w+)&quot;&quot;&quot;</span>, <span title="String(&quot;$1&quot;)" class="string">&quot;$1&quot;</span><span class="delimiter">)</span>
        <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#143241" title="String">s</a>.<span title="()Int">length</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(60)" class="int">60</span><span class="delimiter">)</span> <a href="#143241" title="String">s</a>
        <span class="keyword">else</span> <span class="delimiter">(</span><a href="#143241" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">s</a> <span title="(n: Int)String">take</span> <span title="Int(57)" class="int">57</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;...&quot;)" class="string">&quot;...&quot;</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="List[(Types.this.Type, List[Types.this.Type])]" id="143221">sorted</a>       = <a href="#143215" title="Map[Types.this.Type,List[Types.this.Type]]">btsMap</a>.<span title="=&gt; List[(Types.this.Type, List[Types.this.Type])]">toList</span>.<span title="(lt: ((Types.this.Type, List[Types.this.Type]), (Types.this.Type, List[Types.this.Type])) =&gt; Boolean)List[(Types.this.Type, List[Types.this.Type])]">sortWith</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="(Types.this.Type, List[Types.this.Type])" id="143311">x</a>, <a title="(Types.this.Type, List[Types.this.Type])" id="143312">y</a><span class="delimiter">)</span> =&gt; <a href="#143311" title="(Types.this.Type, List[Types.this.Type])">x</a>.<span title="=&gt; Types.this.Type">_1</span>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#46647" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#143312" title="(Types.this.Type, List[Types.this.Type])">y</a>.<span title="=&gt; Types.this.Type">_1</span>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Int" id="143222">maxSeqLength</a> = <a href="#143221" title="List[(Types.this.Type, List[Types.this.Type])]">sorted</a> <span title="(f: ((Types.this.Type, List[Types.this.Type])) =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Type, List[Types.this.Type])],Int,List[Int]])List[Int]">map</span> <span class="delimiter">(</span><a href="#143330" title="(Types.this.Type, List[Types.this.Type])">_</a>.<span title="=&gt; List[Types.this.Type]">_2</span>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> <span title="(implicit cmp: Ordering[Int])Int">max</span>
    <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="143223">padded</a>       = <a href="#143221" title="List[(Types.this.Type, List[Types.this.Type])]">sorted</a> <span title="(f: ((Types.this.Type, List[Types.this.Type])) =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Type, List[Types.this.Type])],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a href="#143432" title="(Types.this.Type, List[Types.this.Type])">_</a>.<span title="=&gt; List[Types.this.Type]">_2</span>.<span title="(len: Int, elem: Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">padTo</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.Type,List[Types.this.Type]]" class="delimiter">(</span><a href="#143222" title="Int">maxSeqLength</a>, <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="143224">transposed</a>   = <a href="#143223" title="List[List[Types.this.Type]]">padded</a>.<span title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.GenTraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</span>

    <span class="keyword">val</span> <a title="List[scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]]" id="143225">columns</a>: <span title="List[scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]]">List</span><span class="delimiter">[</span>Column<span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="util/Collections.scala.html#38325" title="(xs: List[(Types.this.Type, List[Types.this.Type])])(f: ((Types.this.Type, List[Types.this.Type]), Int) =&gt; scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]])List[scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]]">mapWithIndex</a><span class="delimiter">(</span><a href="#143221" title="List[(Types.this.Type, List[Types.this.Type])]">sorted</a><span class="delimiter">)</span> <a href="#143559" title="scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]" class="delimiter">{</a>
      <span class="keyword">case</span> <span title="scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]" class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="143571">k</a>, <a title="List[Types.this.Type]" id="143572">v</a><span class="delimiter">)</span>, <a title="Int" id="143573">idx</a><span class="delimiter">)</span> =&gt;
        <a href="../../tools/nsc/util/TableDef.scala.html#143576" title="(name: String, f: List[Types.this.Type] =&gt; Any, left: Boolean)scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]">Column</a><span class="delimiter">(</span><a href="#143220" title="(tp: Types.this.Type)String">str</a><span class="delimiter">(</span><a href="#143571" title="Types.this.Type">k</a><span class="delimiter">)</span>, <span class="delimiter">(</span>xs: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="#143220" title="(tp: Types.this.Type)String">str</a><span class="delimiter">(</span><a href="#143610" title="(n: Int)Types.this.Type">xs</a><span class="delimiter">(</span><a href="#143573" title="Int">idx</a><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="scala.tools.nsc.util.TableDef[List[Types.this.Type]]" id="143226">tableDef</a> = <a href="../../tools/nsc/util/TableDef.scala.html#143233" title="(cols: tools.nsc.util.TableDef.Column[List[Types.this.Type]]*)scala.tools.nsc.util.TableDef[List[Types.this.Type]]">TableDef</a><span class="delimiter">(</span><a href="#143225" title="List[scala.tools.nsc.util.TableDef.Column[List[Types.this.Type]]]">columns</a>: _*<span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="tableDef.Table" id="143227">formatted</a> = <a href="#143226" title="scala.tools.nsc.util.TableDef[List[Types.this.Type]]">tableDef</a>.<a href="../../tools/nsc/util/TableDef.scala.html#143649" title="(rows: Seq[List[Types.this.Type]])tableDef.Table">table</a><span class="delimiter">(</span><a href="#143224" title="List[List[Types.this.Type]]">transposed</a><span class="delimiter">)</span>
    <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;** Depth is &quot;)" class="string">&quot;** Depth is &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#143216" title="Int">depth</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#143227" title="tableDef.Table">formatted</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  /** From a list of types, find any which take type parameters 
   *  where the type parameter bounds contain references to other
   *  any types in the list (including itself.)
   *
   *  @return List of symbol pairs holding the recursive type
   *    parameter and the parameter which references it.
   */
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[(Types.this.Symbol, Types.this.Symbol)]" id="39088">findRecursiveBounds</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143701">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[(Types.this.Symbol, Types.this.Symbol)]">List</span><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="List[(Types.this.Symbol, Types.this.Symbol)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#143701" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="object Nil">Nil</span>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="143703">sym</a> = <a href="#143701" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>
      <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#143701" title="List[Types.this.Type]">ts</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#143715" title="Types.this.Type">_</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#143703" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>, <a href="#143701" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="143740">p</a> &lt;- <a href="#143703" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46628" title="(f: Types.this.Symbol =&gt; scala.collection.GenTraversableOnce[(Types.this.Symbol, Types.this.Symbol)])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],(Types.this.Symbol, Types.this.Symbol),List[(Types.this.Symbol, Types.this.Symbol)]])List[(Types.this.Symbol, Types.this.Symbol)]">typeParams</a> ; <a title="Types.this.Symbol" id="143757">in</a> &lt;- <a href="#143703" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46628" title="(f: Types.this.Symbol =&gt; (Types.this.Symbol, Types.this.Symbol))(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],(Types.this.Symbol, Types.this.Symbol),List[(Types.this.Symbol, Types.this.Symbol)]])List[(Types.this.Symbol, Types.this.Symbol)]">typeParams</a> ; <span class="keyword">if</span> <a href="#143757" title="Types.this.Symbol">in</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a> <a href="#41569" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#143740" title="Types.this.Symbol">p</a><span class="delimiter">)</span> <span class="keyword">yield</span>
        <a href="#143740" title="(x: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">p</a> <span title="(y: Types.this.Symbol)(Types.this.Symbol, Types.this.Symbol)">-&gt;</span> <a href="#143757" title="Types.this.Symbol">in</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Given a matrix `tsBts` whose columns are basetype sequences (and the symbols `tsParams` that should be interpreted as type parameters in this matrix),
   * compute its least sorted upwards closed upper bound relative to the following ordering &lt;= between lists of types:
   *
   *    xs &lt;= ys   iff   forall y in ys exists x in xs such that x &lt;: y
   *
   *  @arg tsParams for each type in the original list of types `ts0`, its list of type parameters (if that type is a type constructor)
   *                (these type parameters may be referred to by type arguments in the BTS column of those types,
   *                and must be interpreted as bound variables; i.e., under a type lambda that wraps the types that refer to these type params)
   *  @arg tsBts    a matrix whose columns are basetype sequences
   *                the first row is the original list of types for which we're computing the lub
   *                  (except that type constructors have been applied to their dummyArgs)
   *  @See baseTypeSeq  for a definition of sorted and upwards closed.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]" id="39089">lubList</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143839">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="143840">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    // Matching the type params of one of the initial types means dummies.
    <span class="keyword">val</span> <a title="List[List[Types.this.Symbol]]" id="143842">initialTypeParams</a> = <a href="#143839" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; List[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Symbol],List[List[Types.this.Symbol]]])List[List[Types.this.Symbol]]">map</span> <span class="delimiter">(</span><a href="#143864" title="Types.this.Type">_</a>.<a href="#41528" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(xs: List[Types.this.Type])Boolean" id="143843">isHotForTs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143892">xs</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#143842" title="List[List[Types.this.Symbol]]">initialTypeParams</a> <span title="(elem: Any)Boolean">contains</span> <a href="#143892" title="List[Types.this.Type]">xs</a>.<span title="(f: Types.this.Type =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,Any])Any">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.Symbol,List[Types.this.Symbol]]" class="delimiter">(</span><a href="#143909" title="Types.this.Type">_</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="143844">elimHigherOrderTypeParam</a><span class="delimiter">(</span><a title="Types.this.Type" id="143937">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#143937" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="143938">pre</a>, <a title="Types.this.Symbol" id="143939">sym</a>, <a title="List[Types.this.Type]" id="143940">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#143940" title="List[Types.this.Type]">args</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#143843" title="(xs: List[Types.this.Type])Boolean">isHotForTs</a><span class="delimiter">(</span><a href="#143940" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> =&gt; <a href="#143937" title="Types.this.Type">tp</a>.<a href="#41516" title="=&gt; Types.this.Type">typeConstructor</a>
      <span class="keyword">case</span> <span title="Types.this.Type">_</span>                                                            =&gt; <a href="#143937" title="Types.this.Type">tp</a>
    <span class="delimiter">}</span>
    <span class="keyword">var</span> <a title="Int" id="143845">lubListDepth</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">def</span> <a title="(tsBts: List[List[Types.this.Type]])List[Types.this.Type]" id="143846">loop</a><span class="delimiter">(</span><a title="List[List[Types.this.Type]]" id="143941">tsBts</a>: <span title="List[List[Types.this.Type]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="#143845" title="Int">lubListDepth</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>

      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#143941" title="List[List[Types.this.Type]]">tsBts</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#143941" title="List[List[Types.this.Type]]">tsBts</a>.<span title="(p: List[Types.this.Type] =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#143954" title="List[Types.this.Type]">_</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="object Nil">Nil</span>
      <span class="keyword">else</span> <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#143941" title="List[List[Types.this.Type]]">tsBts</a>.<span title="=&gt; List[List[Types.this.Type]]">tail</span>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#143941" title="List[List[Types.this.Type]]">tsBts</a>.<span title="=&gt; List[Types.this.Type]">head</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        // ts0 is the 1-dimensional frontier of symbols cutting through 2-dimensional tsBts.
        // Invariant: all symbols &quot;under&quot; (closer to the first row) the frontier
        // are smaller (according to _.isLess) than the ones &quot;on and beyond&quot; the frontier
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="143956">ts0</a>  = <a href="#143941" title="List[List[Types.this.Type]]">tsBts</a> <span title="(f: List[Types.this.Type] =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#143974" title="List[Types.this.Type]">_</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span>

        // Is the frontier made up of types with the same symbol?
        <span class="keyword">val</span> <a title="Boolean" id="143957">isUniformFrontier</a> = <span class="delimiter">(</span><a href="#143956" title="List[Types.this.Type]">ts0</a>: @<span title="List[Types.this.Type] @unchecked">unchecked</span><span class="delimiter">)</span> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="Boolean" id="144006">t</a> :: <a title="List[Types.this.Type]" id="144007">ts</a>  =&gt; <a href="#144007" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#144014" title="Types.this.Type">_</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#144006" title="Types.this.Type">t</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        // Produce a single type for this frontier by merging the prefixes and arguments of those
        // typerefs that share the same symbol: that symbol is the current maximal symbol for which
        // the invariant holds, i.e., the one that conveys most information wrt subtyping. Before
        // merging, strip targs that refer to bound tparams (when we're computing the lub of type
        // constructors.) Also filter out all types that are a subtype of some other type.
        <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#143957" title="Boolean">isUniformFrontier</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74514" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">||</span> <a href="#38785" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[(Types.this.Symbol, Types.this.Symbol)]" id="144024">fbounds</a> = <a href="#39088" title="(ts: List[Types.this.Type])List[(Types.this.Symbol, Types.this.Symbol)]">findRecursiveBounds</a><span class="delimiter">(</span><a href="#143956" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#144024" title="List[(Types.this.Symbol, Types.this.Symbol)]">fbounds</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;Encountered &quot;)" class="string">&quot;Encountered &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#144024" title="List[(Types.this.Symbol, Types.this.Symbol)]">fbounds</a>.<span title="=&gt; Int">size</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; recursive bounds while lubbing &quot;)" class="string">&quot; recursive bounds while lubbing &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#143956" title="List[Types.this.Type]">ts0</a>.<span title="=&gt; Int">size</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; types.&quot;)" class="string">&quot; types.&quot;</span><span class="delimiter">)</span>
              <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="144063">p0</a>, <a title="Types.this.Symbol" id="144064">p1</a><span class="delimiter">)</span> &lt;- <a href="#144024" title="(f: ((Types.this.Symbol, Types.this.Symbol)) =&gt; Unit)Unit">fbounds</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">val</span> <a title="String" id="144065">desc</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#144063" title="Types.this.Symbol">p0</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#144064" title="Types.this.Symbol">p1</a><span class="delimiter">)</span> <span title="String(&quot;its own bounds&quot;)" class="string">&quot;its own bounds&quot;</span> <span class="keyword">else</span> <span title="String(&quot;the bounds of &quot;)" class="string">&quot;the bounds of &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#144064" title="Types.this.Symbol">p1</a>

                <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#144063" title="Types.this.Symbol">p0</a>.<a href="Symbols.scala.html#46745" title="=&gt; String">fullLocationString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; appears in &quot;)" class="string">&quot; appears in &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#144065" title="String">desc</a><span class="delimiter">)</span>
                <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;    &quot;)" class="string">&quot;    &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#144064" title="Types.this.Symbol">p1</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#144064" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
              <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="144020">tails</a> = <a href="#143941" title="List[List[Types.this.Type]]">tsBts</a> <span title="(f: List[Types.this.Type] =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a href="#144087" title="List[Types.this.Type]">_</a>.<span title="=&gt; List[Types.this.Type]">tail</span><span class="delimiter">)</span>
          <a href="#39121" title="(tps: List[Types.this.Type], variance: Int, depth: Int)Option[Types.this.Type]">mergePrefixAndArgs</a><span class="delimiter">(</span><a href="#39095" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">elimSub</a><span class="delimiter">(</span><a href="#143956" title="List[Types.this.Type]">ts0</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#143844" title="(tp: Types.this.Type)Types.this.Type">elimHigherOrderTypeParam</a>, <a href="#143840" title="Int">depth</a><span class="delimiter">)</span>, <span title="Int(1)" class="int">1</span>, <a href="#143840" title="Int">depth</a><span class="delimiter">)</span> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="List[Types.this.Type]">Some</span><span class="delimiter">(</span><a title="Types.this.Type" id="144163">tp</a><span class="delimiter">)</span> =&gt; <a href="#144163" title="Types.this.Type">tp</a> <a href="#144164" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#143846" title="(tsBts: List[List[Types.this.Type]])List[Types.this.Type]">loop</a><span class="delimiter">(</span><a href="#144020" title="List[List[Types.this.Type]]">tails</a><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="List[Types.this.Type]">_</span>        =&gt; <a href="#143846" title="(tsBts: List[List[Types.this.Type]])List[Types.this.Type]">loop</a><span class="delimiter">(</span><a href="#144020" title="List[List[Types.this.Type]]">tails</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          // frontier is not uniform yet, move it beyond the current minimal symbol;
          // lather, rinSe, repeat
          <span class="keyword">val</span> <a title="Types.this.Symbol" id="144170">sym</a>    = <a href="#39090" title="(tps: List[Types.this.Type])Types.this.Symbol">minSym</a><span class="delimiter">(</span><a href="#143956" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="144171">newtps</a> = <a href="#143941" title="List[List[Types.this.Type]]">tsBts</a> <span title="(f: List[Types.this.Type] =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a title="List[Types.this.Type]" id="144190">ts</a> =&gt; <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#144190" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#144170" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#144190" title="List[Types.this.Type]">ts</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span class="keyword">else</span> <a href="#144190" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#38785" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="String" id="144224">str</a> = <span class="delimiter">(</span><a href="#144171" title="List[List[Types.this.Type]]">newtps</a>.<span title="(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],(List[Types.this.Type], Int),List[(List[Types.this.Type], Int)]])List[(List[Types.this.Type], Int)]">zipWithIndex</span> <span title="(f: ((List[Types.this.Type], Int)) =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[(List[Types.this.Type], Int)],String,List[String]])List[String]">map</span> <a href="#144284" title="String" class="delimiter">{</a> <span class="keyword">case</span> <span title="String" class="delimiter">(</span><a title="List[Types.this.Type]" id="144287">tps</a>, <a title="Int" id="144288">idx</a><span class="delimiter">)</span> =&gt;
              <a href="#144287" title="List[Types.this.Type]">tps</a>.<span title="(f: Types.this.Type =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],String,List[String]])List[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,String,List[String]]" class="delimiter">(</span><span title="String(&quot;        &quot;)" class="string">&quot;        &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#144305" title="Types.this.Type">_</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;   (&quot;)" class="string">&quot;   (&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#144288" title="Int">idx</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)\n&quot;)" class="string">&quot;)\n&quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span>
            <span class="delimiter">}</span><span class="delimiter">)</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>

            <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;Frontier(\n&quot;)" class="string">&quot;Frontier(\n&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#144224" title="String">str</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
            <a href="#39087" title="(btsMap: Map[Types.this.Type,List[Types.this.Type]], depth: Int)Unit">printLubMatrix</a><span class="delimiter">(</span><a href="#143839" title="List[Types.this.Type]">ts</a> <span title="(that: scala.collection.GenIterable[List[Types.this.Type]])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],(Types.this.Type, List[Types.this.Type]),List[(Types.this.Type, List[Types.this.Type])]])List[(Types.this.Type, List[Types.this.Type])]">zip</span> <a href="#143941" title="List[List[Types.this.Type]]">tsBts</a> <span title="(implicit ev: &lt;:&lt;[(Types.this.Type, List[Types.this.Type]),(Types.this.Type, List[Types.this.Type])])scala.collection.immutable.Map[Types.this.Type,List[Types.this.Type]]">toMap</span>, <a href="#143845" title="Int">lubListDepth</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>

          <a href="#143846" title="(tsBts: List[List[Types.this.Type]])List[Types.this.Type]">loop</a><span class="delimiter">(</span><a href="#144171" title="List[List[Types.this.Type]]">newtps</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="143847">initialBTSes</a> = <a href="#143839" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a href="#144469" title="Types.this.Type">_</a>.<a href="#41579" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#59598" title="=&gt; List[Types.this.Type]">toList</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a href="#144475" title="Types.this.Type">_</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="HasFlags.scala.html#46792" title="=&gt; Boolean">isPublic</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#38785" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span>
      <a href="#39087" title="(btsMap: Map[Types.this.Type,List[Types.this.Type]], depth: Int)Unit">printLubMatrix</a><span class="delimiter">(</span><a href="#143839" title="List[Types.this.Type]">ts</a> <span title="(that: scala.collection.GenIterable[List[Types.this.Type]])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],(Types.this.Type, List[Types.this.Type]),List[(Types.this.Type, List[Types.this.Type])]])List[(Types.this.Type, List[Types.this.Type])]">zip</span> <a href="#143847" title="List[List[Types.this.Type]]">initialBTSes</a> <span title="(implicit ev: &lt;:&lt;[(Types.this.Type, List[Types.this.Type]),(Types.this.Type, List[Types.this.Type])])scala.collection.immutable.Map[Types.this.Type,List[Types.this.Type]]">toMap</span>, <a href="#143840" title="Int">depth</a><span class="delimiter">)</span>

    <a href="#143846" title="(tsBts: List[List[Types.this.Type]])List[Types.this.Type]">loop</a><span class="delimiter">(</span><a href="#143847" title="List[List[Types.this.Type]]">initialBTSes</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  // @AM the following problem is solved by elimHOTparams in lublist
  // @PP lubLists gone bad: lubList(List(
  //   List(scala.collection.generic.GenericCompanion[scala.collection.immutable.Seq], ScalaObject, java.lang.Object, Any)
  //   List(scala.collection.generic.GenericCompanion[scala.collection.mutable.Seq], ScalaObject, java.lang.Object, Any)
  // )) == (
  //   List(scala.collection.generic.GenericCompanion[Seq**[Any]**], ScalaObject, java.lang.Object, Any)
  // )

  /** The minimal symbol (wrt Symbol.isLess) of a list of types */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type])Types.this.Symbol" id="39090">minSym</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144172">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> =
    <span class="delimiter">(</span><a href="#144172" title="List[Types.this.Type]">tps</a>.<span title="=&gt; Types.this.Type">head</span>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="#144558" title="(z: Types.this.Symbol)(op: (Types.this.Symbol, Types.this.Type) =&gt; Types.this.Symbol)Types.this.Symbol">/:</a> <a href="#144172" title="List[Types.this.Type]">tps</a>.<span title="=&gt; List[Types.this.Type]">tail</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="delimiter">(</span><a title="Types.this.Symbol" id="144574">sym1</a>, <a title="Types.this.Type" id="144575">tp2</a><span class="delimiter">)</span> =&gt; <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#144575" title="Types.this.Type">tp2</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#46647" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#144574" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> <a href="#144575" title="Types.this.Type">tp2</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span class="keyword">else</span> <a href="#144574" title="Types.this.Symbol">sym1</a>
    <span class="delimiter">}</span>

  /** A minimal type list which has a given list of types as its base type sequence */
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="39091">spanningTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144576">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#144576" title="List[Types.this.Type]">ts</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#144579" title="List[Nothing]">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="List[Types.this.Type]" id="144601">first</a> :: <a title="List[Types.this.Type]" id="144602">rest</a> =&gt;
      <a href="#144601" title="Types.this.Type">first</a> <a href="#144603" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#39091" title="(ts: List[Types.this.Type])List[Types.this.Type]">spanningTypes</a><span class="delimiter">(</span>
        <a href="#144602" title="List[Types.this.Type]">rest</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a title="Types.this.Type" id="144607">t</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#144601" title="Types.this.Type">first</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46650" title="(that: Types.this.Symbol)Boolean">isSubClass</a><span class="delimiter">(</span><a href="#144607" title="Types.this.Type">t</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Eliminate from list of types all elements which are a supertype
   *  of some other element of the list. */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="39092">elimSuper</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144611">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#144611" title="List[Types.this.Type]">ts</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#144614" title="List[Nothing]">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="List[Types.this.Type]" id="144636">t</a> :: <a title="List[Types.this.Type]" id="144637">ts1</a> =&gt;
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="144638">rest</a> = <a href="#39092" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSuper</a><span class="delimiter">(</span><a href="#144637" title="List[Types.this.Type]">ts1</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a title="Types.this.Type" id="144642">t1</a> =&gt; <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#144636" title="Types.this.Type">t</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#144642" title="Types.this.Type">t1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#144638" title="List[Types.this.Type]">rest</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a title="Types.this.Type" id="144650">t1</a> =&gt; <a href="#144650" title="Types.this.Type">t1</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#144636" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#144638" title="List[Types.this.Type]">rest</a> <span class="keyword">else</span> <a href="#144636" title="Types.this.Type">t</a> <a href="#144652" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#144638" title="List[Types.this.Type]">rest</a>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(t: Types.this.Type)Types.this.Type" id="39093">elimAnonymousClass</a><span class="delimiter">(</span><a title="Types.this.Type" id="144658">t</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#144658" title="Types.this.Type">t</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">TypeRef</span><span class="delimiter">(</span><a title="Types.this.Type" id="144661">pre</a>, <a title="Types.this.Symbol" id="144662">clazz</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#144662" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#46503" title="=&gt; Boolean">isAnonymousClass</a> =&gt;
      <a href="#144662" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#46631" title="=&gt; Types.this.Type">classBound</a>.<a href="#41554" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#144661" title="Types.this.Type">pre</a>, <a href="#144662" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#46564" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <a href="#144658" title="Types.this.Type">t</a>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="(t: Types.this.Type)Types.this.Type" id="39094">elimRefinement</a><span class="delimiter">(</span><a title="Types.this.Type" id="144666">t</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#144666" title="Types.this.Type">t</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Types.this.Type">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144669">parents</a>, <a title="Types.this.Scope" id="144670">decls</a><span class="delimiter">)</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#144670" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60495" title="=&gt; Boolean">isEmpty</a> =&gt; <a href="#38939" title="(tps: List[Types.this.Type])Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="#144669" title="List[Types.this.Type]">parents</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span>                                             =&gt; <a href="#144666" title="Types.this.Type">t</a>
  <span class="delimiter">}</span>

  /** Eliminate from list of types all elements which are a subtype
   *  of some other element of the list. */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]" id="39095">elimSub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144115">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="144116">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])List[Types.this.Type]" id="144675">elimSub0</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144677">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#144677" title="List[Types.this.Type]">ts</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#144679" title="List[Nothing]">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="List[Types.this.Type]" id="144701">t</a> :: <a title="List[Types.this.Type]" id="144702">ts1</a> =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="144703">rest</a> = <a href="#144675" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSub0</a><span class="delimiter">(</span><a href="#144702" title="List[Types.this.Type]">ts1</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <span class="delimiter">(</span><a title="Types.this.Type" id="144707">t1</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#39062" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#144707" title="Types.this.Type">t1</a>, <a href="#144701" title="Types.this.Type">t</a>, <a href="#38784" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#144116" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#144703" title="List[Types.this.Type]">rest</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a title="Types.this.Type" id="144718">t1</a> =&gt; <a href="#39062" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: Int)Boolean">isSubType</a><span class="delimiter">(</span><a href="#144701" title="Types.this.Type">t</a>, <a href="#144718" title="Types.this.Type">t1</a>, <a href="#38784" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#144116" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#144703" title="List[Types.this.Type]">rest</a> <span class="keyword">else</span> <a href="#144701" title="Types.this.Type">t</a> <a href="#144723" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#144703" title="List[Types.this.Type]">rest</a>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="List[Types.this.Type]" id="144676">ts0</a> = <a href="#144675" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSub0</a><span class="delimiter">(</span><a href="#144115" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
    <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#144676" title="List[Types.this.Type]">ts0</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">||</span> <a href="#144676" title="List[Types.this.Type]">ts0</a>.<span title="=&gt; List[Types.this.Type]">tail</span>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#144676" title="List[Types.this.Type]">ts0</a>
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="144730">ts1</a> = <a href="#144676" title="List[Types.this.Type]">ts0</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <span class="delimiter">(</span><a title="Types.this.Type" id="144737">t</a> =&gt; <a href="#39093" title="(t: Types.this.Type)Types.this.Type">elimAnonymousClass</a><span class="delimiter">(</span><a href="#144737" title="Types.this.Type">t</a>.<a href="#41507" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#144730" title="List[Types.this.Type]">ts1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#144676" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span> <a href="#144676" title="List[Types.this.Type]">ts0</a>
      <span class="keyword">else</span> <a href="#39095" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">elimSub</a><span class="delimiter">(</span><a href="#144730" title="List[Types.this.Type]">ts1</a>, <a href="#144116" title="Int">depth</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])(List[Types.this.Type], List[Types.this.Symbol])" id="39096">stripExistentialsAndTypeVars</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144739">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span>, List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="144741">quantified</a> = <a href="#144739" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">flatMap</span> <a href="#144760" title="List[Types.this.Symbol]" class="delimiter">{</a>
      <span class="keyword">case</span> <span title="List[Types.this.Symbol]">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="144761">qs</a>, _<span class="delimiter">)</span> =&gt; <a href="#144761" title="List[Types.this.Symbol]">qs</a>
      <span class="keyword">case</span> <a title="List[Nothing]" id="144762">t</a> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="144742">stripType</a><span class="delimiter">(</span><a title="Types.this.Type" id="144797">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#144797" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">ExistentialType</span><span class="delimiter">(</span>_, <a title="Types.this.Type" id="144798">res</a><span class="delimiter">)</span> =&gt;
        <a href="#144798" title="Types.this.Type">res</a>
      <span class="keyword">case</span> <a href="#84008" title="Types.this.Type">TypeVar</a><span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="144800">constr</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#144800" title="Types.this.TypeConstraint">constr</a>.<a href="#84071" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#144800" title="Types.this.TypeConstraint">constr</a>.<a href="#84069" title="=&gt; Types.this.Type">inst</a>
        <span class="keyword">else</span> <a href="SymbolTable.scala.html#35603" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><span title="String(&quot;trying to do lub/glb of typevar &quot;)" class="string">&quot;trying to do lub/glb of typevar &quot;</span><span title="(x$1: Any)String">+</span><a href="#144797" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="144805">t</a> =&gt; <a href="#144805" title="Types.this.Type">t</a>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="List[Types.this.Type]" id="144743">strippedTypes</a> = <a href="#144739" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)List[Types.this.Type]">mapConserve</span> <a href="#144742" title="(tp: Types.this.Type)Types.this.Type">stripType</a>
    <span title="(_1: List[Types.this.Type], _2: List[Types.this.Symbol])(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</span><a href="#144743" title="List[Types.this.Type]">strippedTypes</a>, <a href="#144741" title="List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])(Types.this.Type, Boolean)" id="39097">weakLub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144820">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#144820" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#144820" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <a href="Definitions.scala.html#45482" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#39099" title="(ts: List[Types.this.Type])Types.this.Type">numericLub</a><span class="delimiter">(</span><a href="#144820" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#144820" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#144820" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#144859" title="Types.this.Type">_</a>.<a href="#41597" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="AnnotationCheckers.scala.html#34939" title="(tpe: Types.this.Type, ts: List[Types.this.Type])Types.this.Type">annotationsLub</a><span class="delimiter">(</span><a href="#39107" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#144820" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#144887" title="Types.this.Type">_</a>.<a href="#41598" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#144820" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#39107" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#144820" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])(Types.this.Type, Boolean)" id="39098">weakGlb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144927">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#144927" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#144927" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <a href="Definitions.scala.html#45482" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="144937">nglb</a> = <a href="#39100" title="(ts: List[Types.this.Type])Types.this.Type">numericGlb</a><span class="delimiter">(</span><a href="#144927" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
      <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#144937" title="Types.this.Type">nglb</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#144937" title="Types.this.Type">nglb</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#39116" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#144927" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span title="(Types.this.Type, Boolean)" class="keyword">if</span> <span class="delimiter">(</span><a href="#144927" title="List[Types.this.Type]">ts</a>.<span title="=&gt; Boolean">nonEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#144927" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#144981" title="Types.this.Type">_</a>.<a href="#41597" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="AnnotationCheckers.scala.html#34940" title="(tpe: Types.this.Type, ts: List[Types.this.Type])Types.this.Type">annotationsGlb</a><span class="delimiter">(</span><a href="#39116" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#144927" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#145009" title="Types.this.Type">_</a>.<a href="#41598" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#144927" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span title="(_1: Types.this.Type, _2: Boolean)(Types.this.Type, Boolean)" class="delimiter">(</span><a href="#39116" title="(ts: List[Types.this.Type])Types.this.Type">glb</a><span class="delimiter">(</span><a href="#144927" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="39099">numericLub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144834">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#144834" title="List[Types.this.Type]">ts</a> <span title="(f: (Types.this.Type, Types.this.Type) =&gt; Types.this.Type)Types.this.Type">reduceLeft</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="144849">t1</a>, <a title="Types.this.Type" id="144850">t2</a><span class="delimiter">)</span> =&gt;
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#39102" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#144849" title="Types.this.Type">t1</a>, <a href="#144850" title="Types.this.Type">t2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#144850" title="Types.this.Type">t2</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#39102" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#144850" title="Types.this.Type">t2</a>, <a href="#144849" title="Types.this.Type">t1</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#144849" title="Types.this.Type">t1</a>
      <span class="keyword">else</span> <a href="Definitions.scala.html#45539" title="=&gt; Types.this.Symbol">IntClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="39100">numericGlb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="144938">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#144938" title="List[Types.this.Type]">ts</a> <span title="(f: (Types.this.Type, Types.this.Type) =&gt; Types.this.Type)Types.this.Type">reduceLeft</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="144953">t1</a>, <a title="Types.this.Type" id="144954">t2</a><span class="delimiter">)</span> =&gt;
      <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#39102" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#144953" title="Types.this.Type">t1</a>, <a href="#144954" title="Types.this.Type">t2</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#144953" title="Types.this.Type">t1</a>
      <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#39102" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#144954" title="Types.this.Type">t2</a>, <a href="#144953" title="Types.this.Type">t1</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#144954" title="Types.this.Type">t2</a>
      <span class="keyword">else</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="39101">isWeakSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="131063">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="131064">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
    <a href="#131063" title="Types.this.Type">tp1</a>.<a href="#41509" title="=&gt; Types.this.Type">deconst</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="131068">sym1</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="Definitions.scala.html#45527" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#131068" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span> =&gt;
        <a href="#131064" title="Types.this.Type">tp2</a>.<a href="#41509" title="=&gt; Types.this.Type">deconst</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="131072">sym2</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="Definitions.scala.html#45527" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#131072" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> =&gt;
            <a href="Definitions.scala.html#45526" title="(sub: Types.this.Symbol, sup: Types.this.Symbol)Boolean">isNumericSubClass</a><span class="delimiter">(</span><a href="#131068" title="Types.this.Symbol">sym1</a>, <a href="#131072" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <a title="Boolean" id="131075">tv2</a> @ <a href="#84008" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
            <a href="#131075" title="Types.this.TypeVar">tv2</a>.<a href="#83985" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#131063" title="Types.this.Type">tp1</a>, isLowerBound = <span title="Boolean(true)" class="keyword">true</span>, isNumericBound = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#39061" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a><span class="delimiter">(</span><a href="#131063" title="Types.this.Type">tp1</a>, <a href="#131064" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <a title="Boolean" id="131086">tv1</a> @ <a href="#84008" title="(tv: Types.this.TypeVar)Some[(Types.this.Type, Types.this.TypeConstraint)]">TypeVar</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
        <a href="#131064" title="Types.this.Type">tp2</a>.<a href="#41509" title="=&gt; Types.this.Type">deconst</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Boolean">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="131089">sym2</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="Definitions.scala.html#45527" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#131089" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span> =&gt;
            <a href="#131086" title="Types.this.TypeVar">tv1</a>.<a href="#83985" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#131064" title="Types.this.Type">tp2</a>, isLowerBound = <span title="Boolean(false)" class="keyword">false</span>, isNumericBound = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
            <a href="#39061" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a><span class="delimiter">(</span><a href="#131063" title="Types.this.Type">tp1</a>, <a href="#131064" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="Boolean">_</span> =&gt;
        <a href="#39061" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSubType</a><span class="delimiter">(</span><a href="#131063" title="Types.this.Type">tp1</a>, <a href="#131064" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  /** The isNumericValueType tests appear redundant, but without them
   *  test/continuations-neg/function3.scala goes into an infinite loop.
   *  (Even if the calls are to typeSymbolDirect.)
   */
  <span class="keyword">def</span> <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="39102">isNumericSubType</a><span class="delimiter">(</span><a title="Types.this.Type" id="138763">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="138764">tp2</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
       <a href="Definitions.scala.html#45482" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#138763" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
    <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#45482" title="(tp: Types.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#138764" title="Types.this.Type">tp2</a><span class="delimiter">)</span>
    <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="Definitions.scala.html#45526" title="(sub: Types.this.Symbol, sup: Types.this.Symbol)Boolean">isNumericSubClass</a><span class="delimiter">(</span><a href="#138763" title="Types.this.Type">tp1</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#138764" title="Types.this.Type">tp2</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
  <span class="delimiter">)</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" id="39103">lubResults</a> = <span title="()scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">HashMap</span><span class="delimiter">[</span><span class="delimiter">(</span>Int, List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>, Type<span class="delimiter">]</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" id="39105">glbResults</a> = <span title="()scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]" class="keyword">new</span> mutable.<span title="scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">HashMap</span><span class="delimiter">[</span><span class="delimiter">(</span>Int, List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>, Type<span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="39107">lub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143042">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#143042" title="List[Types.this.Type]">ts</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#145050" title="Types.this.Type">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a>.<a href="Symbols.scala.html#69227" title="=&gt; Types.this.Type">tpe</a>
    <span class="keyword">case</span> <a href="#145062" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="145073">t</a><span class="delimiter">)</span> =&gt; <a href="#145073" title="Types.this.Type">t</a>
    <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#39108" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#143042" title="List[Types.this.Type]">ts</a>, <a href="#39035" title="(ts: List[Types.this.Type])Int">lubDepth</a><span class="delimiter">(</span><a href="#143042" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
        <a href="#39103" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">lubResults</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#39105" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">glbResults</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** The least upper bound wrt &lt;:&lt; of a list of types */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)Types.this.Type" id="39108">lub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143048">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="143049">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="145078">lub0</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="145081">ts0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#39095" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">elimSub</a><span class="delimiter">(</span><a href="#145081" title="List[Types.this.Type]">ts0</a>, <a href="#143049" title="Int">depth</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#145083" title="Types.this.Type">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a>.<a href="Symbols.scala.html#69227" title="=&gt; Types.this.Type">tpe</a>
      <span class="keyword">case</span> <a href="#145095" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="145106">t</a><span class="delimiter">)</span> =&gt; <a href="#145106" title="Types.this.Type">t</a>
      <span class="keyword">case</span> <a title="Types.this.PolyType" id="145107">ts</a> @ PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="145112">tparams</a>, _<span class="delimiter">)</span> :: _ =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="145113">tparams1</a> = <a href="util/Collections.scala.html#38302" title="(xs1: List[Types.this.Symbol], xs2: List[List[Types.this.Type]])(f: (Types.this.Symbol, List[Types.this.Type]) =&gt; Types.this.Symbol)List[Types.this.Symbol]">map2</a><span class="delimiter">(</span><a href="#145112" title="List[Types.this.Symbol]">tparams</a>, <a href="#39123" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[List[Types.this.Type]]">matchingBounds</a><span class="delimiter">(</span><a href="#145107" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#145112" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>.<span title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.GenTraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="145196">tparam</a>, <a title="List[Types.this.Type]" id="145197">bounds</a><span class="delimiter">)</span> =&gt;
          <a href="#145196" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46656" title="=&gt; Types.this.Symbol">cloneSymbol</a>.<a href="Symbols.scala.html#46610" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a><span class="delimiter">(</span><a href="#39117" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#145197" title="List[Types.this.Type]">bounds</a>, <a href="#143049" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#62451" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#145113" title="List[Types.this.Symbol]">tparams1</a>, <a href="#145078" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#39124" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">matchingInstTypes</a><span class="delimiter">(</span><a href="#145107" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#145113" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.MethodType" id="145218">ts</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="145223">params</a>, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="145224">rest</a> =&gt;
        <a href="#62346" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#145223" title="List[Types.this.Symbol]">params</a>, <a href="#145078" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#39125" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span><a href="#145218" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#145223" title="List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#145244" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.NullaryMethodType" id="145272">ts</a> @ NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="145277">rest</a> =&gt;
        <a href="#62410" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#145078" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#39125" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span><a href="#145272" title="collection.immutable.::[Types.this.Type]">ts</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.TypeBounds" id="145278">ts</a> @ TypeBounds<span class="delimiter">(</span>_, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="145283">rest</a> =&gt;
        <a href="#62285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#39117" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#145278" title="collection.immutable.::[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#145304" title="Types.this.Type">_</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62325" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#143049" title="Int">depth</a><span class="delimiter">)</span>, <a href="#39108" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#145278" title="collection.immutable.::[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#145346" title="Types.this.Type">_</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#143049" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="145374">ts</a> =&gt;
        <a href="#39103" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">lubResults</a> <span title="(key: (Int, List[Types.this.Type]))Option[Types.this.Type]">get</span> <span class="delimiter">(</span><a href="#143049" title="Int">depth</a>, <a href="#145374" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Types.this.Type">Some</span><span class="delimiter">(</span><a title="Types.this.Type" id="145385">lubType</a><span class="delimiter">)</span> =&gt;
            <a href="#145385" title="Types.this.Type">lubType</a>
          <span class="keyword">case</span> <span title="Types.this.Type">None</span> =&gt;
            <a href="#39103" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">lubResults</a><span class="delimiter">(</span><span title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</span><a href="#143049" title="Int">depth</a>, <a href="#145374" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="145386">res</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#143049" title="Int">depth</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#145079" title="(ts0: List[Types.this.Type])Types.this.Type">lub1</a><span class="delimiter">(</span><a href="#145374" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
            <a href="#39103" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">lubResults</a><span class="delimiter">(</span><span title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</span><a href="#143049" title="Int">depth</a>, <a href="#145374" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="#145386" title="Types.this.Type">res</a>
            <a href="#145386" title="Types.this.Type">res</a>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="145079">lub1</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="145401">ts0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#145409" title="(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</a><a href="#145408" title="List[Types.this.Type]" id="145409">ts</a>, <a href="#145408" title="List[Types.this.Symbol]" id="145410">tparams</a><span class="delimiter">)</span> = <a href="#39096" title="(ts: List[Types.this.Type])(List[Types.this.Type], List[Types.this.Symbol])">stripExistentialsAndTypeVars</a><span title="(List[Types.this.Type], List[Types.this.Symbol]) @unchecked" class="delimiter">(</span><a href="#145401" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="145411">lubBaseTypes</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#39089" title="(ts: List[Types.this.Type], depth: Int)List[Types.this.Type]">lubList</a><span class="delimiter">(</span><a href="#145409" title="List[Types.this.Type]">ts</a>, <a href="#143049" title="Int">depth</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="145412">lubParents</a> = <a href="#39091" title="(ts: List[Types.this.Type])List[Types.this.Type]">spanningTypes</a><span class="delimiter">(</span><a href="#145411" title="List[Types.this.Type]">lubBaseTypes</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Symbol" id="145413">lubOwner</a> = <a href="#39021" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#145409" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="145414">lubBase</a> = <a href="#38938" title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="#145412" title="List[Types.this.Type]">lubParents</a>, <a href="#145413" title="Types.this.Symbol">lubOwner</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="145415">lubType</a> =
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#143049" title="Int">depth</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#145414" title="Types.this.Type">lubBase</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="145440">lubRefined</a>  = <a href="#38932" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#145412" title="List[Types.this.Type]">lubParents</a>, <a href="#145413" title="Types.this.Symbol">lubOwner</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="Types.this.Type" id="145441">lubThisType</a> = <a href="#145440" title="Types.this.Type">lubRefined</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46667" title="=&gt; Types.this.Type">thisType</a>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="145442">narrowts</a>    = <a href="#145409" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#145466" title="Types.this.Type">_</a>.<a href="#41511" title="=&gt; Types.this.Type">narrow</a><span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(sym: Types.this.Symbol)Boolean" id="145443">excludeFromLub</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="145494">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
               <a href="#145494" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46445" title="=&gt; Boolean">isClass</a>
            <span title="(x: Boolean)Boolean">||</span> <a href="#145494" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46492" title="=&gt; Boolean">isConstructor</a>
            <span title="(x: Boolean)Boolean">||</span> <span title="=&gt; Boolean">!</span><a href="#145494" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#46792" title="=&gt; Boolean">isPublic</a>
            <span title="(x: Boolean)Boolean">||</span> <a href="Definitions.scala.html#45528" title="(sym: Types.this.Symbol)Boolean">isGetClass</a><span class="delimiter">(</span><a href="#145494" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
            <span title="(x: Boolean)Boolean">||</span> <a href="#145442" title="List[Types.this.Type]">narrowts</a>.<span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a title="Types.this.Type" id="145502">t</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#145445" title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean">refines</a><span class="delimiter">(</span><a href="#145502" title="Types.this.Type">t</a>, <a href="#145494" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(proto: Types.this.Symbol)Types.this.Symbol" id="145444">lubsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="145505">proto</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="145506">prototp</a> = <a href="#145441" title="Types.this.Type">lubThisType</a>.<a href="#41555" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#145505" title="Types.this.Symbol">proto</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="145507">syms</a> = <a href="#145442" title="List[Types.this.Type]">narrowts</a> <span title="(f: Types.this.Type =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</span> <span class="delimiter">(</span><a title="Types.this.Type" id="145524">t</a> =&gt;
              <a href="#145524" title="Types.this.Type">t</a>.<a href="#41546" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#145505" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#46655" title="(cond: Types.this.Symbol =&gt; Boolean)Types.this.Symbol">suchThat</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="145527">sym</a> =&gt;
                <a href="#145527" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a> <a href="#41577" title="(that: Types.this.Type)Boolean">matches</a> <a href="#145506" title="Types.this.Type">prototp</a>.<a href="#41560" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#145441" title="Types.this.Type">lubThisType</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#145524" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#145507" title="List[Types.this.Symbol]">syms</a> <span title="(elem: Any)Boolean">contains</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a>
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="List[Types.this.Type]" id="145559">symtypes</a> =
                <a href="util/Collections.scala.html#38302" title="(xs1: List[Types.this.Type], xs2: List[Types.this.Symbol])(f: (Types.this.Type, Types.this.Symbol) =&gt; Types.this.Type)List[Types.this.Type]">map2</a><span class="delimiter">(</span><a href="#145442" title="List[Types.this.Type]">narrowts</a>, <a href="#145507" title="List[Types.this.Symbol]">syms</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Type" id="145594">t</a>, <a title="Types.this.Symbol" id="145595">sym</a><span class="delimiter">)</span> =&gt; <a href="#145594" title="Types.this.Type">t</a>.<a href="#41555" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#145595" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#41560" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#145594" title="Types.this.Type">t</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#145441" title="Types.this.Type">lubThisType</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#145505" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#46443" title="=&gt; Boolean">isTerm</a><span class="delimiter">)</span> // possible problem: owner of info is still the old one, instead of new refinement class
                <a href="#145505" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#46657" title="(newOwner: Types.this.Symbol)Types.this.Symbol">cloneSymbol</a><span class="delimiter">(</span><a href="#145440" title="Types.this.Type">lubRefined</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#46613" title="(info: Types.this.Type)Types.this.Symbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span><a href="#39108" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#145559" title="List[Types.this.Type]">symtypes</a>, <a href="#38784" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#143049" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span title="Types.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#145559" title="List[Types.this.Type]">symtypes</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#145559" title="List[Types.this.Type]">symtypes</a>.<a href="#145626" title="=&gt; Types.this.Type">head</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#145505" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#46657" title="(newOwner: Types.this.Symbol)Types.this.Symbol">cloneSymbol</a><span class="delimiter">(</span><a href="#145440" title="Types.this.Type">lubRefined</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#46613" title="(info: Types.this.Type)Types.this.Symbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span><a href="#145559" title="List[Types.this.Type]">symtypes</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span class="delimiter">{</span>
                <span class="keyword">def</span> <a title="(bnds: List[Types.this.TypeBounds])Types.this.TypeBounds" id="145632">lubBounds</a><span class="delimiter">(</span><a title="List[Types.this.TypeBounds]" id="145633">bnds</a>: <span title="List[Types.this.TypeBounds]">List</span><span class="delimiter">[</span>TypeBounds<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#62311" title="Types.this.TypeBounds">TypeBounds</a> =
                  <a href="#62285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#39117" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#145633" title="List[Types.this.TypeBounds]">bnds</a> <span title="(f: Types.this.TypeBounds =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeBounds],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#145654" title="Types.this.TypeBounds">_</a>.<a href="#62325" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#38784" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#143049" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#39108" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#145633" title="List[Types.this.TypeBounds]">bnds</a> <span title="(f: Types.this.TypeBounds =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeBounds],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#145696" title="Types.this.TypeBounds">_</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#38784" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#143049" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#145440" title="Types.this.Type">lubRefined</a>.<a href="#41504" title="Types.this.Symbol" id="145734">typeSymbol</a>.<a href="Symbols.scala.html#113021" title="Long" id="145737">newAbstractType</a><span class="delimiter">(</span><a href="#145505" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a>.<a href="Names.scala.html#52127" title="Types.this.TypeName" id="145735">toTypeName</a>, <a href="#145505" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#46379" title="Types.this.Position" id="145736">pos</a><span class="delimiter">)</span>
                  .<a href="Symbols.scala.html#46613" title="(info: Types.this.Type)Types.this.Symbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span><a href="#145632" title="(bnds: List[Types.this.TypeBounds])Types.this.TypeBounds">lubBounds</a><span class="delimiter">(</span><a href="#145559" title="List[Types.this.Type]">symtypes</a> <span title="(f: Types.this.Type =&gt; Types.this.TypeBounds)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.TypeBounds,List[Types.this.TypeBounds]])List[Types.this.TypeBounds]">map</span> <span class="delimiter">(</span><a href="#145754" title="Types.this.Type">_</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span class="keyword">def</span> <a title="(tp: Types.this.Type, sym: Types.this.Symbol)Boolean" id="145445">refines</a><span class="delimiter">(</span><a title="Types.this.Type" id="145503">tp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="145504">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="145782">syms</a> = <a href="#145503" title="Types.this.Type">tp</a>.<a href="#41546" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#145504" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#46653" title="=&gt; List[Types.this.Symbol]">alternatives</a>;
            <span title="=&gt; Boolean">!</span><a href="#145782" title="List[Types.this.Symbol]">syms</a>.<span title="=&gt; Boolean">isEmpty</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#145782" title="List[Types.this.Symbol]">syms</a> <span title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="145790">alt</a> =&gt;
              // todo alt != sym is strictly speaking not correct, but without it we lose
              // efficiency.
              <a href="#145790" title="Types.this.Symbol">alt</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#145504" title="Types.this.Symbol">sym</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#39075" title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#145441" title="Types.this.Type">lubThisType</a>, <a href="#145504" title="Types.this.Symbol">sym</a>, <a href="#145503" title="Types.this.Type">tp</a>, <a href="#145790" title="Types.this.Symbol">alt</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          // add a refinement symbol for all non-class members of lubBase
          // which are refined by every type in ts.
          <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="145809">sym</a> &lt;- <a href="#145414" title="Types.this.Type">lubBase</a>.<a href="#41541" title="(f: Types.this.Symbol =&gt; Unit)Unit">nonPrivateMembers</a> ; <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#145443" title="(sym: Types.this.Symbol)Boolean">excludeFromLub</a><span class="delimiter">(</span><a href="#145809" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">try</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Symbol" id="145810">lsym</a> = <a href="#145444" title="(proto: Types.this.Symbol)Types.this.Symbol">lubsym</a><span class="delimiter">(</span><a href="#145809" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
              <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#145810" title="Types.this.Symbol">lsym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#39122" title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol)Unit">addMember</a><span class="delimiter">(</span><a href="#145441" title="Types.this.Type">lubThisType</a>, <a href="#145440" title="Types.this.Type">lubRefined</a>, <a href="#145810" title="Types.this.Symbol">lsym</a><span class="delimiter">)</span>
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <a title="Unit" id="145815">ex</a>: <a href="#39130" title="Types.this.NoCommonType">NoCommonType</a> =&gt;
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#145440" title="Types.this.Type">lubRefined</a>.<a href="#41536" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60495" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#145414" title="Types.this.Type">lubBase</a>
          <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span title="Boolean(true)">verifyLubs</span><span class="delimiter">)</span> <a href="#145440" title="Types.this.Type">lubRefined</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            // Verify that every given type conforms to the calculated lub.
            // In theory this should not be necessary, but higher-order type
            // parameters are not handled correctly.
            <span class="keyword">val</span> <a title="Boolean" id="145821">ok</a> = <a href="#145409" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">{</span> <a title="Types.this.Type" id="145828">t</a> =&gt;
              <span class="delimiter">(</span><a href="#145828" title="Types.this.Type">t</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#145440" title="Types.this.Type">lubRefined</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">{</span>
                <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74514" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">debug</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a> <span title="(x: Boolean)Boolean">||</span> <a href="#38785" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                  <span title="object Console">Console</span>.<span title="(x: Any)Unit">println</span><span class="delimiter">(</span>
                    <span title="String(&quot;Malformed lub: &quot;)" class="string">&quot;Malformed lub: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#145440" title="Types.this.Type">lubRefined</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span> <span title="(x$1: Any)String">+</span>
                    <span title="String(&quot;Argument &quot;)" class="string">&quot;Argument &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#145828" title="Types.this.Type">t</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; does not conform.  Falling back to &quot;)" class="string">&quot; does not conform.  Falling back to &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#145414" title="Types.this.Type">lubBase</a>
                  <span class="delimiter">)</span>
                <span class="delimiter">}</span>
                <span title="Boolean(false)" class="keyword">false</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            // If not, fall back on the more conservative calculation.
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#145821" title="Boolean">ok</a><span class="delimiter">)</span> <a href="#145440" title="Types.this.Type">lubRefined</a>
            <span class="keyword">else</span> <a href="#145414" title="Types.this.Type">lubBase</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <a href="#38945" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#145410" title="List[Types.this.Symbol]">tparams</a>, <a href="#145415" title="Types.this.Type">lubType</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#38785" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#39133" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;lub of &quot;)" class="string">&quot;lub of &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#143048" title="List[Types.this.Type]">ts</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; at depth &quot;)" class="string">&quot; at depth &quot;</span><span title="(x$1: Any)String">+</span><a href="#143049" title="Int">depth</a><span class="delimiter">)</span>//debug
      <a href="#39133" title="(x$1: String)Unit">indent</a> = <a href="#39133" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
      <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#39133" title="=&gt; String">indent</a>.<span title="()Int">length</span> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(100)" class="int">100</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="Types.this.Type" id="145080">res</a> = <a href="#145078" title="(ts0: List[Types.this.Type])Types.this.Type">lub0</a><span class="delimiter">(</span><a href="#143048" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#38785" title="=&gt; Boolean">printLubs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#39133" title="(x$1: String)Unit">indent</a> = <a href="#39133" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">indent</a> <span title="(suffix: String)String">stripSuffix</span> <span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
      <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#39133" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;lub of &quot;)" class="string">&quot;lub of &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#143048" title="List[Types.this.Type]">ts</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; is &quot;)" class="string">&quot; is &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#145080" title="Types.this.Type">res</a><span class="delimiter">)</span>//debug
    <span class="delimiter">}</span>
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#143048" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#145856" title="Types.this.Type">_</a>.<a href="#41493" title="=&gt; Boolean">isNotNull</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#145080" title="Types.this.Type">res</a>.<a href="#41530" title="=&gt; Types.this.Type">notNull</a> <span class="keyword">else</span> <a href="#145080" title="Types.this.Type">res</a>
  <span class="delimiter">}</span>

  <span class="keyword">val</span> <a title="Throwable" id="39109">GlbFailure</a> = <span title="Throwable" class="keyword">new</span> <span title="Throwable">Throwable</span>

  /** A global counter for glb calls in the `specializes` query connected to the `addMembers`
   *  call in `glb`. There's a possible infinite recursion when `specializes` calls
   *  memberType, which calls baseTypeSeq, which calls mergePrefixAndArgs, which calls glb.
   *  The counter breaks this recursion after two calls.
   *  If the recursion is broken, no member is added to the glb.
   */
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="39112">globalGlbDepth</a> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(2)" id="39114">globalGlbLimit</a> = <span title="Int(2)" class="int">2</span>

  /** The greatest lower bound wrt &lt;:&lt; of a list of types */
  <span class="keyword">def</span> <a title="(ts: List[Types.this.Type])Types.this.Type" id="39116">glb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143024">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#39092" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSuper</a><span class="delimiter">(</span><a href="#143024" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#145858" title="Types.this.Type">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>
    <span class="keyword">case</span> <a href="#145870" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="145881">t</a><span class="delimiter">)</span> =&gt; <a href="#145881" title="Types.this.Type">t</a>
    <span class="keyword">case</span> <a title="Types.this.Type" id="145882">ts0</a> =&gt;
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#39118" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glbNorm</a><span class="delimiter">(</span><a href="#145882" title="List[Types.this.Type]">ts0</a>, <a href="#39035" title="(ts: List[Types.this.Type])Int">lubDepth</a><span class="delimiter">(</span><a href="#145882" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
        <a href="#39103" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">lubResults</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#39105" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">glbResults</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)Types.this.Type" id="39117">glb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="143030">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="143031">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#39092" title="(ts: List[Types.this.Type])List[Types.this.Type]">elimSuper</a><span class="delimiter">(</span><a href="#143030" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#145887" title="Types.this.Type">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>
    <span class="keyword">case</span> <a href="#145899" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="145910">t</a><span class="delimiter">)</span> =&gt; <a href="#145910" title="Types.this.Type">t</a>
    <span class="keyword">case</span> <a title="Types.this.Type" id="145911">ts0</a> =&gt; <a href="#39118" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glbNorm</a><span class="delimiter">(</span><a href="#145911" title="List[Types.this.Type]">ts0</a>, <a href="#143031" title="Int">depth</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** The greatest lower bound wrt &lt;:&lt; of a list of types, which have been normalized
   *  wrt elimSuper */
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(ts: List[Types.this.Type], depth: Int)Types.this.Type" id="39118">glbNorm</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="145883">ts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="145884">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="145912">glb0</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="145915">ts0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#145915" title="List[Types.this.Type]">ts0</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#145917" title="Types.this.Type">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>
      <span class="keyword">case</span> <a href="#145929" title="Types.this.Type">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="145940">t</a><span class="delimiter">)</span> =&gt; <a href="#145940" title="Types.this.Type">t</a>
      <span class="keyword">case</span> <a title="Types.this.PolyType" id="145941">ts</a> @ PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="145946">tparams</a>, _<span class="delimiter">)</span> :: _ =&gt;
        <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="145947">tparams1</a> = <a href="util/Collections.scala.html#38302" title="(xs1: List[Types.this.Symbol], xs2: List[List[Types.this.Type]])(f: (Types.this.Symbol, List[Types.this.Type]) =&gt; Types.this.Symbol)List[Types.this.Symbol]">map2</a><span class="delimiter">(</span><a href="#145946" title="List[Types.this.Symbol]">tparams</a>, <a href="#39123" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[List[Types.this.Type]]">matchingBounds</a><span class="delimiter">(</span><a href="#145941" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#145946" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>.<span title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.GenTraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="146019">tparam</a>, <a title="List[Types.this.Type]" id="146020">bounds</a><span class="delimiter">)</span> =&gt;
          <a href="#146019" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46656" title="=&gt; Types.this.Symbol">cloneSymbol</a>.<a href="Symbols.scala.html#46610" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a><span class="delimiter">(</span><a href="#39108" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#146020" title="List[Types.this.Type]">bounds</a>, <a href="#145884" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#62451" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#145947" title="List[Types.this.Symbol]">tparams1</a>, <a href="#39118" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glbNorm</a><span class="delimiter">(</span><a href="#39124" title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]">matchingInstTypes</a><span class="delimiter">(</span><a href="#145941" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#145947" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>, <a href="#145884" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.MethodType" id="146035">ts</a> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="146040">params</a>, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="146041">rest</a> =&gt;
        <a href="#62346" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#146040" title="List[Types.this.Symbol]">params</a>, <a href="#39118" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glbNorm</a><span class="delimiter">(</span><a href="#39125" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span><a href="#146035" title="collection.immutable.::[Types.this.Type]">ts</a>, <a href="#146040" title="List[Types.this.Symbol]">params</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#146058" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#145884" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.NullaryMethodType" id="146086">ts</a> @ NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="146091">rest</a> =&gt;
        <a href="#62410" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><a href="#39118" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glbNorm</a><span class="delimiter">(</span><a href="#39125" title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]">matchingRestypes</a><span class="delimiter">(</span><a href="#146086" title="collection.immutable.::[Types.this.Type]">ts</a>, <span title="object Nil">Nil</span><span class="delimiter">)</span>, <a href="#145884" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.TypeBounds" id="146092">ts</a> @ TypeBounds<span class="delimiter">(</span>_, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="146097">rest</a> =&gt;
        <a href="#62285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#39108" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#146092" title="collection.immutable.::[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#146118" title="Types.this.Type">_</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62325" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#145884" title="Int">depth</a><span class="delimiter">)</span>, <a href="#39117" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#146092" title="collection.immutable.::[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#146160" title="Types.this.Type">_</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#145884" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="146188">ts</a> =&gt;
        <a href="#39105" title="=&gt; scala.collection.mutable.HashMap[(Int, List[Types.this.Type]),Types.this.Type]">glbResults</a> <span title="(key: (Int, List[Types.this.Type]))Option[Types.this.Type]">get</span> <span class="delimiter">(</span><a href="#145884" title="Int">depth</a>, <a href="#146188" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="Types.this.Type">Some</span><span class="delimiter">(</span><a title="Types.this.Type" id="146199">glbType</a><span class="delimiter">)</span> =&gt;
            <a href="#146199" title="Types.this.Type">glbType</a>
          <span class="keyword">case</span> <span title="Types.this.Type">_</span> =&gt;
            <a href="#39105" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">glbResults</a><span class="delimiter">(</span><span title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</span><a href="#145884" title="Int">depth</a>, <a href="#146188" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a>.<a href="Symbols.scala.html#69227" title="=&gt; Types.this.Type">tpe</a>
            <span class="keyword">val</span> <a title="Types.this.Type" id="146200">res</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#145884" title="Int">depth</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a>.<a href="Symbols.scala.html#69227" title="=&gt; Types.this.Type">tpe</a> <span class="keyword">else</span> <a href="#145913" title="(ts0: List[Types.this.Type])Types.this.Type">glb1</a><span class="delimiter">(</span><a href="#146188" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
            <a href="#39105" title="(key: (Int, List[Types.this.Type]), value: Types.this.Type)Unit">glbResults</a><span class="delimiter">(</span><span title="(_1: Int, _2: List[Types.this.Type])(Int, List[Types.this.Type])" class="delimiter">(</span><a href="#145884" title="Int">depth</a>, <a href="#146188" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="#146200" title="Types.this.Type">res</a>
            <a href="#146200" title="Types.this.Type">res</a>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(ts0: List[Types.this.Type])Types.this.Type" id="145913">glb1</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="146215">ts0</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a href="#146223" title="(List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</a><a href="#146222" title="List[Types.this.Type]" id="146223">ts</a>, <a href="#146222" title="List[Types.this.Symbol]" id="146224">tparams</a><span class="delimiter">)</span> = <a href="#39096" title="(ts: List[Types.this.Type])(List[Types.this.Type], List[Types.this.Symbol])">stripExistentialsAndTypeVars</a><span title="(List[Types.this.Type], List[Types.this.Symbol]) @unchecked" class="delimiter">(</span><a href="#146215" title="List[Types.this.Type]">ts0</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Symbol" id="146225">glbOwner</a> = <a href="#39021" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#146223" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="(t: Types.this.Type)List[Types.this.Type]" id="146226">refinedToParents</a><span class="delimiter">(</span><a title="Types.this.Type" id="146247">t</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#146247" title="Types.this.Type">t</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="List[Types.this.Type]">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="146248">ps</a>, _<span class="delimiter">)</span> =&gt; <a href="#146248" title="List[Types.this.Type]">ps</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">flatMap</span> <a href="#146226" title="(t: Types.this.Type)List[Types.this.Type]">refinedToParents</a>
          <span class="keyword">case</span> <span title="List[Types.this.Type]">_</span> =&gt; <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#146247" title="Types.this.Type">t</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">def</span> <a title="(t: Types.this.Type)List[Types.this.Scope]" id="146227">refinedToDecls</a><span class="delimiter">(</span><a title="Types.this.Type" id="146300">t</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="List[Types.this.Scope]">List</span><span class="delimiter">[</span>Scope<span class="delimiter">]</span> = <a href="#146300" title="Types.this.Type">t</a> <span title="List[Types.this.Scope]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="List[Types.this.Scope]">RefinedType</span><span class="delimiter">(</span><a title="List[Types.this.Type]" id="146301">ps</a>, <a title="Types.this.Scope" id="146302">decls</a><span class="delimiter">)</span> =&gt;
            <span class="keyword">val</span> <a title="List[Types.this.Scope]" id="146303">dss</a> = <a href="#146301" title="List[Types.this.Type]">ps</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Scope])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Scope,List[Types.this.Scope]])List[Types.this.Scope]">flatMap</span> <a href="#146227" title="(t: Types.this.Type)List[Types.this.Scope]">refinedToDecls</a>
            <span title="List[Types.this.Scope]" class="keyword">if</span> <span class="delimiter">(</span><a href="#146302" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60495" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#146303" title="List[Types.this.Scope]">dss</a> <span class="keyword">else</span> <a href="#146302" title="Types.this.Scope">decls</a> <a href="#146348" title="(x: Types.this.Scope)List[Types.this.Scope]">::</a> <a href="#146303" title="List[Types.this.Scope]">dss</a>
          <span class="keyword">case</span> <span title="List[Nothing]">_</span> =&gt; List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">val</span> <a title="List[Types.this.Type]" id="146228">ts1</a> = <a href="#146223" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">flatMap</span> <a href="#146226" title="(t: Types.this.Type)List[Types.this.Type]">refinedToParents</a>
        <span class="keyword">val</span> <a title="Types.this.Type" id="146229">glbBase</a> = <a href="#38938" title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="#146228" title="List[Types.this.Type]">ts1</a>, <a href="#146225" title="Types.this.Symbol">glbOwner</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Types.this.Type" id="146230">glbType</a> =
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">||</span> <a href="#145884" title="Int">depth</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#146229" title="Types.this.Type">glbBase</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="146413">glbRefined</a> = <a href="#38932" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#146228" title="List[Types.this.Type]">ts1</a>, <a href="#146225" title="Types.this.Symbol">glbOwner</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="Types.this.Type" id="146414">glbThisType</a> = <a href="#146413" title="Types.this.Type">glbRefined</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#46667" title="=&gt; Types.this.Type">thisType</a>
            <span class="keyword">def</span> <a title="(proto: Types.this.Symbol)Types.this.Symbol" id="146415">glbsym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="146420">proto</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="Types.this.Type" id="146421">prototp</a> = <a href="#146414" title="Types.this.Type">glbThisType</a>.<a href="#41555" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#146420" title="Types.this.Symbol">proto</a><span class="delimiter">)</span>
              <span class="keyword">val</span> <a title="List[Types.this.Symbol]" id="146422">syms</a> = <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="146434">t</a> &lt;- <a href="#146223" title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">ts</a>;
                    <a title="Types.this.Symbol" id="146450">alt</a> &lt;- <span class="delimiter">(</span><a href="#146434" title="Types.this.Type">t</a>.<a href="#41546" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#146420" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#46653" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">alternatives</a><span class="delimiter">)</span>;
                <span class="keyword">if</span> <a href="#146414" title="Types.this.Type">glbThisType</a>.<a href="#41555" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#146450" title="Types.this.Symbol">alt</a><span class="delimiter">)</span> <a href="#41577" title="(that: Types.this.Type)Boolean">matches</a> <a href="#146421" title="Types.this.Type">prototp</a>
              <span class="delimiter">)</span> <span class="keyword">yield</span> <a href="#146450" title="Types.this.Symbol">alt</a>
              <span class="keyword">val</span> <a title="List[Types.this.Type]" id="146423">symtypes</a> = <a href="#146422" title="List[Types.this.Symbol]">syms</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#146414" title="Types.this.Type">glbThisType</a>.<a href="#41555" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a>
              <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#146423" title="List[Types.this.Type]">symtypes</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
              <a href="#146420" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#46657" title="(newOwner: Types.this.Symbol)Types.this.Symbol">cloneSymbol</a><span class="delimiter">(</span><a href="#146413" title="Types.this.Type">glbRefined</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#46613" title="(info: Types.this.Type)Types.this.Symbol">setInfoOwnerAdjusted</a><span class="delimiter">(</span>
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#146420" title="Types.this.Symbol">proto</a>.<a href="Symbols.scala.html#46443" title="=&gt; Boolean">isTerm</a><span class="delimiter">)</span> <a href="#39117" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#146423" title="List[Types.this.Type]">symtypes</a>, <a href="#38784" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#145884" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span class="delimiter">{</span>
                  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Boolean" id="146563">isTypeBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="146567">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#146567" title="Types.this.Type">tp</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
                    <span class="keyword">case</span> <span title="Boolean(true)">TypeBounds</span><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <span title="Boolean(true)" class="keyword">true</span>
                    <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
                  <span class="delimiter">}</span>
                  <span class="keyword">def</span> <a title="(bnds: List[Types.this.Type])Types.this.TypeBounds" id="146564">glbBounds</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="146568">bnds</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#62311" title="Types.this.TypeBounds">TypeBounds</a> = <span class="delimiter">{</span>
                    <span class="keyword">val</span> <a title="Types.this.Type" id="146569">lo</a> = <a href="#39108" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#146568" title="List[Types.this.Type]">bnds</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#146591" title="Types.this.Type">_</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62325" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#38784" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#145884" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="keyword">val</span> <a title="Types.this.Type" id="146570">hi</a> = <a href="#39117" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#146568" title="List[Types.this.Type]">bnds</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#146633" title="Types.this.Type">_</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>, <a href="#38784" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#145884" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span title="Types.this.TypeBounds" class="keyword">if</span> <span class="delimiter">(</span><a href="#146569" title="Types.this.Type">lo</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#146570" title="Types.this.Type">hi</a><span class="delimiter">)</span> <a href="#62285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#146569" title="Types.this.Type">lo</a>, <a href="#146570" title="Types.this.Type">hi</a><span class="delimiter">)</span>
                    <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <a href="#39109" title="=&gt; Throwable">GlbFailure</a>
                  <span class="delimiter">}</span>
                  <span class="keyword">val</span> <a title="List[Types.this.Type]" id="146565">symbounds</a> = <a href="#146423" title="List[Types.this.Type]">symtypes</a> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filter</span> <a href="#146563" title="(tp: Types.this.Type)Boolean">isTypeBound</a>
                  <span class="keyword">var</span> <a title="Types.this.Type" id="146566">result</a>: <a href="#38813" title="Types.this.Type">Type</a> =
                    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#146565" title="List[Types.this.Type]">symbounds</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
                      <a href="#132015" title="object Types.this.TypeBounds">TypeBounds</a>.<a href="#62282" title="=&gt; Types.this.TypeBounds">empty</a>
                    <span class="keyword">else</span> <a href="#146564" title="(bnds: List[Types.this.Type])Types.this.TypeBounds">glbBounds</a><span class="delimiter">(</span><a href="#146565" title="List[Types.this.Type]">symbounds</a><span class="delimiter">)</span>
                  <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Type" id="146674">t</a> &lt;- <a href="#146423" title="(f: Types.this.Type =&gt; Unit)Unit">symtypes</a> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#146563" title="(tp: Types.this.Type)Boolean">isTypeBound</a><span class="delimiter">(</span><a href="#146674" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#146566" title="Types.this.Type">result</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a> <a href="#62306" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#146674" title="Types.this.Type">t</a><span class="delimiter">)</span> <a href="#146566" title="Types.this.Type">result</a> = <a href="#146674" title="Types.this.Type">t</a>
                    <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <a href="#39109" title="=&gt; Throwable">GlbFailure</a>
                  <a href="#146566" title="Types.this.Type">result</a>
                <span class="delimiter">}</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#39112" title="=&gt; Int">globalGlbDepth</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(2)">globalGlbLimit</span><span class="delimiter">)</span>
              <span class="keyword">try</span> <span class="delimiter">{</span>
                <a href="#39112" title="(x$1: Int)Unit">globalGlbDepth</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
                <span class="keyword">val</span> <a title="List[Types.this.Scope]" id="146680">dss</a> = <a href="#146223" title="List[Types.this.Type]">ts</a> <span title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Scope])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Scope,List[Types.this.Scope]])List[Types.this.Scope]">flatMap</span> <a href="#146227" title="(t: Types.this.Type)List[Types.this.Scope]">refinedToDecls</a>
                <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Scope" id="146744">ds</a> &lt;- <a href="#146680" title="(f: Types.this.Scope =&gt; Unit)Unit">dss</a>; <a title="Types.this.Symbol" id="146755">sym</a> &lt;- <a href="#146744" title="Types.this.Scope">ds</a>.<a href="Scopes.scala.html#60512" title="(f: Types.this.Symbol =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span>
                  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#39112" title="=&gt; Int">globalGlbDepth</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(2)">globalGlbLimit</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#146414" title="Types.this.Type">glbThisType</a> <a href="#41576" title="(sym: Types.this.Symbol)Boolean">specializes</a> <a href="#146755" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="keyword">try</span> <span class="delimiter">{</span>
                      <a href="#39122" title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol)Unit">addMember</a><span class="delimiter">(</span><a href="#146414" title="Types.this.Type">glbThisType</a>, <a href="#146413" title="Types.this.Type">glbRefined</a>, <a href="#146415" title="(proto: Types.this.Symbol)Types.this.Symbol">glbsym</a><span class="delimiter">(</span><a href="#146755" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
                      <span class="keyword">case</span> <a title="Unit" id="146760">ex</a>: <a href="#39130" title="Types.this.NoCommonType">NoCommonType</a> =&gt;
                    <span class="delimiter">}</span>
              <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                <a href="#39112" title="(x$1: Int)Unit">globalGlbDepth</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
              <span class="delimiter">}</span>
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#146413" title="Types.this.Type">glbRefined</a>.<a href="#41536" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#60495" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#146229" title="Types.this.Type">glbBase</a> <span class="keyword">else</span> <a href="#146413" title="Types.this.Type">glbRefined</a>
          <span class="delimiter">}</span>
        <a href="#38945" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#146224" title="List[Types.this.Symbol]">tparams</a>, <a href="#146230" title="Types.this.Type">glbType</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="#39109" title="Types.this.Type">GlbFailure</a> =&gt;
          <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#145883" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a title="Types.this.Type" id="146776">t</a> =&gt; <a href="Definitions.scala.html#44998" title="object Types.this.definitions.NullClass">NullClass</a>.<a href="Symbols.scala.html#69227" title="=&gt; Types.this.Type">tpe</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#146776" title="Types.this.Type">t</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Definitions.scala.html#44998" title="object Types.this.definitions.NullClass">NullClass</a>.<a href="Symbols.scala.html#69227" title="=&gt; Types.this.Type">tpe</a>
          <span class="keyword">else</span> <a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a>.<a href="Symbols.scala.html#69227" title="=&gt; Types.this.Type">tpe</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    // if (settings.debug.value) { println(indent + &quot;glb of &quot; + ts + &quot; at depth &quot;+depth); indent = indent + &quot;  &quot; } //DEBUG

    <span class="keyword">val</span> <a title="Types.this.Type" id="145914">res</a> = <a href="#145912" title="(ts0: List[Types.this.Type])Types.this.Type">glb0</a><span class="delimiter">(</span><a href="#145883" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>

    // if (settings.debug.value) { indent = indent.substring(0, indent.length() - 2); log(indent + &quot;glb of &quot; + ts + &quot; is &quot; + res) }//DEBUG

    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#145883" title="List[Types.this.Type]">ts</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#146785" title="Types.this.Type">_</a>.<a href="#41493" title="=&gt; Boolean">isNotNull</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#145914" title="Types.this.Type">res</a>.<a href="#41530" title="=&gt; Types.this.Type">notNull</a> <span class="keyword">else</span> <a href="#145914" title="Types.this.Type">res</a>
  <span class="delimiter">}</span>
  
  /** A list of the typevars in a type. */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)List[Types.this.TypeVar]" id="39119">typeVarsInType</a><span class="delimiter">(</span><a title="Types.this.Type" id="146786">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="List[Types.this.TypeVar]">List</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="List[Types.this.TypeVar]" id="146788">tvs</a>: <span title="List[Types.this.TypeVar]">List</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> = <span title="object Nil">Nil</span>
    <a href="#146786" title="Types.this.Type">tp</a> <a href="#41566" title="(f: Types.this.Type =&gt; Unit)Unit">foreach</a> <a href="#146791" title="Unit" class="delimiter">{</a>
      <span class="keyword">case</span> <a title="Unit" id="146792">t</a>: <a href="#38912" title="Types.this.TypeVar">TypeVar</a> =&gt; <a href="#146788" title="List[Types.this.TypeVar]">tvs</a> <span title="(x: Types.this.TypeVar)List[Types.this.TypeVar]">::=</span> <a href="#146792" title="Types.this.TypeVar">t</a>
      <span class="keyword">case</span> <span title="Unit">_</span>          =&gt; 
    <span class="delimiter">}</span>
    <a href="#146788" title="List[Types.this.TypeVar]">tvs</a>.<span title="=&gt; List[Types.this.TypeVar]">reverse</span>
  <span class="delimiter">}</span>
  /** Make each type var in this type use its original type for comparisons instead
   * of collecting constraints.
   */
  <span class="keyword">def</span> <a title="(tp: Types.this.Type)List[Types.this.TypeVar]" id="39120">suspendTypeVarsInType</a><span class="delimiter">(</span><a title="Types.this.Type" id="131280">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="List[Types.this.TypeVar]">List</span><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="List[Types.this.TypeVar]" id="146807">tvs</a> = <a href="#39119" title="(tp: Types.this.Type)List[Types.this.TypeVar]">typeVarsInType</a><span class="delimiter">(</span><a href="#131280" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    // !!! Is it somehow guaranteed that this will not break under nesting?
    // In general one has to save and restore the contents of the field...
    <a href="#146807" title="List[Types.this.TypeVar]">tvs</a> <span title="(f: Types.this.TypeVar =&gt; Unit)Unit">foreach</span> <span class="delimiter">(</span><a href="#146827" title="Types.this.TypeVar">_</a>.<a href="#83983" title="(x$1: Boolean)Unit">suspended</a> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <a href="#146807" title="List[Types.this.TypeVar]">tvs</a> 
  <span class="delimiter">}</span>

  /** Compute lub (if `variance == 1`) or glb (if `variance == -1`) of given list
   *  of types `tps`. All types in `tps` are typerefs or singletypes
   *  with the same symbol.
   *  Return `Some(x)` if the computation succeeds with result `x`.
   *  Return `None` if the computation fails.
   */
  <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], variance: Int, depth: Int)Option[Types.this.Type]" id="39121">mergePrefixAndArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="60563">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Int" id="60564">variance</a>: <span title="Int">Int</span>, <a title="Int" id="60565">depth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Option[Types.this.Type]">Option</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#60563" title="List[Types.this.Type]">tps</a> <span title="Option[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#146830" title="Some[Types.this.Type]">List</a><span class="delimiter">(</span><a title="Types.this.Type" id="146841">tp</a><span class="delimiter">)</span> =&gt;
      <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#146841" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Option[Types.this.Type]">TypeRef</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="146849">sym</a>, _<span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="146850">rest</a> =&gt;
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="146851">pres</a> = <a href="#60563" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#146871" title="Types.this.Type">_</a>.<a href="#41514" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span> // prefix normalizes automatically
      <span class="keyword">val</span> <a title="Types.this.Type" id="146852">pre</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#60564" title="Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#39108" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#146851" title="List[Types.this.Type]">pres</a>, <a href="#60565" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#39117" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#146851" title="List[Types.this.Type]">pres</a>, <a href="#60565" title="Int">depth</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[List[Types.this.Type]]" id="146853">argss</a> = <a href="#60563" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <span class="delimiter">(</span><a href="#146921" title="Types.this.Type">_</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a>.<a href="#41517" title="=&gt; List[Types.this.Type]">typeArgs</a><span class="delimiter">)</span> // symbol equality (of the tp in tps) was checked using typeSymbol, which normalizes, so should normalize before retrieving arguments
      <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[Types.this.Symbol]" id="146854">capturedParams</a> = <span title="scala.collection.mutable.ListBuffer[Types.this.Symbol]" class="keyword">new</span> <span title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">ListBuffer</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#146849" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#45152" title="=&gt; Types.this.Symbol">ArrayClass</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          // special treatment for lubs of array types after erasure:
          // if argss contain one value type and some other type, the lub is Object
          // if argss contain several reference types, the lub is an array over lub of argtypes
          <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#146853" title="List[List[Types.this.Type]]">argss</a> <span title="(p: List[Types.this.Type] =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#146959" title="List[Types.this.Type]">_</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="object None">None</span>  // something is wrong: an array without a type arg.
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[Types.this.Type]" id="146960">args</a> = <a href="#146853" title="List[List[Types.this.Type]]">argss</a> <span title="(f: List[Types.this.Type] =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[Types.this.Type]],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#146977" title="List[Types.this.Type]">_</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span>
            <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#146960" title="List[Types.this.Type]">args</a>.<span title="=&gt; List[Types.this.Type]">tail</span> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</span> <span class="delimiter">(</span><a href="#147013" title="Types.this.Type">_</a> <a href="#41575" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#146960" title="List[Types.this.Type]">args</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#38934" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#146852" title="Types.this.Type">pre</a>, <a href="#146849" title="Types.this.Symbol">sym</a>, <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#146960" title="List[Types.this.Type]">args</a>.<span title="=&gt; Types.this.Type">head</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword">else</span> <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#146960" title="List[Types.this.Type]">args</a> <span title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a title="Types.this.Type" id="147031">arg</a> =&gt; <a href="Definitions.scala.html#45476" title="(sym: Types.this.Symbol)Boolean">isValueClass</a><span class="delimiter">(</span><a href="#147031" title="Types.this.Type">arg</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="Definitions.scala.html#44986" title="=&gt; Types.this.Symbol">ObjectClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#38934" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#146852" title="Types.this.Type">pre</a>, <a href="#146849" title="Types.this.Symbol">sym</a>, <span title="(xs: Types.this.Type*)List[Types.this.Type]">List</span><span class="delimiter">(</span><a href="#39107" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><a href="#146960" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="List[Types.this.Type]" id="147049">args</a> = <a href="util/Collections.scala.html#38302" title="(xs1: List[Types.this.Symbol], xs2: List[List[Types.this.Type]])(f: (Types.this.Symbol, List[Types.this.Type]) =&gt; Types.this.Type)List[Types.this.Type]">map2</a><span class="delimiter">(</span><a href="#146849" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#146853" title="List[List[Types.this.Type]]">argss</a>.<span title="(implicit asTraversable: List[Types.this.Type] =&gt; scala.collection.GenTraversableOnce[Types.this.Type])List[List[Types.this.Type]]">transpose</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="147122">tparam</a>, <a title="List[Types.this.Type]" id="147123">as</a><span class="delimiter">)</span> =&gt;
            <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#60565" title="Int">depth</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#147122" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46562" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <a href="#60564" title="Int">variance</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                // Take the intersection of the upper bounds of the type parameters
                // rather than falling all the way back to &quot;Any&quot;, otherwise we end up not
                // conforming to bounds.
                <span class="keyword">val</span> <a title="List[Types.this.Type]" id="147133">bounds0</a> = <a href="#146849" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46628" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#147153" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41512" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#62326" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span> <span title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</span> <span class="delimiter">(</span><a href="#147186" title="Types.this.Type">_</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a><span class="delimiter">)</span>
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#147133" title="List[Types.this.Type]">bounds0</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>
                <span class="keyword">else</span> <a href="#38939" title="(tps: List[Types.this.Type])Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="#147133" title="List[Types.this.Type]">bounds0</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a title="Types.this.Type" id="147212">b</a> =&gt; <a href="#147212" title="Types.this.Type">b</a>.<a href="#41554" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#60563" title="List[Types.this.Type]">tps</a>.<span title="=&gt; Types.this.Type">head</span>, <a href="#146849" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="delimiter">}</span>
              <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#147122" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46562" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="=&gt; Int">-</span><a href="#60564" title="Int">variance</a><span class="delimiter">)</span> <a href="Definitions.scala.html#44996" title="object Types.this.definitions.NothingClass">NothingClass</a>.<a href="Symbols.scala.html#69227" title="=&gt; Types.this.Type">tpe</a>
              <span class="keyword">else</span> <a href="#131699" title="object Types.this.NoType">NoType</a>
            <span class="delimiter">}</span>
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#147122" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46562" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <a href="#60564" title="Int">variance</a><span class="delimiter">)</span> <a href="#39108" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#147123" title="List[Types.this.Type]">as</a>, <a href="#38784" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#60565" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#147122" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46562" title="=&gt; Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="=&gt; Int">-</span><a href="#60564" title="Int">variance</a><span class="delimiter">)</span> <a href="#39117" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#147123" title="List[Types.this.Type]">as</a>, <a href="#38784" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#60565" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span class="delimiter">{</span>
                <span class="keyword">val</span> <a title="Types.this.Type" id="147265">l</a> = <a href="#39108" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#147123" title="List[Types.this.Type]">as</a>, <a href="#38784" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#60565" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">val</span> <a title="Types.this.Type" id="147266">g</a> = <a href="#39117" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#147123" title="List[Types.this.Type]">as</a>, <a href="#38784" title="(depth: Int)Int">decr</a><span class="delimiter">(</span><a href="#60565" title="Int">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#147265" title="Types.this.Type">l</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#147266" title="Types.this.Type">g</a><span class="delimiter">)</span> <a href="#147265" title="Types.this.Type">l</a>
                <span class="keyword">else</span> <span class="delimiter">{</span> // Martin: I removed this, because incomplete. Not sure there is a good way to fix it. For the moment we
                       // just err on the conservative side, i.e. with a bound that is too high.
                       // if(!(tparam.info.bounds contains tparam))   //@M can't deal with f-bounds, see #2251

                  <span class="keyword">val</span> <a title="Types.this.Symbol" id="147276">qvar</a> = <a href="#39021" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#147123" title="List[Types.this.Type]">as</a><span class="delimiter">)</span> <a href="Symbols.scala.html#46418" title="(suffix: String)Types.this.Symbol">freshExistential</a> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <a href="Symbols.scala.html#46610" title="(info: Types.this.Type)Types.this.Symbol">setInfo</a> <a href="#62285" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#147266" title="Types.this.Type">g</a>, <a href="#147265" title="Types.this.Type">l</a><span class="delimiter">)</span>
                  <a href="#146854" title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">capturedParams</a> <span title="(x: Types.this.Symbol)capturedParams.type">+=</span> <a href="#147276" title="Types.this.Symbol">qvar</a>
                  <a href="#147276" title="Types.this.Symbol">qvar</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <span title="Option[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#147049" title="List[Types.this.Type]">args</a> <span title="(elem: Any)Boolean">contains</span> <a href="#131699" title="object Types.this.NoType">NoType</a><span class="delimiter">)</span> <span title="object None">None</span>
          <span class="keyword">else</span> <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#38945" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#146854" title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">capturedParams</a>.<span title="=&gt; List[Types.this.Symbol]">toList</span>, <a href="#38934" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#146852" title="Types.this.Type">pre</a>, <a href="#146849" title="Types.this.Symbol">sym</a>, <a href="#147049" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="None.type" id="147297">ex</a>: <a href="#39131" title="Types.this.MalformedType">MalformedType</a> =&gt; <span title="object None">None</span>
        <span class="keyword">case</span> <a title="None.type" id="147298">ex</a>: <span title="IndexOutOfBoundsException">IndexOutOfBoundsException</span> =&gt;  // transpose freaked out because of irregular argss
        // catching just in case (shouldn't happen, but also doesn't cost us)
        <a href="SymbolTable.scala.html#35605" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><span title="String(&quot;transposed irregular matrix!?&quot;)" class="string">&quot;transposed irregular matrix!?&quot;</span><span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="#60563" title="List[Types.this.Type]">tps</a>, <a href="#146853" title="List[List[Types.this.Type]]">argss</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="object None">None</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> <span title="Option[Types.this.Type]">SingleType</span><span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="147311">sym</a><span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="147312">rest</a> =&gt;
      <span class="keyword">val</span> <a title="List[Types.this.Type]" id="147313">pres</a> = <a href="#60563" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#147331" title="Types.this.Type">_</a>.<a href="#41514" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Types.this.Type" id="147314">pre</a> = <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#60564" title="Int">variance</a> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#39108" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#147313" title="List[Types.this.Type]">pres</a>, <a href="#60565" title="Int">depth</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#39117" title="(ts: List[Types.this.Type], depth: Int)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#147313" title="List[Types.this.Type]">pres</a>, <a href="#60565" title="Int">depth</a><span class="delimiter">)</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <span title="(x: Types.this.Type)Some[Types.this.Type]">Some</span><span class="delimiter">(</span><a href="#38930" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#147314" title="Types.this.Type">pre</a>, <a href="#147311" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="None.type" id="147374">ex</a>: <a href="#39131" title="Types.this.MalformedType">MalformedType</a> =&gt; <span title="object None">None</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> <span title="Option[Types.this.Type]">ExistentialType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="147379">tparams</a>, <a title="Types.this.Type" id="147380">quantified</a><span class="delimiter">)</span> :: <a title="List[Types.this.Type]" id="147381">rest</a> =&gt;
      <a href="#39121" title="(tps: List[Types.this.Type], variance: Int, depth: Int)Option[Types.this.Type]">mergePrefixAndArgs</a><span class="delimiter">(</span><a href="#147380" title="Types.this.Type">quantified</a> <a href="#147382" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="#147381" title="List[Types.this.Type]">rest</a>, <a href="#60564" title="Int">variance</a>, <a href="#60565" title="Int">depth</a><span class="delimiter">)</span> <span title="(f: Types.this.Type =&gt; Types.this.Type)Option[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#38945" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#147379" title="List[Types.this.Symbol]">tparams</a>, <a href="#147392" title="Types.this.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="None.type">_</span> =&gt;
      <span title="(assertion: Boolean, message: =&gt; Any)Unit">assert</span><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span>, <a href="#60563" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>; <span title="object None">None</span>
  <span class="delimiter">}</span>

  /** Make symbol `sym` a member of scope `tp.decls`
   *  where `thistp` is the narrowed owner type of the scope.
   */
  <span class="keyword">def</span> <a title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol)Unit" id="39122">addMember</a><span class="delimiter">(</span><a title="Types.this.Type" id="115582">thistp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="115583">tp</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="115584">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#115584" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="Symbols.scala.html#38740" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
    // debuglog(&quot;add member &quot; + sym+&quot;:&quot;+sym.info+&quot; to &quot;+thistp) //DEBUG
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#115582" title="Types.this.Type">thistp</a> <a href="#41576" title="(sym: Types.this.Symbol)Boolean">specializes</a> <a href="#115584" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#115584" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46443" title="=&gt; Boolean">isTerm</a><span class="delimiter">)</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="147423">alt</a> &lt;- <a href="#115583" title="Types.this.Type">tp</a>.<a href="#41539" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateDecl</a><span class="delimiter">(</span><a href="#115584" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#46571" title="=&gt; Types.this.Name">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#46653" title="(f: Types.this.Symbol =&gt; Unit)Unit">alternatives</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#39075" title="(tp1: Types.this.Type, sym1: Types.this.Symbol, tp2: Types.this.Type, sym2: Types.this.Symbol)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#115582" title="Types.this.Type">thistp</a>, <a href="#115584" title="Types.this.Symbol">sym</a>, <a href="#115582" title="Types.this.Type">thistp</a>, <a href="#147423" title="Types.this.Symbol">alt</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#115583" title="Types.this.Type">tp</a>.<a href="#41536" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#60505" title="(sym: Types.this.Symbol)Unit">unlink</a> <a href="#147423" title="Types.this.Symbol">alt</a>;
      <a href="#115583" title="Types.this.Type">tp</a>.<a href="#41536" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#60499" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#115584" title="Types.this.Symbol">sym</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** All types in list must be polytypes with type parameter lists of
   *  same length as tparams.
   *  Returns list of list of bounds infos, where corresponding type
   *  parameters are renamed to tparams.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[List[Types.this.Type]]" id="39123">matchingBounds</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="145128">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="145129">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[List[Types.this.Type]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)List[Types.this.Type]" id="147436">getBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="147437">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#147437" title="Types.this.Type">tp</a> <span title="List[Types.this.Type]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="List[Types.this.Type]">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="147438">tparams1</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#147438" title="List[Types.this.Symbol]">tparams1</a>, <a href="#145129" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> =&gt;
        <a href="#147438" title="List[Types.this.Symbol]">tparams1</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="147457">tparam</a> =&gt; <a href="#147457" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#46608" title="=&gt; Types.this.Type">info</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#147438" title="List[Types.this.Symbol]">tparams1</a>, <a href="#145129" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="List[Types.this.Type]" id="147485">tp</a> =&gt;
        <span title="List[Types.this.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#147485" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#147485" title="Types.this.Type">tp</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#147436" title="(tp: Types.this.Type)List[Types.this.Type]">getBounds</a><span class="delimiter">(</span><a href="#147485" title="Types.this.Type">tp</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <span title="Types.this.NoCommonType" class="keyword">new</span> <a href="#39130" title="Types.this.NoCommonType">NoCommonType</a><span class="delimiter">(</span><a href="#145128" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#145128" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; List[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],List[Types.this.Type],List[List[Types.this.Type]]])List[List[Types.this.Type]]">map</span> <a href="#147436" title="(tp: Types.this.Type)List[Types.this.Type]">getBounds</a>
  <span class="delimiter">}</span>

  /** All types in list must be polytypes with type parameter lists of
   *  same length as tparams.
   *  Returns list of instance types, where corresponding type
   *  parameters are renamed to tparams.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], tparams: List[Types.this.Symbol])List[Types.this.Type]" id="39124">matchingInstTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="145215">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="145216">tparams</a>: <span title="List[Types.this.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="147531">transformResultType</a><span class="delimiter">(</span><a title="Types.this.Type" id="147532">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> = <a href="#147532" title="Types.this.Type">tp</a> <span title="Types.this.Type" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Types.this.Type">PolyType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="147533">tparams1</a>, <a title="Types.this.Type" id="147534">restpe</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#39051" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#147533" title="List[Types.this.Symbol]">tparams1</a>, <a href="#145216" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> =&gt;
        <a href="#147534" title="Types.this.Type">restpe</a>.<a href="#41559" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#147533" title="List[Types.this.Symbol]">tparams1</a>, <a href="#145216" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Types.this.Type" id="147537">tp</a> =&gt;
        <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#147537" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#147537" title="Types.this.Type">tp</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#147531" title="(tp: Types.this.Type)Types.this.Type">transformResultType</a><span class="delimiter">(</span><a href="#147537" title="Types.this.Type">tp</a>.<a href="#41534" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="Nothing" class="keyword">throw</span> <span title="Types.this.NoCommonType" class="keyword">new</span> <a href="#39130" title="Types.this.NoCommonType">NoCommonType</a><span class="delimiter">(</span><a href="#145215" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#145215" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#147531" title="(tp: Types.this.Type)Types.this.Type">transformResultType</a>
  <span class="delimiter">}</span>

  /** All types in list must be method types with equal parameter types.
   *  Returns list of their result types.
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tps: List[Types.this.Type], pts: List[Types.this.Type])List[Types.this.Type]" id="39125">matchingRestypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="145225">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="145226">pts</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span> =
    <a href="#145225" title="List[Types.this.Type]">tps</a> <span title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <a href="#147598" title="Types.this.Type" class="delimiter">{</a>
      <span class="keyword">case</span> <span title="Types.this.Type">MethodType</span><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="147599">params1</a>, <a title="Types.this.Type" id="147600">res</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#39050" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean">isSameTypes</a><span class="delimiter">(</span><a href="#147599" title="List[Types.this.Symbol]">params1</a> <span title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</span> <span class="delimiter">(</span><a href="#147617" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>, <a href="#145226" title="List[Types.this.Type]">pts</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <a href="#147600" title="Types.this.Type">res</a>
      <span class="keyword">case</span> <span title="Types.this.Type">NullaryMethodType</span><span class="delimiter">(</span><a title="Types.this.Type" id="147645">res</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#145226" title="List[Types.this.Type]">pts</a> <span title="=&gt; Boolean">isEmpty</span> =&gt;
        <a href="#147645" title="Types.this.Type">res</a>
      <span class="keyword">case</span> <span title="Nothing">_</span> =&gt;
        <span title="Nothing" class="keyword">throw</span> <span title="Types.this.NoCommonType" class="keyword">new</span> <a href="#39130" title="Types.this.NoCommonType">NoCommonType</a><span class="delimiter">(</span><a href="#145225" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

// Errors and Diagnostics -----------------------------------------------------

  /** A throwable signalling a type error */
  <span class="keyword">class</span> <a title="class TypeError extends Throwable with ScalaObject" id="39126">TypeError</a><a href="#39126" title="ScalaObject" class="delimiter">(</a><span class="keyword">var</span> <a title="Types.this.Position" id="62870">pos</a>: <span title="Types.this.Position">Position</span>, <span class="keyword">val</span> <a title="String" id="62871">msg</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="Throwable">Throwable</span><span class="delimiter">(</span><a href="#62871" title="String">msg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(msg: String)Types.this.TypeError" id="62866" class="keyword">this</a><span class="delimiter">(</span><a title="String" id="62869">msg</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#39126" title="TypeError.this.type" class="keyword">this</a><span class="delimiter">(</span><a href="#7741" title="=&gt; Types.this.Position">NoPosition</a>, <a href="#62869" title="String">msg</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  // TODO: RecoverableCyclicReference should be separated from TypeError,
  // but that would be a big change. Left for further refactoring.
  /** An exception for cyclic references from which we can recover */
  case <span class="keyword">class</span> <a title="class RecoverableCyclicReference extends Types.this.TypeError with ScalaObject with Product with Serializable" id="147833">RecoverableCyclicReference</a><a href="#62866" title="ScalaObject" class="delimiter">(</a><a title="Types.this.Symbol" id="147830">sym</a>: <a href="Symbols.scala.html#38726" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>
    <span class="keyword">extends</span> <a href="#39126" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic reference involving &quot;)" class="string">&quot;illegal cyclic reference involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#147830" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>

  <span class="keyword">class</span> <a title="class NoCommonType extends Throwable with scala.util.control.ControlThrowable with ScalaObject" id="39130">NoCommonType</a><a href="#39130" title="ScalaObject" class="delimiter">(</a><a title="List[Types.this.Type]" id="147486">tps</a>: <span title="List[Types.this.Type]">List</span><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="Throwable">Throwable</span><span class="delimiter">(</span>
    <span title="String(&quot;lub/glb of incompatible types: &quot;)" class="string">&quot;lub/glb of incompatible types: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#147486" title="List[Types.this.Type]">tps</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="String(&quot; and &quot;)" class="string">&quot; and &quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">with</span> <span title="scala.util.control.ControlThrowable">ControlThrowable</span>

  /** A throwable signalling a malformed type */
  <span class="keyword">class</span> <a title="class MalformedType extends Types.this.TypeError with ScalaObject" id="39131">MalformedType</a><a href="#62866" title="ScalaObject" class="delimiter">(</a><a title="String" id="141548">msg</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#39126" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><a href="#141548" title="String">msg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(pre: Types.this.Type, tp: String)Types.this.MalformedType" id="140646" class="keyword">this</a><span class="delimiter">(</span><a title="Types.this.Type" id="141546">pre</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="String" id="141547">tp</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#39131" title="MalformedType.this.type" class="keyword">this</a><span class="delimiter">(</span><span title="String(&quot;malformed type: &quot;)" class="string">&quot;malformed type: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#141546" title="Types.this.Type">pre</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#141547" title="String">tp</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** The current indentation string for traces */
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="String" id="39133">indent</a>: <span title="String">String</span> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>

  /** Perform operation `p` on arguments `tp1`, `arg2` and print trace of computation. */
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="[T](op: String, p: (Types.this.Type, T) =&gt; Boolean, tp1: Types.this.Type, arg2: T)Boolean" id="39135">explain</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="39137">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="130908">op</a>: <span title="String">String</span>, <a title="(Types.this.Type, T) =&gt; Boolean" id="130909">p</a>: <span class="delimiter">(</span>Type, T<span class="delimiter">)</span> =&gt; Boolean, <a title="Types.this.Type" id="130910">tp1</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="T" id="130911">arg2</a>: <a href="#39137" title="T">T</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span title="object Console">Console</span>.<span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#39133" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <a href="#130910" title="Types.this.Type">tp1</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#130908" title="String">op</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#130911" title="T">arg2</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span> /* + &quot;(&quot;+tp1.getClass+&quot;,&quot;+arg2.getClass+&quot;)&quot;*/<span class="delimiter">)</span>
    <a href="#39133" title="(x$1: String)Unit">indent</a> = <a href="#39133" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
    <span class="keyword">val</span> <a title="Boolean" id="147747">result</a> = <a href="#130909" title="(v1: Types.this.Type, v2: T)Boolean">p</a><span class="delimiter">(</span><a href="#130910" title="Types.this.Type">tp1</a>, <a href="#130911" title="T">arg2</a><span class="delimiter">)</span>
    <a href="#39133" title="(x$1: String)Unit">indent</a> = <a href="#39133" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">indent</a> <span title="(suffix: String)String">stripSuffix</span> <span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
    <span title="object Console">Console</span>.<span title="(x: Any)Unit">println</span><span class="delimiter">(</span><a href="#39133" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <a href="#147747" title="Boolean">result</a><span class="delimiter">)</span>
    <a href="#147747" title="Boolean">result</a>
  <span class="delimiter">}</span>

  /** If option `explaintypes` is set, print a subtype trace for `found &lt;:&lt; required`. */
  <span class="keyword">def</span> <a title="(found: Types.this.Type, required: Types.this.Type)Unit" id="39138">explainTypes</a><span class="delimiter">(</span><a title="Types.this.Type" id="147757">found</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="147758">required</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74516" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">explaintypes</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#39140" title="(op: =&gt; Boolean)Boolean">withTypesExplained</a><span title="Unit" class="delimiter">(</span><a href="#147757" title="Types.this.Type">found</a> <a href="#41571" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#147758" title="Types.this.Type">required</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** If option `explaintypes` is set, print a subtype trace for `op(found, required)`. */
  <span class="keyword">def</span> <a title="(op: (Types.this.Type, Types.this.Type) =&gt; Any, found: Types.this.Type, required: Types.this.Type)Unit" id="39139">explainTypes</a><span class="delimiter">(</span><a title="(Types.this.Type, Types.this.Type) =&gt; Any" id="147770">op</a>: <span class="delimiter">(</span>Type, Type<span class="delimiter">)</span> =&gt; Any, <a title="Types.this.Type" id="147771">found</a>: <a href="#38813" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="147772">required</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Required.scala.html#39442" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#74516" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">explaintypes</a>.<a href="settings/MutableSettings.scala.html#74542" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="#39140" title="(op: =&gt; Any)Any">withTypesExplained</a><span title="Unit" class="delimiter">(</span><a href="#147770" title="(v1: Types.this.Type, v2: Types.this.Type)Any">op</a><span class="delimiter">(</span><a href="#147771" title="Types.this.Type">found</a>, <a href="#147772" title="Types.this.Type">required</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Execute `op` while printing a trace of the operations on types executed. */
  <span class="keyword">def</span> <a title="[A](op: =&gt; A)A" id="39140">withTypesExplained</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="39142">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="147763">op</a>: =&gt; A<span class="delimiter">)</span>: <a href="#39142" title="A">A</a> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Boolean" id="147782">s</a> = <a href="#38772" title="=&gt; Boolean">explainSwitch</a>
    <span class="keyword">try</span> <span class="delimiter">{</span> <a href="#38772" title="(x$1: Boolean)Unit">explainSwitch</a> = <span title="Boolean(true)" class="keyword">true</span>; <a href="#147763" title="=&gt; A">op</a> <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span> <a href="#38772" title="(x$1: Boolean)Unit">explainSwitch</a> = <a href="#147782" title="Boolean">s</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(tp: Types.this.Type)Types.this.Type" id="39143">objToAny</a><span class="delimiter">(</span><a title="Types.this.Type" id="147783">tp</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#38813" title="Types.this.Type">Type</a> =
    <span title="Types.this.Type" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="SymbolTable.scala.html#35628" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#69312" title="=&gt; Boolean">erasedTypes</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#147783" title="Types.this.Type">tp</a>.<a href="#41504" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Definitions.scala.html#44986" title="=&gt; Types.this.Symbol">ObjectClass</a><span class="delimiter">)</span> <a href="Definitions.scala.html#44982" title="=&gt; Types.this.Symbol">AnyClass</a>.<a href="Symbols.scala.html#46606" title="=&gt; Types.this.Type">tpe</a>
    <span class="keyword">else</span> <a href="#147783" title="Types.this.Type">tp</a>

  <span class="keyword">val</span> <a title="scala.collection.immutable.Set[String]" id="39144">shorthands</a> = <span title="(elems: String*)scala.collection.immutable.Set[String]">Set</span><span class="delimiter">(</span>
    <span title="String(&quot;scala.collection.immutable.List&quot;)" class="string">&quot;scala.collection.immutable.List&quot;</span>,
    <span title="String(&quot;scala.collection.immutable.Nil&quot;)" class="string">&quot;scala.collection.immutable.Nil&quot;</span>,
    <span title="String(&quot;scala.collection.Seq&quot;)" class="string">&quot;scala.collection.Seq&quot;</span>,
    <span title="String(&quot;scala.collection.Traversable&quot;)" class="string">&quot;scala.collection.Traversable&quot;</span>,
    <span title="String(&quot;scala.collection.Iterable&quot;)" class="string">&quot;scala.collection.Iterable&quot;</span>,
    <span title="String(&quot;scala.collection.mutable.StringBuilder&quot;)" class="string">&quot;scala.collection.mutable.StringBuilder&quot;</span>,
    <span title="String(&quot;scala.collection.IndexedSeq&quot;)" class="string">&quot;scala.collection.IndexedSeq&quot;</span>,
    <span title="String(&quot;scala.collection.Iterator&quot;)" class="string">&quot;scala.collection.Iterator&quot;</span><span class="delimiter">)</span>


  /** The maximum number of recursions allowed in toString
   */
  <span class="keyword">final</span> <span class="keyword">val</span> <a title="Int(50)" id="39146">maxTostringRecursions</a> = <span title="Int(50)" class="int">50</span>

  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="39149">tostringRecursions</a> = <span title="Int(0)" class="int">0</span>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tpe: Types.this.Type)String" id="39151">typeToString</a><span class="delimiter">(</span><a title="Types.this.Type" id="131206">tpe</a>: <a href="#38813" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <span title="String">String</span> =
    <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#39149" title="=&gt; Int">tostringRecursions</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(50)">maxTostringRecursions</span><span class="delimiter">)</span>
      <span title="String(&quot;...&quot;)" class="string">&quot;...&quot;</span>
    <span class="keyword">else</span>
      <span class="keyword">try</span> <span class="delimiter">{</span>
        <a href="#39149" title="(x$1: Int)Unit">tostringRecursions</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
        <a href="#131206" title="Types.this.Type">tpe</a>.<a href="#41590" title="=&gt; String">safeToString</a>
      <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
        <a href="#39149" title="(x$1: Int)Unit">tostringRecursions</a> <span title="(x: Int)Int">-=</span> <span title="Int(1)" class="int">1</span>
      <span class="delimiter">}</span>
   
<span class="delimiter">}</span>

        </pre>
    </body>
</html>