<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>fj/control/parallel/Strategy.java</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> fj.control.parallel;

<span class="keyword">import</span> fj.Effect;
<span class="keyword">import</span> fj.F;
<span class="keyword">import</span> fj.F2;
<span class="keyword">import</span> fj.Function;
<span class="keyword">import</span> fj.P;
<span class="keyword">import</span> fj.P1;
<span class="keyword">import</span> static fj.Function.compose;
<span class="keyword">import</span> static fj.Function.curry;
<span class="keyword">import</span> static fj.P1.fmap;
<span class="keyword">import</span> static fj.P1.sequence;
<span class="keyword">import</span> fj.data.Java;
<span class="keyword">import</span> fj.data.List;
<span class="keyword">import</span> fj.data.Array;

<span class="keyword">import</span> java.util.concurrent.Callable;
<span class="keyword">import</span> java.util.concurrent.CompletionService;
<span class="keyword">import</span> java.util.concurrent.ExecutionException;
<span class="keyword">import</span> java.util.concurrent.ExecutorService;
<span class="keyword">import</span> java.util.concurrent.Future;
<span class="keyword">import</span> java.util.concurrent.FutureTask;

<span class="comment">/**
 * Functional-style parallel evaluation strategies.
 * A Strategy is a method of evaluating a product-1, yielding another product-1 from which the result of its evaluation
 * can be retrieved at a later time.
 * &lt;p/&gt;
 *
 * @version %build.number%
 */</span>
public <span class="keyword">final</span> <span class="keyword">class</span> <a title="object fj.control.parallel.Strategy" id="9975">Strategy</a>&lt;<a title="Nothing" id="9976">A</a>&gt; <span class="delimiter">{</span>

  <span class="keyword">private</span> <span class="keyword">final</span> F&lt;P1&lt;<a href="#9976" title="A">A</a>&gt;, P1&lt;<a href="#9976" title="A">A</a>&gt;&gt; <a title="fj.F[fj.P1[A],fj.P1[A]]" id="19676">f</a>;

  <span class="keyword">private</span> Strategy<span class="delimiter">(</span><span class="keyword">final</span> F&lt;P1&lt;A&gt;, P1&lt;A&gt;&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">this</span>.f = f;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns the functional representation of this Strategy, a function that evaluates a product-1.
   *
   * @return The function representing this strategy, which evaluates a product-1.
   */</span>
  public F&lt;P1&lt;<a href="#9976" title="A">A</a>&gt;, P1&lt;<a href="#9976" title="A">A</a>&gt;&gt; <a title="()fj.F[fj.P1[A],fj.P1[A]]" id="19678">f</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> f;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Constructs a strategy from the given evaluation function.
   *
   * @param f The execution function for the strategy
   * @return A strategy that uses the given function to evaluate product-1s.
   */</span>
  public static &lt;<a title="Nothing" id="25995">A</a>&gt; <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;<a href="#25995" title="A">A</a>&gt; <a title="[A](f: fj.F[fj.P1[A],fj.P1[A]])fj.control.parallel.Strategy[A]" id="25993">strategy</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;P1&lt;<a href="#25995" title="A">A</a>&gt;, P1&lt;<a href="#25995" title="A">A</a>&gt;&gt; <a title="fj.F[fj.P1[A],fj.P1[A]]" id="26042">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> Strategy&lt;A&gt;<span class="delimiter">(</span>f<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Apply the strategy to the given product-1.
   *
   * @param a A P1 to evaluate according to this strategy.
   * @return A P1 that yields the value from calling the given product-1.
   */</span>
  public P1&lt;<a href="#9976" title="A">A</a>&gt; <a title="(a: fj.P1[A])fj.P1[A]" id="19679">par</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#9976" title="A">A</a>&gt; <a title="fj.P1[A]" id="26183">a</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> f<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>a<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Promotes a function to a concurrent function.
   *
   * @param f A function to promote to a concurrent function.
   * @return A function that executes concurrently when called, yielding a Future value.
   */</span>
  public &lt;<a title="Nothing" id="19682">B</a>&gt; F&lt;<a href="#19682" title="B">B</a>, P1&lt;<a href="#9976" title="A">A</a>&gt;&gt; <a title="[B](f: fj.F[B,A])fj.F[B,fj.P1[A]]" id="19680">concurry</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#19682" title="B">B</a>, <a href="#9976" title="A">A</a>&gt; <a title="fj.F[B,A]" id="26184">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> compose<span class="delimiter">(</span>f<span class="delimiter">(</span><span class="delimiter">)</span>, P1.&lt;B, A&gt;curry<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Promotes a function of arity-2 to a concurrent function.
   *
   * @param f The function to promote to a concurrent function.
   * @return A function that executes concurrently when called, yielding a product-1 that returns the value.
   */</span>
  public &lt;<a title="Nothing" id="19686">B</a>, <a title="Nothing" id="19687">C</a>&gt; F&lt;<a href="#19686" title="B">B</a>, F&lt;<a href="#19687" title="C">C</a>, P1&lt;<a href="#9976" title="A">A</a>&gt;&gt;&gt; <a title="[B, C](f: fj.F2[B,C,A])fj.F[B,fj.F[C,fj.P1[A]]]" id="19683">concurry</a><span class="delimiter">(</span><span class="keyword">final</span> F2&lt;<a href="#19686" title="B">B</a>, <a href="#19687" title="C">C</a>, <a href="#9976" title="A">A</a>&gt; <a title="fj.F2[B,C,A]" id="26186">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;B, F&lt;C, P1&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public F&lt;C, P1&lt;A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> B b<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> concurry<span class="delimiter">(</span>curry<span class="delimiter">(</span>f<span class="delimiter">)</span>.f<span class="delimiter">(</span>b<span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Waits for every Future in a list to obtain a value, and collects those values in a list.
   *
   * @param xs The list of Futures from which to get values.
   * @return A list of values extracted from the Futures in the argument list.
   */</span>
  public static &lt;<a title="Nothing" id="25998">A</a>&gt; List&lt;P1&lt;<a href="#25998" title="A">A</a>&gt;&gt; <a title="[A](xs: fj.data.List[java.util.concurrent.Future[A]])fj.data.List[fj.P1[A]]" id="25996">mergeAll</a><span class="delimiter">(</span><span class="keyword">final</span> List&lt;Future&lt;<a href="#25998" title="A">A</a>&gt;&gt; <a title="fj.data.List[java.util.concurrent.Future[A]]" id="26045">xs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> xs.map<span class="delimiter">(</span>Strategy.&lt;A&gt;obtain<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Evaluates a list of product-1s in parallel.
   *
   * @param ps A list to evaluate in parallel.
   * @return A list of the values of the product-1s in the argument.
   */</span>
  public P1&lt;List&lt;<a href="#9976" title="A">A</a>&gt;&gt; <a title="(ps: fj.data.List[fj.P1[A]])fj.P1[fj.data.List[A]]" id="19688">parList</a><span class="delimiter">(</span><span class="keyword">final</span> List&lt;P1&lt;<a href="#9976" title="A">A</a>&gt;&gt; <a title="fj.data.List[fj.P1[A]]" id="26188">ps</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sequence<span class="delimiter">(</span>ps.map<span class="delimiter">(</span>f<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps the given function over the given list in parallel using this strategy.
   *
   * @param f  A function to map over the given list in parallel.
   * @param bs A list over which to map the given function in parallel.
   * @return A product-1 that returns the list with all of its elements transformed by the given function.
   */</span>
  public &lt;<a title="Nothing" id="19691">B</a>&gt; P1&lt;List&lt;<a href="#9976" title="A">A</a>&gt;&gt; <a title="[B](f: fj.F[B,A], bs: fj.data.List[B])fj.P1[fj.data.List[A]]" id="19689">parMap</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#19691" title="B">B</a>, <a href="#9976" title="A">A</a>&gt; <a title="fj.F[B,A]" id="26189">f</a>, <span class="keyword">final</span> List&lt;<a href="#19691" title="B">B</a>&gt; <a title="fj.data.List[B]" id="26190">bs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sequence<span class="delimiter">(</span>bs.map<span class="delimiter">(</span>concurry<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps the given function over the given array in parallel using this strategy.
   *
   * @param f  A function to map over the given array in parallel.
   * @param bs An array over which to map the given function in parallel.
   * @return A product-1 that returns the array with all of its elements transformed by the given function.
   */</span>
  public &lt;<a title="Nothing" id="19694">B</a>&gt; P1&lt;Array&lt;<a href="#9976" title="A">A</a>&gt;&gt; <a title="[B](f: fj.F[B,A], bs: fj.data.Array[B])fj.P1[fj.data.Array[A]]" id="19692">parMap</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#19694" title="B">B</a>, <a href="#9976" title="A">A</a>&gt; <a title="fj.F[B,A]" id="26193">f</a>, <span class="keyword">final</span> Array&lt;<a href="#19694" title="B">B</a>&gt; <a title="fj.data.Array[B]" id="26194">bs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sequence<span class="delimiter">(</span>bs.map<span class="delimiter">(</span>concurry<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A strict version of parMap over lists.
   * Maps the given function over the given list in parallel using this strategy,
   * blocking the current thread until all values have been obtained.
   *
   * @param f  A function to map over the given list in parallel.
   * @param bs A list over which to map the given function in parallel.
   * @return A list with all of its elements transformed by the given function.
   */</span>
  public &lt;<a title="Nothing" id="19697">B</a>&gt; List&lt;<a href="#9976" title="A">A</a>&gt; <a title="[B](f: fj.F[B,A], bs: fj.data.List[B])fj.data.List[A]" id="19695">parMap1</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#19697" title="B">B</a>, <a href="#9976" title="A">A</a>&gt; <a title="fj.F[B,A]" id="26197">f</a>, <span class="keyword">final</span> List&lt;<a href="#19697" title="B">B</a>&gt; <a title="fj.data.List[B]" id="26198">bs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> compose<span class="delimiter">(</span>P1.&lt;List&lt;A&gt;&gt;__1<span class="delimiter">(</span><span class="delimiter">)</span>, parMapList<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>bs<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A strict version of parMap over arrays.
   * Maps the given function over the given arrays in parallel using this strategy,
   * blocking the current thread until all values have been obtained.
   *
   * @param f  A function to map over the given array in parallel.
   * @param bs An array over which to map the given function in parallel.
   * @return An array with all of its elements transformed by the given function.
   */</span>
  public &lt;<a title="Nothing" id="19700">B</a>&gt; Array&lt;<a href="#9976" title="A">A</a>&gt; <a title="[B](f: fj.F[B,A], bs: fj.data.Array[B])fj.data.Array[A]" id="19698">parMap1</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#19700" title="B">B</a>, <a href="#9976" title="A">A</a>&gt; <a title="fj.F[B,A]" id="26201">f</a>, <span class="keyword">final</span> Array&lt;<a href="#19700" title="B">B</a>&gt; <a title="fj.data.Array[B]" id="26202">bs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> compose<span class="delimiter">(</span>P1.&lt;Array&lt;A&gt;&gt;__1<span class="delimiter">(</span><span class="delimiter">)</span>, parMapArray<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>bs<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Promotes a function to a parallel function on lists using this strategy.
   *
   * @param f A function to transform into a parallel function on lists.
   * @return The function transformed into a parallel function on lists.
   */</span>
  public &lt;<a title="Nothing" id="19703">B</a>&gt; F&lt;List&lt;<a href="#19703" title="B">B</a>&gt;, P1&lt;List&lt;<a href="#9976" title="A">A</a>&gt;&gt;&gt; <a title="[B](f: fj.F[B,A])fj.F[fj.data.List[B],fj.P1[fj.data.List[A]]]" id="19701">parMapList</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#19703" title="B">B</a>, <a href="#9976" title="A">A</a>&gt; <a title="fj.F[B,A]" id="26205">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;List&lt;B&gt;, P1&lt;List&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public P1&lt;List&lt;A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> List&lt;B&gt; as<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parMap<span class="delimiter">(</span>f, as<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * First-class version of parMap on lists.
   *
   * @return A function that promotes another function to a parallel function on lists.
   */</span>
  public &lt;<a title="Nothing" id="19706">B</a>&gt; F&lt;F&lt;<a href="#19706" title="B">B</a>, <a href="#9976" title="A">A</a>&gt;, F&lt;List&lt;<a href="#19706" title="B">B</a>&gt;, P1&lt;List&lt;<a href="#9976" title="A">A</a>&gt;&gt;&gt;&gt; <a title="[B]()fj.F[fj.F[B,A],fj.F[fj.data.List[B],fj.P1[fj.data.List[A]]]]" id="19704">parMapList</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;F&lt;B, A&gt;, F&lt;List&lt;B&gt;, P1&lt;List&lt;A&gt;&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public F&lt;List&lt;B&gt;, P1&lt;List&lt;A&gt;&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;B, A&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parMapList<span class="delimiter">(</span>f<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * First-class version of parMap1 on lists (parallel list functor).
   *
   * @return A function that promotes another function to a blocking parallel function on lists.
   */</span>
  public &lt;<a title="Nothing" id="19709">B</a>&gt; F&lt;F&lt;<a href="#19709" title="B">B</a>, <a href="#9976" title="A">A</a>&gt;, F&lt;List&lt;<a href="#19709" title="B">B</a>&gt;, List&lt;<a href="#9976" title="A">A</a>&gt;&gt;&gt; <a title="[B]()fj.F[fj.F[B,A],fj.F[fj.data.List[B],fj.data.List[A]]]" id="19707">parMapList1</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;F&lt;B, A&gt;, F&lt;List&lt;B&gt;, List&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public F&lt;List&lt;B&gt;, List&lt;A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;B, A&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> F&lt;List&lt;B&gt;, List&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public List&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> List&lt;B&gt; bs<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> parMap1<span class="delimiter">(</span>f, bs<span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Promotes a function to a parallel function on arrays using this strategy.
   *
   * @param f A function to transform into a parallel function on arrays.
   * @return The function transformed into a parallel function on arrays.
   */</span>
  public &lt;<a title="Nothing" id="19712">B</a>&gt; F&lt;Array&lt;<a href="#19712" title="B">B</a>&gt;, P1&lt;Array&lt;<a href="#9976" title="A">A</a>&gt;&gt;&gt; <a title="[B](f: fj.F[B,A])fj.F[fj.data.Array[B],fj.P1[fj.data.Array[A]]]" id="19710">parMapArray</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#19712" title="B">B</a>, <a href="#9976" title="A">A</a>&gt; <a title="fj.F[B,A]" id="26207">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Array&lt;B&gt;, P1&lt;Array&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public P1&lt;Array&lt;A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Array&lt;B&gt; as<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parMap<span class="delimiter">(</span>f, as<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * First-class version of parMap on arrays.
   *
   * @return A function that promotes another function to a parallel function on arrays.
   */</span>
  public &lt;<a title="Nothing" id="19715">B</a>&gt; F&lt;F&lt;<a href="#19715" title="B">B</a>, <a href="#9976" title="A">A</a>&gt;, F&lt;Array&lt;<a href="#19715" title="B">B</a>&gt;, P1&lt;Array&lt;<a href="#9976" title="A">A</a>&gt;&gt;&gt;&gt; <a title="[B]()fj.F[fj.F[B,A],fj.F[fj.data.Array[B],fj.P1[fj.data.Array[A]]]]" id="19713">parMapArray</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;F&lt;B, A&gt;, F&lt;Array&lt;B&gt;, P1&lt;Array&lt;A&gt;&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public F&lt;Array&lt;B&gt;, P1&lt;Array&lt;A&gt;&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;B, A&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parMapArray<span class="delimiter">(</span>f<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * First-class version of parMap1 on arrays (parallel array functor).
   *
   * @return A function that promotes another function to a blocking parallel function on arrays.
   */</span>
  public &lt;<a title="Nothing" id="19718">B</a>&gt; F&lt;F&lt;<a href="#19718" title="B">B</a>, <a href="#9976" title="A">A</a>&gt;, F&lt;Array&lt;<a href="#19718" title="B">B</a>&gt;, Array&lt;<a href="#9976" title="A">A</a>&gt;&gt;&gt; <a title="[B]()fj.F[fj.F[B,A],fj.F[fj.data.Array[B],fj.data.Array[A]]]" id="19716">parMapArray1</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;F&lt;B, A&gt;, F&lt;Array&lt;B&gt;, Array&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public F&lt;Array&lt;B&gt;, Array&lt;A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;B, A&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Array&lt;B&gt;, Array&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Array&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Array&lt;B&gt; bs<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> parMap1<span class="delimiter">(</span>f, bs<span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function in parallel across the given list, using the given strategy, with a final join.
   *
   * @param s  The strategy to use for parallelization.
   * @param f  The function to bind across the given list.
   * @param as The list across which to bind the given function.
   * @return A P1 containing the result of the parallel map operation after the final join.
   */</span>
  public static &lt;<a title="Nothing" id="26002">A</a>, <a title="Nothing" id="26003">B</a>&gt; P1&lt;List&lt;<a href="#26003" title="B">B</a>&gt;&gt; <a title="[A, B](s: fj.control.parallel.Strategy[fj.data.List[B]], f: fj.F[A,fj.data.List[B]], as: fj.data.List[A])fj.P1[fj.data.List[B]]" id="25999">parFlatMap</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;List&lt;<a href="#26003" title="B">B</a>&gt;&gt; <a title="fj.control.parallel.Strategy[fj.data.List[B]]" id="26059">s</a>,
                                              <span class="keyword">final</span> F&lt;<a href="#26002" title="A">A</a>, List&lt;<a href="#26003" title="B">B</a>&gt;&gt; <a title="fj.F[A,fj.data.List[B]]" id="26060">f</a>,
                                              <span class="keyword">final</span> List&lt;<a href="#26002" title="A">A</a>&gt; <a title="fj.data.List[A]" id="26061">as</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> fmap<span class="delimiter">(</span>List.&lt;B&gt;join<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>s.parMap<span class="delimiter">(</span>f, as<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function in parallel across the given array, using the given strategy, with a final join.
   *
   * @param s  The strategy to use for parallelization.
   * @param f  The function to bind across the given array.
   * @param as The array across which to bind the given function.
   * @return A P1 containing the result of the parallel map operation after the final join.
   */</span>
  public static &lt;<a title="Nothing" id="26007">A</a>, <a title="Nothing" id="26008">B</a>&gt; P1&lt;Array&lt;<a href="#26008" title="B">B</a>&gt;&gt; <a title="[A, B](s: fj.control.parallel.Strategy[fj.data.Array[B]], f: fj.F[A,fj.data.Array[B]], as: fj.data.Array[A])fj.P1[fj.data.Array[B]]" id="26004">parFlatMap</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;Array&lt;<a href="#26008" title="B">B</a>&gt;&gt; <a title="fj.control.parallel.Strategy[fj.data.Array[B]]" id="26066">s</a>,
                                               <span class="keyword">final</span> F&lt;<a href="#26007" title="A">A</a>, Array&lt;<a href="#26008" title="B">B</a>&gt;&gt; <a title="fj.F[A,fj.data.Array[B]]" id="26067">f</a>,
                                               <span class="keyword">final</span> Array&lt;<a href="#26007" title="A">A</a>&gt; <a title="fj.data.Array[A]" id="26068">as</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> fmap<span class="delimiter">(</span>Array.&lt;B&gt;join<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>s.parMap<span class="delimiter">(</span>f, as<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Sequentially evaluates chunks (sub-sequences) of a list in parallel. Splits the list into chunks,
   * evaluating the chunks simultaneously, but each chunk as a sequence.
   *
   * @param s           The strategy to use for parallelization.
   * @param chunkLength The length of each sequence.
   * @param as          The list to evaluate in parallel chunks.
   * @return A product-1 containing the list of results extracted from the given list of product-1s.
   */</span>
  public static &lt;<a title="Nothing" id="26011">A</a>&gt; P1&lt;List&lt;<a href="#26011" title="A">A</a>&gt;&gt; <a title="[A](s: fj.control.parallel.Strategy[fj.data.List[A]], chunkLength: Int, as: fj.data.List[fj.P1[A]])fj.P1[fj.data.List[A]]" id="26009">parListChunk</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;List&lt;<a href="#26011" title="A">A</a>&gt;&gt; <a title="fj.control.parallel.Strategy[fj.data.List[A]]" id="26073">s</a>,
                                             <span class="keyword">final</span> int <a title="Int" id="26074">chunkLength</a>,
                                             <span class="keyword">final</span> List&lt;P1&lt;<a href="#26011" title="A">A</a>&gt;&gt; <a title="fj.data.List[fj.P1[A]]" id="26075">as</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> fmap<span class="delimiter">(</span>List.&lt;A&gt;join<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>s.parList<span class="delimiter">(</span>as.partition<span class="delimiter">(</span>chunkLength<span class="delimiter">)</span>.map<span class="delimiter">(</span>P1.&lt;A&gt;sequenceList<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Zips together two lists in parallel using a given function, with this strategy.
   * Calls the given function once for each corresponding pair in the lists, position-wise,
   * passing elements from the first list to the first argument of the function, and elements from the second list
   * to the second argument of the function, yielding a list of the results.
   * If the lists are not of the same length, the remaining elements of the longer list are ignored.
   *
   * @param f  The function of arity-2 with which to zip.
   * @param bs A list to zip with the given function.
   * @param cs A list to zip with the given function.
   * @return The list of the results of calling the given function on corresponding elements of the given lists.
   */</span>
  public &lt;<a title="Nothing" id="19722">B</a>, <a title="Nothing" id="19723">C</a>&gt; P1&lt;List&lt;<a href="#9976" title="A">A</a>&gt;&gt; <a title="[B, C](f: fj.F2[B,C,A], bs: fj.data.List[B], cs: fj.data.List[C])fj.P1[fj.data.List[A]]" id="19719">parZipWith</a><span class="delimiter">(</span><span class="keyword">final</span> F2&lt;<a href="#19722" title="B">B</a>, <a href="#19723" title="C">C</a>, <a href="#9976" title="A">A</a>&gt; <a title="fj.F2[B,C,A]" id="26209">f</a>, <span class="keyword">final</span> List&lt;<a href="#19722" title="B">B</a>&gt; <a title="fj.data.List[B]" id="26210">bs</a>, <span class="keyword">final</span> List&lt;<a href="#19723" title="C">C</a>&gt; <a title="fj.data.List[C]" id="26211">cs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sequence<span class="delimiter">(</span>bs.zipWith<span class="delimiter">(</span>cs, concurry<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Zips together two arrays in parallel using a given function, with this strategy.
   * Calls the given function once for each corresponding pair in the arrays, position-wise,
   * passing elements from the first array to the first argument of the function, and elements from the second array
   * to the second argument of the function, yielding a array of the results.
   * If the arrays are not of the same length, the remaining elements of the longer array are ignored.
   *
   * @param f  The function of arity-2 with which to zip.
   * @param bs A array to zip with the given function.
   * @param cs A array to zip with the given function.
   * @return The array of the results of calling the given function on corresponding elements of the given arrays.
   */</span>
  public &lt;<a title="Nothing" id="19727">B</a>, <a title="Nothing" id="19728">C</a>&gt; P1&lt;Array&lt;<a href="#9976" title="A">A</a>&gt;&gt; <a title="[B, C](f: fj.F2[B,C,A], bs: fj.data.Array[B], cs: fj.data.Array[C])fj.P1[fj.data.Array[A]]" id="19724">parZipWith</a><span class="delimiter">(</span><span class="keyword">final</span> F2&lt;<a href="#19727" title="B">B</a>, <a href="#19728" title="C">C</a>, <a href="#9976" title="A">A</a>&gt; <a title="fj.F2[B,C,A]" id="26215">f</a>, <span class="keyword">final</span> Array&lt;<a href="#19727" title="B">B</a>&gt; <a title="fj.data.Array[B]" id="26216">bs</a>, <span class="keyword">final</span> Array&lt;<a href="#19728" title="C">C</a>&gt; <a title="fj.data.Array[C]" id="26217">cs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sequence<span class="delimiter">(</span>bs.zipWith<span class="delimiter">(</span>cs, concurry<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Lifts a given function of arity-2 so that it zips together two lists in parallel,
   * using this strategy, calling the function once for each corresponding pair in the lists, position-wise.
   *
   * @param f The function of arity-2 with which to zip.
   * @return A transformation that zips two lists using the argument function, in parallel.
   */</span>
  public &lt;<a title="Nothing" id="19732">B</a>, <a title="Nothing" id="19733">C</a>&gt; F2&lt;List&lt;<a href="#19732" title="B">B</a>&gt;, List&lt;<a href="#19733" title="C">C</a>&gt;, P1&lt;List&lt;<a href="#9976" title="A">A</a>&gt;&gt;&gt; <a title="[B, C](f: fj.F2[B,C,A])fj.F2[fj.data.List[B],fj.data.List[C],fj.P1[fj.data.List[A]]]" id="19729">parZipListWith</a><span class="delimiter">(</span><span class="keyword">final</span> F2&lt;<a href="#19732" title="B">B</a>, <a href="#19733" title="C">C</a>, <a href="#9976" title="A">A</a>&gt; <a title="fj.F2[B,C,A]" id="26221">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F2&lt;List&lt;B&gt;, List&lt;C&gt;, P1&lt;List&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public P1&lt;List&lt;A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> List&lt;B&gt; bs, <span class="keyword">final</span> List&lt;C&gt; cs<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parZipWith<span class="delimiter">(</span>f, bs, cs<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Lifts a given function of arity-2 so that it zips together two arrays in parallel,
   * using this strategy, calling the function once for each corresponding pair in the arrays, position-wise.
   *
   * @param f The function of arity-2 with which to zip.
   * @return A transformation that zips two arrays using the argument function, in parallel.
   */</span>
  public &lt;<a title="Nothing" id="19737">B</a>, <a title="Nothing" id="19738">C</a>&gt; F2&lt;Array&lt;<a href="#19737" title="B">B</a>&gt;, Array&lt;<a href="#19738" title="C">C</a>&gt;, P1&lt;Array&lt;<a href="#9976" title="A">A</a>&gt;&gt;&gt; <a title="[B, C](f: fj.F2[B,C,A])fj.F2[fj.data.Array[B],fj.data.Array[C],fj.P1[fj.data.Array[A]]]" id="19734">parZipArrayWith</a><span class="delimiter">(</span><span class="keyword">final</span> F2&lt;<a href="#19737" title="B">B</a>, <a href="#19738" title="C">C</a>, <a href="#9976" title="A">A</a>&gt; <a title="fj.F2[B,C,A]" id="26223">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F2&lt;Array&lt;B&gt;, Array&lt;C&gt;, P1&lt;Array&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public P1&lt;Array&lt;A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Array&lt;B&gt; bs, <span class="keyword">final</span> Array&lt;C&gt; cs<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parZipWith<span class="delimiter">(</span>f, bs, cs<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a function which returns a product-1 which waits for the given Future to obtain a value.
   *
   * @return A function which, given a Future, yields a product-1 that waits for it.
   */</span>
  public static &lt;<a title="Nothing" id="26014">A</a>&gt; F&lt;Future&lt;<a href="#26014" title="A">A</a>&gt;, P1&lt;<a href="#26014" title="A">A</a>&gt;&gt; <a title="[A]()fj.F[java.util.concurrent.Future[A],fj.P1[A]]" id="26012">obtain</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Future&lt;A&gt;, P1&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public P1&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Future&lt;A&gt; t<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> obtain<span class="delimiter">(</span>t<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides a product-1 that waits for the given future to obtain a value.
   *
   * @param t A Future for which to wait.
   * @return A product-1 that waits for the given future to obtain a value.
   */</span>
  public static &lt;<a title="Nothing" id="26017">A</a>&gt; P1&lt;<a href="#26017" title="A">A</a>&gt; <a title="[A](t: java.util.concurrent.Future[A])fj.P1[A]" id="26015">obtain</a><span class="delimiter">(</span><span class="keyword">final</span> Future&lt;<a href="#26017" title="A">A</a>&gt; <a title="java.util.concurrent.Future[A]" id="26081">t</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> P1&lt;A&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public A _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">try</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> t.get<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>InterruptedException e<span class="delimiter">)</span> <span class="delimiter">{</span>
          Thread.currentThread<span class="delimiter">(</span><span class="delimiter">)</span>.interrupt<span class="delimiter">(</span><span class="delimiter">)</span>;
          <span class="keyword">throw</span> <span class="keyword">new</span> Error<span class="delimiter">(</span>e<span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>ExecutionException e<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">throw</span> <span class="keyword">new</span> Error<span class="delimiter">(</span>e<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns an Effect that waits for a given Future to obtain a value, discarding the value.
   *
   * @return An effect, which, given a Future, waits for it to obtain a value, discarding the value.
   */</span>
  public static &lt;<a title="Nothing" id="26020">A</a>&gt; Effect&lt;Future&lt;<a href="#26020" title="A">A</a>&gt;&gt; <a title="[A]()fj.Effect[java.util.concurrent.Future[A]]" id="26018">discard</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> Effect&lt;Future&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public void e<span class="delimiter">(</span><span class="keyword">final</span> Future&lt;A&gt; a<span class="delimiter">)</span> <span class="delimiter">{</span>
        Strategy.&lt;A&gt;obtain<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>a<span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides a simple parallelization strategy that creates, and discards, a new thread for
   * every evaluation.
   *
   * @return a simple parallelization strategy that creates, and discards, a new thread for
   *         every evaluation.
   */</span>
  public static &lt;<a title="Nothing" id="26023">A</a>&gt; <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;<a href="#26023" title="A">A</a>&gt; <a title="[A]()fj.control.parallel.Strategy[A]" id="26021">simpleThreadStrategy</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> strategy<span class="delimiter">(</span><span class="keyword">new</span> F&lt;P1&lt;A&gt;, P1&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public P1&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> P1&lt;A&gt; p<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">final</span> FutureTask&lt;A&gt; t = <span class="keyword">new</span> FutureTask&lt;A&gt;<span class="delimiter">(</span>Java.&lt;A&gt;P1_Callable<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>p<span class="delimiter">)</span><span class="delimiter">)</span>;
        <span class="keyword">new</span> Thread<span class="delimiter">(</span>t<span class="delimiter">)</span>.start<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">return</span> obtain<span class="delimiter">(</span>t<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides a parallelization strategy that uses an ExecutorService to control the method and
   * degree of parallelism.
   *
   * @param s The ExecutorService to use for scheduling evaluations.
   * @return A Strategy that uses the provided ExecutorService to control the method and degree
   *         of parallelism.
   */</span>
  public static &lt;<a title="Nothing" id="26026">A</a>&gt; <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;<a href="#26026" title="A">A</a>&gt; <a title="[A](s: java.util.concurrent.ExecutorService)fj.control.parallel.Strategy[A]" id="26024">executorStrategy</a><span class="delimiter">(</span><span class="keyword">final</span> ExecutorService <a title="java.util.concurrent.ExecutorService" id="26086">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> strategy<span class="delimiter">(</span><span class="keyword">new</span> F&lt;P1&lt;A&gt;, P1&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public P1&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> P1&lt;A&gt; p<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> obtain<span class="delimiter">(</span>s.submit<span class="delimiter">(</span>Java.&lt;A&gt;P1_Callable<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>p<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides a parallelization strategy that uses a CompletionService to control the method and
   * degree of parallelism, and where each parallel task's completion is registered with the service.
   *
   * @param s The CompletionService to use for scheduling evaluations and detect their completion.
   * @return A Strategy that uses the provided CompletionService to control the method and degree of parallelism,
   *         and notifies the service of task completion.
   */</span>
  public static &lt;<a title="Nothing" id="26029">A</a>&gt; <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;<a href="#26029" title="A">A</a>&gt; <a title="[A](s: java.util.concurrent.CompletionService[A])fj.control.parallel.Strategy[A]" id="26027">completionStrategy</a><span class="delimiter">(</span><span class="keyword">final</span> CompletionService&lt;<a href="#26029" title="A">A</a>&gt; <a title="java.util.concurrent.CompletionService[A]" id="26148">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> strategy<span class="delimiter">(</span><span class="keyword">new</span> F&lt;P1&lt;A&gt;, P1&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public P1&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> P1&lt;A&gt; p<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> obtain<span class="delimiter">(</span>s.submit<span class="delimiter">(</span>Java.&lt;A&gt;P1_Callable<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>p<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides a strategy that performs sequential (non-concurrent) evaluation of its argument.
   *
   * @return A strategy that performs sequential (non-concurrent) evaluation of its argument.
   */</span>
  public static &lt;<a title="Nothing" id="26032">A</a>&gt; <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;<a href="#26032" title="A">A</a>&gt; <a title="[A]()fj.control.parallel.Strategy[A]" id="26030">seqStrategy</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> strategy<span class="delimiter">(</span><span class="keyword">new</span> F&lt;P1&lt;A&gt;, P1&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public P1&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> P1&lt;A&gt; a<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> P.p<span class="delimiter">(</span>a._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides a strategy that performs no evaluation of its argument.
   *
   * @return A strategy that performs no evaluation of its argument.
   */</span>
  public static &lt;<a title="Nothing" id="26035">A</a>&gt; <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;<a href="#26035" title="A">A</a>&gt; <a title="[A]()fj.control.parallel.Strategy[A]" id="26033">idStrategy</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> strategy<span class="delimiter">(</span>Function.&lt;P1&lt;A&gt;&gt;identity<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps the given bijective transformation across this strategy (Exponential Functor pattern).
   *
   * @param f A transformation from this strategy's codomain to the resulting strategy's codomain.
   * @param g A transformation from the resulting strategy's domain to this strategy's domain.
   * @return A new strategy that maps to this strategy and back again.
   */</span>
  public &lt;<a title="Nothing" id="19741">B</a>&gt; <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;<a href="#19741" title="B">B</a>&gt; <a title="[B](f: fj.F[fj.P1[A],fj.P1[B]], g: fj.F[fj.P1[B],fj.P1[A]])fj.control.parallel.Strategy[B]" id="19739">xmap</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;P1&lt;<a href="#9976" title="A">A</a>&gt;, P1&lt;<a href="#19741" title="B">B</a>&gt;&gt; <a title="fj.F[fj.P1[A],fj.P1[B]]" id="26225">f</a>, <span class="keyword">final</span> F&lt;P1&lt;<a href="#19741" title="B">B</a>&gt;, P1&lt;<a href="#9976" title="A">A</a>&gt;&gt; <a title="fj.F[fj.P1[B],fj.P1[A]]" id="26226">g</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> strategy<span class="delimiter">(</span>compose<span class="delimiter">(</span>f, compose<span class="delimiter">(</span>f<span class="delimiter">(</span><span class="delimiter">)</span>, g<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps the given transformation across this strategy's domain (Invariant Functor pattern).
   *
   * @param f A transformation from this strategy's codomain to the resulting strategy's codomain.
   * @return A new strategy that applies the given transformation after each application of this strategy.
   */</span>
  public <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;<a href="#9976" title="A">A</a>&gt; <a title="(f: fj.F[fj.P1[A],fj.P1[A]])fj.control.parallel.Strategy[A]" id="19742">map</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;P1&lt;<a href="#9976" title="A">A</a>&gt;, P1&lt;<a href="#9976" title="A">A</a>&gt;&gt; <a title="fj.F[fj.P1[A],fj.P1[A]]" id="26229">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> xmap<span class="delimiter">(</span>f, Function.&lt;P1&lt;A&gt;&gt;identity<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps the given transformation across this strategy's codomain (Invariant Functor pattern).
   *
   * @param f A transformation from the resulting strategy's domain to this strategy's domain.
   * @return A new strategy that applies the given transformation before each application of this strategy.
   */</span>
  public <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;<a href="#9976" title="A">A</a>&gt; <a title="(f: fj.F[fj.P1[A],fj.P1[A]])fj.control.parallel.Strategy[A]" id="19743">comap</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;P1&lt;<a href="#9976" title="A">A</a>&gt;, P1&lt;<a href="#9976" title="A">A</a>&gt;&gt; <a title="fj.F[fj.P1[A],fj.P1[A]]" id="26230">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> xmap<span class="delimiter">(</span>Function.&lt;P1&lt;A&gt;&gt;identity<span class="delimiter">(</span><span class="delimiter">)</span>, f<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides an error-handling strategy. Captures any uncaught runtime errors encountered by this strategy and applies
   * the given side-effect to them.
   *
   * @param e The effect that should handle errors.
   * @return A strategy that captures any runtime errors with a side-effect.
   */</span>
  public <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;<a href="#9976" title="A">A</a>&gt; <a title="(e: fj.Effect[java.lang.Error])fj.control.parallel.Strategy[A]" id="19744">errorStrategy</a><span class="delimiter">(</span><span class="keyword">final</span> Effect&lt;Error&gt; <a title="fj.Effect[java.lang.Error]" id="26231">e</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> errorStrategy<span class="delimiter">(</span><span class="keyword">this</span>, e<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides an error-handling strategy. Captures any uncaught runtime errors encountered by the given strategy
   * and applies the given side-effect to them.
   *
   * @param s The strategy to equip with an error-handling effect.
   * @param e The effect that should handle errors.
   * @return A strategy that captures any runtime errors with a side-effect.
   */</span>
  public static &lt;<a title="Nothing" id="26038">A</a>&gt; <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;<a href="#26038" title="A">A</a>&gt; <a title="[A](s: fj.control.parallel.Strategy[A], e: fj.Effect[java.lang.Error])fj.control.parallel.Strategy[A]" id="26036">errorStrategy</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;<a href="#26038" title="A">A</a>&gt; <a title="fj.control.parallel.Strategy[A]" id="26175">s</a>, <span class="keyword">final</span> Effect&lt;Error&gt; <a title="fj.Effect[java.lang.Error]" id="26176">e</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> s.comap<span class="delimiter">(</span><span class="keyword">new</span> F&lt;P1&lt;A&gt;, P1&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public P1&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> P1&lt;A&gt; a<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> P1&lt;A&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public A _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">try</span> <span class="delimiter">{</span>
              <span class="keyword">return</span> a._1<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">(</span>Throwable t<span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">final</span> Error error = <span class="keyword">new</span> Error<span class="delimiter">(</span>t<span class="delimiter">)</span>;
              e.e<span class="delimiter">(</span>error<span class="delimiter">)</span>;
              <span class="keyword">throw</span> error;
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides a normalising strategy that fully evaluates its Callable argument.
   *
   * @param s A non-normalising strategy to use for the evaluation.
   * @return A new strategy that fully evaluates Callables, using the given strategy.
   */</span>
  public static &lt;<a title="Nothing" id="26041">A</a>&gt; <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;Callable&lt;<a href="#26041" title="A">A</a>&gt;&gt; <a title="[A](s: fj.control.parallel.Strategy[java.util.concurrent.Callable[A]])fj.control.parallel.Strategy[java.util.concurrent.Callable[A]]" id="26039">callableStrategy</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;Callable&lt;<a href="#26041" title="A">A</a>&gt;&gt; <a title="fj.control.parallel.Strategy[java.util.concurrent.Callable[A]]" id="26180">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> s.comap<span class="delimiter">(</span><span class="keyword">new</span> F&lt;P1&lt;Callable&lt;A&gt;&gt;, P1&lt;Callable&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public P1&lt;Callable&lt;A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> P1&lt;Callable&lt;A&gt;&gt; a<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> P1.curry<span class="delimiter">(</span>Callables.&lt;A&gt;normalise<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>a._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>