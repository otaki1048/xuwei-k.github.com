<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>fj/control/parallel/ParModule.java</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> fj.control.parallel;

<span class="keyword">import</span> fj.Effect;
<span class="keyword">import</span> fj.F;
<span class="keyword">import</span> fj.F2;
<span class="keyword">import</span> fj.Function;
<span class="keyword">import</span> fj.Monoid;
<span class="keyword">import</span> fj.P;
<span class="keyword">import</span> fj.P1;
<span class="keyword">import</span> fj.P2;
<span class="keyword">import</span> fj.P3;
<span class="keyword">import</span> fj.P4;
<span class="keyword">import</span> fj.Unit;
<span class="keyword">import</span> static fj.P.p;
<span class="keyword">import</span> static fj.Function.curry;
<span class="keyword">import</span> static fj.Function.uncurryF2;
<span class="keyword">import</span> static fj.control.parallel.Promise.liftM2;
<span class="keyword">import</span> fj.data.Array;
<span class="keyword">import</span> fj.data.IterableW;
<span class="keyword">import</span> fj.data.List;
<span class="keyword">import</span> fj.data.NonEmptyList;
<span class="keyword">import</span> fj.data.Option;
<span class="keyword">import</span> fj.data.Stream;
<span class="keyword">import</span> fj.data.Tree;
<span class="keyword">import</span> fj.data.TreeZipper;
<span class="keyword">import</span> fj.data.Zipper;
<span class="keyword">import</span> static fj.data.Option.some;
<span class="keyword">import</span> static fj.data.Stream.iterableStream;

<span class="comment">/**
 * A module of higher-order concurrency features.
 */</span>
public <span class="keyword">final</span> <span class="keyword">class</span> <a title="object fj.control.parallel.ParModule" id="9923">ParModule</a> <span class="delimiter">{</span>
  <span class="keyword">private</span> <span class="keyword">final</span> Strategy&lt;Unit&gt; strategy;

  <span class="keyword">private</span> ParModule<span class="delimiter">(</span><span class="keyword">final</span> Strategy&lt;Unit&gt; strategy<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">this</span>.strategy = strategy;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Constructor method for ParModule
   *
   * @param u A parallel strategy for the module.
   * @return A ParModule that uses the given strategy for parallelism.
   */</span>
  public static <a href="#9923" title="fj.control.parallel.ParModule">ParModule</a> <a title="(u: fj.control.parallel.Strategy[fj.Unit])fj.control.parallel.ParModule" id="25774">parModule</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="Strategy.java.html#9975" title="fj.control.parallel.Strategy">Strategy</a>&lt;Unit&gt; <a title="fj.control.parallel.Strategy[fj.Unit]" id="25775">u</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> ParModule<span class="delimiter">(</span>u<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Evaluates the given product concurrently and returns a Promise of the result.
   *
   * @param p A product to evaluate concurrently.
   * @return A Promise of the value of the given product, that can be claimed in the future.
   */</span>
  public &lt;A&gt; Promise&lt;A&gt; promise<span class="delimiter">(</span><span class="keyword">final</span> P1&lt;A&gt; p<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> Promise.promise<span class="delimiter">(</span>strategy, p<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a function that evaluates a given product concurrently and returns a Promise of the result.
   *
   * @return a function that evaluates a given product concurrently and returns a Promise of the result.
   */</span>
  public &lt;A&gt; F&lt;P1&lt;A&gt;, Promise&lt;A&gt;&gt; promise<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;P1&lt;A&gt;, Promise&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Promise&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> P1&lt;A&gt; ap1<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> promise<span class="delimiter">(</span>ap1<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Promotes the given function to a concurrent function that returns a Promise.
   *
   * @param f A given function to promote to a concurrent function.
   * @return A function that is applied concurrently when given an argument, yielding a Promise of the result
   *         that can be claimed in the future.
   */</span>
  public &lt;A, B&gt; F&lt;A, Promise&lt;B&gt;&gt; promise<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> f.promiseK<span class="delimiter">(</span>strategy<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a function that promotes a given function to a concurrent function that returns a Promise.
   * The pure Kleisli arrow of Promise.
   *
   * @return A higher-order function that takes pure functions to promise-valued functions.
   */</span>
  public &lt;A, B&gt; F&lt;F&lt;A, B&gt;, F&lt;A, Promise&lt;B&gt;&gt;&gt; promisePure<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;F&lt;A, B&gt;, F&lt;A, Promise&lt;B&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public F&lt;A, Promise&lt;B&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, B&gt; abf<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> promise<span class="delimiter">(</span>abf<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Promotes the given function to a concurrent function that returns a Promise.
   *
   * @param f A given function to promote to a concurrent function.
   * @return A function that is applied concurrently when given an argument, yielding a Promise of the result
   *         that can be claimed in the future.
   */</span>
  public &lt;A, B, C&gt; F2&lt;A, B, Promise&lt;C&gt;&gt; promise<span class="delimiter">(</span><span class="keyword">final</span> F2&lt;A, B, C&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> P2.untuple<span class="delimiter">(</span>f.tuple<span class="delimiter">(</span><span class="delimiter">)</span>.promiseK<span class="delimiter">(</span>strategy<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>


  <span class="comment">/**
   * Creates a very fast concurrent effect, as an actor that does not guarantee ordering of its messages.
   * Such an actor is not thread-safe unless the given Effect is.
   *
   * @param e The effect that the actor should have on its messages.
   * @return A concurrent actor that does not guarantee ordering of its messages.
   */</span>
  public &lt;A&gt; Actor&lt;A&gt; effect<span class="delimiter">(</span><span class="keyword">final</span> Effect&lt;A&gt; e<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> Actor.actor<span class="delimiter">(</span>strategy, e<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A first-class constructor of concurrent effects, as actors that don't guarantee ordering of messages.
   * Such an actor is not thread-safe unless the given Effect is.
   *
   * @return A function that takes an effect and returns a concurrent effect.
   */</span>
  public &lt;A&gt; F&lt;Effect&lt;A&gt;, Actor&lt;A&gt;&gt; effect<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Effect&lt;A&gt;, Actor&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Actor&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Effect&lt;A&gt; effect<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> effect<span class="delimiter">(</span>effect<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Creates a concurrent actor that is guaranteed to process only one message at a time.
   *
   * @param e The effect that the actor should have on its messages.
   * @return A concurrent actor that is guaranteed to process its messages in order.
   */</span>
  public &lt;A&gt; Actor&lt;A&gt; actor<span class="delimiter">(</span><span class="keyword">final</span> Effect&lt;A&gt; e<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> Actor.queueActor<span class="delimiter">(</span>strategy, e<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A first-class constructor of actors.
   *
   * @return A function that takes an effect and returns an actor that processes messages in some order.
   */</span>
  public &lt;A&gt; F&lt;Effect&lt;A&gt;, Actor&lt;A&gt;&gt; actor<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Effect&lt;A&gt;, Actor&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Actor&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Effect&lt;A&gt; effect<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> actor<span class="delimiter">(</span>effect<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * List iteration inside a Promise. Traverses a List of Promises yielding a Promise of a List.
   *
   * @param ps A list of promises to sequence.
   * @return A promise of the List of values promised by the list of promises.
   */</span>
  public &lt;A&gt; Promise&lt;List&lt;A&gt;&gt; sequence<span class="delimiter">(</span><span class="keyword">final</span> List&lt;Promise&lt;A&gt;&gt; ps<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> Promise.sequence<span class="delimiter">(</span>strategy, ps<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A first-class function that traverses a list inside a promise.
   *
   * @return A first-class function that traverses a list inside a promise.
   */</span>
  public &lt;A&gt; F&lt;List&lt;Promise&lt;A&gt;&gt;, Promise&lt;List&lt;A&gt;&gt;&gt; sequenceList<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;List&lt;Promise&lt;A&gt;&gt;, Promise&lt;List&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Promise&lt;List&lt;A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> List&lt;Promise&lt;A&gt;&gt; list<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> sequence<span class="delimiter">(</span>list<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Stream iteration inside a Promise. Traverses a Stream of Promises yielding a Promise of a Stream.
   *
   * @param ps A Stream of promises to sequence.
   * @return A promise of the Stream of values promised by the Stream of promises.
   */</span>
  public &lt;A&gt; Promise&lt;Stream&lt;A&gt;&gt; sequence<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;Promise&lt;A&gt;&gt; ps<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> Promise.sequence<span class="delimiter">(</span>strategy, ps<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A first-class function that traverses a stream inside a promise.
   *
   * @return A first-class function that traverses a stream inside a promise.
   */</span>
  public &lt;A&gt; F&lt;Stream&lt;Promise&lt;A&gt;&gt;, Promise&lt;Stream&lt;A&gt;&gt;&gt; sequenceStream<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Stream&lt;Promise&lt;A&gt;&gt;, Promise&lt;Stream&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Promise&lt;Stream&lt;A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;Promise&lt;A&gt;&gt; stream<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> sequence<span class="delimiter">(</span>stream<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Traverses a product-1 inside a promise.
   *
   * @param p A product-1 of a promised value.
   * @return A promise of a product of the value promised by the argument.
   */</span>
  public &lt;A&gt; Promise&lt;P1&lt;A&gt;&gt; sequence<span class="delimiter">(</span><span class="keyword">final</span> P1&lt;Promise&lt;A&gt;&gt; p<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> Promise.sequence<span class="delimiter">(</span>strategy, p<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Takes a Promise-valued function and applies it to each element
   * in the given List, yielding a promise of a List of results.
   *
   * @param as A list to map across.
   * @param f  A promise-valued function to map across the list.
   * @return A Promise of a new list with the given function applied to each element.
   */</span>
  public &lt;A, B&gt; Promise&lt;List&lt;B&gt;&gt; mapM<span class="delimiter">(</span><span class="keyword">final</span> List&lt;A&gt; as, <span class="keyword">final</span> F&lt;A, Promise&lt;B&gt;&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sequence<span class="delimiter">(</span>as.map<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * First-class function that maps a concurrent function over a List inside a promise.
   *
   * @return a function that maps a concurrent function over a List inside a promise.
   */</span>
  public &lt;A, B&gt; F&lt;F&lt;A, Promise&lt;B&gt;&gt;, F&lt;List&lt;A&gt;, Promise&lt;List&lt;B&gt;&gt;&gt;&gt; mapList<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> curry<span class="delimiter">(</span><span class="keyword">new</span> F2&lt;F&lt;A, Promise&lt;B&gt;&gt;, List&lt;A&gt;, Promise&lt;List&lt;B&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Promise&lt;List&lt;B&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, Promise&lt;B&gt;&gt; f, <span class="keyword">final</span> List&lt;A&gt; list<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> mapM<span class="delimiter">(</span>list, f<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Takes a Promise-valued function and applies it to each element
   * in the given Stream, yielding a promise of a Stream of results.
   *
   * @param as A Stream to map across.
   * @param f  A promise-valued function to map across the Stream.
   * @return A Promise of a new Stream with the given function applied to each element.
   */</span>
  public &lt;A, B&gt; Promise&lt;Stream&lt;B&gt;&gt; mapM<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;A&gt; as, <span class="keyword">final</span> F&lt;A, Promise&lt;B&gt;&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sequence<span class="delimiter">(</span>as.map<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * First-class function that maps a concurrent function over a Stream inside a promise.
   *
   * @return a function that maps a concurrent function over a Stream inside a promise.
   */</span>
  public &lt;A, B&gt; F&lt;F&lt;A, Promise&lt;B&gt;&gt;, F&lt;Stream&lt;A&gt;, Promise&lt;Stream&lt;B&gt;&gt;&gt;&gt; mapStream<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> curry<span class="delimiter">(</span><span class="keyword">new</span> F2&lt;F&lt;A, Promise&lt;B&gt;&gt;, Stream&lt;A&gt;, Promise&lt;Stream&lt;B&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Promise&lt;Stream&lt;B&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, Promise&lt;B&gt;&gt; f, <span class="keyword">final</span> Stream&lt;A&gt; stream<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> mapM<span class="delimiter">(</span>stream, f<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps a concurrent function over a Product-1 inside a Promise.
   *
   * @param a A product-1 across which to map.
   * @param f A concurrent function to map over the product inside a promise.
   * @return A promised product of the result of mapping the given function over the given product.
   */</span>
  public &lt;A, B&gt; Promise&lt;P1&lt;B&gt;&gt; mapM<span class="delimiter">(</span><span class="keyword">final</span> P1&lt;A&gt; a, <span class="keyword">final</span> F&lt;A, Promise&lt;B&gt;&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sequence<span class="delimiter">(</span>a.map<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps across a list in parallel.
   *
   * @param as A list to map across in parallel.
   * @param f  A function to map across the given list.
   * @return A Promise of a new list with the given function applied to each element.
   */</span>
  public &lt;A, B&gt; Promise&lt;List&lt;B&gt;&gt; parMap<span class="delimiter">(</span><span class="keyword">final</span> List&lt;A&gt; as, <span class="keyword">final</span> F&lt;A, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> mapM<span class="delimiter">(</span>as, promise<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A first-class function that maps another function across a list in parallel.
   *
   * @return A function that maps another function across a list in parallel.
   */</span>
  public &lt;A, B&gt; F&lt;F&lt;A, B&gt;, F&lt;List&lt;A&gt;, Promise&lt;List&lt;B&gt;&gt;&gt;&gt; parMapList<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> curry<span class="delimiter">(</span><span class="keyword">new</span> F2&lt;F&lt;A, B&gt;, List&lt;A&gt;, Promise&lt;List&lt;B&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Promise&lt;List&lt;B&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, B&gt; abf, <span class="keyword">final</span> List&lt;A&gt; list<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parMap<span class="delimiter">(</span>list, abf<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps across a nonempty list in parallel.
   *
   * @param as A NonEmptyList to map across in parallel.
   * @param f  A function to map across the given NonEmptyList.
   * @return A Promise of a new NonEmptyList with the given function applied to each element.
   */</span>
  public &lt;A, B&gt; Promise&lt;NonEmptyList&lt;B&gt;&gt; parMap<span class="delimiter">(</span><span class="keyword">final</span> NonEmptyList&lt;A&gt; as, <span class="keyword">final</span> F&lt;A, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> mapM<span class="delimiter">(</span>as.toList<span class="delimiter">(</span><span class="delimiter">)</span>, promise<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>.fmap<span class="delimiter">(</span><span class="keyword">new</span> F&lt;List&lt;B&gt;, NonEmptyList&lt;B&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public NonEmptyList&lt;B&gt; f<span class="delimiter">(</span><span class="keyword">final</span> List&lt;B&gt; list<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> NonEmptyList.fromList<span class="delimiter">(</span>list<span class="delimiter">)</span>.some<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps across a Stream in parallel.
   *
   * @param as A Stream to map across in parallel.
   * @param f  A function to map across the given Stream.
   * @return A Promise of a new Stream with the given function applied to each element.
   */</span>
  public &lt;A, B&gt; Promise&lt;Stream&lt;B&gt;&gt; parMap<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;A&gt; as, <span class="keyword">final</span> F&lt;A, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> mapM<span class="delimiter">(</span>as, promise<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A first-class function that maps another function across a stream in parallel.
   *
   * @return A function that maps another function across a stream in parallel.
   */</span>
  public &lt;A, B&gt; F&lt;F&lt;A, B&gt;, F&lt;Stream&lt;A&gt;, Promise&lt;Stream&lt;B&gt;&gt;&gt;&gt; parMapStream<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> curry<span class="delimiter">(</span><span class="keyword">new</span> F2&lt;F&lt;A, B&gt;, Stream&lt;A&gt;, Promise&lt;Stream&lt;B&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Promise&lt;Stream&lt;B&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, B&gt; abf, <span class="keyword">final</span> Stream&lt;A&gt; stream<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parMap<span class="delimiter">(</span>stream, abf<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps across an Iterable in parallel.
   *
   * @param as An Iterable to map across in parallel.
   * @param f  A function to map across the given Iterable.
   * @return A Promise of a new Iterable with the given function applied to each element.
   */</span>
  public &lt;A, B&gt; Promise&lt;Iterable&lt;B&gt;&gt; parMap<span class="delimiter">(</span><span class="keyword">final</span> Iterable&lt;A&gt; as, <span class="keyword">final</span> F&lt;A, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parMap<span class="delimiter">(</span>iterableStream<span class="delimiter">(</span>as<span class="delimiter">)</span>, f<span class="delimiter">)</span>
        .fmap<span class="delimiter">(</span>Function.&lt;Stream&lt;B&gt;, Iterable&lt;B&gt;&gt;vary<span class="delimiter">(</span>Function.&lt;Stream&lt;B&gt;&gt;identity<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A first-class function that maps another function across an iterable in parallel.
   *
   * @return A function that maps another function across an iterable in parallel.
   */</span>
  public &lt;A, B&gt; F&lt;F&lt;A, B&gt;, F&lt;Iterable&lt;A&gt;, Promise&lt;Iterable&lt;B&gt;&gt;&gt;&gt; parMapIterable<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> curry<span class="delimiter">(</span><span class="keyword">new</span> F2&lt;F&lt;A, B&gt;, Iterable&lt;A&gt;, Promise&lt;Iterable&lt;B&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Promise&lt;Iterable&lt;B&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, B&gt; abf, <span class="keyword">final</span> Iterable&lt;A&gt; iterable<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parMap<span class="delimiter">(</span>iterable, abf<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps across an Array in parallel.
   *
   * @param as An array to map across in parallel.
   * @param f  A function to map across the given Array.
   * @return A Promise of a new Array with the given function applied to each element.
   */</span>
  public &lt;A, B&gt; Promise&lt;Array&lt;B&gt;&gt; parMap<span class="delimiter">(</span><span class="keyword">final</span> Array&lt;A&gt; as, <span class="keyword">final</span> F&lt;A, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parMap<span class="delimiter">(</span>as.toStream<span class="delimiter">(</span><span class="delimiter">)</span>, f<span class="delimiter">)</span>.fmap<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Stream&lt;B&gt;, Array&lt;B&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Array&lt;B&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;B&gt; stream<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> stream.toArray<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A first-class function that maps another function across an array in parallel.
   *
   * @return A function that maps another function across an array in parallel.
   */</span>
  public &lt;A, B&gt; F&lt;F&lt;A, B&gt;, F&lt;Array&lt;A&gt;, Promise&lt;Array&lt;B&gt;&gt;&gt;&gt; parMapArray<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> curry<span class="delimiter">(</span><span class="keyword">new</span> F2&lt;F&lt;A, B&gt;, Array&lt;A&gt;, Promise&lt;Array&lt;B&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Promise&lt;Array&lt;B&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, B&gt; abf, <span class="keyword">final</span> Array&lt;A&gt; array<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parMap<span class="delimiter">(</span>array, abf<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps a function across a Zipper in parallel.
   *
   * @param za A Zipper to map across in parallel.
   * @param f  A function to map across the given Zipper.
   * @return A promise of a new Zipper with the given function applied to each element.
   */</span>
  public &lt;A, B&gt; Promise&lt;Zipper&lt;B&gt;&gt; parMap<span class="delimiter">(</span><span class="keyword">final</span> Zipper&lt;A&gt; za, <span class="keyword">final</span> F&lt;A, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parMap<span class="delimiter">(</span>za.rights<span class="delimiter">(</span><span class="delimiter">)</span>, f<span class="delimiter">)</span>
        .apply<span class="delimiter">(</span>promise<span class="delimiter">(</span>f<span class="delimiter">)</span>.f<span class="delimiter">(</span>za.focus<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.apply<span class="delimiter">(</span>parMap<span class="delimiter">(</span>za.lefts<span class="delimiter">(</span><span class="delimiter">)</span>, f<span class="delimiter">)</span>.fmap<span class="delimiter">(</span>curry<span class="delimiter">(</span>Zipper.&lt;B&gt;zipper<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps a function across a Tree in parallel.
   *
   * @param ta A Tree to map across in parallel.
   * @param f  A function to map across the given Tree.
   * @return A promise of a new Tree with the given function applied to each element.
   */</span>
  public &lt;A, B&gt; Promise&lt;Tree&lt;B&gt;&gt; parMap<span class="delimiter">(</span><span class="keyword">final</span> Tree&lt;A&gt; ta, <span class="keyword">final</span> F&lt;A, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> mapM<span class="delimiter">(</span>ta.subForest<span class="delimiter">(</span><span class="delimiter">)</span>, <span class="keyword">this</span>.&lt;Tree&lt;A&gt;, Tree&lt;B&gt;&gt;mapStream<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span><span class="keyword">this</span>.&lt;A, B&gt;parMapTree<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        .apply<span class="delimiter">(</span>promise<span class="delimiter">(</span>f<span class="delimiter">)</span>.f<span class="delimiter">(</span>ta.root<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.fmap<span class="delimiter">(</span>Tree.&lt;B&gt;node<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A first-class function that maps across a Tree in parallel.
   *
   * @return A function that maps a given function across a Tree in parallel.
   */</span>
  public &lt;A, B&gt; F&lt;F&lt;A, B&gt;, F&lt;Tree&lt;A&gt;, Promise&lt;Tree&lt;B&gt;&gt;&gt;&gt; parMapTree<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> curry<span class="delimiter">(</span><span class="keyword">new</span> F2&lt;F&lt;A, B&gt;, Tree&lt;A&gt;, Promise&lt;Tree&lt;B&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Promise&lt;Tree&lt;B&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, B&gt; abf, <span class="keyword">final</span> Tree&lt;A&gt; tree<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parMap<span class="delimiter">(</span>tree, abf<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps a function across a TreeZipper in parallel.
   *
   * @param za A TreeZipper to map across in parallel.
   * @param f  A function to map across the given TreeZipper.
   * @return A promise of a new TreeZipper with the given function applied to each element of the tree.
   */</span>
  public &lt;A, B&gt; Promise&lt;TreeZipper&lt;B&gt;&gt; parMap<span class="delimiter">(</span><span class="keyword">final</span> TreeZipper&lt;A&gt; za, <span class="keyword">final</span> F&lt;A, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> F&lt;Tree&lt;A&gt;, Tree&lt;B&gt;&gt; tf = Tree.&lt;A, B&gt;fmap_<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>f<span class="delimiter">)</span>;
    <span class="keyword">final</span> P4&lt;Tree&lt;A&gt;, Stream&lt;Tree&lt;A&gt;&gt;, Stream&lt;Tree&lt;A&gt;&gt;, Stream&lt;P3&lt;Stream&lt;Tree&lt;A&gt;&gt;, A, Stream&lt;Tree&lt;A&gt;&gt;&gt;&gt;&gt; p = za.p<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="keyword">return</span> mapM<span class="delimiter">(</span>p._4<span class="delimiter">(</span><span class="delimiter">)</span>,
                <span class="keyword">new</span> F&lt;P3&lt;Stream&lt;Tree&lt;A&gt;&gt;, A, Stream&lt;Tree&lt;A&gt;&gt;&gt;, Promise&lt;P3&lt;Stream&lt;Tree&lt;B&gt;&gt;, B, Stream&lt;Tree&lt;B&gt;&gt;&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                  public Promise&lt;P3&lt;Stream&lt;Tree&lt;B&gt;&gt;, B, Stream&lt;Tree&lt;B&gt;&gt;&gt;&gt; f<span class="delimiter">(</span>
                      <span class="keyword">final</span> P3&lt;Stream&lt;Tree&lt;A&gt;&gt;, A, Stream&lt;Tree&lt;A&gt;&gt;&gt; p3<span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">return</span> parMap<span class="delimiter">(</span>p3._3<span class="delimiter">(</span><span class="delimiter">)</span>, tf<span class="delimiter">)</span>.apply<span class="delimiter">(</span>promise<span class="delimiter">(</span>f<span class="delimiter">)</span>.f<span class="delimiter">(</span>p3._2<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.apply<span class="delimiter">(</span>
                        parMap<span class="delimiter">(</span>p3._1<span class="delimiter">(</span><span class="delimiter">)</span>, tf<span class="delimiter">)</span>.fmap<span class="delimiter">(</span>P.&lt;Stream&lt;Tree&lt;B&gt;&gt;, B, Stream&lt;Tree&lt;B&gt;&gt;&gt;p3<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
                  <span class="delimiter">}</span>
                <span class="delimiter">}</span><span class="delimiter">)</span>.apply<span class="delimiter">(</span>parMap<span class="delimiter">(</span>za.rights<span class="delimiter">(</span><span class="delimiter">)</span>, tf<span class="delimiter">)</span>.apply<span class="delimiter">(</span>
        parMap<span class="delimiter">(</span>za.lefts<span class="delimiter">(</span><span class="delimiter">)</span>, tf<span class="delimiter">)</span>.apply<span class="delimiter">(</span>parMap<span class="delimiter">(</span>p._1<span class="delimiter">(</span><span class="delimiter">)</span>, f<span class="delimiter">)</span>.fmap<span class="delimiter">(</span>TreeZipper.&lt;B&gt;treeZipper<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds a list-valued function across a list in parallel, concatenating the results into a new list.
   *
   * @param as A list to bind across in parallel.
   * @param f  A function to bind across the given list in parallel.
   * @return A promise of a new List with the given function bound across its elements.
   */</span>
  public &lt;A, B&gt; Promise&lt;List&lt;B&gt;&gt; parFlatMap<span class="delimiter">(</span><span class="keyword">final</span> List&lt;A&gt; as, <span class="keyword">final</span> F&lt;A, List&lt;B&gt;&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parFoldMap<span class="delimiter">(</span>as, f, Monoid.&lt;B&gt;listMonoid<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds a Stream-valued function across a Stream in parallel, concatenating the results into a new Stream.
   *
   * @param as A Stream to bind across in parallel.
   * @param f  A function to bind across the given Stream in parallel.
   * @return A promise of a new Stream with the given function bound across its elements.
   */</span>
  public &lt;A, B&gt; Promise&lt;Stream&lt;B&gt;&gt; parFlatMap<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;A&gt; as, <span class="keyword">final</span> F&lt;A, Stream&lt;B&gt;&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parFoldMap<span class="delimiter">(</span>as, f, Monoid.&lt;B&gt;streamMonoid<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds an Array-valued function across an Array in parallel, concatenating the results into a new Array.
   *
   * @param as An Array to bind across in parallel.
   * @param f  A function to bind across the given Array in parallel.
   * @return A promise of a new Array with the given function bound across its elements.
   */</span>
  public &lt;A, B&gt; Promise&lt;Array&lt;B&gt;&gt; parFlatMap<span class="delimiter">(</span><span class="keyword">final</span> Array&lt;A&gt; as, <span class="keyword">final</span> F&lt;A, Array&lt;B&gt;&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parMap<span class="delimiter">(</span>as, f<span class="delimiter">)</span>.fmap<span class="delimiter">(</span>Array.&lt;B&gt;join<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds an Iterable-valued function across an Iterable in parallel, concatenating the results into a new Iterable.
   *
   * @param as A Iterable to bind across in parallel.
   * @param f  A function to bind across the given Iterable in parallel.
   * @return A promise of a new Iterable with the given function bound across its elements.
   */</span>
  public &lt;A, B&gt; Promise&lt;Iterable&lt;B&gt;&gt; parFlatMap<span class="delimiter">(</span><span class="keyword">final</span> Iterable&lt;A&gt; as, <span class="keyword">final</span> F&lt;A, Iterable&lt;B&gt;&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parMap<span class="delimiter">(</span>as, f<span class="delimiter">)</span>.fmap<span class="delimiter">(</span>IterableW.&lt;B, Iterable&lt;B&gt;&gt;join<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
        .fmap<span class="delimiter">(</span>Function.&lt;IterableW&lt;B&gt;, Iterable&lt;B&gt;&gt;vary<span class="delimiter">(</span>Function.&lt;Iterable&lt;B&gt;&gt;identity<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Zips two lists together with a given function, in parallel.
   *
   * @param as A list to zip with another in parallel.
   * @param bs A list to zip with another in parallel.
   * @param f  A function with which to zip two lists in parallel.
   * @return A Promise of a new list with the results of applying the given function across the two lists in lockstep.
   */</span>
  public &lt;A, B, C&gt; Promise&lt;List&lt;C&gt;&gt; parZipWith<span class="delimiter">(</span><span class="keyword">final</span> List&lt;A&gt; as, <span class="keyword">final</span> List&lt;B&gt; bs, <span class="keyword">final</span> F&lt;A, F&lt;B, C&gt;&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sequence<span class="delimiter">(</span>as.&lt;B, Promise&lt;C&gt;&gt;zipWith<span class="delimiter">(</span>bs, promise<span class="delimiter">(</span>uncurryF2<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Zips two streams together with a given function, in parallel.
   *
   * @param as A stream to zip with another in parallel.
   * @param bs A stream to zip with another in parallel.
   * @param f  A function with which to zip two streams in parallel.
   * @return A Promise of a new stream with the results of applying the given function across the two streams, stepwise.
   */</span>
  public &lt;A, B, C&gt; Promise&lt;Stream&lt;C&gt;&gt; parZipWith<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;A&gt; as, <span class="keyword">final</span> Stream&lt;B&gt; bs, <span class="keyword">final</span> F&lt;A, F&lt;B, C&gt;&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sequence<span class="delimiter">(</span>as.&lt;B, Promise&lt;C&gt;&gt;zipWith<span class="delimiter">(</span>bs, promise<span class="delimiter">(</span>uncurryF2<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Zips two arrays together with a given function, in parallel.
   *
   * @param as An array to zip with another in parallel.
   * @param bs An array to zip with another in parallel.
   * @param f  A function with which to zip two arrays in parallel.
   * @return A Promise of a new array with the results of applying the given function across the two arrays, stepwise.
   */</span>
  public &lt;A, B, C&gt; Promise&lt;Array&lt;C&gt;&gt; parZipWith<span class="delimiter">(</span><span class="keyword">final</span> Array&lt;A&gt; as, <span class="keyword">final</span> Array&lt;B&gt; bs, <span class="keyword">final</span> F&lt;A, F&lt;B, C&gt;&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parZipWith<span class="delimiter">(</span>as.toStream<span class="delimiter">(</span><span class="delimiter">)</span>, bs.toStream<span class="delimiter">(</span><span class="delimiter">)</span>, f<span class="delimiter">)</span>.fmap<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Stream&lt;C&gt;, Array&lt;C&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Array&lt;C&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;C&gt; stream<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> stream.toArray<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Zips two iterables together with a given function, in parallel.
   *
   * @param as An iterable to zip with another in parallel.
   * @param bs An iterable to zip with another in parallel.
   * @param f  A function with which to zip two iterables in parallel.
   * @return A Promise of a new iterable with the results of applying the given function across the two iterables, stepwise.
   */</span>
  public &lt;A, B, C&gt; Promise&lt;Iterable&lt;C&gt;&gt; parZipWith<span class="delimiter">(</span><span class="keyword">final</span> Iterable&lt;A&gt; as, <span class="keyword">final</span> Iterable&lt;B&gt; bs, <span class="keyword">final</span> F&lt;A, F&lt;B, C&gt;&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parZipWith<span class="delimiter">(</span>iterableStream<span class="delimiter">(</span>as<span class="delimiter">)</span>, iterableStream<span class="delimiter">(</span>bs<span class="delimiter">)</span>, f<span class="delimiter">)</span>.fmap<span class="delimiter">(</span>
        Function.&lt;Stream&lt;C&gt;, Iterable&lt;C&gt;&gt;vary<span class="delimiter">(</span>Function.&lt;Iterable&lt;C&gt;&gt;identity<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps with the given function across the given stream in parallel, while folding with
   * the given monoid.
   *
   * @param as     A stream to map over and reduce.
   * @param map    The function to map over the given stream.
   * @param reduce The monoid with which to sum the results.
   * @return A promise of a result of mapping and folding in parallel.
   */</span>
  public &lt;A, B&gt; Promise&lt;B&gt; parFoldMap<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;A&gt; as, <span class="keyword">final</span> F&lt;A, B&gt; map, <span class="keyword">final</span> Monoid&lt;B&gt; reduce<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> as.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? promise<span class="delimiter">(</span>p<span class="delimiter">(</span>reduce.zero<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> : as.map<span class="delimiter">(</span>promise<span class="delimiter">(</span>map<span class="delimiter">)</span><span class="delimiter">)</span>.foldLeft1<span class="delimiter">(</span>liftM2<span class="delimiter">(</span>reduce.sum<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps with the given function across chunks of the given stream in parallel, while folding with
   * the given monoid. The stream is split into chunks according to the given chunking function,
   * the given map function is mapped over all chunks simultaneously, but over each chunk sequentially.
   * All chunks are summed concurrently and the sums are then summed sequentially.
   *
   * @param as       A stream to chunk, then map over and reduce.
   * @param map      The function to map over the given stream.
   * @param reduce   The monoid with which to sum the results.
   * @param chunking A function describing how the stream should be split into chunks. Should return the first chunk
   *                 and the rest of the stream.
   * @return A promise of a result of mapping and folding in parallel.
   */</span>
  public &lt;A, B&gt; Promise&lt;B&gt; parFoldMap<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;A&gt; as, <span class="keyword">final</span> F&lt;A, B&gt; map, <span class="keyword">final</span> Monoid&lt;B&gt; reduce,
                                      <span class="keyword">final</span> F&lt;Stream&lt;A&gt;, P2&lt;Stream&lt;A&gt;, Stream&lt;A&gt;&gt;&gt; chunking<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parMap<span class="delimiter">(</span>Stream.unfold<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Stream&lt;A&gt;, Option&lt;P2&lt;Stream&lt;A&gt;, Stream&lt;A&gt;&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Option&lt;P2&lt;Stream&lt;A&gt;, Stream&lt;A&gt;&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;A&gt; stream<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> stream.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? Option.&lt;P2&lt;Stream&lt;A&gt;, Stream&lt;A&gt;&gt;&gt;none<span class="delimiter">(</span><span class="delimiter">)</span> : some<span class="delimiter">(</span>chunking.f<span class="delimiter">(</span>stream<span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>, as<span class="delimiter">)</span>, Stream.&lt;A, B&gt;map_<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>map<span class="delimiter">)</span><span class="delimiter">)</span>.bind<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Stream&lt;Stream&lt;B&gt;&gt;, Promise&lt;B&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Promise&lt;B&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;Stream&lt;B&gt;&gt; stream<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parMap<span class="delimiter">(</span>stream, reduce.sumLeftS<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.fmap<span class="delimiter">(</span>reduce.sumLeftS<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps with the given function across chunks of the given Iterable in parallel, while folding with
   * the given monoid. The Iterable is split into chunks according to the given chunking function,
   * the given map function is mapped over all chunks simultaneously, but over each chunk sequentially.
   * All chunks are summed concurrently and the sums are then summed sequentially.
   *
   * @param as       An Iterable to chunk, then map over and reduce.
   * @param map      The function to map over the given Iterable.
   * @param reduce   The monoid with which to sum the results.
   * @param chunking A function describing how the Iterable should be split into chunks. Should return the first chunk
   *                 and the rest of the Iterable.
   * @return A promise of a result of mapping and folding in parallel.
   */</span>
  public &lt;A, B&gt; Promise&lt;B&gt; parFoldMap<span class="delimiter">(</span><span class="keyword">final</span> Iterable&lt;A&gt; as, <span class="keyword">final</span> F&lt;A, B&gt; map, <span class="keyword">final</span> Monoid&lt;B&gt; reduce,
                                      <span class="keyword">final</span> F&lt;Iterable&lt;A&gt;, P2&lt;Iterable&lt;A&gt;, Iterable&lt;A&gt;&gt;&gt; chunking<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parFoldMap<span class="delimiter">(</span>iterableStream<span class="delimiter">(</span>as<span class="delimiter">)</span>, map, reduce, <span class="keyword">new</span> F&lt;Stream&lt;A&gt;, P2&lt;Stream&lt;A&gt;, Stream&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public P2&lt;Stream&lt;A&gt;, Stream&lt;A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;A&gt; stream<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">final</span> F&lt;Iterable&lt;A&gt;, Stream&lt;A&gt;&gt; is = <span class="keyword">new</span> F&lt;Iterable&lt;A&gt;, Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Stream&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Iterable&lt;A&gt; iterable<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> iterableStream<span class="delimiter">(</span>iterable<span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>;
        <span class="keyword">return</span> chunking.f<span class="delimiter">(</span>stream<span class="delimiter">)</span>.map1<span class="delimiter">(</span>is<span class="delimiter">)</span>.map2<span class="delimiter">(</span>is<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps with the given function across the given iterable in parallel, while folding with
   * the given monoid.
   *
   * @param as     An Iterable to map over and reduce.
   * @param map    The function to map over the given Iterable.
   * @param reduce The Monoid with which to sum the results.
   * @return A promise of a result of mapping and folding in parallel.
   */</span>
  public &lt;A, B&gt; Promise&lt;B&gt; parFoldMap<span class="delimiter">(</span><span class="keyword">final</span> Iterable&lt;A&gt; as, <span class="keyword">final</span> F&lt;A, B&gt; map, <span class="keyword">final</span> Monoid&lt;B&gt; reduce<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parFoldMap<span class="delimiter">(</span>iterableStream<span class="delimiter">(</span>as<span class="delimiter">)</span>, map, reduce<span class="delimiter">)</span>;
  <span class="delimiter">}</span>


  <span class="comment">/**
   * Maps the given function across all positions of the given zipper in parallel.
   *
   * @param za A zipper to extend the given function across.
   * @param f  A function to extend across the given zipper.
   * @return A promise of a new zipper of the results of applying the given function to all positions of the given
   *         zipper.
   */</span>
  public &lt;A, B&gt; Promise&lt;Zipper&lt;B&gt;&gt; parExtend<span class="delimiter">(</span><span class="keyword">final</span> Zipper&lt;A&gt; za, <span class="keyword">final</span> F&lt;Zipper&lt;A&gt;, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parMap<span class="delimiter">(</span>za.positions<span class="delimiter">(</span><span class="delimiter">)</span>, f<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps the given function across all subtrees of the given Tree in parallel.
   *
   * @param ta A tree to extend the given function across.
   * @param f  A function to extend across the given Tree.
   * @return A promise of a new Tree of the results of applying the given function to all subtrees of the given Tree.
   */</span>
  public &lt;A, B&gt; Promise&lt;Tree&lt;B&gt;&gt; parExtend<span class="delimiter">(</span><span class="keyword">final</span> Tree&lt;A&gt; ta, <span class="keyword">final</span> F&lt;Tree&lt;A&gt;, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parMap<span class="delimiter">(</span>ta.cojoin<span class="delimiter">(</span><span class="delimiter">)</span>, f<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps the given function across all positions of the given TreeZipper in parallel.
   *
   * @param za A TreeZipper to extend the given function across.
   * @param f  A function to extend across the given TreeZipper.
   * @return A promise of a new TreeZipper of the results of applying the given function to all positions of the
   *         given TreeZipper.
   */</span>
  public &lt;A, B&gt; Promise&lt;TreeZipper&lt;B&gt;&gt; parExtend<span class="delimiter">(</span><span class="keyword">final</span> TreeZipper&lt;A&gt; za, <span class="keyword">final</span> F&lt;TreeZipper&lt;A&gt;, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parMap<span class="delimiter">(</span>za.positions<span class="delimiter">(</span><span class="delimiter">)</span>, f<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps the given function across all sublists of the given NonEmptyList in parallel.
   *
   * @param as A NonEmptyList to extend the given function across.
   * @param f  A function to extend across the given NonEmptyList
   * @return A promise of a new NonEmptyList of the results of applying the given function to all sublists of the
   *         given NonEmptyList.
   */</span>
  public &lt;A, B&gt; Promise&lt;NonEmptyList&lt;B&gt;&gt; parExtend<span class="delimiter">(</span><span class="keyword">final</span> NonEmptyList&lt;A&gt; as, <span class="keyword">final</span> F&lt;NonEmptyList&lt;A&gt;, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parMap<span class="delimiter">(</span>as.tails<span class="delimiter">(</span><span class="delimiter">)</span>, f<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>