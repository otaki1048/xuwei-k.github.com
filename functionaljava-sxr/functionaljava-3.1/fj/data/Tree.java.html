<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>fj/data/Tree.java</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> fj.data;

<span class="keyword">import</span> fj.F;
<span class="keyword">import</span> fj.F2;
<span class="keyword">import</span> fj.P;
<span class="keyword">import</span> fj.P1;
<span class="keyword">import</span> fj.P2;
<span class="keyword">import</span> <a href="../Function.java.html#9624" title="object fj.Function">static</a> fj.Function.*;
<span class="keyword">import</span> <a href="Stream.java.html#10363" title="object fj.data.Stream">static</a> fj.data.Stream.*;
<span class="keyword">import</span> fj.Monoid;
<span class="keyword">import</span> fj.Show;

<span class="keyword">import</span> java.util.Collection;
<span class="keyword">import</span> java.util.Iterator;

<span class="comment">/**
 * Provides a lazy, immutable, non-empty, multi-way tree (a rose tree).
 *
 * @version %build.number%
 */</span>
public <span class="keyword">final</span> <span class="keyword">class</span> <a title="object fj.data.Tree" id="10381">Tree</a>&lt;<a title="Nothing" id="10382">A</a>&gt; implements Iterable&lt;<a href="#10382" title="A">A</a>&gt; <span class="delimiter">{</span>
  <span class="comment">/**
   * Returns an iterator for this tree. This method exists to permit the use in a &lt;code&gt;for&lt;/code&gt;-each loop.
   *
   * @return A iterator for this tree.
   */</span>
  public Iterator&lt;<a href="#10382" title="A">A</a>&gt; <a title="()java.util.Iterator[A]" id="14789">iterator</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> flatten<span class="delimiter">(</span><span class="delimiter">)</span>.iterator<span class="delimiter">(</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">final</span> <a href="#10382" title="A">A</a> <a title="A" id="14790">root</a>;
  <span class="keyword">private</span> <span class="keyword">final</span> P1&lt;<a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#10382" title="A">A</a>&gt;&gt;&gt; <a title="fj.P1[fj.data.Stream[fj.data.Tree[A]]]" id="14791">subForest</a>;

  <span class="keyword">private</span> Tree<span class="delimiter">(</span><span class="keyword">final</span> A root, <span class="keyword">final</span> P1&lt;Stream&lt;Tree&lt;A&gt;&gt;&gt; subForest<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">this</span>.root = root;
    <span class="keyword">this</span>.subForest = subForest;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Creates a nullary tree.
   *
   * @param root The root element of the tree.
   * @return A nullary tree with the root element in it.
   */</span>
  public static &lt;<a title="Nothing" id="30686">A</a>&gt; <a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30686" title="A">A</a>&gt; <a title="[A](root: A)fj.data.Tree[A]" id="30684">leaf</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#30686" title="A">A</a> <a title="A" id="30738">root</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> node<span class="delimiter">(</span>root, Stream.&lt;Tree&lt;A&gt;&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Creates a new tree given a root and a (potentially infinite) subforest.
   *
   * @param root   The root element of the tree.
   * @param forest A stream of the tree's subtrees.
   * @return A newly sprouted tree.
   */</span>
  public static &lt;<a title="Nothing" id="30689">A</a>&gt; <a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30689" title="A">A</a>&gt; <a title="[A](root: A, forest: fj.P1[fj.data.Stream[fj.data.Tree[A]]])fj.data.Tree[A]" id="30687">node</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#30689" title="A">A</a> <a title="A" id="30741">root</a>, <span class="keyword">final</span> P1&lt;<a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30689" title="A">A</a>&gt;&gt;&gt; <a title="fj.P1[fj.data.Stream[fj.data.Tree[A]]]" id="30742">forest</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> Tree&lt;A&gt;<span class="delimiter">(</span>root, forest<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Creates a new tree given a root and a (potentially infinite) subforest.
   *
   * @param root   The root element of the tree.
   * @param forest A stream of the tree's subtrees.
   * @return A newly sprouted tree.
   */</span>
  public static &lt;<a title="Nothing" id="30692">A</a>&gt; <a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30692" title="A">A</a>&gt; <a title="[A](root: A, forest: fj.data.Stream[fj.data.Tree[A]])fj.data.Tree[A]" id="30690">node</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#30692" title="A">A</a> <a title="A" id="30746">root</a>, <span class="keyword">final</span> <a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30692" title="A">A</a>&gt;&gt; <a title="fj.data.Stream[fj.data.Tree[A]]" id="30747">forest</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> Tree&lt;A&gt;<span class="delimiter">(</span>root, P.p<span class="delimiter">(</span>forest<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Creates a new n-ary given a root and a subforest of length n.
   *
   * @param root   The root element of the tree.
   * @param forest A list of the tree's subtrees.
   * @return A newly sprouted tree.
   */</span>
  public static &lt;<a title="Nothing" id="30695">A</a>&gt; <a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30695" title="A">A</a>&gt; <a title="[A](root: A, forest: fj.data.List[fj.data.Tree[A]])fj.data.Tree[A]" id="30693">node</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#30695" title="A">A</a> <a title="A" id="30751">root</a>, <span class="keyword">final</span> <a href="List.java.html#10232" title="fj.data.List">List</a>&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30695" title="A">A</a>&gt;&gt; <a title="fj.data.List[fj.data.Tree[A]]" id="30752">forest</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> node<span class="delimiter">(</span>root, forest.toStream<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * First-class constructor of trees.
   *
   * @return A function that constructs an n-ary tree given a root and a subforest or length n.
   */</span>
  public static &lt;<a title="Nothing" id="30698">A</a>&gt; F&lt;<a href="#30698" title="A">A</a>, F&lt;P1&lt;<a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30698" title="A">A</a>&gt;&gt;&gt;, <a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30698" title="A">A</a>&gt;&gt;&gt; <a title="[A]()fj.F[A,fj.F[fj.P1[fj.data.Stream[fj.data.Tree[A]]],fj.data.Tree[A]]]" id="30696">node</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> curry<span class="delimiter">(</span><span class="keyword">new</span> F2&lt;A, P1&lt;Stream&lt;Tree&lt;A&gt;&gt;&gt;, Tree&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Tree&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> A a, <span class="keyword">final</span> P1&lt;Stream&lt;Tree&lt;A&gt;&gt;&gt; p1<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> node<span class="delimiter">(</span>a, p1<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns the root element of the tree.
   *
   * @return The root element of the tree.
   */</span>
  public <a href="#10382" title="A">A</a> <a title="()A" id="14793">root</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> root;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a stream of the tree's subtrees.
   *
   * @return A stream of the tree's subtrees.
   */</span>
  public P1&lt;<a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#10382" title="A">A</a>&gt;&gt;&gt; <a title="()fj.P1[fj.data.Stream[fj.data.Tree[A]]]" id="14794">subForest</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> subForest;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides a transformation from a tree to its root.
   *
   * @return A transformation from a tree to its root.
   */</span>
  public static &lt;<a title="Nothing" id="30701">A</a>&gt; F&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30701" title="A">A</a>&gt;, <a href="#30701" title="A">A</a>&gt; <a title="[A]()fj.F[fj.data.Tree[A],A]" id="30699">root_</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Tree&lt;A&gt;, A&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public A f<span class="delimiter">(</span><span class="keyword">final</span> Tree&lt;A&gt; a<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> a.root<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides a transformation from a tree to its subforest.
   *
   * @return A transformation from a tree to its subforest.
   */</span>
  public static &lt;<a title="Nothing" id="30704">A</a>&gt; F&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30704" title="A">A</a>&gt;, P1&lt;<a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30704" title="A">A</a>&gt;&gt;&gt;&gt; <a title="[A]()fj.F[fj.data.Tree[A],fj.P1[fj.data.Stream[fj.data.Tree[A]]]]" id="30702">subForest_</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Tree&lt;A&gt;, P1&lt;Stream&lt;Tree&lt;A&gt;&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public P1&lt;Stream&lt;Tree&lt;A&gt;&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Tree&lt;A&gt; a<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> a.subForest<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Puts the elements of the tree into a Stream, in pre-order.
   *
   * @return The elements of the tree in pre-order.
   */</span>
  public <a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10382" title="A">A</a>&gt; <a title="()fj.data.Stream[A]" id="14795">flatten</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> F2&lt;Tree&lt;A&gt;, P1&lt;Stream&lt;A&gt;&gt;, Stream&lt;A&gt;&gt; squish = <span class="keyword">new</span> F2&lt;Tree&lt;A&gt;, P1&lt;Stream&lt;A&gt;&gt;, Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Tree&lt;A&gt; t, <span class="keyword">final</span> P1&lt;Stream&lt;A&gt;&gt; xs<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> cons<span class="delimiter">(</span>t.root<span class="delimiter">(</span><span class="delimiter">)</span>, t.subForest<span class="delimiter">(</span><span class="delimiter">)</span>.map<span class="delimiter">(</span>Stream.&lt;Tree&lt;A&gt;, Stream&lt;A&gt;&gt;foldRight<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>curry<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>xs._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
    <span class="keyword">return</span> squish.f<span class="delimiter">(</span><span class="keyword">this</span>, P.p<span class="delimiter">(</span>Stream.&lt;A&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * flatten :: Tree a -&gt; [a]
   * flatten t = squish t []
   * where squish (Node x ts) xs = x:Prelude.foldr squish xs ts
   * Puts the elements of the tree into a Stream, in pre-order.
   *
   * @return The elements of the tree in pre-order.
   */</span>
  public static &lt;<a title="Nothing" id="30707">A</a>&gt; F&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30707" title="A">A</a>&gt;, <a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#30707" title="A">A</a>&gt;&gt; <a title="[A]()fj.F[fj.data.Tree[A],fj.data.Stream[A]]" id="30705">flatten_</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Tree&lt;A&gt;, Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Tree&lt;A&gt; t<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> t.flatten<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides a stream of the elements of the tree at each level, in level order.
   *
   * @return The elements of the tree at each level.
   */</span>
  public <a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;<a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10382" title="A">A</a>&gt;&gt; <a title="()fj.data.Stream[fj.data.Stream[A]]" id="14796">levels</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> F&lt;Stream&lt;Tree&lt;A&gt;&gt;, Stream&lt;Tree&lt;A&gt;&gt;&gt; flatSubForests =
        Stream.&lt;Tree&lt;A&gt;, Tree&lt;A&gt;&gt;bind_<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>compose<span class="delimiter">(</span>P1.&lt;Stream&lt;Tree&lt;A&gt;&gt;&gt;__1<span class="delimiter">(</span><span class="delimiter">)</span>, Tree.&lt;A&gt;subForest_<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
    <span class="keyword">final</span> F&lt;Stream&lt;Tree&lt;A&gt;&gt;, Stream&lt;A&gt;&gt; roots = Stream.&lt;Tree&lt;A&gt;, A&gt;map_<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>Tree.&lt;A&gt;root_<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
    <span class="keyword">return</span> iterateWhile<span class="delimiter">(</span>flatSubForests, Stream.&lt;Tree&lt;A&gt;&gt;isNotEmpty_<span class="delimiter">(</span><span class="delimiter">)</span>, single<span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span><span class="delimiter">)</span>.map<span class="delimiter">(</span>roots<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps the given function over this tree.
   *
   * @param f The function to map over this tree.
   * @return The new Tree after the function has been applied to each element in this Tree.
   */</span>
  public &lt;<a title="Nothing" id="14799">B</a>&gt; <a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#14799" title="B">B</a>&gt; <a title="[B](f: fj.F[A,B])fj.data.Tree[B]" id="14797">fmap</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10382" title="A">A</a>, <a href="#14799" title="B">B</a>&gt; <a title="fj.F[A,B]" id="30792">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> node<span class="delimiter">(</span>f.f<span class="delimiter">(</span>root<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>, subForest<span class="delimiter">(</span><span class="delimiter">)</span>.map<span class="delimiter">(</span>Stream.&lt;Tree&lt;A&gt;, Tree&lt;B&gt;&gt;map_<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>Tree.&lt;A, B&gt;fmap_<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides a transformation to lift any function so that it maps over Trees.
   *
   * @return A transformation to lift any function so that it maps over Trees.
   */</span>
  public static &lt;<a title="Nothing" id="30711">A</a>, <a title="Nothing" id="30712">B</a>&gt; F&lt;F&lt;<a href="#30711" title="A">A</a>, <a href="#30712" title="B">B</a>&gt;, F&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30711" title="A">A</a>&gt;, <a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30712" title="B">B</a>&gt;&gt;&gt; <a title="[A, B]()fj.F[fj.F[A,B],fj.F[fj.data.Tree[A],fj.data.Tree[B]]]" id="30708">fmap_</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;F&lt;A, B&gt;, F&lt;Tree&lt;A&gt;, Tree&lt;B&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public F&lt;Tree&lt;A&gt;, Tree&lt;B&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Tree&lt;A&gt;, Tree&lt;B&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Tree&lt;B&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Tree&lt;A&gt; a<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> a.fmap<span class="delimiter">(</span>f<span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Folds this tree using the given monoid.
   *
   * @param f A transformation from this tree's elements, to the monoid.
   * @param m The monoid to fold this tree with.
   * @return The result of folding the tree with the given monoid.
   */</span>
  public &lt;<a title="Nothing" id="14802">B</a>&gt; <a href="#14802" title="B">B</a> <a title="[B](f: fj.F[A,B], m: fj.Monoid[B])B" id="14800">foldMap</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10382" title="A">A</a>, <a href="#14802" title="B">B</a>&gt; <a title="fj.F[A,B]" id="30795">f</a>, <span class="keyword">final</span> Monoid&lt;<a href="#14802" title="B">B</a>&gt; <a title="fj.Monoid[B]" id="30796">m</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> m.sum<span class="delimiter">(</span>f.f<span class="delimiter">(</span>root<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>, m.sumRight<span class="delimiter">(</span>subForest<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.map<span class="delimiter">(</span>foldMap_<span class="delimiter">(</span>f, m<span class="delimiter">)</span><span class="delimiter">)</span>.toList<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Projects an immutable collection of this tree.
   *
   * @return An immutable collection of this tree.
   */</span>
  public Collection&lt;<a href="#10382" title="A">A</a>&gt; <a title="()java.util.Collection[A]" id="14803">toCollection</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> flatten<span class="delimiter">(</span><span class="delimiter">)</span>.toCollection<span class="delimiter">(</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides a function that folds a tree with the given monoid.
   *
   * @param f A transformation from a tree's elements to the monoid.
   * @param m A monoid to fold the tree with.
   * @return A function that, given a tree, folds it with the given monoid.
   */</span>
  public static &lt;<a title="Nothing" id="30716">A</a>, <a title="Nothing" id="30717">B</a>&gt; F&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30716" title="A">A</a>&gt;, <a href="#30717" title="B">B</a>&gt; <a title="[A, B](f: fj.F[A,B], m: fj.Monoid[B])fj.F[fj.data.Tree[A],B]" id="30713">foldMap_</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#30716" title="A">A</a>, <a href="#30717" title="B">B</a>&gt; <a title="fj.F[A,B]" id="30761">f</a>, <span class="keyword">final</span> Monoid&lt;<a href="#30717" title="B">B</a>&gt; <a title="fj.Monoid[B]" id="30762">m</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Tree&lt;A&gt;, B&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public B f<span class="delimiter">(</span><span class="keyword">final</span> Tree&lt;A&gt; t<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> t.foldMap<span class="delimiter">(</span>f, m<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Builds a tree from a seed value.
   *
   * @param f A function with which to build the tree.
   * @return A function which, given a seed value, yields a tree.
   */</span>
  public static &lt;<a title="Nothing" id="30721">A</a>, <a title="Nothing" id="30722">B</a>&gt; F&lt;<a href="#30722" title="B">B</a>, <a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30721" title="A">A</a>&gt;&gt; <a title="[A, B](f: fj.F[B,fj.P2[A,fj.P1[fj.data.Stream[B]]]])fj.F[B,fj.data.Tree[A]]" id="30718">unfoldTree</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#30722" title="B">B</a>, P2&lt;<a href="#30721" title="A">A</a>, P1&lt;<a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#30722" title="B">B</a>&gt;&gt;&gt;&gt; <a title="fj.F[B,fj.P2[A,fj.P1[fj.data.Stream[B]]]]" id="30766">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;B, Tree&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Tree&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> B b<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">final</span> P2&lt;A, P1&lt;Stream&lt;B&gt;&gt;&gt; p = f.f<span class="delimiter">(</span>b<span class="delimiter">)</span>;
        <span class="keyword">return</span> node<span class="delimiter">(</span>p._1<span class="delimiter">(</span><span class="delimiter">)</span>, p._2<span class="delimiter">(</span><span class="delimiter">)</span>.map<span class="delimiter">(</span>Stream.&lt;B, Tree&lt;A&gt;&gt;map_<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>unfoldTree<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Applies the given function to all subtrees of this tree, returning a tree of the results (comonad pattern).
   *
   * @param f A function to bind across all the subtrees of this tree.
   * @return A new tree, with the results of applying the given function to each subtree of this tree. The result
   *         of applying the function to the entire tree is the root label, and the results of applying to the
   *         root's children are labels of the root's subforest, etc.
   */</span>
  public &lt;<a title="Nothing" id="14806">B</a>&gt; <a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#14806" title="B">B</a>&gt; <a title="[B](f: fj.F[fj.data.Tree[A],B])fj.data.Tree[B]" id="14804">cobind</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#10382" title="A">A</a>&gt;, <a href="#14806" title="B">B</a>&gt; <a title="fj.F[fj.data.Tree[A],B]" id="30801">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> unfoldTree<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Tree&lt;A&gt;, P2&lt;B, P1&lt;Stream&lt;Tree&lt;A&gt;&gt;&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public P2&lt;B, P1&lt;Stream&lt;Tree&lt;A&gt;&gt;&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Tree&lt;A&gt; t<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> P.p<span class="delimiter">(</span>f.f<span class="delimiter">(</span>t<span class="delimiter">)</span>, t.subForest<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>.f<span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Expands this tree into a tree of trees, with this tree as the root label, and subtrees as the labels of
   * child nodes (comonad pattern).
   *
   * @return A tree of trees, with this tree as its root label, and subtrees of this tree as the labels of
   *         its child nodes.
   */</span>
  public <a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#10382" title="A">A</a>&gt;&gt; <a title="()fj.data.Tree[fj.data.Tree[A]]" id="14807">cojoin</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> F&lt;Tree&lt;A&gt;, Tree&lt;A&gt;&gt; id = identity<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="keyword">return</span> cobind<span class="delimiter">(</span>id<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="keyword">private</span> static &lt;<a title="Nothing" id="30725">A</a>&gt; <a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;String&gt; <a title="[A](s: fj.Show[A], ts: fj.data.Stream[fj.data.Tree[A]])fj.data.Stream[java.lang.String]" id="30723">drawSubTrees</a><span class="delimiter">(</span><span class="keyword">final</span> Show&lt;<a href="#30725" title="A">A</a>&gt; <a title="fj.Show[A]" id="30769">s</a>, <span class="keyword">final</span> <a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30725" title="A">A</a>&gt;&gt; <a title="fj.data.Stream[fj.data.Tree[A]]" id="30770">ts</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> ts.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? Stream.&lt;String&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span>
                        : ts.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? shift<span class="delimiter">(</span><span class="string">&quot;`- &quot;</span>, <span class="string">&quot;   &quot;</span>, ts.head<span class="delimiter">(</span><span class="delimiter">)</span>.drawTree<span class="delimiter">(</span>s<span class="delimiter">)</span><span class="delimiter">)</span>.cons<span class="delimiter">(</span><span class="string">&quot;|&quot;</span><span class="delimiter">)</span>
                                                   : shift<span class="delimiter">(</span><span class="string">&quot;+- &quot;</span>, <span class="string">&quot;|  &quot;</span>, ts.head<span class="delimiter">(</span><span class="delimiter">)</span>.drawTree<span class="delimiter">(</span>s<span class="delimiter">)</span><span class="delimiter">)</span>
                                                       .append<span class="delimiter">(</span>drawSubTrees<span class="delimiter">(</span>s, ts.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="keyword">private</span> static <a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;String&gt; <a title="(f: java.lang.String, o: java.lang.String, s: fj.data.Stream[java.lang.String])fj.data.Stream[java.lang.String]" id="30726">shift</a><span class="delimiter">(</span><span class="keyword">final</span> String <a title="java.lang.String" id="30774">f</a>, <span class="keyword">final</span> String <a title="java.lang.String" id="30775">o</a>, <span class="keyword">final</span> <a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;String&gt; <a title="fj.data.Stream[java.lang.String]" id="30776">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> Stream.repeat<span class="delimiter">(</span>o<span class="delimiter">)</span>.cons<span class="delimiter">(</span>f<span class="delimiter">)</span>.zipWith<span class="delimiter">(</span>s, Monoid.stringMonoid.sum<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;String&gt; <a title="(s: fj.Show[A])fj.data.Stream[java.lang.String]" id="14808">drawTree</a><span class="delimiter">(</span><span class="keyword">final</span> Show&lt;<a href="#10382" title="A">A</a>&gt; <a title="fj.Show[A]" id="30805">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> drawSubTrees<span class="delimiter">(</span>s, subForest._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.cons<span class="delimiter">(</span>s.showS<span class="delimiter">(</span>root<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Draws a 2-dimensional representation of a tree.
   *
   * @param s A show instance for the elements of the tree.
   * @return a String showing this tree in two dimensions.
   */</span>
  public String <a title="(s: fj.Show[A])java.lang.String" id="14809">draw</a><span class="delimiter">(</span><span class="keyword">final</span> Show&lt;<a href="#10382" title="A">A</a>&gt; <a title="fj.Show[A]" id="30807">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> Monoid.stringMonoid.join<span class="delimiter">(</span>drawTree<span class="delimiter">(</span>s<span class="delimiter">)</span>, <span class="string">&quot;\n&quot;</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides a show instance that draws a 2-dimensional representation of a tree.
   *
   * @param s A show instance for the elements of the tree.
   * @return a show instance that draws a 2-dimensional representation of a tree.
   */</span>
  public static &lt;<a title="Nothing" id="30729">A</a>&gt; Show&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30729" title="A">A</a>&gt;&gt; <a title="[A](s: fj.Show[A])fj.Show[fj.data.Tree[A]]" id="30727">show2D</a><span class="delimiter">(</span><span class="keyword">final</span> Show&lt;<a href="#30729" title="A">A</a>&gt; <a title="fj.Show[A]" id="30778">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> Show.showS<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Tree&lt;A&gt;, String&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public String f<span class="delimiter">(</span><span class="keyword">final</span> Tree&lt;A&gt; tree<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> tree.draw<span class="delimiter">(</span>s<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Zips this tree with another, using the given function. The resulting tree is the structural intersection
   * of the two trees.
   *
   * @param bs A tree to zip this tree with.
   * @param f  A function with which to zip together the two trees.
   * @return A new tree of the results of applying the given function over this tree and the given tree, position-wise.
   */</span>
  public &lt;<a title="Nothing" id="14813">B</a>, <a title="Nothing" id="14814">C</a>&gt; <a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#14814" title="C">C</a>&gt; <a title="[B, C](bs: fj.data.Tree[B], f: fj.F2[A,B,C])fj.data.Tree[C]" id="14810">zipWith</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#14813" title="B">B</a>&gt; <a title="fj.data.Tree[B]" id="30809">bs</a>, <span class="keyword">final</span> F2&lt;<a href="#10382" title="A">A</a>, <a href="#14813" title="B">B</a>, <a href="#14814" title="C">C</a>&gt; <a title="fj.F2[A,B,C]" id="30810">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> f.zipTreeM<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span><span class="keyword">this</span>, bs<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Zips this tree with another, using the given function. The resulting tree is the structural intersection
   * of the two trees.
   *
   * @param bs A tree to zip this tree with.
   * @param f  A function with which to zip together the two trees.
   * @return A new tree of the results of applying the given function over this tree and the given tree, position-wise.
   */</span>
  public &lt;<a title="Nothing" id="14818">B</a>, <a title="Nothing" id="14819">C</a>&gt; <a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#14819" title="C">C</a>&gt; <a title="[B, C](bs: fj.data.Tree[B], f: fj.F[A,fj.F[B,C]])fj.data.Tree[C]" id="14815">zipWith</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#14818" title="B">B</a>&gt; <a title="fj.data.Tree[B]" id="30814">bs</a>, <span class="keyword">final</span> F&lt;<a href="#10382" title="A">A</a>, F&lt;<a href="#14818" title="B">B</a>, <a href="#14819" title="C">C</a>&gt;&gt; <a title="fj.F[A,fj.F[B,C]]" id="30815">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> zipWith<span class="delimiter">(</span>bs, uncurryF2<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Folds a Tree&lt;A&gt; into a Tree&lt;B&gt; by applying the function f from the bottom of the Tree to the top
   *
   * @param t A tree to fold from the bottom to the top.
   * @param f  A function transforming the current node and a stream of already transformed nodes (its children) into a new node
   * @return The folded tree
   */</span>
  public static &lt;<a title="Nothing" id="30733">A</a>, <a title="Nothing" id="30734">B</a>&gt; <a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30734" title="B">B</a>&gt; <a title="[A, B](t: fj.data.Tree[A], f: fj.F[fj.P2[A,fj.data.Stream[B]],B])fj.data.Tree[B]" id="30730">bottomUp</a><span class="delimiter">(</span><a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30733" title="A">A</a>&gt; <a title="fj.data.Tree[A]" id="30781">t</a>, <span class="keyword">final</span> F&lt;P2&lt;<a href="#30733" title="A">A</a>, <a href="Stream.java.html#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#30734" title="B">B</a>&gt;&gt;, <a href="#30734" title="B">B</a>&gt; <a title="fj.F[fj.P2[A,fj.data.Stream[B]],B]" id="30782">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> F&lt;Tree&lt;A&gt;, Tree&lt;B&gt;&gt; recursiveCall = <span class="keyword">new</span> F&lt;Tree&lt;A&gt;, Tree&lt;B&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      @Override public Tree&lt;B&gt; f<span class="delimiter">(</span>Tree&lt;A&gt; a<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> bottomUp<span class="delimiter">(</span>a, f<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
 
    <span class="keyword">final</span> Stream&lt;Tree&lt;B&gt;&gt; tbs = t.subForest<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.map<span class="delimiter">(</span>recursiveCall<span class="delimiter">)</span>;
    <span class="keyword">return</span> Tree.node<span class="delimiter">(</span>f.f<span class="delimiter">(</span>P.p<span class="delimiter">(</span>t.root<span class="delimiter">(</span><span class="delimiter">)</span>, tbs.map<span class="delimiter">(</span>Tree.&lt;B&gt; getRoot<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>, tbs<span class="delimiter">)</span>;
   <span class="delimiter">}</span>
 
   <span class="comment">/**
    * @return a function getting the root of a Tree 
	*/</span>
   <span class="keyword">private</span> static &lt;<a title="Nothing" id="30737">A</a>&gt; F&lt;<a href="#10381" title="fj.data.Tree">Tree</a>&lt;<a href="#30737" title="A">A</a>&gt;, <a href="#30737" title="A">A</a>&gt; <a title="[A]()fj.F[fj.data.Tree[A],A]" id="30735">getRoot</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
     <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Tree&lt;A&gt;, A&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
       @Override public A f<span class="delimiter">(</span>Tree&lt;A&gt; a<span class="delimiter">)</span> <span class="delimiter">{</span>
         <span class="keyword">return</span> a.root<span class="delimiter">(</span><span class="delimiter">)</span>;
       <span class="delimiter">}</span>
     <span class="delimiter">}</span>;
   <span class="delimiter">}</span>

<span class="delimiter">}</span>
        </pre>
    </body>
</html>