<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>fj/data/Stream.java</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> fj.data;

<span class="keyword">import</span> fj.Effect;
<span class="keyword">import</span> fj.Equal;
<span class="keyword">import</span> fj.F;
<span class="keyword">import</span> fj.F2;
<span class="keyword">import</span> fj.F3;
<span class="keyword">import</span> fj.Function;
<span class="keyword">import</span> fj.Monoid;
<span class="keyword">import</span> fj.Ord;
<span class="keyword">import</span> fj.P;
<span class="keyword">import</span> fj.P1;
<span class="keyword">import</span> fj.P2;
<span class="keyword">import</span> fj.Unit;
<span class="keyword">import</span> fj.control.parallel.Promise;
<span class="keyword">import</span> fj.control.parallel.Strategy;
<span class="keyword">import</span> fj.Ordering;

<span class="keyword">import</span> java.util.AbstractCollection;
<span class="keyword">import</span> java.util.Collection;
<span class="keyword">import</span> java.util.Iterator;
<span class="keyword">import</span> java.util.NoSuchElementException;

<span class="keyword">import</span> static fj.Bottom.error;
<span class="keyword">import</span> static fj.Function.compose;
<span class="keyword">import</span> static fj.Function.constant;
<span class="keyword">import</span> static fj.Function.curry;
<span class="keyword">import</span> static fj.Function.flip;
<span class="keyword">import</span> static fj.Function.identity;
<span class="keyword">import</span> static fj.P.p;
<span class="keyword">import</span> static fj.P.p2;
<span class="keyword">import</span> static fj.Unit.unit;
<span class="keyword">import</span> static fj.control.parallel.Promise.promise;
<span class="keyword">import</span> static fj.data.Array.mkArray;
<span class="keyword">import</span> static fj.data.Option.none;
<span class="keyword">import</span> static fj.data.Option.some;
<span class="keyword">import</span> static fj.function.Booleans.not;
<span class="keyword">import</span> static fj.Ordering.EQ;
<span class="keyword">import</span> static fj.Ordering.GT;
<span class="keyword">import</span> static fj.Ordering.LT;

<span class="comment">/**
 * A lazy (not yet evaluated), immutable, singly linked list.
 *
 * @version %build.number%
 */</span>
public <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="object fj.data.Stream" id="10365">Stream</a>&lt;<a title="Nothing" id="10366">A</a>&gt; implements Iterable&lt;<a href="#10366" title="A">A</a>&gt; <span class="delimiter">{</span>
  <span class="keyword">private</span> Stream<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>

  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns an iterator for this stream. This method exists to permit the use in a &lt;code&gt;for&lt;/code&gt;-each loop.
   *
   * @return A iterator for this stream.
   */</span>
  public <span class="keyword">final</span> Iterator&lt;<a href="#10366" title="A">A</a>&gt; <a title="()java.util.Iterator[A]" id="17865">iterator</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> toCollection<span class="delimiter">(</span><span class="delimiter">)</span>.iterator<span class="delimiter">(</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * The first element of the stream or fails for the empty stream.
   *
   * @return The first element of the stream or fails for the empty stream.
   */</span>
  public <span class="keyword">abstract</span> <a href="#10366" title="A">A</a> <a title="()A" id="17866">head</a><span class="delimiter">(</span><span class="delimiter">)</span>;

  <span class="comment">/**
   * The stream without the first element or fails for the empty stream.
   *
   * @return The stream without the first element or fails for the empty stream.
   */</span>
  public <span class="keyword">abstract</span> P1&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt;&gt; <a title="()fj.P1[fj.data.Stream[A]]" id="17867">tail</a><span class="delimiter">(</span><span class="delimiter">)</span>;

  <span class="comment">/**
   * Returns &lt;code&gt;true&lt;/code&gt; if this stream is empty, &lt;code&gt;false&lt;/code&gt; otherwise.
   *
   * @return &lt;code&gt;true&lt;/code&gt; if this stream is empty, &lt;code&gt;false&lt;/code&gt; otherwise.
   */</span>
  public <span class="keyword">final</span> boolean <a title="()Boolean" id="17868">isEmpty</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">this</span> instanceof Nil;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns &lt;code&gt;false&lt;/code&gt; if this stream is empty, &lt;code&gt;true&lt;/code&gt; otherwise.
   *
   * @return &lt;code&gt;false&lt;/code&gt; if this stream is empty, &lt;code&gt;true&lt;/code&gt; otherwise.
   */</span>
  public <span class="keyword">final</span> boolean <a title="()Boolean" id="17869">isNotEmpty</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">this</span> instanceof Cons;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Performs a reduction on this stream using the given arguments.
   *
   * @param nil  The value to return if this stream is empty.
   * @param cons The function to apply to the head and tail of this stream if it is not empty.
   * @return A reduction on this stream.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17872">B</a>&gt; <a href="#17872" title="B">B</a> <a title="[B](nil: B, cons: fj.F[A,fj.F[fj.P1[fj.data.Stream[A]],B]])B" id="17870">stream</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#17872" title="B">B</a> <a title="B" id="30434">nil</a>, <span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, F&lt;P1&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt;&gt;, <a href="#17872" title="B">B</a>&gt;&gt; <a title="fj.F[A,fj.F[fj.P1[fj.data.Stream[A]],B]]" id="30435">cons</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? nil : cons.f<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>tail<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Performs a right-fold reduction across this stream. This function uses O(length) stack space.
   *
   * @param f The function to apply on each element of the stream.
   * @param b The beginning value to start the application from.
   * @return The final result after the right-fold reduction.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17875">B</a>&gt; <a href="#17875" title="B">B</a> <a title="[B](f: fj.F[A,fj.F[fj.P1[B],B]], b: B)B" id="17873">foldRight</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, F&lt;P1&lt;<a href="#17875" title="B">B</a>&gt;, <a href="#17875" title="B">B</a>&gt;&gt; <a title="fj.F[A,fj.F[fj.P1[B],B]]" id="30439">f</a>, <span class="keyword">final</span> <a href="#17875" title="B">B</a> <a title="B" id="30440">b</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? b : f.f<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.f<span class="delimiter">(</span><span class="keyword">new</span> P1&lt;B&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public B _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.foldRight<span class="delimiter">(</span>f, b<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Performs a right-fold reduction across this stream. This function uses O(length) stack space.
   *
   * @param f The function to apply on each element of the stream.
   * @param b The beginning value to start the application from.
   * @return The final result after the right-fold reduction.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17878">B</a>&gt; <a href="#17878" title="B">B</a> <a title="[B](f: fj.F2[A,fj.P1[B],B], b: B)B" id="17876">foldRight</a><span class="delimiter">(</span><span class="keyword">final</span> F2&lt;<a href="#10366" title="A">A</a>, P1&lt;<a href="#17878" title="B">B</a>&gt;, <a href="#17878" title="B">B</a>&gt; <a title="fj.F2[A,fj.P1[B],B]" id="30444">f</a>, <span class="keyword">final</span> <a href="#17878" title="B">B</a> <a title="B" id="30445">b</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> foldRight<span class="delimiter">(</span>curry<span class="delimiter">(</span>f<span class="delimiter">)</span>, b<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Performs a right-fold reduction across this stream. This function uses O(length) stack space.
   *
   * @param f The function to apply on each element of the stream.
   * @param b The beginning value to start the application from.
   * @return The final result after the right-fold reduction.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17881">B</a>&gt; <a href="#17881" title="B">B</a> <a title="[B](f: fj.F[A,fj.F[B,B]], b: B)B" id="17879">foldRight1</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, F&lt;<a href="#17881" title="B">B</a>, <a href="#17881" title="B">B</a>&gt;&gt; <a title="fj.F[A,fj.F[B,B]]" id="30449">f</a>, <span class="keyword">final</span> <a href="#17881" title="B">B</a> <a title="B" id="30450">b</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> foldRight<span class="delimiter">(</span>compose<span class="delimiter">(</span>Function.&lt;P1&lt;B&gt;, B, B&gt;andThen<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>P1.&lt;B&gt;__1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>, f<span class="delimiter">)</span>, b<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Performs a right-fold reduction across this stream. This function uses O(length) stack space.
   *
   * @param f The function to apply on each element of the stream.
   * @param b The beginning value to start the application from.
   * @return The final result after the right-fold reduction.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17884">B</a>&gt; <a href="#17884" title="B">B</a> <a title="[B](f: fj.F2[A,B,B], b: B)B" id="17882">foldRight1</a><span class="delimiter">(</span><span class="keyword">final</span> F2&lt;<a href="#10366" title="A">A</a>, <a href="#17884" title="B">B</a>, <a href="#17884" title="B">B</a>&gt; <a title="fj.F2[A,B,B]" id="30454">f</a>, <span class="keyword">final</span> <a href="#17884" title="B">B</a> <a title="B" id="30455">b</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> foldRight1<span class="delimiter">(</span>curry<span class="delimiter">(</span>f<span class="delimiter">)</span>, b<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Performs a left-fold reduction across this stream. This function runs in constant space.
   *
   * @param f The function to apply on each element of the stream.
   * @param b The beginning value to start the application from.
   * @return The final result after the left-fold reduction.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17887">B</a>&gt; <a href="#17887" title="B">B</a> <a title="[B](f: fj.F[B,fj.F[A,B]], b: B)B" id="17885">foldLeft</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#17887" title="B">B</a>, F&lt;<a href="#10366" title="A">A</a>, <a href="#17887" title="B">B</a>&gt;&gt; <a title="fj.F[B,fj.F[A,B]]" id="30459">f</a>, <span class="keyword">final</span> <a href="#17887" title="B">B</a> <a title="B" id="30460">b</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    B x = b;

    <span class="keyword">for</span> <span class="delimiter">(</span>Stream&lt;A&gt; xs = <span class="keyword">this</span>; !xs.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span>; xs = xs.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      x = f.f<span class="delimiter">(</span>x<span class="delimiter">)</span>.f<span class="delimiter">(</span>xs.head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;

    <span class="keyword">return</span> x;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Performs a left-fold reduction across this stream. This function runs in constant space.
   *
   * @param f The function to apply on each element of the stream.
   * @param b The beginning value to start the application from.
   * @return The final result after the left-fold reduction.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17890">B</a>&gt; <a href="#17890" title="B">B</a> <a title="[B](f: fj.F2[B,A,B], b: B)B" id="17888">foldLeft</a><span class="delimiter">(</span><span class="keyword">final</span> F2&lt;<a href="#17890" title="B">B</a>, <a href="#10366" title="A">A</a>, <a href="#17890" title="B">B</a>&gt; <a title="fj.F2[B,A,B]" id="30464">f</a>, <span class="keyword">final</span> <a href="#17890" title="B">B</a> <a title="B" id="30465">b</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> foldLeft<span class="delimiter">(</span>curry<span class="delimiter">(</span>f<span class="delimiter">)</span>, b<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Takes the first 2 elements of the stream and applies the function to them,
   * then applies the function to the result and the third element and so on.
   *
   * @param f The function to apply on each element of the stream.
   * @return The final result after the left-fold reduction.
   */</span>
  public <span class="keyword">final</span> <a href="#10366" title="A">A</a> <a title="(f: fj.F2[A,A,A])A" id="17891">foldLeft1</a><span class="delimiter">(</span><span class="keyword">final</span> F2&lt;<a href="#10366" title="A">A</a>, <a href="#10366" title="A">A</a>, <a href="#10366" title="A">A</a>&gt; <a title="fj.F2[A,A,A]" id="30469">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> foldLeft1<span class="delimiter">(</span>curry<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Takes the first 2 elements of the stream and applies the function to them,
   * then applies the function to the result and the third element and so on.
   *
   * @param f The function to apply on each element of the stream.
   * @return The final result after the left-fold reduction.
   */</span>
  public <span class="keyword">final</span> <a href="#10366" title="A">A</a> <a title="(f: fj.F[A,fj.F[A,A]])A" id="17892">foldLeft1</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, F&lt;<a href="#10366" title="A">A</a>, <a href="#10366" title="A">A</a>&gt;&gt; <a title="fj.F[A,fj.F[A,A]]" id="30471">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">if</span> <span class="delimiter">(</span>isEmpty<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">throw</span> error<span class="delimiter">(</span><span class="string">&quot;Undefined: foldLeft1 on empty list&quot;</span><span class="delimiter">)</span>;
    <span class="keyword">return</span> tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.foldLeft<span class="delimiter">(</span>f, head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns the head of this stream if there is one or the given argument if this stream is empty.
   *
   * @param a The argument to return if this stream is empty.
   * @return The head of this stream if there is one or the given argument if this stream is empty.
   */</span>
  public <span class="keyword">final</span> <a href="#10366" title="A">A</a> <a title="(a: fj.P1[A])A" id="17893">orHead</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#10366" title="A">A</a>&gt; <a title="fj.P1[A]" id="30473">a</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? a._1<span class="delimiter">(</span><span class="delimiter">)</span> : head<span class="delimiter">(</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns the tail of this stream if there is one or the given argument if this stream is empty.
   *
   * @param as The argument to return if this stream is empty.
   * @return The tail of this stream if there is one or the given argument if this stream is empty.
   */</span>
  public <span class="keyword">final</span> P1&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt;&gt; <a title="(as: fj.P1[fj.data.Stream[A]])fj.P1[fj.data.Stream[A]]" id="17894">orTail</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt;&gt; <a title="fj.P1[fj.data.Stream[A]]" id="30475">as</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? as : tail<span class="delimiter">(</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Intersperses the given value between each two elements of the stream.
   *
   * @param a The value to intersperse between values of the stream.
   * @return A new stream with the given value between each two elements of the stream.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(a: A)fj.data.Stream[A]" id="17895">intersperse</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10366" title="A">A</a> <a title="A" id="30477">a</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? <span class="keyword">this</span> : cons<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span>, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> prefix<span class="delimiter">(</span>a, tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>

      public Stream&lt;A&gt; prefix<span class="delimiter">(</span><span class="keyword">final</span> A x, <span class="keyword">final</span> Stream&lt;A&gt; xs<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> xs.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? xs : cons<span class="delimiter">(</span>x, p<span class="delimiter">(</span>cons<span class="delimiter">(</span>xs.head<span class="delimiter">(</span><span class="delimiter">)</span>, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> prefix<span class="delimiter">(</span>a, xs.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps the given function across this stream.
   *
   * @param f The function to map across this stream.
   * @return A new stream after the given function has been applied to each element.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17898">B</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17898" title="B">B</a>&gt; <a title="[B](f: fj.F[A,B])fj.data.Stream[B]" id="17896">map</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, <a href="#17898" title="B">B</a>&gt; <a title="fj.F[A,B]" id="30479">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? Stream.&lt;B&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span> : cons<span class="delimiter">(</span>f.f<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>, <span class="keyword">new</span> P1&lt;Stream&lt;B&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;B&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.map<span class="delimiter">(</span>f<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Provides a first-class version of the map function.
   *
   * @return A function that maps a given function across a given stream.
   */</span>
  public static &lt;<a title="Nothing" id="14648">A</a>, <a title="Nothing" id="14649">B</a>&gt; F&lt;F&lt;<a href="#14648" title="A">A</a>, <a href="#14649" title="B">B</a>&gt;, F&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14648" title="A">A</a>&gt;, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14649" title="B">B</a>&gt;&gt;&gt; <a title="[A, B]()fj.F[fj.F[A,B],fj.F[fj.data.Stream[A],fj.data.Stream[B]]]" id="14645">map_</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;F&lt;A, B&gt;, F&lt;Stream&lt;A&gt;, Stream&lt;B&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public F&lt;Stream&lt;A&gt;, Stream&lt;B&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Stream&lt;A&gt;, Stream&lt;B&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Stream&lt;B&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;A&gt; as<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> as.map<span class="delimiter">(</span>f<span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Performs a side-effect for each element of this stream.
   *
   * @param f The side-effect to perform for the given element.
   * @return The unit value.
   */</span>
  public <span class="keyword">final</span> Unit <a title="(f: fj.F[A,fj.Unit])fj.Unit" id="17899">foreach</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, Unit&gt; <a title="fj.F[A,fj.Unit]" id="30482">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">for</span> <span class="delimiter">(</span>Stream&lt;A&gt; xs = <span class="keyword">this</span>; xs.isNotEmpty<span class="delimiter">(</span><span class="delimiter">)</span>; xs = xs.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      f.f<span class="delimiter">(</span>xs.head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;

    <span class="keyword">return</span> unit<span class="delimiter">(</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Performs a side-effect for each element of this stream.
   *
   * @param f The side-effect to perform for the given element.
   */</span>
  public <span class="keyword">final</span> void <a title="(f: fj.Effect[A])Unit" id="17900">foreach</a><span class="delimiter">(</span><span class="keyword">final</span> Effect&lt;<a href="#10366" title="A">A</a>&gt; <a title="fj.Effect[A]" id="30484">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">for</span> <span class="delimiter">(</span>Stream&lt;A&gt; xs = <span class="keyword">this</span>; xs.isNotEmpty<span class="delimiter">(</span><span class="delimiter">)</span>; xs = xs.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      f.e<span class="delimiter">(</span>xs.head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Filters elements from this stream by returning only elements which produce &lt;code&gt;true&lt;/code&gt;
   * when the given function is applied to them.
   *
   * @param f The predicate function to filter on.
   * @return A new stream whose elements all match the given predicate.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(f: fj.F[A,java.lang.Boolean])fj.data.Stream[A]" id="17901">filter</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, Boolean&gt; <a title="fj.F[A,java.lang.Boolean]" id="30486">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> Stream&lt;A&gt; as = dropWhile<span class="delimiter">(</span>not<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>;
    <span class="keyword">return</span> as.isNotEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? cons<span class="delimiter">(</span>as.head<span class="delimiter">(</span><span class="delimiter">)</span>, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> as.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.filter<span class="delimiter">(</span>f<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span> : as;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Appends the given stream to this stream.
   *
   * @param as The stream to append to this one.
   * @return A new stream that has appended the given stream.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(as: fj.data.Stream[A])fj.data.Stream[A]" id="17902">append</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="fj.data.Stream[A]" id="30488">as</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? as : cons<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span>, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.append<span class="delimiter">(</span>as<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Appends the given stream to this stream.
   *
   * @param as The stream to append to this one.
   * @return A new stream that has appended the given stream.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(as: fj.P1[fj.data.Stream[A]])fj.data.Stream[A]" id="17903">append</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt;&gt; <a title="fj.P1[fj.data.Stream[A]]" id="30490">as</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? as._1<span class="delimiter">(</span><span class="delimiter">)</span> : cons<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span>, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.append<span class="delimiter">(</span>as<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a new stream of all the items in this stream that do not appear in the given stream.
   *
   * @param eq an equality for the items of the streams.
   * @param xs a list to subtract from this stream.
   * @return a stream of all the items in this stream that do not appear in the given stream.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(eq: fj.Equal[A], xs: fj.data.Stream[A])fj.data.Stream[A]" id="17904">minus</a><span class="delimiter">(</span><span class="keyword">final</span> Equal&lt;<a href="#10366" title="A">A</a>&gt; <a title="fj.Equal[A]" id="30492">eq</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="fj.data.Stream[A]" id="30493">xs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> removeAll<span class="delimiter">(</span>compose<span class="delimiter">(</span>Monoid.disjunctionMonoid.sumLeftS<span class="delimiter">(</span><span class="delimiter">)</span>, xs.mapM<span class="delimiter">(</span>curry<span class="delimiter">(</span>eq.eq<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Filters elements from this stream by returning only elements which produce &lt;code&gt;false&lt;/code&gt; when
   * the given function is applied to them.
   *
   * @param f The predicate function to filter on.
   * @return A new stream whose elements do not match the given predicate.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(f: fj.F[A,java.lang.Boolean])fj.data.Stream[A]" id="17905">removeAll</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, Boolean&gt; <a title="fj.F[A,java.lang.Boolean]" id="30495">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> filter<span class="delimiter">(</span>compose<span class="delimiter">(</span>not, f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Turn a stream of functions into a function returning a stream.
   *
   * @param fs The stream of functions to sequence into a single function that returns a stream.
   * @return A function that, when given an argument, applies all the functions in the given stream to it
   *         and returns a stream of the results.
   */</span>
  public static &lt;<a title="Nothing" id="14653">A</a>, <a title="Nothing" id="14654">B</a>&gt; F&lt;<a href="#14654" title="B">B</a>, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14653" title="A">A</a>&gt;&gt; <a title="[A, B](fs: fj.data.Stream[fj.F[B,A]])fj.F[B,fj.data.Stream[A]]" id="14650">sequence_</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;F&lt;<a href="#14654" title="B">B</a>, <a href="#14653" title="A">A</a>&gt;&gt; <a title="fj.data.Stream[fj.F[B,A]]" id="30290">fs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> fs.foldRight<span class="delimiter">(</span><span class="keyword">new</span> F2&lt;F&lt;B, A&gt;, P1&lt;F&lt;B, Stream&lt;A&gt;&gt;&gt;, F&lt;B, Stream&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public F&lt;B, Stream&lt;A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;B, A&gt; baf, <span class="keyword">final</span> P1&lt;F&lt;B, Stream&lt;A&gt;&gt;&gt; p1<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> Function.bind<span class="delimiter">(</span>baf, p1._1<span class="delimiter">(</span><span class="delimiter">)</span>, Function.curry<span class="delimiter">(</span><span class="keyword">new</span> F2&lt;A, Stream&lt;A&gt;, Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Stream&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> A a, <span class="keyword">final</span> Stream&lt;A&gt; stream<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> cons<span class="delimiter">(</span>a, p<span class="delimiter">(</span>stream<span class="delimiter">)</span><span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>, Function
        .&lt;B, Stream&lt;A&gt;&gt;constant<span class="delimiter">(</span>Stream.&lt;A&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps the given function of arity-2 across this stream and returns a function that applies all the resulting
   * functions to a given argument.
   *
   * @param f A function of arity-2
   * @return A function that, when given an argument, applies the given function to that argument and every element
   *         in this list.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17909">B</a>, <a title="Nothing" id="17910">C</a>&gt; F&lt;<a href="#17909" title="B">B</a>, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17910" title="C">C</a>&gt;&gt; <a title="[B, C](f: fj.F[A,fj.F[B,C]])fj.F[B,fj.data.Stream[C]]" id="17906">mapM</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, F&lt;<a href="#17909" title="B">B</a>, <a href="#17910" title="C">C</a>&gt;&gt; <a title="fj.F[A,fj.F[B,C]]" id="30497">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sequence_<span class="delimiter">(</span>map<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across each element of this stream with a final join.
   *
   * @param f The function to apply to each element of this stream.
   * @return A new stream after performing the map, then final join.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17913">B</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17913" title="B">B</a>&gt; <a title="[B](f: fj.F[A,fj.data.Stream[B]])fj.data.Stream[B]" id="17911">bind</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17913" title="B">B</a>&gt;&gt; <a title="fj.F[A,fj.data.Stream[B]]" id="30500">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> join<span class="delimiter">(</span>map<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across each element of this stream and the given stream with a final
   * join.
   *
   * @param sb A given stream to bind the given function with.
   * @param f  The function to apply to each element of this stream and the given stream.
   * @return A new stream after performing the map, then final join.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17917">B</a>, <a title="Nothing" id="17918">C</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17918" title="C">C</a>&gt; <a title="[B, C](sb: fj.data.Stream[B], f: fj.F[A,fj.F[B,C]])fj.data.Stream[C]" id="17914">bind</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17917" title="B">B</a>&gt; <a title="fj.data.Stream[B]" id="30503">sb</a>, <span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, F&lt;<a href="#17917" title="B">B</a>, <a href="#17918" title="C">C</a>&gt;&gt; <a title="fj.F[A,fj.F[B,C]]" id="30504">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sb.apply<span class="delimiter">(</span>map<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across each element of this stream and the given stream with a final
   * join.
   *
   * @param sb A given stream to bind the given function with.
   * @param f  The function to apply to each element of this stream and the given stream.
   * @return A new stream after performing the map, then final join.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17922">B</a>, <a title="Nothing" id="17923">C</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17923" title="C">C</a>&gt; <a title="[B, C](sb: fj.data.Stream[B], f: fj.F2[A,B,C])fj.data.Stream[C]" id="17919">bind</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17922" title="B">B</a>&gt; <a title="fj.data.Stream[B]" id="30508">sb</a>, <span class="keyword">final</span> F2&lt;<a href="#10366" title="A">A</a>, <a href="#17922" title="B">B</a>, <a href="#17923" title="C">C</a>&gt; <a title="fj.F2[A,B,C]" id="30509">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> bind<span class="delimiter">(</span>sb, curry<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across each element of this stream and the given streams with a final
   * join.
   *
   * @param sb A given stream to bind the given function with.
   * @param sc A given stream to bind the given function with.
   * @param f  The function to apply to each element of this stream and the given streams.
   * @return A new stream after performing the map, then final join.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17928">B</a>, <a title="Nothing" id="17929">C</a>, <a title="Nothing" id="17930">D</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17930" title="D">D</a>&gt; <a title="[B, C, D](sb: fj.data.Stream[B], sc: fj.data.Stream[C], f: fj.F[A,fj.F[B,fj.F[C,D]]])fj.data.Stream[D]" id="17924">bind</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17928" title="B">B</a>&gt; <a title="fj.data.Stream[B]" id="30513">sb</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17929" title="C">C</a>&gt; <a title="fj.data.Stream[C]" id="30514">sc</a>, <span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, F&lt;<a href="#17928" title="B">B</a>, F&lt;<a href="#17929" title="C">C</a>, <a href="#17930" title="D">D</a>&gt;&gt;&gt; <a title="fj.F[A,fj.F[B,fj.F[C,D]]]" id="30515">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sc.apply<span class="delimiter">(</span>bind<span class="delimiter">(</span>sb, f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across each element of this stream and the given streams with a final
   * join.
   *
   * @param sb A given stream to bind the given function with.
   * @param sc A given stream to bind the given function with.
   * @param sd A given stream to bind the given function with.
   * @param f  The function to apply to each element of this stream and the given streams.
   * @return A new stream after performing the map, then final join.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17936">B</a>, <a title="Nothing" id="17937">C</a>, <a title="Nothing" id="17938">D</a>, <a title="Nothing" id="17939">E</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17939" title="E">E</a>&gt; <a title="[B, C, D, E](sb: fj.data.Stream[B], sc: fj.data.Stream[C], sd: fj.data.Stream[D], f: fj.F[A,fj.F[B,fj.F[C,fj.F[D,E]]]])fj.data.Stream[E]" id="17931">bind</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17936" title="B">B</a>&gt; <a title="fj.data.Stream[B]" id="30520">sb</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17937" title="C">C</a>&gt; <a title="fj.data.Stream[C]" id="30521">sc</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17938" title="D">D</a>&gt; <a title="fj.data.Stream[D]" id="30522">sd</a>,
                                     <span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, F&lt;<a href="#17936" title="B">B</a>, F&lt;<a href="#17937" title="C">C</a>, F&lt;<a href="#17938" title="D">D</a>, <a href="#17939" title="E">E</a>&gt;&gt;&gt;&gt; <a title="fj.F[A,fj.F[B,fj.F[C,fj.F[D,E]]]]" id="30523">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sd.apply<span class="delimiter">(</span>bind<span class="delimiter">(</span>sb, sc, f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across each element of this stream and the given streams with a final
   * join.
   *
   * @param sb A given stream to bind the given function with.
   * @param sc A given stream to bind the given function with.
   * @param sd A given stream to bind the given function with.
   * @param se A given stream to bind the given function with.
   * @param f  The function to apply to each element of this stream and the given streams.
   * @return A new stream after performing the map, then final join.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17946">B</a>, <a title="Nothing" id="17947">C</a>, <a title="Nothing" id="17948">D</a>, <a title="Nothing" id="17949">E</a>, <a title="Nothing" id="17950">F$</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17950" title="F$">F$</a>&gt; <a title="[B, C, D, E, F$](sb: fj.data.Stream[B], sc: fj.data.Stream[C], sd: fj.data.Stream[D], se: fj.data.Stream[E], f: fj.F[A,fj.F[B,fj.F[C,fj.F[D,fj.F[E,F$]]]]])fj.data.Stream[F$]" id="17940">bind</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17946" title="B">B</a>&gt; <a title="fj.data.Stream[B]" id="30529">sb</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17947" title="C">C</a>&gt; <a title="fj.data.Stream[C]" id="30530">sc</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17948" title="D">D</a>&gt; <a title="fj.data.Stream[D]" id="30531">sd</a>,
                                          <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17949" title="E">E</a>&gt; <a title="fj.data.Stream[E]" id="30532">se</a>, <span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, F&lt;<a href="#17946" title="B">B</a>, F&lt;<a href="#17947" title="C">C</a>, F&lt;<a href="#17948" title="D">D</a>, F&lt;<a href="#17949" title="E">E</a>, <a href="#17950" title="F$">F$</a>&gt;&gt;&gt;&gt;&gt; <a title="fj.F[A,fj.F[B,fj.F[C,fj.F[D,fj.F[E,F$]]]]]" id="30533">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> se.apply<span class="delimiter">(</span>bind<span class="delimiter">(</span>sb, sc, sd, f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across each element of this stream and the given streams with a final
   * join.
   *
   * @param sb A given stream to bind the given function with.
   * @param sc A given stream to bind the given function with.
   * @param sd A given stream to bind the given function with.
   * @param se A given stream to bind the given function with.
   * @param sf A given stream to bind the given function with.
   * @param f  The function to apply to each element of this stream and the given streams.
   * @return A new stream after performing the map, then final join.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17958">B</a>, <a title="Nothing" id="17959">C</a>, <a title="Nothing" id="17960">D</a>, <a title="Nothing" id="17961">E</a>, <a title="Nothing" id="17962">F$</a>, <a title="Nothing" id="17963">G</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17963" title="G">G</a>&gt; <a title="[B, C, D, E, F$, G](sb: fj.data.Stream[B], sc: fj.data.Stream[C], sd: fj.data.Stream[D], se: fj.data.Stream[E], sf: fj.data.Stream[F$], f: fj.F[A,fj.F[B,fj.F[C,fj.F[D,fj.F[E,fj.F[F$,G]]]]]])fj.data.Stream[G]" id="17951">bind</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17958" title="B">B</a>&gt; <a title="fj.data.Stream[B]" id="30540">sb</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17959" title="C">C</a>&gt; <a title="fj.data.Stream[C]" id="30541">sc</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17960" title="D">D</a>&gt; <a title="fj.data.Stream[D]" id="30542">sd</a>,
                                            <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17961" title="E">E</a>&gt; <a title="fj.data.Stream[E]" id="30543">se</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17962" title="F$">F$</a>&gt; <a title="fj.data.Stream[F$]" id="30544">sf</a>,
                                            <span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, F&lt;<a href="#17958" title="B">B</a>, F&lt;<a href="#17959" title="C">C</a>, F&lt;<a href="#17960" title="D">D</a>, F&lt;<a href="#17961" title="E">E</a>, F&lt;<a href="#17962" title="F$">F$</a>, <a href="#17963" title="G">G</a>&gt;&gt;&gt;&gt;&gt;&gt; <a title="fj.F[A,fj.F[B,fj.F[C,fj.F[D,fj.F[E,fj.F[F$,G]]]]]]" id="30545">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sf.apply<span class="delimiter">(</span>bind<span class="delimiter">(</span>sb, sc, sd, se, f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across each element of this stream and the given streams with a final
   * join.
   *
   * @param sb A given stream to bind the given function with.
   * @param sc A given stream to bind the given function with.
   * @param sd A given stream to bind the given function with.
   * @param se A given stream to bind the given function with.
   * @param sf A given stream to bind the given function with.
   * @param sg A given stream to bind the given function with.
   * @param f  The function to apply to each element of this stream and the given streams.
   * @return A new stream after performing the map, then final join.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17972">B</a>, <a title="Nothing" id="17973">C</a>, <a title="Nothing" id="17974">D</a>, <a title="Nothing" id="17975">E</a>, <a title="Nothing" id="17976">F$</a>, <a title="Nothing" id="17977">G</a>, <a title="Nothing" id="17978">H</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17978" title="H">H</a>&gt; <a title="[B, C, D, E, F$, G, H](sb: fj.data.Stream[B], sc: fj.data.Stream[C], sd: fj.data.Stream[D], se: fj.data.Stream[E], sf: fj.data.Stream[F$], sg: fj.data.Stream[G], f: fj.F[A,fj.F[B,fj.F[C,fj.F[D,fj.F[E,fj.F[F$,fj.F[G,H]]]]]]])fj.data.Stream[H]" id="17964">bind</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17972" title="B">B</a>&gt; <a title="fj.data.Stream[B]" id="30553">sb</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17973" title="C">C</a>&gt; <a title="fj.data.Stream[C]" id="30554">sc</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17974" title="D">D</a>&gt; <a title="fj.data.Stream[D]" id="30555">sd</a>,
                                               <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17975" title="E">E</a>&gt; <a title="fj.data.Stream[E]" id="30556">se</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17976" title="F$">F$</a>&gt; <a title="fj.data.Stream[F$]" id="30557">sf</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17977" title="G">G</a>&gt; <a title="fj.data.Stream[G]" id="30558">sg</a>,
                                               <span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, F&lt;<a href="#17972" title="B">B</a>, F&lt;<a href="#17973" title="C">C</a>, F&lt;<a href="#17974" title="D">D</a>, F&lt;<a href="#17975" title="E">E</a>, F&lt;<a href="#17976" title="F$">F$</a>, F&lt;<a href="#17977" title="G">G</a>, <a href="#17978" title="H">H</a>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <a title="fj.F[A,fj.F[B,fj.F[C,fj.F[D,fj.F[E,fj.F[F$,fj.F[G,H]]]]]]]" id="30559">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sg.apply<span class="delimiter">(</span>bind<span class="delimiter">(</span>sb, sc, sd, se, sf, f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across each element of this stream and the given streams with a final
   * join.
   *
   * @param sb A given stream to bind the given function with.
   * @param sc A given stream to bind the given function with.
   * @param sd A given stream to bind the given function with.
   * @param se A given stream to bind the given function with.
   * @param sf A given stream to bind the given function with.
   * @param sg A given stream to bind the given function with.
   * @param sh A given stream to bind the given function with.
   * @param f  The function to apply to each element of this stream and the given streams.
   * @return A new stream after performing the map, then final join.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17988">B</a>, <a title="Nothing" id="17989">C</a>, <a title="Nothing" id="17990">D</a>, <a title="Nothing" id="17991">E</a>, <a title="Nothing" id="17992">F$</a>, <a title="Nothing" id="17993">G</a>, <a title="Nothing" id="17994">H</a>, <a title="Nothing" id="17995">I</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17995" title="I">I</a>&gt; <a title="[B, C, D, E, F$, G, H, I](sb: fj.data.Stream[B], sc: fj.data.Stream[C], sd: fj.data.Stream[D], se: fj.data.Stream[E], sf: fj.data.Stream[F$], sg: fj.data.Stream[G], sh: fj.data.Stream[H], f: fj.F[A,fj.F[B,fj.F[C,fj.F[D,fj.F[E,fj.F[F$,fj.F[G,fj.F[H,I]]]]]]]])fj.data.Stream[I]" id="17979">bind</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17988" title="B">B</a>&gt; <a title="fj.data.Stream[B]" id="30568">sb</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17989" title="C">C</a>&gt; <a title="fj.data.Stream[C]" id="30569">sc</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17990" title="D">D</a>&gt; <a title="fj.data.Stream[D]" id="30570">sd</a>,
                                                  <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17991" title="E">E</a>&gt; <a title="fj.data.Stream[E]" id="30571">se</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17992" title="F$">F$</a>&gt; <a title="fj.data.Stream[F$]" id="30572">sf</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17993" title="G">G</a>&gt; <a title="fj.data.Stream[G]" id="30573">sg</a>,
                                                  <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17994" title="H">H</a>&gt; <a title="fj.data.Stream[H]" id="30574">sh</a>,
                                                  <span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, F&lt;<a href="#17988" title="B">B</a>, F&lt;<a href="#17989" title="C">C</a>, F&lt;<a href="#17990" title="D">D</a>, F&lt;<a href="#17991" title="E">E</a>, F&lt;<a href="#17992" title="F$">F$</a>, F&lt;<a href="#17993" title="G">G</a>, F&lt;<a href="#17994" title="H">H</a>, <a href="#17995" title="I">I</a>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <a title="fj.F[A,fj.F[B,fj.F[C,fj.F[D,fj.F[E,fj.F[F$,fj.F[G,fj.F[H,I]]]]]]]]" id="30575">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sh.apply<span class="delimiter">(</span>bind<span class="delimiter">(</span>sb, sc, sd, se, sf, sg, f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Performs a bind across each stream element, but ignores the element value each time.
   *
   * @param bs The stream to apply in the final join.
   * @return A new stream after the final join.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="17998">B</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17998" title="B">B</a>&gt; <a title="[B](bs: fj.data.Stream[B])fj.data.Stream[B]" id="17996">sequence</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#17998" title="B">B</a>&gt; <a title="fj.data.Stream[B]" id="30585">bs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> F&lt;A, Stream&lt;B&gt;&gt; c = constant<span class="delimiter">(</span>bs<span class="delimiter">)</span>;
    <span class="keyword">return</span> bind<span class="delimiter">(</span>c<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Performs function application within a stream (applicative functor pattern).
   *
   * @param sf The stream of functions to apply.
   * @return A new stream after applying the given stream of functions through this stream.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="18001">B</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#18001" title="B">B</a>&gt; <a title="[B](sf: fj.data.Stream[fj.F[A,B]])fj.data.Stream[B]" id="17999">apply</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;F&lt;<a href="#10366" title="A">A</a>, <a href="#18001" title="B">B</a>&gt;&gt; <a title="fj.data.Stream[fj.F[A,B]]" id="30588">sf</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> sf.bind<span class="delimiter">(</span><span class="keyword">new</span> F&lt;F&lt;A, B&gt;, Stream&lt;B&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;B&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> map<span class="delimiter">(</span><span class="keyword">new</span> F&lt;A, B&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public B f<span class="delimiter">(</span><span class="keyword">final</span> A a<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> f.f<span class="delimiter">(</span>a<span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Interleaves the given stream with this stream to produce a new stream.
   *
   * @param as The stream to interleave this stream with.
   * @return A new stream with elements interleaved from this stream and the given stream.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(as: fj.data.Stream[A])fj.data.Stream[A]" id="18002">interleave</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="fj.data.Stream[A]" id="30591">as</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? as : as.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? <span class="keyword">this</span> : cons<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span>, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      @Override public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> as.interleave<span class="delimiter">(</span>tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Sort this stream according to the given ordering.
   *
   * @param o An ordering for the elements of this stream.
   * @return A new stream with the elements of this stream sorted according to the given ordering.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(o: fj.Ord[A])fj.data.Stream[A]" id="18003">sort</a><span class="delimiter">(</span><span class="keyword">final</span> Ord&lt;<a href="#10366" title="A">A</a>&gt; <a title="fj.Ord[A]" id="30593">o</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> mergesort<span class="delimiter">(</span>o, map<span class="delimiter">(</span>flip<span class="delimiter">(</span>Stream.&lt;A&gt;cons<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>p<span class="delimiter">(</span>Stream.&lt;A&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">// Merges a stream of individually sorted streams into a single sorted stream.</span>
  <span class="keyword">private</span> static &lt;<a title="Nothing" id="14657">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14657" title="A">A</a>&gt; <a title="[A](o: fj.Ord[A], s: fj.data.Stream[fj.data.Stream[A]])fj.data.Stream[A]" id="14655">mergesort</a><span class="delimiter">(</span><span class="keyword">final</span> Ord&lt;<a href="#14657" title="A">A</a>&gt; <a title="fj.Ord[A]" id="30293">o</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14657" title="A">A</a>&gt;&gt; <a title="fj.data.Stream[fj.data.Stream[A]]" id="30294">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">if</span> <span class="delimiter">(</span>s.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">return</span> nil<span class="delimiter">(</span><span class="delimiter">)</span>;
    Stream&lt;Stream&lt;A&gt;&gt; xss = s;
    <span class="keyword">while</span> <span class="delimiter">(</span>xss.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.isNotEmpty<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      xss = mergePairs<span class="delimiter">(</span>o, xss<span class="delimiter">)</span>;
    <span class="keyword">return</span> xss.head<span class="delimiter">(</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">// Merges individually sorted streams two at a time.</span>
  <span class="keyword">private</span> static &lt;<a title="Nothing" id="14660">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14660" title="A">A</a>&gt;&gt; <a title="[A](o: fj.Ord[A], s: fj.data.Stream[fj.data.Stream[A]])fj.data.Stream[fj.data.Stream[A]]" id="14658">mergePairs</a><span class="delimiter">(</span><span class="keyword">final</span> Ord&lt;<a href="#14660" title="A">A</a>&gt; <a title="fj.Ord[A]" id="30298">o</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14660" title="A">A</a>&gt;&gt; <a title="fj.data.Stream[fj.data.Stream[A]]" id="30299">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">if</span> <span class="delimiter">(</span>s.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> || s.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">return</span> s;
    <span class="keyword">final</span> Stream&lt;Stream&lt;A&gt;&gt; t = s.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="keyword">return</span> cons<span class="delimiter">(</span>merge<span class="delimiter">(</span>o, s.head<span class="delimiter">(</span><span class="delimiter">)</span>, t.head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>, <span class="keyword">new</span> P1&lt;Stream&lt;Stream&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;Stream&lt;A&gt;&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> mergePairs<span class="delimiter">(</span>o, t.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">// Merges two individually sorted streams.</span>
  <span class="keyword">private</span> static &lt;<a title="Nothing" id="14663">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14663" title="A">A</a>&gt; <a title="[A](o: fj.Ord[A], xs: fj.data.Stream[A], ys: fj.data.Stream[A])fj.data.Stream[A]" id="14661">merge</a><span class="delimiter">(</span><span class="keyword">final</span> Ord&lt;<a href="#14663" title="A">A</a>&gt; <a title="fj.Ord[A]" id="30303">o</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14663" title="A">A</a>&gt; <a title="fj.data.Stream[A]" id="30304">xs</a>, <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14663" title="A">A</a>&gt; <a title="fj.data.Stream[A]" id="30305">ys</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">if</span> <span class="delimiter">(</span>xs.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">return</span> ys;
    <span class="keyword">if</span> <span class="delimiter">(</span>ys.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">return</span> xs;
    <span class="keyword">final</span> A x = xs.head<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="keyword">final</span> A y = ys.head<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="keyword">if</span> <span class="delimiter">(</span>o.isGreaterThan<span class="delimiter">(</span>x, y<span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">return</span> cons<span class="delimiter">(</span>y, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> merge<span class="delimiter">(</span>o, xs, ys.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="keyword">return</span> cons<span class="delimiter">(</span>x, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> merge<span class="delimiter">(</span>o, xs.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>, ys<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Sort this stream according to the given ordering, using a parallel Quick Sort algorithm that uses the given
   * parallelisation strategy.
   *
   * @param o An ordering for the elements of this stream.
   * @param s A strategy for parallelising the algorithm.
   * @return A new stream with the elements of this stream sorted according to the given ordering.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(o: fj.Ord[A], s: fj.control.parallel.Strategy[fj.Unit])fj.data.Stream[A]" id="18004">sort</a><span class="delimiter">(</span><span class="keyword">final</span> Ord&lt;<a href="#10366" title="A">A</a>&gt; <a title="fj.Ord[A]" id="30595">o</a>, <span class="keyword">final</span> Strategy&lt;Unit&gt; <a title="fj.control.parallel.Strategy[fj.Unit]" id="30596">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> qs<span class="delimiter">(</span>o, s<span class="delimiter">)</span>.claim<span class="delimiter">(</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="keyword">private</span> Promise&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt;&gt; <a title="(o: fj.Ord[A], s: fj.control.parallel.Strategy[fj.Unit])fj.control.parallel.Promise[fj.data.Stream[A]]" id="18005">qs</a><span class="delimiter">(</span><span class="keyword">final</span> Ord&lt;<a href="#10366" title="A">A</a>&gt; <a title="fj.Ord[A]" id="30598">o</a>, <span class="keyword">final</span> Strategy&lt;Unit&gt; <a title="fj.control.parallel.Strategy[fj.Unit]" id="30599">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">if</span> <span class="delimiter">(</span>isEmpty<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">return</span> promise<span class="delimiter">(</span>s, P.p<span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span><span class="delimiter">)</span>;
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">final</span> F&lt;Boolean, Boolean&gt; id = identity<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="keyword">final</span> A x = head<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="keyword">final</span> P1&lt;Stream&lt;A&gt;&gt; xs = tail<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="keyword">final</span> Promise&lt;Stream&lt;A&gt;&gt; left = Promise.join<span class="delimiter">(</span>s, xs.map<span class="delimiter">(</span>flt<span class="delimiter">(</span>o, s, x, id<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="keyword">final</span> Promise&lt;Stream&lt;A&gt;&gt; right = xs.map<span class="delimiter">(</span>flt<span class="delimiter">(</span>o, s, x, not<span class="delimiter">)</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="keyword">final</span> Monoid&lt;Stream&lt;A&gt;&gt; m = Monoid.streamMonoid<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="keyword">return</span> right.fmap<span class="delimiter">(</span>m.sum<span class="delimiter">(</span>single<span class="delimiter">(</span>x<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.apply<span class="delimiter">(</span>left.fmap<span class="delimiter">(</span>m.sum<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> static &lt;<a title="Nothing" id="14666">A</a>&gt; F&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14666" title="A">A</a>&gt;, Promise&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14666" title="A">A</a>&gt;&gt;&gt; <a title="[A](o: fj.Ord[A], s: fj.control.parallel.Strategy[fj.Unit])fj.F[fj.data.Stream[A],fj.control.parallel.Promise[fj.data.Stream[A]]]" id="14664">qs_</a><span class="delimiter">(</span><span class="keyword">final</span> Ord&lt;<a href="#14666" title="A">A</a>&gt; <a title="fj.Ord[A]" id="30310">o</a>, <span class="keyword">final</span> Strategy&lt;Unit&gt; <a title="fj.control.parallel.Strategy[fj.Unit]" id="30311">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Stream&lt;A&gt;, Promise&lt;Stream&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Promise&lt;Stream&lt;A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;A&gt; xs<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> xs.qs<span class="delimiter">(</span>o, s<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="keyword">private</span> static &lt;<a title="Nothing" id="14669">A</a>&gt; F&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14669" title="A">A</a>&gt;, Promise&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14669" title="A">A</a>&gt;&gt;&gt; <a title="[A](o: fj.Ord[A], s: fj.control.parallel.Strategy[fj.Unit], x: A, f: fj.F[java.lang.Boolean,java.lang.Boolean])fj.F[fj.data.Stream[A],fj.control.parallel.Promise[fj.data.Stream[A]]]" id="14667">flt</a><span class="delimiter">(</span><span class="keyword">final</span> Ord&lt;<a href="#14669" title="A">A</a>&gt; <a title="fj.Ord[A]" id="30315">o</a>,
                                                          <span class="keyword">final</span> Strategy&lt;Unit&gt; <a title="fj.control.parallel.Strategy[fj.Unit]" id="30316">s</a>,
                                                          <span class="keyword">final</span> <a href="#14669" title="A">A</a> <a title="A" id="30317">x</a>,
                                                          <span class="keyword">final</span> F&lt;Boolean, Boolean&gt; <a title="fj.F[java.lang.Boolean,java.lang.Boolean]" id="30318">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> F&lt;F&lt;A, Boolean&gt;, F&lt;Stream&lt;A&gt;, Stream&lt;A&gt;&gt;&gt; filter = filter<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="keyword">final</span> F&lt;A, Boolean&gt; lt = o.isLessThan<span class="delimiter">(</span>x<span class="delimiter">)</span>;
    <span class="keyword">return</span> compose<span class="delimiter">(</span>qs_<span class="delimiter">(</span>o, s<span class="delimiter">)</span>, filter.f<span class="delimiter">(</span>compose<span class="delimiter">(</span>f, lt<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Projects an immutable collection of this stream.
   *
   * @return An immutable collection of this stream.
   */</span>
  public <span class="keyword">final</span> Collection&lt;<a href="#10366" title="A">A</a>&gt; <a title="()java.util.Collection[A]" id="18006">toCollection</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> AbstractCollection&lt;A&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Iterator&lt;A&gt; iterator<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;A&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">private</span> Stream&lt;A&gt; xs = Stream.<span class="keyword">this</span>;

          public boolean hasNext<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> xs.isNotEmpty<span class="delimiter">(</span><span class="delimiter">)</span>;
          <span class="delimiter">}</span>

          public A next<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>xs.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span class="keyword">final</span> A a = xs.head<span class="delimiter">(</span><span class="delimiter">)</span>;
              xs = xs.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>;
              <span class="keyword">return</span> a;
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>

          public void remove<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException<span class="delimiter">(</span><span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>;
      <span class="delimiter">}</span>

      public int size<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> length<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a stream of integers from the given &lt;code&gt;from&lt;/code&gt; value (inclusive) to the given
   * &lt;code&gt;to&lt;/code&gt; value (exclusive).
   *
   * @param from The minimum value for the stream (inclusive).
   * @param to   The maximum value for the stream (exclusive).
   * @return A stream of integers from the given &lt;code&gt;from&lt;/code&gt; value (inclusive) to the given
   *         &lt;code&gt;to&lt;/code&gt; value (exclusive).
   */</span>
  public static <a href="#10365" title="fj.data.Stream">Stream</a>&lt;Integer&gt; <a title="(from: Int, to: Long)fj.data.Stream[java.lang.Integer]" id="14670">range</a><span class="delimiter">(</span><span class="keyword">final</span> int <a title="Int" id="30324">from</a>, <span class="keyword">final</span> long <a title="Long" id="30325">to</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> from &gt;= to ? Stream.&lt;Integer&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span> : cons<span class="delimiter">(</span>from, <span class="keyword">new</span> P1&lt;Stream&lt;Integer&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;Integer&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> range<span class="delimiter">(</span>from + <span class="int">1</span>, to<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Constructs a stream with the given elements.
   *
   * @param as The elements which which to construct a stream.
   * @return a new stream with the given elements.
   */</span>
  public static &lt;<a title="Nothing" id="14673">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14673" title="A">A</a>&gt; <a title="[A](as: &lt;repeated...&gt;[A])fj.data.Stream[A]" id="14671">stream</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#14673" title="&lt;repeated...&gt;">A</a>... <a title="&lt;repeated...&gt;[A]" id="30327">as</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> as.length == <span class="int">0</span> ? Stream.&lt;A&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span>
                          : unfold<span class="delimiter">(</span>P2.tuple<span class="delimiter">(</span><span class="keyword">new</span> F2&lt;A<span class="delimiter">[</span><span class="delimiter">]</span>, Integer, Option&lt;P2&lt;A, P2&lt;A<span class="delimiter">[</span><span class="delimiter">]</span>, Integer&gt;&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                            public Option&lt;P2&lt;A, P2&lt;A<span class="delimiter">[</span><span class="delimiter">]</span>, Integer&gt;&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> A<span class="delimiter">[</span><span class="delimiter">]</span> as, <span class="keyword">final</span> Integer i<span class="delimiter">)</span> <span class="delimiter">{</span>
                              <span class="keyword">return</span> i &gt;= as.length ? Option.&lt;P2&lt;A, P2&lt;A<span class="delimiter">[</span><span class="delimiter">]</span>, Integer&gt;&gt;&gt;none<span class="delimiter">(</span><span class="delimiter">)</span>
                                                    : some<span class="delimiter">(</span>P.p<span class="delimiter">(</span>as<span class="delimiter">[</span>i<span class="delimiter">]</span>, P.p<span class="delimiter">(</span>as, i + <span class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
                            <span class="delimiter">}</span>
                          <span class="delimiter">}</span><span class="delimiter">)</span>, P.p<span class="delimiter">(</span>as, <span class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a stream that is either infinite or bounded up to the maximum value of the given iterator starting at the
   * given value and stepping at increments of &lt;code&gt;1&lt;/code&gt;.
   *
   * @param e    The enumerator to compute successors from.
   * @param from The value to begin computing successors from.
   * @return A stream that is either infinite or bounded up to the maximum value of the given iterator starting at the
   *         given value and stepping at increments of &lt;code&gt;1&lt;/code&gt;.
   */</span>
  public static &lt;<a title="Nothing" id="14676">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14676" title="A">A</a>&gt; <a title="[A](e: fj.data.Enumerator[A], from: A)fj.data.Stream[A]" id="14674">forever</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="Enumerator.java.html#10057" title="fj.data.Enumerator">Enumerator</a>&lt;<a href="#14676" title="A">A</a>&gt; <a title="fj.data.Enumerator[A]" id="30330">e</a>, <span class="keyword">final</span> <a href="#14676" title="A">A</a> <a title="A" id="30331">from</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> forever<span class="delimiter">(</span>e, from, <span class="long">1L</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a stream that is either infinite or bounded up to the maximum value of the given iterator starting at the
   * given value and stepping at the given increment.
   *
   * @param e    The enumerator to compute successors from.
   * @param from The value to begin computing successors from.
   * @param step The increment to step.
   * @return A stream that is either infinite or bounded up to the maximum value of the given iterator starting at the
   *         given value and stepping at the given increment.
   */</span>
  public static &lt;<a title="Nothing" id="14679">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14679" title="A">A</a>&gt; <a title="[A](e: fj.data.Enumerator[A], from: A, step: Long)fj.data.Stream[A]" id="14677">forever</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="Enumerator.java.html#10057" title="fj.data.Enumerator">Enumerator</a>&lt;<a href="#14679" title="A">A</a>&gt; <a title="fj.data.Enumerator[A]" id="30335">e</a>, <span class="keyword">final</span> <a href="#14679" title="A">A</a> <a title="A" id="30336">from</a>, <span class="keyword">final</span> long <a title="Long" id="30337">step</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> cons<span class="delimiter">(</span>from, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> e.plus<span class="delimiter">(</span>from, step<span class="delimiter">)</span>.map<span class="delimiter">(</span><span class="keyword">new</span> F&lt;A, Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Stream&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> A a<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> forever<span class="delimiter">(</span>e, a, step<span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>.orSome<span class="delimiter">(</span>Stream.&lt;A&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a stream using the given enumerator from the given value to the other given value stepping at increments of
   * &lt;code&gt;1&lt;/code&gt;.
   *
   * @param e    The enumerator to compute successors from.
   * @param from The value to begin computing successors from.
   * @param to   The value to stop computing successors from.
   * @return A stream using the given enumerator from the given value to the other given value stepping at increments of
   *         &lt;code&gt;1&lt;/code&gt;.
   */</span>
  public static &lt;<a title="Nothing" id="14682">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14682" title="A">A</a>&gt; <a title="[A](e: fj.data.Enumerator[A], from: A, to: A)fj.data.Stream[A]" id="14680">range</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="Enumerator.java.html#10057" title="fj.data.Enumerator">Enumerator</a>&lt;<a href="#14682" title="A">A</a>&gt; <a title="fj.data.Enumerator[A]" id="30342">e</a>, <span class="keyword">final</span> <a href="#14682" title="A">A</a> <a title="A" id="30343">from</a>, <span class="keyword">final</span> <a href="#14682" title="A">A</a> <a title="A" id="30344">to</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> range<span class="delimiter">(</span>e, from, to, <span class="long">1L</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a stream using the given enumerator from the given value to the other given value stepping at the given
   * increment.
   *
   * @param e    The enumerator to compute successors from.
   * @param from The value to begin computing successors from.
   * @param to   The value to stop computing successors from.
   * @param step The increment to step.
   * @return A stream using the given enumerator from the given value to the other given value stepping at the given
   *         increment.
   */</span>
  public static &lt;<a title="Nothing" id="14685">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14685" title="A">A</a>&gt; <a title="[A](e: fj.data.Enumerator[A], from: A, to: A, step: Long)fj.data.Stream[A]" id="14683">range</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="Enumerator.java.html#10057" title="fj.data.Enumerator">Enumerator</a>&lt;<a href="#14685" title="A">A</a>&gt; <a title="fj.data.Enumerator[A]" id="30349">e</a>, <span class="keyword">final</span> <a href="#14685" title="A">A</a> <a title="A" id="30350">from</a>, <span class="keyword">final</span> <a href="#14685" title="A">A</a> <a title="A" id="30351">to</a>, <span class="keyword">final</span> long <a title="Long" id="30352">step</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> Ordering o = e.order<span class="delimiter">(</span><span class="delimiter">)</span>.compare<span class="delimiter">(</span>from, to<span class="delimiter">)</span>;
    <span class="keyword">return</span> o == EQ || step &gt; <span class="long">0L</span> &amp;&amp; o == GT || step &lt; <span class="long">0L</span> &amp;&amp; o == LT ? single<span class="delimiter">(</span>from<span class="delimiter">)</span> : cons<span class="delimiter">(</span>from, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> Stream.join<span class="delimiter">(</span>e.plus<span class="delimiter">(</span>from, step<span class="delimiter">)</span>.filter<span class="delimiter">(</span><span class="keyword">new</span> F&lt;A, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> A a<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> !<span class="delimiter">(</span>o == LT ? e.order<span class="delimiter">(</span><span class="delimiter">)</span>.isLessThan<span class="delimiter">(</span>to, a<span class="delimiter">)</span> : e.order<span class="delimiter">(</span><span class="delimiter">)</span>.isGreaterThan<span class="delimiter">(</span>to, a<span class="delimiter">)</span><span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>.map<span class="delimiter">(</span><span class="keyword">new</span> F&lt;A, Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Stream&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> A a<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> range<span class="delimiter">(</span>e, a, to, step<span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>.toStream<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns an infinite stream of integers from the given &lt;code&gt;from&lt;/code&gt; value (inclusive).
   *
   * @param from The minimum value for the stream (inclusive).
   * @return A stream of integers from the given &lt;code&gt;from&lt;/code&gt; value (inclusive).
   */</span>
  public static <a href="#10365" title="fj.data.Stream">Stream</a>&lt;Integer&gt; <a title="(from: Int)fj.data.Stream[java.lang.Integer]" id="14686">range</a><span class="delimiter">(</span><span class="keyword">final</span> int <a title="Int" id="30358">from</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> cons<span class="delimiter">(</span>from, <span class="keyword">new</span> P1&lt;Stream&lt;Integer&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;Integer&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> range<span class="delimiter">(</span>from + <span class="int">1</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a first-class version of the filter function.
   *
   * @return a function that filters a given stream using a given predicate.
   */</span>
  public static &lt;<a title="Nothing" id="14689">A</a>&gt; F&lt;F&lt;<a href="#14689" title="A">A</a>, Boolean&gt;, F&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14689" title="A">A</a>&gt;, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14689" title="A">A</a>&gt;&gt;&gt; <a title="[A]()fj.F[fj.F[A,java.lang.Boolean],fj.F[fj.data.Stream[A],fj.data.Stream[A]]]" id="14687">filter</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> curry<span class="delimiter">(</span><span class="keyword">new</span> F2&lt;F&lt;A, Boolean&gt;, Stream&lt;A&gt;, Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, Boolean&gt; f, <span class="keyword">final</span> Stream&lt;A&gt; as<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> as.filter<span class="delimiter">(</span>f<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Zips this stream with the given stream of functions, applying each function in turn to the
   * corresponding element in this stream to produce a new stream. If this stream and the given stream
   * have different lengths, then the longer stream is normalised so this function never fails.
   *
   * @param fs The stream of functions to apply to this stream.
   * @return A new stream with a length the same as the shortest of this stream and the given stream.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="18009">B</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#18009" title="B">B</a>&gt; <a title="[B](fs: fj.data.Stream[fj.F[A,B]])fj.data.Stream[B]" id="18007">zapp</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;F&lt;<a href="#10366" title="A">A</a>, <a href="#18009" title="B">B</a>&gt;&gt; <a title="fj.data.Stream[fj.F[A,B]]" id="30602">fs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> fs.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> || isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? Stream.&lt;B&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span> :
           cons<span class="delimiter">(</span>fs.head<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>, <span class="keyword">new</span> P1&lt;Stream&lt;B&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
             public Stream&lt;B&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
               <span class="keyword">return</span> tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.zapp<span class="delimiter">(</span>fs.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
             <span class="delimiter">}</span>
           <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Zips this stream with the given stream using the given function to produce a new stream. If
   * this stream and the given stream have different lengths, then the longer stream is normalised
   * so this function never fails.
   *
   * @param bs The stream to zip this stream with.
   * @param f  The function to zip this stream and the given stream with.
   * @return A new stream with a length the same as the shortest of this stream and the given
   *         stream.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="18013">B</a>, <a title="Nothing" id="18014">C</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#18014" title="C">C</a>&gt; <a title="[B, C](bs: fj.data.Stream[B], f: fj.F[A,fj.F[B,C]])fj.data.Stream[C]" id="18010">zipWith</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#18013" title="B">B</a>&gt; <a title="fj.data.Stream[B]" id="30605">bs</a>, <span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, F&lt;<a href="#18013" title="B">B</a>, <a href="#18014" title="C">C</a>&gt;&gt; <a title="fj.F[A,fj.F[B,C]]" id="30606">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> bs.zapp<span class="delimiter">(</span>zapp<span class="delimiter">(</span>repeat<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Zips this stream with the given stream using the given function to produce a new stream. If
   * this stream and the given stream have different lengths, then the longer stream is normalised
   * so this function never fails.
   *
   * @param bs The stream to zip this stream with.
   * @param f  The function to zip this stream and the given stream with.
   * @return A new stream with a length the same as the shortest of this stream and the given
   *         stream.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="18018">B</a>, <a title="Nothing" id="18019">C</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#18019" title="C">C</a>&gt; <a title="[B, C](bs: fj.data.Stream[B], f: fj.F2[A,B,C])fj.data.Stream[C]" id="18015">zipWith</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#18018" title="B">B</a>&gt; <a title="fj.data.Stream[B]" id="30610">bs</a>, <span class="keyword">final</span> F2&lt;<a href="#10366" title="A">A</a>, <a href="#18018" title="B">B</a>, <a href="#18019" title="C">C</a>&gt; <a title="fj.F2[A,B,C]" id="30611">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> zipWith<span class="delimiter">(</span>bs, curry<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Partially-applied version of zipWith.
   * Returns a function that zips a given stream with this stream using the given function.
   *
   * @param f The function to zip this stream and a given stream with.
   * @return A function that zips a given stream with this stream using the given function.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="18023">B</a>, <a title="Nothing" id="18024">C</a>&gt; F&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#18023" title="B">B</a>&gt;, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#18024" title="C">C</a>&gt;&gt; <a title="[B, C](f: fj.F[A,fj.F[B,C]])fj.F[fj.data.Stream[B],fj.data.Stream[C]]" id="18020">zipWith</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, F&lt;<a href="#18023" title="B">B</a>, <a href="#18024" title="C">C</a>&gt;&gt; <a title="fj.F[A,fj.F[B,C]]" id="30615">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Stream&lt;B&gt;, Stream&lt;C&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;C&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;B&gt; stream<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> zipWith<span class="delimiter">(</span>stream, f<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Zips this stream with the given stream to produce a stream of pairs. If this stream and the
   * given stream have different lengths, then the longer stream is normalised so this function
   * never fails.
   *
   * @param bs The stream to zip this stream with.
   * @return A new stream with a length the same as the shortest of this stream and the given
   *         stream.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="18027">B</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;P2&lt;<a href="#10366" title="A">A</a>, <a href="#18027" title="B">B</a>&gt;&gt; <a title="[B](bs: fj.data.Stream[B])fj.data.Stream[fj.P2[A,B]]" id="18025">zip</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#18027" title="B">B</a>&gt; <a title="fj.data.Stream[B]" id="30618">bs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> F&lt;A, F&lt;B, P2&lt;A, B&gt;&gt;&gt; __2 = p2<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="keyword">return</span> zipWith<span class="delimiter">(</span>bs, __2<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Zips this stream with the index of its element as a pair.
   *
   * @return A new stream with the same length as this stream.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;P2&lt;<a href="#10366" title="A">A</a>, Integer&gt;&gt; <a title="()fj.data.Stream[fj.P2[A,java.lang.Integer]]" id="18028">zipIndex</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> zipWith<span class="delimiter">(</span>range<span class="delimiter">(</span><span class="int">0</span><span class="delimiter">)</span>, <span class="keyword">new</span> F2&lt;A, Integer, P2&lt;A, Integer&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public P2&lt;A, Integer&gt; f<span class="delimiter">(</span><span class="keyword">final</span> A a, <span class="keyword">final</span> Integer i<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> p<span class="delimiter">(</span>a, i<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns an either projection of this stream; the given argument in &lt;code&gt;Left&lt;/code&gt; if empty,
   * or the first element in &lt;code&gt;Right&lt;/code&gt;.
   *
   * @param x The value to return in left if this stream is empty.
   * @return An either projection of this stream.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="18031">X</a>&gt; <a href="Either.java.html#10039" title="fj.data.Either">Either</a>&lt;<a href="#18031" title="X">X</a>, <a href="#10366" title="A">A</a>&gt; <a title="[X](x: fj.P1[X])fj.data.Either[X,A]" id="18029">toEither</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#18031" title="X">X</a>&gt; <a title="fj.P1[X]" id="30622">x</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? Either.&lt;X, A&gt;left<span class="delimiter">(</span>x._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> : Either.&lt;X, A&gt;right<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns an option projection of this stream; &lt;code&gt;None&lt;/code&gt; if empty, or the first element
   * in &lt;code&gt;Some&lt;/code&gt;.
   *
   * @return An option projection of this stream.
   */</span>
  public <span class="keyword">final</span> <a href="Option.java.html#10291" title="fj.data.Option">Option</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="()fj.data.Option[A]" id="18032">toOption</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? Option.&lt;A&gt;none<span class="delimiter">(</span><span class="delimiter">)</span> : some<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a list projection of this stream.
   *
   * @return A list projection of this stream.
   */</span>
  public <span class="keyword">final</span> <a href="List.java.html#10232" title="fj.data.List">List</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="()fj.data.List[A]" id="18033">toList</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    List&lt;A&gt; as = List.nil<span class="delimiter">(</span><span class="delimiter">)</span>;

    <span class="keyword">for</span> <span class="delimiter">(</span>Stream&lt;A&gt; x = <span class="keyword">this</span>; !x.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span>; x = x.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      as = as.snoc<span class="delimiter">(</span>x.head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="keyword">return</span> as;
  <span class="delimiter">}</span>


  <span class="comment">/**
   * Returns a array projection of this stream.
   *
   * @return A array projection of this stream.
   */</span>
  @SuppressWarnings<span class="delimiter">(</span><span class="delimiter">{</span><span class="string">&quot;unchecked&quot;</span><span class="delimiter">}</span><span class="delimiter">)</span>
  public <span class="keyword">final</span> <a href="Array.java.html#10010" title="fj.data.Array">Array</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="()fj.data.Array[A]" id="18034">toArray</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> int l = length<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="keyword">final</span> Object<span class="delimiter">[</span><span class="delimiter">]</span> a = <span class="keyword">new</span> Object<span class="delimiter">[</span>l<span class="delimiter">]</span>;
    Stream&lt;A&gt; x = <span class="keyword">this</span>;
    <span class="keyword">for</span> <span class="delimiter">(</span>int i = <span class="int">0</span>; i &lt; l; i++<span class="delimiter">)</span> <span class="delimiter">{</span>
      a<span class="delimiter">[</span>i<span class="delimiter">]</span> = x.head<span class="delimiter">(</span><span class="delimiter">)</span>;
      x = x.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="keyword">return</span> mkArray<span class="delimiter">(</span>a<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a array projection of this stream.
   *
   * @param c The class type of the array to return.
   * @return A array projection of this stream.
   */</span>
  @SuppressWarnings<span class="delimiter">(</span><span class="delimiter">{</span><span class="string">&quot;unchecked&quot;</span>, <span class="string">&quot;UnnecessaryFullyQualifiedName&quot;</span><span class="delimiter">}</span><span class="delimiter">)</span>
  public <span class="keyword">final</span> <a href="Array.java.html#10010" title="fj.data.Array">Array</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(c: java.lang.Class[Array[A with java.lang.Object]])fj.data.Array[A]" id="18035">toArray</a><span class="delimiter">(</span><span class="keyword">final</span> Class&lt;<a href="#10366" title="A">A</a><span class="delimiter">[</span><span title="Array" class="delimiter">]</span>&gt; <a title="java.lang.Class[Array[A]]" id="30628">c</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> A<span class="delimiter">[</span><span class="delimiter">]</span> a = <span class="delimiter">(</span>A<span class="delimiter">[</span><span class="delimiter">]</span><span class="delimiter">)</span> java.lang.reflect.Array.newInstance<span class="delimiter">(</span>c.getComponentType<span class="delimiter">(</span><span class="delimiter">)</span>, length<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;

    int i = <span class="int">0</span>;
    <span class="keyword">for</span> <span class="delimiter">(</span><span class="keyword">final</span> A x : <span class="keyword">this</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      a<span class="delimiter">[</span>i<span class="delimiter">]</span> = x;
      i++;
    <span class="delimiter">}</span>

    <span class="keyword">return</span> Array.array<span class="delimiter">(</span>a<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns an array from this stream.
   *
   * @param c The class type of the array to return.
   * @return An array from this stream.
   */</span>
  public <span class="keyword">final</span> <a href="#10366" title="A">A</a><span class="delimiter">[</span><span title="Array" class="delimiter">]</span> <a title="(c: java.lang.Class[Array[A with java.lang.Object]])Array[A with java.lang.Object]" id="18036">array</a><span class="delimiter">(</span><span class="keyword">final</span> Class&lt;<a href="#10366" title="A">A</a><span class="delimiter">[</span><span title="Array" class="delimiter">]</span>&gt; <a title="java.lang.Class[Array[A]]" id="30633">c</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> toArray<span class="delimiter">(</span>c<span class="delimiter">)</span>.array<span class="delimiter">(</span>c<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Prepends (cons) the given element to this stream to product a new stream.
   *
   * @param a The element to prepend.
   * @return A new stream with the given element at the head.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(a: A)fj.data.Stream[A]" id="18037">cons</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10366" title="A">A</a> <a title="A" id="30639">a</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> Cons&lt;A&gt;<span class="delimiter">(</span>a, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> Stream.<span class="keyword">this</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a string from the given stream of characters. The inverse of this function is {@link
   * #fromString(String)}.
   *
   * @param cs The stream of characters to produce the string from.
   * @return A string from the given stream of characters.
   */</span>
  public static String <a title="(cs: fj.data.Stream[java.lang.Character])java.lang.String" id="14690">asString</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;Character&gt; <a title="fj.data.Stream[java.lang.Character]" id="30361">cs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> LazyString.fromStream<span class="delimiter">(</span>cs<span class="delimiter">)</span>.toString<span class="delimiter">(</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a stream of characters from the given string. The inverse of this function is {@link
   * #asString(Stream)}.
   *
   * @param s The string to produce the stream of characters from.
   * @return A stream of characters from the given string.
   */</span>
  public static <a href="#10365" title="fj.data.Stream">Stream</a>&lt;Character&gt; <a title="(s: java.lang.String)fj.data.Stream[java.lang.Character]" id="14691">fromString</a><span class="delimiter">(</span><span class="keyword">final</span> String <a title="java.lang.String" id="30363">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> LazyString.str<span class="delimiter">(</span>s<span class="delimiter">)</span>.toStream<span class="delimiter">(</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Append the given element to this stream to product a new stream.
   *
   * @param a The element to append.
   * @return A new stream with the given element at the end.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(a: A)fj.data.Stream[A]" id="18038">snoc</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10366" title="A">A</a> <a title="A" id="30641">a</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> snoc<span class="delimiter">(</span>p<span class="delimiter">(</span>a<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Append the given element to this stream to produce a new stream.
   *
   * @param a The element to append.
   * @return A new stream with the given element at the end.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(a: fj.P1[A])fj.data.Stream[A]" id="18039">snoc</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#10366" title="A">A</a>&gt; <a title="fj.P1[A]" id="30643">a</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> append<span class="delimiter">(</span><span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> single<span class="delimiter">(</span>a._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns the first &lt;code&gt;n&lt;/code&gt; elements from the head of this stream.
   *
   * @param n The number of elements to take from this stream.
   * @return The first &lt;code&gt;n&lt;/code&gt; elements from the head of this stream.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(n: Int)fj.data.Stream[A]" id="18040">take</a><span class="delimiter">(</span><span class="keyword">final</span> int <a title="Int" id="30645">n</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> n &lt;= <span class="int">0</span> || isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ?
           Stream.&lt;A&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span> :
           cons<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span>, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
             public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
               <span class="keyword">return</span> tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.take<span class="delimiter">(</span>n - <span class="int">1</span><span class="delimiter">)</span>;
             <span class="delimiter">}</span>
           <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Drops the given number of elements from the head of this stream if they are available.
   *
   * @param i The number of elements to drop from the head of this stream.
   * @return A stream with a length the same, or less than, this stream.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(i: Int)fj.data.Stream[A]" id="18041">drop</a><span class="delimiter">(</span><span class="keyword">final</span> int <a title="Int" id="30647">i</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    int c = <span class="int">0</span>;

    Stream&lt;A&gt; xs = <span class="keyword">this</span>;

    <span class="keyword">for</span> <span class="delimiter">(</span>; xs.isNotEmpty<span class="delimiter">(</span><span class="delimiter">)</span> &amp;&amp; c &lt; i; xs = xs.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      c++;

    <span class="keyword">return</span> xs;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns the first elements of the head of this stream that match the given predicate function.
   *
   * @param f The predicate function to apply on this stream until it finds an element that does not
   *          hold, or the stream is exhausted.
   * @return The first elements of the head of this stream that match the given predicate function.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(f: fj.F[A,java.lang.Boolean])fj.data.Stream[A]" id="18042">takeWhile</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, Boolean&gt; <a title="fj.F[A,java.lang.Boolean]" id="30649">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ?
           <span class="keyword">this</span> :
           f.f<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> ?
           cons<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span>, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
             public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
               <span class="keyword">return</span> tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.takeWhile<span class="delimiter">(</span>f<span class="delimiter">)</span>;
             <span class="delimiter">}</span>
           <span class="delimiter">}</span><span class="delimiter">)</span> :
           Stream.&lt;A&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Removes elements from the head of this stream that do not match the given predicate function
   * until an element is found that does match or the stream is exhausted.
   *
   * @param f The predicate function to apply through this stream.
   * @return The stream whose first element does not match the given predicate function.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(f: fj.F[A,java.lang.Boolean])fj.data.Stream[A]" id="18043">dropWhile</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, Boolean&gt; <a title="fj.F[A,java.lang.Boolean]" id="30651">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    Stream&lt;A&gt; as;
    <span class="comment">//noinspection StatementWithEmptyBody</span>
    <span class="keyword">for</span> <span class="delimiter">(</span>as = <span class="keyword">this</span>; !as.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> &amp;&amp; f.f<span class="delimiter">(</span>as.head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>; as = as.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> ;

    <span class="keyword">return</span> as;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a tuple where the first element is the longest prefix of this stream that satisfies
   * the given predicate and the second element is the remainder of the stream.
   *
   * @param p A predicate to be satisfied by a prefix of this stream.
   * @return A tuple where the first element is the longest prefix of this stream that satisfies
   *         the given predicate and the second element is the remainder of the stream.
   */</span>
  public <span class="keyword">final</span> P2&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt;, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt;&gt; <a title="(p: fj.F[A,java.lang.Boolean])fj.P2[fj.data.Stream[A],fj.data.Stream[A]]" id="18044">span</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, Boolean&gt; <a title="fj.F[A,java.lang.Boolean]" id="30653">p</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">if</span> <span class="delimiter">(</span>isEmpty<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">return</span> p<span class="delimiter">(</span><span class="keyword">this</span>, <span class="keyword">this</span><span class="delimiter">)</span>;
    <span class="keyword">else</span> <span class="keyword">if</span> <span class="delimiter">(</span>p.f<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">final</span> P1&lt;P2&lt;Stream&lt;A&gt;, Stream&lt;A&gt;&gt;&gt; yszs = <span class="keyword">new</span> P1&lt;P2&lt;Stream&lt;A&gt;, Stream&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        @Override public P2&lt;Stream&lt;A&gt;, Stream&lt;A&gt;&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.span<span class="delimiter">(</span>p<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>;
      <span class="keyword">return</span> <span class="keyword">new</span> P2&lt;Stream&lt;A&gt;, Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        @Override public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> cons<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span>, yszs.map<span class="delimiter">(</span>P2.&lt;Stream&lt;A&gt;, Stream&lt;A&gt;&gt;__1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>

        @Override public Stream&lt;A&gt; _2<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> yszs._1<span class="delimiter">(</span><span class="delimiter">)</span>._2<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>;
    <span class="delimiter">}</span> <span class="keyword">else</span>
      <span class="keyword">return</span> p<span class="delimiter">(</span>Stream.&lt;A&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span>, <span class="keyword">this</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a new stream resulting from replacing all elements that match the given predicate with the given element.
   *
   * @param p The predicate to match replaced elements.
   * @param a The element with which to replace elements.
   * @return A new stream resulting from replacing all elements that match the given predicate with the given element.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(p: fj.F[A,java.lang.Boolean], a: A)fj.data.Stream[A]" id="18045">replace</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, Boolean&gt; <a title="fj.F[A,java.lang.Boolean]" id="30655">p</a>, <span class="keyword">final</span> <a href="#10366" title="A">A</a> <a title="A" id="30656">a</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">if</span> <span class="delimiter">(</span>isEmpty<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">return</span> nil<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">final</span> P2&lt;Stream&lt;A&gt;, Stream&lt;A&gt;&gt; s = span<span class="delimiter">(</span>p<span class="delimiter">)</span>;
      <span class="keyword">return</span> s._1<span class="delimiter">(</span><span class="delimiter">)</span>.append<span class="delimiter">(</span>cons<span class="delimiter">(</span>a, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        @Override public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> s._2<span class="delimiter">(</span><span class="delimiter">)</span>.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.replace<span class="delimiter">(</span>p, a<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a tuple where the first element is the longest prefix of this stream that does not satisfy
   * the given predicate and the second element is the remainder of the stream.
   *
   * @param p A predicate not to be satisfied by a prefix of this stream.
   * @return A tuple where the first element is the longest prefix of this stream that does not satisfy
   *         the given predicate and the second element is the remainder of the stream.
   */</span>
  public <span class="keyword">final</span> P2&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt;, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt;&gt; <a title="(p: fj.F[A,java.lang.Boolean])fj.P2[fj.data.Stream[A],fj.data.Stream[A]]" id="18046">split</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, Boolean&gt; <a title="fj.F[A,java.lang.Boolean]" id="30658">p</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> span<span class="delimiter">(</span>compose<span class="delimiter">(</span>not, p<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Reverse this stream in constant stack space.
   *
   * @return A new stream that is the reverse of this one.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="()fj.data.Stream[A]" id="18047">reverse</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> foldLeft<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Stream&lt;A&gt;, F&lt;A, Stream&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public F&lt;A, Stream&lt;A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;A&gt; as<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> F&lt;A, Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Stream&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> A a<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> cons<span class="delimiter">(</span>a, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">return</span> as;
              <span class="delimiter">}</span>
            <span class="delimiter">}</span><span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>, Stream.&lt;A&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Get the last element of this stream. Undefined for infinite streams.
   *
   * @return The last element in this stream, if there is one.
   */</span>
  public <span class="keyword">final</span> <a href="#10366" title="A">A</a> <a title="()A" id="18048">last</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> reverse<span class="delimiter">(</span><span class="delimiter">)</span>.head<span class="delimiter">(</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * The length of this stream. This function will not terminate for an infinite stream.
   *
   * @return The length of this stream.
   */</span>
  public <span class="keyword">final</span> int <a title="()Int" id="18049">length</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">// we're using an iterative approach here as the previous implementation (toList().length()) took</span>
    <span class="comment">// very long even for some 10000 elements.</span>
    Stream&lt;A&gt; xs = <span class="keyword">this</span>;
    int i = <span class="int">0</span>;
    <span class="keyword">while</span> <span class="delimiter">(</span>!xs.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      xs = xs.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>;
      i += <span class="int">1</span>;
    <span class="delimiter">}</span>
    <span class="keyword">return</span> i;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns the element at the given index if it exists, fails otherwise.
   *
   * @param i The index at which to get the element to return.
   * @return The element at the given index if it exists, fails otherwise.
   */</span>
  public <span class="keyword">final</span> <a href="#10366" title="A">A</a> <a title="(i: Int)A" id="18050">index</a><span class="delimiter">(</span><span class="keyword">final</span> int <a title="Int" id="30663">i</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">if</span> <span class="delimiter">(</span>i &lt; <span class="int">0</span><span class="delimiter">)</span>
      <span class="keyword">throw</span> error<span class="delimiter">(</span><span class="string">&quot;index &quot;</span> + i + <span class="string">&quot; out of range on stream&quot;</span><span class="delimiter">)</span>;
    <span class="keyword">else</span> <span class="delimiter">{</span>
      Stream&lt;A&gt; xs = <span class="keyword">this</span>;

      <span class="keyword">for</span> <span class="delimiter">(</span>int c = <span class="int">0</span>; c &lt; i; c++<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>xs.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">throw</span> error<span class="delimiter">(</span><span class="string">&quot;index &quot;</span> + i + <span class="string">&quot; out of range on stream&quot;</span><span class="delimiter">)</span>;

        xs = xs.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>

      <span class="keyword">if</span> <span class="delimiter">(</span>xs.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">throw</span> error<span class="delimiter">(</span><span class="string">&quot;index &quot;</span> + i + <span class="string">&quot; out of range on stream&quot;</span><span class="delimiter">)</span>;

      <span class="keyword">return</span> xs.head<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns &lt;code&gt;true&lt;/code&gt; if the predicate holds for all of the elements of this stream,
   * &lt;code&gt;false&lt;/code&gt; otherwise (&lt;code&gt;true&lt;/code&gt; for the empty stream).
   *
   * @param f the predicate function to test on each element of this stream.
   * @return &lt;code&gt;true&lt;/code&gt; if the predicate holds for all of the elements of this stream,
   *         &lt;code&gt;false&lt;/code&gt; otherwise.
   */</span>
  public <span class="keyword">final</span> boolean <a title="(f: fj.F[A,java.lang.Boolean])Boolean" id="18051">forall</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, Boolean&gt; <a title="fj.F[A,java.lang.Boolean]" id="30665">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> || f.f<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> &amp;&amp; tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.forall<span class="delimiter">(</span>f<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns &lt;code&gt;true&lt;/code&gt; if the predicate holds for at least one of the elements of this
   * stream, &lt;code&gt;false&lt;/code&gt; otherwise (&lt;code&gt;false&lt;/code&gt; for the empty stream).
   *
   * @param f The predicate function to test on the elements of this stream.
   * @return &lt;code&gt;true&lt;/code&gt; if the predicate holds for at least one of the elements of this
   *         stream.
   */</span>
  public <span class="keyword">final</span> boolean <a title="(f: fj.F[A,java.lang.Boolean])Boolean" id="18052">exists</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, Boolean&gt; <a title="fj.F[A,java.lang.Boolean]" id="30667">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> dropWhile<span class="delimiter">(</span>not<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>.isNotEmpty<span class="delimiter">(</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Finds the first occurrence of an element that matches the given predicate or no value if no
   * elements match.
   *
   * @param f The predicate function to test on elements of this stream.
   * @return The first occurrence of an element that matches the given predicate or no value if no
   *         elements match.
   */</span>
  public <span class="keyword">final</span> <a href="Option.java.html#10291" title="fj.data.Option">Option</a>&lt;<a href="#10366" title="A">A</a>&gt; <a title="(f: fj.F[A,java.lang.Boolean])fj.data.Option[A]" id="18053">find</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, Boolean&gt; <a title="fj.F[A,java.lang.Boolean]" id="30669">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">for</span> <span class="delimiter">(</span>Stream&lt;A&gt; as = <span class="keyword">this</span>; as.isNotEmpty<span class="delimiter">(</span><span class="delimiter">)</span>; as = as.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">if</span> <span class="delimiter">(</span>f.f<span class="delimiter">(</span>as.head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">return</span> some<span class="delimiter">(</span>as.head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="keyword">return</span> none<span class="delimiter">(</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across the stream of substreams of this stream.
   *
   * @param k A function to bind across this stream and its substreams.
   * @return a new stream of the results of applying the given function to this stream and its substreams.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="18056">B</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#18056" title="B">B</a>&gt; <a title="[B](k: fj.F[fj.data.Stream[A],B])fj.data.Stream[B]" id="18054">cobind</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt;, <a href="#18056" title="B">B</a>&gt; <a title="fj.F[fj.data.Stream[A],B]" id="30671">k</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> substreams<span class="delimiter">(</span><span class="delimiter">)</span>.map<span class="delimiter">(</span>k<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a stream of the suffixes of this stream. A stream is considered to be a suffix of itself in this context.
   *
   * @return a stream of the suffixes of this stream, starting with the stream itself.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt;&gt; <a title="()fj.data.Stream[fj.data.Stream[A]]" id="18057">tails</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? Stream.&lt;Stream&lt;A&gt;&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span> : cons<span class="delimiter">(</span><span class="keyword">this</span>, <span class="keyword">new</span> P1&lt;Stream&lt;Stream&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;Stream&lt;A&gt;&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.tails<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a stream of all prefixes of this stream. A stream is considered a prefix of itself in tnis context.
   *
   * @return a stream of the prefixes of this stream, starting with the stream itself.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt;&gt; <a title="()fj.data.Stream[fj.data.Stream[A]]" id="18058">inits</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> Stream&lt;Stream&lt;A&gt;&gt; nil = Stream.cons<span class="delimiter">(</span>Stream.&lt;A&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span>, <span class="keyword">new</span> P1&lt;Stream&lt;Stream&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;Stream&lt;A&gt;&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> nil<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="keyword">return</span> isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ? nil : nil.append<span class="delimiter">(</span><span class="keyword">new</span> P1&lt;Stream&lt;Stream&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;Stream&lt;A&gt;&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>.inits<span class="delimiter">(</span><span class="delimiter">)</span>.map<span class="delimiter">(</span>Stream.&lt;A&gt;cons_<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span>head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a stream of all infixes of this stream. A stream is considered to contain itself.
   *
   * @return a stream of the infixes of this stream.
   */</span>
  public <span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt;&gt; <a title="()fj.data.Stream[fj.data.Stream[A]]" id="18059">substreams</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> tails<span class="delimiter">(</span><span class="delimiter">)</span>.bind<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Stream&lt;A&gt;, Stream&lt;Stream&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;Stream&lt;A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;A&gt; stream<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> stream.inits<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns the position of the first element matching the given predicate, if any.
   *
   * @param p A predicate to match.
   * @return the position of the first element matching the given predicate, if any.
   */</span>
  public <span class="keyword">final</span> <a href="Option.java.html#10291" title="fj.data.Option">Option</a>&lt;Integer&gt; <a title="(p: fj.F[A,java.lang.Boolean])fj.data.Option[java.lang.Integer]" id="18060">indexOf</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10366" title="A">A</a>, Boolean&gt; <a title="fj.F[A,java.lang.Boolean]" id="30677">p</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> zipIndex<span class="delimiter">(</span><span class="delimiter">)</span>.find<span class="delimiter">(</span><span class="keyword">new</span> F&lt;P2&lt;A, Integer&gt;, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> P2&lt;A, Integer&gt; p2<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> p.f<span class="delimiter">(</span>p2._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>.map<span class="delimiter">(</span>P2.&lt;A, Integer&gt;__2<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Applies a stream of comonadic functions to this stream, returning a stream of values.
   *
   * @param fs A stream of comonadic functions to apply to this stream.
   * @return A new stream of the results of applying the stream of functions to this stream.
   */</span>
  public <span class="keyword">final</span> &lt;<a title="Nothing" id="18063">B</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#18063" title="B">B</a>&gt; <a title="[B](fs: fj.data.Stream[fj.F[fj.data.Stream[A],B]])fj.data.Stream[B]" id="18061">sequenceW</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;F&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10366" title="A">A</a>&gt;, <a href="#18063" title="B">B</a>&gt;&gt; <a title="fj.data.Stream[fj.F[fj.data.Stream[A],B]]" id="30679">fs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> fs.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span>
           ? Stream.&lt;B&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span>
           : cons<span class="delimiter">(</span>fs.head<span class="delimiter">(</span><span class="delimiter">)</span>.f<span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span>, <span class="keyword">new</span> P1&lt;Stream&lt;B&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
             public Stream&lt;B&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
               <span class="keyword">return</span> sequenceW<span class="delimiter">(</span>fs.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
             <span class="delimiter">}</span>
           <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Converts this stream to a function of natural numbers.
   *
   * @return A function from natural numbers to values with the corresponding position in this stream.
   */</span>
  public <span class="keyword">final</span> F&lt;Integer, <a href="#10366" title="A">A</a>&gt; <a title="()fj.F[java.lang.Integer,A]" id="18064">toFunction</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Integer, A&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public A f<span class="delimiter">(</span><span class="keyword">final</span> Integer i<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> index<span class="delimiter">(</span>i<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Converts a function of natural numbers to a stream.
   *
   * @param f The function to convert to a stream.
   * @return A new stream of the results of the given function applied to the natural numbers, starting at 0.
   */</span>
  public static &lt;<a title="Nothing" id="14694">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14694" title="A">A</a>&gt; <a title="[A](f: fj.F[fj.data.Natural,A])fj.data.Stream[A]" id="14692">fromFunction</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="Natural.java.html#10246" title="fj.data.Natural">Natural</a>, <a href="#14694" title="A">A</a>&gt; <a title="fj.F[fj.data.Natural,A]" id="30365">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> fromFunction<span class="delimiter">(</span>Enumerator.naturalEnumerator, f, Natural.ZERO<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Converts a function of an enumerable type to a stream of the results of that function,
   * starting at the given index.
   *
   * @param e An enumerator for the domain of the function.
   * @param f The function to convert to a stream.
   * @param i The index into the function at which to begin the stream.
   * @return A new stream of the results of the given function applied to the values of the given enumerator,
   *         starting at the given value.
   */</span>
  public static &lt;<a title="Nothing" id="14698">A</a>, <a title="Nothing" id="14699">B</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14698" title="A">A</a>&gt; <a title="[A, B](e: fj.data.Enumerator[B], f: fj.F[B,A], i: B)fj.data.Stream[A]" id="14695">fromFunction</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="Enumerator.java.html#10057" title="fj.data.Enumerator">Enumerator</a>&lt;<a href="#14699" title="B">B</a>&gt; <a title="fj.data.Enumerator[B]" id="30368">e</a>, <span class="keyword">final</span> F&lt;<a href="#14699" title="B">B</a>, <a href="#14698" title="A">A</a>&gt; <a title="fj.F[B,A]" id="30369">f</a>, <span class="keyword">final</span> <a href="#14699" title="B">B</a> <a title="B" id="30370">i</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> cons<span class="delimiter">(</span>f.f<span class="delimiter">(</span>i<span class="delimiter">)</span>, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">final</span> Option&lt;B&gt; s = e.successor<span class="delimiter">(</span>i<span class="delimiter">)</span>;
        <span class="keyword">return</span> s.isSome<span class="delimiter">(</span><span class="delimiter">)</span>
               ? fromFunction<span class="delimiter">(</span>e, f, s.some<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
               : Stream.&lt;A&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Transforms a stream of pairs into a stream of first components and a stream of second components.
   *
   * @param xs The stream of pairs to transform.
   * @return A stream of first components and a stream of second components.
   */</span>
  public static &lt;<a title="Nothing" id="14703">A</a>, <a title="Nothing" id="14704">B</a>&gt; P2&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14703" title="A">A</a>&gt;, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14704" title="B">B</a>&gt;&gt; <a title="[A, B](xs: fj.data.Stream[fj.P2[A,B]])fj.P2[fj.data.Stream[A],fj.data.Stream[B]]" id="14700">unzip</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;P2&lt;<a href="#14703" title="A">A</a>, <a href="#14704" title="B">B</a>&gt;&gt; <a title="fj.data.Stream[fj.P2[A,B]]" id="30375">xs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> xs.foldRight<span class="delimiter">(</span><span class="keyword">new</span> F2&lt;P2&lt;A, B&gt;, P1&lt;P2&lt;Stream&lt;A&gt;, Stream&lt;B&gt;&gt;&gt;, P2&lt;Stream&lt;A&gt;, Stream&lt;B&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public P2&lt;Stream&lt;A&gt;, Stream&lt;B&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> P2&lt;A, B&gt; p, <span class="keyword">final</span> P1&lt;P2&lt;Stream&lt;A&gt;, Stream&lt;B&gt;&gt;&gt; ps<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">final</span> P2&lt;Stream&lt;A&gt;, Stream&lt;B&gt;&gt; pp = ps._1<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">return</span> P.p<span class="delimiter">(</span>cons<span class="delimiter">(</span>p._1<span class="delimiter">(</span><span class="delimiter">)</span>, P.p<span class="delimiter">(</span>pp._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>, cons<span class="delimiter">(</span>p._2<span class="delimiter">(</span><span class="delimiter">)</span>, P.p<span class="delimiter">(</span>pp._2<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>, P.p<span class="delimiter">(</span>Stream.&lt;A&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span>, Stream.&lt;B&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A first-class version of the zipWith function.
   *
   * @return a function that zips two given streams with a given function.
   */</span>
  public static &lt;<a title="Nothing" id="14709">A</a>, <a title="Nothing" id="14710">B</a>, <a title="Nothing" id="14711">C</a>&gt; F&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14709" title="A">A</a>&gt;, F&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14710" title="B">B</a>&gt;, F&lt;F&lt;<a href="#14709" title="A">A</a>, F&lt;<a href="#14710" title="B">B</a>, <a href="#14711" title="C">C</a>&gt;&gt;, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14711" title="C">C</a>&gt;&gt;&gt;&gt; <a title="[A, B, C]()fj.F[fj.data.Stream[A],fj.F[fj.data.Stream[B],fj.F[fj.F[A,fj.F[B,C]],fj.data.Stream[C]]]]" id="14705">zipWith</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> curry<span class="delimiter">(</span><span class="keyword">new</span> F3&lt;Stream&lt;A&gt;, Stream&lt;B&gt;, F&lt;A, F&lt;B, C&gt;&gt;, Stream&lt;C&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;C&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;A&gt; as, <span class="keyword">final</span> Stream&lt;B&gt; bs, <span class="keyword">final</span> F&lt;A, F&lt;B, C&gt;&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> as.zipWith<span class="delimiter">(</span>bs, f<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="keyword">private</span> static <span class="keyword">final</span> <span class="keyword">class</span> <a title="object fj.data.Stream.Nil" id="14714">Nil</a>&lt;<a id="14715">A</a>&gt; <span class="keyword">extends</span> Stream&lt;A&gt; <span class="delimiter">{</span>
    public A head<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">throw</span> error<span class="delimiter">(</span><span class="string">&quot;head on empty stream&quot;</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    public P1&lt;Stream&lt;A&gt;&gt; tail<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">throw</span> error<span class="delimiter">(</span><span class="string">&quot;tail on empty stream&quot;</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> static <span class="keyword">final</span> <span class="keyword">class</span> <a title="object fj.data.Stream.Cons" id="14718">Cons</a>&lt;<a id="14719">A</a>&gt; <span class="keyword">extends</span> Stream&lt;A&gt; <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">final</span> A head;
    <span class="keyword">private</span> <span class="keyword">final</span> P1&lt;Stream&lt;A&gt;&gt; tail;

    Cons<span class="delimiter">(</span><span class="keyword">final</span> A head, <span class="keyword">final</span> P1&lt;Stream&lt;A&gt;&gt; tail<span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">this</span>.head = head;
      <span class="keyword">this</span>.tail = tail.memo<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    public A head<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> head;
    <span class="delimiter">}</span>

    public P1&lt;Stream&lt;A&gt;&gt; tail<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> tail;
    <span class="delimiter">}</span>

  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a function that prepends (cons) an element to a stream to produce a new stream.
   *
   * @return A function that prepends (cons) an element to a stream to produce a new stream.
   */</span>
  public static &lt;<a title="Nothing" id="14722">A</a>&gt; F&lt;<a href="#14722" title="A">A</a>, F&lt;P1&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14722" title="A">A</a>&gt;&gt;, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14722" title="A">A</a>&gt;&gt;&gt; <a title="[A]()fj.F[A,fj.F[fj.P1[fj.data.Stream[A]],fj.data.Stream[A]]]" id="14720">cons</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;A, F&lt;P1&lt;Stream&lt;A&gt;&gt;, Stream&lt;A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public F&lt;P1&lt;Stream&lt;A&gt;&gt;, Stream&lt;A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> A a<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> F&lt;P1&lt;Stream&lt;A&gt;&gt;, Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Stream&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> P1&lt;Stream&lt;A&gt;&gt; list<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> cons<span class="delimiter">(</span>a, list<span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a function that prepends (cons) an element to a stream to produce a new stream.
   *
   * @return A function that prepends (cons) an element to a stream to produce a new stream.
   */</span>
  public static &lt;<a title="Nothing" id="14725">A</a>&gt; F&lt;<a href="#14725" title="A">A</a>, F&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14725" title="A">A</a>&gt;, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14725" title="A">A</a>&gt;&gt;&gt; <a title="[A]()fj.F[A,fj.F[fj.data.Stream[A],fj.data.Stream[A]]]" id="14723">cons_</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> curry<span class="delimiter">(</span><span class="keyword">new</span> F2&lt;A, Stream&lt;A&gt;, Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> A a, <span class="keyword">final</span> Stream&lt;A&gt; as<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> as.cons<span class="delimiter">(</span>a<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns an empty stream.
   *
   * @return An empty stream.
   */</span>
  public static &lt;<a title="Nothing" id="14728">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14728" title="A">A</a>&gt; <a title="[A]()fj.data.Stream[A]" id="14726">nil</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> Nil&lt;A&gt;<span class="delimiter">(</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns an empty stream.
   *
   * @return An empty stream.
   */</span>
  public static &lt;<a title="Nothing" id="14731">A</a>&gt; P1&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14731" title="A">A</a>&gt;&gt; <a title="[A]()fj.P1[fj.data.Stream[A]]" id="14729">nil_</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> <span class="keyword">new</span> Nil&lt;A&gt;<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a function that determines whether a given stream is empty.
   *
   * @return A function that determines whether a given stream is empty.
   */</span>
  public static &lt;<a title="Nothing" id="14734">A</a>&gt; F&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14734" title="A">A</a>&gt;, Boolean&gt; <a title="[A]()fj.F[fj.data.Stream[A],java.lang.Boolean]" id="14732">isEmpty_</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Stream&lt;A&gt;, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;A&gt; as<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> as.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a function that determines whether a given stream is not empty.
   *
   * @return A function that determines whether a given stream is not empty.
   */</span>
  public static &lt;<a title="Nothing" id="14737">A</a>&gt; F&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14737" title="A">A</a>&gt;, Boolean&gt; <a title="[A]()fj.F[fj.data.Stream[A],java.lang.Boolean]" id="14735">isNotEmpty_</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Stream&lt;A&gt;, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;A&gt; as<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> as.isNotEmpty<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a stream of one element containing the given value.
   *
   * @param a The value for the head of the returned stream.
   * @return A stream of one element containing the given value.
   */</span>
  public static &lt;<a title="Nothing" id="14740">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14740" title="A">A</a>&gt; <a title="[A](a: A)fj.data.Stream[A]" id="14738">single</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#14740" title="A">A</a> <a title="A" id="30387">a</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> cons<span class="delimiter">(</span>a, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> nil<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a function that yields a stream containing its argument.
   *
   * @return a function that yields a stream containing its argument.
   */</span>
  public static &lt;<a title="Nothing" id="14743">A</a>&gt; F&lt;<a href="#14743" title="A">A</a>, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14743" title="A">A</a>&gt;&gt; <a title="[A]()fj.F[A,fj.data.Stream[A]]" id="14741">single</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;A, Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> A a<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> single<span class="delimiter">(</span>a<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Prepends the given head element to the given tail element to produce a new stream.
   *
   * @param head The element to prepend.
   * @param tail The stream to prepend to.
   * @return The stream with the given element prepended.
   */</span>
  public static &lt;<a title="Nothing" id="14746">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14746" title="A">A</a>&gt; <a title="[A](head: A, tail: fj.P1[fj.data.Stream[A]])fj.data.Stream[A]" id="14744">cons</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#14746" title="A">A</a> <a title="A" id="30391">head</a>, <span class="keyword">final</span> P1&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14746" title="A">A</a>&gt;&gt; <a title="fj.P1[fj.data.Stream[A]]" id="30392">tail</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> Cons&lt;A&gt;<span class="delimiter">(</span>head, tail<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Joins the given stream of streams by concatenation.
   *
   * @param o The stream of streams to join.
   * @return A new stream that is the join of the given streams.
   */</span>
  public static &lt;<a title="Nothing" id="14749">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14749" title="A">A</a>&gt; <a title="[A](o: fj.data.Stream[fj.data.Stream[A]])fj.data.Stream[A]" id="14747">join</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14749" title="A">A</a>&gt;&gt; <a title="fj.data.Stream[fj.data.Stream[A]]" id="30396">o</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> Monoid.&lt;A&gt;streamMonoid<span class="delimiter">(</span><span class="delimiter">)</span>.sumRight<span class="delimiter">(</span>o<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A first-class version of join
   *
   * @return A function that joins a stream of streams using a bind operation.
   */</span>
  public static &lt;<a title="Nothing" id="14752">A</a>&gt; F&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14752" title="A">A</a>&gt;&gt;, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14752" title="A">A</a>&gt;&gt; <a title="[A]()fj.F[fj.data.Stream[fj.data.Stream[A]],fj.data.Stream[A]]" id="14750">join</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> F&lt;Stream&lt;Stream&lt;A&gt;&gt;, Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;Stream&lt;A&gt;&gt; as<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> join<span class="delimiter">(</span>as<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Unfolds across the given function starting at the given value to produce a stream.
   *
   * @param f The function to unfold across.
   * @param b The start value to begin the unfold.
   * @return A new stream that is a result of unfolding until the function does not produce a
   *         value.
   */</span>
  public static &lt;<a title="Nothing" id="14756">A</a>, <a title="Nothing" id="14757">B</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14756" title="A">A</a>&gt; <a title="[A, B](f: fj.F[B,fj.data.Option[fj.P2[A,B]]], b: B)fj.data.Stream[A]" id="14753">unfold</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#14757" title="B">B</a>, <a href="Option.java.html#10291" title="fj.data.Option">Option</a>&lt;P2&lt;<a href="#14756" title="A">A</a>, <a href="#14757" title="B">B</a>&gt;&gt;&gt; <a title="fj.F[B,fj.data.Option[fj.P2[A,B]]]" id="30400">f</a>, <span class="keyword">final</span> <a href="#14757" title="B">B</a> <a title="B" id="30401">b</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> Option&lt;P2&lt;A, B&gt;&gt; o = f.f<span class="delimiter">(</span>b<span class="delimiter">)</span>;
    <span class="keyword">if</span> <span class="delimiter">(</span>o.isNone<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">return</span> nil<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">final</span> P2&lt;A, B&gt; p = o.some<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="keyword">return</span> cons<span class="delimiter">(</span>p._1<span class="delimiter">(</span><span class="delimiter">)</span>, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> unfold<span class="delimiter">(</span>f, p._2<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Creates a stream where the first item is calculated by applying the function on the third argument,
   * the second item by applying the function on the previous result and so on.
   *
   * @param f The function to iterate with.
   * @param p The predicate which must be true for the next item in order to continue the iteration.
   * @param a The input to the first iteration.
   * @return A stream where the first item is calculated by applying the function on the third argument,
   *         the second item by applying the function on the previous result and so on.
   */</span>
  public static &lt;<a title="Nothing" id="14760">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14760" title="A">A</a>&gt; <a title="[A](f: fj.F[A,A], p: fj.F[A,java.lang.Boolean], a: A)fj.data.Stream[A]" id="14758">iterateWhile</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#14760" title="A">A</a>, <a href="#14760" title="A">A</a>&gt; <a title="fj.F[A,A]" id="30405">f</a>, <span class="keyword">final</span> F&lt;<a href="#14760" title="A">A</a>, Boolean&gt; <a title="fj.F[A,java.lang.Boolean]" id="30406">p</a>, <span class="keyword">final</span> <a href="#14760" title="A">A</a> <a title="A" id="30407">a</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> unfold<span class="delimiter">(</span>
        <span class="keyword">new</span> F&lt;A, Option&lt;P2&lt;A, A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Option&lt;P2&lt;A, A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> A o<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> Option.iif<span class="delimiter">(</span><span class="keyword">new</span> F&lt;P2&lt;A, A&gt;, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> P2&lt;A, A&gt; p2<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">return</span> p.f<span class="delimiter">(</span>o<span class="delimiter">)</span>;
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>, P.p<span class="delimiter">(</span>o, f.f<span class="delimiter">(</span>o<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        , a<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Takes the given iterable to a stream.
   *
   * @param i The iterable to take to a stream.
   * @return A stream from the given iterable.
   */</span>
  public static &lt;<a title="Nothing" id="14763">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14763" title="A">A</a>&gt; <a title="[A](i: java.lang.Iterable[A])fj.data.Stream[A]" id="14761">iterableStream</a><span class="delimiter">(</span><span class="keyword">final</span> Iterable&lt;<a href="#14763" title="A">A</a>&gt; <a title="java.lang.Iterable[A]" id="30412">i</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">final</span> <span class="keyword">class</span> Util <span class="delimiter">{</span>
      public &lt;A&gt; Stream&lt;A&gt; iteratorStream<span class="delimiter">(</span><span class="keyword">final</span> Iterator&lt;A&gt; i<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>i.hasNext<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">final</span> A a = i.next<span class="delimiter">(</span><span class="delimiter">)</span>;
          <span class="keyword">return</span> cons<span class="delimiter">(</span>a, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">return</span> iteratorStream<span class="delimiter">(</span>i<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
          <span class="delimiter">}</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">else</span>
          <span class="keyword">return</span> nil<span class="delimiter">(</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">return</span> <span class="keyword">new</span> Util<span class="delimiter">(</span><span class="delimiter">)</span>.iteratorStream<span class="delimiter">(</span>i.iterator<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns an infinite-length stream of the given element.
   *
   * @param a The element to repeat infinitely.
   * @return An infinite-length stream of the given element.
   */</span>
  public static &lt;<a title="Nothing" id="14766">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14766" title="A">A</a>&gt; <a title="[A](a: A)fj.data.Stream[A]" id="14764">repeat</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#14766" title="A">A</a> <a title="A" id="30415">a</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> cons<span class="delimiter">(</span>a, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> repeat<span class="delimiter">(</span>a<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns an infinite-length stream of the given elements cycling. Fails on the empty stream.
   *
   * @param as The elements to cycle infinitely. This must not be empty.
   * @return An infinite-length stream of the given elements cycling.
   */</span>
  public static &lt;<a title="Nothing" id="14769">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14769" title="A">A</a>&gt; <a title="[A](as: fj.data.Stream[A])fj.data.Stream[A]" id="14767">cycle</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14769" title="A">A</a>&gt; <a title="fj.data.Stream[A]" id="30418">as</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">if</span> <span class="delimiter">(</span>as.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">throw</span> error<span class="delimiter">(</span><span class="string">&quot;cycle on empty list&quot;</span><span class="delimiter">)</span>;
    <span class="keyword">else</span>
      <span class="keyword">return</span> as.append<span class="delimiter">(</span><span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> cycle<span class="delimiter">(</span>as<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a stream constructed by applying the given iteration function starting at the given value.
   *
   * @param f The iteration function.
   * @param a The value to begin iterating from.
   * @return A stream constructed by applying the given iteration function starting at the given value.
   */</span>
  public static &lt;<a title="Nothing" id="14772">A</a>&gt; <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14772" title="A">A</a>&gt; <a title="[A](f: fj.F[A,A], a: A)fj.data.Stream[A]" id="14770">iterate</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#14772" title="A">A</a>, <a href="#14772" title="A">A</a>&gt; <a title="fj.F[A,A]" id="30421">f</a>, <span class="keyword">final</span> <a href="#14772" title="A">A</a> <a title="A" id="30422">a</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> cons<span class="delimiter">(</span>a, <span class="keyword">new</span> P1&lt;Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> iterate<span class="delimiter">(</span>f, f.f<span class="delimiter">(</span>a<span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A first-class version of the iterate function.
   *
   * @return A function that returns a stream constructed by applying a given iteration function
   *         starting at a given value.
   */</span>
  public static &lt;<a title="Nothing" id="14775">A</a>&gt; F&lt;F&lt;<a href="#14775" title="A">A</a>, <a href="#14775" title="A">A</a>&gt;, F&lt;<a href="#14775" title="A">A</a>, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14775" title="A">A</a>&gt;&gt;&gt; <a title="[A]()fj.F[fj.F[A,A],fj.F[A,fj.data.Stream[A]]]" id="14773">iterate</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> curry<span class="delimiter">(</span><span class="keyword">new</span> F2&lt;F&lt;A, A&gt;, A, Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, A&gt; f, <span class="keyword">final</span> A a<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> iterate<span class="delimiter">(</span>f, a<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A first-class version of the bind function.
   *
   * @return A function that binds a given function across a given stream, joining the resulting streams.
   */</span>
  public static &lt;<a title="Nothing" id="14779">A</a>, <a title="Nothing" id="14780">B</a>&gt; F&lt;F&lt;<a href="#14779" title="A">A</a>, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14780" title="B">B</a>&gt;&gt;, F&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14779" title="A">A</a>&gt;, <a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14780" title="B">B</a>&gt;&gt;&gt; <a title="[A, B]()fj.F[fj.F[A,fj.data.Stream[B]],fj.F[fj.data.Stream[A],fj.data.Stream[B]]]" id="14776">bind_</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> curry<span class="delimiter">(</span><span class="keyword">new</span> F2&lt;F&lt;A, Stream&lt;B&gt;&gt;, Stream&lt;A&gt;, Stream&lt;B&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Stream&lt;B&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, Stream&lt;B&gt;&gt; f, <span class="keyword">final</span> Stream&lt;A&gt; as<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> as.bind<span class="delimiter">(</span>f<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A first-class version of the foldRight function.
   *
   * @return A function that folds a given stream with a given function.
   */</span>
  public static &lt;<a title="Nothing" id="14784">A</a>, <a title="Nothing" id="14785">B</a>&gt; F&lt;F&lt;<a href="#14784" title="A">A</a>, F&lt;P1&lt;<a href="#14785" title="B">B</a>&gt;, <a href="#14785" title="B">B</a>&gt;&gt;, F&lt;<a href="#14785" title="B">B</a>, F&lt;<a href="#10365" title="fj.data.Stream">Stream</a>&lt;<a href="#14784" title="A">A</a>&gt;, <a href="#14785" title="B">B</a>&gt;&gt;&gt; <a title="[A, B]()fj.F[fj.F[A,fj.F[fj.P1[B],B]],fj.F[B,fj.F[fj.data.Stream[A],B]]]" id="14781">foldRight</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> curry<span class="delimiter">(</span><span class="keyword">new</span> F3&lt;F&lt;A, F&lt;P1&lt;B&gt;, B&gt;&gt;, B, Stream&lt;A&gt;, B&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public B f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, F&lt;P1&lt;B&gt;, B&gt;&gt; f, <span class="keyword">final</span> B b, <span class="keyword">final</span> Stream&lt;A&gt; as<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> as.foldRight<span class="delimiter">(</span>f, b<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>