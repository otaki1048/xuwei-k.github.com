<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>fj/parser/Parser.java</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> fj.parser;

<span class="keyword">import</span> fj.F;
<span class="keyword">import</span> static fj.P.p;
<span class="keyword">import</span> fj.P1;
<span class="keyword">import</span> fj.Semigroup;
<span class="keyword">import</span> fj.Unit;
<span class="keyword">import</span> fj.Digit;
<span class="keyword">import</span> static fj.Unit.unit;
<span class="keyword">import</span> fj.data.List;
<span class="keyword">import</span> static fj.data.List.cons_;
<span class="keyword">import</span> fj.data.Stream;
<span class="keyword">import</span> fj.data.Validation;
<span class="keyword">import</span> static fj.data.Validation.success;
<span class="keyword">import</span> static fj.parser.Result.result;

<span class="comment">/**
 * A parser is a function that takes some input (I) and produces either an error (E) or a parse result (A) and the
 * remainder of the input.
 *
 * @version %build.number%
 */</span>
public <span class="keyword">final</span> <span class="keyword">class</span> <a title="object fj.parser.Parser" id="10890">Parser</a>&lt;<a title="Nothing" id="10891">I</a>, <a title="Nothing" id="10892">A</a>, <a title="Nothing" id="10893">E</a>&gt; <span class="delimiter">{</span>
  <span class="keyword">private</span> <span class="keyword">final</span> F&lt;<a href="#10891" title="I">I</a>, Validation&lt;<a href="#10893" title="E">E</a>, <a href="Result.java.html#10902" title="fj.parser.Result">Result</a>&lt;<a href="#10891" title="I">I</a>, <a href="#10892" title="A">A</a>&gt;&gt;&gt; <a title="fj.F[I,fj.data.Validation[E,fj.parser.Result[I,A]]]" id="33815">f</a>;

  <span class="keyword">private</span> Parser<span class="delimiter">(</span><span class="keyword">final</span> F&lt;I, Validation&lt;E, Result&lt;I, A&gt;&gt;&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">this</span>.f = f;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Parses the input to produce a result or error.
   *
   * @param i The input to parse.
   * @return A parse result with the remaining input or an error.
   */</span>
  public Validation&lt;<a href="#10893" title="E">E</a>, <a href="Result.java.html#10902" title="fj.parser.Result">Result</a>&lt;<a href="#10891" title="I">I</a>, <a href="#10892" title="A">A</a>&gt;&gt; <a title="(i: I)fj.data.Validation[E,fj.parser.Result[I,A]]" id="33817">parse</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10891" title="I">I</a> <a title="I" id="34379">i</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> f.f<span class="delimiter">(</span>i<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps the parse input type through an invariant functor.
   *
   * @param f The function to covariant map.
   * @param g The function to contra-variant map.
   * @return A parser with the new input type.
   */</span>
  public &lt;<a title="Nothing" id="33820">Z</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#33820" title="Z">Z</a>, <a href="#10892" title="A">A</a>, <a href="#10893" title="E">E</a>&gt; <a title="[Z](f: fj.F[I,Z], g: fj.F[Z,I])fj.parser.Parser[Z,A,E]" id="33818">xmap</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10891" title="I">I</a>, <a href="#33820" title="Z">Z</a>&gt; <a title="fj.F[I,Z]" id="34380">f</a>, <span class="keyword">final</span> F&lt;<a href="#33820" title="Z">Z</a>, <a href="#10891" title="I">I</a>&gt; <a title="fj.F[Z,I]" id="34381">g</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parser<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Z, Validation&lt;E, Result&lt;Z, A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Validation&lt;E, Result&lt;Z, A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Z z<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parse<span class="delimiter">(</span>g.f<span class="delimiter">(</span>z<span class="delimiter">)</span><span class="delimiter">)</span>.map<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Result&lt;I, A&gt;, Result&lt;Z, A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Result&lt;Z, A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Result&lt;I, A&gt; r<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> r.mapRest<span class="delimiter">(</span>f<span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps the given result type across this parser.
   *
   * @param f The function to map.
   * @return A parser with the new result type.
   */</span>
  public &lt;<a title="Nothing" id="33823">B</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33823" title="B">B</a>, <a href="#10893" title="E">E</a>&gt; <a title="[B](f: fj.F[A,B])fj.parser.Parser[I,B,E]" id="33821">map</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10892" title="A">A</a>, <a href="#33823" title="B">B</a>&gt; <a title="fj.F[A,B]" id="34384">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parser<span class="delimiter">(</span><span class="keyword">new</span> F&lt;I, Validation&lt;E, Result&lt;I, B&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Validation&lt;E, Result&lt;I, B&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> I i<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parse<span class="delimiter">(</span>i<span class="delimiter">)</span>.map<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Result&lt;I, A&gt;, Result&lt;I, B&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Result&lt;I, B&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Result&lt;I, A&gt; r<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> r.mapValue<span class="delimiter">(</span>f<span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a parser that fails with the given error if the result value does not meet the given predicate.
   *
   * @param f The predicate to filter on.
   * @param e The error to in the event that the predicate is not met.
   * @return A parser that fails with the given error if the result value does not meet the given predicate.
   */</span>
  public <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#10892" title="A">A</a>, <a href="#10893" title="E">E</a>&gt; <a title="(f: fj.F[A,java.lang.Boolean], e: E)fj.parser.Parser[I,A,E]" id="33824">filter</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10892" title="A">A</a>, Boolean&gt; <a title="fj.F[A,java.lang.Boolean]" id="34386">f</a>, <span class="keyword">final</span> <a href="#10893" title="E">E</a> <a title="E" id="34387">e</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parser<span class="delimiter">(</span><span class="keyword">new</span> F&lt;I, Validation&lt;E, Result&lt;I, A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Validation&lt;E, Result&lt;I, A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> I i<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parse<span class="delimiter">(</span>i<span class="delimiter">)</span>.bind<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Result&lt;I, A&gt;, Validation&lt;E, Result&lt;I, A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Validation&lt;E, Result&lt;I, A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Result&lt;I, A&gt; r<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">final</span> A v = r.value<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">return</span> f.f<span class="delimiter">(</span>v<span class="delimiter">)</span> ?
                Validation.&lt;E, Result&lt;I, A&gt;&gt;success<span class="delimiter">(</span>result<span class="delimiter">(</span>r.rest<span class="delimiter">(</span><span class="delimiter">)</span>, v<span class="delimiter">)</span><span class="delimiter">)</span> :
                Validation.&lt;E, Result&lt;I, A&gt;&gt;fail<span class="delimiter">(</span>e<span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across the parser with a final join.
   *
   * @param f The function to apply to the element of this parser.
   * @return A new parser after performing the map, then final join.
   */</span>
  public &lt;<a title="Nothing" id="33827">B</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33827" title="B">B</a>, <a href="#10893" title="E">E</a>&gt; <a title="[B](f: fj.F[A,fj.parser.Parser[I,B,E]])fj.parser.Parser[I,B,E]" id="33825">bind</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10892" title="A">A</a>, <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33827" title="B">B</a>, <a href="#10893" title="E">E</a>&gt;&gt; <a title="fj.F[A,fj.parser.Parser[I,B,E]]" id="34388">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parser<span class="delimiter">(</span><span class="keyword">new</span> F&lt;I, Validation&lt;E, Result&lt;I, B&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Validation&lt;E, Result&lt;I, B&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> I i<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parse<span class="delimiter">(</span>i<span class="delimiter">)</span>.bind<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Result&lt;I, A&gt;, Validation&lt;E, Result&lt;I, B&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Validation&lt;E, Result&lt;I, B&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Result&lt;I, A&gt; r<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> f.f<span class="delimiter">(</span>r.value<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.parse<span class="delimiter">(</span>r.rest<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across the parsers with a final join.
   *
   * @param f  The function to apply to the element of the parsers.
   * @param pb A given parser to bind the given function with.
   * @return A new parser after performing the map, then final join.
   */</span>
  public &lt;<a title="Nothing" id="33831">B</a>, <a title="Nothing" id="33832">C</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33832" title="C">C</a>, <a href="#10893" title="E">E</a>&gt; <a title="[B, C](pb: fj.parser.Parser[I,B,E], f: fj.F[A,fj.F[B,C]])fj.parser.Parser[I,C,E]" id="33828">bind</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33831" title="B">B</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,B,E]" id="34390">pb</a>, <span class="keyword">final</span> F&lt;<a href="#10892" title="A">A</a>, F&lt;<a href="#33831" title="B">B</a>, <a href="#33832" title="C">C</a>&gt;&gt; <a title="fj.F[A,fj.F[B,C]]" id="34391">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> pb.apply<span class="delimiter">(</span>map<span class="delimiter">(</span>f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across the parsers with a final join.
   *
   * @param f  The function to apply to the element of the parsers.
   * @param pb A given parser to bind the given function with.
   * @param pc A given parser to bind the given function with.
   * @return A new parser after performing the map, then final join.
   */</span>
  public &lt;<a title="Nothing" id="33837">B</a>, <a title="Nothing" id="33838">C</a>, <a title="Nothing" id="33839">D</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33839" title="D">D</a>, <a href="#10893" title="E">E</a>&gt; <a title="[B, C, D](pb: fj.parser.Parser[I,B,E], pc: fj.parser.Parser[I,C,E], f: fj.F[A,fj.F[B,fj.F[C,D]]])fj.parser.Parser[I,D,E]" id="33833">bind</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33837" title="B">B</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,B,E]" id="34394">pb</a>, <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33838" title="C">C</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,C,E]" id="34395">pc</a>,
                                        <span class="keyword">final</span> F&lt;<a href="#10892" title="A">A</a>, F&lt;<a href="#33837" title="B">B</a>, F&lt;<a href="#33838" title="C">C</a>, <a href="#33839" title="D">D</a>&gt;&gt;&gt; <a title="fj.F[A,fj.F[B,fj.F[C,D]]]" id="34396">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> pc.apply<span class="delimiter">(</span>bind<span class="delimiter">(</span>pb, f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across the parsers with a final join.
   *
   * @param f  The function to apply to the element of the parsers.
   * @param pb A given parser to bind the given function with.
   * @param pc A given parser to bind the given function with.
   * @param pd A given parser to bind the given function with.
   * @return A new parser after performing the map, then final join.
   */</span>
  public &lt;<a title="Nothing" id="33845">B</a>, <a title="Nothing" id="33846">C</a>, <a title="Nothing" id="33847">D</a>, <a title="Nothing" id="33848">E$</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33848" title="E$">E$</a>, <a href="#10893" title="E">E</a>&gt; <a title="[B, C, D, E$](pb: fj.parser.Parser[I,B,E], pc: fj.parser.Parser[I,C,E], pd: fj.parser.Parser[I,D,E], f: fj.F[A,fj.F[B,fj.F[C,fj.F[D,E$]]]])fj.parser.Parser[I,E$,E]" id="33840">bind</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33845" title="B">B</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,B,E]" id="34400">pb</a>, <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33846" title="C">C</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,C,E]" id="34401">pc</a>,
                                             <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33847" title="D">D</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,D,E]" id="34402">pd</a>, <span class="keyword">final</span> F&lt;<a href="#10892" title="A">A</a>, F&lt;<a href="#33845" title="B">B</a>, F&lt;<a href="#33846" title="C">C</a>, F&lt;<a href="#33847" title="D">D</a>, <a href="#33848" title="E$">E$</a>&gt;&gt;&gt;&gt; <a title="fj.F[A,fj.F[B,fj.F[C,fj.F[D,E$]]]]" id="34403">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> pd.apply<span class="delimiter">(</span>bind<span class="delimiter">(</span>pb, pc, f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across the parsers with a final join.
   *
   * @param f  The function to apply to the element of the parsers.
   * @param pb A given parser to bind the given function with.
   * @param pc A given parser to bind the given function with.
   * @param pd A given parser to bind the given function with.
   * @param pe A given parser to bind the given function with.
   * @return A new parser after performing the map, then final join.
   */</span>
  public &lt;<a title="Nothing" id="33855">B</a>, <a title="Nothing" id="33856">C</a>, <a title="Nothing" id="33857">D</a>, <a title="Nothing" id="33858">E$</a>, <a title="Nothing" id="33859">F$</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33859" title="F$">F$</a>, <a href="#10893" title="E">E</a>&gt; <a title="[B, C, D, E$, F$](pb: fj.parser.Parser[I,B,E], pc: fj.parser.Parser[I,C,E], pd: fj.parser.Parser[I,D,E], pe: fj.parser.Parser[I,E$,E], f: fj.F[A,fj.F[B,fj.F[C,fj.F[D,fj.F[E$,F$]]]]])fj.parser.Parser[I,F$,E]" id="33849">bind</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33855" title="B">B</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,B,E]" id="34408">pb</a>, <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33856" title="C">C</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,C,E]" id="34409">pc</a>,
                                                 <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33857" title="D">D</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,D,E]" id="34410">pd</a>, <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33858" title="E$">E$</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,E$,E]" id="34411">pe</a>,
                                                 <span class="keyword">final</span> F&lt;<a href="#10892" title="A">A</a>, F&lt;<a href="#33855" title="B">B</a>, F&lt;<a href="#33856" title="C">C</a>, F&lt;<a href="#33857" title="D">D</a>, F&lt;<a href="#33858" title="E$">E$</a>, <a href="#33859" title="F$">F$</a>&gt;&gt;&gt;&gt;&gt; <a title="fj.F[A,fj.F[B,fj.F[C,fj.F[D,fj.F[E$,F$]]]]]" id="34412">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> pe.apply<span class="delimiter">(</span>bind<span class="delimiter">(</span>pb, pc, pd, f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across the parsers with a final join.
   *
   * @param f  The function to apply to the element of the parsers.
   * @param pb A given parser to bind the given function with.
   * @param pc A given parser to bind the given function with.
   * @param pd A given parser to bind the given function with.
   * @param pe A given parser to bind the given function with.
   * @param pf A given parser to bind the given function with.
   * @return A new parser after performing the map, then final join.
   */</span>
  public &lt;<a title="Nothing" id="33867">B</a>, <a title="Nothing" id="33868">C</a>, <a title="Nothing" id="33869">D</a>, <a title="Nothing" id="33870">E$</a>, <a title="Nothing" id="33871">F$</a>, <a title="Nothing" id="33872">G</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33872" title="G">G</a>, <a href="#10893" title="E">E</a>&gt; <a title="[B, C, D, E$, F$, G](pb: fj.parser.Parser[I,B,E], pc: fj.parser.Parser[I,C,E], pd: fj.parser.Parser[I,D,E], pe: fj.parser.Parser[I,E$,E], pf: fj.parser.Parser[I,F$,E], f: fj.F[A,fj.F[B,fj.F[C,fj.F[D,fj.F[E$,fj.F[F$,G]]]]]])fj.parser.Parser[I,G,E]" id="33860">bind</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33867" title="B">B</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,B,E]" id="34418">pb</a>, <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33868" title="C">C</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,C,E]" id="34419">pc</a>,
                                                   <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33869" title="D">D</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,D,E]" id="34420">pd</a>, <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33870" title="E$">E$</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,E$,E]" id="34421">pe</a>,
                                                   <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33871" title="F$">F$</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,F$,E]" id="34422">pf</a>,
                                                   <span class="keyword">final</span> F&lt;<a href="#10892" title="A">A</a>, F&lt;<a href="#33867" title="B">B</a>, F&lt;<a href="#33868" title="C">C</a>, F&lt;<a href="#33869" title="D">D</a>, F&lt;<a href="#33870" title="E$">E$</a>, F&lt;<a href="#33871" title="F$">F$</a>, <a href="#33872" title="G">G</a>&gt;&gt;&gt;&gt;&gt;&gt; <a title="fj.F[A,fj.F[B,fj.F[C,fj.F[D,fj.F[E$,fj.F[F$,G]]]]]]" id="34423">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> pf.apply<span class="delimiter">(</span>bind<span class="delimiter">(</span>pb, pc, pd, pe, f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across the parsers with a final join.
   *
   * @param f  The function to apply to the element of the parsers.
   * @param pb A given parser to bind the given function with.
   * @param pc A given parser to bind the given function with.
   * @param pd A given parser to bind the given function with.
   * @param pe A given parser to bind the given function with.
   * @param pf A given parser to bind the given function with.
   * @param pg A given parser to bind the given function with.
   * @return A new parser after performing the map, then final join.
   */</span>
  public &lt;<a title="Nothing" id="33881">B</a>, <a title="Nothing" id="33882">C</a>, <a title="Nothing" id="33883">D</a>, <a title="Nothing" id="33884">E$</a>, <a title="Nothing" id="33885">F$</a>, <a title="Nothing" id="33886">G</a>, <a title="Nothing" id="33887">H</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33887" title="H">H</a>, <a href="#10893" title="E">E</a>&gt; <a title="[B, C, D, E$, F$, G, H](pb: fj.parser.Parser[I,B,E], pc: fj.parser.Parser[I,C,E], pd: fj.parser.Parser[I,D,E], pe: fj.parser.Parser[I,E$,E], pf: fj.parser.Parser[I,F$,E], pg: fj.parser.Parser[I,G,E], f: fj.F[A,fj.F[B,fj.F[C,fj.F[D,fj.F[E$,fj.F[F$,fj.F[G,H]]]]]]])fj.parser.Parser[I,H,E]" id="33873">bind</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33881" title="B">B</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,B,E]" id="34430">pb</a>, <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33882" title="C">C</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,C,E]" id="34431">pc</a>,
                                                      <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33883" title="D">D</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,D,E]" id="34432">pd</a>, <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33884" title="E$">E$</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,E$,E]" id="34433">pe</a>,
                                                      <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33885" title="F$">F$</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,F$,E]" id="34434">pf</a>, <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33886" title="G">G</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,G,E]" id="34435">pg</a>,
                                                      <span class="keyword">final</span> F&lt;<a href="#10892" title="A">A</a>, F&lt;<a href="#33881" title="B">B</a>, F&lt;<a href="#33882" title="C">C</a>, F&lt;<a href="#33883" title="D">D</a>, F&lt;<a href="#33884" title="E$">E$</a>, F&lt;<a href="#33885" title="F$">F$</a>, F&lt;<a href="#33886" title="G">G</a>, <a href="#33887" title="H">H</a>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <a title="fj.F[A,fj.F[B,fj.F[C,fj.F[D,fj.F[E$,fj.F[F$,fj.F[G,H]]]]]]]" id="34436">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> pg.apply<span class="delimiter">(</span>bind<span class="delimiter">(</span>pb, pc, pd, pe, pf, f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds the given function across the parsers with a final join.
   *
   * @param f  The function to apply to the element of the parsers.
   * @param pb A given parser to bind the given function with.
   * @param pc A given parser to bind the given function with.
   * @param pd A given parser to bind the given function with.
   * @param pe A given parser to bind the given function with.
   * @param pf A given parser to bind the given function with.
   * @param pg A given parser to bind the given function with.
   * @param ph A given parser to bind the given function with.
   * @return A new parser after performing the map, then final join.
   */</span>
  public &lt;<a title="Nothing" id="33897">B</a>, <a title="Nothing" id="33898">C</a>, <a title="Nothing" id="33899">D</a>, <a title="Nothing" id="33900">E$</a>, <a title="Nothing" id="33901">F$</a>, <a title="Nothing" id="33902">G</a>, <a title="Nothing" id="33903">H</a>, <a title="Nothing" id="33904">I$</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33904" title="I$">I$</a>, <a href="#10893" title="E">E</a>&gt; <a title="[B, C, D, E$, F$, G, H, I$](pb: fj.parser.Parser[I,B,E], pc: fj.parser.Parser[I,C,E], pd: fj.parser.Parser[I,D,E], pe: fj.parser.Parser[I,E$,E], pf: fj.parser.Parser[I,F$,E], pg: fj.parser.Parser[I,G,E], ph: fj.parser.Parser[I,H,E], f: fj.F[A,fj.F[B,fj.F[C,fj.F[D,fj.F[E$,fj.F[F$,fj.F[G,fj.F[H,I$]]]]]]]])fj.parser.Parser[I,I$,E]" id="33888">bind</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33897" title="B">B</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,B,E]" id="34444">pb</a>, <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33898" title="C">C</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,C,E]" id="34445">pc</a>,
                                                           <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33899" title="D">D</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,D,E]" id="34446">pd</a>, <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33900" title="E$">E$</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,E$,E]" id="34447">pe</a>,
                                                           <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33901" title="F$">F$</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,F$,E]" id="34448">pf</a>, <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33902" title="G">G</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,G,E]" id="34449">pg</a>,
                                                           <span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33903" title="H">H</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,H,E]" id="34450">ph</a>,
                                                           <span class="keyword">final</span> F&lt;<a href="#10892" title="A">A</a>, F&lt;<a href="#33897" title="B">B</a>, F&lt;<a href="#33898" title="C">C</a>, F&lt;<a href="#33899" title="D">D</a>, F&lt;<a href="#33900" title="E$">E$</a>, F&lt;<a href="#33901" title="F$">F$</a>, F&lt;<a href="#33902" title="G">G</a>, F&lt;<a href="#33903" title="H">H</a>, <a href="#33904" title="I$">I$</a>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <a title="fj.F[A,fj.F[B,fj.F[C,fj.F[D,fj.F[E$,fj.F[F$,fj.F[G,fj.F[H,I$]]]]]]]]" id="34451">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> ph.apply<span class="delimiter">(</span>bind<span class="delimiter">(</span>pb, pc, pd, pe, pf, pg, f<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds anonymously, ignoring the result value.
   *
   * @param p The parser to bind with.
   * @return A parser after binding anonymously.
   */</span>
  public &lt;<a title="Nothing" id="33907">B</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33907" title="B">B</a>, <a href="#10893" title="E">E</a>&gt; <a title="[B](p: fj.parser.Parser[I,B,E])fj.parser.Parser[I,B,E]" id="33905">sequence</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33907" title="B">B</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,B,E]" id="34460">p</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> bind<span class="delimiter">(</span><span class="keyword">new</span> F&lt;A, Parser&lt;I, B, E&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Parser&lt;I, B, E&gt; f<span class="delimiter">(</span><span class="keyword">final</span> A a<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> p;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Performs function application within a parser.
   *
   * @param p The parser returning a function value.
   * @return A new parser after function application.
   */</span>
  public &lt;<a title="Nothing" id="33910">B</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#33910" title="B">B</a>, <a href="#10893" title="E">E</a>&gt; <a title="[B](p: fj.parser.Parser[I,fj.F[A,B],E])fj.parser.Parser[I,B,E]" id="33908">apply</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, F&lt;<a href="#10892" title="A">A</a>, <a href="#33910" title="B">B</a>&gt;, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,fj.F[A,B],E]" id="34462">p</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> p.bind<span class="delimiter">(</span><span class="keyword">new</span> F&lt;F&lt;A, B&gt;, Parser&lt;I, B, E&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Parser&lt;I, B, E&gt; f<span class="delimiter">(</span><span class="keyword">final</span> F&lt;A, B&gt; f<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> map<span class="delimiter">(</span>f<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a parser that tries this parser and if it fails, then tries the given parser.
   *
   * @param alt The parser to try if this parser fails.
   * @return A parser that tries this parser and if it fails, then tries the given parser.
   */</span>
  public <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#10892" title="A">A</a>, <a href="#10893" title="E">E</a>&gt; <a title="(alt: fj.P1[fj.parser.Parser[I,A,E]])fj.parser.Parser[I,A,E]" id="33911">or</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#10892" title="A">A</a>, <a href="#10893" title="E">E</a>&gt;&gt; <a title="fj.P1[fj.parser.Parser[I,A,E]]" id="34464">alt</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parser<span class="delimiter">(</span><span class="keyword">new</span> F&lt;I, Validation&lt;E, Result&lt;I, A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Validation&lt;E, Result&lt;I, A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> I i<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parse<span class="delimiter">(</span>i<span class="delimiter">)</span>.f<span class="delimiter">(</span><span class="delimiter">)</span>.sequence<span class="delimiter">(</span>alt._1<span class="delimiter">(</span><span class="delimiter">)</span>.parse<span class="delimiter">(</span>i<span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a parser that tries this parser and if it fails, then tries the given parser.
   *
   * @param alt The parser to try if this parser fails.
   * @return A parser that tries this parser and if it fails, then tries the given parser.
   */</span>
  public <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#10892" title="A">A</a>, <a href="#10893" title="E">E</a>&gt; <a title="(alt: fj.parser.Parser[I,A,E])fj.parser.Parser[I,A,E]" id="33912">or</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#10892" title="A">A</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,A,E]" id="34465">alt</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> or<span class="delimiter">(</span>p<span class="delimiter">(</span>alt<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a parser that tries this parser and if it fails, then tries the given parser. If both parsers fail, then
   * append their errors with the given semigroup.
   *
   * @param alt The parser to try if this parser fails.
   * @param s   The semigroup to append error messages if both parsers fail.
   * @return A parser that tries this parser and if it fails, then tries the given parser.
   */</span>
  public <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#10892" title="A">A</a>, <a href="#10893" title="E">E</a>&gt; <a title="(alt: fj.P1[fj.parser.Parser[I,A,E]], s: fj.Semigroup[E])fj.parser.Parser[I,A,E]" id="33913">or</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#10892" title="A">A</a>, <a href="#10893" title="E">E</a>&gt;&gt; <a title="fj.P1[fj.parser.Parser[I,A,E]]" id="34466">alt</a>, <span class="keyword">final</span> Semigroup&lt;<a href="#10893" title="E">E</a>&gt; <a title="fj.Semigroup[E]" id="34467">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parser<span class="delimiter">(</span><span class="keyword">new</span> F&lt;I, Validation&lt;E, Result&lt;I, A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Validation&lt;E, Result&lt;I, A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> I i<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parse<span class="delimiter">(</span>i<span class="delimiter">)</span>.f<span class="delimiter">(</span><span class="delimiter">)</span>.bind<span class="delimiter">(</span><span class="keyword">new</span> F&lt;E, Validation&lt;E, Result&lt;I, A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Validation&lt;E, Result&lt;I, A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> E e<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> alt._1<span class="delimiter">(</span><span class="delimiter">)</span>.parse<span class="delimiter">(</span>i<span class="delimiter">)</span>.f<span class="delimiter">(</span><span class="delimiter">)</span>.map<span class="delimiter">(</span>s.sum<span class="delimiter">(</span>e<span class="delimiter">)</span><span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a parser that tries this parser and if it fails, then tries the given parser. If both parsers fail, then
   * append their errors with the given semigroup.
   *
   * @param alt The parser to try if this parser fails.
   * @param s   The semigroup to append error messages if both parsers fail.
   * @return A parser that tries this parser and if it fails, then tries the given parser.
   */</span>
  public <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#10892" title="A">A</a>, <a href="#10893" title="E">E</a>&gt; <a title="(alt: fj.parser.Parser[I,A,E], s: fj.Semigroup[E])fj.parser.Parser[I,A,E]" id="33914">or</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#10892" title="A">A</a>, <a href="#10893" title="E">E</a>&gt; <a title="fj.parser.Parser[I,A,E]" id="34468">alt</a>, <span class="keyword">final</span> Semigroup&lt;<a href="#10893" title="E">E</a>&gt; <a title="fj.Semigroup[E]" id="34469">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> or<span class="delimiter">(</span>p<span class="delimiter">(</span>alt<span class="delimiter">)</span>, s<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a parser that negates this parser. If this parser succeeds, then the returned parser fails and vice versa.
   *
   * @param e The error message to fail with if this parser succeeds.
   * @return A parser that negates this parser.
   */</span>
  public <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, Unit, <a href="#10893" title="E">E</a>&gt; <a title="(e: fj.P1[E])fj.parser.Parser[I,fj.Unit,E]" id="33915">not</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#10893" title="E">E</a>&gt; <a title="fj.P1[E]" id="34470">e</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parser<span class="delimiter">(</span><span class="keyword">new</span> F&lt;I, Validation&lt;E, Result&lt;I, Unit&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Validation&lt;E, Result&lt;I, Unit&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> I i<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> parse<span class="delimiter">(</span>i<span class="delimiter">)</span>.isFail<span class="delimiter">(</span><span class="delimiter">)</span> ?
            Validation.&lt;E, Result&lt;I, Unit&gt;&gt;success<span class="delimiter">(</span>result<span class="delimiter">(</span>i, unit<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> :
            Validation.&lt;E, Result&lt;I, Unit&gt;&gt;fail<span class="delimiter">(</span>e._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a parser that negates this parser. If this parser succeeds, then the returned parser fails and vice versa.
   *
   * @param e The error message to fail with if this parser succeeds.
   * @return A parser that negates this parser.
   */</span>
  public <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, Unit, <a href="#10893" title="E">E</a>&gt; <a title="(e: E)fj.parser.Parser[I,fj.Unit,E]" id="33916">not</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#10893" title="E">E</a> <a title="E" id="34471">e</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> not<span class="delimiter">(</span>p<span class="delimiter">(</span>e<span class="delimiter">)</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a parser that repeats application of this parser zero or many times.
   *
   * @return A parser that repeats application of this parser zero or many times.
   */</span>
  public <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, Stream&lt;<a href="#10892" title="A">A</a>&gt;, <a href="#10893" title="E">E</a>&gt; <a title="()fj.parser.Parser[I,fj.data.Stream[A],E]" id="33917">repeat</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> repeat1<span class="delimiter">(</span><span class="delimiter">)</span>.or<span class="delimiter">(</span><span class="keyword">new</span> P1&lt;Parser&lt;I, Stream&lt;A&gt;, E&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Parser&lt;I, Stream&lt;A&gt;, E&gt; _1<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> value<span class="delimiter">(</span>Stream.&lt;A&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a parser that repeats application of this parser one or many times.
   *
   * @return A parser that repeats application of this parser one or many times.
   */</span>
  public <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, Stream&lt;<a href="#10892" title="A">A</a>&gt;, <a href="#10893" title="E">E</a>&gt; <a title="()fj.parser.Parser[I,fj.data.Stream[A],E]" id="33918">repeat1</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> bind<span class="delimiter">(</span><span class="keyword">new</span> F&lt;A, Parser&lt;I, Stream&lt;A&gt;, E&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Parser&lt;I, Stream&lt;A&gt;, E&gt; f<span class="delimiter">(</span><span class="keyword">final</span> A a<span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">return</span> repeat<span class="delimiter">(</span><span class="delimiter">)</span>.map<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Stream&lt;A&gt;, Stream&lt;A&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                public Stream&lt;A&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;A&gt; as<span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">return</span> as.cons<span class="delimiter">(</span>a<span class="delimiter">)</span>;
                <span class="delimiter">}</span>
            <span class="delimiter">}</span><span class="delimiter">)</span>;
          <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Maps the given function across this parser's error.
   *
   * @param f The function to map this parser's error with.
   * @return A new parser with a new error type.
   */</span>
  public &lt;<a title="Nothing" id="33921">K</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#10891" title="I">I</a>, <a href="#10892" title="A">A</a>, <a href="#33921" title="K">K</a>&gt; <a title="[K](f: fj.F[E,K])fj.parser.Parser[I,A,K]" id="33919">mapError</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#10893" title="E">E</a>, <a href="#33921" title="K">K</a>&gt; <a title="fj.F[E,K]" id="34472">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parser<span class="delimiter">(</span><span class="keyword">new</span> F&lt;I, Validation&lt;K, Result&lt;I, A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Validation&lt;K, Result&lt;I, A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> I i<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> Parser.<span class="keyword">this</span>.f.f<span class="delimiter">(</span>i<span class="delimiter">)</span>.f<span class="delimiter">(</span><span class="delimiter">)</span>.map<span class="delimiter">(</span>f<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a parser that computes using the given function.
   *
   * @param f The function to construct the parser with.
   * @return A parser that computes using the given function.
   */</span>
  public static &lt;<a title="Nothing" id="33782">I</a>, <a title="Nothing" id="33783">A</a>, <a title="Nothing" id="33784">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#33782" title="I">I</a>, <a href="#33783" title="A">A</a>, <a href="#33784" title="E">E</a>&gt; <a title="[I, A, E](f: fj.F[I,fj.data.Validation[E,fj.parser.Result[I,A]]])fj.parser.Parser[I,A,E]" id="33778">parser</a><span class="delimiter">(</span><span class="keyword">final</span> F&lt;<a href="#33782" title="I">I</a>, Validation&lt;<a href="#33784" title="E">E</a>, <a href="Result.java.html#10902" title="fj.parser.Result">Result</a>&lt;<a href="#33782" title="I">I</a>, <a href="#33783" title="A">A</a>&gt;&gt;&gt; <a title="fj.F[I,fj.data.Validation[E,fj.parser.Result[I,A]]]" id="33812">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> <span class="keyword">new</span> Parser&lt;I, A, E&gt;<span class="delimiter">(</span>f<span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Constructs a parser that always returns the given value. The unital for a parser.
   *
   * @param a The value to consistently return from a parser.
   * @return A parser that always returns the given value.
   */</span>
  public static &lt;<a title="Nothing" id="33789">I</a>, <a title="Nothing" id="33790">A</a>, <a title="Nothing" id="33791">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#33789" title="I">I</a>, <a href="#33790" title="A">A</a>, <a href="#33791" title="E">E</a>&gt; <a title="[I, A, E](a: A)fj.parser.Parser[I,A,E]" id="33785">value</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#33790" title="A">A</a> <a title="A" id="33952">a</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parser<span class="delimiter">(</span><span class="keyword">new</span> F&lt;I, Validation&lt;E, Result&lt;I, A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Validation&lt;E, Result&lt;I, A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> I i<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> success<span class="delimiter">(</span>result<span class="delimiter">(</span>i, a<span class="delimiter">)</span><span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a parser that always fails with the given error.
   *
   * @param e The error to fail with.
   * @return A parser that always fails with the given error.
   */</span>
  public static &lt;<a title="Nothing" id="33796">I</a>, <a title="Nothing" id="33797">A</a>, <a title="Nothing" id="33798">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#33796" title="I">I</a>, <a href="#33797" title="A">A</a>, <a href="#33798" title="E">E</a>&gt; <a title="[I, A, E](e: E)fj.parser.Parser[I,A,E]" id="33792">fail</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#33798" title="E">E</a> <a title="E" id="33955">e</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> parser<span class="delimiter">(</span><span class="keyword">new</span> F&lt;I, Validation&lt;E, Result&lt;I, A&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      public Validation&lt;E, Result&lt;I, A&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> I i<span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> Validation.fail<span class="delimiter">(</span>e<span class="delimiter">)</span>;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Sequence the list of parsers through {@link #bind}.
   *
   * @param ps The parsers to sequence.
   * @return A parser after sequencing.
   */</span>
  public static &lt;<a title="Nothing" id="33803">I</a>, <a title="Nothing" id="33804">A</a>, <a title="Nothing" id="33805">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#33803" title="I">I</a>, List&lt;<a href="#33804" title="A">A</a>&gt;, <a href="#33805" title="E">E</a>&gt; <a title="[I, A, E](ps: fj.data.List[fj.parser.Parser[I,A,E]])fj.parser.Parser[I,fj.data.List[A],E]" id="33799">sequence</a><span class="delimiter">(</span><span class="keyword">final</span> List&lt;<a href="#10890" title="fj.parser.Parser">Parser</a>&lt;<a href="#33803" title="I">I</a>, <a href="#33804" title="A">A</a>, <a href="#33805" title="E">E</a>&gt;&gt; <a title="fj.data.List[fj.parser.Parser[I,A,E]]" id="33958">ps</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">return</span> ps.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ?
        Parser.&lt;I, List&lt;A&gt;, E&gt;value<span class="delimiter">(</span>List.&lt;A&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> :
        ps.head<span class="delimiter">(</span><span class="delimiter">)</span>.bind<span class="delimiter">(</span><span class="keyword">new</span> F&lt;A, Parser&lt;I, List&lt;A&gt;, E&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          public Parser&lt;I, List&lt;A&gt;, E&gt; f<span class="delimiter">(</span><span class="keyword">final</span> A a<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> sequence<span class="delimiter">(</span>ps.tail<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.map<span class="delimiter">(</span>cons_<span class="delimiter">(</span>a<span class="delimiter">)</span><span class="delimiter">)</span>;
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>;
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Parsers that accept {@link Stream} input.
   */</span>
  public static <span class="keyword">final</span> <span class="keyword">class</span> <a title="object fj.parser.Parser.StreamParser" id="33808">StreamParser</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> StreamParser<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces an element from the stream if it is available and fails otherwise.
     *
     * @param e The error to fail with if no element is available.
     * @return A parser that produces an element from the stream if it is available and fails otherwise.
     */</span>
    public static &lt;<a title="Nothing" id="33965">I</a>, <a title="Nothing" id="33966">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;<a href="#33965" title="I">I</a>&gt;, <a href="#33965" title="I">I</a>, <a href="#33966" title="E">E</a>&gt; <a title="[I, E](e: fj.P1[E])fj.parser.Parser[fj.data.Stream[I],I,E]" id="33962">element</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#33966" title="E">E</a>&gt; <a title="fj.P1[E]" id="33982">e</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> parser<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Stream&lt;I&gt;, Validation&lt;E, Result&lt;Stream&lt;I&gt;, I&gt;&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Validation&lt;E, Result&lt;Stream&lt;I&gt;, I&gt;&gt; f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;I&gt; is<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> is.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ?
              Validation.&lt;E, Result&lt;Stream&lt;I&gt;, I&gt;&gt;fail<span class="delimiter">(</span>e._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> :
              Validation.&lt;E, Result&lt;Stream&lt;I&gt;, I&gt;&gt;success<span class="delimiter">(</span>result<span class="delimiter">(</span>is.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span>, is.head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces an element from the stream if it is available and fails otherwise.
     *
     * @param e The error to fail with if no element is available.
     * @return A parser that produces an element from the stream if it is available and fails otherwise.
     */</span>
    public static &lt;<a title="Nothing" id="33970">I</a>, <a title="Nothing" id="33971">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;<a href="#33970" title="I">I</a>&gt;, <a href="#33970" title="I">I</a>, <a href="#33971" title="E">E</a>&gt; <a title="[I, E](e: E)fj.parser.Parser[fj.data.Stream[I],I,E]" id="33967">element</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#33971" title="E">E</a> <a title="E" id="33985">e</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> element<span class="delimiter">(</span>p<span class="delimiter">(</span>e<span class="delimiter">)</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces an element from the stream that satisfies the given predicate, or fails.
     *
     * @param missing The error if no element is available.
     * @param sat     The error if the element does not satisfy the predicate.
     * @param f       The predicate that the element should satisfy.
     * @return A parser that produces an element from the stream that satisfies the given predicate, or fails.
     */</span>
    public static &lt;<a title="Nothing" id="33975">I</a>, <a title="Nothing" id="33976">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;<a href="#33975" title="I">I</a>&gt;, <a href="#33975" title="I">I</a>, <a href="#33976" title="E">E</a>&gt; <a title="[I, E](missing: fj.P1[E], sat: fj.F[I,E], f: fj.F[I,java.lang.Boolean])fj.parser.Parser[fj.data.Stream[I],I,E]" id="33972">satisfy</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#33976" title="E">E</a>&gt; <a title="fj.P1[E]" id="33988">missing</a>, <span class="keyword">final</span> F&lt;<a href="#33975" title="I">I</a>, <a href="#33976" title="E">E</a>&gt; <a title="fj.F[I,E]" id="33989">sat</a>,
                                                         <span class="keyword">final</span> F&lt;<a href="#33975" title="I">I</a>, Boolean&gt; <a title="fj.F[I,java.lang.Boolean]" id="33990">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.&lt;I, E&gt;element<span class="delimiter">(</span>missing<span class="delimiter">)</span>.bind<span class="delimiter">(</span><span class="keyword">new</span> F&lt;I, Parser&lt;Stream&lt;I&gt;, I, E&gt;&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Parser&lt;Stream&lt;I&gt;, I, E&gt; f<span class="delimiter">(</span><span class="keyword">final</span> I x<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> f.f<span class="delimiter">(</span>x<span class="delimiter">)</span> ?
              Parser.&lt;Stream&lt;I&gt;, I, E&gt;value<span class="delimiter">(</span>x<span class="delimiter">)</span> :
              Parser.&lt;Stream&lt;I&gt;, I, E&gt;fail<span class="delimiter">(</span>sat.f<span class="delimiter">(</span>x<span class="delimiter">)</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces an element from the stream that satisfies the given predicate, or fails.
     *
     * @param missing The error if no element is available.
     * @param sat     The error if the element does not satisfy the predicate.
     * @param f       The predicate that the element should satisfy.
     * @return A parser that produces an element from the stream that satisfies the given predicate, or fails.
     */</span>
    public static &lt;<a title="Nothing" id="33980">I</a>, <a title="Nothing" id="33981">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;<a href="#33980" title="I">I</a>&gt;, <a href="#33980" title="I">I</a>, <a href="#33981" title="E">E</a>&gt; <a title="[I, E](missing: E, sat: fj.F[I,E], f: fj.F[I,java.lang.Boolean])fj.parser.Parser[fj.data.Stream[I],I,E]" id="33977">satisfy</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#33981" title="E">E</a> <a title="E" id="33995">missing</a>, <span class="keyword">final</span> F&lt;<a href="#33980" title="I">I</a>, <a href="#33981" title="E">E</a>&gt; <a title="fj.F[I,E]" id="33996">sat</a>, <span class="keyword">final</span> F&lt;<a href="#33980" title="I">I</a>, Boolean&gt; <a title="fj.F[I,java.lang.Boolean]" id="33997">f</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> satisfy<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat, f<span class="delimiter">)</span>;
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Parsers that accept {@link Stream Stream&amp;lt;Character&amp;gt;} input.
   */</span>
  public static <span class="keyword">final</span> <span class="keyword">class</span> <a title="object fj.parser.Parser.CharsParser" id="33811">CharsParser</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> CharsParser<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a character if one is available or fails with the given error.
     *
     * @param e The error to fail with if a character is unavailable.
     * @return A parser that produces a character if one is available or fails with the given error.
     */</span>
    public static &lt;<a title="Nothing" id="34005">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34005" title="E">E</a>&gt; <a title="[E](e: fj.P1[E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34003">character</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34005" title="E">E</a>&gt; <a title="fj.P1[E]" id="34141">e</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.element<span class="delimiter">(</span>e<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a character if one is available or fails with the given error.
     *
     * @param e The error to fail with if a character is unavailable.
     * @return A parser that produces a character if one is available or fails with the given error.
     */</span>
    public static &lt;<a title="Nothing" id="34008">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34008" title="E">E</a>&gt; <a title="[E](e: E)fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34006">character</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34008" title="E">E</a> <a title="E" id="34144">e</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> character<span class="delimiter">(</span>p<span class="delimiter">(</span>e<span class="delimiter">)</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces the given character or fails otherwise.
     *
     * @param missing The error if no character is available.
     * @param sat     The error if the produced character is not the one given.
     * @param c       The character to produce in the parser.
     * @return A parser that produces the given character or fails otherwise.
     */</span>
    public static &lt;<a title="Nothing" id="34011">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34011" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E], c: Char)fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34009">character</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34011" title="E">E</a>&gt; <a title="fj.P1[E]" id="34147">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34011" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34148">sat</a>,
                                                                        <span class="keyword">final</span> char <a title="Char" id="34149">c</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character x<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> x == c;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces the given character or fails otherwise.
     *
     * @param missing The error if no character is available.
     * @param sat     The error if the produced character is not the one given.
     * @param c       The character to produce in the parser.
     * @return A parser that produces the given character or fails otherwise.
     */</span>
    public static &lt;<a title="Nothing" id="34014">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34014" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E], c: Char)fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34012">character</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34014" title="E">E</a> <a title="E" id="34154">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34014" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34155">sat</a>,
                                                                        <span class="keyword">final</span> char <a title="Char" id="34156">c</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> character<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat, c<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces the given number of characters, or fails with the given error.
     *
     * @param missing The error if the given number of characters is unavailable.
     * @param n       The number of characters to produce in the parse result.
     * @return A parser that produces the given number of characters, or fails with the given error.
     */</span>
    public static &lt;<a title="Nothing" id="34017">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Stream&lt;Character&gt;, <a href="#34017" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], n: Int)fj.parser.Parser[fj.data.Stream[java.lang.Character],fj.data.Stream[java.lang.Character],E]" id="34015">characters</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34017" title="E">E</a>&gt; <a title="fj.P1[E]" id="34161">missing</a>, <span class="keyword">final</span> int <a title="Int" id="34162">n</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> n &lt;= <span class="int">0</span> ?
          Parser.&lt;Stream&lt;Character&gt;, Stream&lt;Character&gt;, E&gt;value<span class="delimiter">(</span>Stream.&lt;Character&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> :
          character<span class="delimiter">(</span>missing<span class="delimiter">)</span>.bind<span class="delimiter">(</span>characters<span class="delimiter">(</span>missing, n - <span class="int">1</span><span class="delimiter">)</span>, Stream.&lt;Character&gt;cons_<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces the given number of characters, or fails with the given error.
     *
     * @param missing The error if the given number of characters is unavailable.
     * @param n       The number of characters to produce in the parse result.
     * @return A parser that produces the given number of characters, or fails with the given error.
     */</span>
    public static &lt;<a title="Nothing" id="34020">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Stream&lt;Character&gt;, <a href="#34020" title="E">E</a>&gt; <a title="[E](missing: E, n: Int)fj.parser.Parser[fj.data.Stream[java.lang.Character],fj.data.Stream[java.lang.Character],E]" id="34018">characters</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34020" title="E">E</a> <a title="E" id="34166">missing</a>, <span class="keyword">final</span> int <a title="Int" id="34167">n</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> characters<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, n<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces the given stream of characters or fails otherwise.
     *
     * @param missing The error if the producing stream could not supply more characters.
     * @param sat     The error if a character was produced that is not the given stream of characters.
     * @param cs      The stream of characters to produce.
     * @return A parser that produces the given stream of characters or fails otherwise.
     */</span>
    public static &lt;<a title="Nothing" id="34023">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Stream&lt;Character&gt;, <a href="#34023" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E], cs: fj.data.Stream[java.lang.Character])fj.parser.Parser[fj.data.Stream[java.lang.Character],fj.data.Stream[java.lang.Character],E]" id="34021">characters</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34023" title="E">E</a>&gt; <a title="fj.P1[E]" id="34171">missing</a>,
                                                                                 <span class="keyword">final</span> F&lt;Character, <a href="#34023" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34172">sat</a>,
                                                                                 <span class="keyword">final</span> Stream&lt;Character&gt; <a title="fj.data.Stream[java.lang.Character]" id="34173">cs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> cs.isEmpty<span class="delimiter">(</span><span class="delimiter">)</span> ?
          Parser.&lt;Stream&lt;Character&gt;, Stream&lt;Character&gt;, E&gt;value<span class="delimiter">(</span>Stream.&lt;Character&gt;nil<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> :
          character<span class="delimiter">(</span>missing, sat, cs.head<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.bind<span class="delimiter">(</span>characters<span class="delimiter">(</span>missing, sat, cs.tail<span class="delimiter">(</span><span class="delimiter">)</span>._1<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>, Stream.&lt;Character&gt;cons_<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces the given stream of characters or fails otherwise.
     *
     * @param missing The error if the producing stream could not supply more characters.
     * @param sat     The error if a character was produced that is not the given stream of characters.
     * @param cs      The stream of characters to produce.
     * @return A parser that produces the given stream of characters or fails otherwise.
     */</span>
    public static &lt;<a title="Nothing" id="34026">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Stream&lt;Character&gt;, <a href="#34026" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E], cs: fj.data.Stream[java.lang.Character])fj.parser.Parser[fj.data.Stream[java.lang.Character],fj.data.Stream[java.lang.Character],E]" id="34024">characters</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34026" title="E">E</a> <a title="E" id="34178">missing</a>,
                                                                                 <span class="keyword">final</span> F&lt;Character, <a href="#34026" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34179">sat</a>,
                                                                                 <span class="keyword">final</span> Stream&lt;Character&gt; <a title="fj.data.Stream[java.lang.Character]" id="34180">cs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> characters<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat, cs<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces the given string or fails otherwise.
     *
     * @param missing The error if the producing stream could not supply more characters.
     * @param sat     The error if a character was produced that is not the given string.
     * @param s       The string to produce.
     * @return A parser that produces the given string or fails otherwise.
     */</span>
    public static &lt;<a title="Nothing" id="34029">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, String, <a href="#34029" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E], s: java.lang.String)fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.String,E]" id="34027">string</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34029" title="E">E</a>&gt; <a title="fj.P1[E]" id="34185">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34029" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34186">sat</a>,
                                                                  <span class="keyword">final</span> String <a title="java.lang.String" id="34187">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> characters<span class="delimiter">(</span>missing, sat, List.fromString<span class="delimiter">(</span>s<span class="delimiter">)</span>.toStream<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>.map<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Stream&lt;Character&gt;, String&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public String f<span class="delimiter">(</span><span class="keyword">final</span> Stream&lt;Character&gt; cs<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> List.asString<span class="delimiter">(</span>cs.toList<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces the given string or fails otherwise.
     *
     * @param missing The error if the producing stream could not supply more characters.
     * @param sat     The error if a character was produced that is not the given string.
     * @param s       The string to produce.
     * @return A parser that produces the given string or fails otherwise.
     */</span>
    public static &lt;<a title="Nothing" id="34032">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, String, <a href="#34032" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E], s: java.lang.String)fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.String,E]" id="34030">string</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34032" title="E">E</a> <a title="E" id="34192">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34032" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34193">sat</a>,
                                                                  <span class="keyword">final</span> String <a title="java.lang.String" id="34194">s</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> string<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat, s<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a digit (0 to 9).
     *
     * @param missing The error if there is no character on the stream to produce a digit with.
     * @param sat     The error if the produced character is not a digit.
     * @return A parser that produces a digit (0 to 9).
     */</span>
    public static &lt;<a title="Nothing" id="34035">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Digit, <a href="#34035" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],fj.Digit,E]" id="34033">digit</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34035" title="E">E</a>&gt; <a title="fj.P1[E]" id="34199">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34035" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34200">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isDigit<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>.map<span class="delimiter">(</span><span class="keyword">new</span> F&lt;Character, Digit&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Digit f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Digit.fromChar<span class="delimiter">(</span>c<span class="delimiter">)</span>.some<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a digit (0 to 9).
     *
     * @param missing The error if there is no character on the stream to produce a digit with.
     * @param sat     The error if the produced character is not a digit.
     * @return A parser that produces a digit (0 to 9).
     */</span>
    public static &lt;<a title="Nothing" id="34038">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Digit, <a href="#34038" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],fj.Digit,E]" id="34036">digit</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34038" title="E">E</a> <a title="E" id="34204">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34038" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34205">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> digit<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a lower-case character.
     *
     * @param missing The error if there is no character on the stream to produce a lower-case character with.
     * @param sat     The error if the produced character is not a lower-case character.
     * @return A parser that produces a lower-case character.
     * @see Character#isLowerCase(char)
     */</span>
    public static &lt;<a title="Nothing" id="34041">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34041" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34039">lower</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34041" title="E">E</a>&gt; <a title="fj.P1[E]" id="34209">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34041" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34210">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isLowerCase<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a lower-case character.
     *
     * @param missing The error if there is no character on the stream to produce a lower-case character with.
     * @param sat     The error if the produced character is not a lower-case character.
     * @return A parser that produces a lower-case character.
     * @see Character#isLowerCase(char)
     */</span>
    public static &lt;<a title="Nothing" id="34044">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34044" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34042">lower</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34044" title="E">E</a> <a title="E" id="34214">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34044" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34215">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> lower<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a upper-case character.
     *
     * @param missing The error if there is no character on the stream to produce a upper-case character with.
     * @param sat     The error if the produced character is not a upper-case character.
     * @return A parser that produces a upper-case character.
     * @see Character#isUpperCase(char)
     */</span>
    public static &lt;<a title="Nothing" id="34047">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34047" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34045">upper</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34047" title="E">E</a>&gt; <a title="fj.P1[E]" id="34219">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34047" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34220">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isUpperCase<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a upper-case character.
     *
     * @param missing The error if there is no character on the stream to produce a upper-case character with.
     * @param sat     The error if the produced character is not a upper-case character.
     * @return A parser that produces a upper-case character.
     * @see Character#isUpperCase(char)
     */</span>
    public static &lt;<a title="Nothing" id="34050">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34050" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34048">upper</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34050" title="E">E</a> <a title="E" id="34224">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34050" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34225">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> upper<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a defined character.
     *
     * @param missing The error if there is no character on the stream to produce a defined character with.
     * @param sat     The error if the produced character is not a defined character.
     * @return A parser that produces a defined character.
     * @see Character#isDefined(char)
     */</span>
    public static &lt;<a title="Nothing" id="34053">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34053" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34051">defined</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34053" title="E">E</a>&gt; <a title="fj.P1[E]" id="34229">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34053" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34230">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isDefined<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a defined character.
     *
     * @param missing The error if there is no character on the stream to produce a defined character with.
     * @param sat     The error if the produced character is not a defined character.
     * @return A parser that produces a defined character.
     * @see Character#isDefined(char)
     */</span>
    public static &lt;<a title="Nothing" id="34056">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34056" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34054">defined</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34056" title="E">E</a> <a title="E" id="34234">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34056" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34235">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> defined<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a high-surrogate character.
     *
     * @param missing The error if there is no character on the stream to produce a high-surrogate character with.
     * @param sat     The error if the produced character is not a high-surrogate character.
     * @return A parser that produces a high-surrogate character.
     * @see Character#isHighSurrogate(char)
     */</span>
    public static &lt;<a title="Nothing" id="34059">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34059" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34057">highSurrogate</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34059" title="E">E</a>&gt; <a title="fj.P1[E]" id="34239">missing</a>,
                                                                            <span class="keyword">final</span> F&lt;Character, <a href="#34059" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34240">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isHighSurrogate<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a high-surrogate character.
     *
     * @param missing The error if there is no character on the stream to produce a high-surrogate character with.
     * @param sat     The error if the produced character is not a high-surrogate character.
     * @return A parser that produces a high-surrogate character.
     * @see Character#isHighSurrogate(char)
     */</span>
    public static &lt;<a title="Nothing" id="34062">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34062" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34060">highSurrogate</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34062" title="E">E</a> <a title="E" id="34244">missing</a>,
                                                                            <span class="keyword">final</span> F&lt;Character, <a href="#34062" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34245">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> highSurrogate<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces an identifier-ignorable character.
     *
     * @param missing The error if there is no character on the stream to produce an identifier-ignorable character with.
     * @param sat     The error if the produced character is not an identifier-ignorable character.
     * @return A parser that produces an identifier-ignorable character.
     * @see Character#isIdentifierIgnorable(char)
     */</span>
    public static &lt;<a title="Nothing" id="34065">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34065" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34063">identifierIgnorable</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34065" title="E">E</a>&gt; <a title="fj.P1[E]" id="34249">missing</a>,
                                                                                  <span class="keyword">final</span> F&lt;Character, <a href="#34065" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34250">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isIdentifierIgnorable<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces an identifier-ignorable character.
     *
     * @param missing The error if there is no character on the stream to produce an identifier-ignorable character with.
     * @param sat     The error if the produced character is not an identifier-ignorable character.
     * @return A parser that produces an identifier-ignorable character.
     * @see Character#isIdentifierIgnorable(char)
     */</span>
    public static &lt;<a title="Nothing" id="34068">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34068" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34066">identifierIgnorable</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34068" title="E">E</a> <a title="E" id="34254">missing</a>,
                                                                                  <span class="keyword">final</span> F&lt;Character, <a href="#34068" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34255">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> identifierIgnorable<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces an ISO control character.
     *
     * @param missing The error if there is no character on the stream to produce an ISO control character with.
     * @param sat     The error if the produced character is not an ISO control character.
     * @return A parser that produces an ISO control character.
     * @see Character#isISOControl(char)
     */</span>
    public static &lt;<a title="Nothing" id="34071">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34071" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34069">isoControl</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34071" title="E">E</a>&gt; <a title="fj.P1[E]" id="34259">missing</a>,
                                                                         <span class="keyword">final</span> F&lt;Character, <a href="#34071" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34260">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isISOControl<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces an ISO control character.
     *
     * @param missing The error if there is no character on the stream to produce an ISO control character with.
     * @param sat     The error if the produced character is not an ISO control character.
     * @return A parser that produces an ISO control character.
     * @see Character#isISOControl(char)
     */</span>
    public static &lt;<a title="Nothing" id="34074">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34074" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34072">isoControl</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34074" title="E">E</a> <a title="E" id="34264">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34074" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34265">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> isoControl<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a Java identifier part character.
     *
     * @param missing The error if there is no character on the stream to produce a Java identifier part character with.
     * @param sat     The error if the produced character is not a Java identifier part character.
     * @return A parser that produces a Java identifier part character.
     * @see Character#isJavaIdentifierPart(char)
     */</span>
    public static &lt;<a title="Nothing" id="34077">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34077" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34075">javaIdentifierPart</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34077" title="E">E</a>&gt; <a title="fj.P1[E]" id="34269">missing</a>,
                                                                                 <span class="keyword">final</span> F&lt;Character, <a href="#34077" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34270">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isJavaIdentifierPart<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a Java identifier part character.
     *
     * @param missing The error if there is no character on the stream to produce a Java identifier part character with.
     * @param sat     The error if the produced character is not a Java identifier part character.
     * @return A parser that produces a Java identifier part character.
     * @see Character#isJavaIdentifierPart(char)
     */</span>
    public static &lt;<a title="Nothing" id="34080">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34080" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34078">javaIdentifierPart</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34080" title="E">E</a> <a title="E" id="34274">missing</a>,
                                                                                 <span class="keyword">final</span> F&lt;Character, <a href="#34080" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34275">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> javaIdentifierPart<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a Java identifier start character.
     *
     * @param missing The error if there is no character on the stream to produce a Java identifier start character with.
     * @param sat     The error if the produced character is not a Java identifier start character.
     * @return A parser that produces a Java identifier start character.
     * @see Character#isJavaIdentifierStart(char)
     */</span>
    public static &lt;<a title="Nothing" id="34083">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34083" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34081">javaIdentifierStart</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34083" title="E">E</a>&gt; <a title="fj.P1[E]" id="34279">missing</a>,
                                                                                  <span class="keyword">final</span> F&lt;Character, <a href="#34083" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34280">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isJavaIdentifierStart<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a Java identifier start character.
     *
     * @param missing The error if there is no character on the stream to produce a Java identifier start character with.
     * @param sat     The error if the produced character is not a Java identifier start character.
     * @return A parser that produces a Java identifier start character.
     * @see Character#isJavaIdentifierStart(char)
     */</span>
    public static &lt;<a title="Nothing" id="34086">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34086" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34084">javaIdentifierStart</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34086" title="E">E</a> <a title="E" id="34284">missing</a>,
                                                                                  <span class="keyword">final</span> F&lt;Character, <a href="#34086" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34285">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> javaIdentifierStart<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces an alpha character.
     *
     * @param missing The error if there is no character on the stream to produce an alpha character with.
     * @param sat     The error if the produced character is not an alpha character.
     * @return A parser that produces an alpha character.
     * @see Character#isLetter(char)
     */</span>
    public static &lt;<a title="Nothing" id="34089">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34089" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34087">alpha</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34089" title="E">E</a>&gt; <a title="fj.P1[E]" id="34289">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34089" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34290">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isLetter<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces an alpha character.
     *
     * @param missing The error if there is no character on the stream to produce an alpha character with.
     * @param sat     The error if the produced character is not an alpha character.
     * @return A parser that produces an alpha character.
     * @see Character#isLetter(char)
     */</span>
    public static &lt;<a title="Nothing" id="34092">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34092" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34090">alpha</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34092" title="E">E</a> <a title="E" id="34294">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34092" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34295">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> alpha<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces an alpha-numeric character.
     *
     * @param missing The error if there is no character on the stream to produce an alpha-numeric character with.
     * @param sat     The error if the produced character is not an alpha-numeric character.
     * @return A parser that produces an alpha-numeric character.
     * @see Character#isLetterOrDigit(char)
     */</span>
    public static &lt;<a title="Nothing" id="34095">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34095" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34093">alphaNum</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34095" title="E">E</a>&gt; <a title="fj.P1[E]" id="34299">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34095" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34300">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isLetterOrDigit<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces an alpha-numeric character.
     *
     * @param missing The error if there is no character on the stream to produce an alpha-numeric character with.
     * @param sat     The error if the produced character is not an alpha-numeric character.
     * @return A parser that produces an alpha-numeric character.
     * @see Character#isLetterOrDigit(char)
     */</span>
    public static &lt;<a title="Nothing" id="34098">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34098" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34096">alphaNum</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34098" title="E">E</a> <a title="E" id="34304">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34098" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34305">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> alphaNum<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a low-surrogate character.
     *
     * @param missing The error if there is no character on the stream to produce a low-surrogate character with.
     * @param sat     The error if the produced character is not a low-surrogate character.
     * @return A parser that produces a low-surrogate character.
     * @see Character#isLowSurrogate(char)
     */</span>
    public static &lt;<a title="Nothing" id="34101">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34101" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34099">lowSurrogate</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34101" title="E">E</a>&gt; <a title="fj.P1[E]" id="34309">missing</a>,
                                                                           <span class="keyword">final</span> F&lt;Character, <a href="#34101" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34310">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isLowSurrogate<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a low-surrogate character.
     *
     * @param missing The error if there is no character on the stream to produce a low-surrogate character with.
     * @param sat     The error if the produced character is not a low-surrogate character.
     * @return A parser that produces a low-surrogate character.
     * @see Character#isLowSurrogate(char)
     */</span>
    public static &lt;<a title="Nothing" id="34104">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34104" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34102">lowSurrogate</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34104" title="E">E</a> <a title="E" id="34314">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34104" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34315">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> lowSurrogate<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a mirrored character.
     *
     * @param missing The error if there is no character on the stream to produce a mirrored character with.
     * @param sat     The error if the produced character is not a mirrored character.
     * @return A parser that produces a mirrored character.
     * @see Character#isMirrored(char)
     */</span>
    public static &lt;<a title="Nothing" id="34107">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34107" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34105">mirrored</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34107" title="E">E</a>&gt; <a title="fj.P1[E]" id="34319">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34107" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34320">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isMirrored<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a mirrored character.
     *
     * @param missing The error if there is no character on the stream to produce a mirrored character with.
     * @param sat     The error if the produced character is not a mirrored character.
     * @return A parser that produces a mirrored character.
     * @see Character#isMirrored(char)
     */</span>
    public static &lt;<a title="Nothing" id="34110">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34110" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34108">mirrored</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34110" title="E">E</a> <a title="E" id="34324">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34110" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34325">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> mirrored<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a space character.
     *
     * @param missing The error if there is no character on the stream to produce a space character with.
     * @param sat     The error if the produced character is not a space character.
     * @return A parser that produces a space character.
     * @see Character#isSpace(char)
     */</span>
    public static &lt;<a title="Nothing" id="34113">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34113" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34111">space</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34113" title="E">E</a>&gt; <a title="fj.P1[E]" id="34329">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34113" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34330">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isSpaceChar<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a space character.
     *
     * @param missing The error if there is no character on the stream to produce a space character with.
     * @param sat     The error if the produced character is not a space character.
     * @return A parser that produces a space character.
     * @see Character#isSpace(char)
     */</span>
    public static &lt;<a title="Nothing" id="34116">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34116" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34114">space</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34116" title="E">E</a> <a title="E" id="34334">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34116" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34335">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> space<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a title-case character.
     *
     * @param missing The error if there is no character on the stream to produce a title-case character with.
     * @param sat     The error if the produced character is not a title-case character.
     * @return A parser that produces a title-case character.
     * @see Character#isTitleCase(char)
     */</span>
    public static &lt;<a title="Nothing" id="34119">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34119" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34117">titleCase</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34119" title="E">E</a>&gt; <a title="fj.P1[E]" id="34339">missing</a>,
                                                                        <span class="keyword">final</span> F&lt;Character, <a href="#34119" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34340">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isTitleCase<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a title-case character.
     *
     * @param missing The error if there is no character on the stream to produce a title-case character with.
     * @param sat     The error if the produced character is not a title-case character.
     * @return A parser that produces a title-case character.
     * @see Character#isTitleCase(char)
     */</span>
    public static &lt;<a title="Nothing" id="34122">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34122" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34120">titleCase</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34122" title="E">E</a> <a title="E" id="34344">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34122" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34345">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> titleCase<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a unicode identifier part character.
     *
     * @param missing The error if there is no character on the stream to produce a unicode identifier part character with.
     * @param sat     The error if the produced character is not a unicode identifier part character.
     * @return A parser that produces a unicode identifier part character.
     * @see Character#isUnicodeIdentifierPart(char)
     */</span>
    public static &lt;<a title="Nothing" id="34125">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34125" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34123">unicodeIdentiferPart</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34125" title="E">E</a>&gt; <a title="fj.P1[E]" id="34349">missing</a>,
                                                                                   <span class="keyword">final</span> F&lt;Character, <a href="#34125" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34350">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isUnicodeIdentifierPart<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a unicode identifier part character.
     *
     * @param missing The error if there is no character on the stream to produce a unicode identifier part character with.
     * @param sat     The error if the produced character is not a unicode identifier part character.
     * @return A parser that produces a unicode identifier part character.
     * @see Character#isUnicodeIdentifierPart(char)
     */</span>
    public static &lt;<a title="Nothing" id="34128">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34128" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34126">unicodeIdentiferPart</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34128" title="E">E</a> <a title="E" id="34354">missing</a>,
                                                                                   <span class="keyword">final</span> F&lt;Character, <a href="#34128" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34355">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> unicodeIdentiferPart<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a unicode identifier start character.
     *
     * @param missing The error if there is no character on the stream to produce a unicode identifier start character with.
     * @param sat     The error if the produced character is not a unicode identifier start character.
     * @return A parser that produces a unicode identifier start character.
     * @see Character#isUnicodeIdentifierStart(char)
     */</span>
    public static &lt;<a title="Nothing" id="34131">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34131" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34129">unicodeIdentiferStart</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34131" title="E">E</a>&gt; <a title="fj.P1[E]" id="34359">missing</a>,
                                                                                    <span class="keyword">final</span> F&lt;Character, <a href="#34131" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34360">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isUnicodeIdentifierStart<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a unicode identifier start character.
     *
     * @param missing The error if there is no character on the stream to produce a unicode identifier start character with.
     * @param sat     The error if the produced character is not a unicode identifier start character.
     * @return A parser that produces a unicode identifier start character.
     * @see Character#isUnicodeIdentifierStart(char)
     */</span>
    public static &lt;<a title="Nothing" id="34134">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34134" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34132">unicodeIdentiferStart</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34134" title="E">E</a> <a title="E" id="34364">missing</a>,
                                                                                    <span class="keyword">final</span> F&lt;Character, <a href="#34134" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34365">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> unicodeIdentiferStart<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a white-space character.
     *
     * @param missing The error if there is no character on the stream to produce a white-space character with.
     * @param sat     The error if the produced character is not a white-space character.
     * @return A parser that produces a white-space character.
     * @see Character#isWhitespace(char)
     */</span>
    public static &lt;<a title="Nothing" id="34137">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34137" title="E">E</a>&gt; <a title="[E](missing: fj.P1[E], sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34135">whitespace</a><span class="delimiter">(</span><span class="keyword">final</span> P1&lt;<a href="#34137" title="E">E</a>&gt; <a title="fj.P1[E]" id="34369">missing</a>,
                                                                         <span class="keyword">final</span> F&lt;Character, <a href="#34137" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34370">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> StreamParser.satisfy<span class="delimiter">(</span>missing, sat, <span class="keyword">new</span> F&lt;Character, Boolean&gt;<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        public Boolean f<span class="delimiter">(</span><span class="keyword">final</span> Character c<span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">return</span> Character.isWhitespace<span class="delimiter">(</span>c<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns a parser that produces a white-space character.
     *
     * @param missing The error if there is no character on the stream to produce a white-space character with.
     * @param sat     The error if the produced character is not a white-space character.
     * @return A parser that produces a white-space character.
     * @see Character#isWhitespace(char)
     */</span>
    public static &lt;<a title="Nothing" id="34140">E</a>&gt; <a href="#10890" title="fj.parser.Parser">Parser</a>&lt;Stream&lt;Character&gt;, Character, <a href="#34140" title="E">E</a>&gt; <a title="[E](missing: E, sat: fj.F[java.lang.Character,E])fj.parser.Parser[fj.data.Stream[java.lang.Character],java.lang.Character,E]" id="34138">whitespace</a><span class="delimiter">(</span><span class="keyword">final</span> <a href="#34140" title="E">E</a> <a title="E" id="34374">missing</a>, <span class="keyword">final</span> F&lt;Character, <a href="#34140" title="E">E</a>&gt; <a title="fj.F[java.lang.Character,E]" id="34375">sat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> whitespace<span class="delimiter">(</span>p<span class="delimiter">(</span>missing<span class="delimiter">)</span>, sat<span class="delimiter">)</span>;
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>
        </pre>
    </body>
</html>