<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>org/scalatest/StackDepthException.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright 2001-2008 Artima, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>
<span class="keyword">package</span> org.scalatest

<span class="comment">/**
 * Exception class that encapsulates information about the stack depth at which the line of code that failed resides,
 * so that information can be presented to the user that makes it quick to find the failing line of code. (In other
 * words, the user need not scan through the stack trace to find the correct filename and line number of the problem code.)
 * Having a stack depth is more useful in a testing environment in which test failures are implemented as
 * thrown exceptions, as is the case in ScalaTest's built-in suite traits.
 *
 * @param messageFun an function that produces an optional detail message for this &lt;code&gt;StackDepthException&lt;/code&gt;.
 * @param cause an optional cause, the &lt;code&gt;Throwable&lt;/code&gt; that caused this &lt;code&gt;StackDepthException&lt;/code&gt; to be thrown.
 * @param failedCodeStackDepthFun a function that produces the depth in the stack trace of this exception at which the line of test code that failed resides.
 *
 * @throws NullPointerException if either &lt;code&gt;messageFun&lt;/code&gt;, &lt;code&gt;cause&lt;/code&gt; or &lt;code&gt;failedCodeStackDepthFun&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;Some(null)&lt;/code&gt;.
 *
 * @author Bill Venners
 */</span>
<span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class StackDepthException extends java.lang.RuntimeException with org.scalatest.StackDepth with ScalaObject" id="9866">StackDepthException</a><a href="#9866" title="ScalaObject" class="delimiter">(</a>
  <span class="keyword">val</span> <a title="org.scalatest.StackDepthException =&gt; Option[String]" id="35945">messageFun</a>: StackDepthException =&gt; Option<span class="delimiter">[</span>String<span class="delimiter">]</span>,
  <span class="keyword">val</span> <a title="Option[Throwable]" id="35946">cause</a>: <span title="Option[Throwable]">Option</span><span class="delimiter">[</span>Throwable<span class="delimiter">]</span>,
  <span class="keyword">val</span> <a title="org.scalatest.StackDepthException =&gt; Int" id="35947">failedCodeStackDepthFun</a>: StackDepthException =&gt; Int
<span class="delimiter">)</span> <span class="keyword">extends</span> <span title="java.lang.RuntimeException">RuntimeException</span><span class="delimiter">(</span><span title="Throwable" class="keyword">if</span> <span class="delimiter">(</span><a href="#35946" title="Option[Throwable]">cause</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span> <a href="#35946" title="Option[Throwable]">cause</a>.<span title="=&gt; Throwable">get</span> <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="keyword">with</span> <a href="StackDepth.scala.html#9683" title="org.scalatest.StackDepth">StackDepth</a> <span class="delimiter">{</span>

  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#35945" title="=&gt; org.scalatest.StackDepthException =&gt; Option[String]">messageFun</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <span title="(x$1: java.lang.String)java.lang.NullPointerException" class="keyword">new</span> <span title="java.lang.NullPointerException">NullPointerException</span><span class="delimiter">(</span><span title="java.lang.String(&quot;messageFun was null&quot;)" class="string">&quot;messageFun was null&quot;</span><span class="delimiter">)</span>

  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#35946" title="=&gt; Option[Throwable]">cause</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <span title="(x$1: java.lang.String)java.lang.NullPointerException" class="keyword">new</span> <span title="java.lang.NullPointerException">NullPointerException</span><span class="delimiter">(</span><span title="java.lang.String(&quot;cause was null&quot;)" class="string">&quot;cause was null&quot;</span><span class="delimiter">)</span>
  <a href="#35946" title="=&gt; Option[Throwable]">cause</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Nothing">Some</span><span class="delimiter">(</span><span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> =&gt; <span title="Nothing" class="keyword">throw</span> <span title="(x$1: java.lang.String)java.lang.NullPointerException" class="keyword">new</span> <span title="java.lang.NullPointerException">NullPointerException</span><span class="delimiter">(</span><span title="java.lang.String(&quot;cause was a Some(null)&quot;)" class="string">&quot;cause was a Some(null)&quot;</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="Unit">_</span> =&gt;
  <span class="delimiter">}</span>

  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#35947" title="=&gt; org.scalatest.StackDepthException =&gt; Int">failedCodeStackDepthFun</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <span title="(x$1: java.lang.String)java.lang.NullPointerException" class="keyword">new</span> <span title="java.lang.NullPointerException">NullPointerException</span><span class="delimiter">(</span><span title="java.lang.String(&quot;failedCodeStackDepthFun was null&quot;)" class="string">&quot;failedCodeStackDepthFun was null&quot;</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Constructs a &lt;code&gt;StackDepthException&lt;/code&gt; with an optional pre-determined &lt;code&gt;message&lt;/code&gt;, optional cause, and
   * a &lt;code&gt;failedCodeStackDepth&lt;/code&gt; function.
   *
   * @param message an optional detail message for this &lt;code&gt;StackDepthException&lt;/code&gt;.
   * @param cause an optional cause, the &lt;code&gt;Throwable&lt;/code&gt; that caused this &lt;code&gt;StackDepthException&lt;/code&gt; to be thrown.
   * @param failedCodeStackDepth the depth in the stack trace of this exception at which the line of test code that failed resides.
   *
   * @throws NullPointerException if either &lt;code&gt;message&lt;/code&gt; or &lt;code&gt;cause&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;Some(null)&lt;/code&gt;, or &lt;code&gt;failedCodeStackDepthFun&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <a title="(message: Option[String], cause: Option[Throwable], failedCodeStackDepthFun: org.scalatest.StackDepthException =&gt; Int)org.scalatest.StackDepthException" id="27406" class="keyword">this</a><span class="delimiter">(</span><a title="Option[String]" id="35942">message</a>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Option[Throwable]" id="35943">cause</a>: <span title="Option[Throwable]">Option</span><span class="delimiter">[</span>Throwable<span class="delimiter">]</span>, <a title="org.scalatest.StackDepthException =&gt; Int" id="35944">failedCodeStackDepthFun</a>: StackDepthException =&gt; Int<span class="delimiter">)</span> =
    <a href="#9866" title="StackDepthException.this.type" class="keyword">this</a><span class="delimiter">(</span>
      <a href="#35942" title="Option[String]">message</a> <span title="org.scalatest.StackDepthException =&gt; Option[String]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Nothing" class="keyword">null</span> =&gt; <span title="Nothing" class="keyword">throw</span> <span title="(x$1: java.lang.String)java.lang.NullPointerException" class="keyword">new</span> <span title="java.lang.NullPointerException">NullPointerException</span><span class="delimiter">(</span><span title="java.lang.String(&quot;message was null&quot;)" class="string">&quot;message was null&quot;</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Nothing">Some</span><span class="delimiter">(</span><span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> =&gt; <span title="Nothing" class="keyword">throw</span> <span title="(x$1: java.lang.String)java.lang.NullPointerException" class="keyword">new</span> <span title="java.lang.NullPointerException">NullPointerException</span><span class="delimiter">(</span><span title="java.lang.String(&quot;message was a Some(null)&quot;)" class="string">&quot;message was a Some(null)&quot;</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="org.scalatest.StackDepthException =&gt; Option[String]">_</span> =&gt; <span class="delimiter">(</span>e: <a href="#9866" title="org.scalatest.StackDepthException">StackDepthException</a><span class="delimiter">)</span> =&gt; <a href="#35942" title="Option[String]">message</a>
      <span class="delimiter">}</span>,
      <a href="#35943" title="Option[Throwable]">cause</a>,
      <a href="#35944" title="org.scalatest.StackDepthException =&gt; Int">failedCodeStackDepthFun</a>
    <span class="delimiter">)</span>

  <span class="comment">/**
   * Constructs a &lt;code&gt;StackDepthException&lt;/code&gt; with an optional pre-determined &lt;code&gt;message&lt;/code&gt;,
   * optional &lt;code&gt;cause&lt;/code&gt;, and and &lt;code&gt;failedCodeStackDepth&lt;/code&gt;. (This was
   * the primary constructor form prior to ScalaTest 1.5.)
   *
   * @param message an optional detail message for this &lt;code&gt;StackDepthException&lt;/code&gt;.
   * @param cause an optional cause, the &lt;code&gt;Throwable&lt;/code&gt; that caused this &lt;code&gt;StackDepthException&lt;/code&gt; to be thrown.
   * @param failedCodeStackDepth the depth in the stack trace of this exception at which the line of test code that failed resides.
   *
   * @throws NullPointerException if either &lt;code&gt;message&lt;/code&gt; of &lt;code&gt;cause&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;Some(null)&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <a title="(message: Option[String], cause: Option[Throwable], failedCodeStackDepth: Int)org.scalatest.StackDepthException" id="27407" class="keyword">this</a><span class="delimiter">(</span><a title="Option[String]" id="35939">message</a>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Option[Throwable]" id="35940">cause</a>: <span title="Option[Throwable]">Option</span><span class="delimiter">[</span>Throwable<span class="delimiter">]</span>, <a title="Int" id="35941">failedCodeStackDepth</a>: <span title="Int">Int</span><span class="delimiter">)</span> =
    <a href="#9866" title="StackDepthException.this.type" class="keyword">this</a><span class="delimiter">(</span>
      <a href="#35939" title="Option[String]">message</a> <span title="org.scalatest.StackDepthException =&gt; Option[String]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Nothing" class="keyword">null</span> =&gt; <span title="Nothing" class="keyword">throw</span> <span title="(x$1: java.lang.String)java.lang.NullPointerException" class="keyword">new</span> <span title="java.lang.NullPointerException">NullPointerException</span><span class="delimiter">(</span><span title="java.lang.String(&quot;message was null&quot;)" class="string">&quot;message was null&quot;</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Nothing">Some</span><span class="delimiter">(</span><span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> =&gt; <span title="Nothing" class="keyword">throw</span> <span title="(x$1: java.lang.String)java.lang.NullPointerException" class="keyword">new</span> <span title="java.lang.NullPointerException">NullPointerException</span><span class="delimiter">(</span><span title="java.lang.String(&quot;message was a Some(null)&quot;)" class="string">&quot;message was a Some(null)&quot;</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="org.scalatest.StackDepthException =&gt; Option[String]">_</span> =&gt; <span class="delimiter">(</span>e: <a href="#9866" title="org.scalatest.StackDepthException">StackDepthException</a><span class="delimiter">)</span> =&gt; <a href="#35939" title="Option[String]">message</a>
      <span class="delimiter">}</span>,
      <a href="#35940" title="Option[Throwable]">cause</a>,
      <span class="delimiter">(</span>e: <a href="#9866" title="org.scalatest.StackDepthException">StackDepthException</a><span class="delimiter">)</span> =&gt; <a href="#35941" title="Int">failedCodeStackDepth</a>
    <span class="delimiter">)</span>

  <span class="comment">/**
   * An optional detail message for this &lt;code&gt;StackDepth&lt;/code&gt; exception.
   *
   * &lt;p&gt;
   * One reason this is lazy is to delay any searching of the stack trace until it is actually needed. It will
   * usually be needed, but not always. For example, exceptions thrown during a shrink phase of a failed property
   * will often be &lt;code&gt;StackDepthException&lt;/code&gt;s, but whose &lt;code&gt;message&lt;/code&gt; will never be used. Another related reason is to remove the need
   * to create a different exception before creating this one just for the purpose of searching through its stack
   * trace for the proper stack depth. Still one more reason is to allow the message to contain information about the
   * stack depth, such as the failed file name and line number.
   * &lt;/p&gt;
   */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Option[String]" id="27409">message</a>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="#35945" title="(v1: org.scalatest.StackDepthException)Option[String]">messageFun</a><span class="delimiter">(</span><a href="#9866" title="org.scalatest.StackDepthException" class="keyword">this</a><span class="delimiter">)</span>
 
  <span class="comment">/**
   * The depth in the stack trace of this exception at which the line of test code that failed resides.
   *
   * &lt;p&gt;
   * One reason this is lazy is to delay any searching of the stack trace until it is actually needed. It will
   * usually be needed, but not always. For example, exceptions thrown during a shrink phase of a failed property
   * will often be &lt;code&gt;StackDepthException&lt;/code&gt;s, but whose &lt;code&gt;failedCodeStackDepth&lt;/code&gt; will never be used. Another reason is to remove the need
   * to create a different exception before creating this one just for the purpose of searching through its stack
   * trace for the proper stack depth. Still one more reason is to allow the message to contain information about the
   * stack depth, such as the failed file name and line number.
   * &lt;/p&gt;
   */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Int" id="27411">failedCodeStackDepth</a>: <span title="Int">Int</span> = <a href="#35947" title="(v1: org.scalatest.StackDepthException)Int">failedCodeStackDepthFun</a><span class="delimiter">(</span><a href="#9866" title="org.scalatest.StackDepthException" class="keyword">this</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns the detail message string of this &lt;code&gt;StackDepthException&lt;/code&gt;.
   *
   * @return the detail message string of this &lt;code&gt;StackDepthException&lt;/code&gt; instance (which may be &lt;code&gt;null&lt;/code&gt;).
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="27412">getMessage</a>: <span title="String">String</span> = <a href="#27408" title="=&gt; Option[String]">message</a>.<span title="(implicit ev: &lt;:&lt;[Null,String])String">orNull</span>

  <span class="comment">/*
  * Throws &lt;code&gt;IllegalStateException&lt;/code&gt;, because &lt;code&gt;StackDepthException&lt;/code&gt;s are
  * always initialized with a cause passed to the constructor of superclass &lt;code&gt;
  */</span>
  <span class="keyword">override</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="(throwable: Throwable)Throwable" id="27413">initCause</a><span class="delimiter">(</span><a title="Throwable" id="47950">throwable</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span>: <span title="Throwable">Throwable</span> = <span class="delimiter">{</span> <span title="Nothing" class="keyword">throw</span> <span title="java.lang.IllegalStateException" class="keyword">new</span> <span title="java.lang.IllegalStateException">IllegalStateException</span> <span class="delimiter">}</span>

  <span class="comment">/**
   * Indicates whether this object can be equal to the passed object.
   */</span>
  <span class="keyword">def</span> <a title="(other: Any)Boolean" id="27414">canEqual</a><span class="delimiter">(</span><a title="Any" id="36426">other</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#36426" title="Any">other</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#9866" title="org.scalatest.StackDepthException">StackDepthException</a><span class="delimiter">]</span>

  <span class="comment">/**
   * Indicates whether this object is equal to the passed object. If the passed object is
   * a &lt;code&gt;StackDepthException&lt;/code&gt;, equality requires equal &lt;code&gt;message&lt;/code&gt;,
   * &lt;code&gt;cause&lt;/code&gt;, and &lt;code&gt;failedCodeStackDepth&lt;/code&gt; fields, as well as equal
   * return values of &lt;code&gt;getStackTrace&lt;/code&gt;.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="(other: Any)Boolean" id="27415">equals</a><span class="delimiter">(</span><a title="Any" id="36430">other</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="#36430" title="Any">other</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Boolean" id="47954">that</a>: <a href="#9866" title="org.scalatest.StackDepthException">StackDepthException</a> =&gt; 
        <span class="delimiter">(</span><a href="#47954" title="org.scalatest.StackDepthException">that</a> <a href="#27414" title="(other: Any)Boolean">canEqual</a> <a href="#9866" title="org.scalatest.StackDepthException" class="keyword">this</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <a href="#27408" title="=&gt; Option[String]">message</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#47954" title="org.scalatest.StackDepthException">that</a>.<a href="#27408" title="=&gt; Option[String]">message</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <a href="#35946" title="=&gt; Option[Throwable]">cause</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#47954" title="org.scalatest.StackDepthException">that</a>.<a href="#35946" title="=&gt; Option[Throwable]">cause</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <a href="#27410" title="=&gt; Int">failedCodeStackDepth</a> <span title="(x: Int)Boolean">==</span> <a href="#47954" title="org.scalatest.StackDepthException">that</a>.<a href="#27410" title="=&gt; Int">failedCodeStackDepth</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
        <a href="#9866" title="(xs: Array[java.lang.StackTraceElement])scala.collection.mutable.ArrayOps[java.lang.StackTraceElement]">getStackTrace</a>.<span title="=&gt; IndexedSeq[Any]">deep</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#47954" title="org.scalatest.StackDepthException">that</a>.<span title="(xs: Array[java.lang.StackTraceElement])scala.collection.mutable.ArrayOps[java.lang.StackTraceElement]">getStackTrace</span>.<span title="=&gt; IndexedSeq[Any]">deep</span>
      <span class="keyword">case</span> <span title="Boolean(false)">_</span> =&gt; <span title="Boolean(false)" class="keyword">false</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a hash code value for this object.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()Int" id="27416">hashCode</a>: <span title="Int">Int</span> =
    <span title="Int(41)" class="int">41</span> <span title="(x: Int)Int">*</span> <span class="delimiter">(</span>
      <span title="Int(41)" class="int">41</span> <span title="(x: Int)Int">*</span> <span class="delimiter">(</span>
        <span title="Int(41)" class="int">41</span> <span title="(x: Int)Int">*</span> <span class="delimiter">(</span>
          <span title="Int(41)" class="int">41</span> <span title="(x: Int)Int">+</span> <a href="#27408" title="=&gt; Option[String]">message</a>.<span title="()Int">hashCode</span>
        <span class="delimiter">)</span> <span title="(x: Int)Int">+</span> <a href="#35946" title="=&gt; Option[Throwable]">cause</a>.<span title="()Int">hashCode</span>
      <span class="delimiter">)</span> <span title="(x: Int)Int">+</span> <a href="#27410" title="=&gt; Int">failedCodeStackDepth</a>.<span title="()Int">hashCode</span>
    <span class="delimiter">)</span> <span title="(x: Int)Int">+</span> <a href="#9866" title="()Array[java.lang.StackTraceElement]">getStackTrace</a>.<span title="()Int">hashCode</span>
<span class="delimiter">}</span>

<span class="comment">/*
For check methods in Checkers, passed fileName will be &quot;Checkers.scala&quot; and
passed methodName will be &quot;check&quot;:

0 org.scalatest.prop.Checkers$class.check(Checkers.scala:194)
1 org.scalatest.ShouldContainElementSpec.check(ShouldContainElementSpec.scala:23)
2 org.scalatest.prop.Checkers$class.check(Checkers.scala:205)
3 org.scalatest.ShouldContainElementSpec.check(ShouldContainElementSpec.scala:23)
4 org.scalatest.prop.Checkers$class.check(Checkers.scala:96)
5 org.scalatest.ShouldContainElementSpec.check(ShouldContainElementSpec.scala:23)
6 org.scalatest.ShouldContainElementSpec$$anonfun$1$$anonfun$apply$1$$anonfun$apply$28.apply(ShouldContainElementSpec.scala:80)

For detection of a duplicate test name in Spec, passed fileName will be &quot;Spec.scala&quot; and
passed methodName will be &quot;it&quot;:

0 org.scalatest.Spec$class.registerExample(Spec.scala:682)
1 org.scalatest.Spec$class.it(Spec.scala:712)
2 org.scalatest.ShouldContainElementSpec.it(ShouldContainElementSpec.scala:23)
3 org.scalatest.Spec$class.it(Spec.scala:735)
4 org.scalatest.ShouldContainElementSpec.it(ShouldContainElementSpec.scala:23)
5 org.scalatest.ShouldContainElementSpec$$anonfun$1$$anonfun$apply$167.apply(ShouldContainElementSpec.scala:1092) 

For detection of a duplicate test name in FunSuite, passed fileName will be &quot;FunSuite.scala&quot; and
passed methodName will be &quot;test&quot;:

0 org.scalatest.FunSuite$class.test(FunSuite.scala:592)
1 org.scalatest.SpecSuite.test(SpecSuite.scala:18)
2 org.scalatest.SpecSuite.&lt;init&gt;(SpecSuite.scala:42) 

For detection of an it inside an it in Spec, passed fileName will be &quot;Spec.scala&quot; and
passed methodName will be &quot;it&quot;:

0 org.scalatest.Spec$class.it(Spec.scala:745)
1 org.scalatest.ShouldBehaveLikeSpec.it(ShouldBehaveLikeSpec.scala:23)
2 org.scalatest.ShouldBehaveLikeSpec$$anonfun$1.apply(ShouldBehaveLikeSpec.scala:26) 

For detection of a describe inside an it in Spec, passed fileName will be &quot;Spec.scala&quot; and
passed methodName will be &quot;describe&quot;:

0 org.scalatest.Spec$class.describe(Spec.scala:804)
1 org.scalatest.ShouldBehaveLikeSpec.describe(ShouldBehaveLikeSpec.scala:23)
2 org.scalatest.ShouldBehaveLikeSpec$$anonfun$1.apply(ShouldBehaveLikeSpec.scala:26) 

For detection of an ignore inside an it in Spec, passed fileName will be &quot;Spec.scala&quot; and
passed methodName will be &quot;ignore&quot;:

0 org.scalatest.Spec$class.ignore(Spec.scala:792)
1 org.scalatest.ShouldBehaveLikeSpec.ignore(ShouldBehaveLikeSpec.scala:23)
2 org.scalatest.ShouldBehaveLikeSpec$$anonfun$1.apply(ShouldBehaveLikeSpec.scala:26) 

For detection of a test inside a test in FunSuite, passed fileName will be &quot;FunSuite.scala&quot; and
passed methodName will be &quot;test&quot;:

0 org.scalatest.FunSuite$class.test(FunSuite.scala:591)
1 org.scalatest.Q36Suite.test(ShouldBehaveLikeSpec.scala:23)
2 org.scalatest.Q36Suite$$anonfun$1.apply(ShouldBehaveLikeSpec.scala:25)

For detection of an ignore inside a test in FunSuite, passed fileName will be &quot;FunSuite.scala&quot; and
passed methodName will be &quot;ignore&quot;:

0 org.scalatest.FunSuite$class.ignore(FunSuite.scala:624)
1 org.scalatest.Q36Suite.ignore(ShouldBehaveLikeSpec.scala:23)
2 org.scalatest.Q36Suite$$anonfun$1.apply(ShouldBehaveLikeSpec.scala:25)

Not sure yet what to do with TableDrivenPropertyCheckFailedExeptions. It seems to 
work fine hard-coded at 7. Can't find a case that doesn't work. Will release it hard-coded at 7 and see
if someone else runs across one, and if so, I'll fix it then. (So the code that throws that exception
doesn't call the getStackDepth helper method at this point.)

0 org.scalatest.prop.TableFor2$$anonfun$apply$4.apply(Table.scala:356)
1 org.scalatest.prop.TableFor2$$anonfun$apply$4.apply(Table.scala:347)
2 scala.collection.mutable.ResizableArray$class.foreach(ResizableArray.scala:57)
3 scala.collection.mutable.ArrayBuffer.foreach(ArrayBuffer.scala:43)
4 org.scalatest.prop.TableFor2.apply(Table.scala:347)
5 org.scalatest.prop.TableDrivenPropertyChecks$class.forAll(TableDrivenPropertyChecks.scala:215)
6 org.scalatest.prop.PropertyChecksSuite.forAll(PropertyChecksSuite.scala:21)
org.scalatest.prop.PropertyChecksSuite$$anonfun$2.apply(PropertyChecksSuite.scala:48) &lt;-- this should not be cut

Conductor from conduct method: Stack depth should be 3 or 4. Both of which are the same

[scalatest] org.scalatest.NotAllowedException: A Conductor's conduct method can only be invoked once.
[scalatest] 	at org.scalatest.concurrent.Conductor.conduct(Conductor.scala:525)
[scalatest] 	at org.scalatest.concurrent.Conductor.conduct(Conductor.scala:476)
[scalatest] 	at org.scalatest.concurrent.ConductorSuite$$anonfun$1$$anonfun$2.apply(ConductorSuite.scala:30)
[scalatest] 	at org.scalatest.concurrent.ConductorSuite$$anonfun$1$$anonfun$2.apply(ConductorSuite.scala:30)
[scalatest] 	at org.scalatest.Assertions$class.intercept(Assertions.scala:515)
[scalatest] 	at org.scalatest.concurrent.ConductorSuite.intercept(ConductorSuite.scala:23)
[scalatest] 	at org.scalatest.concurrent.ConductorSuite$$anonfun$1.apply(ConductorSuite.scala:30)
[scalatest] 	at org.scalatest.concurrent.ConductorSuite$$anonfun$1.apply(ConductorSuite.scala:27)
[scalatest] 	at org.scalatest.FunSuite$$anon$1.apply(FunSuite.scala:1031)
[scalatest] 	at org.scalatest.Suite$class.withFixture(Suite.scala:1450)
[scalatest] 	at org.scalatest.concurrent.ConductorSuite.withFixture(ConductorSuite.scala:23)
[scalatest] 	at org.scalatest.FunSuite$class.runTest(FunSuite.scala:1028)
[scalatest] 	at org.scalatest.concurrent.ConductorSuite.runTest(ConductorSuite.scala:23)
*/</span>
<span class="keyword">private</span><span class="delimiter">[</span>scalatest<span class="delimiter">]</span> <span class="keyword">object</span> <a title="object org.scalatest.StackDepthExceptionHelper" id="9555">StackDepthExceptionHelper</a> <span title="ScalaObject" class="delimiter">{</span>

  <span class="keyword">def</span> <a title="(fileName: String, methodName: String)org.scalatest.StackDepthException =&gt; Int" id="36443">getStackDepth</a><span class="delimiter">(</span><a title="String" id="39619">fileName</a>: <span title="String">String</span>, <a title="String" id="39620">methodName</a>: <span title="String">String</span><span class="delimiter">)</span>: <span class="delimiter">(</span>StackDepthException =&gt; Int<span class="delimiter">)</span> = <span class="delimiter">{</span> <a title="org.scalatest.StackDepthException" id="48065">sde</a> =&gt;

    <span class="keyword">val</span> <a title="List[java.lang.StackTraceElement]" id="48066">stackTraceList</a> = <a href="#48065" title="org.scalatest.StackDepthException">sde</a>.<span title="(xs: Array[java.lang.StackTraceElement])scala.collection.mutable.ArrayOps[java.lang.StackTraceElement]">getStackTrace</span>.<span title="=&gt; List[java.lang.StackTraceElement]">toList</span>

    <span class="keyword">val</span> <a title="List[Boolean]" id="48067">fileNameIsDesiredList</a>: <span title="List[Boolean]">List</span><span class="delimiter">[</span>Boolean<span class="delimiter">]</span> =
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="java.lang.StackTraceElement" id="48199">element</a> &lt;- <a href="#48066" title="(f: java.lang.StackTraceElement =&gt; Boolean)(implicit bf: scala.collection.generic.CanBuildFrom[List[java.lang.StackTraceElement],Boolean,List[Boolean]])List[Boolean]">stackTraceList</a><span class="delimiter">)</span> <span class="keyword">yield</span>
        <a href="#48199" title="java.lang.StackTraceElement">element</a>.<span title="()java.lang.String">getFileName</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#39619" title="String">fileName</a> <span class="comment">// such as &quot;Checkers.scala&quot;</span>

    <span class="keyword">val</span> <a title="List[Boolean]" id="48068">methodNameIsDesiredList</a>: <span title="List[Boolean]">List</span><span class="delimiter">[</span>Boolean<span class="delimiter">]</span> =
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="java.lang.StackTraceElement" id="48242">element</a> &lt;- <a href="#48066" title="(f: java.lang.StackTraceElement =&gt; Boolean)(implicit bf: scala.collection.generic.CanBuildFrom[List[java.lang.StackTraceElement],Boolean,List[Boolean]])List[Boolean]">stackTraceList</a><span class="delimiter">)</span> <span class="keyword">yield</span>
        <a href="#48242" title="java.lang.StackTraceElement">element</a>.<span title="()java.lang.String">getMethodName</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#39620" title="String">methodName</a> <span class="comment">// such as &quot;check&quot;</span>

    <span class="comment">// For element 0, the previous file name was not desired, because there is no previous</span>
    <span class="comment">// one, so you start with false. For element 1, it depends on whether element 0 of the stack trace</span>
    <span class="comment">// had the desired file name, and so forth.</span>
    <span class="keyword">val</span> <a title="List[Boolean]" id="48069">previousFileNameIsDesiredList</a>: <span title="List[Boolean]">List</span><span class="delimiter">[</span>Boolean<span class="delimiter">]</span> = <span title="Boolean(false)" class="keyword">false</span> <a href="#48275" title="(x: Boolean)List[Boolean]">::</a> <span class="delimiter">(</span><a href="#48067" title="List[Boolean]">fileNameIsDesiredList</a>.<span title="(n: Int)List[Boolean]">dropRight</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">// Zip these two related lists together. They now have two boolean values together, when both</span>
    <span class="comment">// are true, that's a stack trace element that should be included in the stack depth.</span>
    <span class="keyword">val</span> <a title="List[(Boolean, Boolean)]" id="48070">zipped1</a> = <a href="#48068" title="List[Boolean]">methodNameIsDesiredList</a> <span title="(that: scala.collection.GenIterable[Boolean])(implicit bf: scala.collection.generic.CanBuildFrom[List[Boolean],(Boolean, Boolean),List[(Boolean, Boolean)]])List[(Boolean, Boolean)]">zip</span> <a href="#48069" title="List[Boolean]">previousFileNameIsDesiredList</a>
    <span class="keyword">val</span> <a title="List[Boolean]" id="48071">methodNameAndPreviousFileNameAreDesiredList</a>: <span title="List[Boolean]">List</span><span class="delimiter">[</span>Boolean<span class="delimiter">]</span> =
      <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Boolean" id="48367">methodNameIsDesired</a>, <a title="Boolean" id="48368">previousFileNameIsDesired</a><span class="delimiter">)</span> &lt;- <a href="#48070" title="(f: (Boolean, Boolean) =&gt; Boolean)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Boolean, Boolean)],Boolean,List[Boolean]])List[Boolean]">zipped1</a><span class="delimiter">)</span> <span class="keyword">yield</span>
        <a href="#48367" title="Boolean">methodNameIsDesired</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#48368" title="Boolean">previousFileNameIsDesired</a>

    <span class="comment">// Zip the two lists together, that when one or the other is true is an include.</span>
    <span class="keyword">val</span> <a title="List[(Boolean, Boolean)]" id="48072">zipped2</a> = <a href="#48067" title="List[Boolean]">fileNameIsDesiredList</a> <span title="(that: scala.collection.GenIterable[Boolean])(implicit bf: scala.collection.generic.CanBuildFrom[List[Boolean],(Boolean, Boolean),List[(Boolean, Boolean)]])List[(Boolean, Boolean)]">zip</span> <a href="#48071" title="List[Boolean]">methodNameAndPreviousFileNameAreDesiredList</a>
    <span class="keyword">val</span> <a title="List[Boolean]" id="48073">includeInStackDepthList</a>: <span title="List[Boolean]">List</span><span class="delimiter">[</span>Boolean<span class="delimiter">]</span> =
      <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Boolean" id="48476">fileNameIsDesired</a>, <a title="Boolean" id="48477">methodNameAndPreviousFileNameAreDesired</a><span class="delimiter">)</span> &lt;- <a href="#48072" title="(f: (Boolean, Boolean) =&gt; Boolean)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Boolean, Boolean)],Boolean,List[Boolean]])List[Boolean]">zipped2</a><span class="delimiter">)</span> <span class="keyword">yield</span>
        <a href="#48476" title="Boolean">fileNameIsDesired</a> <span title="(x: Boolean)Boolean">||</span> <a href="#48477" title="Boolean">methodNameAndPreviousFileNameAreDesired</a>

    <a href="#48073" title="List[Boolean]">includeInStackDepthList</a>.<span title="(p: Boolean =&gt; Boolean)List[Boolean]">takeWhile</span><span class="delimiter">(</span><a title="Boolean" id="48511">include</a> =&gt; <a href="#48511" title="Boolean">include</a><span class="delimiter">)</span>.<span title="=&gt; Int">length</span>
  <span class="delimiter">}</span>

<span class="comment">/*
mixing in trait GeneratorDrivenPropertyChecks:

at org.scalatest.prop.Checkers$.doCheck(Checkers.scala:234)
at org.scalatest.prop.GeneratorDrivenPropertyChecks$class.forAll(GeneratorDrivenPropertyChecks.scala:51)
at org.scalatest.prop.PropertyChecksSuite.forAll(PropertyChecksSuite.scala:23)
at org.scalatest.prop.PropertyChecksSuite$$anonfun$2.apply(PropertyChecksSuite.scala:37) &lt;-- actual stack depth
at org.scalatest.prop.PropertyChecksSuite$$anonfun$2.apply(PropertyChecksSuite.scala:37) &lt;-- add one to zap duplication
at org.scalatest.FunSuite$$anon$4.apply(FunSuite.scala:1146)
at org.scalatest.Suite$class.withFixture(Suite.scala:1478)
at org.scalatest.prop.PropertyChecksSuite.withFixture(PropertyChecksSuite.scala:23)
at org.scalatest.FunSuite$class.runTest(FunSuite.scala:1143)
at org.scalatest.prop.PropertyChecksSuite.runTest(PropertyChecksSuite.scala:23)
at org.scalatest.FunSuite$$anonfun$runTests$1.apply(FunSuite.scala:1252)

importing GeneratorDrivenPropertyChecks._

at org.scalatest.prop.Checkers$.doCheck(Checkers.scala:234)
at org.scalatest.prop.GeneratorDrivenPropertyChecks$class.forAll(GeneratorDrivenPropertyChecks.scala:51)
at org.scalatest.prop.GeneratorDrivenPropertyChecks$.forAll(GeneratorDrivenPropertyChecks.scala:55)
at org.scalatest.prop.PropertyChecksSuite$$anonfun$2.apply(PropertyChecksSuite.scala:38) &lt;-- actual stack depth
at org.scalatest.prop.PropertyChecksSuite$$anonfun$2.apply(PropertyChecksSuite.scala:38) &lt;-- add one to zap duplication
at org.scalatest.FunSuite$$anon$4.apply(FunSuite.scala:1146)
at org.scalatest.Suite$class.withFixture(Suite.scala:1478)
at org.scalatest.prop.PropertyChecksSuite.withFixture(PropertyChecksSuite.scala:24)
at org.scalatest.FunSuite$class.runTest(FunSuite.scala:1143)
at org.scalatest.prop.PropertyChecksSuite.runTest(PropertyChecksSuite.scala:24)
at org.scalatest.FunSuite$$anonfun$runTests$1.apply(FunSuite.scala:1252)

What I'm doing here is including everything up to the first appearance of the desired method one stack
trace element beyond an appearance of the desired file name.

mixing in trait TableDrivenPropertyChecks:

at org.scalatest.prop.TableFor2$$anonfun$apply$4.apply(Table.scala:396)
at org.scalatest.prop.TableFor2$$anonfun$apply$4.apply(Table.scala:387)
at scala.collection.mutable.ResizableArray$class.foreach(ResizableArray.scala:57)
at scala.collection.mutable.ArrayBuffer.foreach(ArrayBuffer.scala:43)
at org.scalatest.prop.TableFor2.apply(Table.scala:387)
at org.scalatest.prop.TableDrivenPropertyChecks$class.forAll(TableDrivenPropertyChecks.scala:350)
at org.scalatest.prop.OtherSuite.forAll(OtherSuite.scala:21)
at org.scalatest.prop.OtherSuite$$anonfun$2.apply(OtherSuite.scala:48) &lt;-- stack depth should be 7
at org.scalatest.prop.OtherSuite$$anonfun$2.apply(OtherSuite.scala:33)
at org.scalatest.FunSuite$$anon$4.apply(FunSuite.scala:1146)
at org.scalatest.Suite$class.withFixture(Suite.scala:1478)
at org.scalatest.prop.OtherSuite.withFixture(OtherSuite.scala:21)
at org.scalatest.FunSuite$class.runTest(FunSuite.scala:1143)
at org.scalatest.prop.OtherSuite.runTest(OtherSuite.scala:21)

importing TableDrivenPropertyChecks._:

at org.scalatest.prop.TableFor2$$anonfun$apply$4.apply(Table.scala:396)
at org.scalatest.prop.TableFor2$$anonfun$apply$4.apply(Table.scala:387)
at scala.collection.mutable.ResizableArray$class.foreach(ResizableArray.scala:57)
at scala.collection.mutable.ArrayBuffer.foreach(ArrayBuffer.scala:43)
at org.scalatest.prop.TableFor2.apply(Table.scala:387)
at org.scalatest.prop.TableDrivenPropertyChecks$class.forAll(TableDrivenPropertyChecks.scala:350)
at org.scalatest.prop.TableDrivenPropertyChecks$.forAll(TableDrivenPropertyChecks.scala:619)
at org.scalatest.prop.OtherSuite$$anonfun$2.apply(OtherSuite.scala:49) &lt;-- stack depth should be 7
at org.scalatest.prop.OtherSuite$$anonfun$2.apply(OtherSuite.scala:34)
at org.scalatest.FunSuite$$anon$4.apply(FunSuite.scala:1146)
at org.scalatest.Suite$class.withFixture(Suite.scala:1478)
at org.scalatest.prop.OtherSuite.withFixture(OtherSuite.scala:22)
at org.scalatest.FunSuite$class.runTest(FunSuite.scala:1143)
at org.scalatest.prop.OtherSuite.runTest(OtherSuite.scala:22)
at org.scalatest.FunSuite$$anonfun$runTests$1.apply(FunSuite.scala:1252)

forAll (minSize(10), maxSize(20)) { fun... } form. Stack trace is:
The proper stack depth here should be the second one that has ack.scala:27
Had bug. But turned out same algo works, but needed to send &quot;apply&quot; not &quot;forAll&quot;

[scalatest]   org.scalatest.prop.GeneratorDrivenPropertyCheckFailedException: org.scalatest.TestFailedException (included as this exception's cause) was thrown during property evaluation.
[scalatest]   at org.scalatest.prop.Checkers$.doCheck(Checkers.scala:269)
[scalatest]   at org.scalatest.prop.GeneratorDrivenPropertyChecks$ConfiguredPropertyCheck.apply(GeneratorDrivenPropertyChecks.scala:432)
[scalatest]   at org.scalatest.prop.AckSuite$$anonfun$1.apply(ack.scala:27)
[scalatest]   at org.scalatest.prop.AckSuite$$anonfun$1.apply(ack.scala:27)
[scalatest]   at org.scalatest.FunSuite$$anon$4.apply(FunSuite.scala:1146)
[scalatest]   at org.scalatest.Suite$class.withFixture(Suite.scala:1478)
[scalatest]   at org.scalatest.prop.AckSuite.withFixture(ack.scala:23)
[scalatest]   at org.scalatest.FunSuite$class.runTest(FunSuite.scala:1143)
[scalatest]   at org.scalatest.prop.AckSuite.runTest(ack.scala:23)
[scalatest]   at org.scalatest.FunSuite$$anonfun$runTests$1.apply(FunSuite.scala:1252)
[scalatest]   at org.scalatest.FunSuite$$anonfun$runTests$1.apply(FunSuite.scala:1243)
[scalatest]   at scala.collection.LinearSeqOptimized$class.foreach(LinearSeqOptimized.scala:61)
[scalatest]   at scala.collection.immutable.List.foreach(List.scala:45)
[scalatest]   at org.scalatest.FunSuite$class.runTests(FunSuite.scala:1243)
[scalatest]   at org.scalatest.prop.AckSuite.runTests(ack.scala:23)
[scalatest]   at org.scalatest.Suite$class.run(Suite.scala:1773)
[scalatest]   at org.scalatest.prop.AckSuite.org$scalatest$FunSuite$$super$run(ack.scala:23)
[scalatest]   at org.scalatest.FunSuite$class.run(FunSuite.scala:1289)
[scalatest]   at org.scalatest.prop.AckSuite.run(ack.scala:23)
[scalatest]   at org.scalatest.tools.SuiteRunner.run(SuiteRunner.scala:59)
[scalatest]   at org.scalatest.tools.Runner$$anonfun$doRunRunRunDaDoRunRun$3.apply(Runner.scala:1515)
[scalatest]   at org.scalatest.tools.Runner$$anonfun$doRunRunRunDaDoRunRun$3.apply(Runner.scala:1512)
[scalatest]   at scala.collection.LinearSeqOptimized$class.foreach(LinearSeqOptimized.scala:61)
[scalatest]   at scala.collection.immutable.List.foreach(List.scala:45)
[scalatest]   at org.scalatest.tools.Runner$.doRunRunRunDaDoRunRun(Runner.scala:1512)
[scalatest]   at org.scalatest.tools.Runner$$anonfun$runOptionallyWithPassFailReporter$2.apply(Runner.scala:594)
[scalatest]   at org.scalatest.tools.Runner$$anonfun$runOptionallyWithPassFailReporter$2.apply(Runner.scala:593)
[scalatest]   at org.scalatest.tools.Runner$.withClassLoaderAndDispatchReporter(Runner.scala:1556)

*/</span>
  <span class="keyword">def</span> <a title="(fileName: String, methodName: String)org.scalatest.StackDepthException =&gt; Int" id="36444">getStackDepthForPropCheck</a><span class="delimiter">(</span><a title="String" id="48519">fileName</a>: <span title="String">String</span>, <a title="String" id="48520">methodName</a>: <span title="String">String</span><span class="delimiter">)</span>: <span class="delimiter">(</span>StackDepthException =&gt; Int<span class="delimiter">)</span> = <span class="delimiter">{</span> <a title="org.scalatest.StackDepthException" id="48523">sde</a> =&gt;

    <span class="keyword">val</span> <a title="List[java.lang.StackTraceElement]" id="48524">stackTraceList</a> = <a href="#48523" title="org.scalatest.StackDepthException">sde</a>.<span title="(xs: Array[java.lang.StackTraceElement])scala.collection.mutable.ArrayOps[java.lang.StackTraceElement]">getStackTrace</span>.<span title="=&gt; List[java.lang.StackTraceElement]">toList</span>

    <span class="keyword">val</span> <a title="List[Boolean]" id="48525">fileNameIsDesiredList</a>: <span title="List[Boolean]">List</span><span class="delimiter">[</span>Boolean<span class="delimiter">]</span> =
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="java.lang.StackTraceElement" id="48651">element</a> &lt;- <a href="#48524" title="(f: java.lang.StackTraceElement =&gt; Boolean)(implicit bf: scala.collection.generic.CanBuildFrom[List[java.lang.StackTraceElement],Boolean,List[Boolean]])List[Boolean]">stackTraceList</a><span class="delimiter">)</span> <span class="keyword">yield</span>
        <a href="#48651" title="java.lang.StackTraceElement">element</a>.<span title="()java.lang.String">getFileName</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#48519" title="String">fileName</a> <span class="comment">// such as &quot;Checkers.scala&quot;</span>

    <span class="keyword">val</span> <a title="List[Boolean]" id="48526">methodNameIsDesiredList</a>: <span title="List[Boolean]">List</span><span class="delimiter">[</span>Boolean<span class="delimiter">]</span> =
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="java.lang.StackTraceElement" id="48694">element</a> &lt;- <a href="#48524" title="(f: java.lang.StackTraceElement =&gt; Boolean)(implicit bf: scala.collection.generic.CanBuildFrom[List[java.lang.StackTraceElement],Boolean,List[Boolean]])List[Boolean]">stackTraceList</a><span class="delimiter">)</span> <span class="keyword">yield</span>
        <a href="#48694" title="java.lang.StackTraceElement">element</a>.<span title="()java.lang.String">getMethodName</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#48520" title="String">methodName</a> <span class="comment">// such as &quot;check&quot;</span>

    <span class="comment">// For element 0, the previous file name was not desired, because there is no previous</span>
    <span class="comment">// one, so you start with false. For element 1, it depends on whether element 0 of the stack trace</span>
    <span class="comment">// had the desired file name, and so forth.</span>
    <span class="keyword">val</span> <a title="List[Boolean]" id="48527">previousFileNameIsDesiredList</a>: <span title="List[Boolean]">List</span><span class="delimiter">[</span>Boolean<span class="delimiter">]</span> = <span title="Boolean(false)" class="keyword">false</span> <a href="#48727" title="(x: Boolean)List[Boolean]">::</a> <span class="delimiter">(</span><a href="#48525" title="List[Boolean]">fileNameIsDesiredList</a>.<span title="(n: Int)List[Boolean]">dropRight</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">// Zip these two related lists together. They now have two boolean values together, when both</span>
    <span class="comment">// are true, that's a stack trace element that should be included in the stack depth.</span>
    <span class="keyword">val</span> <a title="List[(Boolean, Boolean)]" id="48528">zipped1</a> = <a href="#48526" title="List[Boolean]">methodNameIsDesiredList</a> <span title="(that: scala.collection.GenIterable[Boolean])(implicit bf: scala.collection.generic.CanBuildFrom[List[Boolean],(Boolean, Boolean),List[(Boolean, Boolean)]])List[(Boolean, Boolean)]">zip</span> <a href="#48527" title="List[Boolean]">previousFileNameIsDesiredList</a>
    <span class="keyword">val</span> <a title="List[Boolean]" id="48529">methodNameAndPreviousFileNameAreDesiredList</a>: <span title="List[Boolean]">List</span><span class="delimiter">[</span>Boolean<span class="delimiter">]</span> =
      <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="Boolean" id="48811">methodNameIsDesired</a>, <a title="Boolean" id="48812">previousFileNameIsDesired</a><span class="delimiter">)</span> &lt;- <a href="#48528" title="(f: (Boolean, Boolean) =&gt; Boolean)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Boolean, Boolean)],Boolean,List[Boolean]])List[Boolean]">zipped1</a><span class="delimiter">)</span> <span class="keyword">yield</span>
        <a href="#48811" title="Boolean">methodNameIsDesired</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#48812" title="Boolean">previousFileNameIsDesired</a>

    <span class="comment">// Include all falses up to the first true in the stack depth count</span>
    <span class="keyword">val</span> <a title="Int" id="48530">result</a> = <a href="#48529" title="List[Boolean]">methodNameAndPreviousFileNameAreDesiredList</a>.<span title="(p: Boolean =&gt; Boolean)List[Boolean]">takeWhile</span><span class="delimiter">(</span><a title="Boolean" id="48846">b</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#48846" title="Boolean">b</a><span class="delimiter">)</span>.<span title="=&gt; Int">length</span> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>

    <span class="keyword">def</span> <a title="(e1: java.lang.StackTraceElement, e2: java.lang.StackTraceElement)Boolean" id="48531">hasSameFileNameAndLineNumber</a><span class="delimiter">(</span><a title="java.lang.StackTraceElement" id="48852">e1</a>: <span title="java.lang.StackTraceElement">StackTraceElement</span>, <a title="java.lang.StackTraceElement" id="48853">e2</a>: <span title="java.lang.StackTraceElement">StackTraceElement</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#48852" title="java.lang.StackTraceElement">e1</a>.<span title="()java.lang.String">getFileName</span> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span> <span title="(x: Boolean)Boolean">||</span> <a href="#48852" title="java.lang.StackTraceElement">e1</a>.<span title="()Int">getLineNumber</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">||</span> <a href="#48853" title="java.lang.StackTraceElement">e2</a>.<span title="()java.lang.String">getFileName</span> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span> <span title="(x: Boolean)Boolean">||</span> <a href="#48853" title="java.lang.StackTraceElement">e2</a>.<span title="()Int">getLineNumber</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="Boolean(false)" class="keyword">false</span>
      <span class="keyword">else</span> <span class="delimiter">(</span><a href="#48852" title="java.lang.StackTraceElement">e1</a>.<span title="()java.lang.String">getFileName</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#48853" title="java.lang.StackTraceElement">e2</a>.<span title="()java.lang.String">getFileName</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#48852" title="java.lang.StackTraceElement">e1</a>.<span title="()Int">getLineNumber</span> <span title="(x: Int)Boolean">==</span> <a href="#48853" title="java.lang.StackTraceElement">e2</a>.<span title="()Int">getLineNumber</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// For some reason, the same filename and line number is showing up twice at the stack depth for</span>
    <span class="comment">// GeneratorDrivenPropertyChecks. Would look prettier to cut off one of them.</span>
    <span class="comment">//</span>
    <span class="comment">// TEST FAILED - PropertyChecksSuite: fraction property check (PropertyChecksSuite.scala:38) (202 milliseconds)</span>
    <span class="comment">//   Gave up after 0 successful property evaluations. 500 evaluations were discarded.</span>
    <span class="comment">//   org.scalatest.prop.GeneratorDrivenPropertyCheckFailedException: Gave up after 0 successful property evaluations. 500 evaluations were discarded.</span>
    <span class="comment">//   ...</span>
    <span class="comment">//   at org.scalatest.prop.PropertyChecksSuite$$anonfun$2.apply(PropertyChecksSuite.scala:38)</span>
    <span class="comment">//   at org.scalatest.prop.PropertyChecksSuite$$anonfun$2.apply(PropertyChecksSuite.scala:38)</span>
    <span class="comment">//   at org.scalatest.FunSuite$$anon$4.apply(FunSuite.scala:1146)</span>
    <span class="comment">//   at org.scalatest.Suite$class.withFixture(Suite.scala:1478)</span>
    <span class="comment">//   at org.scalatest.prop.PropertyChecksSuite.withFixture(PropertyChecksSuite.scala:24)</span>
    <span class="comment">//   at org.scalatest.FunSuite$class.runTest(FunSuite.scala:1143)</span>
    <span class="comment">//   at org.scalatest.prop.PropertyChecksSuite.runTest(PropertyChecksSuite.scala:24)</span>
    <span class="comment">//   ...</span>
    <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#48524" title="List[java.lang.StackTraceElement]">stackTraceList</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">&gt;</span> <a href="#48530" title="Int">result</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#48531" title="(e1: java.lang.StackTraceElement, e2: java.lang.StackTraceElement)Boolean">hasSameFileNameAndLineNumber</a><span class="delimiter">(</span><a href="#48524" title="(n: Int)java.lang.StackTraceElement">stackTraceList</a><span class="delimiter">(</span><a href="#48530" title="Int">result</a><span class="delimiter">)</span>, <a href="#48524" title="(n: Int)java.lang.StackTraceElement">stackTraceList</a><span class="delimiter">(</span><a href="#48530" title="Int">result</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#48530" title="Int">result</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span> <span class="keyword">else</span> <a href="#48530" title="Int">result</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>