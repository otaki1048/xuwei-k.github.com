<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>org/scalatest/FlatSpec.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright 2001-2009 Artima, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>
<span class="keyword">package</span> org.scalatest

<span class="keyword">import</span> verb.<span class="delimiter">{</span>ResultOfTaggedAsInvocation, ResultOfStringPassedToVerb, BehaveWord, ShouldVerb, MustVerb, CanVerb<span class="delimiter">}</span>
<span class="keyword">import</span> <a href="NodeFamily.scala.html#10254" title="object org.scalatest.NodeFamily">NodeFamily</a>._
<span class="keyword">import</span> scala.collection.immutable.ListSet
<span class="keyword">import</span> org.scalatest.<a href="StackDepthException.scala.html#9555" title="object org.scalatest.StackDepthExceptionHelper">StackDepthExceptionHelper</a>.getStackDepth
<span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference
<span class="keyword">import</span> java.util.ConcurrentModificationException
<span class="keyword">import</span> org.scalatest.events._
<span class="keyword">import</span> <a href="Suite.scala.html#10074" title="object org.scalatest.Suite">Suite</a>.anErrorThatShouldCauseAnAbort

<span class="comment">/**
 * Trait that facilitates a &amp;#8220;behavior-driven&amp;#8221; style of development (BDD), in which tests
 * are combined with text that specifies the behavior the tests verify.
 * (In BDD, the word &lt;em&gt;example&lt;/em&gt; is usually used instead of &lt;em&gt;test&lt;/em&gt;. The word test will not appear
 * in your code if you use &lt;code&gt;FlatSpec&lt;/code&gt;, so if you prefer the word &lt;em&gt;example&lt;/em&gt; you can use it. However, in this documentation
 * the word &lt;em&gt;test&lt;/em&gt; will be used, for clarity and to be consistent with the rest of ScalaTest.)
 * Trait &lt;code&gt;FlatSpec&lt;/code&gt; is so named because
 * your specification text and tests line up flat against the left-side indentation level, with no nesting needed.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * &lt;code&gt;FlatSpec&lt;/code&gt;'s no-nesting approach contrasts with traits &lt;code&gt;Spec&lt;/code&gt; and &lt;code&gt;WordSpec&lt;/code&gt;, which use nesting
 * to reduce duplication of specification text. Although nesting does have the advantage of reducing text duplication,
 * figuring out the full specification text for one test can require back-tracking out of several levels of nesting, mentally prepending
 * each fragment of text encountered. Thus the tradeoff with the nesting approach of &lt;code&gt;Spec&lt;/code&gt; and &lt;code&gt;WordSpec&lt;/code&gt; is that
 * they have less duplicated text at the cost of being a bit challenging to read. Trait &lt;code&gt;FlatSpec&lt;/code&gt; offers the opposite
 * tradeoff. In a &lt;code&gt;FlatSpec&lt;/code&gt; text is duplicated more, but figuring out the full specification text for a particular test is
 * easier. Here's an example &lt;code&gt;FlatSpec&lt;/code&gt;:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.FlatSpec
 * import scala.collection.mutable.Stack
 *
 * class StackSpec extends FlatSpec {
 *
 *   behavior of &quot;A Stack&quot;
 *
 *   it should &quot;pop values in last-in-first-out order&quot; in {
 *     val stack = new Stack[Int]
 *     stack.push(1)
 *     stack.push(2)
 *     assert(stack.pop() === 2)
 *     assert(stack.pop() === 1)
 *   }
 *
 *   it should &quot;throw NoSuchElementException if an empty stack is popped&quot; in {
 *     val emptyStack = new Stack[String]
 *     intercept[NoSuchElementException] {
 *       emptyStack.pop()
 *     }
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Note: you can you &lt;code&gt;must&lt;/code&gt; or &lt;code&gt;can&lt;/code&gt; as well as &lt;code&gt;should&lt;/code&gt; in a &lt;code&gt;FlatSpec&lt;/code&gt;. For example, instead of
 * &lt;code&gt;it should &quot;pop&lt;/code&gt;..., you could write &lt;code&gt;it must &quot;pop&lt;/code&gt;... or &lt;code&gt;it can &quot;pop&lt;/code&gt;....
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Instead of using a &lt;code&gt;behavior of&lt;/code&gt; clause, you can alternatively use a shorthand syntax in which you replace
 * the first &lt;code&gt;it&lt;/code&gt; with the subject string, like this:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.FlatSpec
 * import scala.collection.mutable.Stack
 *
 * class StackSpec extends FlatSpec {
 *
 *   &quot;A Stack&quot; should &quot;pop values in last-in-first-out order&quot; in {
 *     val stack = new Stack[Int]
 *     stack.push(1)
 *     stack.push(2)
 *     assert(stack.pop() === 2)
 *     assert(stack.pop() === 1)
 *   }
 *
 *   it should &quot;throw NoSuchElementException if an empty stack is popped&quot; in {
 *     val emptyStack = new Stack[String]
 *     intercept[NoSuchElementException] {
 *       emptyStack.pop()
 *     }
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Running either of the two previous three versions of &lt;code&gt;StackSpec&lt;/code&gt; in the Scala interpreter would yield:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stREPL&quot;&gt;
 * &lt;span class=&quot;stGreen&quot;&gt;A Stack
 * - should pop values in last-in-first-out order
 * - should throw NoSuchElementException if an empty stack is popped&lt;/span&gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * In a &lt;code&gt;FlatSpec&lt;/code&gt; you write a one (or more) sentence specification for each bit of behavior you wish to
 * specify and test. Each specification sentence has a
 * &quot;subject,&quot; which is sometimes called the &lt;em&gt;system under test&lt;/em&gt; (or SUT). The 
 * subject is the entity being specified and tested and also serves as the subject of the sentences you write for each test.
 * Often you will want to write multiple tests for the same subject. In a &lt;code&gt;FlatSpec&lt;/code&gt;, you name the subject once,
 * with a &lt;code&gt;behavior of&lt;/code&gt; clause or its shorthand, then write tests for that subject with &lt;code&gt;it should&lt;/code&gt;/&lt;code&gt;must&lt;/code&gt;&lt;code&gt;can &quot;do something&quot;&lt;/code&gt; phrases.
 * Each &lt;code&gt;it&lt;/code&gt; refers to the most recently declared subject. For example, the four tests shown in this snippet are all testing
 * a stack that contains one item:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * behavior of &quot;A Stack (with one item)&quot;
 *
 * it should &quot;be non-empty&quot; in {}
 *
 * it should &quot;return the top item on peek&quot; in {}
 *
 * it should &quot;not remove the top item on peek&quot; in {}
 *
 * it should &quot;remove the top item on pop&quot; in {}
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * The same is true if the tests are written using the shorthand notation:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * &quot;A Stack (with one item)&quot; should &quot;be non-empty&quot; in {}
 *
 * it should &quot;return the top item on peek&quot; in {}
 *
 * it should &quot;not remove the top item on peek&quot; in {}
 *
 * it should &quot;remove the top item on pop&quot; in {}
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * In a &lt;code&gt;FlatSpec&lt;/code&gt;, therefore, to figure out what &quot;&lt;code&gt;it&lt;/code&gt;&quot; means, you just scan vertically until you find the most
 * recent use of &lt;code&gt;behavior of&lt;/code&gt; or the shorthand notation.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * A &lt;code&gt;FlatSpec&lt;/code&gt;'s lifecycle has two phases: the &lt;em&gt;registration&lt;/em&gt; phase and the
 * &lt;em&gt;ready&lt;/em&gt; phase. It starts in registration phase and enters ready phase the first time
 * &lt;code&gt;run&lt;/code&gt; is called on it. It then remains in ready phase for the remainder of its lifetime.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Tests can only be registered while the &lt;code&gt;FlatSpec&lt;/code&gt; is
 * in its registration phase. Any attempt to register a test after the &lt;code&gt;FlatSpec&lt;/code&gt; has
 * entered its ready phase, &lt;em&gt;i.e.&lt;/em&gt;, after &lt;code&gt;run&lt;/code&gt; has been invoked on the &lt;code&gt;FlatSpec&lt;/code&gt;,
 * will be met with a thrown &lt;code&gt;TestRegistrationClosedException&lt;/code&gt;. The recommended style
 * of using &lt;code&gt;FlatSpec&lt;/code&gt; is to register tests during object construction as is done in all
 * the examples shown here. If you keep to the recommended style, you should never see a
 * &lt;code&gt;TestRegistrationClosedException&lt;/code&gt;.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * See also: &lt;a href=&quot;http://www.scalatest.org/getting_started_with_flat_spec&quot; target=&quot;_blank&quot;&gt;Getting started with &lt;code&gt;FlatSpec&lt;/code&gt;.&lt;/a&gt;
 * &lt;/p&gt;
 *
 * &lt;a name=&quot;IgnoredTests&quot;&gt;&lt;/a&gt;&lt;h2&gt;Ignored tests&lt;/h2&gt;
 *
 * To support the common use case of &amp;#8220;temporarily&amp;#8221; disabling a test, with the
 * good intention of resurrecting the test at a later time, &lt;code&gt;FlatSpec&lt;/code&gt; provides a method
 * &lt;code&gt;ignore&lt;/code&gt; that can be used instead of &lt;code&gt;it&lt;/code&gt; to register a test. For example, to temporarily
 * disable the test with the name &lt;code&gt;&quot;A Stack should throw NoSuchElementException if an empty stack is popped&quot;&lt;/code&gt;, just
 * change &amp;#8220;&lt;code&gt;it&lt;/code&gt;&amp;#8221; into &amp;#8220;&lt;code&gt;ignore&lt;/code&gt;,&amp;#8221; like this:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.FlatSpec
 * import scala.collection.mutable.Stack
 *
 * class StackSpec extends FlatSpec {
 *
 *   &quot;A Stack&quot; should &quot;pop values in last-in-first-out order&quot; in {
 *       val stack = new Stack[Int]
 *       stack.push(1)
 *       stack.push(2)
 *       assert(stack.pop() === 2)
 *       assert(stack.pop() === 1)
 *     }
 *
 *   ignore should &quot;throw NoSuchElementException if an empty stack is popped&quot; in {
 *     val emptyStack = new Stack[String]
 *     intercept[NoSuchElementException] {
 *       emptyStack.pop()
 *     }
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * If you run this version of &lt;code&gt;StackSpec&lt;/code&gt; with:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stREPL&quot;&gt;
 * scala&gt; (new StackSpec).execute()
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * It will run only the first test and report that the second test was ignored:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stREPL&quot;&gt;
 * &lt;span class=&quot;stGreen&quot;&gt;A Stack
 * - should pop values in last-in-first-out order&lt;/span&gt;
 * &lt;span class=&quot;stYellow&quot;&gt;- should throw NoSuchElementException if an empty stack is popped !!! IGNORED !!!&lt;/span&gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * When using shorthand notation, you won't have an &lt;code&gt;it&lt;/code&gt; to change into &lt;code&gt;ignore&lt;/code&gt; for
 * the first test of each new subject. To ignore such tests, you must instead change &lt;code&gt;in&lt;/code&gt; to &lt;code&gt;ignore&lt;/code&gt;.
 * For example, to temporarily disable the test with the name &lt;code&gt;&quot;A Stack should pop values in last-in-first-out order&quot;&lt;/code&gt;,
 * change &amp;#8220;&lt;code&gt;in&lt;/code&gt;&amp;#8221; into &amp;#8220;&lt;code&gt;ignore&lt;/code&gt;&amp;#8221; like this:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.FlatSpec
 * import scala.collection.mutable.Stack
 *
 * class StackSpec extends FlatSpec {
 *
 *   &quot;A Stack&quot; should &quot;pop values in last-in-first-out order&quot; ignore {
 *       val stack = new Stack[Int]
 *       stack.push(1)
 *       stack.push(2)
 *       assert(stack.pop() === 2)
 *       assert(stack.pop() === 1)
 *     }
 *
 *   it should &quot;throw NoSuchElementException if an empty stack is popped&quot; in {
 *     val emptyStack = new Stack[String]
 *     intercept[NoSuchElementException] {
 *       emptyStack.pop()
 *     }
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * If you run this version of &lt;code&gt;StackSpec&lt;/code&gt; with:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stREPL&quot;&gt;
 * scala&gt; (new StackSpec).execute()
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * It will run only the second test and report that the first test was ignored:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stREPL&quot;&gt;
 * &lt;span class=&quot;stGreen&quot;&gt;A Stack&lt;/span&gt;
 * &lt;span class=&quot;stYellow&quot;&gt;- should pop values in last-in-first-out order !!! IGNORED !!!&lt;/span&gt;
 * &lt;span class=&quot;stGreen&quot;&gt;- should throw NoSuchElementException if an empty stack is popped&lt;/span&gt;
 * &lt;/pre&gt;
 *
 * &lt;h2&gt;Informers&lt;/h2&gt;
 *
 * &lt;p&gt;
 * One of the parameters to the &lt;code&gt;run&lt;/code&gt; method is a &lt;code&gt;Reporter&lt;/code&gt;, which
 * will collect and report information about the running suite of tests.
 * Information about suites and tests that were run, whether tests succeeded or failed, 
 * and tests that were ignored will be passed to the &lt;code&gt;Reporter&lt;/code&gt; as the suite runs.
 * Most often the reporting done by default by &lt;code&gt;FlatSpec&lt;/code&gt;'s methods will be sufficient, but
 * occasionally you may wish to provide custom information to the &lt;code&gt;Reporter&lt;/code&gt; from a test.
 * For this purpose, an &lt;code&gt;Informer&lt;/code&gt; that will forward information to the current &lt;code&gt;Reporter&lt;/code&gt;
 * is provided via the &lt;code&gt;info&lt;/code&gt; parameterless method.
 * You can pass the extra information to the &lt;code&gt;Informer&lt;/code&gt; via its &lt;code&gt;apply&lt;/code&gt; method.
 * The &lt;code&gt;Informer&lt;/code&gt; will then pass the information to the &lt;code&gt;Reporter&lt;/code&gt; via an &lt;code&gt;InfoProvided&lt;/code&gt; event.
 * Here's an example:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.FlatSpec
 *
 * class ArithmeticSpec extends FlatSpec {
 *
 *  &quot;The Scala language&quot; must &quot;add correctly&quot; in {
 *     val sum = 2 + 3
 *     assert(sum === 5)
 *     info(&quot;addition seems to work&quot;)
 *   }
 *
 *   it must &quot;subtract correctly&quot; in {
 *     val diff = 7 - 2
 *     assert(diff === 5)
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * If you run this &lt;code&gt;FlatSpec&lt;/code&gt; from the interpreter, you will see the following message
 * included in the printed report:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stREPL&quot;&gt;
 * scala&gt; (new ArithmeticSpec).execute()
 * &lt;span class=&quot;stGreen&quot;&gt;The Scala language 
 * - must add correctly
 *   + addition seems to work 
 * - must subtract correctly&lt;/span&gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * One use case for the &lt;code&gt;Informer&lt;/code&gt; is to pass more information about a specification to the reporter. For example,
 * the &lt;code&gt;GivenWhenThen&lt;/code&gt; trait provides methods that use the implicit &lt;code&gt;info&lt;/code&gt; provided by &lt;code&gt;FlatSpec&lt;/code&gt;
 * to pass such information to the reporter. Here's an example:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.FlatSpec
 * import org.scalatest.GivenWhenThen
 * 
 * class ArithmeticSpec extends FlatSpec with GivenWhenThen {
 * 
 *  &quot;The Scala language&quot; must &quot;add correctly&quot; in { 
 * 
 *     given(&quot;two integers&quot;)
 *     val x = 2
 *     val y = 3
 * 
 *     when(&quot;they are added&quot;)
 *     val sum = x + y
 * 
 *     then(&quot;the result is the sum of the two numbers&quot;)
 *     assert(sum === 5)
 *   }
 * 
 *   it must &quot;subtract correctly&quot; in {
 * 
 *     given(&quot;two integers&quot;)
 *     val x = 7
 *     val y = 2
 * 
 *     when(&quot;one is subtracted from the other&quot;)
 *     val diff = x - y
 * 
 *     then(&quot;the result is the difference of the two numbers&quot;)
 *     assert(diff === 5)
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;pre class=&quot;stREPL&quot;&gt;
 * scala&gt; (new ArithmeticSpec).execute()
 * &lt;span class=&quot;stGreen&quot;&gt;The Scala language 
 * - must add correctly
 *   + Given two integers 
 *   + When they are added 
 *   + Then the result is the sum of the two numbers 
 * - must subtract correctly
 *   + Given two integers 
 *   + When one is subtracted from the other 
 *   + Then the result is the difference of the two numbers&lt;/span&gt; 
 * &lt;/pre&gt;
 *
 * &lt;a name=&quot;PendingTests&quot;&gt;&lt;h2&gt;Pending tests&lt;/h2&gt;&lt;/a&gt;
 *
 * &lt;p&gt;
 * A &lt;em&gt;pending test&lt;/em&gt; is one that has been given a name but is not yet implemented. The purpose of
 * pending tests is to facilitate a style of testing in which documentation of behavior is sketched
 * out before tests are written to verify that behavior (and often, before the behavior of
 * the system being tested is itself implemented). Such sketches form a kind of specification of
 * what tests and functionality to implement later.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * To support this style of testing, a test can be given a name that specifies one
 * bit of behavior required by the system being tested. The test can also include some code that
 * sends more information about the behavior to the reporter when the tests run. At the end of the test,
 * it can call method &lt;code&gt;pending&lt;/code&gt;, which will cause it to complete abruptly with &lt;code&gt;TestPendingException&lt;/code&gt;.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Because tests in ScalaTest can be designated as pending with &lt;code&gt;TestPendingException&lt;/code&gt;, both the test name and any information
 * sent to the reporter when running the test can appear in the report of a test run. (In other words,
 * the code of a pending test is executed just like any other test.) However, because the test completes abruptly
 * with &lt;code&gt;TestPendingException&lt;/code&gt;, the test will be reported as pending, to indicate
 * the actual test, and possibly the functionality it is intended to test, has not yet been implemented.
 * You can mark tests as pending in &lt;code&gt;FlatSpec&lt;/code&gt; like this:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.FlatSpec
 *
 * class ArithmeticSpec extends FlatSpec {
 *
 *   // Sharing fixture objects via instance variables
 *   val shared = 5
 *
 *  &quot;The Scala language&quot; must &quot;add correctly&quot; in {
 *     val sum = 2 + 3
 *     assert(sum === shared)
 *   }
 *
 *   it must &quot;subtract correctly&quot; is (pending)
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * If you run this version of &lt;code&gt;ArithmeticSpec&lt;/code&gt; with:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stREPL&quot;&gt;
 * scala&gt; (new ArithmeticSpec).execute()
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * It will run both tests but report that &lt;code&gt;The Scala language must subtract correctly&lt;/code&gt; is pending. You'll see:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stREPL&quot;&gt;
 * &lt;span class=&quot;stGreen&quot;&gt;The Scala language
 * - must add correctly&lt;/span&gt;
 * &lt;span class=&quot;stYellow&quot;&gt;- must subtract correctly (pending)&lt;/span&gt;
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * One difference between an ignored test and a pending one is that an ignored test is intended to be used during a
 * significant refactorings of the code under test, when tests break and you don't want to spend the time to fix
 * all of them immediately. You can mark some of those broken tests as ignored temporarily, so that you can focus the red
 * bar on just failing tests you actually want to fix immediately. Later you can go back and fix the ignored tests.
 * In other words, by ignoring some failing tests temporarily, you can more easily notice failed tests that you actually
 * want to fix. By contrast, a pending test is intended to be used before a test and/or the code under test is written.
 * Pending indicates you've decided to write a test for a bit of behavior, but either you haven't written the test yet, or
 * have only written part of it, or perhaps you've written the test but don't want to implement the behavior it tests
 * until after you've implemented a different bit of behavior you realized you need first. Thus ignored tests are designed
 * to facilitate refactoring of existing code whereas pending tests are designed to facilitate the creation of new code.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * One other difference between ignored and pending tests is that ignored tests are implemented as a test tag that is
 * excluded by default. Thus an ignored test is never executed. By contrast, a pending test is implemented as a
 * test that throws &lt;code&gt;TestPendingException&lt;/code&gt; (which is what calling the &lt;code&gt;pending&lt;/code&gt; method does). Thus
 * the body of pending tests are executed up until they throw &lt;code&gt;TestPendingException&lt;/code&gt;. The reason for this difference
 * is that it enables your unfinished test to send &lt;code&gt;InfoProvided&lt;/code&gt; messages to the reporter before it completes
 * abruptly with &lt;code&gt;TestPendingException&lt;/code&gt;, as shown in the previous example on &lt;code&gt;Informer&lt;/code&gt;s
 * that used the &lt;code&gt;GivenWhenThen&lt;/code&gt; trait. For example, the following snippet in a &lt;code&gt;FlatSpec&lt;/code&gt;:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 *  &quot;The Scala language&quot; must &quot;add correctly&quot; in { 
 *     given(&quot;two integers&quot;)
 *     when(&quot;they are added&quot;)
 *     then(&quot;the result is the sum of the two numbers&quot;)
 *     pending
 *   }
 *   // ...
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Would yield the following output when run in the interpreter:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stREPL&quot;&gt;
 * &lt;span class=&quot;stGreen&quot;&gt;The Scala language&lt;/span&gt;
 * &lt;span class=&quot;stYellow&quot;&gt;- must add correctly (pending)
 *   + Given two integers 
 *   + When they are added 
 *   + Then the result is the sum of the two numbers&lt;/span&gt; 
 * &lt;/pre&gt;
 *
 * &lt;a name=&quot;TaggingTests&quot;&gt;&lt;/a&gt;&lt;h2&gt;Tagging tests&lt;/h2&gt;
 *
 * A &lt;code&gt;FlatSpec&lt;/code&gt;'s tests may be classified into groups by &lt;em&gt;tagging&lt;/em&gt; them with string names.
 * As with any suite, when executing a &lt;code&gt;FlatSpec&lt;/code&gt;, groups of tests can
 * optionally be included and/or excluded. To tag a &lt;code&gt;FlatSpec&lt;/code&gt;'s tests,
 * you pass objects that extend abstract class &lt;code&gt;org.scalatest.Tag&lt;/code&gt; to &lt;code&gt;taggedAs&lt;/code&gt; method
 * invoked on the string that describes the test you want to tag. Class &lt;code&gt;Tag&lt;/code&gt; takes one parameter,
 * a string name.  If you have
 * created Java annotation interfaces for use as group names in direct subclasses of &lt;code&gt;org.scalatest.Suite&lt;/code&gt;,
 * then you will probably want to use group names on your &lt;code&gt;FlatSpec&lt;/code&gt;s that match. To do so, simply 
 * pass the fully qualified names of the Java interfaces to the &lt;code&gt;Tag&lt;/code&gt; constructor. For example, if you've
 * defined Java annotation interfaces with fully qualified names, &lt;code&gt;com.mycompany.tags.SlowTest&lt;/code&gt; and &lt;code&gt;com.mycompany.tags.DbTest&lt;/code&gt;, then you could
 * create matching groups for &lt;code&gt;Spec&lt;/code&gt;s like this:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.Tag
 *
 * object SlowTest extends Tag(&quot;com.mycompany.tags.SlowTest&quot;)
 * object DbTest extends Tag(&quot;com.mycompany.tags.DbTest&quot;)
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Given these definitions, you could place &lt;code&gt;FlatSpec&lt;/code&gt; tests into groups like this:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.FlatSpec
 *
 * class ExampleSpec extends FlatSpec {
 *
 *   &quot;The Scala language&quot; must &quot;add correctly&quot; taggedAs(SlowTest) in {
 *       val sum = 1 + 1
 *       assert(sum === 2)
 *     }
 *
 *   it must &quot;subtract correctly&quot; taggedAs(SlowTest, DbTest) in {
 *     val diff = 4 - 1
 *     assert(diff === 3)
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * This code marks both tests with the &lt;code&gt;com.mycompany.tags.SlowTest&lt;/code&gt; tag, 
 * and test &lt;code&gt;&quot;The Scala language should subtract correctly&quot;&lt;/code&gt; with the &lt;code&gt;com.mycompany.tags.DbTest&lt;/code&gt; tag.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The &lt;code&gt;run&lt;/code&gt; method takes a &lt;code&gt;Filter&lt;/code&gt;, whose constructor takes an optional
 * &lt;code&gt;Set[String]&lt;/code&gt; called &lt;code&gt;tagsToInclude&lt;/code&gt; and a &lt;code&gt;Set[String]&lt;/code&gt; called
 * &lt;code&gt;tagsToExclude&lt;/code&gt;. If &lt;code&gt;tagsToInclude&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, all tests will be run
 * except those those belonging to tags listed in the
 * &lt;code&gt;tagsToExclude&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt;. If &lt;code&gt;tagsToInclude&lt;/code&gt; is defined, only tests
 * belonging to tags mentioned in the &lt;code&gt;tagsToInclude&lt;/code&gt; set, and not mentioned in &lt;code&gt;tagsToExclude&lt;/code&gt;,
 * will be run.
 * &lt;/p&gt;
 *
 * &lt;a name=&quot;sharedFixtures&quot;&gt;&lt;/a&gt;&lt;h2&gt;Shared fixtures&lt;/h2&gt;
 *
 * &lt;p&gt;
 * A test &lt;em&gt;fixture&lt;/em&gt; is objects or other artifacts (such as files, sockets, database
 * connections, &lt;em&gt;etc.&lt;/em&gt;) used by tests to do their work.
 * If a fixture is used by only one test method, then the definitions of the fixture objects can
 * be local to the method, such as the objects assigned to &lt;code&gt;sum&lt;/code&gt; and &lt;code&gt;diff&lt;/code&gt; in the
 * previous &lt;code&gt;ExampleSpec&lt;/code&gt; examples. If multiple methods need to share an immutable fixture, one approach
 * is to assign them to instance variables.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * In some cases, however, shared &lt;em&gt;mutable&lt;/em&gt; fixture objects may be changed by test methods such that
 * they need to be recreated or reinitialized before each test. Shared resources such
 * as files or database connections may also need to 
 * be created and initialized before, and cleaned up after, each test. JUnit 3 offered methods &lt;code&gt;setUp&lt;/code&gt; and
 * &lt;code&gt;tearDown&lt;/code&gt; for this purpose. In ScalaTest, you can use the &lt;code&gt;BeforeAndAfterEach&lt;/code&gt; trait,
 * which will be described later, to implement an approach similar to JUnit's &lt;code&gt;setUp&lt;/code&gt;
 * and &lt;code&gt;tearDown&lt;/code&gt;, however, this approach usually involves reassigning &lt;code&gt;var&lt;/code&gt;s or mutating objects
 * between tests. Before going that route, you may wish to consider some more functional approaches that
 * avoid side effects.
 * &lt;/p&gt;
 *
 * &lt;h4&gt;Calling create-fixture methods&lt;/h4&gt;
 *
 * &lt;p&gt;
 * One approach is to write one or more &lt;em&gt;create-fixture&lt;/em&gt; methods
 * that return a new instance of a needed fixture object (or an holder object containing multiple needed fixture objects) each time it
 * is called. You can then call a create-fixture method at the beginning of each
 * test method that needs the fixture, storing the returned object or objects in local variables. Here's an example:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.FlatSpec
 * import collection.mutable.ListBuffer
 *
 * class ExampleSpec extends FlatSpec {
 * 
 *   def fixture =
 *     new {
 *       val builder = new StringBuilder(&quot;ScalaTest is &quot;)
 *       val buffer = new ListBuffer[String]
 *     }
 * 
 *   &quot;Testing&quot; should &quot;be easy&quot; in {
 *     val f = fixture
 *     f.builder.append(&quot;easy!&quot;)
 *     assert(f.builder.toString === &quot;ScalaTest is easy!&quot;)
 *     assert(f.buffer.isEmpty)
 *     f.buffer += &quot;sweet&quot;
 *   }
 * 
 *   it should &quot;be fun&quot; in {
 *     val f = fixture
 *     f.builder.append(&quot;fun!&quot;)
 *     assert(f.builder.toString === &quot;ScalaTest is fun!&quot;)
 *     assert(f.buffer.isEmpty)
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * The &amp;ldquo;&lt;code&gt;f.&lt;/code&gt;&amp;rdquo; in front of each use of a fixture object provides a visual indication of which objects 
 * are part of the fixture, but if you prefer, you can import the the members with &amp;ldquo;&lt;code&gt;import f._&lt;/code&gt;&amp;rdquo; and use the names directly.
 * &lt;/p&gt;
 *
 * &lt;h4&gt;Instantiating fixture traits&lt;/h4&gt;
 *
 * &lt;p&gt;
 * A related technique is to place
 * the fixture objects in a &lt;em&gt;fixture trait&lt;/em&gt; and run your test code in the context of a new anonymous class instance that mixes in
 * the fixture trait, like this:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.FlatSpec
 * import collection.mutable.ListBuffer
 * 
 * class ExampleSpec extends FlatSpec {
 * 
 *   trait Fixture {
 *     val builder = new StringBuilder(&quot;ScalaTest is &quot;)
 *     val buffer = new ListBuffer[String]
 *   }
 * 
 *   &quot;Testing&quot; should &quot;be easy&quot; in {
 *     new Fixture {
 *       builder.append(&quot;easy!&quot;)
 *       assert(builder.toString === &quot;ScalaTest is easy!&quot;)
 *       assert(buffer.isEmpty)
 *       buffer += &quot;sweet&quot;
 *     }
 *   }
 * 
 *   it should &quot;be fun&quot; in {
 *     new Fixture {
 *       builder.append(&quot;fun!&quot;)
 *       assert(builder.toString === &quot;ScalaTest is fun!&quot;)
 *       assert(buffer.isEmpty)
 *     }
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;h4&gt;Mixing in &lt;code&gt;OneInstancePerTest&lt;/code&gt;&lt;/h4&gt;
 *
 * &lt;p&gt;
 * If every test method requires the same set of
 * mutable fixture objects, one other approach you can take is make them simply &lt;code&gt;val&lt;/code&gt;s and mix in trait
 * &lt;a href=&quot;OneInstancePerTest.html&quot;&gt;&lt;code&gt;OneInstancePerTest&lt;/code&gt;&lt;/a&gt;.  If you mix in &lt;code&gt;OneInstancePerTest&lt;/code&gt;, each test
 * will be run in its own instance of the &lt;code&gt;Suite&lt;/code&gt;, similar to the way JUnit tests are executed. Here's an example:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.FlatSpec
 * import org.scalatest.OneInstancePerTest
 * import collection.mutable.ListBuffer
 * 
 * class ExampleSpec extends FlatSpec with OneInstancePerTest {
 * 
 *   val builder = new StringBuilder(&quot;ScalaTest is &quot;)
 *   val buffer = new ListBuffer[String]
 * 
 *   &quot;Testing&quot; should &quot;be easy&quot; in {
 *     builder.append(&quot;easy!&quot;)
 *     assert(builder.toString === &quot;ScalaTest is easy!&quot;)
 *     assert(buffer.isEmpty)
 *     buffer += &quot;sweet&quot;
 *   }
 * 
 *   it should &quot;be fun&quot; in {
 *     builder.append(&quot;fun!&quot;)
 *     assert(builder.toString === &quot;ScalaTest is fun!&quot;)
 *     assert(buffer.isEmpty)
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Although the create-fixture, fixture-trait, and &lt;code&gt;OneInstancePerTest&lt;/code&gt; approaches take care of setting up a fixture before each
 * test, they don't address the problem of cleaning up a fixture after the test completes. In this situation, you'll need to either
 * use side effects or the &lt;em&gt;loan pattern&lt;/em&gt;.
 * &lt;/p&gt;
 *
 * &lt;h4&gt;Mixing in &lt;code&gt;BeforeAndAfter&lt;/code&gt;&lt;/h4&gt;
 *
 * &lt;p&gt;
 * One way to use side effects is to mix in the &lt;a href=&quot;BeforeAndAfter.html&quot;&gt;&lt;code&gt;BeforeAndAfter&lt;/code&gt;&lt;/a&gt; trait.
 * With this trait you can denote a bit of code to run before each test with &lt;code&gt;before&lt;/code&gt; and/or after each test
 * each test with &lt;code&gt;after&lt;/code&gt;, like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.FlatSpec
 * import org.scalatest.BeforeAndAfter
 * import collection.mutable.ListBuffer
 * 
 * class ExampleSpec extends FlatSpec with BeforeAndAfter {
 * 
 *   val builder = new StringBuilder
 *   val buffer = new ListBuffer[String]
 * 
 *   before {
 *     builder.append(&quot;ScalaTest is &quot;)
 *   }
 * 
 *   after {
 *     builder.clear()
 *     buffer.clear()
 *   }
 * 
 *   &quot;Testing&quot; should &quot;be easy&quot; in {
 *     builder.append(&quot;easy!&quot;)
 *     assert(builder.toString === &quot;ScalaTest is easy!&quot;)
 *     assert(buffer.isEmpty)
 *     buffer += &quot;sweet&quot;
 *   }
 * 
 *   it should &quot;be fun&quot; in {
 *     builder.append(&quot;fun!&quot;)
 *     assert(builder.toString === &quot;ScalaTest is fun!&quot;)
 *     assert(buffer.isEmpty)
 *   }
 * }
 * &lt;/pre&gt;
 * 
 * &lt;h4&gt;Overriding &lt;code&gt;withFixture(NoArgTest)&lt;/code&gt;&lt;/h4&gt;
 *
 * &lt;p&gt;
 * An alternate way to take care of setup and cleanup via side effects
 * is to override &lt;code&gt;withFixture&lt;/code&gt;. Trait &lt;code&gt;Suite&lt;/code&gt;'s implementation of
 * &lt;code&gt;runTest&lt;/code&gt;, which is inherited by this trait, passes a no-arg test function to &lt;code&gt;withFixture&lt;/code&gt;. It is &lt;code&gt;withFixture&lt;/code&gt;'s
 * responsibility to invoke that test function.  &lt;code&gt;Suite&lt;/code&gt;'s implementation of &lt;code&gt;withFixture&lt;/code&gt; simply
 * invokes the function, like this:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * // Default implementation
 * protected def withFixture(test: NoArgTest) {
 *   test()
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * You can, therefore, override &lt;code&gt;withFixture&lt;/code&gt; to perform setup before, and cleanup after, invoking the test function. If
 * you have cleanup to perform, you should invoke the test function
 * inside a &lt;code&gt;try&lt;/code&gt; block and perform the cleanup in a &lt;code&gt;finally&lt;/code&gt; clause.
 * Here's an example:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.FlatSpec
 * import collection.mutable.ListBuffer
 *
 * class ExampleSpec extends FlatSpec {
 *
 *   val builder = new StringBuilder
 *   val buffer = new ListBuffer[String]
 *
 *   override def withFixture(test: NoArgTest) {
 *     builder.append(&quot;ScalaTest is &quot;) // perform setup
 *     try {
 *       test() // invoke the test function
 *     }
 *     finally {
 *       builder.clear() // perform cleanup
 *       buffer.clear()
 *     }
 *   }
 *
 *   &quot;Testing&quot; should &quot;be easy&quot; in {
 *     builder.append(&quot;easy!&quot;)
 *     assert(builder.toString === &quot;ScalaTest is easy!&quot;)
 *     assert(buffer.isEmpty)
 *     buffer += &quot;sweet&quot;
 *   }
 *
 *   it should &quot;be fun&quot; in {
 *     builder.append(&quot;fun!&quot;)
 *     assert(builder.toString === &quot;ScalaTest is fun!&quot;)
 *     assert(buffer.isEmpty)
 *     buffer += &quot;clear&quot;
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Note that the &lt;a href=&quot;Suite$NoArgTest.html&quot;&gt;&lt;code&gt;NoArgTest&lt;/code&gt;&lt;/a&gt; passed to &lt;code&gt;withFixture&lt;/code&gt;, in addition to
 * an &lt;code&gt;apply&lt;/code&gt; method that executes the test, also includes the test name as well as the &lt;a href=&quot;Suite.html#configMapSection&quot;&gt;config
 * map&lt;/a&gt; passed to &lt;code&gt;runTest&lt;/code&gt;. Thus you can also use the test name and configuration objects in &lt;code&gt;withFixture&lt;/code&gt;.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The reason you should perform cleanup in a &lt;code&gt;finally&lt;/code&gt; clause is that &lt;code&gt;withFixture&lt;/code&gt; is called by
 * &lt;code&gt;runTest&lt;/code&gt;, which expects an exception to be thrown to indicate a failed test. Thus when you invoke
 * the &lt;code&gt;test&lt;/code&gt; function inside &lt;code&gt;withFixture&lt;/code&gt;, it may complete abruptly with an exception. The &lt;code&gt;finally&lt;/code&gt;
 * clause will ensure the fixture cleanup happens as that exception propagates back up the call stack to &lt;code&gt;runTest&lt;/code&gt;.
 * &lt;/p&gt;
 *
 * &lt;h4&gt;Overriding &lt;code&gt;withFixture(OneArgTest)&lt;/code&gt;&lt;/h4&gt;
 *
 * &lt;p&gt;
 * To use the loan pattern, you can extend &lt;code&gt;FixtureFlatSpec&lt;/code&gt; (from the &lt;code&gt;org.scalatest.fixture&lt;/code&gt; package) instead of
 * &lt;code&gt;FlatSpec&lt;/code&gt;. Each test in a &lt;code&gt;FixtureFlatSpec&lt;/code&gt; takes a fixture as a parameter, allowing you to pass the fixture into
 * the test. You must indicate the type of the fixture parameter by specifying &lt;code&gt;FixtureParam&lt;/code&gt;, and implement a
 * &lt;code&gt;withFixture&lt;/code&gt; method that takes a &lt;code&gt;OneArgTest&lt;/code&gt;. This &lt;code&gt;withFixture&lt;/code&gt; method is responsible for
 * invoking the one-arg test function, so you can perform fixture set up before, and clean up after, invoking and passing
 * the fixture into the test function. Here's an example:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.fixture.FixtureFlatSpec
 * import java.io.FileWriter
 * import java.io.File
 * 
 * class ExampleSpec extends FixtureFlatSpec {
 * 
 *   final val tmpFile = &quot;temp.txt&quot;
 * 
 *   type FixtureParam = FileWriter
 * 
 *   def withFixture(test: OneArgTest) {
 * 
 *     val writer = new FileWriter(tmpFile) // set up the fixture
 *     try {
 *       test(writer) // &quot;loan&quot; the fixture to the test
 *     }
 *     finally {
 *       writer.close() // clean up the fixture
 *     }
 *   }
 * 
 *   &quot;Testing&quot; should &quot;be easy&quot; in { writer =&gt;
 *     writer.write(&quot;Hello, test!&quot;)
 *     writer.flush()
 *     assert(new File(tmpFile).length === 12)
 *   }
 * 
 *   it should &quot;be fun&quot; in { writer =&gt;
 *     writer.write(&quot;Hi, test!&quot;)
 *     writer.flush()
 *     assert(new File(tmpFile).length === 9)
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * For more information, see the &lt;a href=&quot;fixture/FixtureFlatSpec.html&quot;&gt;documentation for &lt;code&gt;FixtureFlatSpec&lt;/code&gt;&lt;/a&gt;.
 * &lt;/p&gt;
 *
 * &lt;a name=&quot;differentFixtures&quot;&gt;&lt;/a&gt;&lt;h2&gt;Providing different fixtures to different tests&lt;/h2&gt;
 * 
 * &lt;p&gt;
 * If different tests in the same &lt;code&gt;FlatSpec&lt;/code&gt; require different fixtures, you can combine the previous techniques and
 * provide each test with just the fixture or fixtures it needs. Here's an example in which a &lt;code&gt;StringBuilder&lt;/code&gt; and a
 * &lt;code&gt;ListBuffer&lt;/code&gt; are provided via fixture traits, and file writer (that requires cleanup) is provided via the loan pattern:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import java.io.FileWriter
 * import java.io.File
 * import collection.mutable.ListBuffer
 * import org.scalatest.FlatSpec
 * 
 * class ExampleSpec extends FlatSpec {
 * 
 *   final val tmpFile = &quot;temp.txt&quot;
 * 
 *   trait Builder {
 *     val builder = new StringBuilder(&quot;ScalaTest is &quot;)
 *   }
 * 
 *   trait Buffer {
 *     val buffer = ListBuffer(&quot;ScalaTest&quot;, &quot;is&quot;)
 *   }
 * 
 *   def withWriter(testCode: FileWriter =&gt; Any) {
 *     val writer = new FileWriter(tmpFile) // set up the fixture
 *     try {
 *       testCode(writer) // &quot;loan&quot; the fixture to the test
 *     }
 *     finally {
 *       writer.close() // clean up the fixture
 *     }
 *   }
 * 
 *   &quot;Testing&quot; should &quot;be productive&quot; in { // This test needs the StringBuilder fixture
 *     new Builder {
 *       builder.append(&quot;productive!&quot;)
 *       assert(builder.toString === &quot;ScalaTest is productive!&quot;)
 *     }
 *   }
 * 
 *   it should &quot;be readable&quot; in { // This test needs the ListBuffer[String] fixture
 *     new Buffer {
 *       buffer += (&quot;readable!&quot;)
 *       assert(buffer === List(&quot;ScalaTest&quot;, &quot;is&quot;, &quot;readable!&quot;))
 *     }
 *   }
 * 
 *   it should &quot;be user-friendly&quot; in { // This test needs the FileWriter fixture
 *     withWriter { writer =&gt;
 *       writer.write(&quot;Hello, user!&quot;)
 *       writer.flush()
 *       assert(new File(tmpFile).length === 12)
 *     }
 *   }
 * 
 *   &quot;Test code&quot; should &quot;be clear and concise&quot; in { // This test needs the StringBuilder and ListBuffer
 *     new Builder with Buffer {
 *       builder.append(&quot;clear!&quot;)
 *       buffer += (&quot;concise!&quot;)
 *       assert(builder.toString === &quot;ScalaTest is clear!&quot;)
 *       assert(buffer === List(&quot;ScalaTest&quot;, &quot;is&quot;, &quot;concise!&quot;))
 *     }
 *   }
 * 
 *   it should &quot;be composable&quot; in { // This test needs all three fixtures
 *     new Builder with Buffer {
 *       builder.append(&quot;clear!&quot;)
 *       buffer += (&quot;concise!&quot;)
 *       assert(builder.toString === &quot;ScalaTest is clear!&quot;)
 *       assert(buffer === List(&quot;ScalaTest&quot;, &quot;is&quot;, &quot;concise!&quot;))
 *       withWriter { writer =&gt;
 *         writer.write(builder.toString)
 *         writer.flush()
 *         assert(new File(tmpFile).length === 19)
 *       }
 *     }
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * In the previous example, &lt;code&gt;ScalaTest should be productive&lt;/code&gt; uses only the &lt;code&gt;StringBuilder&lt;/code&gt; fixture, so it just instantiates
 * a &lt;code&gt;new Builder&lt;/code&gt;, whereas &lt;code&gt;it should be readable&lt;/code&gt; uses only the &lt;code&gt;ListBuffer&lt;/code&gt; fixture, so it just intantiates
 * a &lt;code&gt;new Buffer&lt;/code&gt;. &lt;code&gt;it should be user-friendly&lt;/code&gt; needs just the &lt;code&gt;FileWriter&lt;/code&gt; fixture, so it invokes
 * &lt;code&gt;withWriter&lt;/code&gt;, which prepares and passes a &lt;code&gt;FileWriter&lt;/code&gt; to the test (and takes care of closing it afterwords).
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Two tests need multiple fixtures: &lt;code&gt;Test code should be clear and concise&lt;/code&gt; needs both the &lt;code&gt;StringBuilder&lt;/code&gt; and the
 * &lt;code&gt;ListBuffer&lt;/code&gt;, so it instantiates a class that mixes in both fixture traits with &lt;code&gt;new Builder with Buffer&lt;/code&gt;.
 * &lt;code&gt;it should be composable&lt;/code&gt; needs all three fixtures, so in addition to &lt;code&gt;new Builder with Buffer&lt;/code&gt; it also invokes
 * &lt;code&gt;withWriter&lt;/code&gt;, wrapping just the of the test code that needs the fixture.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Note that in this case, the loan pattern is being implemented via the &lt;code&gt;withWriter&lt;/code&gt; method that takes a function, not
 * by overriding &lt;code&gt;FixtureFlatSpec&lt;/code&gt;'s &lt;code&gt;withFixture(OneArgTest)&lt;/code&gt; method. &lt;code&gt;FixtureFlatSpec&lt;/code&gt; makes the most sense
 * if all (or at least most) tests need the same fixture, whereas in this &lt;code&gt;Suite&lt;/code&gt; only two tests need the
 * &lt;code&gt;FileWriter&lt;/code&gt;.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * In the previous example, the &lt;code&gt;withWriter&lt;/code&gt; method passed an object into
 * the tests. Passing fixture objects into tests is generally a good idea when possible, but sometimes a side affect is unavoidable.
 * For example, if you need to initialize a database running on a server across a network, your with-fixture 
 * method will likely have nothing to pass. In such cases, simply create a with-fixture method that takes a by-name parameter and
 * performs setup and cleanup via side effects, like this:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * def withDataInDatabase(test: =&gt; Any) {
 *   // initialize the database across the network
 *   try {
 *     test // &quot;loan&quot; the initialized database to the test
 *   }
 *   finally {
 *     // clean up the database
 *   }
 * }
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * You can then use it like:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * &quot;A user&quot; should &quot;be able to log onto the system&quot; in {
 *   withDataInDatabase {
 *     // test user logging in scenario
 *   }
 * }
 * &lt;/pre&gt;
 * 
 * &lt;a name=&quot;composingFixtures&quot;&gt;&lt;/a&gt;&lt;h2&gt;Composing stackable fixture traits&lt;/h2&gt;
 *
 * &lt;p&gt;
 * In larger projects, teams often end up with several different fixtures that test classes need in different combinations,
 * and possibly initialized (and cleaned up) in different orders. A good way to accomplish this in ScalaTest is to factor the individual
 * fixtures into traits that can be composed using the &lt;em&gt;stackable trait&lt;/em&gt; pattern. This can be done, for example, by placing
 * &lt;code&gt;withFixture&lt;/code&gt; methods in several traits, each of which call &lt;code&gt;super.withFixture&lt;/code&gt;. Here's an example in
 * which the &lt;code&gt;StringBuilder&lt;/code&gt; and &lt;code&gt;ListBuffer[String]&lt;/code&gt; fixtures used in the previous examples have been
 * factored out into two &lt;em&gt;stackable fixture traits&lt;/em&gt; named &lt;code&gt;Builder&lt;/code&gt; and &lt;code&gt;Buffer&lt;/code&gt;:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.FlatSpec
 * import org.scalatest.AbstractSuite
 * import collection.mutable.ListBuffer
 * 
 * trait Builder extends AbstractSuite { this: Suite =&gt;
 *
 *   val builder = new StringBuilder
 *
 *   abstract override def withFixture(test: NoArgTest) {
 *     builder.append(&quot;ScalaTest is &quot;)
 *     try {
 *       super.withFixture(test) // To be stackable, must call super.withFixture
 *     }
 *     finally {
 *       builder.clear()
 *     }
 *   }
 * }
 *
 * trait Buffer extends AbstractSuite { this: Suite =&gt;
 *
 *   val buffer = new ListBuffer[String]
 *
 *   abstract override def withFixture(test: NoArgTest) {
 *     try {
 *       super.withFixture(test) // To be stackable, must call super.withFixture
 *     }
 *     finally {
 *       buffer.clear()
 *     }
 *   }
 * }
 * 
 * class ExampleSpec extends FlatSpec with Builder with Buffer {
 * 
 *   &quot;Testing&quot; should &quot;be easy&quot; in {
 *     builder.append(&quot;easy!&quot;)
 *     assert(builder.toString === &quot;ScalaTest is easy!&quot;)
 *     assert(buffer.isEmpty)
 *     buffer += &quot;sweet&quot;
 *   }
 * 
 *   it should &quot;be fun&quot; in {
 *     builder.append(&quot;fun!&quot;)
 *     assert(builder.toString === &quot;ScalaTest is fun!&quot;)
 *     assert(buffer.isEmpty)
 *     buffer += &quot;clear&quot;
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * By mixing in both the &lt;code&gt;Builder&lt;/code&gt; and &lt;code&gt;Buffer&lt;/code&gt; traits, &lt;code&gt;ExampleSpec&lt;/code&gt; gets both fixtures, which will be
 * initialized before each test and cleaned up after. The order the traits are mixed together determines the order of execution.
 * In this case, &lt;code&gt;Builder&lt;/code&gt; is &quot;super&quot; to &lt;/code&gt;Buffer&lt;/code&gt;. If you wanted &lt;code&gt;Buffer&lt;/code&gt; to be &quot;super&quot;
 * to &lt;code&gt;Builder&lt;/code&gt;, you need only switch the order you mix them together, like this: 
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * class Example2Spec extends FlatSpec with Buffer with Builder
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * And if you only need one fixture you mix in only that trait:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * class Example3Spec extends FlatSpec with Builder
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Another way to create stackable fixture traits is by extending the &lt;a href=&quot;BeforeAndAfterEach.html&quot;&gt;&lt;code&gt;BeforeAndAfterEach&lt;/code&gt;&lt;/a&gt;
 * and/or &lt;a href=&quot;BeforeAndAfterAll.html&quot;&gt;&lt;code&gt;BeforeAndAfterAll&lt;/code&gt;&lt;/a&gt; traits.
 * &lt;code&gt;BeforeAndAfterEach&lt;/code&gt; has a &lt;code&gt;beforeEach&lt;/code&gt; method that will be run before each test (like JUnit's &lt;code&gt;setUp&lt;/code&gt;),
 * and an &lt;code&gt;afterEach&lt;/code&gt; method that will be run after (like JUnit's &lt;code&gt;tearDown&lt;/code&gt;).
 * Similarly, &lt;code&gt;BeforeAndAfterAll&lt;/code&gt; has a &lt;code&gt;beforeAll&lt;/code&gt; method that will be run before all tests,
 * and an &lt;code&gt;afterAll&lt;/code&gt; method that will be run after all tests. Here's what the previously shown example would look like if it
 * were rewritten to use the &lt;code&gt;BeforeAndAfterEach&lt;/code&gt; methods instead of &lt;code&gt;withFixture&lt;/code&gt;:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import org.scalatest.FlatSpec
 * import org.scalatest.BeforeAndAfterEach
 * import collection.mutable.ListBuffer
 * 
 * trait Builder extends BeforeAndAfterEach { this: Suite =&gt;
 * 
 *   val builder = new StringBuilder
 * 
 *   override def beforeEach() {
 *     builder.append(&quot;ScalaTest is &quot;)
 *     super.beforeEach() // To be stackable, must call super.beforeEach
 *   }
 * 
 *   override def afterEach() {
 *     try {
 *       super.afterEach() // To be stackable, must call super.afterEach
 *     }
 *     finally {
 *       builder.clear()
 *     }
 *   }
 * }
 * 
 * trait Buffer extends BeforeAndAfterEach { this: Suite =&gt;
 * 
 *   val buffer = new ListBuffer[String]
 * 
 *   override def afterEach() {
 *     try {
 *       super.afterEach() // To be stackable, must call super.afterEach
 *     }
 *     finally {
 *       buffer.clear()
 *     }
 *   }
 * }
 * 
 * class ExampleSpec extends FlatSpec with Builder with Buffer {
 * 
 *   &quot;Testing&quot; should &quot;be easy&quot; in {
 *     builder.append(&quot;easy!&quot;)
 *     assert(builder.toString === &quot;ScalaTest is easy!&quot;)
 *     assert(buffer.isEmpty)
 *     buffer += &quot;sweet&quot;
 *   }
 * 
 *   it should &quot;be fun&quot; in {
 *     builder.append(&quot;fun!&quot;)
 *     assert(builder.toString === &quot;ScalaTest is fun!&quot;)
 *     assert(buffer.isEmpty)
 *     buffer += &quot;clear&quot;
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * To get the same ordering as &lt;code&gt;withFixture&lt;/code&gt;, place your &lt;code&gt;super.beforeEach&lt;/code&gt; call at the end of each
 * &lt;code&gt;beforeEach&lt;/code&gt; method, and the &lt;code&gt;super.afterEach&lt;/code&gt; call at the beginning of each &lt;code&gt;afterEach&lt;/code&gt;
 * method, as shown in the previous example. It is a good idea to invoke &lt;code&gt;super.afterEach&lt;/code&gt; in a &lt;code&gt;try&lt;/code&gt;
 * block and perform cleanup in a &lt;code&gt;finally&lt;/code&gt; clause, as shown in the previous example, because this ensures the
 * cleanup code is performed even if &lt;code&gt;super.afterAll&lt;/code&gt; throws an exception.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * One difference to bear in mind between the before-and-after traits and the &lt;code&gt;withFixture&lt;/code&gt; methods, is that if
 * a &lt;code&gt;withFixture&lt;/code&gt; method completes abruptly with an exception, it is considered a failed test. By contrast, if any of the
 * methods on the before-and-after traits (&lt;em&gt;i.e.&lt;/em&gt;, &lt;code&gt;before&lt;/code&gt;  and &lt;code&gt;after&lt;/code&gt; of &lt;code&gt;BeforeAndAfter&lt;/code&gt;,
 * &lt;code&gt;beforeEach&lt;/code&gt; and &lt;code&gt;afterEach&lt;/code&gt; of &lt;code&gt;BeforeAndAfterEach&lt;/code&gt;,
 * and &lt;code&gt;beforeAll&lt;/code&gt; and &lt;code&gt;afterAll&lt;/code&gt; of &lt;code&gt;BeforeAndAfterAll&lt;/code&gt;) complete abruptly, it is considered a
 * failed suite, which will result in a &lt;a href=&quot;events/SuiteAborted.html&quot;&gt;&lt;code&gt;SuiteAborted&lt;/code&gt;&lt;/a&gt; event.
 * &lt;/p&gt;
 * 
 * &lt;a name=&quot;SharedTests&quot;&gt;&lt;/a&gt;&lt;h2&gt;Shared tests&lt;/h2&gt;
 *
 * &lt;p&gt;
 * Sometimes you may want to run the same test code on different fixture objects. In other words, you may want to write tests that are &quot;shared&quot;
 * by different fixture objects.  To accomplish this in a &lt;code&gt;FlatSpec&lt;/code&gt;, you first place shared tests in &lt;em&gt;behavior functions&lt;/em&gt;.
 * These behavior functions will be invoked during the construction phase of any &lt;code&gt;FlatSpec&lt;/code&gt; that uses them, so that the tests they
 * contain will be registered as tests in that &lt;code&gt;FlatSpec&lt;/code&gt;.  For example, given this stack class:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * import scala.collection.mutable.ListBuffer
 * 
 * class Stack[T] {
 *
 *   val MAX = 10
 *   private var buf = new ListBuffer[T]
 *
 *   def push(o: T) {
 *     if (!full)
 *       o +: buf
 *     else
 *       throw new IllegalStateException(&quot;can't push onto a full stack&quot;)
 *   }
 *
 *   def pop(): T = {
 *     if (!empty)
 *       buf.remove(0)
 *     else
 *       throw new IllegalStateException(&quot;can't pop an empty stack&quot;)
 *   }
 *
 *   def peek: T = {
 *     if (!empty)
 *       buf(0)
 *     else
 *       throw new IllegalStateException(&quot;can't pop an empty stack&quot;)
 *   }
 *
 *   def full: Boolean = buf.size == MAX
 *   def empty: Boolean = buf.size == 0
 *   def size = buf.size
 *
 *   override def toString = buf.mkString(&quot;Stack(&quot;, &quot;, &quot;, &quot;)&quot;)
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * You may want to test the &lt;code&gt;Stack&lt;/code&gt; class in different states: empty, full, with one item, with one item less than capacity,
 * &lt;em&gt;etc&lt;/em&gt;. You may find you have several tests that make sense any time the stack is non-empty. Thus you'd ideally want to run
 * those same tests for three stack fixture objects: a full stack, a stack with a one item, and a stack with one item less than
 * capacity. With shared tests, you can factor these tests out into a behavior function, into which you pass the
 * stack fixture to use when running the tests. So in your &lt;code&gt;FlatSpec&lt;/code&gt; for stack, you'd invoke the
 * behavior function three times, passing in each of the three stack fixtures so that the shared tests are run for all three fixtures. You
 * can define a behavior function that encapsulates these shared tests inside the &lt;code&gt;FlatSpec&lt;/code&gt; that uses them. If they are shared
 * between different &lt;code&gt;FlatSpec&lt;/code&gt;s, however, you could also define them in a separate trait that is mixed into each &lt;code&gt;FlatSpec&lt;/code&gt;
 * that uses them.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * &lt;a name=&quot;StackBehaviors&quot;&gt;For&lt;/a&gt; example, here the &lt;code&gt;nonEmptyStack&lt;/code&gt; behavior function (in this case, a behavior &lt;em&gt;method&lt;/em&gt;) is
 * defined in a trait along with another method containing shared tests for non-full stacks:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * trait StackBehaviors { this: FlatSpec =&gt;
 * 
 *   def nonEmptyStack(stack: Stack[Int], lastItemAdded: Int) {
 * 
 *     it should &quot;be non-empty&quot; in {
 *       assert(!stack.empty)
 *     }  
 * 
 *     it should &quot;return the top item on peek&quot; in {
 *       assert(stack.peek === lastItemAdded)
 *     }
 *   
 *     it should &quot;not remove the top item on peek&quot; in {
 *       val size = stack.size
 *       assert(stack.peek === lastItemAdded)
 *       assert(stack.size === size)
 *     }
 *   
 *     it should &quot;remove the top item on pop&quot; in {
 *       val size = stack.size
 *       assert(stack.pop === lastItemAdded)
 *       assert(stack.size === size - 1)
 *     }
 *   }
 *   
 *   def nonFullStack(stack: Stack[Int]) {
 *       
 *     it should &quot;not be full&quot; in {
 *       assert(!stack.full)
 *     }
 *       
 *     it should &quot;add to the top on push&quot; in {
 *       val size = stack.size
 *       stack.push(7)
 *       assert(stack.size === size + 1)
 *       assert(stack.peek === 7)
 *     }
 *   }
 * }
 * &lt;/pre&gt;
 *
 *
 * &lt;p&gt;
 * Given these behavior functions, you could invoke them directly, but &lt;code&gt;FlatSpec&lt;/code&gt; offers a DSL for the purpose,
 * which looks like this:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * it should behave like nonEmptyStack(stackWithOneItem, lastValuePushed)
 * it should behave like nonFullStack(stackWithOneItem)
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * If you prefer to use an imperative style to change fixtures, for example by mixing in &lt;code&gt;BeforeAndAfterEach&lt;/code&gt; and
 * reassigning a &lt;code&gt;stack&lt;/code&gt; &lt;code&gt;var&lt;/code&gt; in &lt;code&gt;beforeEach&lt;/code&gt;, you could write your behavior functions
 * in the context of that &lt;code&gt;var&lt;/code&gt;, which means you wouldn't need to pass in the stack fixture because it would be
 * in scope already inside the behavior function. In that case, your code would look like this:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * it should behave like nonEmptyStack // assuming lastValuePushed is also in scope inside nonEmptyStack
 * it should behave like nonFullStack
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * The recommended style, however, is the functional, pass-all-the-needed-values-in style. Here's an example:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * class SharedTestExampleSpec extends FlatSpec with StackBehaviors {
 * 
 *   // Stack fixture creation methods
 *   def emptyStack = new Stack[Int]
 * 
 *   def fullStack = {
 *     val stack = new Stack[Int]
 *     for (i &lt;- 0 until stack.MAX)
 *       stack.push(i)
 *     stack
 *   }
 * 
 *   def stackWithOneItem = {
 *     val stack = new Stack[Int]
 *     stack.push(9)
 *     stack
 *   }
 * 
 *   def stackWithOneItemLessThanCapacity = {
 *     val stack = new Stack[Int]
 *     for (i &lt;- 1 to 9)
 *       stack.push(i)
 *     stack
 *   }
 * 
 *   val lastValuePushed = 9
 * 
 *   &quot;A Stack (when empty)&quot; should &quot;be empty&quot; in {
 *     assert(emptyStack.empty)
 *   }
 * 
 *   it should &quot;complain on peek&quot; in {
 *     intercept[IllegalStateException] {
 *       emptyStack.peek
 *     }
 *   }
 *
 *   it should &quot;complain on pop&quot; in {
 *     intercept[IllegalStateException] {
 *       emptyStack.pop
 *     }
 *   }
 * 
 *   &quot;A Stack (with one item)&quot; should behave like nonEmptyStack(stackWithOneItem, lastValuePushed)
 *
 *   it should behave like nonFullStack(stackWithOneItem)
 *     
 *   &quot;A Stack (with one item less than capacity)&quot; should behave like nonEmptyStack(stackWithOneItemLessThanCapacity, lastValuePushed)
 *
 *   it should behave like nonFullStack(stackWithOneItemLessThanCapacity)
 * 
 *   &quot;A Stack (full)&quot; should &quot;be full&quot; in {
 *     assert(fullStack.full)
 *   }
 * 
 *   it should behave like nonEmptyStack(fullStack, lastValuePushed)
 * 
 *   it should &quot;complain on a push&quot; in {
 *     intercept[IllegalStateException] {
 *       fullStack.push(10)
 *     }
 *   }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * If you load these classes into the Scala interpreter (with scalatest's JAR file on the class path), and execute it,
 * you'll see:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stREPL&quot;&gt;
 * &lt;span class=&quot;stGreen&quot;&gt;scala&gt; (new SharedTestExampleSpec).execute()
 * A Stack (when empty) 
 * - should be empty
 * - should complain on peek
 * - should complain on pop
 * A Stack (with one item) 
 * - should be non-empty
 * - should return the top item on peek
 * - should not remove the top item on peek
 * - should remove the top item on pop
 * - should not be full
 * - should add to the top on push
 * A Stack (with one item less than capacity) 
 * - should be non-empty
 * - should return the top item on peek
 * - should not remove the top item on peek
 * - should remove the top item on pop
 * - should not be full
 * - should add to the top on push
 * A Stack (full) 
 * - should be full
 * - should be non-empty
 * - should return the top item on peek
 * - should not remove the top item on peek
 * - should remove the top item on pop
 * - should complain on a push&lt;/span&gt;
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * One thing to keep in mind when using shared tests is that in ScalaTest, each test in a suite must have a unique name.
 * If you register the same tests repeatedly in the same suite, one problem you may encounter is an exception at runtime
 * complaining that multiple tests are being registered with the same test name. A good way to solve this problem in a &lt;code&gt;WordSpec&lt;/code&gt; is to make sure
 * each invocation of a behavior function is in the context of a different set of &lt;code&gt;when&lt;/code&gt;, &lt;em&gt;verb&lt;/em&gt; (&lt;code&gt;should&lt;/code&gt;,
 * &lt;code&gt;must&lt;/code&gt;, or &lt;/code&gt;can&lt;/code&gt;), and &lt;code&gt;that&lt;/code&gt; clauses,
 * which will prepend a string to each test name.
 * For example, the following code in a &lt;code&gt;WordSpec&lt;/code&gt; would register a test with the name &lt;code&gt;&quot;A Stack (when empty) should be empty&quot;&lt;/code&gt;:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 *   behavior of &quot;A Stack (when empty)&quot;
 *       
 *   it should &quot;be empty&quot; in {
 *     assert(emptyStack.empty)
 *   }
 *   // ...
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Or, using the shorthand notation:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 *   &quot;A Stack&quot; when {
 *     &quot;empty&quot; should {
 *       &quot;be empty&quot; in {
 *         assert(emptyStack.empty)
 *       }
 *     }
 *   }
 *   // ...
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * If the &lt;code&gt;&quot;should be empty&quot;&lt;/code&gt; test was factored out into a behavior function, it could be called repeatedly so long
 * as each invocation of the behavior function is in the context of a different combination
 * of &lt;code&gt;when&lt;/code&gt;, &lt;em&gt;verb&lt;/em&gt;, and &lt;code&gt;that&lt;/code&gt; clauses.
 * &lt;/p&gt;
 *
 * @author Bill Venners
 */</span>
<span class="keyword">trait</span> <a title="trait FlatSpec extends java.lang.Object with org.scalatest.Suite with org.scalatest.verb.ShouldVerb with org.scalatest.verb.MustVerb with org.scalatest.verb.CanVerb with ScalaObject" id="9848">FlatSpec</a> <span title="ScalaObject" class="keyword">extends</span> <a href="Suite.scala.html#10073" title="org.scalatest.Suite">Suite</a> <span class="keyword">with</span> <a href="verb/ShouldVerb.scala.html#15166" title="org.scalatest.verb.ShouldVerb">ShouldVerb</a> <span class="keyword">with</span> <a href="verb/MustVerb.scala.html#15151" title="org.scalatest.verb.MustVerb">MustVerb</a> <span class="keyword">with</span> <a href="verb/CanVerb.scala.html#15154" title="org.scalatest.verb.CanVerb">CanVerb</a> <span class="delimiter">{</span> thisSuite =&gt;

  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">val</span> <a title="org.scalatest.Engine" id="42896">engine</a> = <span title="org.scalatest.Engine" class="keyword">new</span> <a href="Engine.scala.html#10262" title="org.scalatest.Engine">Engine</a><span class="delimiter">(</span><span title="java.lang.String(&quot;concurrentSpecMod&quot;)" class="string">&quot;concurrentSpecMod&quot;</span>, <span title="java.lang.String(&quot;Spec&quot;)" class="string">&quot;Spec&quot;</span><span class="delimiter">)</span>
  <span class="keyword">import</span> <a href="#42896" title="=&gt; org.scalatest.Engine">engine</a>._

  <span class="comment">/**
   * Returns an &lt;code&gt;Informer&lt;/code&gt; that during test execution will forward strings (and other objects) passed to its
   * &lt;code&gt;apply&lt;/code&gt; method to the current reporter. If invoked in a constructor, it
   * will register the passed string for forwarding later during test execution. If invoked while this
   * &lt;code&gt;FlatSpec&lt;/code&gt; is being executed, such as from inside a test function, it will forward the information to
   * the current reporter immediately. If invoked at any other time, it will
   * throw an exception. This method can be called safely by any thread.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; org.scalatest.Informer" id="42899">info</a>: <a href="Informer.scala.html#9884" title="org.scalatest.Informer">Informer</a> = <a href="Engine.scala.html#36495" title="=&gt; java.util.concurrent.atomic.AtomicReference[org.scalatest.Informer]">atomicInformer</a>.<span title="()org.scalatest.Informer">get</span>

  <span class="comment">/**
   * Register a test with the given spec text, optional tags, and test function value that takes no arguments.
   * An invocation of this method is called an &amp;#8220;example.&amp;#8221;
   *
   * This method will register the test for later execution via an invocation of one of the &lt;code&gt;execute&lt;/code&gt;
   * methods. The name of the test will be a concatenation of the text of all surrounding describers,
   * from outside in, and the passed spec text, with one space placed between each item. (See the documenation
   * for &lt;code&gt;testNames&lt;/code&gt; for an example.) The resulting test name must not have been registered previously on
   * this &lt;code&gt;Spec&lt;/code&gt; instance.
   *
   * @param specText the specification text, which will be combined with the descText of any surrounding describers
   * to form the test name
   * @param testTags the optional list of tags for this test
   * @param testFun the test function
   * @throws DuplicateTestNameException if a test with the same name has been registered previously
   * @throws TestRegistrationClosedException if invoked after &lt;code&gt;run&lt;/code&gt; has been invoked on this suite
   * @throws NullPointerException if &lt;code&gt;specText&lt;/code&gt; or any passed test tag is &lt;code&gt;null&lt;/code&gt;
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit" id="42900">registerTestToRun</a><span class="delimiter">(</span><a title="String" id="42961">specText</a>: <span title="String">String</span>, <a title="List[org.scalatest.Tag]" id="42962">testTags</a>: <span title="List[org.scalatest.Tag]">List</span><span class="delimiter">[</span>Tag<span class="delimiter">]</span>, <a title="() =&gt; Unit" id="42963">testFun</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">// TODO: This is what was being used before but it is wrong</span>
    <a href="Engine.scala.html#36508" title="(testText: String, testFun: () =&gt; Unit, testRegistrationClosedResourceName: String, sourceFileName: String, methodName: String, testTags: org.scalatest.Tag*)String">registerTest</a><span title="Unit" class="delimiter">(</span><a href="#42961" title="String">specText</a>, <a href="#42963" title="() =&gt; Unit">testFun</a>, <span title="java.lang.String(&quot;itCannotAppearInsideAnotherIt&quot;)" class="string">&quot;itCannotAppearInsideAnotherIt&quot;</span>, <span title="java.lang.String(&quot;FlatSpec.scala&quot;)" class="string">&quot;FlatSpec.scala&quot;</span>, <span title="java.lang.String(&quot;it&quot;)" class="string">&quot;it&quot;</span>, <a href="#42962" title="List[org.scalatest.Tag]">testTags</a>: _*<span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Class that supports the registration of a &amp;#8220;subject&amp;#8221; being specified and tested via the
   * instance referenced from &lt;code&gt;FlatSpec&lt;/code&gt;'s &lt;code&gt;behavior&lt;/code&gt; field.
   *
   * &lt;p&gt;
   * This field enables syntax such as the following subject registration:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * behavior of &quot;A Stack&quot;
   * ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * For more information and examples of the use of the &lt;code&gt;behavior&lt;/code&gt; field, see the &lt;a href=&quot;FlatSpec.html&quot;&gt;main documentation&lt;/a&gt;
   * for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
   * &lt;/p&gt;
   */</span>
  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class BehaviorWord extends java.lang.Object with ScalaObject" id="42901">BehaviorWord</a> <a href="#42901" title="ScalaObject" class="delimiter">{</a>

    <span class="comment">/**
     * Supports the registration of a &amp;#8220;subject&amp;#8221; being specified and tested via the
     * instance referenced from &lt;code&gt;FlatSpec&lt;/code&gt;'s &lt;code&gt;behavior&lt;/code&gt; field.
     *
     * &lt;p&gt;
     * This method enables syntax such as the following subject registration:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * behavior of &quot;A Stack&quot;
     *          ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For more information and examples of the use of this method, see the &lt;a href=&quot;FlatSpec.html&quot;&gt;main documentation&lt;/a&gt;
     * for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(description: String)Unit" id="42941">of</a><span class="delimiter">(</span><a title="String" id="42972">description</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="delimiter">{</span>

      <span class="comment">// TODO: This is what was here, but it needs fixing.</span>
      <a href="Engine.scala.html#36506" title="(description: String, registrationClosedResource: String, sourceFile: String, methodName: String)Unit">registerFlatBranch</a><span class="delimiter">(</span><a href="#42972" title="String">description</a>, <span title="java.lang.String(&quot;describeCannotAppearInsideAnIt&quot;)" class="string">&quot;describeCannotAppearInsideAnIt&quot;</span>, <span title="java.lang.String(&quot;FlatSpec.scala&quot;)" class="string">&quot;FlatSpec.scala&quot;</span>, <span title="java.lang.String(&quot;describe&quot;)" class="string">&quot;describe&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Supports the registration of a &amp;#8220;subject&amp;#8221; being specified and tested.
   *
   * &lt;p&gt;
   * This field enables syntax such as the following subject registration:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * behavior of &quot;A Stack&quot;
   * ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * For more information and examples of the use of the &lt;code&gt;behavior&lt;/code&gt; field, see the main documentation 
   * for this trait.
   * &lt;/p&gt;
   */</span>
  <span class="keyword">protected</span> <span class="keyword">val</span> <a title="FlatSpec.this.BehaviorWord" id="42902">behavior</a> = <span title="FlatSpec.this.BehaviorWord" class="keyword">new</span> <a href="#42901" title="FlatSpec.this.BehaviorWord">BehaviorWord</a>

  <span class="comment">/**
   * Class that supports the registration of tagged tests via the &lt;code&gt;ItWord&lt;/code&gt; instance
   * referenced from &lt;code&gt;FlatSpec&lt;/code&gt;'s &lt;code&gt;it&lt;/code&gt; field.
   *
   * &lt;p&gt;
   * This class enables syntax such as the following tagged test registration:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * it should &quot;pop values in last-in-first-out order&quot; taggedAs(SlowTest) in { ... }
   *                                                                      ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * It also enables syntax such as the following registration of an ignored, tagged test:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * it should &quot;pop values in last-in-first-out order&quot; taggedAs(SlowTest) ignore { ... }
   *                                                                      ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * In addition, it enables syntax such as the following registration of a pending, tagged test:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * it should &quot;pop values in last-in-first-out order&quot; taggedAs(SlowTest) is (pending)
   *                                                                      ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * For more information and examples of the use of the &lt;code&gt;it&lt;/code&gt; field to register tagged tests, see
   * the &lt;a href=&quot;FlatSpec.html#TaggingTests&quot;&gt;Tagging tests section&lt;/a&gt; in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
   * For examples of tagged test registration, see
   * the &lt;a href=&quot;FlatSpec.html#TaggingTests&quot;&gt;Tagging tests section&lt;/a&gt; in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
   * &lt;/p&gt;
   */</span>
  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class ItVerbStringTaggedAs extends java.lang.Object with ScalaObject" id="42904">ItVerbStringTaggedAs</a><a href="#42904" title="ScalaObject" class="delimiter">(</a><a title="String" id="42988">verb</a>: <span title="String">String</span>, <a title="String" id="42989">name</a>: <span title="String">String</span>, <a title="List[org.scalatest.Tag]" id="42990">tags</a>: <span title="List[org.scalatest.Tag]">List</span><span class="delimiter">[</span>Tag<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * Supports the registration of tagged tests in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * it must &quot;pop values in last-in-first-out order&quot; taggedAs(SlowTest) in { ... }
     *                                                                    ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of tagged test registration, see
     * the &lt;a href=&quot;FlatSpec.html#TaggingTests&quot;&gt;Tagging tests section&lt;/a&gt; in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(testFun: =&gt; Unit)Unit" id="42981">in</a><span class="delimiter">(</span><a title="=&gt; Unit" id="42991">testFun</a>: =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#42900" title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit">registerTestToRun</a><span class="delimiter">(</span><a href="#42988" title="String">verb</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#42989" title="String">name</a>, <a href="#42990" title="List[org.scalatest.Tag]">tags</a>, <a href="#42991" title="=&gt; Unit">testFun</a> _<span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Supports the registration of pending, tagged tests in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * it must &quot;pop values in last-in-first-out order&quot; taggedAs(SlowTest) is (pending)
     *                                                                    ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of pending test registration, see the &lt;a href=&quot;FlatSpec.html#PendingTests&quot;&gt;Pending tests section&lt;/a&gt; in the main documentation
     * for trait &lt;code&gt;FlatSpec&lt;/code&gt;.  And for examples of tagged test registration, see
     * the &lt;a href=&quot;FlatSpec.html#TaggingTests&quot;&gt;Tagging tests section&lt;/a&gt; in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(testFun: =&gt; org.scalatest.PendingNothing)Unit" id="42982">is</a><span class="delimiter">(</span><a title="=&gt; org.scalatest.PendingNothing" id="42994">testFun</a>: =&gt; PendingNothing<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#42900" title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit">registerTestToRun</a><span class="delimiter">(</span><a href="#42988" title="String">verb</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#42989" title="String">name</a>, <a href="#42990" title="List[org.scalatest.Tag]">tags</a>, <a href="#42994" title="=&gt; org.scalatest.PendingNothing">testFun</a> _<span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Supports the registration of ignored, tagged tests in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * it must &quot;pop values in last-in-first-out order&quot; taggedAs(SlowTest) ignore { ... }
     *                                                                    ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of ignored test registration, see the &lt;a href=&quot;FlatSpec.html#IgnoredTests&quot;&gt;Ignored tests section&lt;/a&gt; in the main documentation
     * for trait &lt;code&gt;FlatSpec&lt;/code&gt;.  And for examples of tagged test registration, see
     * the &lt;a href=&quot;FlatSpec.html#TaggingTests&quot;&gt;Tagging tests section&lt;/a&gt; in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(testFun: =&gt; Unit)Unit" id="42983">ignore</a><span class="delimiter">(</span><a title="=&gt; Unit" id="42998">testFun</a>: =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#42922" title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit">registerTestToIgnore</a><span class="delimiter">(</span><a href="#42988" title="String">verb</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#42989" title="String">name</a>, <a href="#42990" title="List[org.scalatest.Tag]">tags</a>, <a href="#42998" title="=&gt; Unit">testFun</a> _<span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Class that supports test registration via the &lt;code&gt;ItWord&lt;/code&gt; instance referenced from &lt;code&gt;FlatSpec&lt;/code&gt;'s &lt;code&gt;it&lt;/code&gt; field.
   *
   * &lt;p&gt;
   * This class enables syntax such as the following test registration:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * it should &quot;pop values in last-in-first-out order&quot; in { ... }
   *                                                   ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * It also enables syntax such as the following registration of an ignored test:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * it should &quot;pop values in last-in-first-out order&quot; ignore { ... }
   *                                                   ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * In addition, it enables syntax such as the following registration of a pending test:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * it should &quot;pop values in last-in-first-out order&quot; is (pending)
   *                                                   ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * And finally, it also enables syntax such as the following tagged test registration:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * it should &quot;pop values in last-in-first-out order&quot; taggedAs(SlowTest) in { ... }
   *                                                   ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * For more information and examples of the use of the &lt;code&gt;it&lt;/code&gt; field, see the &lt;a href=&quot;FlatSpec.html&quot;&gt;main documentation&lt;/a&gt;
   * for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
   * &lt;/p&gt;
   */</span>
  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class ItVerbString extends java.lang.Object with ScalaObject" id="42905">ItVerbString</a><a href="#42905" title="ScalaObject" class="delimiter">(</a><a title="String" id="43017">verb</a>: <span title="String">String</span>, <a title="String" id="43018">name</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * Supports the registration of tests in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * it must &quot;pop values in last-in-first-out order&quot; in { ... }
     *                                                 ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of test registration, see the &lt;a href=&quot;FlatSpec.html&quot;&gt;main documentation&lt;/a&gt;
     * for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(testFun: =&gt; Unit)Unit" id="43010">in</a><span class="delimiter">(</span><a title="=&gt; Unit" id="43019">testFun</a>: =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#42900" title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit">registerTestToRun</a><span class="delimiter">(</span><a href="#43017" title="String">verb</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#43018" title="String">name</a>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#43019" title="=&gt; Unit">testFun</a> _<span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Supports the registration of pending tests in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * it must &quot;pop values in last-in-first-out order&quot; is (pending)
     *                                                 ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of pending test registration, see the &lt;a href=&quot;FlatSpec.html#PendingTests&quot;&gt;Pending tests section&lt;/a&gt; in the main documentation
     * for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(testFun: =&gt; org.scalatest.PendingNothing)Unit" id="43011">is</a><span class="delimiter">(</span><a title="=&gt; org.scalatest.PendingNothing" id="43029">testFun</a>: =&gt; PendingNothing<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#42900" title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit">registerTestToRun</a><span class="delimiter">(</span><a href="#43017" title="String">verb</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#43018" title="String">name</a>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#43029" title="=&gt; org.scalatest.PendingNothing">testFun</a> _<span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Supports the registration of ignored tests in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * it must &quot;pop values in last-in-first-out order&quot; ignore { ... }
     *                                                 ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of ignored test registration, see the &lt;a href=&quot;FlatSpec.html#IgnoredTests&quot;&gt;Ignored tests section&lt;/a&gt; in the main documentation
     * for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(testFun: =&gt; Unit)Unit" id="43012">ignore</a><span class="delimiter">(</span><a title="=&gt; Unit" id="43039">testFun</a>: =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#42922" title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit">registerTestToIgnore</a><span class="delimiter">(</span><a href="#43017" title="String">verb</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#43018" title="String">name</a>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#43039" title="=&gt; Unit">testFun</a> _<span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Supports the registration of tagged tests in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * it must &quot;pop values in last-in-first-out order&quot; taggedAs(SlowTest) in { ... }
     *                                                 ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of tagged test registration, see the &lt;a href=&quot;FlatSpec.html#TaggingTests&quot;&gt;Tagging tests section&lt;/a&gt; in the main documentation
     * for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(firstTestTag: org.scalatest.Tag, otherTestTags: org.scalatest.Tag*)FlatSpec.this.ItVerbStringTaggedAs" id="43013">taggedAs</a><span class="delimiter">(</span><a title="org.scalatest.Tag" id="43049">firstTestTag</a>: <a href="Tag.scala.html#9953" title="org.scalatest.Tag">Tag</a>, <a title="org.scalatest.Tag*" id="43050">otherTestTags</a>: <span title="org.scalatest.Tag*">Tag</span>*<span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[org.scalatest.Tag]" id="43053">tagList</a> = <a href="#43049" title="org.scalatest.Tag">firstTestTag</a> <a href="#43054" title="(x: org.scalatest.Tag)List[org.scalatest.Tag]">::</a> <a href="#43050" title="org.scalatest.Tag*">otherTestTags</a>.<span title="=&gt; List[org.scalatest.Tag]">toList</span>
      <span title="FlatSpec.this.ItVerbStringTaggedAs" class="keyword">new</span> <a href="#42904" title="FlatSpec.this.ItVerbStringTaggedAs">ItVerbStringTaggedAs</a><span class="delimiter">(</span><a href="#43017" title="String">verb</a>, <a href="#43018" title="String">name</a>, <a href="#43053" title="List[org.scalatest.Tag]">tagList</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Class that supports test (and shared test) registration via the instance referenced from &lt;code&gt;FlatSpec&lt;/code&gt;'s &lt;code&gt;it&lt;/code&gt; field.
   *
   * &lt;p&gt;
   * This class enables syntax such as the following test registration:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * it should &quot;pop values in last-in-first-out order&quot; in { ... }
   * ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * It also enables syntax such as the following shared test registration:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * it should behave like nonEmptyStack(lastItemPushed)
   * ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * For more information and examples of the use of the &lt;code&gt;it&lt;/code&gt; field, see the main documentation 
   * for this trait.
   * &lt;/p&gt;
   */</span>
  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class ItWord extends java.lang.Object with ScalaObject" id="42906">ItWord</a> <a href="#42906" title="ScalaObject" class="delimiter">{</a>

    <span class="comment">/**
     * Supports the registration of tests with &lt;code&gt;should&lt;/code&gt; in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * it should &quot;pop values in last-in-first-out order&quot; in { ... }
     *    ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of test registration, see the &lt;a href=&quot;FlatSpec.html&quot;&gt;main documentation&lt;/a&gt;
     * for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(string: String)FlatSpec.this.ItVerbString" id="42943">should</a><span class="delimiter">(</span><a title="String" id="43061">string</a>: <span title="String">String</span><span class="delimiter">)</span> = <span title="FlatSpec.this.ItVerbString" class="keyword">new</span> <a href="#42905" title="FlatSpec.this.ItVerbString">ItVerbString</a><span class="delimiter">(</span><span title="java.lang.String(&quot;should&quot;)" class="string">&quot;should&quot;</span>, <a href="#43061" title="String">string</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Supports the registration of tests with &lt;code&gt;must&lt;/code&gt; in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * it must &quot;pop values in last-in-first-out order&quot; in { ... }
     *    ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of test registration, see the &lt;a href=&quot;FlatSpec.html&quot;&gt;main documentation&lt;/a&gt;
     * for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(string: String)FlatSpec.this.ItVerbString" id="42944">must</a><span class="delimiter">(</span><a title="String" id="43064">string</a>: <span title="String">String</span><span class="delimiter">)</span> = <span title="FlatSpec.this.ItVerbString" class="keyword">new</span> <a href="#42905" title="FlatSpec.this.ItVerbString">ItVerbString</a><span class="delimiter">(</span><span title="java.lang.String(&quot;must&quot;)" class="string">&quot;must&quot;</span>, <a href="#43064" title="String">string</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Supports the registration of tests with &lt;code&gt;can&lt;/code&gt; in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * it can &quot;pop values in last-in-first-out order&quot; in { ... }
     *    ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of test registration, see the &lt;a href=&quot;FlatSpec.html&quot;&gt;main documentation&lt;/a&gt;
     * for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(string: String)FlatSpec.this.ItVerbString" id="42945">can</a><span class="delimiter">(</span><a title="String" id="43067">string</a>: <span title="String">String</span><span class="delimiter">)</span> = <span title="FlatSpec.this.ItVerbString" class="keyword">new</span> <a href="#42905" title="FlatSpec.this.ItVerbString">ItVerbString</a><span class="delimiter">(</span><span title="java.lang.String(&quot;can&quot;)" class="string">&quot;can&quot;</span>, <a href="#43067" title="String">string</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Supports the registration of shared tests with &lt;code&gt;should&lt;/code&gt; in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * it should behave like nonFullStack(stackWithOneItem)
     *    ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of shared tests, see the &lt;a href=&quot;FlatSpec.html#SharedTests&quot;&gt;Shared tests section&lt;/a&gt;
     * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(behaveWord: org.scalatest.verb.BehaveWord)org.scalatest.verb.BehaveWord" id="42946">should</a><span class="delimiter">(</span><a title="org.scalatest.verb.BehaveWord" id="43070">behaveWord</a>: <a href="verb/BehaveWord.scala.html#15142" title="org.scalatest.verb.BehaveWord">BehaveWord</a><span class="delimiter">)</span> = <a href="#43070" title="org.scalatest.verb.BehaveWord">behaveWord</a>

    <span class="comment">/**
     * Supports the registration of shared tests with &lt;code&gt;must&lt;/code&gt; in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * it must behave like nonFullStack(stackWithOneItem)
     *    ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of shared tests, see the &lt;a href=&quot;FlatSpec.html#SharedTests&quot;&gt;Shared tests section&lt;/a&gt;
     * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(behaveWord: org.scalatest.verb.BehaveWord)org.scalatest.verb.BehaveWord" id="42947">must</a><span class="delimiter">(</span><a title="org.scalatest.verb.BehaveWord" id="43073">behaveWord</a>: <a href="verb/BehaveWord.scala.html#15142" title="org.scalatest.verb.BehaveWord">BehaveWord</a><span class="delimiter">)</span> = <a href="#43073" title="org.scalatest.verb.BehaveWord">behaveWord</a>

    <span class="comment">/**
     * Supports the registration of shared tests with &lt;code&gt;can&lt;/code&gt; in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * it can behave like nonFullStack(stackWithOneItem)
     *    ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of shared tests, see the &lt;a href=&quot;FlatSpec.html#SharedTests&quot;&gt;Shared tests section&lt;/a&gt;
     * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(behaveWord: org.scalatest.verb.BehaveWord)org.scalatest.verb.BehaveWord" id="42948">can</a><span class="delimiter">(</span><a title="org.scalatest.verb.BehaveWord" id="43076">behaveWord</a>: <a href="verb/BehaveWord.scala.html#15142" title="org.scalatest.verb.BehaveWord">BehaveWord</a><span class="delimiter">)</span> = <a href="#43076" title="org.scalatest.verb.BehaveWord">behaveWord</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Supports test (and shared test) registration in &lt;code&gt;FlatSpec&lt;/code&gt;s.
   *
   * &lt;p&gt;
   * This field enables syntax such as the following test registration:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * it should &quot;pop values in last-in-first-out order&quot; in { ... }
   * ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * It also enables syntax such as the following shared test registration:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * it should behave like nonEmptyStack(lastItemPushed)
   * ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * For more information and examples of the use of the &lt;code&gt;it&lt;/code&gt; field, see the main documentation 
   * for this trait.
   * &lt;/p&gt;
   */</span>
  <span class="keyword">protected</span> <span class="keyword">val</span> <a title="FlatSpec.this.ItWord" id="42907">it</a> = <span title="FlatSpec.this.ItWord" class="keyword">new</span> <a href="#42906" title="FlatSpec.this.ItWord">ItWord</a>

  <span class="comment">/**
   * Class that supports registration of ignored, tagged tests via the &lt;code&gt;IgnoreWord&lt;/code&gt; instance referenced
   * from &lt;code&gt;FlatSpec&lt;/code&gt;'s &lt;code&gt;ignore&lt;/code&gt; field.
   *
   * &lt;p&gt;
   * This class enables syntax such as the following registration of an ignored, tagged test:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * ignore should &quot;pop values in last-in-first-out order&quot; taggedAs(SlowTest) in { ... }
   *                                                                          ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * In addition, it enables syntax such as the following registration of an ignored, tagged, pending test:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * ignore should &quot;pop values in last-in-first-out order&quot; taggedAs(SlowTest) is (pending)
   *                                                                          ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * Note: the &lt;code&gt;is&lt;/code&gt; method is provided for completeness and design symmetry, given there's no way
   * to prevent changing &lt;code&gt;is&lt;/code&gt; to &lt;code&gt;ignore&lt;/code&gt; and marking a pending test as ignored that way.
   * Although it isn't clear why someone would want to mark a pending test as ignored, it can be done.
   * &lt;/p&gt;
   *
   * &lt;p&gt;
   * For more information and examples of the use of the &lt;code&gt;ignore&lt;/code&gt; field, see the &lt;a href=&quot;FlatSpec.html#IgnoredTests&quot;&gt;Ignored tests section&lt;/a&gt;
   * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;. For examples of tagged test registration, see
   * the &lt;a href=&quot;FlatSpec.html#TaggingTests&quot;&gt;Tagging tests section&lt;/a&gt; in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
   * &lt;/p&gt;
   */</span>
  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class IgnoreVerbStringTaggedAs extends java.lang.Object with ScalaObject" id="42909">IgnoreVerbStringTaggedAs</a><a href="#42909" title="ScalaObject" class="delimiter">(</a><a title="String" id="43092">verb</a>: <span title="String">String</span>, <a title="String" id="43093">name</a>: <span title="String">String</span>, <a title="List[org.scalatest.Tag]" id="43094">tags</a>: <span title="List[org.scalatest.Tag]">List</span><span class="delimiter">[</span>Tag<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * Supports the registration of ignored, tagged tests in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * ignore must &quot;pop values in last-in-first-out order&quot; taggedAs(SlowTest) in { ... }
     *                                                                        ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of the registration of ignored tests, see the &lt;a href=&quot;FlatSpec.html#IgnoredTests&quot;&gt;Ignored tests section&lt;/a&gt;
     * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;. For examples of tagged test registration, see
     * the &lt;a href=&quot;FlatSpec.html#TaggingTests&quot;&gt;Tagging tests section&lt;/a&gt; in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(testFun: =&gt; Unit)Unit" id="43086">in</a><span class="delimiter">(</span><a title="=&gt; Unit" id="43095">testFun</a>: =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#42922" title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit">registerTestToIgnore</a><span class="delimiter">(</span><a href="#43092" title="String">verb</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#43093" title="String">name</a>, <a href="#43094" title="List[org.scalatest.Tag]">tags</a>, <a href="#43095" title="=&gt; Unit">testFun</a> _<span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Supports the registration of ignored, tagged, pending tests in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * ignore must &quot;pop values in last-in-first-out order&quot; taggedAs(SlowTest) is (pending)
     *                                                                        ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * Note: this &lt;code&gt;is&lt;/code&gt; method is provided for completeness and design symmetry, given there's no way
     * to prevent changing &lt;code&gt;is&lt;/code&gt; to &lt;code&gt;ignore&lt;/code&gt; and marking a pending test as ignored that way.
     * Although it isn't clear why someone would want to mark a pending test as ignored, it can be done.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * For examples of pending test registration, see the &lt;a href=&quot;FlatSpec.html#PendingTests&quot;&gt;Pending tests section&lt;/a&gt; in the main documentation
     * for trait &lt;code&gt;FlatSpec&lt;/code&gt;.  For examples of the registration of ignored tests,
     * see the &lt;a href=&quot;FlatSpec.html#IgnoredTests&quot;&gt;Ignored tests section&lt;/a&gt;
     * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;. For examples of tagged test registration, see
     * the &lt;a href=&quot;FlatSpec.html#TaggingTests&quot;&gt;Tagging tests section&lt;/a&gt; in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(testFun: =&gt; org.scalatest.PendingNothing)Unit" id="43087">is</a><span class="delimiter">(</span><a title="=&gt; org.scalatest.PendingNothing" id="43098">testFun</a>: =&gt; PendingNothing<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#42922" title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit">registerTestToIgnore</a><span class="delimiter">(</span><a href="#43092" title="String">verb</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#43093" title="String">name</a>, <a href="#43094" title="List[org.scalatest.Tag]">tags</a>, <a href="#43098" title="=&gt; org.scalatest.PendingNothing">testFun</a> _<span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="comment">// Note: no def ignore here, so you can't put two ignores in the same line</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Class that supports registration of ignored tests via the &lt;code&gt;IgnoreWord&lt;/code&gt; instance referenced
   * from &lt;code&gt;FlatSpec&lt;/code&gt;'s &lt;code&gt;ignore&lt;/code&gt; field.
   *
   * &lt;p&gt;
   * This class enables syntax such as the following registration of an ignored test:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * ignore should &quot;pop values in last-in-first-out order&quot; in { ... }
   *                                                       ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * In addition, it enables syntax such as the following registration of an ignored, pending test:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * ignore should &quot;pop values in last-in-first-out order&quot; is (pending)
   *                                                       ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * Note: the &lt;code&gt;is&lt;/code&gt; method is provided for completeness and design symmetry, given there's no way
   * to prevent changing &lt;code&gt;is&lt;/code&gt; to &lt;code&gt;ignore&lt;/code&gt; and marking a pending test as ignored that way.
   * Although it isn't clear why someone would want to mark a pending test as ignored, it can be done.
   * &lt;/p&gt;
   *
   * &lt;p&gt;
   * And finally, it also enables syntax such as the following ignored, tagged test registration:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * ignore should &quot;pop values in last-in-first-out order&quot; taggedAs(SlowTest) in { ... }
   *                                                       ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * For more information and examples of the use of the &lt;code&gt;ignore&lt;/code&gt; field, see the &lt;a href=&quot;FlatSpec.html#IgnoredTests&quot;&gt;Ignored tests section&lt;/a&gt;
   * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
   * &lt;/p&gt;
   */</span>
  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class IgnoreVerbString extends java.lang.Object with ScalaObject" id="42910">IgnoreVerbString</a><a href="#42910" title="ScalaObject" class="delimiter">(</a><a title="String" id="43112">verb</a>: <span title="String">String</span>, <a title="String" id="43113">name</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * Supports the registration of ignored tests in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * ignore must &quot;pop values in last-in-first-out order&quot; in { ... }
     *                                                     ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of the registration of ignored tests, see the &lt;a href=&quot;FlatSpec.html#IgnoredTests&quot;&gt;Ignored tests section&lt;/a&gt;
     * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(testFun: =&gt; Unit)Unit" id="43106">in</a><span class="delimiter">(</span><a title="=&gt; Unit" id="43114">testFun</a>: =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#42922" title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit">registerTestToIgnore</a><span class="delimiter">(</span><a href="#43112" title="String">verb</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#43113" title="String">name</a>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#43114" title="=&gt; Unit">testFun</a> _<span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Supports the registration of ignored, pending tests in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * ignore must &quot;pop values in last-in-first-out order&quot; is (pending)
     *                                                     ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * Note: this &lt;code&gt;is&lt;/code&gt; method is provided for completeness and design symmetry, given there's no way
     * to prevent changing &lt;code&gt;is&lt;/code&gt; to &lt;code&gt;ignore&lt;/code&gt; and marking a pending test as ignored that way.
     * Although it isn't clear why someone would want to mark a pending test as ignored, it can be done.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * For examples of pending test registration, see the &lt;a href=&quot;FlatSpec.html#PendingTests&quot;&gt;Pending tests section&lt;/a&gt; in the main documentation
     * for trait &lt;code&gt;FlatSpec&lt;/code&gt;.  For examples of the registration of ignored tests,
     * see the &lt;a href=&quot;FlatSpec.html#IgnoredTests&quot;&gt;Ignored tests section&lt;/a&gt;
     * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(testFun: =&gt; org.scalatest.PendingNothing)Unit" id="43107">is</a><span class="delimiter">(</span><a title="=&gt; org.scalatest.PendingNothing" id="43124">testFun</a>: =&gt; PendingNothing<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#42922" title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit">registerTestToIgnore</a><span class="delimiter">(</span><a href="#43112" title="String">verb</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#43113" title="String">name</a>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#43124" title="=&gt; org.scalatest.PendingNothing">testFun</a> _<span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Supports the registration of ignored, tagged tests in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * ignore must &quot;pop values in last-in-first-out order&quot; taggedAs(SlowTest) in { ... }
     *                                                     ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of tagged test registration, see the &lt;a href=&quot;FlatSpec.html#TaggingTests&quot;&gt;Tagging tests section&lt;/a&gt; in the main documentation
     * for trait &lt;code&gt;FlatSpec&lt;/code&gt;.  For examples of the registration of ignored tests,
     * see the &lt;a href=&quot;FlatSpec.html#IgnoredTests&quot;&gt;Ignored tests section&lt;/a&gt;
     * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(firstTestTag: org.scalatest.Tag, otherTestTags: org.scalatest.Tag*)FlatSpec.this.IgnoreVerbStringTaggedAs" id="43108">taggedAs</a><span class="delimiter">(</span><a title="org.scalatest.Tag" id="43134">firstTestTag</a>: <a href="Tag.scala.html#9953" title="org.scalatest.Tag">Tag</a>, <a title="org.scalatest.Tag*" id="43135">otherTestTags</a>: <span title="org.scalatest.Tag*">Tag</span>*<span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[org.scalatest.Tag]" id="43138">tagList</a> = <a href="#43134" title="org.scalatest.Tag">firstTestTag</a> <a href="#43139" title="(x: org.scalatest.Tag)List[org.scalatest.Tag]">::</a> <a href="#43135" title="org.scalatest.Tag*">otherTestTags</a>.<span title="=&gt; List[org.scalatest.Tag]">toList</span>
      <span title="FlatSpec.this.IgnoreVerbStringTaggedAs" class="keyword">new</span> <a href="#42909" title="FlatSpec.this.IgnoreVerbStringTaggedAs">IgnoreVerbStringTaggedAs</a><span class="delimiter">(</span><a href="#43112" title="String">verb</a>, <a href="#43113" title="String">name</a>, <a href="#43138" title="List[org.scalatest.Tag]">tagList</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Class that supports registration of ignored tests via the &lt;code&gt;ItWord&lt;/code&gt; instance
   * referenced from &lt;code&gt;FlatSpec&lt;/code&gt;'s &lt;code&gt;ignore&lt;/code&gt; field.
   *
   * &lt;p&gt;
   * This class enables syntax such as the following registration of an ignored test:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * ignore should &quot;pop values in last-in-first-out order&quot; in { ... }
   * ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * For more information and examples of the use of the &lt;code&gt;ignore&lt;/code&gt; field, see &lt;a href=&quot;FlatSpec.html#IgnoredTests&quot;&gt;Ignored tests section&lt;/a&gt;
   * in the main documentation for this trait.
   * &lt;/p&gt;
   */</span>
  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class IgnoreWord extends java.lang.Object with ScalaObject" id="42911">IgnoreWord</a> <a href="#42911" title="ScalaObject" class="delimiter">{</a>

    <span class="comment">/**
     * Supports the registration of ignored tests with &lt;code&gt;should&lt;/code&gt; in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * ignore should &quot;pop values in last-in-first-out order&quot; in { ... }
     *        ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For more information and examples of the use of the &lt;code&gt;ignore&lt;/code&gt; field, see &lt;a href=&quot;FlatSpec.html#IgnoredTests&quot;&gt;Ignored tests section&lt;/a&gt;
     * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(string: String)FlatSpec.this.IgnoreVerbString" id="42950">should</a><span class="delimiter">(</span><a title="String" id="43144">string</a>: <span title="String">String</span><span class="delimiter">)</span> = <span title="FlatSpec.this.IgnoreVerbString" class="keyword">new</span> <a href="#42910" title="FlatSpec.this.IgnoreVerbString">IgnoreVerbString</a><span class="delimiter">(</span><span title="java.lang.String(&quot;should&quot;)" class="string">&quot;should&quot;</span>, <a href="#43144" title="String">string</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Supports the registration of ignored tests with &lt;code&gt;must&lt;/code&gt; in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * ignore must &quot;pop values in last-in-first-out order&quot; in { ... }
     *        ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For more information and examples of the use of the &lt;code&gt;ignore&lt;/code&gt; field, see &lt;a href=&quot;FlatSpec.html#IgnoredTests&quot;&gt;Ignored tests section&lt;/a&gt;
     * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(string: String)FlatSpec.this.IgnoreVerbString" id="42951">must</a><span class="delimiter">(</span><a title="String" id="43147">string</a>: <span title="String">String</span><span class="delimiter">)</span> = <span title="FlatSpec.this.IgnoreVerbString" class="keyword">new</span> <a href="#42910" title="FlatSpec.this.IgnoreVerbString">IgnoreVerbString</a><span class="delimiter">(</span><span title="java.lang.String(&quot;must&quot;)" class="string">&quot;must&quot;</span>, <a href="#43147" title="String">string</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Supports the registration of ignored tests with &lt;code&gt;can&lt;/code&gt; in a &lt;code&gt;FlatSpec&lt;/code&gt;.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * ignore can &quot;pop values in last-in-first-out order&quot; in { ... }
     *        ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For more information and examples of the use of the &lt;code&gt;ignore&lt;/code&gt; field, see &lt;a href=&quot;FlatSpec.html#IgnoredTests&quot;&gt;Ignored tests section&lt;/a&gt;
     * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(string: String)FlatSpec.this.IgnoreVerbString" id="42952">can</a><span class="delimiter">(</span><a title="String" id="43150">string</a>: <span title="String">String</span><span class="delimiter">)</span> = <span title="FlatSpec.this.IgnoreVerbString" class="keyword">new</span> <a href="#42910" title="FlatSpec.this.IgnoreVerbString">IgnoreVerbString</a><span class="delimiter">(</span><span title="java.lang.String(&quot;can&quot;)" class="string">&quot;can&quot;</span>, <a href="#43150" title="String">string</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Supports registration of ignored tests in &lt;code&gt;FlatSpec&lt;/code&gt;s.
   *
   * &lt;p&gt;
   * This field enables syntax such as the following registration of an ignored test:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * ignore should &quot;pop values in last-in-first-out order&quot; in { ... }
   * ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * For more information and examples of the use of the &lt;code&gt;ignore&lt;/code&gt; field, see the &lt;a href=&quot;#IgnoredTests&quot;&gt;Ignored tests section&lt;/a&gt;
   * in the main documentation for this trait.
   * &lt;/p&gt;
   */</span>
  <span class="keyword">protected</span> <span class="keyword">val</span> <a title="FlatSpec.this.IgnoreWord" id="42912">ignore</a> = <span title="FlatSpec.this.IgnoreWord" class="keyword">new</span> <a href="#42911" title="FlatSpec.this.IgnoreWord">IgnoreWord</a>

  <span class="comment">/**
   * Class that supports test registration in shorthand form.
   *
   * &lt;p&gt;
   * For example, this class enables syntax such as the following test registration
   * in shorthand form:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * &quot;A Stack (when empty)&quot; should &quot;be empty&quot; in { ... }
   *                                          ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * This class also enables syntax such as the following ignored test registration
   * in shorthand form:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * &quot;A Stack (when empty)&quot; should &quot;be empty&quot; ignore { ... }
   *                                          ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * This class is used via an implicit conversion (named &lt;code&gt;convertToInAndIgnoreMethods&lt;/code&gt;)
   * from &lt;code&gt;ResultOfStringPassedToVerb&lt;/code&gt;. The &lt;code&gt;ResultOfStringPassedToVerb&lt;/code&gt; class
   * does not declare any methods named &lt;code&gt;in&lt;/code&gt;, because the
   * type passed to &lt;code&gt;in&lt;/code&gt; differs in a &lt;code&gt;FlatSpec&lt;/code&gt; and a &lt;code&gt;FixtureFlatSpec&lt;/code&gt;.
   * A &lt;code&gt;FixtureFlatSpec&lt;/code&gt; needs two &lt;code&gt;in&lt;/code&gt; methods, one that takes a no-arg
   * test function and another that takes a one-arg test function (a test that takes a
   * &lt;code&gt;Fixture&lt;/code&gt; as its parameter). By constrast, a &lt;code&gt;FlatSpec&lt;/code&gt; needs
   * only one &lt;code&gt;in&lt;/code&gt; method that takes a by-name parameter. As a result,
   * &lt;code&gt;FlatSpec&lt;/code&gt; and &lt;code&gt;FixtureFlatSpec&lt;/code&gt; each provide an implicit conversion
   * from &lt;code&gt;ResultOfStringPassedToVerb&lt;/code&gt; to a type that provides the appropriate
   * &lt;code&gt;in&lt;/code&gt; methods.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class InAndIgnoreMethods extends java.lang.Object with ScalaObject" id="42914">InAndIgnoreMethods</a><a href="#42914" title="ScalaObject" class="delimiter">(</a><a title="org.scalatest.verb.ResultOfStringPassedToVerb" id="43171">resultOfStringPassedToVerb</a>: <a href="verb/ResultOfStringPassedToVerb.scala.html#15145" title="org.scalatest.verb.ResultOfStringPassedToVerb">ResultOfStringPassedToVerb</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="keyword">import</span> <a href="#43171" title="org.scalatest.verb.ResultOfStringPassedToVerb">resultOfStringPassedToVerb</a>.verb
    <span class="keyword">import</span> <a href="#43171" title="org.scalatest.verb.ResultOfStringPassedToVerb">resultOfStringPassedToVerb</a>.rest

    <span class="comment">/**
     * Supports the registration of tests in shorthand form.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * &quot;A Stack&quot; must &quot;pop values in last-in-first-out order&quot; in { ... }
     *                                                        ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of test registration, see the &lt;a href=&quot;FlatSpec.html&quot;&gt;main documentation&lt;/a&gt;
     * for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(testFun: =&gt; Unit)Unit" id="43158">in</a><span class="delimiter">(</span><a title="=&gt; Unit" id="43172">testFun</a>: =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#42900" title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit">registerTestToRun</a><span class="delimiter">(</span><a href="verb/ResultOfStringPassedToVerb.scala.html#43164" title="=&gt; String">verb</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="verb/ResultOfStringPassedToVerb.scala.html#43166" title="=&gt; String">rest</a>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#43172" title="=&gt; Unit">testFun</a> _<span class="delimiter">)</span>
    <span class="delimiter">}</span>
    
    <span class="comment">/**
     * Supports the registration of ignored tests in shorthand form.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * &quot;A Stack&quot; must &quot;pop values in last-in-first-out order&quot; ignore { ... }
     *                                                        ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of ignored test registration, see the &lt;a href=&quot;FlatSpec.html#IgnoredTests&quot;&gt;Ignored tests section&lt;/a&gt;
     * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(testFun: =&gt; Unit)Unit" id="43159">ignore</a><span class="delimiter">(</span><a title="=&gt; Unit" id="43182">testFun</a>: =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#42922" title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit">registerTestToIgnore</a><span class="delimiter">(</span><a href="verb/ResultOfStringPassedToVerb.scala.html#43164" title="=&gt; String">verb</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="verb/ResultOfStringPassedToVerb.scala.html#43166" title="=&gt; String">rest</a>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#43182" title="=&gt; Unit">testFun</a> _<span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;ResultOfStringPassedToVerb&lt;/code&gt; to an
   * &lt;code&gt;InAndIgnoreMethods&lt;/code&gt;, to enable &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;ignore&lt;/code&gt;
   * methods to be invokable on that object.
   */</span>
  <span class="keyword">protected</span> <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit org.scalatest.FlatSpec.convertToInAndIgnoreMethods : (resultOfStringPassedToVerb: org.scalatest.verb.ResultOfStringPassedToVerb)FlatSpec.this.InAndIgnoreMethods" id="42915">convertToInAndIgnoreMethods</a><span class="delimiter">(</span><a title="org.scalatest.verb.ResultOfStringPassedToVerb" id="43192">resultOfStringPassedToVerb</a>: <a href="verb/ResultOfStringPassedToVerb.scala.html#15145" title="org.scalatest.verb.ResultOfStringPassedToVerb">ResultOfStringPassedToVerb</a><span class="delimiter">)</span> =
    <span title="FlatSpec.this.InAndIgnoreMethods" class="keyword">new</span> <a href="#42914" title="FlatSpec.this.InAndIgnoreMethods">InAndIgnoreMethods</a><span class="delimiter">(</span><a href="#43192" title="org.scalatest.verb.ResultOfStringPassedToVerb">resultOfStringPassedToVerb</a><span class="delimiter">)</span>
  
  <span class="comment">/**
   * Class that supports tagged test registration in shorthand form.
   *
   * &lt;p&gt;
   * For example, this class enables syntax such as the following tagged test registration
   * in shorthand form:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * &quot;A Stack (when empty)&quot; should &quot;be empty&quot; taggedAs() in { ... }
   *                                                     ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * This class also enables syntax such as the following tagged, ignored test registration
   * in shorthand form:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * &quot;A Stack (when empty)&quot; should &quot;be empty&quot; taggedAs(SlowTest) ignore { ... }
   *                                                             ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * This class is used via an implicit conversion (named &lt;code&gt;convertToInAndIgnoreMethodsAfterTaggedAs&lt;/code&gt;)
   * from &lt;code&gt;ResultOfTaggedAsInvocation&lt;/code&gt;. The &lt;code&gt;ResultOfTaggedAsInvocation&lt;/code&gt; class
   * does not declare any methods named &lt;code&gt;in&lt;/code&gt;, because the
   * type passed to &lt;code&gt;in&lt;/code&gt; differs in a &lt;code&gt;FlatSpec&lt;/code&gt; and a &lt;code&gt;FixtureFlatSpec&lt;/code&gt;.
   * A &lt;code&gt;FixtureFlatSpec&lt;/code&gt; needs two &lt;code&gt;in&lt;/code&gt; methods, one that takes a no-arg
   * test function and another that takes a one-arg test function (a test that takes a
   * &lt;code&gt;Fixture&lt;/code&gt; as its parameter). By constrast, a &lt;code&gt;FlatSpec&lt;/code&gt; needs
   * only one &lt;code&gt;in&lt;/code&gt; method that takes a by-name parameter. As a result,
   * &lt;code&gt;FlatSpec&lt;/code&gt; and &lt;code&gt;FixtureFlatSpec&lt;/code&gt; each provide an implicit conversion
   * from &lt;code&gt;ResultOfTaggedAsInvocation&lt;/code&gt; to a type that provides the appropriate
   * &lt;code&gt;in&lt;/code&gt; methods.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class InAndIgnoreMethodsAfterTaggedAs extends java.lang.Object with ScalaObject" id="42916">InAndIgnoreMethodsAfterTaggedAs</a><a href="#42916" title="ScalaObject" class="delimiter">(</a><a title="org.scalatest.verb.ResultOfTaggedAsInvocation" id="43216">resultOfTaggedAsInvocation</a>: <a href="verb/ResultOfTaggedAsInvocation.scala.html#15169" title="org.scalatest.verb.ResultOfTaggedAsInvocation">ResultOfTaggedAsInvocation</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="keyword">import</span> <a href="#43216" title="org.scalatest.verb.ResultOfTaggedAsInvocation">resultOfTaggedAsInvocation</a>.verb
    <span class="keyword">import</span> <a href="#43216" title="org.scalatest.verb.ResultOfTaggedAsInvocation">resultOfTaggedAsInvocation</a>.rest
    <span class="keyword">import</span> <a href="#43216" title="org.scalatest.verb.ResultOfTaggedAsInvocation">resultOfTaggedAsInvocation</a>.<span class="delimiter">{</span>tags =&gt; tagsList<span class="delimiter">}</span>

    <span class="comment">/**
     * Supports the registration of tagged tests in shorthand form.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * &quot;A Stack&quot; must &quot;pop values in last-in-first-out order&quot; taggedAs(SlowTest) in { ... }
     *                                                                           ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of tagged test registration, see the &lt;a href=&quot;FlatSpec.html#TaggingTests&quot;&gt;Tagging tests section&lt;/a&gt;
     * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(testFun: =&gt; Unit)Unit" id="43201">in</a><span class="delimiter">(</span><a title="=&gt; Unit" id="43217">testFun</a>: =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#42900" title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit">registerTestToRun</a><span class="delimiter">(</span><a href="verb/ResultOfTaggedAsInvocation.scala.html#43208" title="=&gt; String">verb</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="verb/ResultOfTaggedAsInvocation.scala.html#43210" title="=&gt; String">rest</a>, <a href="verb/ResultOfTaggedAsInvocation.scala.html#43212" title="=&gt; List[org.scalatest.Tag]">tagsList</a>, <a href="#43217" title="=&gt; Unit">testFun</a> _<span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Supports the registration of tagged, ignored tests in shorthand form.
     *
     * &lt;p&gt;
     * This method supports syntax such as the following:
     * &lt;/p&gt;
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * &quot;A Stack&quot; must &quot;pop values in last-in-first-out order&quot; taggedAs(SlowTest) ignore { ... }
     *                                                                           ^
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * For examples of ignored test registration, see the &lt;a href=&quot;FlatSpec.html#IgnoredTests&quot;&gt;Ignored tests section&lt;/a&gt;
     * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * For examples of tagged test registration, see the &lt;a href=&quot;FlatSpec.html#TaggingTests&quot;&gt;Tagging tests section&lt;/a&gt;
     * in the main documentation for trait &lt;code&gt;FlatSpec&lt;/code&gt;.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(testFun: =&gt; Unit)Unit" id="43202">ignore</a><span class="delimiter">(</span><a title="=&gt; Unit" id="43220">testFun</a>: =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#42922" title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit">registerTestToIgnore</a><span class="delimiter">(</span><a href="verb/ResultOfTaggedAsInvocation.scala.html#43208" title="=&gt; String">verb</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="verb/ResultOfTaggedAsInvocation.scala.html#43210" title="=&gt; String">rest</a>, <a href="verb/ResultOfTaggedAsInvocation.scala.html#43212" title="=&gt; List[org.scalatest.Tag]">tagsList</a>, <a href="#43220" title="=&gt; Unit">testFun</a> _<span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;ResultOfTaggedAsInvocation&lt;/code&gt; to an
   * &lt;code&gt;InAndIgnoreMethodsAfterTaggedAs&lt;/code&gt;, to enable &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;ignore&lt;/code&gt;
   * methods to be invokable on that object.
   */</span>
  <span class="keyword">protected</span> <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit org.scalatest.FlatSpec.convertToInAndIgnoreMethodsAfterTaggedAs : (resultOfTaggedAsInvocation: org.scalatest.verb.ResultOfTaggedAsInvocation)FlatSpec.this.InAndIgnoreMethodsAfterTaggedAs" id="42917">convertToInAndIgnoreMethodsAfterTaggedAs</a><span class="delimiter">(</span><a title="org.scalatest.verb.ResultOfTaggedAsInvocation" id="43223">resultOfTaggedAsInvocation</a>: <a href="verb/ResultOfTaggedAsInvocation.scala.html#15169" title="org.scalatest.verb.ResultOfTaggedAsInvocation">ResultOfTaggedAsInvocation</a><span class="delimiter">)</span> =
    <span title="FlatSpec.this.InAndIgnoreMethodsAfterTaggedAs" class="keyword">new</span> <a href="#42916" title="FlatSpec.this.InAndIgnoreMethodsAfterTaggedAs">InAndIgnoreMethodsAfterTaggedAs</a><span class="delimiter">(</span><a href="#43223" title="org.scalatest.verb.ResultOfTaggedAsInvocation">resultOfTaggedAsInvocation</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Supports the shorthand form of test registration.
   *
   * &lt;p&gt;
   * For example, this method enables syntax such as the following:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * &quot;A Stack (when empty)&quot; should &quot;be empty&quot; in { ... }
   *                        ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * This function is passed as an implicit parameter to a &lt;code&gt;should&lt;/code&gt; method
   * provided in &lt;code&gt;ShouldVerb&lt;/code&gt;, a &lt;code&gt;must&lt;/code&gt; method
   * provided in &lt;code&gt;MustVerb&lt;/code&gt;, and a &lt;code&gt;can&lt;/code&gt; method
   * provided in &lt;code&gt;CanVerb&lt;/code&gt;. When invoked, this function registers the
   * subject description (the first parameter to the function) and returns a &lt;code&gt;ResultOfStringPassedToVerb&lt;/code&gt;
   * initialized with the verb and rest parameters (the second and third parameters to
   * the function, respectively).
   * &lt;/p&gt;
   */</span>
  <span class="keyword">protected</span> <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="(String, String, String) =&gt; org.scalatest.verb.ResultOfStringPassedToVerb" id="42918">shorthandTestRegistrationFunction</a>: <span class="delimiter">(</span>String, String, String<span class="delimiter">)</span> =&gt; ResultOfStringPassedToVerb = <span class="delimiter">{</span>
    <span class="delimiter">(</span><a title="String" id="43227">subject</a>, <a title="String" id="43228">verb</a>, <a title="String" id="43229">rest</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
      <a href="#42902" title="=&gt; FlatSpec.this.BehaviorWord">behavior</a>.<a href="#42941" title="(description: String)Unit">of</a><span class="delimiter">(</span><a href="#43227" title="String">subject</a><span class="delimiter">)</span>
      <a href="#43230" title="org.scalatest.verb.ResultOfStringPassedToVerb" class="keyword">new</a> <a href="verb/ResultOfStringPassedToVerb.scala.html#15145" title="anonymous class $anon extends org.scalatest.verb.ResultOfStringPassedToVerb" id="43230">ResultOfStringPassedToVerb</a><span class="delimiter">(</span><a href="#43228" title="String">verb</a>, <a href="#43229" title="String">rest</a><span class="delimiter">)</span> <span class="delimiter">{</span>

        <span class="keyword">def</span> <a title="(testFun: =&gt; org.scalatest.PendingNothing)Unit" id="43236">is</a><span class="delimiter">(</span><a title="=&gt; org.scalatest.PendingNothing" id="43238">testFun</a>: =&gt; PendingNothing<span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#42900" title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit">registerTestToRun</a><span class="delimiter">(</span><a href="verb/ResultOfStringPassedToVerb.scala.html#43164" title="=&gt; String">verb</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="verb/ResultOfStringPassedToVerb.scala.html#43166" title="=&gt; String">rest</a>, List<span title="object Nil" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#43238" title="=&gt; org.scalatest.PendingNothing">testFun</a> _<span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="comment">// Note, won't have an is method that takes fixture =&gt; PendingNothing one, because don't want</span>
        <span class="comment">// to say is (fixture =&gt; pending), rather just say is (pending)</span>
        <span class="keyword">def</span> <a title="(firstTestTag: org.scalatest.Tag, otherTestTags: org.scalatest.Tag*)org.scalatest.verb.ResultOfTaggedAsInvocation" id="43237">taggedAs</a><span class="delimiter">(</span><a title="org.scalatest.Tag" id="43241">firstTestTag</a>: <a href="Tag.scala.html#9953" title="org.scalatest.Tag">Tag</a>, <a title="org.scalatest.Tag*" id="43242">otherTestTags</a>: <span title="org.scalatest.Tag*">Tag</span>*<span class="delimiter">)</span> = <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="List[org.scalatest.Tag]" id="43246">tagList</a> = <a href="#43241" title="org.scalatest.Tag">firstTestTag</a> <a href="#43247" title="(x: org.scalatest.Tag)List[org.scalatest.Tag]">::</a> <a href="#43242" title="org.scalatest.Tag*">otherTestTags</a>.<span title="=&gt; List[org.scalatest.Tag]">toList</span>
          <a href="#43251" title="org.scalatest.verb.ResultOfTaggedAsInvocation" class="keyword">new</a> <a href="verb/ResultOfTaggedAsInvocation.scala.html#15169" title="anonymous class $anon extends org.scalatest.verb.ResultOfTaggedAsInvocation" id="43251">ResultOfTaggedAsInvocation</a><span class="delimiter">(</span><a href="verb/ResultOfStringPassedToVerb.scala.html#43164" title="=&gt; String">verb</a>, <a href="verb/ResultOfStringPassedToVerb.scala.html#43166" title="=&gt; String">rest</a>, <a href="#43246" title="List[org.scalatest.Tag]">tagList</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="comment">// &quot;A Stack&quot; should &quot;bla bla&quot; taggedAs(SlowTest) is (pending)</span>
            <span class="comment">//                                               ^</span>
            <span class="keyword">def</span> <a title="(testFun: =&gt; org.scalatest.PendingNothing)Unit" id="43258">is</a><span class="delimiter">(</span><a title="=&gt; org.scalatest.PendingNothing" id="43259">testFun</a>: =&gt; PendingNothing<span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#42900" title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit">registerTestToRun</a><span class="delimiter">(</span><a href="verb/ResultOfTaggedAsInvocation.scala.html#43208" title="=&gt; String">verb</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="verb/ResultOfTaggedAsInvocation.scala.html#43210" title="=&gt; String">rest</a>, <a href="verb/ResultOfTaggedAsInvocation.scala.html#43212" title="=&gt; List[org.scalatest.Tag]">tags</a>, <a href="#43259" title="=&gt; org.scalatest.PendingNothing">testFun</a> _<span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Supports the shorthand form of shared test registration.
   *
   * &lt;p&gt;
   * For example, this method enables syntax such as the following in:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * &quot;A Stack (with one item)&quot; should behave like nonEmptyStack(stackWithOneItem, lastValuePushed)
   *                           ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * This function is passed as an implicit parameter to a &lt;code&gt;should&lt;/code&gt; method
   * provided in &lt;code&gt;ShouldVerb&lt;/code&gt;, a &lt;code&gt;must&lt;/code&gt; method
   * provided in &lt;code&gt;MustVerb&lt;/code&gt;, and a &lt;code&gt;can&lt;/code&gt; method
   * provided in &lt;code&gt;CanVerb&lt;/code&gt;. When invoked, this function registers the
   * subject description (the  parameter to the function) and returns a &lt;code&gt;BehaveWord&lt;/code&gt;.
   * &lt;/p&gt;
   */</span>
  <span class="keyword">protected</span> <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="String =&gt; org.scalatest.verb.BehaveWord" id="42920">shorthandSharedTestRegistrationFunction</a>: <span class="delimiter">(</span>String<span class="delimiter">)</span> =&gt; BehaveWord = <span class="delimiter">{</span>
    <span class="delimiter">(</span><a title="String" id="43294">left</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
      <a href="#42902" title="=&gt; FlatSpec.this.BehaviorWord">behavior</a>.<a href="#42941" title="(description: String)Unit">of</a><span class="delimiter">(</span><a href="#43294" title="String">left</a><span class="delimiter">)</span>
      <span title="org.scalatest.verb.BehaveWord" class="keyword">new</span> <a href="verb/BehaveWord.scala.html#15142" title="org.scalatest.verb.BehaveWord">BehaveWord</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Register a test to ignore, which has the given spec text, optional tags, and test function value that takes no arguments.
   * This method will register the test for later ignoring via an invocation of one of the &lt;code&gt;execute&lt;/code&gt;
   * methods. This method exists to make it easy to ignore an existing test by changing the call to &lt;code&gt;it&lt;/code&gt;
   * to &lt;code&gt;ignore&lt;/code&gt; without deleting or commenting out the actual test code. The test will not be executed, but a
   * report will be sent that indicates the test was ignored. The name of the test will be a concatenation of the text of all surrounding describers,
   * from outside in, and the passed spec text, with one space placed between each item. (See the documenation
   * for &lt;code&gt;testNames&lt;/code&gt; for an example.) The resulting test name must not have been registered previously on
   * this &lt;code&gt;Spec&lt;/code&gt; instance.
   *
   * @param specText the specification text, which will be combined with the descText of any surrounding describers
   * to form the test name
   * @param testTags the optional list of tags for this test
   * @param testFun the test function
   * @throws DuplicateTestNameException if a test with the same name has been registered previously
   * @throws TestRegistrationClosedException if invoked after &lt;code&gt;run&lt;/code&gt; has been invoked on this suite
   * @throws NullPointerException if &lt;code&gt;specText&lt;/code&gt; or any passed test tag is &lt;code&gt;null&lt;/code&gt;
   */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(specText: String, testTags: List[org.scalatest.Tag], testFun: () =&gt; Unit)Unit" id="42922">registerTestToIgnore</a><span class="delimiter">(</span><a title="String" id="43000">specText</a>: <span title="String">String</span>, <a title="List[org.scalatest.Tag]" id="43001">testTags</a>: <span title="List[org.scalatest.Tag]">List</span><span class="delimiter">[</span>Tag<span class="delimiter">]</span>, <a title="() =&gt; Unit" id="43002">testFun</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">// TODO: This is how these were, but it needs attention. Mentions &quot;it&quot;.</span>
    <a href="Engine.scala.html#36509" title="(testText: String, f: () =&gt; Unit, testRegistrationClosedResourceName: String, sourceFileName: String, methodName: String, testTags: org.scalatest.Tag*)Unit">registerIgnoredTest</a><span class="delimiter">(</span><a href="#43000" title="String">specText</a>, <a href="#43002" title="() =&gt; Unit">testFun</a>, <span title="java.lang.String(&quot;ignoreCannotAppearInsideAnIt&quot;)" class="string">&quot;ignoreCannotAppearInsideAnIt&quot;</span>, <span title="java.lang.String(&quot;FlatSpec.scala&quot;)" class="string">&quot;FlatSpec.scala&quot;</span>, <span title="java.lang.String(&quot;ignore&quot;)" class="string">&quot;ignore&quot;</span>, <a href="#43001" title="List[org.scalatest.Tag]">testTags</a>: _*<span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A &lt;code&gt;Map&lt;/code&gt; whose keys are &lt;code&gt;String&lt;/code&gt; tag names to which tests in this &lt;code&gt;Spec&lt;/code&gt; belong, and values
   * the &lt;code&gt;Set&lt;/code&gt; of test names that belong to each tag. If this &lt;code&gt;FlatSpec&lt;/code&gt; contains no tags, this method returns an empty &lt;code&gt;Map&lt;/code&gt;.
   *
   * &lt;p&gt;
   * This trait's implementation returns tags that were passed as strings contained in &lt;code&gt;Tag&lt;/code&gt; objects passed to 
   * methods &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;ignore&lt;/code&gt;. 
   * &lt;/p&gt;
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Map[String,Set[String]]" id="42923">tags</a>: <span title="Map[String,Set[String]]">Map</span><span class="delimiter">[</span>String, Set<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="Engine.scala.html#36491" title="=&gt; java.util.concurrent.atomic.AtomicReference[FlatSpec.this.engine.Bundle]">atomic</a>.<span title="()FlatSpec.this.engine.Bundle">get</span>.<a href="Engine.scala.html#36530" title="=&gt; Map[String,Set[String]]">tagsMap</a>

  <span class="comment">/**
   * Run a test. This trait's implementation runs the test registered with the name specified by
   * &lt;code&gt;testName&lt;/code&gt;. Each test's name is a concatenation of the text of all describers surrounding a test,
   * from outside in, and the test's  spec text, with one space placed between each item. (See the documenation
   * for &lt;code&gt;testNames&lt;/code&gt; for an example.)
   *
   * @param testName the name of one test to execute.
   * @param reporter the &lt;code&gt;Reporter&lt;/code&gt; to which results will be reported
   * @param stopper the &lt;code&gt;Stopper&lt;/code&gt; that will be consulted to determine whether to stop execution early.
   * @param configMap a &lt;code&gt;Map&lt;/code&gt; of properties that can be used by this &lt;code&gt;Spec&lt;/code&gt;'s executing tests.
   * @throws NullPointerException if any of &lt;code&gt;testName&lt;/code&gt;, &lt;code&gt;reporter&lt;/code&gt;, &lt;code&gt;stopper&lt;/code&gt;, or &lt;code&gt;configMap&lt;/code&gt;
   *     is &lt;code&gt;null&lt;/code&gt;.
   */</span>
  <span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="(testName: String, reporter: org.scalatest.Reporter, stopper: org.scalatest.Stopper, configMap: Map[String,Any], tracker: org.scalatest.Tracker)Unit" id="42924">runTest</a><span class="delimiter">(</span><a title="String" id="43303">testName</a>: <span title="String">String</span>, <a title="org.scalatest.Reporter" id="43304">reporter</a>: <a href="Reporter.scala.html#10103" title="org.scalatest.Reporter">Reporter</a>, <a title="org.scalatest.Stopper" id="43305">stopper</a>: <a href="Stopper.scala.html#9545" title="org.scalatest.Stopper">Stopper</a>, <a title="Map[String,Any]" id="43306">configMap</a>: <span title="Map[String,Any]">Map</span><span class="delimiter">[</span>String, Any<span class="delimiter">]</span>, <a title="org.scalatest.Tracker" id="43307">tracker</a>: <a href="Tracker.scala.html#9878" title="org.scalatest.Tracker">Tracker</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="keyword">def</span> <a title="(theTest: FlatSpec.this.engine.TestLeaf)Unit" id="43309">invokeWithFixture</a><span class="delimiter">(</span><a title="FlatSpec.this.engine.TestLeaf" id="43310">theTest</a>: <a href="Engine.scala.html#36479" title="FlatSpec.this.engine.TestLeaf">TestLeaf</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Map[String,Any]" id="43313">theConfigMap</a> = <a href="#43306" title="Map[String,Any]">configMap</a>
      <a href="Suite.scala.html#15664" title="(test: FlatSpec.this.NoArgTest)Unit">withFixture</a><span class="delimiter">(</span>
        <a href="#43316" title="java.lang.Object with FlatSpec.this.NoArgTest" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with FlatSpec.this.NoArgTest" id="43316">NoArgTest</a> <span class="delimiter">{</span>
          <span class="keyword">def</span> <a title="=&gt; String" id="43320">name</a> = <a href="#43303" title="String">testName</a>
          <span class="keyword">def</span> <a title="()Unit" id="43321">apply</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#43310" title="FlatSpec.this.engine.TestLeaf">theTest</a>.<a href="Engine.scala.html#36576" title="()Unit">testFun</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span>
          <span class="keyword">def</span> <a title="=&gt; Map[String,Any]" id="43322">configMap</a> = <a href="#43313" title="Map[String,Any]">theConfigMap</a>
        <span class="delimiter">}</span>
      <span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="Engine.scala.html#36500" title="(theSuite: org.scalatest.Suite, testName: String, reporter: org.scalatest.Reporter, stopper: org.scalatest.Stopper, configMap: Map[String,Any], tracker: org.scalatest.Tracker, includeIcon: Boolean, invokeWithFixture: FlatSpec.this.engine.TestLeaf =&gt; Unit)Unit">runTestImpl</a><span class="delimiter">(</span><a href="#9848" title="org.scalatest.FlatSpec">thisSuite</a>, <a href="#43303" title="String">testName</a>, <a href="#43304" title="org.scalatest.Reporter">reporter</a>, <a href="#43305" title="org.scalatest.Stopper">stopper</a>, <a href="#43306" title="Map[String,Any]">configMap</a>, <a href="#43307" title="org.scalatest.Tracker">tracker</a>, <span title="Boolean(true)" class="keyword">true</span>, <a href="#43309" title="(theTest: FlatSpec.this.engine.TestLeaf)Unit">invokeWithFixture</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Run zero to many of this &lt;code&gt;FlatSpec&lt;/code&gt;'s tests.
   *
   * &lt;p&gt;
   * This method takes a &lt;code&gt;testName&lt;/code&gt; parameter that optionally specifies a test to invoke.
   * If &lt;code&gt;testName&lt;/code&gt; is &lt;code&gt;Some&lt;/code&gt;, this trait's implementation of this method
   * invokes &lt;code&gt;runTest&lt;/code&gt; on this object, passing in:
   * &lt;/p&gt;
   *
   * &lt;ul&gt;
   * &lt;li&gt;&lt;code&gt;testName&lt;/code&gt; - the &lt;code&gt;String&lt;/code&gt; value of the &lt;code&gt;testName&lt;/code&gt; &lt;code&gt;Option&lt;/code&gt; passed
   *   to this method&lt;/li&gt;
   * &lt;li&gt;&lt;code&gt;reporter&lt;/code&gt; - the &lt;code&gt;Reporter&lt;/code&gt; passed to this method, or one that wraps and delegates to it&lt;/li&gt;
   * &lt;li&gt;&lt;code&gt;stopper&lt;/code&gt; - the &lt;code&gt;Stopper&lt;/code&gt; passed to this method, or one that wraps and delegates to it&lt;/li&gt;
   * &lt;li&gt;&lt;code&gt;configMap&lt;/code&gt; - the &lt;code&gt;configMap&lt;/code&gt; passed to this method, or one that wraps and delegates to it&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * &lt;p&gt;
   * This method takes a &lt;code&gt;Set&lt;/code&gt; of tag names that should be included (&lt;code&gt;tagsToInclude&lt;/code&gt;), and a &lt;code&gt;Set&lt;/code&gt;
   * that should be excluded (&lt;code&gt;tagsToExclude&lt;/code&gt;), when deciding which of this &lt;code&gt;Suite&lt;/code&gt;'s tests to execute.
   * If &lt;code&gt;tagsToInclude&lt;/code&gt; is empty, all tests will be executed
   * except those those belonging to tags listed in the &lt;code&gt;tagsToExclude&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt;. If &lt;code&gt;tagsToInclude&lt;/code&gt; is non-empty, only tests
   * belonging to tags mentioned in &lt;code&gt;tagsToInclude&lt;/code&gt;, and not mentioned in &lt;code&gt;tagsToExclude&lt;/code&gt;
   * will be executed. However, if &lt;code&gt;testName&lt;/code&gt; is &lt;code&gt;Some&lt;/code&gt;, &lt;code&gt;tagsToInclude&lt;/code&gt; and &lt;code&gt;tagsToExclude&lt;/code&gt; are essentially ignored.
   * Only if &lt;code&gt;testName&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; will &lt;code&gt;tagsToInclude&lt;/code&gt; and &lt;code&gt;tagsToExclude&lt;/code&gt; be consulted to
   * determine which of the tests named in the &lt;code&gt;testNames&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt; should be run. For more information on trait tags, see the main documentation for this trait.
   * &lt;/p&gt;
   *
   * &lt;p&gt;
   * If &lt;code&gt;testName&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, this trait's implementation of this method
   * invokes &lt;code&gt;testNames&lt;/code&gt; on this &lt;code&gt;Suite&lt;/code&gt; to get a &lt;code&gt;Set&lt;/code&gt; of names of tests to potentially execute.
   * (A &lt;code&gt;testNames&lt;/code&gt; value of &lt;code&gt;None&lt;/code&gt; essentially acts as a wildcard that means all tests in
   * this &lt;code&gt;Suite&lt;/code&gt; that are selected by &lt;code&gt;tagsToInclude&lt;/code&gt; and &lt;code&gt;tagsToExclude&lt;/code&gt; should be executed.)
   * For each test in the &lt;code&gt;testName&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt;, in the order
   * they appear in the iterator obtained by invoking the &lt;code&gt;elements&lt;/code&gt; method on the &lt;code&gt;Set&lt;/code&gt;, this trait's implementation
   * of this method checks whether the test should be run based on the &lt;code&gt;tagsToInclude&lt;/code&gt; and &lt;code&gt;tagsToExclude&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt;s.
   * If so, this implementation invokes &lt;code&gt;runTest&lt;/code&gt;, passing in:
   * &lt;/p&gt;
   *
   * &lt;ul&gt;
   * &lt;li&gt;&lt;code&gt;testName&lt;/code&gt; - the &lt;code&gt;String&lt;/code&gt; name of the test to run (which will be one of the names in the &lt;code&gt;testNames&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt;)&lt;/li&gt;
   * &lt;li&gt;&lt;code&gt;reporter&lt;/code&gt; - the &lt;code&gt;Reporter&lt;/code&gt; passed to this method, or one that wraps and delegates to it&lt;/li&gt;
   * &lt;li&gt;&lt;code&gt;stopper&lt;/code&gt; - the &lt;code&gt;Stopper&lt;/code&gt; passed to this method, or one that wraps and delegates to it&lt;/li&gt;
   * &lt;li&gt;&lt;code&gt;configMap&lt;/code&gt; - the &lt;code&gt;configMap&lt;/code&gt; passed to this method, or one that wraps and delegates to it&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * @param testName an optional name of one test to execute. If &lt;code&gt;None&lt;/code&gt;, all relevant tests should be executed.
   *                 I.e., &lt;code&gt;None&lt;/code&gt; acts like a wildcard that means execute all relevant tests in this &lt;code&gt;Spec&lt;/code&gt;.
   * @param reporter the &lt;code&gt;Reporter&lt;/code&gt; to which results will be reported
   * @param stopper the &lt;code&gt;Stopper&lt;/code&gt; that will be consulted to determine whether to stop execution early.
   * @param tagsToInclude a &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt; tag names to include in the execution of this &lt;code&gt;Spec&lt;/code&gt;
   * @param tagsToExclude a &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt; tag names to exclude in the execution of this &lt;code&gt;Spec&lt;/code&gt;
   * @param configMap a &lt;code&gt;Map&lt;/code&gt; of key-value pairs that can be used by this &lt;code&gt;Spec&lt;/code&gt;'s executing tests.
   * @throws NullPointerException if any of &lt;code&gt;testName&lt;/code&gt;, &lt;code&gt;reporter&lt;/code&gt;, &lt;code&gt;stopper&lt;/code&gt;, &lt;code&gt;tagsToInclude&lt;/code&gt;,
   *     &lt;code&gt;tagsToExclude&lt;/code&gt;, or &lt;code&gt;configMap&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
   */</span>
  <span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="(testName: Option[String], reporter: org.scalatest.Reporter, stopper: org.scalatest.Stopper, filter: org.scalatest.Filter, configMap: Map[String,Any], distributor: Option[org.scalatest.Distributor], tracker: org.scalatest.Tracker)Unit" id="42925">runTests</a><span class="delimiter">(</span><a title="Option[String]" id="43342">testName</a>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="org.scalatest.Reporter" id="43343">reporter</a>: <a href="Reporter.scala.html#10103" title="org.scalatest.Reporter">Reporter</a>, <a title="org.scalatest.Stopper" id="43344">stopper</a>: <a href="Stopper.scala.html#9545" title="org.scalatest.Stopper">Stopper</a>, <a title="org.scalatest.Filter" id="43345">filter</a>: <a href="Filter.scala.html#10079" title="org.scalatest.Filter">Filter</a>,
      <a title="Map[String,Any]" id="43346">configMap</a>: <span title="Map[String,Any]">Map</span><span class="delimiter">[</span>String, Any<span class="delimiter">]</span>, <a title="Option[org.scalatest.Distributor]" id="43347">distributor</a>: <span title="Option[org.scalatest.Distributor]">Option</span><span class="delimiter">[</span>Distributor<span class="delimiter">]</span>, <a title="org.scalatest.Tracker" id="43348">tracker</a>: <a href="Tracker.scala.html#9878" title="org.scalatest.Tracker">Tracker</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    
    <a href="Engine.scala.html#36503" title="(theSuite: org.scalatest.Suite, testName: Option[String], reporter: org.scalatest.Reporter, stopper: org.scalatest.Stopper, filter: org.scalatest.Filter, configMap: Map[String,Any], distributor: Option[org.scalatest.Distributor], tracker: org.scalatest.Tracker, info: String =&gt; Unit, includeIcon: Boolean, runTest: (String, org.scalatest.Reporter, org.scalatest.Stopper, Map[String,Any], org.scalatest.Tracker) =&gt; Unit)Unit">runTestsImpl</a><span class="delimiter">(</span><a href="#9848" title="org.scalatest.FlatSpec">thisSuite</a>, <a href="#43342" title="Option[String]">testName</a>, <a href="#43343" title="org.scalatest.Reporter">reporter</a>, <a href="#43344" title="org.scalatest.Stopper">stopper</a>, <a href="#43345" title="org.scalatest.Filter">filter</a>, <a href="#43346" title="Map[String,Any]">configMap</a>, <a href="#43347" title="Option[org.scalatest.Distributor]">distributor</a>, <a href="#43348" title="org.scalatest.Tracker">tracker</a>, <a href="#42899" title="=&gt; org.scalatest.Informer">info</a>, <span title="Boolean(true)" class="keyword">true</span>, <a href="#42924" title="(testName: String, reporter: org.scalatest.Reporter, stopper: org.scalatest.Stopper, configMap: Map[String,Any], tracker: org.scalatest.Tracker)Unit">runTest</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * An immutable &lt;code&gt;Set&lt;/code&gt; of test names. If this &lt;code&gt;FlatSpec&lt;/code&gt; contains no tests, this method returns an
   * empty &lt;code&gt;Set&lt;/code&gt;.
   *
   * &lt;p&gt;
   * This trait's implementation of this method will return a set that contains the names of all registered tests. The set's
   * iterator will return those names in the order in which the tests were registered. Each test's name is composed
   * of the concatenation of the text of each surrounding describer, in order from outside in, and the text of the
   * example itself, with all components separated by a space. For example, consider this &lt;code&gt;FlatSpec&lt;/code&gt;:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * import org.scalatest.FlatSpec
   *
   * class StackSpec extends FlatSpec {
   *
   *   &quot;A Stack (when not empty)&quot; must &quot;allow me to pop&quot; in {}
   *   it must &quot;not be empty&quot; in {}
   *
   *   &quot;A Stack (when not full)&quot; must &quot;allow me to push&quot; in {}
   *   it must &quot;not be full&quot; in {}
   * }
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * Invoking &lt;code&gt;testNames&lt;/code&gt; on this &lt;code&gt;Spec&lt;/code&gt; will yield a set that contains the following
   * two test name strings:
   * &lt;/p&gt;
   *
   * &lt;pre&gt;
   * &quot;A Stack (when not empty) must allow me to pop&quot;
   * &quot;A Stack (when not empty) must not be empty&quot;
   * &quot;A Stack (when not full) must allow me to push&quot;
   * &quot;A Stack (when not full) must not be full&quot;
   * &lt;/pre&gt;
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Set[String]" id="42926">testNames</a>: <span title="Set[String]">Set</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="comment">// I'm returning a ListSet here so that they tests will be run in registration order</span>
    <span title="(elems: String*)scala.collection.immutable.ListSet[String]">ListSet</span><span class="delimiter">(</span><a href="Engine.scala.html#36491" title="=&gt; java.util.concurrent.atomic.AtomicReference[FlatSpec.this.engine.Bundle]">atomic</a>.<span title="()FlatSpec.this.engine.Bundle">get</span>.<a href="Engine.scala.html#36526" title="=&gt; List[String]">testNamesList</a>.<span title="(implicit evidence$1: ClassManifest[String])Array[String]">toArray</span>: _*<span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="(testName: Option[String], reporter: org.scalatest.Reporter, stopper: org.scalatest.Stopper, filter: org.scalatest.Filter, configMap: Map[String,Any], distributor: Option[org.scalatest.Distributor], tracker: org.scalatest.Tracker)Unit" id="42927">run</a><span class="delimiter">(</span><a title="Option[String]" id="43389">testName</a>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="org.scalatest.Reporter" id="43390">reporter</a>: <a href="Reporter.scala.html#10103" title="org.scalatest.Reporter">Reporter</a>, <a title="org.scalatest.Stopper" id="43391">stopper</a>: <a href="Stopper.scala.html#9545" title="org.scalatest.Stopper">Stopper</a>, <a title="org.scalatest.Filter" id="43392">filter</a>: <a href="Filter.scala.html#10079" title="org.scalatest.Filter">Filter</a>,
      <a title="Map[String,Any]" id="43393">configMap</a>: <span title="Map[String,Any]">Map</span><span class="delimiter">[</span>String, Any<span class="delimiter">]</span>, <a title="Option[org.scalatest.Distributor]" id="43394">distributor</a>: <span title="Option[org.scalatest.Distributor]">Option</span><span class="delimiter">[</span>Distributor<span class="delimiter">]</span>, <a title="org.scalatest.Tracker" id="43395">tracker</a>: <a href="Tracker.scala.html#9878" title="org.scalatest.Tracker">Tracker</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <a href="Engine.scala.html#36504" title="(theSuite: org.scalatest.Suite, testName: Option[String], reporter: org.scalatest.Reporter, stopper: org.scalatest.Stopper, filter: org.scalatest.Filter, configMap: Map[String,Any], distributor: Option[org.scalatest.Distributor], tracker: org.scalatest.Tracker, superRun: (Option[String], org.scalatest.Reporter, org.scalatest.Stopper, org.scalatest.Filter, Map[String,Any], Option[org.scalatest.Distributor], org.scalatest.Tracker) =&gt; Unit)Unit">runImpl</a><span class="delimiter">(</span><a href="#9848" title="org.scalatest.FlatSpec">thisSuite</a>, <a href="#43389" title="Option[String]">testName</a>, <a href="#43390" title="org.scalatest.Reporter">reporter</a>, <a href="#43391" title="org.scalatest.Stopper">stopper</a>, <a href="#43392" title="org.scalatest.Filter">filter</a>, <a href="#43393" title="Map[String,Any]">configMap</a>, <a href="#43394" title="Option[org.scalatest.Distributor]">distributor</a>, <a href="#43395" title="org.scalatest.Tracker">tracker</a>, <a href="#9848" title="org.scalatest.FlatSpec" class="keyword">super</a>.<a href="Suite.scala.html#15669" title="(testName: Option[String], reporter: org.scalatest.Reporter, stopper: org.scalatest.Stopper, filter: org.scalatest.Filter, configMap: Map[String,Any], distributor: Option[org.scalatest.Distributor], tracker: org.scalatest.Tracker)Unit">run</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Supports shared test registration in &lt;code&gt;FlatSpec&lt;/code&gt;s.
   *
   * &lt;p&gt;
   * This field supports syntax such as the following:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * it should behave like nonFullStack(stackWithOneItem)
   *           ^
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * For more information and examples of the use of &lt;code&gt;behave&lt;/code&gt;, see the &lt;a href=&quot;#SharedTests&quot;&gt;Shared tests section&lt;/a&gt;
   * in the main documentation for this trait.
   * &lt;/p&gt;
   */</span>
  <span class="keyword">protected</span> <span class="keyword">val</span> <a title="org.scalatest.verb.BehaveWord" id="42928">behave</a> = <span title="org.scalatest.verb.BehaveWord" class="keyword">new</span> <a href="verb/BehaveWord.scala.html#15142" title="org.scalatest.verb.BehaveWord">BehaveWord</a>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>