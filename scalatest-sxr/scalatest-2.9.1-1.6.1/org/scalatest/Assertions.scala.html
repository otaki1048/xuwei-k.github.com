<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>org/scalatest/Assertions.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright 2001-2008 Artima, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>
<span class="keyword">package</span> org.scalatest

<span class="keyword">import</span> scala.reflect.Manifest
<span class="keyword">import</span> <a href="#10095" title="object org.scalatest.Assertions">Assertions</a>.areEqualComparingArraysStructurally

<span class="comment">/**
 * Trait that contains ScalaTest's basic assertion methods.
 *
 * &lt;p&gt;
 * You can use the assertions provided by this trait in any ScalaTest &lt;code&gt;Suite&lt;/code&gt;, because &lt;code&gt;Suite&lt;/code&gt;
 * mixes in this trait. This trait is designed to be used independently of anything else in ScalaTest, though, so you
 * can mix it into anything. (You can alternatively import the methods defined in this trait. For details, see the documentation
 * for the &lt;a href=&quot;Assertions$.html&quot;&gt;&lt;code&gt;Assertions&lt;/code&gt; companion object&lt;/a&gt;.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * In any Scala program, you can write assertions by invoking &lt;code&gt;assert&lt;/code&gt; and passing in a &lt;code&gt;Boolean&lt;/code&gt; expression,
 * such as:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * val left = 2
 * val right = 1
 * assert(left == right)
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * If the passed expression is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;assert&lt;/code&gt; will return normally. If &lt;code&gt;false&lt;/code&gt;,
 * &lt;code&gt;assert&lt;/code&gt; will complete abruptly with an &lt;code&gt;AssertionError&lt;/code&gt;. This behavior is provided by
 * the &lt;code&gt;assert&lt;/code&gt; method defined in object &lt;code&gt;Predef&lt;/code&gt;, whose members are implicitly imported into every
 * Scala source file. This &lt;code&gt;Assertions&lt;/code&gt; traits defines another &lt;code&gt;assert&lt;/code&gt; method that hides the
 * one in &lt;code&gt;Predef&lt;/code&gt;. It behaves the same, except that if &lt;code&gt;false&lt;/code&gt; is passed it throws
 * &lt;code&gt;TestFailedException&lt;/code&gt; instead of &lt;code&gt;AssertionError&lt;/code&gt;. The reason it throws &lt;code&gt;TestFailedException&lt;/code&gt;
 * is because &lt;code&gt;TestFailedException&lt;/code&gt; carries information about exactly which item in the stack trace represents
 * the line of test code that failed, which can help users more quickly find an offending line of code in a failing test.
 * &lt;p&gt;
 *
 * &lt;p&gt;
 * If you pass the previous &lt;code&gt;Boolean&lt;/code&gt; expression, &lt;code&gt;left == right&lt;/code&gt; to &lt;code&gt;assert&lt;/code&gt; in a ScalaTest test, a failure
 * will be reported, but without reporting the left and right values. You can alternatively encode these values in a &lt;code&gt;String&lt;/code&gt; passed as
 * a second argument to &lt;code&gt;assert&lt;/code&gt;, like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * val left = 2
 * val right = 1
 * assert(left == right, left + &quot; did not equal &quot; + right)
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Using this form of &lt;code&gt;assert&lt;/code&gt;, the failure report will include the left and right values, thereby
 * helping you debug the problem. However, ScalaTest provides the &lt;code&gt;===&lt;/code&gt; operator to make this easier.
 * You use it like this:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * val left = 2
 * val right = 1
 * assert(left === right)
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Because you use &lt;code&gt;===&lt;/code&gt; here instead of &lt;code&gt;==&lt;/code&gt;, the failure report will include the left
 * and right values. For example, the detail message in the thrown &lt;code&gt;TestFailedException&lt;/code&gt; from the &lt;code&gt;assert&lt;/code&gt;
 * shown previously will include, &quot;2 did not equal 1&quot;.
 * From this message you will know that the operand on the left had the value 2, and the operand on the right had the value 1.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * If you're familiar with JUnit, you would use &lt;code&gt;===&lt;/code&gt;
 * in a ScalaTest &lt;code&gt;Suite&lt;/code&gt; where you'd use &lt;code&gt;assertEquals&lt;/code&gt; in a JUnit &lt;code&gt;TestCase&lt;/code&gt;.
 * The &lt;code&gt;===&lt;/code&gt; operator is made possible by an implicit conversion from &lt;code&gt;Any&lt;/code&gt;
 * to &lt;code&gt;Equalizer&lt;/code&gt;. If you're curious to understand the mechanics, see the &lt;a href=&quot;Assertions$Equalizer.html&quot;&gt;documentation for
 * &lt;code&gt;Equalizer&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;convertToEqualizer&lt;/code&gt; method.
 * &lt;/p&gt;
 *
 * &lt;h2&gt;Expected results&lt;/h2&gt;
 *
 * Although &lt;code&gt;===&lt;/code&gt; provides a natural, readable extension to Scala's &lt;code&gt;assert&lt;/code&gt; mechanism,
 * as the operands become lengthy, the code becomes less readable. In addition, the &lt;code&gt;===&lt;/code&gt; comparison
 * doesn't distinguish between actual and expected values. The operands are just called &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;,
 * because if one were named &lt;code&gt;expected&lt;/code&gt; and the other &lt;code&gt;actual&lt;/code&gt;, it would be difficult for people to
 * remember which was which. To help with these limitations of assertions, &lt;code&gt;Suite&lt;/code&gt; includes a method called &lt;code&gt;expect&lt;/code&gt; that
 * can be used as an alternative to &lt;code&gt;assert&lt;/code&gt; with &lt;code&gt;===&lt;/code&gt;. To use &lt;code&gt;expect&lt;/code&gt;, you place
 * the expected value in parentheses after &lt;code&gt;expect&lt;/code&gt;, followed by curly braces containing code 
 * that should result in the expected value. For example:
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * val a = 5
 * val b = 2
 * expect(2) {
 *   a - b
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * In this case, the expected value is &lt;code&gt;2&lt;/code&gt;, and the code being tested is &lt;code&gt;a - b&lt;/code&gt;. This expectation will fail, and
 * the detail message in the &lt;code&gt;TestFailedException&lt;/code&gt; will read, &quot;Expected 2, but got 3.&quot;
 * &lt;/p&gt;
 *
 * &lt;h2&gt;Intercepted exceptions&lt;/h2&gt;
 *
 * &lt;p&gt;
 * Sometimes you need to test whether a method throws an expected exception under certain circumstances, such
 * as when invalid arguments are passed to the method. You can do this in the JUnit 3 style, like this:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * val s = &quot;hi&quot;
 * try {
 *   s.charAt(-1)
 *   fail()
 * }
 * catch {
 *   case _: IndexOutOfBoundsException =&gt; // Expected, so continue
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * If &lt;code&gt;charAt&lt;/code&gt; throws &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; as expected, control will transfer
 * to the catch case, which does nothing. If, however, &lt;code&gt;charAt&lt;/code&gt; fails to throw an exception,
 * the next statement, &lt;code&gt;fail()&lt;/code&gt;, will be run. The &lt;code&gt;fail&lt;/code&gt; method always completes abruptly with
 * a &lt;code&gt;TestFailedException&lt;/code&gt;, thereby signaling a failed test.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * To make this common use case easier to express and read, ScalaTest provides an &lt;code&gt;intercept&lt;/code&gt;
 * method. You use it like this:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * val s = &quot;hi&quot;
 * intercept[IndexOutOfBoundsException] {
 *   s.charAt(-1)
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * This code behaves much like the previous example. If &lt;code&gt;charAt&lt;/code&gt; throws an instance of &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;,
 * &lt;code&gt;intercept&lt;/code&gt; will return that exception. But if &lt;code&gt;charAt&lt;/code&gt; completes normally, or throws a different
 * exception, &lt;code&gt;intercept&lt;/code&gt; will complete abruptly with a &lt;code&gt;TestFailedException&lt;/code&gt;. &lt;code&gt;intercept&lt;/code&gt; returns the
 * caught exception so that you can inspect it further if you wish, for example, to ensure that data contained inside
 * the exception has the expected values.
 * &lt;/p&gt;
 *
 * &lt;h2&gt;Getting a clue&lt;/h2&gt;
 *
 * &lt;p&gt;
 * If you want more information that is provided by default by the methods if this trait,
 * you can supply a &quot;clue&quot; string in one of several ways.
 * The extra information (or &quot;clues&quot;) you provide will
 * be included in the detail message of the thrown exception. Both
 * &lt;code&gt;assert&lt;/code&gt; and &lt;code&gt;expect&lt;/code&gt; provide a way for a clue to be
 * included directly, &lt;code&gt;intercept&lt;/code&gt; does not.
 * Here's an example of clues provided directly in &lt;code&gt;assert&lt;/code&gt;:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * assert(1 + 1 === 3, &quot;this is a clue&quot;)
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * and in &lt;code&gt;expect&lt;/code&gt;:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * expect(3, &quot;this is a clue&quot;) { 1 + 1 }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * The exceptions thrown by the previous two statements will include the clue
 * string, &lt;code&gt;&quot;this is a clue&quot;&lt;/code&gt;, in the exception's detail message.
 * To get the same clue in the detail message of an exception thrown
 * by a failed &lt;code&gt;intercept&lt;/code&gt; call requires using &lt;code&gt;withClue&lt;/code&gt;:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * withClue(&quot;this is a clue&quot;) {
 *   intercept[IndexOutOfBoundsException] {
 *     &quot;hi&quot;.charAt(-1)
 *   }
 * }
 * &lt;/pre&gt;
 *
 * The &lt;code&gt;withClue&lt;/code&gt; method will only prepend the clue string to the detail
 * message of exception types that mix in the &lt;code&gt;ModifiableMessage&lt;/code&gt; trait.
 * See the documentation for &lt;a href=&quot;ModifiableMessage.html&quot;&gt;&lt;code&gt;ModifiableMessage&lt;/code&gt;&lt;/a&gt; for more information.
 *
 * @author Bill Venners
 */</span>
<span class="keyword">trait</span> <a title="trait Assertions extends java.lang.Object with ScalaObject" id="10094">Assertions</a> <span title="ScalaObject" class="delimiter">{</span>

  <span class="comment">/**
   * Class used via an implicit conversion to enable any two objects to be compared with
   * &lt;code&gt;===&lt;/code&gt; in assertions in tests. For example:
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * assert(a === b)
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * The benefit of using &lt;code&gt;assert(a === b)&lt;/code&gt; rather than &lt;code&gt;assert(a == b)&lt;/code&gt; is
   * that a &lt;code&gt;TestFailedException&lt;/code&gt; produced by the former will include the values of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;
   * in its detail message.
   * The implicit method that performs the conversion from &lt;code&gt;Any&lt;/code&gt; to &lt;code&gt;Equalizer&lt;/code&gt; is
   * &lt;code&gt;convertToEqualizer&lt;/code&gt; in trait &lt;code&gt;Assertions&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * &lt;p&gt;
   * In case you're not familiar with how implicit conversions work in Scala, here's a quick explanation.
   * The &lt;code&gt;convertToEqualizer&lt;/code&gt; method in &lt;code&gt;Assertions&lt;/code&gt; is defined as an &quot;implicit&quot; method that takes an
   * &lt;code&gt;Any&lt;/code&gt;, which means you can pass in any object, and it will convert it to an &lt;code&gt;Equalizer&lt;/code&gt;.
   * The &lt;code&gt;Equalizer&lt;/code&gt; has &lt;code&gt;===&lt;/code&gt; defined. Most objects don't have &lt;code&gt;===&lt;/code&gt; defined as a method
   * on them. Take two Strings, for example:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * assert(&quot;hello&quot; === &quot;world&quot;)
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * Given this code, the Scala compiler looks for an &lt;code&gt;===&lt;/code&gt; method on class &lt;code&gt;String&lt;/code&gt;, because that's the class of
   * &lt;code&gt;&quot;hello&quot;&lt;/code&gt;. &lt;code&gt;String&lt;/code&gt; doesn't define &lt;code&gt;===&lt;/code&gt;, so the compiler looks for an implicit conversion from
   * &lt;code&gt;String&lt;/code&gt; to something that does have an &lt;code&gt;===&lt;/code&gt; method, and it finds the &lt;code&gt;convertToEqualizer&lt;/code&gt; method. It
   * then rewrites the code to this:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * assert(convertToEqualizer(&quot;hello&quot;).===(&quot;world&quot;))
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * So inside a &lt;code&gt;Suite&lt;/code&gt; (which mixes in &lt;code&gt;Assertions&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt; will work on anything. The only
   * situation in which the implicit conversion wouldn't 
   * happen is on types that have an &lt;code&gt;===&lt;/code&gt; method already defined.
   * &lt;/p&gt;
   * 
   * &lt;p&gt;
   * The primary constructor takes one object, &lt;code&gt;left&lt;/code&gt;, whose type is being converted to &lt;code&gt;Equalizer&lt;/code&gt;. The &lt;code&gt;left&lt;/code&gt;
   * value may be a &lt;code&gt;null&lt;/code&gt; reference, because this is allowed by Scala's &lt;code&gt;==&lt;/code&gt; operator.
   * &lt;/p&gt;
   *
   * @param left An object to convert to &lt;code&gt;Equalizer&lt;/code&gt;, which represents the &lt;code&gt;left&lt;/code&gt; value
   *     of an assertion.
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Equalizer extends java.lang.Object with ScalaObject" id="15636">Equalizer</a><a href="#15636" title="ScalaObject" class="delimiter">(</a><a title="Any" id="19661">left</a>: <span title="Any">Any</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * The &lt;code&gt;===&lt;/code&gt; operation compares this &lt;code&gt;Equalizer&lt;/code&gt;'s &lt;code&gt;left&lt;/code&gt; value (passed
     * to the constructor, usually via an implicit conversion) with the passed &lt;code&gt;right&lt;/code&gt; value 
     * for equality as determined by the expression &lt;code&gt;left == right&lt;/code&gt;.
     * If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;. Else, &lt;code&gt;===&lt;/code&gt; returns
     * a &lt;code&gt;Some&lt;/code&gt; whose &lt;code&gt;String&lt;/code&gt; value indicates the &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; values.
     *
     * &lt;p&gt;
     * In its typical usage, the &lt;code&gt;Option[String]&lt;/code&gt; returned by &lt;code&gt;===&lt;/code&gt; will be passed to one of two
     * of trait &lt;code&gt;Assertion&lt;/code&gt;' overloaded &lt;code&gt;assert&lt;/code&gt; methods. If &lt;code&gt;None&lt;/code&gt;,
     * which indicates the assertion succeeded, &lt;code&gt;assert&lt;/code&gt; will return normally. But if &lt;code&gt;Some&lt;/code&gt; is passed,
     * which indicates the assertion failed, &lt;code&gt;assert&lt;/code&gt; will throw a &lt;code&gt;TestFailedException&lt;/code&gt; whose detail
     * message will include the &lt;code&gt;String&lt;/code&gt; contained inside the &lt;code&gt;Some&lt;/code&gt;, which in turn includes the
     * &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; values. This &lt;code&gt;TestFailedException&lt;/code&gt; is typically embedded in a 
     * &lt;code&gt;Report&lt;/code&gt; and passed to a &lt;code&gt;Reporter&lt;/code&gt;, which can present the &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;
     * values to the user.
     * &lt;/p&gt;
     */</span>
    <span class="keyword">def</span> <a title="(right: Any)Option[String]" id="19658">===</a><span class="delimiter">(</span><a title="Any" id="20250">right</a>: <span title="Any">Any</span><span class="delimiter">)</span> =
      <span title="Option[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#19652" title="(left: Any, right: Any)Boolean">areEqualComparingArraysStructurally</a><span class="delimiter">(</span><a href="#19661" title="Any">left</a>, <a href="#20250" title="Any">right</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span title="object None">None</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a href="#27192" title="(Any, Any)" class="delimiter">(</a><a href="#27191" title="Any" id="27192">leftee</a>, <a href="#27191" title="Any" id="27193">rightee</a><span class="delimiter">)</span> = <a href="Suite.scala.html#10074" title="object org.scalatest.Suite">Suite</a>.<a href="Suite.scala.html#27206" title="(a: Any, b: Any)(Any, Any)">getObjectsForFailureMessage</a><span title="(Any, Any) @unchecked" class="delimiter">(</span><a href="#19661" title="Any">left</a>, <a href="#20250" title="Any">right</a><span class="delimiter">)</span>
        <span title="(x: String)Some[String]">Some</span><span class="delimiter">(</span><a href="FailureMessages.scala.html#27314" title="(resourceName: String, args: Any*)String">FailureMessages</a><span class="delimiter">(</span><span title="java.lang.String(&quot;didNotEqual&quot;)" class="string">&quot;didNotEqual&quot;</span>, <a href="#27192" title="Any">leftee</a>, <a href="#27193" title="Any">rightee</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
<span class="comment">/*
    def !==(right: Any) =
      if (left != right)
        None
      else {
        val (leftee, rightee) = Suite.getObjectsForFailureMessage(left, right)
        Some(FailureMessages(&quot;equaled&quot;, leftee, rightee))
      }
*/</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Assert that a boolean condition is true.
   * If the condition is &lt;code&gt;true&lt;/code&gt;, this method returns normally.
   * Else, it throws &lt;code&gt;TestFailedException&lt;/code&gt;.
   *
   * @param condition the boolean condition to assert
   * @throws TestFailedException if the condition is &lt;code&gt;false&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <a title="(condition: Boolean)Unit" id="15637">assert</a><span class="delimiter">(</span><a title="Boolean" id="27373">condition</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#27373" title="Boolean">condition</a><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <a href="#15638" title="(optionalMessage: Option[Any], optionalCause: Option[Throwable], stackDepth: Int)Throwable">newAssertionFailedException</a><span class="delimiter">(</span><span title="object None">None</span>, <span title="object None">None</span>, <span title="Int(4)" class="int">4</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span>scalatest<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(optionalMessage: Option[Any], optionalCause: Option[Throwable], stackDepth: Int)Throwable" id="15638">newAssertionFailedException</a><span class="delimiter">(</span><a title="Option[Any]" id="27375">optionalMessage</a>: <span title="Option[Any]">Option</span><span class="delimiter">[</span>Any<span class="delimiter">]</span>, <a title="Option[Throwable]" id="27376">optionalCause</a>: <span title="Option[Throwable]">Option</span><span class="delimiter">[</span>Throwable<span class="delimiter">]</span>, <a title="Int" id="27377">stackDepth</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Throwable">Throwable</span> =
    <span title="(_1: Option[Any], _2: Option[Throwable])(Option[Any], Option[Throwable])" class="delimiter">(</span><a href="#27375" title="Option[Any]">optionalMessage</a>, <a href="#27376" title="Option[Throwable]">optionalCause</a><span class="delimiter">)</span> <span title="Throwable" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="org.scalatest.TestFailedException" class="delimiter">(</span><span title="object None">None</span>, <span title="object None">None</span><span class="delimiter">)</span> =&gt; <a href="TestFailedException.scala.html#27425" title="(failedCodeStackDepth: Int)org.scalatest.TestFailedException" class="keyword">new</a> <a href="TestFailedException.scala.html#10052" title="org.scalatest.TestFailedException">TestFailedException</a><span class="delimiter">(</span><a href="#27377" title="Int">stackDepth</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="org.scalatest.TestFailedException" class="delimiter">(</span><span title="object None">None</span>, Some<span class="delimiter">(</span><a title="Throwable" id="27474">cause</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="TestFailedException.scala.html#27427" title="(cause: Throwable, failedCodeStackDepth: Int)org.scalatest.TestFailedException" class="keyword">new</a> <a href="TestFailedException.scala.html#10052" title="org.scalatest.TestFailedException">TestFailedException</a><span class="delimiter">(</span><a href="#27474" title="Throwable">cause</a>, <a href="#27377" title="Int">stackDepth</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="org.scalatest.TestFailedException" class="delimiter">(</span>Some<span class="delimiter">(</span><a title="Any" id="27483">message</a><span class="delimiter">)</span>, <span title="object None">None</span><span class="delimiter">)</span> =&gt; <a href="TestFailedException.scala.html#27426" title="(message: String, failedCodeStackDepth: Int)org.scalatest.TestFailedException" class="keyword">new</a> <a href="TestFailedException.scala.html#10052" title="org.scalatest.TestFailedException">TestFailedException</a><span class="delimiter">(</span><a href="#27483" title="Any">message</a>.<span title="()java.lang.String">toString</span>, <a href="#27377" title="Int">stackDepth</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="org.scalatest.TestFailedException" class="delimiter">(</span>Some<span class="delimiter">(</span><a title="Any" id="27491">message</a><span class="delimiter">)</span>, Some<span class="delimiter">(</span><a title="Throwable" id="27493">cause</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="TestFailedException.scala.html#27428" title="(message: String, cause: Throwable, failedCodeStackDepth: Int)org.scalatest.TestFailedException" class="keyword">new</a> <a href="TestFailedException.scala.html#10052" title="org.scalatest.TestFailedException">TestFailedException</a><span class="delimiter">(</span><a href="#27491" title="Any">message</a>.<span title="()java.lang.String">toString</span>, <a href="#27493" title="Throwable">cause</a>, <a href="#27377" title="Int">stackDepth</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Assert that a boolean condition, described in &lt;code&gt;String&lt;/code&gt;
   * &lt;code&gt;message&lt;/code&gt;, is true.
   * If the condition is &lt;code&gt;true&lt;/code&gt;, this method returns normally.
   * Else, it throws &lt;code&gt;TestFailedException&lt;/code&gt; with the
   * &lt;code&gt;String&lt;/code&gt; obtained by invoking &lt;code&gt;toString&lt;/code&gt; on the
   * specified &lt;code&gt;message&lt;/code&gt; as the exception's detail message.
   *
   * @param condition the boolean condition to assert
   * @param clue An objects whose &lt;code&gt;toString&lt;/code&gt; method returns a message to include in a failure report.
   * @throws TestFailedException if the condition is &lt;code&gt;false&lt;/code&gt;.
   * @throws NullPointerException if &lt;code&gt;message&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <a title="(condition: Boolean, clue: Any)Unit" id="15639">assert</a><span class="delimiter">(</span><a title="Boolean" id="27498">condition</a>: <span title="Boolean">Boolean</span>, <a title="Any" id="27499">clue</a>: <span title="Any">Any</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#27498" title="Boolean">condition</a><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <a href="#15638" title="(optionalMessage: Option[Any], optionalCause: Option[Throwable], stackDepth: Int)Throwable">newAssertionFailedException</a><span class="delimiter">(</span><span title="(x: Any)Some[Any]">Some</span><span class="delimiter">(</span><a href="#27499" title="Any">clue</a><span class="delimiter">)</span>, <span title="object None">None</span>, <span title="Int(4)" class="int">4</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Assert that an &lt;code&gt;Option[String]&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;. 
   * If the condition is &lt;code&gt;None&lt;/code&gt;, this method returns normally.
   * Else, it throws &lt;code&gt;TestFailedException&lt;/code&gt; with the &lt;code&gt;String&lt;/code&gt;
   * value of the &lt;code&gt;Some&lt;/code&gt;, as well as the 
   * &lt;code&gt;String&lt;/code&gt; obtained by invoking &lt;code&gt;toString&lt;/code&gt; on the
   * specified &lt;code&gt;message&lt;/code&gt;,
   * included in the &lt;code&gt;TestFailedException&lt;/code&gt;'s detail message.
   *
   * &lt;p&gt;
   * This form of &lt;code&gt;assert&lt;/code&gt; is usually called in conjunction with an
   * implicit conversion to &lt;code&gt;Equalizer&lt;/code&gt;, using a &lt;code&gt;===&lt;/code&gt; comparison, as in:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * assert(a === b, &quot;extra info reported if assertion fails&quot;)
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * For more information on how this mechanism works, see the &lt;a href=&quot;Suite.Equalizer.html&quot;&gt;documentation for
   * &lt;code&gt;Equalizer&lt;/code&gt;&lt;/a&gt;.
   * &lt;/p&gt;
   *
   * @param o the &lt;code&gt;Option[String]&lt;/code&gt; to assert
   * @param clue An objects whose &lt;code&gt;toString&lt;/code&gt; method returns a message to include in a failure report.
   * @throws TestFailedException if the &lt;code&gt;Option[String]&lt;/code&gt; is &lt;code&gt;Some&lt;/code&gt;.
   * @throws NullPointerException if &lt;code&gt;message&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <a title="(o: Option[String], clue: Any)Unit" id="15640">assert</a><span class="delimiter">(</span><a title="Option[String]" id="27504">o</a>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Any" id="27505">clue</a>: <span title="Any">Any</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#27504" title="Option[String]">o</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Nothing">Some</span><span class="delimiter">(</span><a title="String" id="27508">s</a><span class="delimiter">)</span> =&gt; <span title="Nothing" class="keyword">throw</span> <a href="#15638" title="(optionalMessage: Option[Any], optionalCause: Option[Throwable], stackDepth: Int)Throwable">newAssertionFailedException</a><span class="delimiter">(</span><span title="(x: java.lang.String)Some[java.lang.String]">Some</span><span class="delimiter">(</span><a href="#27505" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">clue</a> <span title="(other: String)java.lang.String">+</span> <span title="java.lang.String(&quot;\012&quot;)" class="string">&quot;\n&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#27508" title="String">s</a><span class="delimiter">)</span>, <span title="object None">None</span>, <span title="Int(4)" class="int">4</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Unit">None</span> =&gt;
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Assert that an &lt;code&gt;Option[String]&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;.
   * If the condition is &lt;code&gt;None&lt;/code&gt;, this method returns normally.
   * Else, it throws &lt;code&gt;TestFailedException&lt;/code&gt; with the &lt;code&gt;String&lt;/code&gt;
   * value of the &lt;code&gt;Some&lt;/code&gt; included in the &lt;code&gt;TestFailedException&lt;/code&gt;'s
   * detail message.
   *
   * &lt;p&gt;
   * This form of &lt;code&gt;assert&lt;/code&gt; is usually called in conjunction with an
   * implicit conversion to &lt;code&gt;Equalizer&lt;/code&gt;, using a &lt;code&gt;===&lt;/code&gt; comparison, as in:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * assert(a === b)
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * For more information on how this mechanism works, see the &lt;a href=&quot;Suite.Equalizer.html&quot;&gt;documentation for
   * &lt;code&gt;Equalizer&lt;/code&gt;&lt;/a&gt;.
   * &lt;/p&gt;
   *
   * @param o the &lt;code&gt;Option[String]&lt;/code&gt; to assert
   * @throws TestFailedException if the &lt;code&gt;Option[String]&lt;/code&gt; is &lt;code&gt;Some&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <a title="(o: Option[String])Unit" id="15641">assert</a><span class="delimiter">(</span><a title="Option[String]" id="27516">o</a>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="#27516" title="Option[String]">o</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Nothing">Some</span><span class="delimiter">(</span><a title="String" id="27519">s</a><span class="delimiter">)</span> =&gt; <span title="Nothing" class="keyword">throw</span> <a href="#15638" title="(optionalMessage: Option[Any], optionalCause: Option[Throwable], stackDepth: Int)Throwable">newAssertionFailedException</a><span class="delimiter">(</span><span title="(x: String)Some[String]">Some</span><span class="delimiter">(</span><a href="#27519" title="String">s</a><span class="delimiter">)</span>, <span title="object None">None</span>, <span title="Int(4)" class="int">4</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Unit">None</span> =&gt;
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Implicit conversion from &lt;code&gt;Any&lt;/code&gt; to &lt;code&gt;Equalizer&lt;/code&gt;, used to enable
   * assertions with &lt;code&gt;===&lt;/code&gt; comparisons.
   *
   * &lt;p&gt;
   * For more information
   * on this mechanism, see the &lt;a href=&quot;Suite.Equalizer.html&quot;&gt;documentation for &lt;/code&gt;Equalizer&lt;/code&gt;&lt;/a&gt;.
   * &lt;/p&gt;
   *
   * &lt;p&gt;
   * Because trait &lt;code&gt;Suite&lt;/code&gt; mixes in &lt;code&gt;Assertions&lt;/code&gt;, this implicit conversion will always be
   * available by default in ScalaTest &lt;code&gt;Suite&lt;/code&gt;s. This is the only implicit conversion that is in scope by default in every
   * ScalaTest &lt;code&gt;Suite&lt;/code&gt;. Other implicit conversions offered by ScalaTest, such as those that support the matchers DSL
   * or &lt;code&gt;invokePrivate&lt;/code&gt;, must be explicitly invited into your test code, either by mixing in a trait or importing the
   * members of its companion object. The reason ScalaTest requires you to invite in implicit conversions (with the exception of the
   * implicit conversion for &lt;code&gt;===&lt;/code&gt; operator)  is because if one of ScalaTest's implicit conversions clashes with an
   * implicit conversion used in the code you are trying to test, your program won't compile. Thus there is a chance that if you
   * are ever trying to use a library or test some code that also offers an implicit conversion involving a &lt;code&gt;===&lt;/code&gt; operator,
   * you could run into the problem of a compiler error due to an ambiguous implicit conversion. If that happens, you can turn off
   * the implicit conversion offered by this &lt;code&gt;convertToEqualizer&lt;/code&gt; method simply by overriding the method in your
   * &lt;code&gt;Suite&lt;/code&gt; subclass, but not marking it as implicit:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * // In your Suite subclass
   * override def convertToEqualizer(left: Any) = new Equalizer(left)
   * &lt;/pre&gt;
   * 
   * @param left the object whose type to convert to &lt;code&gt;Equalizer&lt;/code&gt;.
   * @throws NullPointerException if &lt;code&gt;left&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit org.scalatest.Assertions.convertToEqualizer : (left: Any)Assertions.this.Equalizer" id="15642">convertToEqualizer</a><span class="delimiter">(</span><a title="Any" id="20264">left</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <span title="Assertions.this.Equalizer" class="keyword">new</span> <a href="#15636" title="Assertions.this.Equalizer">Equalizer</a><span class="delimiter">(</span><a href="#20264" title="Any">left</a><span class="delimiter">)</span>

  <span class="comment">/*
   * Intercept and return an instance of the passed exception class (or an instance of a subclass of the
   * passed class), which is expected to be thrown by the passed function value. This method invokes the passed
   * function. If it throws an exception that's an instance of the passed class or one of its
   * subclasses, this method returns that exception. Else, whether the passed function returns normally
   * or completes abruptly with a different exception, this method throws &lt;code&gt;TestFailedException&lt;/code&gt;
   * whose detail message includes the &lt;code&gt;String&lt;/code&gt; obtained by invoking &lt;code&gt;toString&lt;/code&gt; on the passed &lt;code&gt;message&lt;/code&gt;.
   *
   * &lt;p&gt;
   * Note that the passed &lt;code&gt;Class&lt;/code&gt; may represent any type, not just &lt;code&gt;Throwable&lt;/code&gt; or one of its subclasses. In
   * Scala, exceptions can be caught based on traits they implement, so it may at times make sense to pass in a class instance for
   * a trait. If a class instance is passed for a type that could not possibly be used to catch an exception (such as &lt;code&gt;String&lt;/code&gt;,
   * for example), this method will complete abruptly with a &lt;code&gt;TestFailedException&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * @param message An object whose &lt;code&gt;toString&lt;/code&gt; method returns a message to include in a failure report.
   * @param f the function value that should throw the expected exception
   * @return the intercepted exception, if it is of the expected type
   * @throws TestFailedException if the passed function does not result in a value equal to the
   *     passed &lt;code&gt;expected&lt;/code&gt; value.
  def intercept[T &lt;: AnyRef](message: Any)(f: =&gt; Any)(implicit manifest: Manifest[T]): T = {
    val clazz = manifest.erasure.asInstanceOf[Class[T]]
    val messagePrefix = if (message.toString.trim.isEmpty) &quot;&quot; else (message +&quot;\n&quot;)
    val caught = try {
      f
      None
    }
    catch {
      case u: Throwable =&gt; {
        if (!clazz.isAssignableFrom(u.getClass)) {
          val s = Resources(&quot;wrongException&quot;, clazz.getName, u.getClass.getName)
          throw newAssertionFailedException(Some(messagePrefix + s), Some(u), 4)
        }
        else {
          Some(u)
        }
      }
    }
    caught match {
      case None =&gt;
        val message = messagePrefix + Resources(&quot;exceptionExpected&quot;, clazz.getName)
        throw newAssertionFailedException(Some(message), None, 4)
      case Some(e) =&gt; e.asInstanceOf[T] // I know this cast will succeed, becuase iSAssignableFrom succeeded above
    }
  }
THIS DOESN'T OVERLOAD. I THINK I'LL EITHER NEED TO USE interceptWithMessage OR JUST LEAVE IT OUT. FOR NOW I'LL LEAVE IT OUT.
   */</span>

  <span class="comment">/**
   * Intercept and return an exception that's expected to
   * be thrown by the passed function value. The thrown exception must be an instance of the
   * type specified by the type parameter of this method. This method invokes the passed
   * function. If the function throws an exception that's an instance of the specified type,
   * this method returns that exception. Else, whether the passed function returns normally
   * or completes abruptly with a different exception, this method throws &lt;code&gt;TestFailedException&lt;/code&gt;.
   *
   * &lt;p&gt;
   * Note that the type specified as this method's type parameter may represent any subtype of
   * &lt;code&gt;AnyRef&lt;/code&gt;, not just &lt;code&gt;Throwable&lt;/code&gt; or one of its subclasses. In
   * Scala, exceptions can be caught based on traits they implement, so it may at times make sense
   * to specify a trait that the intercepted exception's class must mix in. If a class instance is
   * passed for a type that could not possibly be used to catch an exception (such as &lt;code&gt;String&lt;/code&gt;,
   * for example), this method will complete abruptly with a &lt;code&gt;TestFailedException&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * @param f the function value that should throw the expected exception
   * @param manifest an implicit &lt;code&gt;Manifest&lt;/code&gt; representing the type of the specified
   * type parameter.
   * @return the intercepted exception, if it is of the expected type
   * @throws TestFailedException if the passed function does not complete abruptly with an exception
   *    that's an instance of the specified type
   *     passed &lt;code&gt;expected&lt;/code&gt; value.
   */</span>
  <span class="keyword">def</span> <a title="[T &lt;: AnyRef](f: =&gt; Any)(implicit manifest: scala.reflect.Manifest[T])T" id="15643">intercept</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef" id="15645">T</a> &lt;: AnyRef<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Any" id="27523">f</a>: =&gt; Any<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scala.reflect.Manifest[T]" id="27524">manifest</a>: <span title="scala.reflect.Manifest[T]">Manifest</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#15645" title="T">T</a> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Class[T]" id="27643">clazz</a> = <a href="#27524" title="scala.reflect.Manifest[T]">manifest</a>.<span title="=&gt; java.lang.Class[_]">erasure</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Class[T]" class="delimiter">[</span><span title="Class[T]">Class</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
    <span class="keyword">val</span> <a title="Option[java.lang.Throwable]" id="27644">caught</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
      <a href="#27523" title="=&gt; Any">f</a>
      <span title="object None">None</span>
    <span class="delimiter">}</span>
    <span class="keyword">catch</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Some[java.lang.Throwable]" id="27785">u</a>: <span title="Throwable">Throwable</span> =&gt; <span class="delimiter">{</span>
        <span title="Some[java.lang.Throwable]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#27643" title="Class[T]">clazz</a>.<span title="(x$1: java.lang.Class[_])Boolean">isAssignableFrom</span><span class="delimiter">(</span><a href="#27785" title="java.lang.Throwable">u</a>.<span title="()java.lang.Class[_]">getClass</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="String" id="27789">s</a> = <a href="Resources.scala.html#27793" title="(resourceName: String, o1: AnyRef*)String">Resources</a><span class="delimiter">(</span><span title="java.lang.String(&quot;wrongException&quot;)" class="string">&quot;wrongException&quot;</span>, <a href="#27643" title="Class[T]">clazz</a>.<span title="()java.lang.String">getName</span>, <a href="#27785" title="java.lang.Throwable">u</a>.<span title="()java.lang.Class[_]">getClass</span>.<span title="()java.lang.String">getName</span><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <a href="#15638" title="(optionalMessage: Option[Any], optionalCause: Option[Throwable], stackDepth: Int)Throwable">newAssertionFailedException</a><span class="delimiter">(</span><span title="(x: String)Some[String]">Some</span><span class="delimiter">(</span><a href="#27789" title="String">s</a><span class="delimiter">)</span>, <span title="(x: java.lang.Throwable)Some[java.lang.Throwable]">Some</span><span class="delimiter">(</span><a href="#27785" title="java.lang.Throwable">u</a><span class="delimiter">)</span>, <span title="Int(4)" class="int">4</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span title="(x: java.lang.Throwable)Some[java.lang.Throwable]">Some</span><span class="delimiter">(</span><a href="#27785" title="java.lang.Throwable">u</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#27644" title="Option[java.lang.Throwable]">caught</a> <span title="T" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Nothing">None</span> =&gt;
        <span class="keyword">val</span> <a title="String" id="27828">message</a> = <a href="Resources.scala.html#27793" title="(resourceName: String, o1: AnyRef*)String">Resources</a><span class="delimiter">(</span><span title="java.lang.String(&quot;exceptionExpected&quot;)" class="string">&quot;exceptionExpected&quot;</span>, <a href="#27643" title="Class[T]">clazz</a>.<span title="()java.lang.String">getName</span><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">throw</span> <a href="#15638" title="(optionalMessage: Option[Any], optionalCause: Option[Throwable], stackDepth: Int)Throwable">newAssertionFailedException</a><span class="delimiter">(</span><span title="(x: String)Some[String]">Some</span><span class="delimiter">(</span><a href="#27828" title="String">message</a><span class="delimiter">)</span>, <span title="object None">None</span>, <span title="Int(4)" class="int">4</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="T">Some</span><span class="delimiter">(</span><a title="java.lang.Throwable" id="27839">e</a><span class="delimiter">)</span> =&gt; <a href="#27839" title="java.lang.Throwable">e</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#15645" title="T">T</a><span class="delimiter">]</span> <span class="comment">// I know this cast will succeed, becuase iSAssignableFrom succeeded above</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/*
   * Intercept and return an instance of the passed exception class (or an instance of a subclass of the
   * passed class), which is expected to be thrown by the passed function value. This method invokes the passed
   * function. If it throws an exception that's an instance of the passed class or one of its
   * subclasses, this method returns that exception. Else, whether the passed function returns normally
   * or completes abruptly with a different exception, this method throws &lt;code&gt;TestFailedException&lt;/code&gt;.
   *
   * &lt;p&gt;
   * Note that the passed &lt;code&gt;Class&lt;/code&gt; may represent any type, not just &lt;code&gt;Throwable&lt;/code&gt; or one of its subclasses. In
   * Scala, exceptions can be caught based on traits they implement, so it may at times make sense to pass in a class instance for
   * a trait. If a class instance is passed for a type that could not possibly be used to catch an exception (such as &lt;code&gt;String&lt;/code&gt;,
   * for example), this method will complete abruptly with a &lt;code&gt;TestFailedException&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * @param clazz a type to which the expected exception class is assignable, i.e., the exception should be an instance of the type represented by &lt;code&gt;clazz&lt;/code&gt;.
   * @param f the function value that should throw the expected exception
   * @return the intercepted exception, if 
   * @throws TestFailedException if the passed function does not complete abruptly with an exception that is assignable to the 
   *     passed &lt;code&gt;Class&lt;/code&gt;.
   * @throws IllegalArgumentException if the passed &lt;code&gt;clazz&lt;/code&gt; is not &lt;code&gt;Throwable&lt;/code&gt; or
   *     one of its subclasses.
   */</span>

<span class="comment">/*
  def intercept[T &lt;: AnyRef](clazz: java.lang.Class[T])(f: =&gt; Unit): T = {
    // intercept(clazz)(f)(manifest)
    &quot;hi&quot;.asInstanceOf[T]
  }
*/</span>
<span class="comment">/*
  def intercept[T &lt;: AnyRef](clazz: java.lang.Class[T])(f: =&gt; Unit)(implicit manifest: Manifest[T]): T = {
    intercept(clazz)(f)(manifest)
  }
*/</span>


  <span class="comment">/**
   * Expect that the value passed as &lt;code&gt;expected&lt;/code&gt; equals the value passed as &lt;code&gt;actual&lt;/code&gt;.
   * If the &lt;code&gt;actual&lt;/code&gt; equals the &lt;code&gt;expected&lt;/code&gt;
   * (as determined by &lt;code&gt;==&lt;/code&gt;), &lt;code&gt;expect&lt;/code&gt; returns
   * normally. Else, if &lt;code&gt;actual&lt;/code&gt; is not equal to &lt;code&gt;expected&lt;/code&gt;, &lt;code&gt;expect&lt;/code&gt; throws an
   * &lt;code&gt;TestFailedException&lt;/code&gt; whose detail message includes the expected and actual values, as well as the &lt;code&gt;String&lt;/code&gt;
   * obtained by invoking &lt;code&gt;toString&lt;/code&gt; on the passed &lt;code&gt;message&lt;/code&gt;.
   *
   * @param expected the expected value
   * @param clue An object whose &lt;code&gt;toString&lt;/code&gt; method returns a message to include in a failure report.
   * @param actual the actual value, which should equal the passed &lt;code&gt;expected&lt;/code&gt; value
   * @throws TestFailedException if the passed &lt;code&gt;actual&lt;/code&gt; value does not equal the passed &lt;code&gt;expected&lt;/code&gt; value.
   */</span>
  <span class="keyword">def</span> <a title="(expected: Any, clue: Any)(actual: Any)Unit" id="15646">expect</a><span class="delimiter">(</span><a title="Any" id="27840">expected</a>: <span title="Any">Any</span>, <a title="Any" id="27841">clue</a>: <span title="Any">Any</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Any" id="27842">actual</a>: <span title="Any">Any</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#27842" title="Any">actual</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#27840" title="Any">expected</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#27845" title="(Any, Any)" class="delimiter">(</a><a href="#27844" title="Any" id="27845">act</a>, <a href="#27844" title="Any" id="27846">exp</a><span class="delimiter">)</span> = <a href="Suite.scala.html#10074" title="object org.scalatest.Suite">Suite</a>.<a href="Suite.scala.html#27206" title="(a: Any, b: Any)(Any, Any)">getObjectsForFailureMessage</a><span title="(Any, Any) @unchecked" class="delimiter">(</span><a href="#27842" title="Any">actual</a>, <a href="#27840" title="Any">expected</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="String" id="27847">s</a> = <a href="FailureMessages.scala.html#27314" title="(resourceName: String, args: Any*)String">FailureMessages</a><span class="delimiter">(</span><span title="java.lang.String(&quot;expectedButGot&quot;)" class="string">&quot;expectedButGot&quot;</span>, <a href="#27846" title="Any">exp</a>, <a href="#27845" title="Any">act</a><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <a href="#15638" title="(optionalMessage: Option[Any], optionalCause: Option[Throwable], stackDepth: Int)Throwable">newAssertionFailedException</a><span class="delimiter">(</span><span title="(x: java.lang.String)Some[java.lang.String]">Some</span><span class="delimiter">(</span><a href="#27841" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">clue</a> <span title="(other: String)java.lang.String">+</span> <span title="java.lang.String(&quot;\012&quot;)" class="string">&quot;\n&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#27847" title="String">s</a><span class="delimiter">)</span>, <span title="object None">None</span>, <span title="Int(4)" class="int">4</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** 
   * Expect that the value passed as &lt;code&gt;expected&lt;/code&gt; equals the value passed as &lt;code&gt;actual&lt;/code&gt;.
   * If the &lt;code&gt;actual&lt;/code&gt; value equals the &lt;code&gt;expected&lt;/code&gt; value
   * (as determined by &lt;code&gt;==&lt;/code&gt;), &lt;code&gt;expect&lt;/code&gt; returns
   * normally. Else, &lt;code&gt;expect&lt;/code&gt; throws an
   * &lt;code&gt;TestFailedException&lt;/code&gt; whose detail message includes the expected and actual values.
   *
   * @param expected the expected value
   * @param actual the actual value, which should equal the passed &lt;code&gt;expected&lt;/code&gt; value
   * @throws TestFailedException if the passed &lt;code&gt;actual&lt;/code&gt; value does not equal the passed &lt;code&gt;expected&lt;/code&gt; value.
   */</span>
  <span class="keyword">def</span> <a title="(expected: Any)(actual: Any)Unit" id="15647">expect</a><span class="delimiter">(</span><a title="Any" id="27869">expected</a>: <span title="Any">Any</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Any" id="27870">actual</a>: <span title="Any">Any</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#27870" title="Any">actual</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#27869" title="Any">expected</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#27873" title="(Any, Any)" class="delimiter">(</a><a href="#27872" title="Any" id="27873">act</a>, <a href="#27872" title="Any" id="27874">exp</a><span class="delimiter">)</span> = <a href="Suite.scala.html#10074" title="object org.scalatest.Suite">Suite</a>.<a href="Suite.scala.html#27206" title="(a: Any, b: Any)(Any, Any)">getObjectsForFailureMessage</a><span title="(Any, Any) @unchecked" class="delimiter">(</span><a href="#27870" title="Any">actual</a>, <a href="#27869" title="Any">expected</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="String" id="27875">s</a> = <a href="FailureMessages.scala.html#27314" title="(resourceName: String, args: Any*)String">FailureMessages</a><span class="delimiter">(</span><span title="java.lang.String(&quot;expectedButGot&quot;)" class="string">&quot;expectedButGot&quot;</span>, <a href="#27874" title="Any">exp</a>, <a href="#27873" title="Any">act</a><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <a href="#15638" title="(optionalMessage: Option[Any], optionalCause: Option[Throwable], stackDepth: Int)Throwable">newAssertionFailedException</a><span class="delimiter">(</span><span title="(x: String)Some[String]">Some</span><span class="delimiter">(</span><a href="#27875" title="String">s</a><span class="delimiter">)</span>, <span title="object None">None</span>, <span title="Int(4)" class="int">4</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
<span class="comment">/*
   * TODO: Delete this if sticking with Nothing instead of Unit as result type of fail.
   * &lt;p&gt;
   * The result type of this and the other overloaded &lt;code&gt;fail&lt;/code&gt; methods is
   * &lt;code&gt;Unit&lt;/code&gt; instead of &lt;code&gt;Nothing&lt;/code&gt;, because &lt;code&gt;Nothing&lt;/code&gt;
   * is a subtype of all other types. If the result type of &lt;code&gt;fail&lt;/code&gt; were
   * &lt;code&gt;Nothing&lt;/code&gt;, a block of code that ends in a call to &lt;code&gt;fail()&lt;/code&gt; may
   * fail to compile if the block being passed as a by-name parameter or function to an
   * overloaded method. The reason is that the compiler selects which overloaded
   * method to call based on the static types of the parameters passed. Since
   * &lt;code&gt;Nothing&lt;/code&gt; is an instance of everything, it can often make the overloaded
   * method selection ambiguous.
   * &lt;/p&gt;
   *
   * &lt;p&gt;
   * For a concrete example, the &lt;code&gt;Conductor&lt;/code&gt; class
   * in package &lt;code&gt;org.scalatest.concurrent&lt;/code&gt; has two overloaded variants of the
   * &lt;code&gt;thread&lt;/code&gt; method:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * def thread[T](fun: =&gt; T): Thread
   *
   * def thread[T](name: String)(fun: =&gt; T): Thread
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * Given these two overloaded methods, the following code will compile given the result type
   * of &lt;code&gt;fail&lt;/code&gt; is &lt;code&gt;Unit&lt;/code&gt;, but would not compile if the result type were
   * &lt;code&gt;Nothing&lt;/code&gt;:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * thread { fail() }
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * If the result type of &lt;code&gt;fail&lt;/code&gt; were &lt;code&gt;Nothing&lt;/code&gt;, the type of the by-name parameter
   * would be inferred to be &lt;code&gt;Nothing&lt;/code&gt;, which is a subtype of both &lt;code&gt;T&lt;/code&gt; and
   * &lt;code&gt;String&lt;/code&gt;. Thus the call is ambiguous, because the type matches the first parameter type
   * of both overloaded &lt;code&gt;thread&lt;/code&gt; methods. &lt;code&gt;Unit&lt;/code&gt;, by constrast, is &lt;em&gt;not&lt;/em&gt;
   * a subtype of &lt;code&gt;String&lt;/code&gt;, so it only matches one overloaded variant and compiles just fine.
   * &lt;/p&gt;
*/</span>
  <span class="comment">/**
   * Throws &lt;code&gt;TestFailedException&lt;/code&gt; to indicate a test failed.
   */</span>
  <span class="keyword">def</span> <a title="()Nothing" id="15648">fail</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span class="delimiter">{</span> <span title="Nothing" class="keyword">throw</span> <a href="#15638" title="(optionalMessage: Option[Any], optionalCause: Option[Throwable], stackDepth: Int)Throwable">newAssertionFailedException</a><span class="delimiter">(</span><span title="object None">None</span>, <span title="object None">None</span>, <span title="Int(4)" class="int">4</span><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="comment">/**
   * Throws &lt;code&gt;TestFailedException&lt;/code&gt;, with the passed
   * &lt;code&gt;String&lt;/code&gt; &lt;code&gt;message&lt;/code&gt; as the exception's detail
   * message, to indicate a test failed.
   *
   * @param message A message describing the failure.
   * @throws NullPointerException if &lt;code&gt;message&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
   */</span>
  <span class="keyword">def</span> <a title="(message: String)Nothing" id="15649">fail</a><span class="delimiter">(</span><a title="String" id="27897">message</a>: <span title="String">String</span><span class="delimiter">)</span> = <span class="delimiter">{</span>

    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#27897" title="String">message</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
        <span title="Nothing" class="keyword">throw</span> <span title="(x$1: java.lang.String)java.lang.NullPointerException" class="keyword">new</span> <span title="java.lang.NullPointerException">NullPointerException</span><span class="delimiter">(</span><span title="java.lang.String(&quot;message is null&quot;)" class="string">&quot;message is null&quot;</span><span class="delimiter">)</span>
     
    <span title="Nothing" class="keyword">throw</span> <a href="#15638" title="(optionalMessage: Option[Any], optionalCause: Option[Throwable], stackDepth: Int)Throwable">newAssertionFailedException</a><span class="delimiter">(</span><span title="(x: String)Some[String]">Some</span><span class="delimiter">(</span><a href="#27897" title="String">message</a><span class="delimiter">)</span>,  <span title="object None">None</span>, <span title="Int(4)" class="int">4</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Throws &lt;code&gt;TestFailedException&lt;/code&gt;, with the passed
   * &lt;code&gt;String&lt;/code&gt; &lt;code&gt;message&lt;/code&gt; as the exception's detail
   * message and &lt;code&gt;Throwable&lt;/code&gt; cause, to indicate a test failed.
   *
   * @param message A message describing the failure.
   * @param cause A &lt;code&gt;Throwable&lt;/code&gt; that indicates the cause of the failure.
   * @throws NullPointerException if &lt;code&gt;message&lt;/code&gt; or &lt;code&gt;cause&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
   */</span>
  <span class="keyword">def</span> <a title="(message: String, cause: Throwable)Nothing" id="15650">fail</a><span class="delimiter">(</span><a title="String" id="27912">message</a>: <span title="String">String</span>, <a title="Throwable" id="27913">cause</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span> = <span class="delimiter">{</span>

    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#27912" title="String">message</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <span title="(x$1: java.lang.String)java.lang.NullPointerException" class="keyword">new</span> <span title="java.lang.NullPointerException">NullPointerException</span><span class="delimiter">(</span><span title="java.lang.String(&quot;message is null&quot;)" class="string">&quot;message is null&quot;</span><span class="delimiter">)</span>

    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#27913" title="Throwable">cause</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <span title="(x$1: java.lang.String)java.lang.NullPointerException" class="keyword">new</span> <span title="java.lang.NullPointerException">NullPointerException</span><span class="delimiter">(</span><span title="java.lang.String(&quot;cause is null&quot;)" class="string">&quot;cause is null&quot;</span><span class="delimiter">)</span>

    <span title="Nothing" class="keyword">throw</span> <a href="#15638" title="(optionalMessage: Option[Any], optionalCause: Option[Throwable], stackDepth: Int)Throwable">newAssertionFailedException</a><span class="delimiter">(</span><span title="(x: String)Some[String]">Some</span><span class="delimiter">(</span><a href="#27912" title="String">message</a><span class="delimiter">)</span>, <span title="(x: Throwable)Some[Throwable]">Some</span><span class="delimiter">(</span><a href="#27913" title="Throwable">cause</a><span class="delimiter">)</span>, <span title="Int(4)" class="int">4</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Throws &lt;code&gt;TestFailedException&lt;/code&gt;, with the passed
   * &lt;code&gt;Throwable&lt;/code&gt; cause, to indicate a test failed.
   * The &lt;code&gt;getMessage&lt;/code&gt; method of the thrown &lt;code&gt;TestFailedException&lt;/code&gt;
   * will return &lt;code&gt;cause.toString()&lt;/code&gt;.
   *
   * @param cause a &lt;code&gt;Throwable&lt;/code&gt; that indicates the cause of the failure.
   * @throws NullPointerException if &lt;code&gt;cause&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
   */</span>
  <span class="keyword">def</span> <a title="(cause: Throwable)Nothing" id="15651">fail</a><span class="delimiter">(</span><a title="Throwable" id="27934">cause</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span> = <span class="delimiter">{</span>

    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#27934" title="Throwable">cause</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <span title="(x$1: java.lang.String)java.lang.NullPointerException" class="keyword">new</span> <span title="java.lang.NullPointerException">NullPointerException</span><span class="delimiter">(</span><span title="java.lang.String(&quot;cause is null&quot;)" class="string">&quot;cause is null&quot;</span><span class="delimiter">)</span>
        
    <span title="Nothing" class="keyword">throw</span> <a href="#15638" title="(optionalMessage: Option[Any], optionalCause: Option[Throwable], stackDepth: Int)Throwable">newAssertionFailedException</a><span class="delimiter">(</span><span title="object None">None</span>, <span title="(x: Throwable)Some[Throwable]">Some</span><span class="delimiter">(</span><a href="#27934" title="Throwable">cause</a><span class="delimiter">)</span>, <span title="Int(4)" class="int">4</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Executes the block of code passed as the second parameter, and, if it
   * completes abruptly with a &lt;code&gt;ModifiableMessage&lt;/code&gt; exception,
   * prepends the &quot;clue&quot; string passed as the first parameter to the beginning of the detail message
   * of that thrown exception, then rethrows it. If clue does not end in a white space
   * character, one space will be added
   * between it and the existing detail message (unless the detail message is
   * not defined).
   *
   * &lt;p&gt;
   * This method allows you to add more information about what went wrong that will be
   * reported when a test fails. Here's an example:
   * &lt;/p&gt;
   *
   * &lt;pre class=&quot;stHighlight&quot;&gt;
   * withClue(&quot;(Employee's name was: &quot; + employee.name + &quot;)&quot;) {
   *   intercept[IllegalArgumentException] {
   *     employee.getTask(-1)
   *   }
   * }
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * If an invocation of &lt;code&gt;intercept&lt;/code&gt; completed abruptly with an exception, the resulting message would be something like:
   * &lt;/p&gt;
   *
   * &lt;pre&gt;
   * (Employee's name was Bob Jones) Expected IllegalArgumentException to be thrown, but no exception was thrown
   * &lt;/pre&gt;
  */</span>
  <span class="keyword">def</span> <a title="(clue: Any)(fun: =&gt; Unit)Unit" id="15652">withClue</a><span class="delimiter">(</span><a title="Any" id="27946">clue</a>: <span title="Any">Any</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="=&gt; Unit" id="27947">fun</a>: =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(currentMessage: Option[String])Some[java.lang.String]" id="27949">prepend</a><span class="delimiter">(</span><a title="Option[String]" id="27950">currentMessage</a>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#27950" title="Option[String]">currentMessage</a> <span title="Some[java.lang.String]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Some[java.lang.String]">Some</span><span class="delimiter">(</span><a title="String" id="27952">msg</a><span class="delimiter">)</span> =&gt;
          <span title="Some[java.lang.String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#27946" title="Any">clue</a>.<span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">toString</span>.<span title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar">last</span>.<span title="=&gt; Boolean">isWhitespace</span><span class="delimiter">)</span>
            <span title="(x: java.lang.String)Some[java.lang.String]">Some</span><span class="delimiter">(</span><a href="#27946" title="Any">clue</a>.<span title="()java.lang.String">toString</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#27952" title="String">msg</a><span class="delimiter">)</span>
          <span class="keyword">else</span> 
            <span title="(x: java.lang.String)Some[java.lang.String]">Some</span><span class="delimiter">(</span><a href="#27946" title="Any">clue</a>.<span title="()java.lang.String">toString</span> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#27952" title="String">msg</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Some[java.lang.String]">None</span> =&gt; <span title="(x: java.lang.String)Some[java.lang.String]">Some</span><span class="delimiter">(</span><a href="#27946" title="Any">clue</a>.<span title="()java.lang.String">toString</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="keyword">try</span> <span class="delimiter">{</span>
      <a href="#27947" title="=&gt; Unit">fun</a>
    <span class="delimiter">}</span>
    <span class="keyword">catch</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Unit" id="28217">e</a>: <a href="ModifiableMessage.scala.html#9788" title="org.scalatest.ModifiableMessage[_]">ModifiableMessage</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt;
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#27946" title="Any">clue</a> <span title="(x$1: Any)Boolean">!=</span> <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
          <span title="Nothing" class="keyword">throw</span> <a href="#28217" title="&lt;none&gt; extends java.lang.Throwable with org.scalatest.ModifiableMessage[_]">e</a>.<a href="ModifiableMessage.scala.html#27454" title="(fun: Option[String] =&gt; Option[String])_">modifyMessage</a><span class="delimiter">(</span><a href="#27949" title="(currentMessage: Option[String])Some[java.lang.String]">prepend</a><span class="delimiter">)</span>
        <span class="keyword">else</span>
          <span title="Nothing" class="keyword">throw</span> <a href="#28217" title="&lt;none&gt; extends java.lang.Throwable with org.scalatest.ModifiableMessage[_]">e</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="comment">/* Hold off on this for now. See how people do with the simple one that takes an Any.
  def withClueFunction(sfun: Option[String] =&gt; Option[String])(fun: =&gt; Unit) {
    fun
  }
*/</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Companion object that facilitates the importing of &lt;code&gt;Assertions&lt;/code&gt; members as 
 * an alternative to mixing it in. One use case is to import &lt;code&gt;Assertions&lt;/code&gt; members so you can use
 * them in the Scala interpreter:
 *
 * &lt;pre class=&quot;stREPL&quot;&gt;
 * $scala -classpath scalatest.jar
 * Welcome to Scala version 2.7.3.final (Java HotSpot(TM) Client VM, Java 1.5.0_16).
 * Type in expressions to have them evaluated.
 * Type :help for more information.
 * &amp;nbsp;
 * scala&gt; import org.scalatest.Assertions._
 * import org.scalatest.Assertions._
 * &amp;nbsp;
 * scala&gt; assert(1 === 2)
 * org.scalatest.TestFailedException: 1 did not equal 2
 * 	at org.scalatest.Assertions$class.assert(Assertions.scala:211)
 * 	at org.scalatest.Assertions$.assert(Assertions.scala:511)
 * 	at .&lt;init&gt;(&lt;console&gt;:7)
 * 	at .&lt;clinit&gt;(&lt;console&gt;)
 * 	at RequestResult$.&lt;init&gt;(&lt;console&gt;:3)
 * 	at RequestResult$.&lt;clinit&gt;(&lt;console&gt;)
 * 	at RequestResult$result(&lt;console&gt;)
 * 	at sun.reflect.NativeMethodAccessorImpl.invoke...
 *&amp;nbsp;
 * scala&gt; expect(3) { 1 + 3 }
 * org.scalatest.TestFailedException: Expected 3, but got 4
 * 	at org.scalatest.Assertions$class.expect(Assertions.scala:447)
 * 	at org.scalatest.Assertions$.expect(Assertions.scala:511)
 * 	at .&lt;init&gt;(&lt;console&gt;:7)
 * 	at .&lt;clinit&gt;(&lt;console&gt;)
 * 	at RequestResult$.&lt;init&gt;(&lt;console&gt;:3)
 * 	at RequestResult$.&lt;clinit&gt;(&lt;console&gt;)
 * 	at RequestResult$result(&lt;console&gt;)
 * 	at sun.reflect.NativeMethodAccessorImpl.in...
 *&amp;nbsp;
 * scala&gt; val caught = intercept[StringIndexOutOfBoundsException] { &quot;hi&quot;.charAt(-1) }
 * caught: StringIndexOutOfBoundsException = java.lang.StringIndexOutOfBoundsException: String index out of range: -1
 * &lt;/pre&gt;
 *
 * @author Bill Venners
 */</span>
<span class="keyword">object</span> <a title="object org.scalatest.Assertions" id="10095">Assertions</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#10094" title="org.scalatest.Assertions">Assertions</a> <span class="delimiter">{</span>
  <span class="keyword">private</span><span class="delimiter">[</span>scalatest<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(left: Any, right: Any)Boolean" id="19652">areEqualComparingArraysStructurally</a><span class="delimiter">(</span><a title="Any" id="20253">left</a>: <span title="Any">Any</span>, <a title="Any" id="20254">right</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#20253" title="Any">left</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="Boolean" id="20257">leftArray</a>: <span title="Array[_]">Array</span><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt;
          <a href="#20254" title="Any">right</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a title="Boolean" id="20259">rightArray</a>: <span title="Array[_]">Array</span><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="#20257" title="(xs: Array[_])scala.collection.mutable.ArrayOps[_]">leftArray</a>.<span title="=&gt; IndexedSeq[Any]">deep</span>.<span title="(that: Any)Boolean">equals</span><span class="delimiter">(</span><a href="#20259" title="(xs: Array[_])scala.collection.mutable.ArrayOps[_]">rightArray</a>.<span title="=&gt; IndexedSeq[Any]">deep</span><span class="delimiter">)</span>
            <span class="keyword">case</span> <span title="Boolean">_</span> =&gt; <a href="#20253" title="Any">left</a> <span title="(x$1: Any)Boolean">==</span> <a href="#20254" title="Any">right</a>
        <span class="delimiter">}</span>
        <span class="keyword">case</span> <span title="Boolean">_</span> =&gt; <a href="#20253" title="Any">left</a> <span title="(x$1: Any)Boolean">==</span> <a href="#20254" title="Any">right</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>