<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>org/scalatest/matchers/ShouldMatchers.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright 2001-2008 Artima, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>
<span class="keyword">package</span> org.scalatest.matchers

<span class="keyword">import</span> org.scalatest._
<span class="keyword">import</span> scala.reflect.Manifest
<span class="keyword">import</span> org.scalatest.verb.ShouldVerb
<span class="keyword">import</span> scala.collection.Traversable

<span class="comment">/**
 * Trait that provides a domain specific language (DSL) for expressing assertions in tests
 * using the word &lt;code&gt;should&lt;/code&gt;. (If you prefer the word &lt;code&gt;must&lt;/code&gt;, you can alternatively
 * mix in trait &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt;.) For example, if you mix &lt;code&gt;ShouldMatchers&lt;/code&gt; into
 * a suite class, you can write an equality assertion in that suite like this:
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * result should equal (3)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * Here &lt;code&gt;result&lt;/code&gt; is a variable, and can be of any type. If the object is an
 * &lt;code&gt;Int&lt;/code&gt; with the value 3, execution will continue (&lt;em&gt;i.e.&lt;/em&gt;, the expression will result
 * in the unit value, &lt;code&gt;()&lt;/code&gt;). Otherwise, a &lt;code&gt;TestFailedException&lt;/code&gt;
 * will be thrown with a detail message that explains the problem, such as &lt;code&gt;&quot;7 did not equal 3&quot;&lt;/code&gt;.
 * This &lt;code&gt;TestFailedException&lt;/code&gt; will cause the test to fail.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * The &lt;code&gt;left should equal (right)&lt;/code&gt; syntax works by calling &lt;code&gt;==&lt;/code&gt;  on the &lt;code&gt;left&lt;/code&gt;
 * value, passing in the &lt;code&gt;right&lt;/code&gt; value, on every type except arrays. If both &lt;code&gt;left&lt;/code&gt; and right are arrays, &lt;code&gt;deep&lt;/code&gt;
 * will be invoked on both &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; before comparing them with &lt;em&gt;==&lt;/em&gt;. Thus, even though this expression
 * will yield false, because &lt;code&gt;Array&lt;/code&gt;'s &lt;code&gt;equals&lt;/code&gt; method compares object identity:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * Array(1, 2) == Array(1, 2) // yields false
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * The following expression will &lt;em&gt;not&lt;/em&gt; result in a &lt;code&gt;TestFailedException&lt;/code&gt;, because ScalaTest compares
 * the two arrays structurally, taking into consideration the equality of the array's contents:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * Array(1, 2) should equal (Array(1, 2)) // succeeds (i.e., does not throw TestFailedException)
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * If you ever do want to verify that two arrays are actually the same object (have the same identity), you can use the
 * &lt;code&gt;be theSameInstanceAs&lt;/code&gt; syntax, described below.
 * &lt;/p&gt;
 *
 * &lt;h2&gt;Checking size and length&lt;/h2&gt;
 * 
 * &lt;p&gt;
 * You can check the size or length of just about any type of object for which it
 * would make sense. Here's how checking for length looks:
 * &lt;/p&gt;
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * result should have length (3)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 *Size is similar:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * result should have size (10)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * The &lt;code&gt;length&lt;/code&gt; syntax can be used with any object that has a field or method named &lt;code&gt;length&lt;/code&gt;
 * or a method named &lt;code&gt;getLength&lt;/code&gt;.   Similarly, the &lt;code&gt;size&lt;/code&gt; syntax can be used with any
 * object that has a field or method named &lt;code&gt;size&lt;/code&gt; or a method named &lt;code&gt;getSize&lt;/code&gt;.
 * The type of a &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;size&lt;/code&gt; field, or return type of a method, must be either &lt;code&gt;Int&lt;/code&gt;
 * or &lt;code&gt;Long&lt;/code&gt;. Any such method must take no parameters. (The Scala compiler will ensure at compile time that
 * the object on which &lt;code&gt;should&lt;/code&gt; is being invoked has the appropriate structure.)
 * &lt;/p&gt;
 * 
 * &lt;h2&gt;Checking strings&lt;/h2&gt;
 * 
 * &lt;p&gt;
 * You can check for whether a string starts with, ends with, or includes a substring like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * string should startWith (&quot;Hello&quot;)
 * string should endWith (&quot;world&quot;)
 * string should include (&quot;seven&quot;)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * You can check for whether a string starts with, ends with, or includes a regular expression, like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * string should startWith regex (&quot;Hel*o&quot;)
 * string should endWith regex (&quot;wo.ld&quot;)
 * string should include regex (&quot;wo.ld&quot;)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * And you can check whether a string fully matches a regular expression, like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * string should fullyMatch regex (&quot;&quot;&quot;(-)?(\d+)(\.\d*)?&quot;&quot;&quot;)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * The regular expression passed following the &lt;code&gt;regex&lt;/code&gt; token can be either a &lt;code&gt;String&lt;/code&gt;
 * or a &lt;code&gt;scala.util.matching.Regex&lt;/code&gt;.
 * &lt;/p&gt;
 *
 * &lt;h2&gt;Greater and less than&lt;/h2&gt;
 * &lt;p&gt;
 * You can check whether any type that is, or can be implicitly converted to,
 * an &lt;code&gt;Ordered[T]&lt;/code&gt; is greater than, less than, greater than or equal, or less
 * than or equal to a value of type &lt;code&gt;T&lt;/code&gt;. The syntax is:
 * &lt;/p&gt;
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * one should be &lt; (7)
 * one should be &gt; (0)
 * one should be &lt;= (7)
 * one should be &gt;= (0)
 * &lt;/pre&gt;
 * 
 * &lt;h2&gt;Checking equality with &lt;code&gt;be&lt;/code&gt; &lt;code&gt;=&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;/h2&gt;
 *
 * &lt;p&gt;
 * An alternate way to check for equality of two objects is to use &lt;code&gt;be&lt;/code&gt; with
 * &lt;code&gt;===&lt;/code&gt;. Here's an example:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * result should be === (3)
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Here &lt;code&gt;result&lt;/code&gt; is a variable, and can be of any type. If the object is an
 * &lt;code&gt;Int&lt;/code&gt; with the value 3, execution will continue (&lt;em&gt;i.e.&lt;/em&gt;, the expression will result
 * in the unit value, &lt;code&gt;()&lt;/code&gt;). Otherwise, a &lt;code&gt;TestFailedException&lt;/code&gt;
 * will be thrown with a detail message that explains the problem, such as &lt;code&gt;&quot;7 was not equal to 3&quot;&lt;/code&gt;.
 * This &lt;code&gt;TestFailedException&lt;/code&gt; will cause the test to fail.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The &lt;code&gt;left should be === (right)&lt;/code&gt; syntax works by calling &lt;code&gt;==&lt;/code&gt;  on the &lt;code&gt;left&lt;/code&gt;
 * value, passing in the &lt;code&gt;right&lt;/code&gt; value, on every type except arrays. If both &lt;code&gt;left&lt;/code&gt; and right are arrays, &lt;code&gt;deep&lt;/code&gt;
 * will be invoked on both &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; before comparing them with &lt;em&gt;==&lt;/em&gt;. Thus, even though this expression
 * will yield false, because &lt;code&gt;Array&lt;/code&gt;'s &lt;code&gt;equals&lt;/code&gt; method compares object identity:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * Array(1, 2) == Array(1, 2) // yields false
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * The following expression will &lt;em&gt;not&lt;/em&gt; result in a &lt;code&gt;TestFailedException&lt;/code&gt;, because ScalaTest compares
 * the two arrays structurally, taking into consideration the equality of the array's contents:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * Array(1, 2) should be === (Array(1, 2)) // succeeds (i.e., does not throw TestFailedException)
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * If you ever do want to verify that two arrays are actually the same object (have the same identity), you can use the
 * &lt;code&gt;be theSameInstanceAs&lt;/code&gt; syntax, described below.
 * &lt;/p&gt;
 *
 * &lt;h2&gt;Checking &lt;code&gt;Boolean&lt;/code&gt; properties with &lt;code&gt;be&lt;/code&gt;&lt;/h2&gt;
 * 
 * &lt;p&gt;
 * If an object has a method that takes no parameters and returns boolean, you can check
 * it by placing a &lt;code&gt;Symbol&lt;/code&gt; (after &lt;code&gt;be&lt;/code&gt;) that specifies the name
 * of the method (excluding an optional prefix of &quot;&lt;code&gt;is&lt;/code&gt;&quot;). A symbol literal
 * in Scala begins with a tick mark and ends at the first non-identifier character. Thus,
 * &lt;code&gt;'empty&lt;/code&gt; results in a &lt;code&gt;Symbol&lt;/code&gt; object at runtime, as does
 * &lt;code&gt;'defined&lt;/code&gt; and &lt;code&gt;'file&lt;/code&gt;. Here's an example:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * emptySet should be ('empty)
 * &lt;/pre&gt;
 * 
 * Given this code, ScalaTest will use reflection to look on the object referenced from
 * &lt;code&gt;emptySet&lt;/code&gt; for a method that takes no parameters and results in &lt;code&gt;Boolean&lt;/code&gt;,
 * with either the name &lt;code&gt;empty&lt;/code&gt; or &lt;code&gt;isEmpty&lt;/code&gt;. If found, it will invoke
 * that method. If the method returns &lt;code&gt;true&lt;/code&gt;, execution will continue. But if it returns
 * &lt;code&gt;false&lt;/code&gt;, a &lt;code&gt;TestFailedException&lt;/code&gt; will be thrown that will contain a detail message, such as:
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * Set(1, 2, 3) was not empty
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * This &lt;code&gt;be&lt;/code&gt; syntax can be used with any type.  If the object does
 * not have an appropriately named predicate method, you'll get a &lt;code&gt;TestFailedException&lt;/code&gt;
 * at runtime with a detail message that explains the problem.
 * (For the details on how a field or method is selected during this
 * process, see the documentation for &lt;a href=&quot;Matchers$BeWord.html&quot;&gt;&lt;code&gt;BeWord&lt;/code&gt;&lt;/a&gt;.)
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * If you think it reads better, you can optionally put &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;an&lt;/code&gt; after
 * &lt;code&gt;be&lt;/code&gt;. For example, &lt;code&gt;java.io.File&lt;/code&gt; has two predicate methods,
 * &lt;code&gt;isFile&lt;/code&gt; and &lt;code&gt;isDirectory&lt;/code&gt;. Thus with a &lt;code&gt;File&lt;/code&gt; object
 * named &lt;code&gt;temp&lt;/code&gt;, you could write:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * temp should be a ('file)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * Or, given &lt;code&gt;java.awt.event.KeyEvent&lt;/code&gt; has a method &lt;code&gt;isActionKey&lt;/code&gt; that takes
 * no arguments and returns &lt;code&gt;Boolean&lt;/code&gt;, you could assert that a &lt;code&gt;KeyEvent&lt;/code&gt; is
 * an action key with:
 *&lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * keyEvent should be an ('actionKey)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * If you prefer to check &lt;code&gt;Boolean&lt;/code&gt; properties in a type-safe manner, you can use a &lt;code&gt;BePropertyMatcher&lt;/code&gt;.
 * This would allow you to write expressions such as:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * emptySet should be (empty)
 * temp should be a (file)
 * keyEvent should be an (actionKey)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * These expressions would fail to compile if &lt;code&gt;should&lt;/code&gt; is used on an inappropriate type, as determined
 * by the type parameter of the &lt;code&gt;BePropertyMatcher&lt;/code&gt; being used. (For example, &lt;code&gt;file&lt;/code&gt; in this example
 * would likely be of type &lt;code&gt;BePropertyMatcher[java.io.File]&lt;/code&gt;. If used with an appropriate type, such an expression will compile
 * and at run time the &lt;code&gt;Boolean&lt;/code&gt; property method or field will be accessed directly; &lt;em&gt;i.e.&lt;/em&gt;, no reflection will be used.
 * See the documentation for &lt;a href=&quot;BePropertyMatcher.html&quot;&gt;&lt;code&gt;BePropertyMatcher&lt;/code&gt;&lt;/a&gt; for more information.
 * &lt;/p&gt;
 *
 * &lt;h2&gt;Using custom &lt;code&gt;BeMatchers&lt;/code&gt;&lt;/h2&gt;
 *
 * If you want to create a new way of using &lt;code&gt;be&lt;/code&gt;, which doesn't map to an actual property on the
 * type you care about, you can create a &lt;code&gt;BeMatcher&lt;/code&gt;. You could use this, for example, to create &lt;code&gt;BeMatcher[Int]&lt;/code&gt;
 * called &lt;code&gt;odd&lt;/code&gt;, which would match any odd &lt;code&gt;Int&lt;/code&gt;, and &lt;code&gt;even&lt;/code&gt;, which would match
 * any even &lt;code&gt;Int&lt;/code&gt;. 
 * Given this pair of &lt;code&gt;BeMatcher&lt;/code&gt;s, you could check whether an &lt;code&gt;Int&lt;/code&gt; was odd or even with expressions like:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * num should be (odd)
 * num should not be (even)
 * &lt;/pre&gt;
 *
 * For more information, see the documentation for &lt;a href=&quot;BeMatcher.html&quot;&gt;&lt;code&gt;BeMatcher&lt;/code&gt;&lt;/a&gt;.
 *
 * &lt;h2&gt;Checking object identity&lt;/h2&gt;
 * 
 * &lt;p&gt;
 * If you need to check that two references refer to the exact same object, you can write:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * ref1 should be theSameInstanceAs (ref2)
 * &lt;/pre&gt;
 * 
 * &lt;h2&gt;Checking numbers against a range&lt;/h2&gt;
 * 
 * &lt;p&gt;
 * To check whether a floating point number has a value that exactly matches another, you
 * can use &lt;code&gt;should equal&lt;/code&gt;:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * sevenDotOh should equal (7.0)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * Often, however, you may want to check whether a floating point number is within a
 * range. You can do that using &lt;code&gt;be&lt;/code&gt; and &lt;code&gt;plusOrMinus&lt;/code&gt;, like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * sevenDotOh should be (6.9 plusOrMinus 0.2)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * This expression will cause a &lt;code&gt;TestFailedException&lt;/code&gt; to be thrown if the floating point
 * value, &lt;code&gt;sevenDotOh&lt;/code&gt; is outside the range &lt;code&gt;6.7&lt;/code&gt; to &lt;code&gt;7.1&lt;/code&gt;.
 * You can also use &lt;code&gt;plusOrMinus&lt;/code&gt; with integral types, for example:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * seven should be (6 plusOrMinus 2)
 * &lt;/pre&gt;
 * 
 * &lt;h2&gt;Traversables, iterables, sets, sequences, and maps&lt;/h2&gt;
 * 
 * &lt;p&gt;
 * You can use some of the syntax shown previously with &lt;code&gt;Iterable&lt;/code&gt; and its
 * subtypes. For example, you can check whether an &lt;code&gt;Iterable&lt;/code&gt; is &lt;code&gt;empty&lt;/code&gt;,
 * like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * iterable should be ('empty)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * You can check the length of an &lt;code&gt;Seq&lt;/code&gt; (&lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;List&lt;/code&gt;, etc.),
 * like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * array should have length (3)
 * list should have length (9)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * You can check the size of any &lt;code&gt;Traversable&lt;/code&gt;, like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * map should have size (20)
 * set should have size (90)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * In addition, you can check whether an &lt;code&gt;Iterable&lt;/code&gt; contains a particular
 * element, like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * iterable should contain (&quot;five&quot;)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * You can also check whether a &lt;code&gt;Map&lt;/code&gt; contains a particular key, or value, like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * map should contain key (1)
 * map should contain value (&quot;Howdy&quot;)
 * &lt;/pre&gt;
 * 
 * &lt;h2&gt;Java collections and maps&lt;/h2&gt;
 * 
 * &lt;p&gt;
 * You can use similar syntax on Java collections (&lt;code&gt;java.util.Collection&lt;/code&gt;) and maps (&lt;code&gt;java.util.Map&lt;/code&gt;).
 * For example, you can check whether a Java &lt;code&gt;Collection&lt;/code&gt; or &lt;code&gt;Map&lt;/code&gt; is &lt;code&gt;empty&lt;/code&gt;,
 * like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * javaCollection should be ('empty)
 * javaMap should be ('empty)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * Even though Java's &lt;code&gt;List&lt;/code&gt; type doesn't actually have a &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;getLength&lt;/code&gt; method,
 * you can nevertheless check the length of a Java &lt;code&gt;List&lt;/code&gt; (&lt;code&gt;java.util.List&lt;/code&gt;) like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * javaList should have length (9)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * You can check the size of any Java &lt;code&gt;Collection&lt;/code&gt; or &lt;code&gt;Map&lt;/code&gt;, like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * javaMap should have size (20)
 * javaSet should have size (90)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * In addition, you can check whether a Java &lt;code&gt;Collection&lt;/code&gt; contains a particular
 * element, like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * javaCollection should contain (&quot;five&quot;)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * One difference to note between the syntax supported on Java collections and that of Scala
 * iterables is that you can't use &lt;code&gt;contain (...)&lt;/code&gt; syntax with a Java &lt;code&gt;Map&lt;/code&gt;.
 * Java differs from Scala in that its &lt;code&gt;Map&lt;/code&gt; is not a subtype of its &lt;code&gt;Collection&lt;/code&gt; type.
 * If you want to check that a Java &lt;code&gt;Map&lt;/code&gt; contains a specific key/value pair, the best approach is
 * to invoke &lt;code&gt;entrySet&lt;/code&gt; on the Java &lt;code&gt;Map&lt;/code&gt; and check that entry set for the appropriate
 * element (a &lt;code&gt;java.util.Map.Entry&lt;/code&gt;) using &lt;code&gt;contain (...)&lt;/code&gt;.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Despite this difference, the other (more commonly used) map matcher syntax works just fine on Java &lt;code&gt;Map&lt;/code&gt;s.
 * You can, for example, check whether a Java &lt;code&gt;Map&lt;/code&gt; contains a particular key, or value, like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * javaMap should contain key (1)
 * javaMap should contain value (&quot;Howdy&quot;)
 * &lt;/pre&gt;
 * 
 * &lt;h2&gt;Be as an equality comparison&lt;/h2&gt;
 * 
 * &lt;p&gt;
 * All uses of &lt;code&gt;be&lt;/code&gt; other than those shown previously perform an equality comparison. In other words, they work
 * the same as &lt;code&gt;equals&lt;/code&gt;. This redundance between &lt;code&gt;be&lt;/code&gt; and &lt;code&gt;equals&lt;/code&gt; exists because it enables syntax
 * that sometimes sounds more natural. For example, instead of writing: 
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * result should equal (null)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * You can write:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * result should be (null)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * (Hopefully you won't write that too much given &lt;code&gt;null&lt;/code&gt; is error prone, and &lt;code&gt;Option&lt;/code&gt;
 * is usually a better, well, option.) 
 * Here are some other examples of &lt;code&gt;be&lt;/code&gt; used for equality comparison:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * sum should be (7.0)
 * boring should be (false)
 * fun should be (true)
 * list should be (Nil)
 * option should be (None)
 * option should be (Some(1))
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * As with &lt;code&gt;equal&lt;/code&gt;, using &lt;code&gt;be&lt;/code&gt; on two arrays results in &lt;code&gt;deep&lt;/code&gt; being called on both arrays prior to
 * calling &lt;code&gt;equal&lt;/code&gt;. As a result,
 * the following expression would &lt;em&gt;not&lt;/em&gt; throw a &lt;code&gt;TestFailedException&lt;/code&gt;:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * Array(1, 2) should be (Array(1, 2)) // succeeds (i.e., does not throw TestFailedException)
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Because &lt;code&gt;be&lt;/code&gt; is used in several ways in ScalaTest matcher syntax, just as it is used in many ways in English, one
 * potential point of confusion in the event of a failure is determining whether &lt;code&gt;be&lt;/code&gt; was being used as an equality comparison or
 * in some other way, such as a property assertion. To make it more obvious when &lt;code&gt;be&lt;/code&gt; is being used for equality, the failure
 * messages generated for those equality checks will include the word &lt;code&gt;equal&lt;/code&gt; in them. For example, if this expression fails with a
 * &lt;code&gt;TestFailedException&lt;/code&gt;:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * option should be (Some(1))
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * The detail message in that &lt;code&gt;TestFailedException&lt;/code&gt; will include the words &lt;code&gt;&quot;equal to&quot;&lt;/code&gt; to signify &lt;code&gt;be&lt;/code&gt;
 * was in this case being used for equality comparison:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * Some(2) was not equal to Some(1)
 * &lt;/pre&gt;
 *
 * &lt;h2&gt;Being negative&lt;/h2&gt;
 * 
 * &lt;p&gt;
 * If you wish to check the opposite of some condition, you can simply insert &lt;code&gt;not&lt;/code&gt; in the expression.
 * Here are a few examples:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * result should not be (null)
 * sum should not be &lt;= (10)
 * mylist should not equal (yourList)
 * string should not startWith (&quot;Hello&quot;)
 * &lt;/pre&gt;
 * 
 * &lt;h2&gt;Logical expressions with &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt;&lt;/h2&gt;
 * 
 * &lt;p&gt;
 * You can also combine matcher expressions with &lt;code&gt;and&lt;/code&gt; and/or &lt;code&gt;or&lt;/code&gt;, however,
 * you must place parentheses or curly braces around the &lt;code&gt;and&lt;/code&gt; or &lt;code&gt;or&lt;/code&gt; expression. For example, 
 * this &lt;code&gt;and&lt;/code&gt;-expression would not compile, because the parentheses are missing:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * map should contain key (&quot;two&quot;) and not contain value (7) // ERROR, parentheses missing!
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * Instead, you need to write:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * map should (contain key (&quot;two&quot;) and not contain value (7))
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * Here are some more examples:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * number should (be &gt; (0) and be &lt;= (10))
 * option should (equal (Some(List(1, 2, 3))) or be (None))
 * string should (
 *   equal (&quot;fee&quot;) or
 *   equal (&quot;fie&quot;) or
 *   equal (&quot;foe&quot;) or
 *   equal (&quot;fum&quot;)
 * )
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * Two differences exist between expressions composed of these &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators and the expressions you can write
 * on regular &lt;code&gt;Boolean&lt;/code&gt;s using its &lt;code&gt;&amp;&amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; operators. First, expressions with &lt;code&gt;and&lt;/code&gt;
 * and &lt;code&gt;or&lt;/code&gt; do not short-circuit. The following contrived expression, for example, would print &lt;code&gt;&quot;hello, world!&quot;&lt;/code&gt;:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * &quot;yellow&quot; should (equal (&quot;blue&quot;) and equal { println(&quot;hello, world!&quot;); &quot;green&quot; })
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * In other words, the entire &lt;code&gt;and&lt;/code&gt; or &lt;code&gt;or&lt;/code&gt; expression is always evaluated, so you'll see any side effects
 * of the right-hand side even if evaluating
 * only the left-hand side is enough to determine the ultimate result of the larger expression. Failure messages produced by these
 * expressions will &quot;short-circuit,&quot; however,
 * mentioning only the left-hand side if that's enough to determine the result of the entire expression. This &quot;short-circuiting&quot; behavior
 * of failure messages is intended
 * to make it easier and quicker for you to ascertain which part of the expression caused the failure. The failure message for the previous
 * expression, for example, would be:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * &quot;yellow&quot; did not equal &quot;blue&quot;
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * Most likely this lack of short-circuiting would rarely be noticeable, because evaluating the right hand side will usually not
 * involve a side effect. One situation where it might show up, however, is if you attempt to &lt;code&gt;and&lt;/code&gt; a &lt;code&gt;null&lt;/code&gt; check on a variable with an expression
 * that uses the variable, like this:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * map should (not be (null) and contain key (&quot;ouch&quot;))
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * If &lt;code&gt;map&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the test will indeed fail, but with a &lt;code&gt;NullPointerException&lt;/code&gt;, not a
 * &lt;code&gt;TestFailedException&lt;/code&gt;. Here, the &lt;code&gt;NullPointerException&lt;/code&gt; is the visible right-hand side effect. To get a
 * &lt;code&gt;TestFailedException&lt;/code&gt;, you would need to check each assertion separately:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * map should not be (null)
 * map should contain key (&quot;ouch&quot;)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * If &lt;code&gt;map&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; in this case, the &lt;code&gt;null&lt;/code&gt; check in the first expression will fail with
 * a &lt;code&gt;TestFailedException&lt;/code&gt;, and the second expression will never be executed.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The other difference with &lt;code&gt;Boolean&lt;/code&gt; operators is that although &lt;code&gt;&amp;&amp;&lt;/code&gt; has a higher precedence than &lt;code&gt;||&lt;/code&gt;,
 * &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt;
 * have the same precedence. Thus although the &lt;code&gt;Boolean&lt;/code&gt; expression &lt;code&gt;(a || b &amp;&amp; c)&lt;/code&gt; will evaluate the &lt;code&gt;&amp;&amp;&lt;/code&gt; expression
 * before the &lt;code&gt;||&lt;/code&gt; expression, like &lt;code&gt;(a || (b &amp;&amp; c))&lt;/code&gt;, the following expression:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * traversable should (contain (7) or contain (8) and have size (9))
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * Will evaluate left to right, as:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * traversable should ((contain (7) or contain (8)) and have size (9))
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * If you really want the &lt;code&gt;and&lt;/code&gt; part to be evaluated first, you'll need to put in parentheses, like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * traversable should (contain (7) or (contain (8) and have size (9)))
 * &lt;/pre&gt;
 * 
 * &lt;h2&gt;Working with &lt;code&gt;Option&lt;/code&gt;s&lt;/h2&gt;
 * 
 * &lt;p&gt;
 * ScalaTest matchers has no special support for &lt;code&gt;Option&lt;/code&gt;s, but you can 
 * work with them quite easily using syntax shown previously. For example, if you wish to check
 * whether an option is &lt;code&gt;None&lt;/code&gt;, you can write any of:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * option should equal (None)
 * option should be (None)
 * option should not be ('defined)
 * option should be ('empty)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * If you wish to check an option is defined, and holds a specific value, you can write either of:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * option should equal (Some(&quot;hi&quot;))
 * option should be (Some(&quot;hi&quot;))
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * If you only wish to check that an option is defined, but don't care what it's value is, you can write:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * option should be ('defined)
 * &lt;/pre&gt;
 * 
 * &lt;h2&gt;Checking arbitrary properties with &lt;code&gt;have&lt;/code&gt;&lt;/h2&gt;
 * 
 * &lt;p&gt;
 * Using &lt;code&gt;have&lt;/code&gt;, you can check properties of any type, where a &lt;em&gt;property&lt;/em&gt; is an attribute of any
 * object that can be retrieved either by a public field, method, or JavaBean-style &lt;code&gt;get&lt;/code&gt;
 * or &lt;code&gt;is&lt;/code&gt; method, like this:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * book should have (
 *   'title (&quot;Programming in Scala&quot;),
 *   'author (List(&quot;Odersky&quot;, &quot;Spoon&quot;, &quot;Venners&quot;)),
 *   'pubYear (2008)
 * )
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * This expression will use reflection to ensure the &lt;code&gt;title&lt;/code&gt;, &lt;code&gt;author&lt;/code&gt;, and &lt;code&gt;pubYear&lt;/code&gt; properties of object &lt;code&gt;book&lt;/code&gt;
 * are equal to the specified values. For example, it will ensure that &lt;code&gt;book&lt;/code&gt; has either a public Java field or method
 * named &lt;code&gt;title&lt;/code&gt;, or a public method named &lt;code&gt;getTitle&lt;/code&gt;, that when invoked (or accessed in the field case) results
 * in a the string &lt;code&gt;&quot;Programming in Scala&quot;&lt;/code&gt;. If all specified properties exist and have their expected values, respectively,
 * execution will continue. If one or more of the properties either does not exist, or exists but results in an unexpected value,
 * a &lt;code&gt;TestFailedException&lt;/code&gt; will be thrown that explains the problem. (For the details on how a field or method is selected during this
 * process, see the documentation for &lt;a href=&quot;Matchers$HavePropertyMatcherGenerator.html&quot;&gt;&lt;code&gt;HavePropertyMatcherGenerator&lt;/code&gt;&lt;/a&gt;.)
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * When you use this syntax, you must place one or more property values in parentheses after &lt;code&gt;have&lt;/code&gt;, seperated by commas, where a &lt;em&gt;property
 * value&lt;/em&gt; is a symbol indicating the name of the property followed by the expected value in parentheses. The only exceptions to this rule is the syntax
 * for checking size and length shown previously, which does not require parentheses. If you forget and put parentheses in, however, everything will
 * still work as you'd expect. Thus instead of writing:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * array should have length (3)
 * set should have size (90)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * You can alternatively, write:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * array should have (length (3))
 * set should have (size (90))
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * If a property has a value different from the specified expected value, a &lt;code&gt;TestFailedError&lt;/code&gt; will be thrown
 * with a detail message that explains the problem. For example, if you assert the following on
 * a &lt;code&gt;book&lt;/code&gt; whose title is &lt;code&gt;Moby Dick&lt;/code&gt;:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * book should have ('title (&quot;A Tale of Two Cities&quot;))
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * You'll get a &lt;code&gt;TestFailedException&lt;/code&gt; with this detail message:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * The title property had value &quot;Moby Dick&quot;, instead of its expected value &quot;A Tale of Two Cities&quot;,
 * on object Book(&quot;Moby Dick&quot;, &quot;Melville&quot;, 1851)
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * If you prefer to check properties in a type-safe manner, you can use a &lt;code&gt;HavePropertyMatcher&lt;/code&gt;.
 * This would allow you to write expressions such as:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * book should have (
 *   title (&quot;Programming in Scala&quot;),
 *   author (List(&quot;Odersky&quot;, &quot;Spoon&quot;, &quot;Venners&quot;)),
 *   pubYear (2008)
 * )
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * These expressions would fail to compile if &lt;code&gt;should&lt;/code&gt; is used on an inappropriate type, as determined
 * by the type parameter of the &lt;code&gt;HavePropertyMatcher&lt;/code&gt; being used. (For example, &lt;code&gt;title&lt;/code&gt; in this example
 * might be of type &lt;code&gt;HavePropertyMatcher[org.publiclibrary.Book]&lt;/code&gt;. If used with an appropriate type, such an expression will compile
 * and at run time the property method or field will be accessed directly; &lt;em&gt;i.e.&lt;/em&gt;, no reflection will be used.
 * See the documentation for &lt;a href=&quot;HavePropertyMatcher.html&quot;&gt;&lt;code&gt;HavePropertyMatcher&lt;/code&gt;&lt;/a&gt; for more information.
 * &lt;/p&gt;
 *
 * &lt;h2&gt;Using custom matchers&lt;/h2&gt;
 * 
 * &lt;p&gt;
 * If none of the built-in matcher syntax (or options shown so far for extending the syntax) satisfy a particular need you have, you can create
 * custom &lt;code&gt;Matcher&lt;/code&gt;s that allow
 * you to place your own syntax directly after &lt;code&gt;should&lt;/code&gt;. For example, class &lt;code&gt;java.io.File&lt;/code&gt; has a method &lt;code&gt;exists&lt;/code&gt;, which
 * indicates whether a file of a certain path and name exists. Because the &lt;code&gt;exists&lt;/code&gt; method takes no parameters and returns &lt;code&gt;Boolean&lt;/code&gt;,
 * you can call it using &lt;code&gt;be&lt;/code&gt; with a symbol or &lt;code&gt;BePropertyMatcher&lt;/code&gt;, yielding assertions like:
 * &lt;/p&gt;
 * 
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * file should be ('exists)  // using a symbol
 * file should be (inExistance)   // using a BePropertyMatcher
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * Although these expressions will achieve your goal of throwing a &lt;code&gt;TestFailedException&lt;/code&gt; if the file does not exist, they don't produce
 * the most readable code because the English is either incorrect or awkward. In this case, you might want to create a
 * custom &lt;code&gt;Matcher[java.io.File]&lt;/code&gt;
 * named &lt;code&gt;exist&lt;/code&gt;, which you could then use to write expressions like:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * // using a plain-old Matcher
 * file should exist
 * file should not (exist)
 * file should (exist and have ('name (&quot;temp.txt&quot;)))
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * Note that when you use custom &lt;code&gt;Matcher&lt;/code&gt;s, you will need to put parentheses around the custom matcher in more cases than with
 * the built-in syntax. For example you will often need the parentheses after &lt;code&gt;not&lt;/code&gt;, as shown above. (There's no penalty for
 * always surrounding custom matchers with parentheses, and if you ever leave them off when they are needed, you'll get a compiler error.)
 * For more information about how to create custom &lt;code&gt;Matcher&lt;/code&gt;s, please see the documentation for the &lt;a href=&quot;Matcher.html&quot;&gt;&lt;code&gt;Matcher&lt;/code&gt;&lt;/a&gt; trait.
 * &lt;/p&gt;
 *
 * &lt;h2&gt;Checking for expected exceptions&lt;/h2&gt;
 *
 * &lt;p&gt;
 * Sometimes you need to test whether a method throws an expected exception under certain circumstances, such
 * as when invalid arguments are passed to the method. With &lt;code&gt;ShouldMatchers&lt;/code&gt; mixed in, you can
 * check for an expected exception like this:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * evaluating { s.charAt(-1) } should produce [IndexOutOfBoundsException]
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * If &lt;code&gt;charAt&lt;/code&gt; throws an instance of &lt;code&gt;StringIndexOutOfBoundsException&lt;/code&gt;,
 * this expression will result in that exception. But if &lt;code&gt;charAt&lt;/code&gt; completes normally, or throws a different
 * exception, this expression will complete abruptly with a &lt;code&gt;TestFailedException&lt;/code&gt;.
 * This expression returns the caught exception so that you can inspect it further if you wish, for
 * example, to ensure that data contained inside the exception has the expected values. Here's an
 * example:
 * &lt;/p&gt;
 *
 * &lt;pre class=&quot;stHighlight&quot;&gt;
 * val thrown = evaluating { s.charAt(-1) } should produce [IndexOutOfBoundsException]
 * thrown.getMessage should equal (&quot;String index out of range: -1&quot;)
 * &lt;/pre&gt;
 *
 * &lt;h2&gt;Those pesky parens&lt;/h2&gt;
 * 
 * &lt;p&gt;
 * Perhaps the most tricky part of writing assertions using ScalaTest matchers is remembering
 * when you need or don't need parentheses, but bearing in mind a few simple rules &lt;!-- PRESERVE --&gt;should help.
 * It is also reassuring to know that if you ever leave off a set of parentheses when they are
 * required, your code will not compile. Thus the compiler will help you remember when you need the parens.
 * That said, the rules are:
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * 1. Although you don't always need them, it is recommended style to always put parentheses
 * around right-hand values, such as the &lt;code&gt;7&lt;/code&gt; in &lt;code&gt;num should equal (7)&lt;/code&gt;:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * result should equal &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;4&lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt;
 * array should have length &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;3&lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt;
 * book should have (
 *   'title &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;&quot;Programming in Scala&quot;&lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt;,
 *   'author &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;List(&quot;Odersky&quot;, &quot;Spoon&quot;, &quot;Venners&quot;)&lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt;,
 *   'pubYear &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;2008&lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt;
 * )
 * option should be &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;'defined&lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt;
 * catMap should (contain key &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;9&lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt; and contain value &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;&quot;lives&quot;&lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt;)&lt;/span&gt;
 * keyEvent should be an &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;'actionKey&lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt;
 * javaSet should have size &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;90&lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * 2. Except for &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;, you must always put parentheses around
 * the list of one or more property values following a &lt;code&gt;have&lt;/code&gt;:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * file should (exist and have &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;'name (&quot;temp.txt&quot;)&lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt;)
 * book should have &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;
 *   title (&quot;Programming in Scala&quot;),
 *   author (List(&quot;Odersky&quot;, &quot;Spoon&quot;, &quot;Venners&quot;)),
 *   pubYear (2008)
 * &lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt;
 * javaList should have length (9) // parens optional for length and size
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * 3. You must always put parentheses around &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; expressions, as in:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * catMap should &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;contain key (9) and contain value (&quot;lives&quot;)&lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt;
 * number should &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;equal (2) or equal (4) or equal (8)&lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt;
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * 4. Although you don't always need them, it is recommended style to always put parentheses
 * around custom &lt;code&gt;Matcher&lt;/code&gt;s when they appear directly after &lt;code&gt;not&lt;/code&gt;:
 * &lt;/p&gt;
 * 
 * &lt;pre&gt;
 * file should exist
 * file should not &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;exist&lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt;
 * file should (exist and have ('name (&quot;temp.txt&quot;)))
 * file should (not &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;exist&lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt; and have ('name (&quot;temp.txt&quot;))
 * file should (have ('name (&quot;temp.txt&quot;) or exist)
 * file should (have ('name (&quot;temp.txt&quot;) or not &lt;span class=&quot;stRed&quot;&gt;(&lt;/span&gt;exist&lt;span class=&quot;stRed&quot;&gt;)&lt;/span&gt;)
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * That's it. With a bit of practice it &lt;!-- PRESERVE --&gt;should become natural to you, and the compiler will always be there to tell you if you
 * forget a set of needed parentheses.
 * &lt;/p&gt;
 */</span>
<span class="keyword">trait</span> <a title="trait ShouldMatchers extends java.lang.Object with org.scalatest.matchers.Matchers with org.scalatest.verb.ShouldVerb with ScalaObject" id="12339">ShouldMatchers</a> <span title="ScalaObject" class="keyword">extends</span> <a href="Matchers.scala.html#12375" title="org.scalatest.matchers.Matchers">Matchers</a> <span class="keyword">with</span> <a href="../verb/ShouldVerb.scala.html#15166" title="org.scalatest.verb.ShouldVerb">ShouldVerb</a> <span class="delimiter">{</span>

  <span class="keyword">private</span> <span class="keyword">object</span> <a title="object ShouldMatchers.this.ShouldMethodHelper" id="77540">ShouldMethodHelper</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[T](left: T, rightMatcher: org.scalatest.matchers.Matcher[T])Unit" id="97882">shouldMatcher</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="97884">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="97886">left</a>: <a href="#97884" title="T">T</a>, <a title="org.scalatest.matchers.Matcher[T]" id="97887">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[T]">Matcher</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="Matcher.scala.html#78183" title="(left: T)org.scalatest.matchers.MatchResult">rightMatcher</a><span class="delimiter">(</span><a href="#97886" title="T">left</a><span class="delimiter">)</span> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="Nothing">MatchResult</span><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span>, <a title="String" id="97903">failureMessage</a>, _, _, _<span class="delimiter">)</span> =&gt; <span title="Nothing" class="keyword">throw</span> <a href="Matchers.scala.html#77312" title="(message: String)Throwable">newTestFailedException</a><span class="delimiter">(</span><a href="#97903" title="String">failureMessage</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Unit">_</span> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on objects of type &lt;code&gt;Any&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class AnyShouldWrapper[T] extends java.lang.Object with ScalaObject" id="77542">AnyShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77543">T</a><span class="delimiter">]</span><a href="#77542" title="ScalaObject" class="delimiter">(</a><a title="T" id="97906">left</a>: <a href="#77543" title="T">T</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * result should equal (3)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[T])Unit" id="77880">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[T]" id="97907">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[T]">Matcher</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: T, rightMatcher: org.scalatest.matchers.Matcher[T])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#97906" title="T">left</a>, <a href="#97907" title="org.scalatest.matchers.Matcher[T]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * result should not equal (3)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWord[T]" id="77881">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="97914">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span> = <span title="ShouldMatchers.this.ResultOfNotWord[T]" class="keyword">new</span> <a href="Matchers.scala.html#77397" title="ShouldMatchers.this.ResultOfNotWord[T]">ResultOfNotWord</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#97906" title="T">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// I think the type hasn't been converted yet here. It is just a pass-through. It finally gets</span>
  <span class="comment">// converted in ResultOfHaveWordForLengthWrapper, at which point the actual implicit conversions</span>
  <span class="comment">// from String, Array, and the structural types get applied.</span>
  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on &lt;code&gt;AnyRef&lt;/code&gt; objects that can be implicitly converted to type &lt;code&gt;LengthWrapper&lt;/code&gt;.
   * Trait &lt;code&gt;ShouldMatchers&lt;/code&gt; includes implicit conversions from several types, including many structural types, to &lt;code&gt;LengthWrapper&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class LengthShouldWrapper[A &lt;: AnyRef] extends java.lang.Object with ScalaObject" id="77544">LengthShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef" id="77545">A</a> &lt;: AnyRef &lt;% LengthWrapper<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="97922">left</a>: <a href="#77545" title="A">A</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * objectWithLength should equal (3)
     *                  ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[A])Unit" id="77751">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[A]" id="97924">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[A]">Matcher</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: A, rightMatcher: org.scalatest.matchers.Matcher[A])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#97922" title="A">left</a>, <a href="#97924" title="org.scalatest.matchers.Matcher[A]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * result should have length (3)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(haveWord: ShouldMatchers.this.HaveWord)ShouldMatchers.this.ResultOfHaveWordForLengthWrapper[A]" id="77752">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.HaveWord" id="97931">haveWord</a>: <a href="Matchers.scala.html#77363" title="ShouldMatchers.this.HaveWord">HaveWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77506" title="ShouldMatchers.this.ResultOfHaveWordForLengthWrapper[A]">ResultOfHaveWordForLengthWrapper</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
      <a href="#77749" title="ShouldMatchers.this.ResultOfHaveWordForLengthWrapper[A]" class="keyword">new</a> <a href="Matchers.scala.html#77506" title="ShouldMatchers.this.ResultOfHaveWordForLengthWrapper[A]">ResultOfHaveWordForLengthWrapper</a><span class="delimiter">(</span><a href="#97922" title="A">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * result should not have length (3)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForLengthWrapper[A]" id="77753">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98057">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77504" title="ShouldMatchers.this.ResultOfNotWordForLengthWrapper[A]">ResultOfNotWordForLengthWrapper</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
      <a href="#77749" title="ShouldMatchers.this.ResultOfNotWordForLengthWrapper[A]" class="keyword">new</a> <a href="Matchers.scala.html#77504" title="ShouldMatchers.this.ResultOfNotWordForLengthWrapper[A]">ResultOfNotWordForLengthWrapper</a><span class="delimiter">(</span><a href="#97922" title="A">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * result should be theSameInstanceAs anotherObject
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(beWord: ShouldMatchers.this.BeWord)ShouldMatchers.this.ResultOfBeWordForAnyRef[A]" id="77754">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.BeWord" id="98077">beWord</a>: <a href="Matchers.scala.html#77416" title="ShouldMatchers.this.BeWord">BeWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[A]">ResultOfBeWordForAnyRef</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span title="ShouldMatchers.this.ResultOfBeWordForAnyRef[A]" class="keyword">new</span> <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[A]">ResultOfBeWordForAnyRef</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span><a href="#97922" title="A">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on &lt;code&gt;AnyRef&lt;/code&gt; objects that can be implicitly converted to type &lt;code&gt;SizeWrapper&lt;/code&gt;.
   * Trait &lt;code&gt;ShouldMatchers&lt;/code&gt; includes implicit conversions from several types, including many structural types, to &lt;code&gt;SizeWrapper&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class SizeShouldWrapper[A &lt;: AnyRef] extends java.lang.Object with ScalaObject" id="77546">SizeShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef" id="77547">A</a> &lt;: AnyRef &lt;% SizeWrapper<span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="98084">left</a>: <a href="#77547" title="A">A</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * objectWithSize should equal (3)
     *                ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[A])Unit" id="77702">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[A]" id="98086">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[A]">Matcher</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: A, rightMatcher: org.scalatest.matchers.Matcher[A])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98084" title="A">left</a>, <a href="#98086" title="org.scalatest.matchers.Matcher[A]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * result should not have size (3)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForSizeWrapper[A]" id="77703">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98093">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77502" title="ShouldMatchers.this.ResultOfNotWordForSizeWrapper[A]">ResultOfNotWordForSizeWrapper</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
      <a href="#77700" title="ShouldMatchers.this.ResultOfNotWordForSizeWrapper[A]" class="keyword">new</a> <a href="Matchers.scala.html#77502" title="ShouldMatchers.this.ResultOfNotWordForSizeWrapper[A]">ResultOfNotWordForSizeWrapper</a><span class="delimiter">(</span><a href="#98084" title="A">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * result should have size (3)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(haveWord: ShouldMatchers.this.HaveWord)ShouldMatchers.this.ResultOfHaveWordForSizeWrapper[A]" id="77704">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.HaveWord" id="98113">haveWord</a>: <a href="Matchers.scala.html#77363" title="ShouldMatchers.this.HaveWord">HaveWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77508" title="ShouldMatchers.this.ResultOfHaveWordForSizeWrapper[A]">ResultOfHaveWordForSizeWrapper</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
      <a href="#77700" title="ShouldMatchers.this.ResultOfHaveWordForSizeWrapper[A]" class="keyword">new</a> <a href="Matchers.scala.html#77508" title="ShouldMatchers.this.ResultOfHaveWordForSizeWrapper[A]">ResultOfHaveWordForSizeWrapper</a><span class="delimiter">(</span><a href="#98084" title="A">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

    <span class="comment">// TODO I just added this. Didn't do a test for it.</span>
    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * result should be theSameInstanceAs anotherObject
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(beWord: ShouldMatchers.this.BeWord)ShouldMatchers.this.ResultOfBeWordForAnyRef[A]" id="77705">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.BeWord" id="98133">beWord</a>: <a href="Matchers.scala.html#77416" title="ShouldMatchers.this.BeWord">BeWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[A]">ResultOfBeWordForAnyRef</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span title="ShouldMatchers.this.ResultOfBeWordForAnyRef[A]" class="keyword">new</span> <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[A]">ResultOfBeWordForAnyRef</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span><a href="#98084" title="A">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on &lt;code&gt;String&lt;/code&gt;s.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class StringShouldWrapper extends ShouldMatchers.this.StringShouldWrapperForVerb with ScalaObject" id="77548">StringShouldWrapper</a><a href="#77548" title="ScalaObject" class="delimiter">(</a><a title="String" id="98139">left</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="../verb/ShouldVerb.scala.html#42932" title="ShouldMatchers.this.StringShouldWrapperForVerb">StringShouldWrapperForVerb</a><span class="delimiter">(</span><a href="#98139" title="String">left</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/* *
     * This method enables syntax such as the following in a &lt;code&gt;FlatSpec&lt;/code&gt;:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * &quot;A Stack (when empty)&quot; should &quot;be empty&quot; in {
     *   assert(emptyStack.empty)
     * }
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * &lt;code&gt;FlatSpec&lt;/code&gt; passes in a function via the implicit parameter that takes
     * three strings and results in a &lt;code&gt;ResultOfStringPassedToVerb&lt;/code&gt;. This method
     * simply invokes this function, passing in left, right, and the verb string
     * &lt;code&gt;&quot;should&quot;&lt;/code&gt;.
     * &lt;/p&gt;
     *
    def should(right: String)(implicit fun: (String, String, String) =&gt; ResultOfStringPassedToVerb): ResultOfStringPassedToVerb = {
      fun(left, right, &quot;should&quot;)
    }

    def should(right: =&gt; Unit)(implicit fun: (String, () =&gt; Unit, String) =&gt; Unit) {
      fun(left, right _, &quot;should&quot;)
    }     */</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * string should equal (&quot;hi&quot;)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[String])Unit" id="97975">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[String]" id="98141">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[String]">Matcher</a><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: String, rightMatcher: org.scalatest.matchers.Matcher[String])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98139" title="String">left</a>, <a href="#98141" title="org.scalatest.matchers.Matcher[String]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * string should be theSameInstanceAs anotherObject
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(beWord: ShouldMatchers.this.BeWord)ShouldMatchers.this.ResultOfBeWordForAnyRef[String]" id="97976">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.BeWord" id="98161">beWord</a>: <a href="Matchers.scala.html#77416" title="ShouldMatchers.this.BeWord">BeWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[String]">ResultOfBeWordForAnyRef</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span title="ShouldMatchers.this.ResultOfBeWordForAnyRef[String]" class="keyword">new</span> <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[String]">ResultOfBeWordForAnyRef</a><span class="delimiter">(</span><a href="#98139" title="String">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * string should have length (3)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(haveWord: ShouldMatchers.this.HaveWord)ShouldMatchers.this.ResultOfHaveWordForString" id="97977">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.HaveWord" id="98169">haveWord</a>: <a href="Matchers.scala.html#77363" title="ShouldMatchers.this.HaveWord">HaveWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77410" title="ShouldMatchers.this.ResultOfHaveWordForString">ResultOfHaveWordForString</a> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfHaveWordForString" class="keyword">new</span> <a href="Matchers.scala.html#77410" title="ShouldMatchers.this.ResultOfHaveWordForString">ResultOfHaveWordForString</a><span class="delimiter">(</span><a href="#98139" title="String">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * string should include regex (&quot;hi&quot;)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(includeWord: ShouldMatchers.this.IncludeWord)ShouldMatchers.this.ResultOfIncludeWordForString" id="97978">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.IncludeWord" id="98172">includeWord</a>: <a href="Matchers.scala.html#77339" title="ShouldMatchers.this.IncludeWord">IncludeWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77411" title="ShouldMatchers.this.ResultOfIncludeWordForString">ResultOfIncludeWordForString</a> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfIncludeWordForString" class="keyword">new</span> <a href="Matchers.scala.html#77411" title="ShouldMatchers.this.ResultOfIncludeWordForString">ResultOfIncludeWordForString</a><span class="delimiter">(</span><a href="#98139" title="String">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * string should startWith regex (&quot;hello&quot;)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(startWithWord: ShouldMatchers.this.StartWithWord)ShouldMatchers.this.ResultOfStartWithWordForString" id="97979">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.StartWithWord" id="98175">startWithWord</a>: <a href="Matchers.scala.html#77340" title="ShouldMatchers.this.StartWithWord">StartWithWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77412" title="ShouldMatchers.this.ResultOfStartWithWordForString">ResultOfStartWithWordForString</a> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfStartWithWordForString" class="keyword">new</span> <a href="Matchers.scala.html#77412" title="ShouldMatchers.this.ResultOfStartWithWordForString">ResultOfStartWithWordForString</a><span class="delimiter">(</span><a href="#98139" title="String">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * string should endWith regex (&quot;world&quot;)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(endWithWord: ShouldMatchers.this.EndWithWord)ShouldMatchers.this.ResultOfEndWithWordForString" id="97980">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.EndWithWord" id="98178">endWithWord</a>: <a href="Matchers.scala.html#77341" title="ShouldMatchers.this.EndWithWord">EndWithWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77413" title="ShouldMatchers.this.ResultOfEndWithWordForString">ResultOfEndWithWordForString</a> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfEndWithWordForString" class="keyword">new</span> <a href="Matchers.scala.html#77413" title="ShouldMatchers.this.ResultOfEndWithWordForString">ResultOfEndWithWordForString</a><span class="delimiter">(</span><a href="#98139" title="String">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * string should fullyMatch regex (&quot;&quot;&quot;(-)?(\d+)(\.\d*)?&quot;&quot;&quot;)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(fullyMatchWord: ShouldMatchers.this.FullyMatchWord)ShouldMatchers.this.ResultOfFullyMatchWordForString" id="97981">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.FullyMatchWord" id="98181">fullyMatchWord</a>: <a href="Matchers.scala.html#77342" title="ShouldMatchers.this.FullyMatchWord">FullyMatchWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77414" title="ShouldMatchers.this.ResultOfFullyMatchWordForString">ResultOfFullyMatchWordForString</a> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfFullyMatchWordForString" class="keyword">new</span> <a href="Matchers.scala.html#77414" title="ShouldMatchers.this.ResultOfFullyMatchWordForString">ResultOfFullyMatchWordForString</a><span class="delimiter">(</span><a href="#98139" title="String">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * string should not have length (3)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForString" id="97982">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98184">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77401" title="ShouldMatchers.this.ResultOfNotWordForString">ResultOfNotWordForString</a> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfNotWordForString" class="keyword">new</span> <a href="Matchers.scala.html#77401" title="ShouldMatchers.this.ResultOfNotWordForString">ResultOfNotWordForString</a><span class="delimiter">(</span><a href="#98139" title="String">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on &lt;code&gt;Double&lt;/code&gt;s.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class DoubleShouldWrapper extends java.lang.Object with ScalaObject" id="77549">DoubleShouldWrapper</a><a href="#77549" title="ScalaObject" class="delimiter">(</a><a title="Double" id="98189">left</a>: <span title="Double">Double</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * aDouble should equal (8.8)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[Double])Unit" id="98040">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[Double]" id="98190">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[Double]">Matcher</a><span class="delimiter">[</span>Double<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: Double, rightMatcher: org.scalatest.matchers.Matcher[Double])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98189" title="Double">left</a>, <a href="#98190" title="org.scalatest.matchers.Matcher[Double]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * result should not equal (8.8)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForDouble" id="98041">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98197">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77402" title="ShouldMatchers.this.ResultOfNotWordForDouble">ResultOfNotWordForDouble</a> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfNotWordForDouble" class="keyword">new</span> <a href="Matchers.scala.html#77402" title="ShouldMatchers.this.ResultOfNotWordForDouble">ResultOfNotWordForDouble</a><span class="delimiter">(</span><a href="#98189" title="Double">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on &lt;code&gt;Float&lt;/code&gt;s.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class FloatShouldWrapper extends java.lang.Object with ScalaObject" id="77550">FloatShouldWrapper</a><a href="#77550" title="ScalaObject" class="delimiter">(</a><a title="Float" id="98201">left</a>: <span title="Float">Float</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * aFloat should equal (3.3f)
     *       ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[Float])Unit" id="98035">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[Float]" id="98202">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[Float]">Matcher</a><span class="delimiter">[</span>Float<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: Float, rightMatcher: org.scalatest.matchers.Matcher[Float])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98201" title="Float">left</a>, <a href="#98202" title="org.scalatest.matchers.Matcher[Float]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * result should not equal (8.8f)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForFloat" id="98036">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98209">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77403" title="ShouldMatchers.this.ResultOfNotWordForFloat">ResultOfNotWordForFloat</a> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfNotWordForFloat" class="keyword">new</span> <a href="Matchers.scala.html#77403" title="ShouldMatchers.this.ResultOfNotWordForFloat">ResultOfNotWordForFloat</a><span class="delimiter">(</span><a href="#98201" title="Float">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on &lt;code&gt;Long&lt;/code&gt;s.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class LongShouldWrapper extends java.lang.Object with ScalaObject" id="77551">LongShouldWrapper</a><a href="#77551" title="ScalaObject" class="delimiter">(</a><a title="Long" id="98213">left</a>: <span title="Long">Long</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * aLong should equal (3L)
     *      ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[Long])Unit" id="98030">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[Long]" id="98214">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[Long]">Matcher</a><span class="delimiter">[</span>Long<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: Long, rightMatcher: org.scalatest.matchers.Matcher[Long])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98213" title="Long">left</a>, <a href="#98214" title="org.scalatest.matchers.Matcher[Long]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * result should not equal (88L)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForLong" id="98031">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98221">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77404" title="ShouldMatchers.this.ResultOfNotWordForLong">ResultOfNotWordForLong</a> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfNotWordForLong" class="keyword">new</span> <a href="Matchers.scala.html#77404" title="ShouldMatchers.this.ResultOfNotWordForLong">ResultOfNotWordForLong</a><span class="delimiter">(</span><a href="#98213" title="Long">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on &lt;code&gt;Int&lt;/code&gt;s.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class IntShouldWrapper extends java.lang.Object with ScalaObject" id="77552">IntShouldWrapper</a><a href="#77552" title="ScalaObject" class="delimiter">(</a><a title="Int" id="98225">left</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * anInt should equal (3)
     *      ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[Int])Unit" id="98025">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[Int]" id="98226">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[Int]">Matcher</a><span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: Int, rightMatcher: org.scalatest.matchers.Matcher[Int])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98225" title="Int">left</a>, <a href="#98226" title="org.scalatest.matchers.Matcher[Int]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * result should not equal (8)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForInt" id="98026">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98233">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77405" title="ShouldMatchers.this.ResultOfNotWordForInt">ResultOfNotWordForInt</a> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfNotWordForInt" class="keyword">new</span> <a href="Matchers.scala.html#77405" title="ShouldMatchers.this.ResultOfNotWordForInt">ResultOfNotWordForInt</a><span class="delimiter">(</span><a href="#98225" title="Int">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on &lt;code&gt;Short&lt;/code&gt;s.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class ShortShouldWrapper extends java.lang.Object with ScalaObject" id="77553">ShortShouldWrapper</a><a href="#77553" title="ScalaObject" class="delimiter">(</a><a title="Short" id="98237">left</a>: <span title="Short">Short</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * aShort should equal (3.toShort)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[Short])Unit" id="98020">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[Short]" id="98238">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[Short]">Matcher</a><span class="delimiter">[</span>Short<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: Short, rightMatcher: org.scalatest.matchers.Matcher[Short])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98237" title="Short">left</a>, <a href="#98238" title="org.scalatest.matchers.Matcher[Short]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * result should not equal (8.toShort)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForShort" id="98021">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98245">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77406" title="ShouldMatchers.this.ResultOfNotWordForShort">ResultOfNotWordForShort</a> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfNotWordForShort" class="keyword">new</span> <a href="Matchers.scala.html#77406" title="ShouldMatchers.this.ResultOfNotWordForShort">ResultOfNotWordForShort</a><span class="delimiter">(</span><a href="#98237" title="Short">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on &lt;code&gt;Byte&lt;/code&gt;s.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class ByteShouldWrapper extends java.lang.Object with ScalaObject" id="77554">ByteShouldWrapper</a><a href="#77554" title="ScalaObject" class="delimiter">(</a><a title="Byte" id="98249">left</a>: <span title="Byte">Byte</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * aByte should equal (3.toByte)
     *       ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[Byte])Unit" id="98015">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[Byte]" id="98250">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[Byte]">Matcher</a><span class="delimiter">[</span>Byte<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: Byte, rightMatcher: org.scalatest.matchers.Matcher[Byte])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98249" title="Byte">left</a>, <a href="#98250" title="org.scalatest.matchers.Matcher[Byte]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * result should not equal (8.toByte)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForByte" id="98016">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98257">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77407" title="ShouldMatchers.this.ResultOfNotWordForByte">ResultOfNotWordForByte</a> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfNotWordForByte" class="keyword">new</span> <a href="Matchers.scala.html#77407" title="ShouldMatchers.this.ResultOfNotWordForByte">ResultOfNotWordForByte</a><span class="delimiter">(</span><a href="#98249" title="Byte">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on objects of type &lt;code&gt;scala.collection.Map[K, V]&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class MapShouldWrapper[K, V] extends java.lang.Object with ScalaObject" id="77555">MapShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77556">K</a>, <a title="&gt;: Nothing &lt;: Any" id="77557">V</a><span class="delimiter">]</span><a href="#77555" title="ScalaObject" class="delimiter">(</a><a title="scala.collection.Map[K,V]" id="98261">left</a>: scala.collection.<span title="scala.collection.Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * map should equal (Map(1 -&gt; &quot;one&quot;, 2 -&gt; &quot;two&quot;))
     *     ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[scala.collection.Map[K,V]])Unit" id="97986">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[scala.collection.Map[K,V]]" id="98262">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[scala.collection.Map[K,V]]">Matcher</a><span class="delimiter">[</span>scala.collection.Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: scala.collection.Map[K,V], rightMatcher: org.scalatest.matchers.Matcher[scala.collection.Map[K,V]])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98261" title="scala.collection.Map[K,V]">left</a>, <a href="#98262" title="org.scalatest.matchers.Matcher[scala.collection.Map[K,V]]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * map should be theSameInstanceAs (anotherMap)
     *     ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(beWord: ShouldMatchers.this.BeWord)ShouldMatchers.this.ResultOfBeWordForAnyRef[scala.collection.Map[K,V]]" id="97987">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.BeWord" id="98278">beWord</a>: <a href="Matchers.scala.html#77416" title="ShouldMatchers.this.BeWord">BeWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[scala.collection.Map[K,V]]">ResultOfBeWordForAnyRef</a><span class="delimiter">[</span>scala.collection.Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="ShouldMatchers.this.ResultOfBeWordForAnyRef[scala.collection.Map[K,V]]" class="keyword">new</span> <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[scala.collection.Map[K,V]]">ResultOfBeWordForAnyRef</a><span class="delimiter">(</span><a href="#98261" title="scala.collection.Map[K,V]">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * map should have size (3)
     *     ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(haveWord: ShouldMatchers.this.HaveWord)ShouldMatchers.this.ResultOfHaveWordForTraversable[(K, V)]" id="97988">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.HaveWord" id="98285">haveWord</a>: <a href="Matchers.scala.html#77363" title="ShouldMatchers.this.HaveWord">HaveWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77364" title="ShouldMatchers.this.ResultOfHaveWordForTraversable[(K, V)]">ResultOfHaveWordForTraversable</a><span class="delimiter">[</span><span class="delimiter">(</span>K, V<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfHaveWordForTraversable[(K, V)]" class="keyword">new</span> <a href="Matchers.scala.html#77364" title="ShouldMatchers.this.ResultOfHaveWordForTraversable[(K, V)]">ResultOfHaveWordForTraversable</a><span class="delimiter">(</span><a href="#98261" title="scala.collection.Map[K,V]">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * map should contain key (10)
     *     ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(containWord: ShouldMatchers.this.ContainWord)ShouldMatchers.this.ResultOfContainWordForMap[K,V]" id="97989">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.ContainWord" id="98294">containWord</a>: <a href="Matchers.scala.html#77338" title="ShouldMatchers.this.ContainWord">ContainWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77321" title="ShouldMatchers.this.ResultOfContainWordForMap[K,V]">ResultOfContainWordForMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfContainWordForMap[K,V]" class="keyword">new</span> <a href="Matchers.scala.html#77321" title="ShouldMatchers.this.ResultOfContainWordForMap[K,V]">ResultOfContainWordForMap</a><span class="delimiter">(</span><a href="#98261" title="scala.collection.Map[K,V]">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * map should not have size (3)
     *     ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForMap[K,V]" id="97990">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98311">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77379" title="ShouldMatchers.this.ResultOfNotWordForMap[K,V]">ResultOfNotWordForMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfNotWordForMap[K,V]" class="keyword">new</span> <a href="Matchers.scala.html#77379" title="ShouldMatchers.this.ResultOfNotWordForMap[K,V]">ResultOfNotWordForMap</a><span class="delimiter">(</span><a href="#98261" title="scala.collection.Map[K,V]">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on &lt;code&gt;AnyRef&lt;/code&gt;s.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class AnyRefShouldWrapper[T &lt;: AnyRef] extends java.lang.Object with ScalaObject" id="77558">AnyRefShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef" id="77559">T</a> &lt;: AnyRef<span class="delimiter">]</span><a href="#77558" title="ScalaObject" class="delimiter">(</a><a title="T" id="98330">left</a>: <a href="#77559" title="T">T</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * anyRef should equal (anotherObject)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[T])Unit" id="77859">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[T]" id="98331">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[T]">Matcher</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: T, rightMatcher: org.scalatest.matchers.Matcher[T])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98330" title="T">left</a>, <a href="#98331" title="org.scalatest.matchers.Matcher[T]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * result should not have length (3)
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForAnyRef[T]" id="77860">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98338">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77399" title="ShouldMatchers.this.ResultOfNotWordForAnyRef[T]">ResultOfNotWordForAnyRef</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
      <span title="ShouldMatchers.this.ResultOfNotWordForAnyRef[T]" class="keyword">new</span> <a href="Matchers.scala.html#77399" title="ShouldMatchers.this.ResultOfNotWordForAnyRef[T]">ResultOfNotWordForAnyRef</a><span class="delimiter">(</span><a href="#98330" title="T">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * result should be theSameInstanceAs anotherObject
     *        ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(beWord: ShouldMatchers.this.BeWord)ShouldMatchers.this.ResultOfBeWordForAnyRef[T]" id="77861">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.BeWord" id="98345">beWord</a>: <a href="Matchers.scala.html#77416" title="ShouldMatchers.this.BeWord">BeWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[T]">ResultOfBeWordForAnyRef</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="ShouldMatchers.this.ResultOfBeWordForAnyRef[T]" class="keyword">new</span> <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[T]">ResultOfBeWordForAnyRef</a><span class="delimiter">(</span><a href="#98330" title="T">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on objects of type &lt;code&gt;scala.Collection[T]&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class TraversableShouldWrapper[T] extends java.lang.Object with ScalaObject" id="77560">TraversableShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77561">T</a><span class="delimiter">]</span><a href="#77560" title="ScalaObject" class="delimiter">(</a><a title="Traversable[T]" id="98354">left</a>: <span title="Traversable[T]">Traversable</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * traversable should equal (Set(1, 2, 3))
     *             ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[Traversable[T]])Unit" id="98008">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[Traversable[T]]" id="98355">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[Traversable[T]]">Matcher</a><span class="delimiter">[</span>Traversable<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: Traversable[T], rightMatcher: org.scalatest.matchers.Matcher[Traversable[T]])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98354" title="Traversable[T]">left</a>, <a href="#98355" title="org.scalatest.matchers.Matcher[Traversable[T]]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * traversable should have size (3)
     *             ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(haveWord: ShouldMatchers.this.HaveWord)ShouldMatchers.this.ResultOfHaveWordForTraversable[T]" id="98009">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.HaveWord" id="98364">haveWord</a>: <a href="Matchers.scala.html#77363" title="ShouldMatchers.this.HaveWord">HaveWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77364" title="ShouldMatchers.this.ResultOfHaveWordForTraversable[T]">ResultOfHaveWordForTraversable</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = 
      <span title="ShouldMatchers.this.ResultOfHaveWordForTraversable[T]" class="keyword">new</span> <a href="Matchers.scala.html#77364" title="ShouldMatchers.this.ResultOfHaveWordForTraversable[T]">ResultOfHaveWordForTraversable</a><span class="delimiter">(</span><a href="#98354" title="Traversable[T]">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * traversable should be theSameInstanceAs anotherObject
     *             ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(beWord: ShouldMatchers.this.BeWord)ShouldMatchers.this.ResultOfBeWordForAnyRef[Traversable[T]]" id="98010">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.BeWord" id="98373">beWord</a>: <a href="Matchers.scala.html#77416" title="ShouldMatchers.this.BeWord">BeWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[Traversable[T]]">ResultOfBeWordForAnyRef</a><span class="delimiter">[</span>Traversable<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="ShouldMatchers.this.ResultOfBeWordForAnyRef[Traversable[T]]" class="keyword">new</span> <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[Traversable[T]]">ResultOfBeWordForAnyRef</a><span class="delimiter">(</span><a href="#98354" title="Traversable[T]">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * traversable should not have size (3)
     *             ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForTraversable[T,Traversable[T]]" id="98011">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98380">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77373" title="ShouldMatchers.this.ResultOfNotWordForTraversable[T,Traversable[T]]">ResultOfNotWordForTraversable</a><span class="delimiter">[</span>T, Traversable<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span title="ShouldMatchers.this.ResultOfNotWordForTraversable[T,Traversable[T]]" class="keyword">new</span> <a href="Matchers.scala.html#77373" title="ShouldMatchers.this.ResultOfNotWordForTraversable[T,Traversable[T]]">ResultOfNotWordForTraversable</a><span class="delimiter">(</span><a href="#98354" title="Traversable[T]">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on objects of type &lt;code&gt;java.util.Collection[T]&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class JavaCollectionShouldWrapper[T] extends java.lang.Object with ScalaObject" id="77562">JavaCollectionShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77563">T</a><span class="delimiter">]</span><a href="#77562" title="ScalaObject" class="delimiter">(</a><a title="java.util.Collection[T]" id="98392">left</a>: java.util.<span title="java.util.Collection[T]">Collection</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * javaCollection should equal (aJavaSet)
     *                ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[java.util.Collection[T]])Unit" id="97961">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[java.util.Collection[T]]" id="98393">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[java.util.Collection[T]]">Matcher</a><span class="delimiter">[</span>java.util.Collection<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: java.util.Collection[T], rightMatcher: org.scalatest.matchers.Matcher[java.util.Collection[T]])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98392" title="java.util.Collection[T]">left</a>, <a href="#98393" title="org.scalatest.matchers.Matcher[java.util.Collection[T]]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * javaCollection should have size (3)
     *                ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(haveWord: ShouldMatchers.this.HaveWord)ShouldMatchers.this.ResultOfHaveWordForJavaCollection[T]" id="97962">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.HaveWord" id="98400">haveWord</a>: <a href="Matchers.scala.html#77363" title="ShouldMatchers.this.HaveWord">HaveWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77366" title="ShouldMatchers.this.ResultOfHaveWordForJavaCollection[T]">ResultOfHaveWordForJavaCollection</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
      <span title="ShouldMatchers.this.ResultOfHaveWordForJavaCollection[T]" class="keyword">new</span> <a href="Matchers.scala.html#77366" title="ShouldMatchers.this.ResultOfHaveWordForJavaCollection[T]">ResultOfHaveWordForJavaCollection</a><span class="delimiter">(</span><a href="#98392" title="java.util.Collection[T]">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * javaCollection should be theSameInstanceAs anotherObject
     *                ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(beWord: ShouldMatchers.this.BeWord)ShouldMatchers.this.ResultOfBeWordForAnyRef[java.util.Collection[T]]" id="97963">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.BeWord" id="98407">beWord</a>: <a href="Matchers.scala.html#77416" title="ShouldMatchers.this.BeWord">BeWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[java.util.Collection[T]]">ResultOfBeWordForAnyRef</a><span class="delimiter">[</span>java.util.Collection<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="ShouldMatchers.this.ResultOfBeWordForAnyRef[java.util.Collection[T]]" class="keyword">new</span> <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[java.util.Collection[T]]">ResultOfBeWordForAnyRef</a><span class="delimiter">(</span><a href="#98392" title="java.util.Collection[T]">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * javaCollection should not have size (3)
     *                ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForJavaCollection[T,java.util.Collection[T]]" id="97964">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98414">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77376" title="ShouldMatchers.this.ResultOfNotWordForJavaCollection[T,java.util.Collection[T]]">ResultOfNotWordForJavaCollection</a><span class="delimiter">[</span>T, java.util.Collection<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span title="ShouldMatchers.this.ResultOfNotWordForJavaCollection[T,java.util.Collection[T]]" class="keyword">new</span> <a href="Matchers.scala.html#77376" title="ShouldMatchers.this.ResultOfNotWordForJavaCollection[T,java.util.Collection[T]]">ResultOfNotWordForJavaCollection</a><span class="delimiter">(</span><a href="#98392" title="java.util.Collection[T]">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on objects of type &lt;code&gt;java.util.Map[K, V]&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class JavaMapShouldWrapper[K, V] extends java.lang.Object with ScalaObject" id="77564">JavaMapShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77565">K</a>, <a title="&gt;: Nothing &lt;: Any" id="77566">V</a><span class="delimiter">]</span><a href="#77564" title="ScalaObject" class="delimiter">(</a><a title="java.util.Map[K,V]" id="98424">left</a>: java.util.<span title="java.util.Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * javaMap should equal (someJavaMap)
     *         ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[java.util.Map[K,V]])Unit" id="97947">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[java.util.Map[K,V]]" id="98425">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[java.util.Map[K,V]]">Matcher</a><span class="delimiter">[</span>java.util.Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: java.util.Map[K,V], rightMatcher: org.scalatest.matchers.Matcher[java.util.Map[K,V]])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98424" title="java.util.Map[K,V]">left</a>, <a href="#98425" title="org.scalatest.matchers.Matcher[java.util.Map[K,V]]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * javaMap should contain value (3)
     *         ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(containWord: ShouldMatchers.this.ContainWord)ShouldMatchers.this.ResultOfContainWordForJavaMap[K,V]" id="97948">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.ContainWord" id="98432">containWord</a>: <a href="Matchers.scala.html#77338" title="ShouldMatchers.this.ContainWord">ContainWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77324" title="ShouldMatchers.this.ResultOfContainWordForJavaMap[K,V]">ResultOfContainWordForJavaMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfContainWordForJavaMap[K,V]" class="keyword">new</span> <a href="Matchers.scala.html#77324" title="ShouldMatchers.this.ResultOfContainWordForJavaMap[K,V]">ResultOfContainWordForJavaMap</a><span class="delimiter">(</span><a href="#98424" title="java.util.Map[K,V]">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
 
    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * javaMap should have size (3)
     *         ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(haveWord: ShouldMatchers.this.HaveWord)ShouldMatchers.this.ResultOfHaveWordForJavaMap" id="97949">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.HaveWord" id="98440">haveWord</a>: <a href="Matchers.scala.html#77363" title="ShouldMatchers.this.HaveWord">HaveWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77368" title="ShouldMatchers.this.ResultOfHaveWordForJavaMap">ResultOfHaveWordForJavaMap</a> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfHaveWordForJavaMap" class="keyword">new</span> <a href="Matchers.scala.html#77368" title="ShouldMatchers.this.ResultOfHaveWordForJavaMap">ResultOfHaveWordForJavaMap</a><span class="delimiter">(</span><a href="#98424" title="java.util.Map[K,V]">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * javaMap should not have length (3)
     *         ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForJavaMap[K,V]" id="97950">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98444">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77382" title="ShouldMatchers.this.ResultOfNotWordForJavaMap[K,V]">ResultOfNotWordForJavaMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfNotWordForJavaMap[K,V]" class="keyword">new</span> <a href="Matchers.scala.html#77382" title="ShouldMatchers.this.ResultOfNotWordForJavaMap[K,V]">ResultOfNotWordForJavaMap</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">(</span><a href="#98424" title="java.util.Map[K,V]">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * javaMap should be theSameInstanceAs anotherObject
     *         ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(beWord: ShouldMatchers.this.BeWord)ShouldMatchers.this.ResultOfBeWordForAnyRef[java.util.Map[K,V]]" id="97951">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.BeWord" id="98448">beWord</a>: <a href="Matchers.scala.html#77416" title="ShouldMatchers.this.BeWord">BeWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[java.util.Map[K,V]]">ResultOfBeWordForAnyRef</a><span class="delimiter">[</span>java.util.Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="ShouldMatchers.this.ResultOfBeWordForAnyRef[java.util.Map[K,V]]" class="keyword">new</span> <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[java.util.Map[K,V]]">ResultOfBeWordForAnyRef</a><span class="delimiter">(</span><a href="#98424" title="java.util.Map[K,V]">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on objects of type &lt;code&gt;scala.Seq[T]&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class SeqShouldWrapper[T] extends java.lang.Object with ScalaObject" id="77567">SeqShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77568">T</a><span class="delimiter">]</span><a href="#77567" title="ScalaObject" class="delimiter">(</a><a title="Seq[T]" id="98457">left</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
 
    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * seq should equal (List(1, 2, 3))
     *     ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[Seq[T]])Unit" id="98001">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[Seq[T]]" id="98458">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[Seq[T]]">Matcher</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: Seq[T], rightMatcher: org.scalatest.matchers.Matcher[Seq[T]])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98457" title="Seq[T]">left</a>, <a href="#98458" title="org.scalatest.matchers.Matcher[Seq[T]]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * seq should have length (3)
     *     ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(haveWord: ShouldMatchers.this.HaveWord)ShouldMatchers.this.ResultOfHaveWordForSeq[T]" id="98002">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.HaveWord" id="98474">haveWord</a>: <a href="Matchers.scala.html#77363" title="ShouldMatchers.this.HaveWord">HaveWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77369" title="ShouldMatchers.this.ResultOfHaveWordForSeq[T]">ResultOfHaveWordForSeq</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
      <span title="ShouldMatchers.this.ResultOfHaveWordForSeq[T]" class="keyword">new</span> <a href="Matchers.scala.html#77369" title="ShouldMatchers.this.ResultOfHaveWordForSeq[T]">ResultOfHaveWordForSeq</a><span class="delimiter">(</span><a href="#98457" title="Seq[T]">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

<span class="comment">/* TODO: This is what I think it should be. But it was the AnyRef one, or maybe even not that.
    def should(notWord: NotWord): ResultOfNotWordForSeq[T, List[T]] =
      new ResultOfNotWordForSeq(left, false)
*/</span>
    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * seq should not have length (3)
     *     ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForAnyRef[Seq[T]]" id="98003">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98490">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77399" title="ShouldMatchers.this.ResultOfNotWordForAnyRef[Seq[T]]">ResultOfNotWordForAnyRef</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span title="ShouldMatchers.this.ResultOfNotWordForAnyRef[Seq[T]]" class="keyword">new</span> <a href="Matchers.scala.html#77399" title="ShouldMatchers.this.ResultOfNotWordForAnyRef[Seq[T]]">ResultOfNotWordForAnyRef</a><span class="delimiter">(</span><a href="#98457" title="Seq[T]">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * seq should be theSameInstanceAs anotherObject
     *     ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(beWord: ShouldMatchers.this.BeWord)ShouldMatchers.this.ResultOfBeWordForAnyRef[Seq[T]]" id="98004">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.BeWord" id="98497">beWord</a>: <a href="Matchers.scala.html#77416" title="ShouldMatchers.this.BeWord">BeWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[Seq[T]]">ResultOfBeWordForAnyRef</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="ShouldMatchers.this.ResultOfBeWordForAnyRef[Seq[T]]" class="keyword">new</span> <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[Seq[T]]">ResultOfBeWordForAnyRef</a><span class="delimiter">(</span><a href="#98457" title="Seq[T]">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on objects of type &lt;code&gt;scala.Array[T]&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class ArrayShouldWrapper[T] extends java.lang.Object with ScalaObject" id="77569">ArrayShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77570">T</a><span class="delimiter">]</span><a href="#77569" title="ScalaObject" class="delimiter">(</a><a title="Array[T]" id="98506">left</a>: <span title="Array[T]">Array</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * array should equal (Array(&quot;one&quot;, &quot;two&quot;))
     *       ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[Array[T]])Unit" id="79761">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[Array[T]]" id="98507">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[Array[T]]">Matcher</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: Array[T], rightMatcher: org.scalatest.matchers.Matcher[Array[T]])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98506" title="Array[T]">left</a>, <a href="#98507" title="org.scalatest.matchers.Matcher[Array[T]]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * array should have length (3)
     *       ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(haveWord: ShouldMatchers.this.HaveWord)ShouldMatchers.this.ResultOfHaveWordForSeq[T]" id="79762">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.HaveWord" id="98514">haveWord</a>: <a href="Matchers.scala.html#77363" title="ShouldMatchers.this.HaveWord">HaveWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77369" title="ShouldMatchers.this.ResultOfHaveWordForSeq[T]">ResultOfHaveWordForSeq</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfHaveWordForSeq[T]" class="keyword">new</span> <a href="Matchers.scala.html#77369" title="ShouldMatchers.this.ResultOfHaveWordForSeq[T]">ResultOfHaveWordForSeq</a><span class="delimiter">(</span><a href="#98506" title="(xs: Array[T])scala.collection.mutable.WrappedArray[T]">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * array should not have length (3)
     *       ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForArray[T]" id="79763">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98550">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77388" title="ShouldMatchers.this.ResultOfNotWordForArray[T]">ResultOfNotWordForArray</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
      <span title="ShouldMatchers.this.ResultOfNotWordForArray[T]" class="keyword">new</span> <a href="Matchers.scala.html#77388" title="ShouldMatchers.this.ResultOfNotWordForArray[T]">ResultOfNotWordForArray</a><span class="delimiter">(</span><a href="#98506" title="Array[T]">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">// Note, no should(beWord) is needed here because a different implicit conversion will be used</span>
  <span class="comment">// on &quot;array shoudl be ...&quot; because this one doesn't solve the type error.</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on objects of type &lt;code&gt;scala.List[T]&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class ListShouldWrapper[T] extends java.lang.Object with ScalaObject" id="77571">ListShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77572">T</a><span class="delimiter">]</span><a href="#77571" title="ScalaObject" class="delimiter">(</a><a title="List[T]" id="98559">left</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * list should equal (List(1, 2, 3))
     *      ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[List[T]])Unit" id="97994">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[List[T]]" id="98560">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[List[T]]">Matcher</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: List[T], rightMatcher: org.scalatest.matchers.Matcher[List[T]])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98559" title="List[T]">left</a>, <a href="#98560" title="org.scalatest.matchers.Matcher[List[T]]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * list should be theSameInstanceAs anotherObject
     *      ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(beWord: ShouldMatchers.this.BeWord)ShouldMatchers.this.ResultOfBeWordForAnyRef[List[T]]" id="97995">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.BeWord" id="98573">beWord</a>: <a href="Matchers.scala.html#77416" title="ShouldMatchers.this.BeWord">BeWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[List[T]]">ResultOfBeWordForAnyRef</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="ShouldMatchers.this.ResultOfBeWordForAnyRef[List[T]]" class="keyword">new</span> <a href="Matchers.scala.html#77395" title="ShouldMatchers.this.ResultOfBeWordForAnyRef[List[T]]">ResultOfBeWordForAnyRef</a><span class="delimiter">(</span><a href="#98559" title="List[T]">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * list should have length (3)
     *      ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(haveWord: ShouldMatchers.this.HaveWord)ShouldMatchers.this.ResultOfHaveWordForSeq[T]" id="97996">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.HaveWord" id="98580">haveWord</a>: <a href="Matchers.scala.html#77363" title="ShouldMatchers.this.HaveWord">HaveWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77369" title="ShouldMatchers.this.ResultOfHaveWordForSeq[T]">ResultOfHaveWordForSeq</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
      <span title="ShouldMatchers.this.ResultOfHaveWordForSeq[T]" class="keyword">new</span> <a href="Matchers.scala.html#77369" title="ShouldMatchers.this.ResultOfHaveWordForSeq[T]">ResultOfHaveWordForSeq</a><span class="delimiter">(</span><a href="#98559" title="List[T]">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * list should not have length (3)
     *      ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForSeq[T,List[T]]" id="97997">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98596">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77385" title="ShouldMatchers.this.ResultOfNotWordForSeq[T,List[T]]">ResultOfNotWordForSeq</a><span class="delimiter">[</span>T, List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span title="ShouldMatchers.this.ResultOfNotWordForSeq[T,List[T]]" class="keyword">new</span> <a href="Matchers.scala.html#77385" title="ShouldMatchers.this.ResultOfNotWordForSeq[T,List[T]]">ResultOfNotWordForSeq</a><span class="delimiter">(</span><a href="#98559" title="List[T]">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable &lt;code&gt;should&lt;/code&gt; methods to
   * be invoked on objects of type &lt;code&gt;java.util.List[T]&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class JavaListShouldWrapper[T] extends java.lang.Object with ScalaObject" id="77573">JavaListShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77574">T</a><span class="delimiter">]</span><a href="#77573" title="ScalaObject" class="delimiter">(</a><a title="java.util.List[T]" id="98615">left</a>: java.util.<span title="java.util.List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * javaList should equal (someOtherJavaList)
     *          ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(rightMatcher: org.scalatest.matchers.Matcher[java.util.List[T]])Unit" id="97955">should</a><span class="delimiter">(</span><a title="org.scalatest.matchers.Matcher[java.util.List[T]]" id="98616">rightMatcher</a>: <a href="Matcher.scala.html#12120" title="org.scalatest.matchers.Matcher[java.util.List[T]]">Matcher</a><span class="delimiter">[</span>java.util.List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#77540" title="object ShouldMatchers.this.ShouldMethodHelper">ShouldMethodHelper</a>.<a href="#97882" title="(left: java.util.List[T], rightMatcher: org.scalatest.matchers.Matcher[java.util.List[T]])Unit">shouldMatcher</a><span class="delimiter">(</span><a href="#98615" title="java.util.List[T]">left</a>, <a href="#98616" title="org.scalatest.matchers.Matcher[java.util.List[T]]">rightMatcher</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * javaList should have length (3)
     *          ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(haveWord: ShouldMatchers.this.HaveWord)ShouldMatchers.this.ResultOfHaveWordForJavaList[T]" id="97956">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.HaveWord" id="98623">haveWord</a>: <a href="Matchers.scala.html#77363" title="ShouldMatchers.this.HaveWord">HaveWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77390" title="ShouldMatchers.this.ResultOfHaveWordForJavaList[T]">ResultOfHaveWordForJavaList</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfHaveWordForJavaList[T]" class="keyword">new</span> <a href="Matchers.scala.html#77390" title="ShouldMatchers.this.ResultOfHaveWordForJavaList[T]">ResultOfHaveWordForJavaList</a><span class="delimiter">(</span><a href="#98615" title="java.util.List[T]">left</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * javaList should not have length (3)
     *          ^
     * &lt;/pre&gt;
     */</span>
    <span class="keyword">def</span> <a title="(notWord: ShouldMatchers.this.NotWord)ShouldMatchers.this.ResultOfNotWordForJavaList[T,java.util.List[T]]" id="97957">should</a><span class="delimiter">(</span><a title="ShouldMatchers.this.NotWord" id="98630">notWord</a>: <a href="Matchers.scala.html#77417" title="ShouldMatchers.this.NotWord">NotWord</a><span class="delimiter">)</span>: <a href="Matchers.scala.html#77392" title="ShouldMatchers.this.ResultOfNotWordForJavaList[T,java.util.List[T]]">ResultOfNotWordForJavaList</a><span class="delimiter">[</span>T, java.util.List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span title="ShouldMatchers.this.ResultOfNotWordForJavaList[T,java.util.List[T]]" class="keyword">new</span> <a href="Matchers.scala.html#77392" title="ShouldMatchers.this.ResultOfNotWordForJavaList[T,java.util.List[T]]">ResultOfNotWordForJavaList</a><span class="delimiter">(</span><a href="#98615" title="java.util.List[T]">left</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for &lt;a href=&quot;ShouldMatchers.html&quot;&gt;&lt;code&gt;ShouldMatchers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;MustMatchers.html&quot;&gt;&lt;code&gt;MustMatchers&lt;/code&gt;&lt;/a&gt; for an overview of
   * the matchers DSL.
   *
   * &lt;p&gt;
   * This class is used in conjunction with an implicit conversion to enable a &lt;code&gt;should&lt;/code&gt; method to
   * be invoked on objects that result of &lt;code&gt;evaulating { ... }&lt;/code&gt;.
   * &lt;/p&gt;
   *
   * @author Bill Venners
   */</span>
  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class EvaluatingApplicationShouldWrapper extends java.lang.Object with ScalaObject" id="77575">EvaluatingApplicationShouldWrapper</a><a href="#77575" title="ScalaObject" class="delimiter">(</a><a title="ShouldMatchers.this.ResultOfEvaluatingApplication" id="98640">left</a>: <a href="Matchers.scala.html#77532" title="ShouldMatchers.this.ResultOfEvaluatingApplication">ResultOfEvaluatingApplication</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * This method enables syntax such as the following:
     *
     * &lt;pre class=&quot;stHighlight&quot;&gt;
     * evaluating { &quot;hi&quot;.charAt(-1) } should produce [StringIndexOutOfBoundsException]
     *                                ^
     * &lt;/pre&gt;
     */</span>
     <span class="keyword">def</span> <a title="[T](resultOfProduceApplication: ShouldMatchers.this.ResultOfProduceInvocation[T])T" id="98045">should</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="98047">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="ShouldMatchers.this.ResultOfProduceInvocation[T]" id="98641">resultOfProduceApplication</a>: <a href="Matchers.scala.html#77534" title="ShouldMatchers.this.ResultOfProduceInvocation[T]">ResultOfProduceInvocation</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#98047" title="T">T</a> =  <span class="delimiter">{</span>
       <span class="keyword">val</span> <a title="Class[T]" id="98644">clazz</a> = <a href="#98641" title="ShouldMatchers.this.ResultOfProduceInvocation[T]">resultOfProduceApplication</a>.<a href="Matchers.scala.html#97846" title="=&gt; Class[T]">clazz</a>
       <span class="keyword">val</span> <a title="Option[java.lang.Throwable]" id="98645">caught</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
         <a href="#98640" title="ShouldMatchers.this.ResultOfEvaluatingApplication">left</a>.<a href="Matchers.scala.html#77886" title="()Any">fun</a><span class="delimiter">(</span><span class="delimiter">)</span>
         <span title="object None">None</span>
       <span class="delimiter">}</span>
       <span class="keyword">catch</span> <span class="delimiter">{</span>
         <span class="keyword">case</span> <a title="Some[java.lang.Throwable]" id="98646">u</a>: <span title="Throwable">Throwable</span> =&gt; <span class="delimiter">{</span>
           <span title="Some[java.lang.Throwable]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#98644" title="Class[T]">clazz</a>.<span title="(x$1: java.lang.Class[_])Boolean">isAssignableFrom</span><span class="delimiter">(</span><a href="#98646" title="java.lang.Throwable">u</a>.<span title="()java.lang.Class[_]">getClass</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
             <span class="keyword">val</span> <a title="String" id="98650">s</a> = <a href="../Resources.scala.html#27793" title="(resourceName: String, o1: AnyRef*)String">Resources</a><span class="delimiter">(</span><span title="java.lang.String(&quot;wrongException&quot;)" class="string">&quot;wrongException&quot;</span>, <a href="#98644" title="Class[T]">clazz</a>.<span title="()java.lang.String">getName</span>, <a href="#98646" title="java.lang.Throwable">u</a>.<span title="()java.lang.Class[_]">getClass</span>.<span title="()java.lang.String">getName</span><span class="delimiter">)</span>
             <span title="Nothing" class="keyword">throw</span> <a href="Matchers.scala.html#77312" title="(message: String)Throwable">newTestFailedException</a><span class="delimiter">(</span><a href="#98650" title="String">s</a><span class="delimiter">)</span>
             <span class="comment">// throw new TestFailedException(s, u, 3)</span>
           <span class="delimiter">}</span>
           <span class="keyword">else</span> <span class="delimiter">{</span>
             <span title="(x: java.lang.Throwable)Some[java.lang.Throwable]">Some</span><span class="delimiter">(</span><a href="#98646" title="java.lang.Throwable">u</a><span class="delimiter">)</span>
           <span class="delimiter">}</span>
         <span class="delimiter">}</span>
       <span class="delimiter">}</span>
       <a href="#98645" title="Option[java.lang.Throwable]">caught</a> <span title="T" class="keyword">match</span> <span class="delimiter">{</span>
         <span class="keyword">case</span> <span title="Nothing">None</span> =&gt;
           <span class="keyword">val</span> <a title="String" id="98673">message</a> = <a href="../Resources.scala.html#27793" title="(resourceName: String, o1: AnyRef*)String">Resources</a><span class="delimiter">(</span><span title="java.lang.String(&quot;exceptionExpected&quot;)" class="string">&quot;exceptionExpected&quot;</span>, <a href="#98644" title="Class[T]">clazz</a>.<span title="()java.lang.String">getName</span><span class="delimiter">)</span>
           <span title="Nothing" class="keyword">throw</span> <a href="Matchers.scala.html#77312" title="(message: String)Throwable">newTestFailedException</a><span class="delimiter">(</span><a href="#98673" title="String">message</a><span class="delimiter">)</span>
           <span class="comment">// throw new TestFailedException(message, 3)</span>
         <span class="keyword">case</span> <span title="T">Some</span><span class="delimiter">(</span><a title="java.lang.Throwable" id="98681">e</a><span class="delimiter">)</span> =&gt; <a href="#98681" title="java.lang.Throwable">e</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#98047" title="T">T</a><span class="delimiter">]</span> <span class="comment">// I know this cast will succeed, becuase isAssignableFrom succeeded above</span>
       <span class="delimiter">}</span>
     <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;T&lt;/code&gt; to a &lt;code&gt;EvaluatingApplicationShouldWrapper[T]&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit org.scalatest.matchers.ShouldMatchers.convertToEvaluatingApplicationShouldWrapper : (o: ShouldMatchers.this.ResultOfEvaluatingApplication)ShouldMatchers.this.EvaluatingApplicationShouldWrapper" id="77576">convertToEvaluatingApplicationShouldWrapper</a><span class="delimiter">(</span><a title="ShouldMatchers.this.ResultOfEvaluatingApplication" id="77882">o</a>: <a href="Matchers.scala.html#77532" title="ShouldMatchers.this.ResultOfEvaluatingApplication">ResultOfEvaluatingApplication</a><span class="delimiter">)</span>: <a href="#77575" title="ShouldMatchers.this.EvaluatingApplicationShouldWrapper">EvaluatingApplicationShouldWrapper</a> = <span title="ShouldMatchers.this.EvaluatingApplicationShouldWrapper" class="keyword">new</span> <a href="#77575" title="ShouldMatchers.this.EvaluatingApplicationShouldWrapper">EvaluatingApplicationShouldWrapper</a><span class="delimiter">(</span><a href="#77882" title="ShouldMatchers.this.ResultOfEvaluatingApplication">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;T&lt;/code&gt; to a &lt;code&gt;AnyShouldWrapper[T]&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](o: T)ShouldMatchers.this.AnyShouldWrapper[T]" id="77577">convertToAnyShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77579">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77874">o</a>: <a href="#77579" title="T">T</a><span class="delimiter">)</span>: <a href="#77542" title="ShouldMatchers.this.AnyShouldWrapper[T]">AnyShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="ShouldMatchers.this.AnyShouldWrapper[T]" class="keyword">new</span> <a href="#77542" title="ShouldMatchers.this.AnyShouldWrapper[T]">AnyShouldWrapper</a><span class="delimiter">(</span><a href="#77874" title="T">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;scala.Double&lt;/code&gt; to a &lt;code&gt;DoubleShouldWrapper&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit org.scalatest.matchers.ShouldMatchers.convertToDoubleShouldWrapper : (o: Double)ShouldMatchers.this.DoubleShouldWrapper" id="77580">convertToDoubleShouldWrapper</a><span class="delimiter">(</span><a title="Double" id="77872">o</a>: <span title="Double">Double</span><span class="delimiter">)</span>: <a href="#77549" title="ShouldMatchers.this.DoubleShouldWrapper">DoubleShouldWrapper</a> = <span title="ShouldMatchers.this.DoubleShouldWrapper" class="keyword">new</span> <a href="#77549" title="ShouldMatchers.this.DoubleShouldWrapper">DoubleShouldWrapper</a><span class="delimiter">(</span><a href="#77872" title="Double">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;scala.Float&lt;/code&gt; to a &lt;code&gt;FloatShouldWrapper&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit org.scalatest.matchers.ShouldMatchers.convertToFloatShouldWrapper : (o: Float)ShouldMatchers.this.FloatShouldWrapper" id="77581">convertToFloatShouldWrapper</a><span class="delimiter">(</span><a title="Float" id="77870">o</a>: <span title="Float">Float</span><span class="delimiter">)</span>: <a href="#77550" title="ShouldMatchers.this.FloatShouldWrapper">FloatShouldWrapper</a> = <span title="ShouldMatchers.this.FloatShouldWrapper" class="keyword">new</span> <a href="#77550" title="ShouldMatchers.this.FloatShouldWrapper">FloatShouldWrapper</a><span class="delimiter">(</span><a href="#77870" title="Float">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;scala.Long&lt;/code&gt; to a &lt;code&gt;LongShouldWrapper&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit org.scalatest.matchers.ShouldMatchers.convertToLongShouldWrapper : (o: Long)ShouldMatchers.this.LongShouldWrapper" id="77582">convertToLongShouldWrapper</a><span class="delimiter">(</span><a title="Long" id="77868">o</a>: <span title="Long">Long</span><span class="delimiter">)</span>: <a href="#77551" title="ShouldMatchers.this.LongShouldWrapper">LongShouldWrapper</a> = <span title="ShouldMatchers.this.LongShouldWrapper" class="keyword">new</span> <a href="#77551" title="ShouldMatchers.this.LongShouldWrapper">LongShouldWrapper</a><span class="delimiter">(</span><a href="#77868" title="Long">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;scala.Int&lt;/code&gt; to a &lt;code&gt;IntShouldWrapper&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit org.scalatest.matchers.ShouldMatchers.convertToIntShouldWrapper : (o: Int)ShouldMatchers.this.IntShouldWrapper" id="77583">convertToIntShouldWrapper</a><span class="delimiter">(</span><a title="Int" id="77866">o</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#77552" title="ShouldMatchers.this.IntShouldWrapper">IntShouldWrapper</a> = <span title="ShouldMatchers.this.IntShouldWrapper" class="keyword">new</span> <a href="#77552" title="ShouldMatchers.this.IntShouldWrapper">IntShouldWrapper</a><span class="delimiter">(</span><a href="#77866" title="Int">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;scala.Short&lt;/code&gt; to a &lt;code&gt;ShortShouldWrapper&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit org.scalatest.matchers.ShouldMatchers.convertToShortShouldWrapper : (o: Short)ShouldMatchers.this.ShortShouldWrapper" id="77584">convertToShortShouldWrapper</a><span class="delimiter">(</span><a title="Short" id="77864">o</a>: <span title="Short">Short</span><span class="delimiter">)</span>: <a href="#77553" title="ShouldMatchers.this.ShortShouldWrapper">ShortShouldWrapper</a> = <span title="ShouldMatchers.this.ShortShouldWrapper" class="keyword">new</span> <a href="#77553" title="ShouldMatchers.this.ShortShouldWrapper">ShortShouldWrapper</a><span class="delimiter">(</span><a href="#77864" title="Short">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;scala.Byte&lt;/code&gt; to a &lt;code&gt;ByteShouldWrapper&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit org.scalatest.matchers.ShouldMatchers.convertToByteShouldWrapper : (o: Byte)ShouldMatchers.this.ByteShouldWrapper" id="77585">convertToByteShouldWrapper</a><span class="delimiter">(</span><a title="Byte" id="77862">o</a>: <span title="Byte">Byte</span><span class="delimiter">)</span>: <a href="#77554" title="ShouldMatchers.this.ByteShouldWrapper">ByteShouldWrapper</a> = <span title="ShouldMatchers.this.ByteShouldWrapper" class="keyword">new</span> <a href="#77554" title="ShouldMatchers.this.ByteShouldWrapper">ByteShouldWrapper</a><span class="delimiter">(</span><a href="#77862" title="Byte">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts a &lt;code&gt;scala.AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; to an &lt;code&gt;AnyRefShouldWrapper[T]&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef](o: T)ShouldMatchers.this.AnyRefShouldWrapper[T]" id="77586">convertToAnyRefShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef" id="77588">T</a> &lt;: AnyRef<span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77853">o</a>: <a href="#77588" title="T">T</a><span class="delimiter">)</span>: <a href="#77558" title="ShouldMatchers.this.AnyRefShouldWrapper[T]">AnyRefShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="ShouldMatchers.this.AnyRefShouldWrapper[T]" class="keyword">new</span> <a href="#77558" title="ShouldMatchers.this.AnyRefShouldWrapper[T]">AnyRefShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77853" title="T">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;scala.Collection[T]&lt;/code&gt; to a &lt;code&gt;CollectionShouldWrapper&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](o: Traversable[T])ShouldMatchers.this.TraversableShouldWrapper[T]" id="77589">convertToTraversableShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77591">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Traversable[T]" id="77850">o</a>: <span title="Traversable[T]">Traversable</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#77560" title="ShouldMatchers.this.TraversableShouldWrapper[T]">TraversableShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="ShouldMatchers.this.TraversableShouldWrapper[T]" class="keyword">new</span> <a href="#77560" title="ShouldMatchers.this.TraversableShouldWrapper[T]">TraversableShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77850" title="Traversable[T]">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;scala.Seq[T]&lt;/code&gt; to a &lt;code&gt;SeqShouldWrapper[T]&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](o: Seq[T])ShouldMatchers.this.SeqShouldWrapper[T]" id="77592">convertToSeqShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77594">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[T]" id="77847">o</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#77567" title="ShouldMatchers.this.SeqShouldWrapper[T]">SeqShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="ShouldMatchers.this.SeqShouldWrapper[T]" class="keyword">new</span> <a href="#77567" title="ShouldMatchers.this.SeqShouldWrapper[T]">SeqShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77847" title="Seq[T]">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;scala.Array[T]&lt;/code&gt; to a &lt;code&gt;ArrayShouldWrapper[T]&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](o: Array[T])ShouldMatchers.this.ArrayShouldWrapper[T]" id="77595">convertToArrayShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77597">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Array[T]" id="77844">o</a>: <span title="Array[T]">Array</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#77569" title="ShouldMatchers.this.ArrayShouldWrapper[T]">ArrayShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="ShouldMatchers.this.ArrayShouldWrapper[T]" class="keyword">new</span> <a href="#77569" title="ShouldMatchers.this.ArrayShouldWrapper[T]">ArrayShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77844" title="Array[T]">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;scala.List[T]&lt;/code&gt; to a &lt;code&gt;ListShouldWrapper[T]&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](o: List[T])ShouldMatchers.this.ListShouldWrapper[T]" id="77598">convertToListShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77600">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[T]" id="77841">o</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#77571" title="ShouldMatchers.this.ListShouldWrapper[T]">ListShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="ShouldMatchers.this.ListShouldWrapper[T]" class="keyword">new</span> <a href="#77571" title="ShouldMatchers.this.ListShouldWrapper[T]">ListShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77841" title="List[T]">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;scala.collection.Map[K, V]&lt;/code&gt; to a &lt;code&gt;MapShouldWrapper[K, V]&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V](o: scala.collection.Map[K,V])ShouldMatchers.this.MapShouldWrapper[K,V]" id="77601">convertToMapShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77604">K</a>, <a title="&gt;: Nothing &lt;: Any" id="77605">V</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.collection.Map[K,V]" id="77838">o</a>: scala.collection.<span title="scala.collection.Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#77555" title="ShouldMatchers.this.MapShouldWrapper[K,V]">MapShouldWrapper</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <span title="ShouldMatchers.this.MapShouldWrapper[K,V]" class="keyword">new</span> <a href="#77555" title="ShouldMatchers.this.MapShouldWrapper[K,V]">MapShouldWrapper</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77838" title="scala.collection.Map[K,V]">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;java.lang.String&lt;/code&gt; to a &lt;code&gt;StringShouldWrapper&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="implicit org.scalatest.matchers.ShouldMatchers.convertToStringShouldWrapper : (o: String)ShouldMatchers.this.StringShouldWrapper" id="77606">convertToStringShouldWrapper</a><span class="delimiter">(</span><a title="String" id="77688">o</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#77548" title="ShouldMatchers.this.StringShouldWrapper">StringShouldWrapper</a> = <span title="ShouldMatchers.this.StringShouldWrapper" class="keyword">new</span> <a href="#77548" title="ShouldMatchers.this.StringShouldWrapper">StringShouldWrapper</a><span class="delimiter">(</span><a href="#77688" title="String">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;java.util.Collection[T]&lt;/code&gt; to a &lt;code&gt;JavaCollectionShouldWrapper[T]&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](o: java.util.Collection[T])ShouldMatchers.this.JavaCollectionShouldWrapper[T]" id="77607">convertToJavaCollectionShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77609">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="java.util.Collection[T]" id="77835">o</a>: java.util.<span title="java.util.Collection[T]">Collection</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#77562" title="ShouldMatchers.this.JavaCollectionShouldWrapper[T]">JavaCollectionShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="ShouldMatchers.this.JavaCollectionShouldWrapper[T]" class="keyword">new</span> <a href="#77562" title="ShouldMatchers.this.JavaCollectionShouldWrapper[T]">JavaCollectionShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77835" title="java.util.Collection[T]">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;java.util.List[T]&lt;/code&gt; to a &lt;code&gt;JavaListShouldWrapper[T]&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object. This conversion is necessary to enable
   * &lt;code&gt;length&lt;/code&gt; to be used on Java &lt;code&gt;List&lt;/code&gt;s.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](o: java.util.List[T])ShouldMatchers.this.JavaListShouldWrapper[T]" id="77610">convertToJavaListShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77612">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="java.util.List[T]" id="77832">o</a>: java.util.<span title="java.util.List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#77573" title="ShouldMatchers.this.JavaListShouldWrapper[T]">JavaListShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="ShouldMatchers.this.JavaListShouldWrapper[T]" class="keyword">new</span> <a href="#77573" title="ShouldMatchers.this.JavaListShouldWrapper[T]">JavaListShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77832" title="java.util.List[T]">o</a><span class="delimiter">)</span>


  <span class="comment">/**
   * Implicitly converts an object of type &lt;code&gt;java.util.Map[K, V]&lt;/code&gt; to a &lt;code&gt;JavaMapShouldWrapper[K, V]&lt;/code&gt;,
   * to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V](o: java.util.Map[K,V])ShouldMatchers.this.JavaMapShouldWrapper[K,V]" id="77613">convertToJavaMapShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="77616">K</a>, <a title="&gt;: Nothing &lt;: Any" id="77617">V</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="java.util.Map[K,V]" id="77790">o</a>: java.util.<span title="java.util.Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#77564" title="ShouldMatchers.this.JavaMapShouldWrapper[K,V]">JavaMapShouldWrapper</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <span title="ShouldMatchers.this.JavaMapShouldWrapper[K,V]" class="keyword">new</span> <a href="#77564" title="ShouldMatchers.this.JavaMapShouldWrapper[K,V]">JavaMapShouldWrapper</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77790" title="java.util.Map[K,V]">o</a><span class="delimiter">)</span>

  <span class="comment">// Implicitly just used to trigger the addition of the should method. The LengthShouldWrapper</span>
  <span class="comment">// doesn't actually convert them, just passes it through. The conversion that happens here is to LengthShouldWrapper,</span>
  <span class="comment">// and later, inside ResultOfHaveWordForLengthWrapper, the implicit conversion from T to LengthWrapper takes place. So</span>
  <span class="comment">// weirdly enough, here strings are treated structurally for the implicit that adds the should, but later they are</span>
  <span class="comment">// treated nominally by the implicit conversion from plain old String to StringLengthWrapper. So when length is</span>
  <span class="comment">// ultimately invoked up in ResultOfHaveWordForLengthWrapper, it is done directly, not with reflection. That's my</span>
  <span class="comment">// theory anyway.</span>

  <span class="comment">/**
   * Implicitly converts an &lt;code&gt;AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; whose structure includes
   * a &lt;code&gt;getLength&lt;/code&gt; method that results in &lt;code&gt;Int&lt;/code&gt;
   * to a &lt;code&gt;SizeShouldWrapper[T]&lt;/code&gt;, to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef{def getLength(): Int}](o: T)ShouldMatchers.this.LengthShouldWrapper[T]" id="77618">convertHasIntGetLengthMethodToLengthShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef{def getLength(): Int}" id="77620">T</a> &lt;: AnyRef <span class="delimiter">{</span> <span class="keyword">def</span> getLength<span class="delimiter">(</span><span class="delimiter">)</span>: Int<span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77785">o</a>: <a href="#77620" title="T">T</a><span class="delimiter">)</span>: <a href="#77544" title="ShouldMatchers.this.LengthShouldWrapper[T]">LengthShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Matchers.scala.html#77347" title="ShouldMatchers.this.LengthShouldWrapper[T]" class="keyword">new</a> <a href="#77544" title="ShouldMatchers.this.LengthShouldWrapper[T]">LengthShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77785" title="T">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an &lt;code&gt;AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; whose structure includes
   * a &lt;code&gt;getLength&lt;/code&gt; &lt;code&gt;val&lt;/code&gt; of type &lt;code&gt;Int&lt;/code&gt;
   * to a &lt;code&gt;SizeShouldWrapper[T]&lt;/code&gt;, to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef{val getLength: Int}](o: T)ShouldMatchers.this.LengthShouldWrapper[T]" id="77621">convertHasIntGetLengthFieldToLengthShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef{val getLength: Int}" id="77623">T</a> &lt;: AnyRef <span class="delimiter">{</span> <span class="keyword">val</span> getLength: Int<span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77780">o</a>: <a href="#77623" title="T">T</a><span class="delimiter">)</span>: <a href="#77544" title="ShouldMatchers.this.LengthShouldWrapper[T]">LengthShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Matchers.scala.html#77346" title="ShouldMatchers.this.LengthShouldWrapper[T]" class="keyword">new</a> <a href="#77544" title="ShouldMatchers.this.LengthShouldWrapper[T]">LengthShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77780" title="T">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an &lt;code&gt;AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; whose structure includes
   * a &lt;code&gt;length&lt;/code&gt; &lt;code&gt;val&lt;/code&gt; of type &lt;code&gt;Int&lt;/code&gt;
   * to a &lt;code&gt;SizeShouldWrapper[T]&lt;/code&gt;, to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef{val length: Int}](o: T)ShouldMatchers.this.LengthShouldWrapper[T]" id="77624">convertHasIntLengthFieldToLengthShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef{val length: Int}" id="77626">T</a> &lt;: AnyRef <span class="delimiter">{</span> <span class="keyword">val</span> length: Int<span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77775">o</a>: <a href="#77626" title="T">T</a><span class="delimiter">)</span>: <a href="#77544" title="ShouldMatchers.this.LengthShouldWrapper[T]">LengthShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Matchers.scala.html#77344" title="ShouldMatchers.this.LengthShouldWrapper[T]" class="keyword">new</a> <a href="#77544" title="ShouldMatchers.this.LengthShouldWrapper[T]">LengthShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77775" title="T">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an &lt;code&gt;AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; whose structure includes
   * a &lt;code&gt;length&lt;/code&gt; method that results in &lt;code&gt;Int&lt;/code&gt;
   * to a &lt;code&gt;SizeShouldWrapper[T]&lt;/code&gt;, to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef{def length(): Int}](o: T)ShouldMatchers.this.LengthShouldWrapper[T]" id="77627">convertHasIntLengthMethodToLengthShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef{def length(): Int}" id="77629">T</a> &lt;: AnyRef <span class="delimiter">{</span> <span class="keyword">def</span> length<span class="delimiter">(</span><span class="delimiter">)</span>: Int<span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77770">o</a>: <a href="#77629" title="T">T</a><span class="delimiter">)</span>: <a href="#77544" title="ShouldMatchers.this.LengthShouldWrapper[T]">LengthShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Matchers.scala.html#77345" title="ShouldMatchers.this.LengthShouldWrapper[T]" class="keyword">new</a> <a href="#77544" title="ShouldMatchers.this.LengthShouldWrapper[T]">LengthShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77770" title="T">o</a><span class="delimiter">)</span>


  <span class="comment">/**
   * Implicitly converts an &lt;code&gt;AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; whose structure includes
   * a &lt;code&gt;getLength&lt;/code&gt; method that results in &lt;code&gt;Long&lt;/code&gt;
   * to a &lt;code&gt;SizeShouldWrapper[T]&lt;/code&gt;, to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef{def getLength(): Long}](o: T)ShouldMatchers.this.LengthShouldWrapper[T]" id="77630">convertHasLongGetLengthMethodToLengthShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef{def getLength(): Long}" id="77632">T</a> &lt;: AnyRef <span class="delimiter">{</span> <span class="keyword">def</span> getLength<span class="delimiter">(</span><span class="delimiter">)</span>: Long<span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77765">o</a>: <a href="#77632" title="T">T</a><span class="delimiter">)</span>: <a href="#77544" title="ShouldMatchers.this.LengthShouldWrapper[T]">LengthShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Matchers.scala.html#77351" title="ShouldMatchers.this.LengthShouldWrapper[T]" class="keyword">new</a> <a href="#77544" title="ShouldMatchers.this.LengthShouldWrapper[T]">LengthShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77765" title="T">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an &lt;code&gt;AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; whose structure includes
   * a &lt;code&gt;getLength&lt;/code&gt; &lt;code&gt;val&lt;/code&gt; of type &lt;code&gt;Long&lt;/code&gt;
   * to a &lt;code&gt;SizeShouldWrapper[T]&lt;/code&gt;, to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef{val getLength: Long}](o: T)ShouldMatchers.this.LengthShouldWrapper[T]" id="77633">convertHasLongGetLengthFieldToLengthShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef{val getLength: Long}" id="77635">T</a> &lt;: AnyRef <span class="delimiter">{</span> <span class="keyword">val</span> getLength: Long<span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77760">o</a>: <a href="#77635" title="T">T</a><span class="delimiter">)</span>: <a href="#77544" title="ShouldMatchers.this.LengthShouldWrapper[T]">LengthShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Matchers.scala.html#77350" title="ShouldMatchers.this.LengthShouldWrapper[T]" class="keyword">new</a> <a href="#77544" title="ShouldMatchers.this.LengthShouldWrapper[T]">LengthShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77760" title="T">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an &lt;code&gt;AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; whose structure includes
   * a &lt;code&gt;length&lt;/code&gt; &lt;code&gt;val&lt;/code&gt; of type &lt;code&gt;Long&lt;/code&gt;
   * to a &lt;code&gt;SizeShouldWrapper[T]&lt;/code&gt;, to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef{val length: Long}](o: T)ShouldMatchers.this.LengthShouldWrapper[T]" id="77636">convertHasLongLengthFieldToLengthShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef{val length: Long}" id="77638">T</a> &lt;: AnyRef <span class="delimiter">{</span> <span class="keyword">val</span> length: Long<span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77755">o</a>: <a href="#77638" title="T">T</a><span class="delimiter">)</span>: <a href="#77544" title="ShouldMatchers.this.LengthShouldWrapper[T]">LengthShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Matchers.scala.html#77348" title="ShouldMatchers.this.LengthShouldWrapper[T]" class="keyword">new</a> <a href="#77544" title="ShouldMatchers.this.LengthShouldWrapper[T]">LengthShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77755" title="T">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an &lt;code&gt;AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; whose structure includes
   * a &lt;code&gt;length&lt;/code&gt; method that results in &lt;code&gt;Long&lt;/code&gt;
   * to a &lt;code&gt;SizeShouldWrapper[T]&lt;/code&gt;, to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef{def length(): Long}](o: T)ShouldMatchers.this.LengthShouldWrapper[T]" id="77639">convertHasLongLengthMethodToLengthShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef{def length(): Long}" id="77641">T</a> &lt;: AnyRef <span class="delimiter">{</span> <span class="keyword">def</span> length<span class="delimiter">(</span><span class="delimiter">)</span>: Long<span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77741">o</a>: <a href="#77641" title="T">T</a><span class="delimiter">)</span>: <a href="#77544" title="ShouldMatchers.this.LengthShouldWrapper[T]">LengthShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Matchers.scala.html#77349" title="ShouldMatchers.this.LengthShouldWrapper[T]" class="keyword">new</a> <a href="#77544" title="ShouldMatchers.this.LengthShouldWrapper[T]">LengthShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77741" title="T">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an &lt;code&gt;AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; whose structure includes
   * a &lt;code&gt;getSize&lt;/code&gt; method that results in &lt;code&gt;Int&lt;/code&gt;
   * to a &lt;code&gt;SizeShouldWrapper[T]&lt;/code&gt;, to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef{def getSize(): Int}](o: T)ShouldMatchers.this.SizeShouldWrapper[T]" id="77642">convertHasIntGetSizeMethodToSizeShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef{def getSize(): Int}" id="77644">T</a> &lt;: AnyRef <span class="delimiter">{</span> <span class="keyword">def</span> getSize<span class="delimiter">(</span><span class="delimiter">)</span>: Int<span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77736">o</a>: <a href="#77644" title="T">T</a><span class="delimiter">)</span>: <a href="#77546" title="ShouldMatchers.this.SizeShouldWrapper[T]">SizeShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Matchers.scala.html#77356" title="ShouldMatchers.this.SizeShouldWrapper[T]" class="keyword">new</a> <a href="#77546" title="ShouldMatchers.this.SizeShouldWrapper[T]">SizeShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77736" title="T">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an &lt;code&gt;AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; whose structure includes
   * a &lt;code&gt;getSize&lt;/code&gt; &lt;code&gt;val&lt;/code&gt; of type &lt;code&gt;Int&lt;/code&gt;
   * to a &lt;code&gt;SizeShouldWrapper[T]&lt;/code&gt;, to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef{val getSize: Int}](o: T)ShouldMatchers.this.SizeShouldWrapper[T]" id="77645">convertHasIntGetSizeFieldToSizeShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef{val getSize: Int}" id="77647">T</a> &lt;: AnyRef <span class="delimiter">{</span> <span class="keyword">val</span> getSize: Int<span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77731">o</a>: <a href="#77647" title="T">T</a><span class="delimiter">)</span>: <a href="#77546" title="ShouldMatchers.this.SizeShouldWrapper[T]">SizeShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Matchers.scala.html#77355" title="ShouldMatchers.this.SizeShouldWrapper[T]" class="keyword">new</a> <a href="#77546" title="ShouldMatchers.this.SizeShouldWrapper[T]">SizeShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77731" title="T">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an &lt;code&gt;AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; whose structure includes
   * a &lt;code&gt;size&lt;/code&gt; &lt;code&gt;val&lt;/code&gt; of type &lt;code&gt;Int&lt;/code&gt;
   * to a &lt;code&gt;SizeShouldWrapper[T]&lt;/code&gt;, to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef{val size: Int}](o: T)ShouldMatchers.this.SizeShouldWrapper[T]" id="77648">convertHasIntSizeFieldToSizeShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef{val size: Int}" id="77650">T</a> &lt;: AnyRef <span class="delimiter">{</span> <span class="keyword">val</span> size: Int<span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77726">o</a>: <a href="#77650" title="T">T</a><span class="delimiter">)</span>: <a href="#77546" title="ShouldMatchers.this.SizeShouldWrapper[T]">SizeShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Matchers.scala.html#77353" title="ShouldMatchers.this.SizeShouldWrapper[T]" class="keyword">new</a> <a href="#77546" title="ShouldMatchers.this.SizeShouldWrapper[T]">SizeShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77726" title="T">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an &lt;code&gt;AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; whose structure includes
   * a &lt;code&gt;size&lt;/code&gt; method that results in &lt;code&gt;Int&lt;/code&gt;
   * to a &lt;code&gt;SizeShouldWrapper[T]&lt;/code&gt;, to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef{def size(): Int}](o: T)ShouldMatchers.this.SizeShouldWrapper[T]" id="77651">convertHasIntSizeMethodToSizeShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef{def size(): Int}" id="77653">T</a> &lt;: AnyRef <span class="delimiter">{</span> <span class="keyword">def</span> size<span class="delimiter">(</span><span class="delimiter">)</span>: Int<span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77721">o</a>: <a href="#77653" title="T">T</a><span class="delimiter">)</span>: <a href="#77546" title="ShouldMatchers.this.SizeShouldWrapper[T]">SizeShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Matchers.scala.html#77354" title="ShouldMatchers.this.SizeShouldWrapper[T]" class="keyword">new</a> <a href="#77546" title="ShouldMatchers.this.SizeShouldWrapper[T]">SizeShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77721" title="T">o</a><span class="delimiter">)</span>


  <span class="comment">/**
   * Implicitly converts an &lt;code&gt;AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; whose structure includes
   * a &lt;code&gt;getSize&lt;/code&gt; method that results in &lt;code&gt;Long&lt;/code&gt;
   * to a &lt;code&gt;SizeShouldWrapper[T]&lt;/code&gt;, to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef{def getSize(): Long}](o: T)ShouldMatchers.this.SizeShouldWrapper[T]" id="77654">convertHasLongGetSizeMethodToSizeShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef{def getSize(): Long}" id="77656">T</a> &lt;: AnyRef <span class="delimiter">{</span> <span class="keyword">def</span> getSize<span class="delimiter">(</span><span class="delimiter">)</span>: Long<span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77716">o</a>: <a href="#77656" title="T">T</a><span class="delimiter">)</span>: <a href="#77546" title="ShouldMatchers.this.SizeShouldWrapper[T]">SizeShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Matchers.scala.html#77360" title="ShouldMatchers.this.SizeShouldWrapper[T]" class="keyword">new</a> <a href="#77546" title="ShouldMatchers.this.SizeShouldWrapper[T]">SizeShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77716" title="T">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an &lt;code&gt;AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; whose structure includes
   * a &lt;code&gt;getSize&lt;/code&gt; &lt;code&gt;val&lt;/code&gt; of type &lt;code&gt;Long&lt;/code&gt;
   * to a &lt;code&gt;SizeShouldWrapper[T]&lt;/code&gt;, to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef{val getSize: Long}](o: T)ShouldMatchers.this.SizeShouldWrapper[T]" id="77657">convertHasLongGetSizeFieldToSizeShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef{val getSize: Long}" id="77659">T</a> &lt;: AnyRef <span class="delimiter">{</span> <span class="keyword">val</span> getSize: Long<span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77711">o</a>: <a href="#77659" title="T">T</a><span class="delimiter">)</span>: <a href="#77546" title="ShouldMatchers.this.SizeShouldWrapper[T]">SizeShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Matchers.scala.html#77359" title="ShouldMatchers.this.SizeShouldWrapper[T]" class="keyword">new</a> <a href="#77546" title="ShouldMatchers.this.SizeShouldWrapper[T]">SizeShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77711" title="T">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an &lt;code&gt;AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; whose structure includes
   * a &lt;code&gt;size&lt;/code&gt; &lt;code&gt;val&lt;/code&gt; type &lt;code&gt;Long&lt;/code&gt;
   * to a &lt;code&gt;SizeShouldWrapper[T]&lt;/code&gt;, to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef{val size: Long}](o: T)ShouldMatchers.this.SizeShouldWrapper[T]" id="77660">convertHasLongSizeFieldToSizeShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef{val size: Long}" id="77662">T</a> &lt;: AnyRef <span class="delimiter">{</span> <span class="keyword">val</span> size: Long<span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77706">o</a>: <a href="#77662" title="T">T</a><span class="delimiter">)</span>: <a href="#77546" title="ShouldMatchers.this.SizeShouldWrapper[T]">SizeShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Matchers.scala.html#77357" title="ShouldMatchers.this.SizeShouldWrapper[T]" class="keyword">new</a> <a href="#77546" title="ShouldMatchers.this.SizeShouldWrapper[T]">SizeShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77706" title="T">o</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Implicitly converts an &lt;code&gt;AnyRef&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; whose structure includes
   * a &lt;code&gt;size&lt;/code&gt; method that results in &lt;code&gt;Long&lt;/code&gt;
   * to a &lt;code&gt;SizeShouldWrapper[T]&lt;/code&gt;, to enable &lt;code&gt;should&lt;/code&gt; methods to be invokable on that object.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T &lt;: AnyRef{def size(): Long}](o: T)ShouldMatchers.this.SizeShouldWrapper[T]" id="77663">convertHasLongSizeMethodToSizeShouldWrapper</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: AnyRef{def size(): Long}" id="77665">T</a> &lt;: AnyRef <span class="delimiter">{</span> <span class="keyword">def</span> size<span class="delimiter">(</span><span class="delimiter">)</span>: Long<span class="delimiter">}</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="77692">o</a>: <a href="#77665" title="T">T</a><span class="delimiter">)</span>: <a href="#77546" title="ShouldMatchers.this.SizeShouldWrapper[T]">SizeShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Matchers.scala.html#77358" title="ShouldMatchers.this.SizeShouldWrapper[T]" class="keyword">new</a> <a href="#77546" title="ShouldMatchers.this.SizeShouldWrapper[T]">SizeShouldWrapper</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#77692" title="T">o</a><span class="delimiter">)</span>
<span class="delimiter">}</span>
<span class="comment">/*
When Scala must chose between an implicit with a structural type and one with a nominal one,
the nominal one wins.

scala&gt; set.size
res0: Int = 3

scala&gt; class SetWrapper(payload: Set[Int]) { def prove() { println(&quot;SetWrapper&quot;) }}
defined class SetWrapper

scala&gt; class SizeWrapper(payload: { def size: Int }) { def prove() { println(&quot;SizeWrapper&quot;) }}
defined class SizeWrapper

scala&gt; new SizeWrapper(set)
res1: SizeWrapper = SizeWrapper@39ce9b

scala&gt; res1.prove
SizeWrapper

scala&gt; new SetWrapper(set)
res3: SetWrapper = SetWrapper@9fc9fe

scala&gt; res3.prove
SetWrapper

scala&gt; implicit def convertToSetWrapper(setParam: Set[Int]): SetWrapper = new SetWrapper(setParam)
convertToSetWrapper: (Set[Int])SetWrapper

scala&gt; implicit def convertToSizeWrapper(setParam: { def size: Int }): SizeWrapper = new SizeWrapper(setParam)
convertToSizeWrapper: (AnyRef{def size: Int})SizeWrapper

scala&gt; convertToSetWrapper(set)
res5: SetWrapper = SetWrapper@598095

scala&gt; convertToSizeWrapper(set)
res6: SizeWrapper = SizeWrapper@660ff1

scala&gt; set.prove
SetWrapper
 */</span>
<span class="comment">/*
leave this explanation in. It is a useful reminder.
THIS DOESN'T WORK BECAUSE...
  trait ShouldMethods[T] {
    val leftOperand: T
    def should(rightMatcher: Matcher[T]) {
      rightMatcher(leftOperand) match {
        case MatchResult(false, failureMessage, _) =&gt; throw newTestFailedException(failureMessage)
        case _ =&gt; ()
      }
    }

    // I don't think there's a be on Any, because a (symbol) and an (symbol), pluse
    // theSameInstanceAs only work on AnyRefs
    // def should(beWord: BeWord): ResultOfBeWord[T] = new ResultOfBeWord(leftOperand, true)
    def should(notWord: NotWord) = new ResultOfNotWord[T](leftOperand, false)
  }
  trait ShouldMethodsForAnyRef[T &lt;: AnyRef] extends ShouldMethods[T] {
    val leftOperand: T
    override def should(notWord: NotWord): ResultOfNotWordForAnyRef[T] = {
      new ResultOfNotWordForAnyRef(leftOperand, false)
    }
    def should(beWord: BeWord): ResultOfBeWordForAnyRef[T] = new ResultOfBeWordForAnyRef[T](leftOperand, true)
  }

  class CollectionShouldWrapper[T](left: Collection[T]) extends { val leftOperand = left }
  with ShouldMethodsForAnyRef[Collection[T]]
      with ShouldContainWordForIterableMethods[T] with ShouldHaveWordForCollectionMethods[T] {

    override def should(notWord: NotWord): ResultOfNotWordForCollection[Collection[T]] = {
      new ResultOfNotWordForCollection(leftOperand, false)
    }
  }
When you mix in the latter, the result type of should(BeWord) is still the more generic ResultOfNotWord, not ResultOfNotWordForAnyRef.
As a result it doesn't have an &quot;a (Symbol)&quot; method on it. This triggers another implicit conversion in this case:

emptySet should be a ('empty)

Turns into:

BeSymbolSpec.this.convertToAnyRefShouldWrapper[BeSymbolSpec.this.CollectionShouldWrapper[T]]
(BeSymbolSpec.this.convertToCollectionShouldWrapper[T](emptySet)).should(BeSymbolSpec.this.be).
a(scala.Symbol.apply(&quot;empty&quot;));

So the problem with having these &quot;methods&quot; traits extend each other is the covariant result
types don't get more specific visibly enough.

LATER: Well, I'm wondering if now that I've removed the be method in ShouldMethods if this will work. 
*/</span>

<span class="comment">/**
 * Companion object that facilitates the importing of &lt;code&gt;ShouldMatchers&lt;/code&gt; members as 
 * an alternative to mixing it the trait. One use case is to import &lt;code&gt;ShouldMatchers&lt;/code&gt; members so you can use
 * them in the Scala interpreter:
 *
 * &lt;pre class=&quot;stREPL&quot;&gt;
 * $scala -classpath scalatest.jar
 * Welcome to Scala version 2.7.3.final (Java HotSpot(TM) Client VM, Java 1.5.0_16).
 * Type in expressions to have them evaluated.
 * Type :help for more information.
 * 
 * scala&gt; import org.scalatest.matchers.ShouldMatchers._
 * import org.scalatest.matchers.ShouldMatchers._
 * 
 * scala&gt; 1 should equal (2)
 * org.scalatest.TestFailedException: 1 did not equal 2
 * 	at org.scalatest.matchers.Helper$.newTestFailedException(Matchers.scala:40)
 * 	at org.scalatest.matchers.ShouldMatchers$ShouldMethodHelper$.shouldMatcher(ShouldMatchers.scala:826)
 * 	at org.scalatest.matchers.ShouldMatchers$IntShouldWrapper.should(ShouldMatchers.scala:1123)
 * 	at .&lt;init&gt;(&lt;console&gt;:9)
 * 	at .&lt;clinit&gt;(&lt;console&gt;)
 * 	at RequestR...
 *
 * scala&gt; &quot;hello, world&quot; should startWith (&quot;hello&quot;)
 * 
 * scala&gt; 7 should (be &gt;= (3) and not be &lt;= (7))
 * org.scalatest.TestFailedException: 7 was greater than or equal to 3, but 7 was less than or equal to 7
 * 	at org.scalatest.matchers.Helper$.newTestFailedException(Matchers.scala:40)
 * 	at org.scalatest.matchers.ShouldMatchers$ShouldMethodHelper$.shouldMatcher(ShouldMatchers.scala:826)
 * 	at org.scalatest.matchers.ShouldMatchers$IntShouldWrapper.should(ShouldMatchers.scala:1123)
 * 	at .&lt;init&gt;(...
 * &lt;/pre&gt;
 *
 * @author Bill Venners
 */</span>
<span class="keyword">object</span> <a title="object org.scalatest.matchers.ShouldMatchers" id="12340">ShouldMatchers</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#12339" title="org.scalatest.matchers.ShouldMatchers">ShouldMatchers</a>

        </pre>
    </body>
</html>