<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>org/scalatest/events/EventSpec.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> org.scalatest.events

<span class="keyword">import</span> org.scalatest._
<span class="keyword">import</span> org.scalatest.prop.Checkers
<span class="keyword">import</span> org.scalacheck._
<span class="keyword">import</span> <span title="object org.scalacheck.Arbitrary">Arbitrary</span>._
<span class="keyword">import</span> <span title="object org.scalacheck.Prop">Prop</span>._

<span class="keyword">class</span> <a title="class EventSpec extends java.lang.Object with org.scalatest.Spec with org.scalatest.prop.Checkers with ScalaObject" id="10973">EventSpec</a> <a href="#10973" title="ScalaObject" class="keyword">extends</a> <a href="org/scalatest/Spec.scala.html#9842" title="org.scalatest.Spec">Spec</a> <span class="keyword">with</span> <a href="org/scalatest/prop/Checkers.scala.html#13769" title="org.scalatest.prop.Checkers">Checkers</a> <span class="delimiter">{</span>
<span class="comment">/*
  describe(&quot;An TestStarting Event&quot;) {
    describe(&quot;(with different runStamps)&quot;) {
      it(&quot;should sort into order by runStamp&quot;) {
        check(
          (runStampA: Int, runStampB: Int, suiteStamp: List[Int], testStamp: Int, ordinal: Int) =&gt;
            (runStampA != runStampB) ==&gt; {
              val unsorted =
                List(
                  TestStarting(&quot;X - test&quot;, &quot;X&quot;, Some(&quot;com.acme.X&quot;), &quot;test&quot;, runStampA, suiteStamp, testStamp, ordinal),
                  TestStarting(&quot;Y - test&quot;, &quot;Y&quot;, Some(&quot;com.acme.Y&quot;), &quot;test&quot;, runStampB, suiteStamp, testStamp, ordinal)
                )
              val sorted = unsorted.sort(_ &lt; _)
              sorted.head.runStamp &lt; sorted.tail.head.runStamp
            }
        )
      }
    }

    describe(&quot;(with same runStamps but different suiteStamps of the same length)&quot;) {
      it(&quot;should sort into order by suiteStamp&quot;) {
        check(
          (runStamp: Int, suiteStampA: List[Int], suiteStampB: List[Int], testStamp: Int, ordinal: Int) =&gt;
            (suiteStampA != suiteStampB &amp;&amp; !suiteStampA.isEmpty &amp;&amp; !suiteStampB.isEmpty) ==&gt; {
              val length = if (suiteStampA.length &gt; suiteStampB.length) suiteStampB.length else suiteStampA.length
              val properLengthA = if (suiteStampA.length != length) suiteStampA take length else suiteStampA
              val properLengthB = if (suiteStampB.length != length) suiteStampB take length else suiteStampB
              val unequalA = if (properLengthA == properLengthB) (properLengthA.head + 1) :: properLengthB.tail else properLengthA
              val unsorted =
                List(
                  TestStarting(&quot;X - test&quot;, &quot;X&quot;, Some(&quot;com.acme.X&quot;), &quot;test&quot;, runStamp, unequalA, testStamp, ordinal),
                  TestStarting(&quot;Y - test&quot;, &quot;Y&quot;, Some(&quot;com.acme.Y&quot;), &quot;test&quot;, runStamp, properLengthB, testStamp, ordinal)
                )
              val sorted = unsorted.sort(_ &lt; _)
              val first = sorted.head.suiteStamp.get.reverse
              val second = sorted.tail.head.suiteStamp.get.reverse
              val zipped = first zip second
              val unequalPair = zipped find (pair =&gt; pair._1 != pair._2)
              unequalPair match {
                case Some((firstElement, secondElement)) =&gt; firstElement &lt; secondElement
                case None =&gt; fail() // should never happen
              }
            }
        )
      }
    }

    describe(&quot;(with same runStamps, suiteStamps, but different ordinals)&quot;) {
      it(&quot;should sort into order by ordinal&quot;) {
        check(
          (runStamp: Int, suiteStamp: List[Int], testStamp: Int, ordinalA: Int, ordinalB: Int) =&gt;
            (ordinalA != ordinalB) ==&gt; {
              val length = if (suiteStampA.length &gt; suiteStampB.length) suiteStampB.length else suiteStampA.length
              val properLengthA = if (suiteStampA.length != length) suiteStampA take length else suiteStampA
              val properLengthB = if (suiteStampB.length != length) suiteStampB take length else suiteStampB
              val unequalA = if (properLengthA == properLengthB) (properLengthA.head + 1) :: properLengthB.tail else properLengthA
              val unsorted =
                List(
                  TestStarting(&quot;X - test&quot;, &quot;X&quot;, Some(&quot;com.acme.X&quot;), &quot;test&quot;, runStamp, unequalA, testStamp, ordinal),
                  TestStarting(&quot;Y - test&quot;, &quot;Y&quot;, Some(&quot;com.acme.Y&quot;), &quot;test&quot;, runStamp, properLengthB, testStamp, ordinal)
                )
              val sorted = unsorted.sort(_ &lt; _)
              val first = sorted.head.suiteStamp.get.reverse
              val second = sorted.tail.head.suiteStamp.get.reverse
              val zipped = first zip second
              val unequalPair = zipped find (pair =&gt; pair._1 != pair._2)
              unequalPair match {
                case Some((firstElement, secondElement)) =&gt; firstElement &lt; secondElement
                case None =&gt; fail() // should never happen
              }
            }
        )
      }
    }
  }
*/</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>